// Generated by CoffeeScript 2.7.0
// Requires
var CSON, arg, argv, bin, conversion, create, data, exit, fs, hasData, help, input, invalidArg, node, opts, output, parse, processData, result, stderr, stdin, stdout, timeout, timeoutFunction;

fs = require('fs');

CSON = require('./index.js');

({stdin, stdout, stderr, argv, exit} = process);

// Helpers
help = function(message = '') {
  stderr.write(`CSON CLI

USAGE

cson [...options] <input> <output>

# json to cson, to stdout
cson in.json

# json to cson, to file
cson in.cson out.cson

# cson to json, to stdout
cson in.cson

# cson to json, to file
cson in.cson out.json

# explicit conversion to support ambigious extension and stdin

json2cson in.data out.data
json2cson in.data > out.data
cat in.data | json2cson --stdin out.data

cson --json2cson in.data out.data
cson --json2cson in.data > out.data
cat in.data | cson --json2cson --stdin out.data

cson --cson2json in.data out.data
cson --cson2json in.data > out.data
cat in.data | cson --cson2json --stdin out.data

cson2json in.data out.data
cson2json in.data > out.data
cat in.data | cson2json --stdin out.data

OPTIONS

--help
    Display this help.

--tabs
--2spaces
--4spaces
    Adjust output indentation.`);
  if (message) {
    stderr.write(`\n\nERROR:\n${message}\n`);
  }
  return exit(22);
};

invalidArg = function(arg) {
  return help(`Invalid argument: ${arg}`);
};

// prepare
conversion = '';

input = '';

output = '';

opts = {};

// parse
node = argv.shift();

bin = argv.shift();

if (bin.includes('json2cson')) {
  conversion = 'json2cson';
} else if (bin.includes('cson2json')) {
  conversion = 'cson2json';
}

while (argv.length) {
  arg = argv.shift();
  switch (arg) {
    case '--help':
      help();
      break;
    case '--json2cson':
      conversion = 'json2cson';
      break;
    case '--cson2json':
      conversion = 'cson2json';
      break;
    case '--stdin':
      input = '/dev/stdin';
      break;
    case '--tabs':
      opts.indent = '\t';
      break;
    case '--2spaces':
      opts.indent = '  ';
      break;
    case '--4spaces':
      opts.indent = '    ';
      break;
    default:
      if (!input) {
        input = arg;
      } else if (!output) {
        output = arg;
      } else {
        return invalidArg(arg);
      }
  }
}

if (!conversion) {
  if (input.endsWith('.json') || output.endsWith('.cson')) {
    conversion = 'json2cson';
  } else if (input.endsWith('.cson') || output.endsWith('.json')) {
    conversion = 'cson2json';
  } else {
    return help(`Unable to determine conversion from input/output file extensions. You must provide either --json2cson or --cson2json.\n${node} ${bin} ${input} ${output}}`);
  }
}

// convert input
if (input && input !== '/dev/stdin') {
  // prepare file conversion
  if (conversion === 'cson2json') {
    parse = CSON.parseCSONFile.bind(CSON);
    create = CSON.createJSONString.bind(CSON);
  } else {
    parse = CSON.parseJSONFile.bind(CSON);
    create = CSON.createCSONString.bind(CSON);
  }
  // convert
  result = parse(input);
  if (result instanceof Error) {
    throw result;
  }
  result = create(result, opts);
  if (result instanceof Error) {
    throw result;
  }
  // output
  if (output) {
    fs.writeFileSync(output, result);
  } else {
    stdout.write(result);
  }
} else {
  // convert stdin
  data = '';
  hasData = function() {
    return data.replace(/\s+/, '').length !== 0;
  };
  processData = function() {
    // prepare string conversion
    if (conversion === 'cson2json') {
      parse = CSON.parseCSONString.bind(CSON);
      create = CSON.createJSONString.bind(CSON);
    } else {
      parse = CSON.parseJSONString.bind(CSON);
      create = CSON.createCSONString.bind(CSON);
    }
    // convert
    result = parse(data);
    if (result instanceof Error) {
      throw result;
    }
    result = create(result, opts);
    if (result instanceof Error) {
      throw result;
    }
    // output
    if (output) {
      return fs.writeFileSync(output, result);
    } else {
      return stdout.write(result);
    }
  };
  // timeout if we don't have stdin
  timeoutFunction = function() {
    var timeout;
    // clear timeout
    clearTimeout(timeout);
    timeout = null;
    // if we didn't detect output, then fail
    if (hasData() === false) {
      stdin.pause();
      return help('No STDIN data received...');
    }
  };
  timeout = setTimeout(timeoutFunction, 1000);
  // read stdin
  stdin = stdin;
  stdin.setEncoding('utf8');
  stdin.resume(); // node 0.8
  stdin.on('data', function(_data) {
    return data += _data.toString();
  });
  stdin.on('end', function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
    return processData();
  });
}
