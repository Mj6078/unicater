/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/js/PageManager.js":
/*!**********************************!*\
  !*** ./assets/js/PageManager.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PageManager)
/* harmony export */ });
var PageManager = /*#__PURE__*/function () {
  function PageManager() {}
  var _proto = PageManager.prototype;
  _proto.before = function before(next) {
    next();
  };
  _proto.loaded = function loaded(next) {
    next();
  };
  _proto.after = function after(next) {
    next();
  };
  _proto.type = function type() {
    return this.constructor.name;
  };
  return PageManager;
}();


/***/ }),

/***/ "./assets/js/theme/404-error.js":
/*!**************************************!*\
  !*** ./assets/js/theme/404-error.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Errors404)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Errors404 = /*#__PURE__*/function (_PageManager) {
  function Errors404() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Errors404, _PageManager);
  return Errors404;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/AmpProduct.js":
/*!***************************************!*\
  !*** ./assets/js/theme/AmpProduct.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AmpProduct)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _core_amp_AmpProductUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/amp/AmpProductUtils */ "./assets/js/theme/core/amp/AmpProductUtils.js");
/* harmony import */ var _core_amp_AmpQuantityWidget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/amp/AmpQuantityWidget */ "./assets/js/theme/core/amp/AmpQuantityWidget.js");
/* harmony import */ var _core_formSelectedValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/formSelectedValue */ "./assets/js/theme/core/formSelectedValue.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }




var AmpProduct = /*#__PURE__*/function (_PageManager) {
  function AmpProduct(context) {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.el = '[data-product-container]';
    return _this;
  }
  _inheritsLoose(AmpProduct, _PageManager);
  var _proto = AmpProduct.prototype;
  _proto.loaded = function loaded() {
    (0,_core_formSelectedValue__WEBPACK_IMPORTED_MODULE_3__["default"])();

    // Qty Control
    new _core_amp_AmpQuantityWidget__WEBPACK_IMPORTED_MODULE_2__["default"]({
      scope: '[data-cart-item-add]'
    });
    this.ProductUtils = new _core_amp_AmpProductUtils__WEBPACK_IMPORTED_MODULE_1__["default"](this.el, {
      callbacks: {},
      template: 'products/add-to-cart-form'
    }).init(this.context);
  };
  return AmpProduct;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Auth.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Auth.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Auth)
/* harmony export */ });
/* harmony import */ var _core_Auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Auth */ "./assets/js/theme/core/Auth.js");
/* harmony import */ var _components_SelectWrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/SelectWrapper */ "./assets/js/theme/components/SelectWrapper.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


var Auth = /*#__PURE__*/function (_CoreAuth) {
  function Auth() {
    return _CoreAuth.apply(this, arguments) || this;
  }
  _inheritsLoose(Auth, _CoreAuth);
  var _proto = Auth.prototype;
  _proto.selectWrapCallback = function selectWrapCallback($selectEl) {
    new _components_SelectWrapper__WEBPACK_IMPORTED_MODULE_1__["default"]($selectEl);
  };
  return Auth;
}(_core_Auth__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Blog.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Blog.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Blog)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Blog = /*#__PURE__*/function (_PageManager) {
  function Blog() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Blog, _PageManager);
  return Blog;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Brand.js":
/*!**********************************!*\
  !*** ./assets/js/theme/Brand.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Brand)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global/FacetedSearch */ "./assets/js/theme/global/FacetedSearch.js");
/* harmony import */ var _global_initCompare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global/initCompare */ "./assets/js/theme/global/initCompare.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./global/svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* harmony import */ var _global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global/fillFacetRatingStars */ "./assets/js/theme/global/fillFacetRatingStars.js");
/* harmony import */ var _global_toggleFacet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global/toggleFacet */ "./assets/js/theme/global/toggleFacet.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }







var Brand = /*#__PURE__*/function (_PageManager) {
  function Brand() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.$body = $(document.body);
    if ($('[data-product-compare]').length) {
      (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.initCompare)();
    }
    _this._bindEvents();
    (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__["default"])();
    return _this;
  }
  _inheritsLoose(Brand, _PageManager);
  var _proto = Brand.prototype;
  _proto.loaded = function loaded(next) {
    this._initializeFacetedSearch(this.context.listingProductCount);
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$body.on('click', '[data-listing-view]', function (event) {
      _this2._toggleView(event);
    });
    this.$body.on('click', '[data-faceted-search-toggle]', function (event) {
      event.preventDefault();
      $(event.currentTarget).toggleClass('is-open').next().toggleClass('visible');
    });
  };
  _proto._initializeFacetedSearch = function _initializeFacetedSearch(productCount) {
    var loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_4__["default"])('spinner') + "</div>"
    };
    var facetedSearchOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_3__["default"](loadingOptions, false, '.product-listing');
    var facetedSearchOptions = {
      config: {
        brand: {
          shop_by_price: true,
          products: {
            limit: productCount
          }
        }
      },
      template: {
        productListing: 'brand/product-listing',
        sidebar: 'brand/sidebar'
      },
      scope: {
        productListing: '[data-brand]',
        sidebar: '[data-brand-sidebar]'
      },
      showMore: 'brand/show-more',
      toggleFacet: function toggleFacet(event) {
        return (0,_global_toggleFacet__WEBPACK_IMPORTED_MODULE_6__["default"])(event);
      },
      callbacks: {
        willUpdate: function willUpdate() {
          facetedSearchOverlay.show();
        },
        didUpdate: function didUpdate() {
          facetedSearchOverlay.hide();
          if ($('[data-product-compare]').length) {
            (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.updateCompare)();
          }
          (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__["default"])();
        }
      }
    };

    // Change teplate option if view mode theme setting is "list"
    if (this.context.listingViewMode === 'list') {
      facetedSearchOptions.template = {
        productListing: 'brand/product-listing-list',
        sidebar: 'brand/sidebar'
      };
    }
    this.FacetedSearch = new _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__["default"](facetedSearchOptions);
  };
  _proto._toggleView = function _toggleView(event) {
    var $target = $(event.currentTarget);
    var template = $target.data('listing-view') === 'grid' ? 'brand/product-listing' : 'brand/product-listing-list';
    var options = {
      template: {
        productListing: template
      }
    };

    // re-init faceted search with new template option
    this.FacetedSearch.init(options);

    // toggle button classes
    $target.addClass('active').siblings().removeClass('active');
  };
  return Brand;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Brands.js":
/*!***********************************!*\
  !*** ./assets/js/theme/Brands.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Brands)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Brands = /*#__PURE__*/function (_PageManager) {
  function Brands() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Brands, _PageManager);
  return Brands;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Cart.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Cart.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Cart)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _cart_CartUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cart/CartUtils */ "./assets/js/theme/cart/CartUtils.js");
/* harmony import */ var _cart_ShippingCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cart/ShippingCalculator */ "./assets/js/theme/cart/ShippingCalculator.js");
/* harmony import */ var _cart_CouponCodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cart/CouponCodes */ "./assets/js/theme/cart/CouponCodes.js");
/* harmony import */ var _cart_GiftCertificates__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cart/GiftCertificates */ "./assets/js/theme/cart/GiftCertificates.js");
/* harmony import */ var _cart_GiftWrapping__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cart/GiftWrapping */ "./assets/js/theme/cart/GiftWrapping.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var _components_QuantityWidget__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/QuantityWidget */ "./assets/js/theme/components/QuantityWidget.js");
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./global/svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* harmony import */ var _cart_EditOptions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cart/EditOptions */ "./assets/js/theme/cart/EditOptions.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }











var Cart = /*#__PURE__*/function (_PageManager) {
  function Cart() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.$cartContent = $('[data-cart-content]');

    // brute-force apple-pay bodyclass in local environment
    if (window.ApplePaySession && $('.dev-environment').length) {
      $(document.body).addClass('apple-pay-supported');
    }
    return _this;
  }
  _inheritsLoose(Cart, _PageManager);
  var _proto = Cart.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    $('body').on('click', '.add-to-cart-button', function (event) {
      return _this2._addToCart(event);
    });
  };
  _proto.loaded = function loaded(next) {
    var context = this.context;
    new _components_QuantityWidget__WEBPACK_IMPORTED_MODULE_8__["default"]({
      scope: '[data-cart-content]'
    });
    var loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_9__["default"])('spinner') + "</div>"
    };
    new _cart_GiftWrapping__WEBPACK_IMPORTED_MODULE_6__["default"]({
      scope: '[data-cart-content]',
      context: context
    });
    var cartContentOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_7__["default"](loadingOptions, true, '.product-listing');
    var cartTotalsOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_7__["default"](loadingOptions, true, '[data-cart-totals]');
    this.ShippingCalculator = new _cart_ShippingCalculator__WEBPACK_IMPORTED_MODULE_3__["default"]('[data-shipping-calculator]', {
      context: context,
      visibleClass: 'visible',
      callbacks: {
        willUpdate: function willUpdate() {
          return cartTotalsOverlay.show();
        },
        didUpdate: function didUpdate() {
          return cartTotalsOverlay.hide();
        }
      }
    });
    this.CouponCodes = new _cart_CouponCodes__WEBPACK_IMPORTED_MODULE_4__["default"]('[data-coupon-codes]', {
      context: context,
      visibleClass: 'visible',
      callbacks: {
        willUpdate: function willUpdate() {
          return cartTotalsOverlay.show();
        },
        didUpdate: function didUpdate() {
          return cartTotalsOverlay.hide();
        }
      }
    });
    this.GiftCertificates = new _cart_GiftCertificates__WEBPACK_IMPORTED_MODULE_5__["default"]('[data-gift-certificates]', {
      context: context,
      visibleClass: 'visible',
      callbacks: {
        willUpdate: function willUpdate() {
          return cartTotalsOverlay.show();
        },
        didUpdate: function didUpdate() {
          return cartTotalsOverlay.hide();
        }
      }
    });
    this.CartUtils = new _cart_CartUtils__WEBPACK_IMPORTED_MODULE_2__["default"]({
      ShippingCalculator: this.ShippingCalculator,
      CouponCodes: this.CouponCodes,
      GiftCertificates: this.GiftCertificates
    }, {
      callbacks: {
        willUpdate: function willUpdate() {
          return cartContentOverlay.show();
        },
        didUpdate: function didUpdate() {
          return cartContentOverlay.hide();
        }
      }
    }).init();
    this.cartEditOptions = new _cart_EditOptions__WEBPACK_IMPORTED_MODULE_10__["default"](this.context, {
      willUpdate: function willUpdate() {
        return cartContentOverlay.show();
      },
      didUpdate: function didUpdate() {
        return cartContentOverlay.hide();
      }
    });
    next();
  };
  return Cart;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Category.js":
/*!*************************************!*\
  !*** ./assets/js/theme/Category.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Category)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global/FacetedSearch */ "./assets/js/theme/global/FacetedSearch.js");
/* harmony import */ var _global_initCompare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global/initCompare */ "./assets/js/theme/global/initCompare.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./global/svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* harmony import */ var _global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global/fillFacetRatingStars */ "./assets/js/theme/global/fillFacetRatingStars.js");
/* harmony import */ var _global_toggleFacet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global/toggleFacet */ "./assets/js/theme/global/toggleFacet.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }







var Category = /*#__PURE__*/function (_PageManager) {
  function Category() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.$body = $(document.body);
    if ($('[data-product-compare]').length) {
      (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.initCompare)();
    }
    _this._bindEvents();
    (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__["default"])();
    return _this;
  }
  _inheritsLoose(Category, _PageManager);
  var _proto = Category.prototype;
  _proto.loaded = function loaded(next) {
    this._initializeFacetedSearch(this.context.listingProductCount);
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$body.on('click', '[data-listing-view]', function (event) {
      _this2._toggleView(event);
    });
    this.$body.on('click', '[data-faceted-search-toggle]', function (event) {
      event.preventDefault();
      $(event.currentTarget).toggleClass('is-open').next().toggleClass('visible');
    });
  };
  _proto._initializeFacetedSearch = function _initializeFacetedSearch(productCount) {
    var loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_4__["default"])('spinner') + "</div>"
    };
    var facetedSearchOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_3__["default"](loadingOptions, false, '.product-listing');
    var facetedSearchOptions = {
      config: {
        category: {
          shop_by_price: true,
          products: {
            limit: productCount
          }
        }
      },
      toggleFacet: function toggleFacet(event) {
        return (0,_global_toggleFacet__WEBPACK_IMPORTED_MODULE_6__["default"])(event);
      },
      showMore: 'category/show-more',
      callbacks: {
        willUpdate: function willUpdate() {
          facetedSearchOverlay.show();
        },
        didUpdate: function didUpdate() {
          facetedSearchOverlay.hide();
          if ($('[data-product-compare]').length) {
            (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.updateCompare)();
          }
          (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__["default"])();
        }
      }
    };

    // Add teplate option if view mode theme setting is "list"
    if (this.context.listingViewMode === 'list') {
      facetedSearchOptions.template = {
        productListing: 'category/product-listing-list',
        sidebar: 'category/sidebar'
      };
    }
    this.FacetedSearch = new _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__["default"](facetedSearchOptions);
  };
  _proto._toggleView = function _toggleView(event) {
    var $target = $(event.currentTarget);
    var template = $target.data('listing-view') === 'grid' ? 'category/product-listing' : 'category/product-listing-list';
    var options = {
      template: {
        productListing: template
      }
    };

    // re-init faceted search with new template option
    this.FacetedSearch.init(options);

    // toggle button classes
    $target.addClass('active').siblings().removeClass('active');

    // TODO - possibly add this back after testing in live environ
    // if (typeof(Storage) !== 'undefined') {
    //   localStorage.setItem('listingView', $target.data('listing-view'));
    // }
  };
  return Category;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Compare.js":
/*!************************************!*\
  !*** ./assets/js/theme/Compare.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Compare)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Compare = /*#__PURE__*/function (_PageManager) {
  function Compare() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Compare, _PageManager);
  return Compare;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/ContactUs.js":
/*!**************************************!*\
  !*** ./assets/js/theme/ContactUs.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContactUs)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var ContactUs = /*#__PURE__*/function (_PageManager) {
  function ContactUs() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(ContactUs, _PageManager);
  return ContactUs;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Errors.js":
/*!***********************************!*\
  !*** ./assets/js/theme/Errors.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Errors)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Errors = /*#__PURE__*/function (_PageManager) {
  function Errors() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Errors, _PageManager);
  return Errors;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Global.js":
/*!***********************************!*\
  !*** ./assets/js/theme/Global.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Global)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var bc_scroll_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bc-scroll-link */ "./node_modules/bc-scroll-link/dist/scroll-link.js");
/* harmony import */ var _utils_FormValidator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/FormValidator */ "./assets/js/theme/utils/FormValidator.js");
/* harmony import */ var _global_Dropdown__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./global/Dropdown */ "./assets/js/theme/global/Dropdown.js");
/* harmony import */ var _global_Header__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./global/Header */ "./assets/js/theme/global/Header.js");
/* harmony import */ var _global_quick_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global/quick-search */ "./assets/js/theme/global/quick-search.js");
/* harmony import */ var _global_MiniCart__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global/MiniCart */ "./assets/js/theme/global/MiniCart.js");
/* harmony import */ var _product_QuickShop__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./product/QuickShop */ "./assets/js/theme/product/QuickShop.js");
/* harmony import */ var _product_wishlistDropdown__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./product/wishlistDropdown */ "./assets/js/theme/product/wishlistDropdown.js");
/* harmony import */ var _global_MegaNav__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./global/MegaNav */ "./assets/js/theme/global/MegaNav.js");
/* harmony import */ var _global_MobileNav__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./global/MobileNav */ "./assets/js/theme/global/MobileNav.js");
/* harmony import */ var _core_selectOption__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/selectOption */ "./assets/js/theme/core/selectOption.js");
/* harmony import */ var _core_selectOption__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_core_selectOption__WEBPACK_IMPORTED_MODULE_11__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }





 // Import QuickSearch






var Global = /*#__PURE__*/function (_PageManager) {
  function Global() {
    var _this;
    _this = _PageManager.call(this) || this;
    new _global_Dropdown__WEBPACK_IMPORTED_MODULE_3__["default"]($('.dropdown'));
    new _global_Header__WEBPACK_IMPORTED_MODULE_4__["default"]($('.site-header'));
    new bc_scroll_link__WEBPACK_IMPORTED_MODULE_1__["default"]({
      selector: '.button-top'
    });
    new _global_MegaNav__WEBPACK_IMPORTED_MODULE_9__["default"]($('.mega-nav-variant-container'));
    new _global_MobileNav__WEBPACK_IMPORTED_MODULE_10__["default"]();
    new _global_MiniCart__WEBPACK_IMPORTED_MODULE_6__["default"]();
    new _product_wishlistDropdown__WEBPACK_IMPORTED_MODULE_8__["default"]();
    _this._toggleScrollLink();
    _this._initAnchors();
    _this._initializeQuickSearch(); // Initialize quick search
    return _this;
  }

  /**
   * You can wrap the execution in this method with an asynchronous function map using the async library
   * if your global modules need async callback handling.
   * @param next
   */
  _inheritsLoose(Global, _PageManager);
  var _proto = Global.prototype;
  _proto.loaded = function loaded(next) {
    // global form validation
    this.validator = new _utils_FormValidator__WEBPACK_IMPORTED_MODULE_2__["default"](this.context);
    this.validator.initGlobal();

    // QuickShop
    if ($('[data-quick-shop]').length) {
      new _product_QuickShop__WEBPACK_IMPORTED_MODULE_7__["default"](this.context);
    }
    next();
  };
  _proto._initAnchors = function _initAnchors() {
    var anchorSelector = '.cms-page [href^="#"]';
    $(anchorSelector).each(function (index, element) {
      var targetId = $(element).attr('href');
      var target = targetId.substring(1);
      $(element).attr('data-scroll', targetId);
      $("[name='" + target + "']").attr('id', target);
    });
    new bc_scroll_link__WEBPACK_IMPORTED_MODULE_1__["default"]({
      selector: anchorSelector,
      offset: -150
    });
  };
  _proto._toggleScrollLink = function _toggleScrollLink() {
    $(window).on('scroll', function (e) {
      var winScrollTop = $(e.currentTarget).scrollTop();
      var winHeight = $(window).height();
      if (winScrollTop > winHeight) {
        $('.button-top').addClass('show');
      } else {
        $('.button-top').removeClass('show');
      }
    });
  };
  _proto._initializeQuickSearch = function _initializeQuickSearch() {
    new _global_quick_search__WEBPACK_IMPORTED_MODULE_5__["default"](); // Initialize quick search
  };
  return Global;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Home.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Home.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Home)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _product_ProductUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./product/ProductUtils */ "./assets/js/theme/product/ProductUtils.js");
/* harmony import */ var bc_tabs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bc-tabs */ "./node_modules/bc-tabs/dist/tabs.js");
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! slick-carousel */ "./node_modules/slick-carousel/slick/slick.js");
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(slick_carousel__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_4__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }





var Home = /*#__PURE__*/function (_PageManager) {
  function Home() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Home, _PageManager);
  var _proto = Home.prototype;
  _proto.loaded = function loaded(next) {
    this._initSlick();
    this._initTabs();
    next();
  };
  _proto._initTabs = function _initTabs() {
    this.tabs = new bc_tabs__WEBPACK_IMPORTED_MODULE_2__["default"]({
      afterSetup: function afterSetup() {
        $('.product-carousel').slick('setPosition');
      },
      afterChange: function afterChange() {
        $('.product-carousel').slick('setPosition');
      }
    });
  };
  _proto._initSlick = function _initSlick() {
    // Hero carousel
    var $carousel = $('.carousel');
    var isNaturalAspectRatio = $carousel.hasClass('ratio-natural');
    var speed = $carousel.data('swap-frequency');
    $carousel.on('init', function (event, slick) {
      $('.slick-active .carousel-item-info:has(*)').addClass('show');
      // Fix misalignment because no scrollbar on load
      $(window).trigger('resize');
    }).slick({
      dots: true,
      fade: true,
      autoplay: true,
      autoplaySpeed: speed,
      lazyLoad: 'progressive',
      adaptiveHeight: true,
      prevArrow: '<span class="carousel-navigation-item previous"><svg class="icon icon-arrow-left"><use xlink:href="#icon-arrow-left" /></svg></span>',
      nextArrow: '<span class="carousel-navigation-item next"><svg class="icon icon-arrow-right"><use xlink:href="#icon-arrow-right" /></svg></span>'
    }).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
      $('.slick-active .carousel-item-info:has(*)').removeClass('show');
    }).on('afterChange', function (event, slick, currentSlide) {
      $('.slick-active .carousel-item-info:has(*)').addClass('show');
    });
    var settings = {
      infinite: true,
      slidesToShow: 4,
      slidesToScroll: 4,
      autoplaySpeed: 3000,
      // Autoplay speed in milliseconds (3 seconds)
      autoplay: true,
      // Enable autoplay
      lazyLoad: 'progressive',
      speed: 800,
      prevArrow: '<span class="carousel-navigation-item previous"><svg class="icon icon-arrow-left"><use xlink:href="#icon-arrow-left" /></svg></span>',
      nextArrow: '<span class="carousel-navigation-item next"><svg class="icon icon-arrow-right"><use xlink:href="#icon-arrow-right" /></svg></span>',
      responsive: [{
        breakpoint: 1024,
        settings: {
          slidesToShow: 3,
          slidesToScroll: 3,
          autoplay: false
        }
      }, {
        breakpoint: 768,
        settings: {
          slidesToShow: 2,
          slidesToScroll: 2,
          autoplay: true
        }
      }, {
        breakpoint: 480,
        settings: {
          slidesToShow: 2,
          slidesToScroll: 2,
          autoplay: true
        }
      }]
    };
    var $productCarousel = $('.product-carousel');
    $productCarousel.slick(settings);
    $(window).on('resize', function () {
      if ($(this).width() > 420 && !$productCarousel.hasClass('slick-initialized')) {
        $productCarousel.slick(settings);
      }
    });
  };
  return Home;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/OrderComplete.js":
/*!******************************************!*\
  !*** ./assets/js/theme/OrderComplete.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OrderComplete)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var OrderComplete = /*#__PURE__*/function (_PageManager) {
  function OrderComplete() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(OrderComplete, _PageManager);
  return OrderComplete;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Page.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Page.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Page)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Page = /*#__PURE__*/function (_PageManager) {
  function Page() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.createWrapperForTable();
    return _this;
  }
  _inheritsLoose(Page, _PageManager);
  var _proto = Page.prototype;
  _proto.createWrapperForTable = function createWrapperForTable() {
    $('table', '.page-content').each(function (index, table) {
      var $parent = $(table).parent();
      var $prevSibling = $(table).prev();
      var $div = $('<div/>').addClass('horizontal-scrollbar').append(table);
      if ($prevSibling.length) {
        $div.insertAfter($prevSibling);
      } else {
        $parent.prepend($div);
      }
    });
  };
  return Page;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Product.js":
/*!************************************!*\
  !*** ./assets/js/theme/Product.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Product)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _product_ProductUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./product/ProductUtils */ "./assets/js/theme/product/ProductUtils.js");
/* harmony import */ var _product_ProductImages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./product/ProductImages */ "./assets/js/theme/product/ProductImages.js");
/* harmony import */ var _product_ProductReviews__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./product/ProductReviews */ "./assets/js/theme/product/ProductReviews.js");
/* harmony import */ var _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./product/ColorSwatch */ "./assets/js/theme/product/ColorSwatch.js");
/* harmony import */ var _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./product/productViewTemplates */ "./assets/js/theme/product/productViewTemplates.js");
/* harmony import */ var _product_variationImgPreview__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./product/variationImgPreview */ "./assets/js/theme/product/variationImgPreview.js");
/* harmony import */ var bc_tabs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! bc-tabs */ "./node_modules/bc-tabs/dist/tabs.js");
/* harmony import */ var fitvids__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! fitvids */ "./node_modules/fitvids/index.js");
/* harmony import */ var fitvids__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(fitvids__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var bc_scroll_link__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! bc-scroll-link */ "./node_modules/bc-scroll-link/dist/scroll-link.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }











var Product = /*#__PURE__*/function (_PageManager) {
  function Product() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.el = '[data-product-container]';
    _this.$el = $(_this.el);
    _this.productImgs = '.product-slides-wrap';
    _this.fitVidsInitialized = false;
    new _components_Alert__WEBPACK_IMPORTED_MODULE_1__["default"]($('[data-alerts]'));
    new bc_scroll_link__WEBPACK_IMPORTED_MODULE_10__["default"]({
      selector: '.accordion-title a',
      offset: -117
    });
    new bc_scroll_link__WEBPACK_IMPORTED_MODULE_10__["default"]({
      selector: '.reviews-jumplink'
    });
    return _this;
  }
  _inheritsLoose(Product, _PageManager);
  var _proto = Product.prototype;
  _proto.loaded = function loaded(next) {
    // Product Utils
    this.ProductUtils = new _product_ProductUtils__WEBPACK_IMPORTED_MODULE_2__["default"](this.el, {
      priceWithoutTaxTemplate: _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__["default"].priceWithoutTax,
      priceWithTaxTemplate: _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__["default"].priceWithTax,
      priceSavedTemplate: _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__["default"].priceSaved,
      variationPreviewImageTemplate: _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__["default"].variationPreviewImage,
      callbacks: {
        switchImage: _product_variationImgPreview__WEBPACK_IMPORTED_MODULE_7__["default"]
      }
    }).init(this.context);

    // Product Images
    new _product_ProductImages__WEBPACK_IMPORTED_MODULE_3__["default"](this.productImgs);

    // Product Swatches
    this.swatches = new _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_5__["default"](); // Init our color swatches

    // Reviews
    new _product_ProductReviews__WEBPACK_IMPORTED_MODULE_4__["default"](this.context);

    // Product UI
    this._bindEvents();
    this._initTabs();
    this._initSlick();
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    // Activate the reviews tab when we jump down to it
    $('.product-reviews-link').on('click', function () {
      _this2.tabs.activateTab('#product-reviews');
      $('.accordion-title').removeClass('is-open');
      $('[href="#product-reviews"]').parent('.accordion-title').addClass('is-open');
    });

    // Show all the reviews
    $('.reviews-show-more-link').on('click', function (event) {
      event.preventDefault();
      $('.review-item.hidden').each(function (index, el) {
        setTimeout(function () {
          $(el).revealer('show');
        }, index * 250);
      });
      $(event.currentTarget).hide();
    });
    $('.accordion-title').on('click', function (event) {
      event.preventDefault();
      _this2._accordionTabToggle(event);
    });
  };
  _proto._initTabs = function _initTabs() {
    var _this3 = this;
    if ($('[data-tab-link]').length) {
      this.tabs = new bc_tabs__WEBPACK_IMPORTED_MODULE_8__["default"]({
        afterSetup: function afterSetup(tabId) {
          _this3._initVids(tabId);
          $('.tab-content-panel.active').prev('.accordion-title').addClass('is-open');
        },
        afterChange: function afterChange(tabId) {
          _this3._initVids(tabId);
        },
        keepTabsOpen: function keepTabsOpen() {
          return false;
        }
      });
    } else {
      $('.product-tabs').css('display', 'none');
    }
  }

  // Add accordion style buttons to toggle tab panels
  ;
  _proto._accordionTabToggle = function _accordionTabToggle(event) {
    var tab = $(event.currentTarget).find('a').attr('href');
    $(event.currentTarget).addClass('is-open').siblings('.accordion-title').removeClass('is-open');
    this.tabs.displayTabContent(tab);
  }

  // if page loads with tabs hidden, we need to wait until the proper tab is clicked before running fitVids.
  ;
  _proto._initVids = function _initVids(tabId) {
    if (tabId == '#product-videos' && !this.fitVidsInitialized) {
      fitvids__WEBPACK_IMPORTED_MODULE_9___default()('.product-videos-list');
      this.fitVidsInitialized = true;
    }
  };
  _proto._initSlick = function _initSlick() {
    // Related Product carousels
    $('.product-carousel').slick({
      infinite: true,
      slidesToShow: 4,
      slidesToScroll: 4,
      autoplaySpeed: 4000,
      speed: 800,
      prevArrow: '<span class="carousel-navigation-item previous"><svg class="icon icon-arrow-left"><use xlink:href="#icon-arrow-left" /></svg></span>',
      nextArrow: '<span class="carousel-navigation-item next"><svg class="icon icon-arrow-right"><use xlink:href="#icon-arrow-right" /></svg></span>',
      responsive: [{
        breakpoint: 1024,
        settings: {
          slidesToShow: 3,
          slidesToScroll: 3,
          autoplay: false
        }
      }, {
        breakpoint: 768,
        settings: {
          slidesToShow: 2,
          slidesToScroll: 2,
          autoplay: true
        }
      }, {
        breakpoint: 480,
        settings: {
          slidesToShow: 1,
          slidesToScroll: 1,
          autoplay: true
        }
      }]
    });
  };
  return Product;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Search.js":
/*!***********************************!*\
  !*** ./assets/js/theme/Search.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Search)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global/FacetedSearch */ "./assets/js/theme/global/FacetedSearch.js");
/* harmony import */ var _global_initCompare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global/initCompare */ "./assets/js/theme/global/initCompare.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var bc_tabs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bc-tabs */ "./node_modules/bc-tabs/dist/tabs.js");
/* harmony import */ var _global_MiniCart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global/MiniCart */ "./assets/js/theme/global/MiniCart.js");
/* harmony import */ var _global_quick_search__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global/quick-search */ "./assets/js/theme/global/quick-search.js");
/* harmony import */ var _global_Dropdown__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./global/Dropdown */ "./assets/js/theme/global/Dropdown.js");
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./global/svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* harmony import */ var _global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./global/fillFacetRatingStars */ "./assets/js/theme/global/fillFacetRatingStars.js");
/* harmony import */ var _global_toggleFacet__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./global/toggleFacet */ "./assets/js/theme/global/toggleFacet.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }






 // Import QuickSearch




var Search = /*#__PURE__*/function (_PageManager) {
  function Search() {
    var _this;
    _this = _PageManager.call(this) || this;
    new _global_Dropdown__WEBPACK_IMPORTED_MODULE_7__["default"]($('.dropdown'));
    new _global_MiniCart__WEBPACK_IMPORTED_MODULE_5__["default"]();
    _this.$body = $(document.body);
    if ($('[data-product-compare]').length) {
      (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.initCompare)();
    }
    _this._bindEvents();
    _this._initTabs();
    _this._initializeQuickSearch();
    (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_9__["default"])();
    return _this;
  }
  _inheritsLoose(Search, _PageManager);
  var _proto = Search.prototype;
  _proto.loaded = function loaded(next) {
    this._initializeFacetedSearch(this.context.listingProductCount);
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$body.on('click', '[data-listing-view]', function (event) {
      _this2._toggleView(event);
    });
    this.$body.on('click', '[data-faceted-search-toggle]', function (event) {
      event.preventDefault();
      $(event.currentTarget).toggleClass('is-open').next().toggleClass('visible');
    });
  };
  _proto._initTabs = function _initTabs() {
    this.tabs = new bc_tabs__WEBPACK_IMPORTED_MODULE_4__["default"]({
      afterChange: function afterChange() {},
      keepTabsOpen: function keepTabsOpen() {}
    });
    if (!$('#product-results .product-block').length || window.location.search.indexOf('section=content') > -1) {
      this.tabs.displayTabContent('#content-results');
    }
  };
  _proto._initializeQuickSearch = function _initializeQuickSearch() {
    new _global_quick_search__WEBPACK_IMPORTED_MODULE_6__["default"](); // Initialize quick search
  };
  _proto._initializeFacetedSearch = function _initializeFacetedSearch(productCount) {
    var loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_8__["default"])('spinner') + "</div>"
    };
    var facetedSearchOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_3__["default"](loadingOptions, false, '.product-listing');
    var facetedSearchOptions = {
      config: {
        product_results: {
          limit: productCount
        }
      },
      template: {
        productListing: 'search/product-listing',
        sidebar: 'search/sidebar'
      },
      scope: {
        productListing: '[data-search]',
        sidebar: '[data-search-sidebar]'
      },
      toggleFacet: function toggleFacet(event) {
        return (0,_global_toggleFacet__WEBPACK_IMPORTED_MODULE_10__["default"])(event);
      },
      showMore: 'search/show-more',
      callbacks: {
        willUpdate: function willUpdate() {
          facetedSearchOverlay.show();
        },
        didUpdate: function didUpdate() {
          facetedSearchOverlay.hide();
          if ($('[data-product-compare]').length) {
            (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.updateCompare)();
          }
          (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_9__["default"])();
        }
      }
    };
    if (this.context.listingViewMode === 'list') {
      facetedSearchOptions.template = {
        productListing: 'search/product-listing-list',
        sidebar: 'search/sidebar'
      };
    }
    this.FacetedSearch = new _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__["default"](facetedSearchOptions);
  };
  _proto._toggleView = function _toggleView(event) {
    var $target = $(event.currentTarget);
    var template = $target.data('listing-view') === 'grid' ? 'search/product-listing' : 'search/product-listing-list';
    var options = {
      template: {
        productListing: template
      }
    };
    this.FacetedSearch.init(options);
    $target.addClass('active').siblings().removeClass('active');
  };
  return Search;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Sitemap.js":
/*!************************************!*\
  !*** ./assets/js/theme/Sitemap.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SiteMap)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var SiteMap = /*#__PURE__*/function (_PageManager) {
  function SiteMap() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(SiteMap, _PageManager);
  return SiteMap;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Subscribe.js":
/*!**************************************!*\
  !*** ./assets/js/theme/Subscribe.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Subscribe)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Subscribe = /*#__PURE__*/function (_PageManager) {
  function Subscribe() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Subscribe, _PageManager);
  return Subscribe;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Wishlist.js":
/*!*************************************!*\
  !*** ./assets/js/theme/Wishlist.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WishList)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _utils_pagination_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/pagination-utils */ "./assets/js/theme/utils/pagination-utils.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


var WishList = /*#__PURE__*/function (_PageManager) {
  function WishList() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.onReady();
    return _this;
  }
  _inheritsLoose(WishList, _PageManager);
  var _proto = WishList.prototype;
  _proto.onReady = function onReady() {
    if ($('[data-pagination-wishlist]').length) {
      (0,_utils_pagination_utils__WEBPACK_IMPORTED_MODULE_1__.wishlistPaginationHelper)();
    }
  };
  return WishList;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/cart/CartUtils.js":
/*!*******************************************!*\
  !*** ./assets/js/theme/cart/CartUtils.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CartUtils)
/* harmony export */ });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_bind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/bind */ "./node_modules/lodash/bind.js");
/* harmony import */ var lodash_bind__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_bind__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _refreshContent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./refreshContent */ "./assets/js/theme/cart/refreshContent.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");





var CartUtils = /*#__PURE__*/function () {
  function CartUtils(modules, options) {
    this.modules = modules;
    this.$cartContent = $('[data-cart-content]');
    this.$addToCart = $('[data-button-purchase]'); // Initialize $addToCart
    this.quantityInput = '[data-quantity-control-input]';
    this.cartAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_3__["default"]($('[data-alerts]'));
    this.cartPromos = $('[data-cart-promos]');
    this.productData = {};
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, options.callbacks);
  }
  var _proto = CartUtils.prototype;
  _proto.init = function init() {
    this._cacheInitialQuantities();
    this._bindEvents();
  };
  _proto._addToCart = function _addToCart(event) {
    var _this = this;
    event.preventDefault();
    var $target = $(event.currentTarget);
    var $form = $target.closest('form');
    var formData = $form.serialize();
    console.log('Form data being sent to API:', formData); // Debug line

    this.callbacks.willUpdate();

    // Use the BigCommerce Stencil utility to add the item to the cart
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__["default"].api.cart.itemAdd(formData, function (err, response) {
      if (response && response.data && response.data.status === 'succeed') {
        (0,_refreshContent__WEBPACK_IMPORTED_MODULE_4__["default"])(_this.callbacks.didUpdate, true);
      } else {
        var errorMessage = response.data.errors.join('\n') || "Unfortunately, this product is not available for purchase.";
        _this.cartAlerts.error(errorMessage, true);
        _this.callbacks.didUpdate();
      }
    });
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$cartContent.on('change', this.quantityInput, lodash_bind__WEBPACK_IMPORTED_MODULE_1___default()(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(this._updateCartItem, 750), this));

    // Attach event handler for add-to-cart buttons
    $('body').on('click', '[data-button-purchase]', function (event) {
      return _this2._addToCart(event);
    });
    this.$cartContent.on('change', '[data-quantity-control-input]', function (evt) {
      var $target = $(evt.target);
      var itemId = $target.closest('[data-quantity-control]').data('quantity-control');
      _this2.productData[itemId].quantityAltered = true;
      _this2.productData[itemId].newQuantity = parseInt($target.val(), 10);
    });
    this.$cartContent.on('click', '[data-cart-item-remove]', function (event) {
      event.preventDefault();
      _this2._removeCartItem(event);
    });
    $('body').on('click', '.mini-cart [data-cart-item-remove]', function () {
      _this2.callbacks.willUpdate();
    });
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__["default"].hooks.on('cart-item-remove-remote', function () {
      (0,_refreshContent__WEBPACK_IMPORTED_MODULE_4__["default"])(_this2.callbacks.didUpdate, true);
    });

    // Ensure the CartUtils is initialized after document is ready
    $(document).ready(function () {
      var cartUtils = new CartUtils();
      cartUtils.init();
    });
  };
  _proto._cacheInitialQuantities = function _cacheInitialQuantities() {
    var _this3 = this;
    $('[data-cart-item]').each(function (i, el) {
      var $cartItem = $(el);
      var itemId = $cartItem.data('item-id');
      _this3.productData[itemId] = {
        oldQuantity: parseInt($cartItem.find('[data-quantity-control-input]').attr('value'), 10),
        quantityAltered: false
      };
    });
  };
  _proto._updateCartItem = function _updateCartItem(event) {
    var _this4 = this;
    var $target = $(event.currentTarget);
    var $cartItem = $target.closest('[data-cart-item]');
    var itemId = $cartItem.data('item-id');
    this.callbacks.willUpdate();
    if (this.productData[itemId].quantityAltered) {
      var $quantityInput = $cartItem.find('[data-cart-item-quantity-input]');
      var newQuantity = this.productData[itemId].newQuantity;
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__["default"].api.cart.itemUpdate(itemId, newQuantity, function (err, response) {
        if (response.data.status === 'succeed') {
          var remove = newQuantity === 0;
          _this4.productData[itemId].oldQuantity = newQuantity;
          (0,_refreshContent__WEBPACK_IMPORTED_MODULE_4__["default"])(_this4.callbacks.didUpdate, remove);
        } else {
          $quantityInput.val(_this4.productData[itemId].oldQuantity);
          _this4.cartAlerts.error(response.data.errors.join('\n'), true);
          _this4.callbacks.didUpdate();
        }

        // this.cartPromos.empty();
      });
    }
  };
  _proto._removeCartItem = function _removeCartItem(event) {
    var _this5 = this;
    var itemId = $(event.currentTarget).closest('[data-cart-item]').data('item-id');
    this.callbacks.willUpdate();
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__["default"].api.cart.itemRemove(itemId, function (err, response) {
      if (response.data.status === 'succeed') {
        (0,_refreshContent__WEBPACK_IMPORTED_MODULE_4__["default"])(_this5.callbacks.didUpdate, true);
      } else {
        _this5.cartAlerts.error(response.data.errors.join('\n'), true);
        _this5.callbacks.didUpdate();
      }
    });
  };
  return CartUtils;
}();


/***/ }),

/***/ "./assets/js/theme/cart/CouponCodes.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/cart/CouponCodes.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CouponCodes)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _refreshContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./refreshContent */ "./assets/js/theme/cart/refreshContent.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");



var CouponCodes = /*#__PURE__*/function () {
  function CouponCodes(el, options) {
    this.$el = $(el);
    this.couponAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_1__["default"]($('[data-alerts]'));
    this.options = $.extend({
      context: {},
      $scope: $('[data-cart-totals]'),
      visibleClass: 'visible'
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = CouponCodes.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.options.$scope.on('submit', '[data-coupon-code-form]', function (event) {
      event.preventDefault();
      _this._addCode();
    });
  };
  _proto._addCode = function _addCode() {
    var _this2 = this;
    var $input = $('[data-coupon-code-input]', this.options.$scope);
    var code = $input.val();
    this.couponAlerts.clear();
    this.callbacks.willUpdate();
    if (!code) {
      this.couponAlerts.error(this.options.context.couponCodeEmptyInput, true);
      return this.callbacks.didUpdate();
    }
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.applyCode(code, function (err, response) {
      if (response.data.status === 'success') {
        (0,_refreshContent__WEBPACK_IMPORTED_MODULE_2__["default"])(_this2.callbacks.didUpdate);
      } else {
        _this2.couponAlerts.error(response.data.errors.join('\n'), true);
        _this2.callbacks.didUpdate();
      }
    });
  };
  return CouponCodes;
}();


/***/ }),

/***/ "./assets/js/theme/cart/EditOptions.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/cart/EditOptions.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CartEditOptions)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var bc_modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bc-modal */ "./node_modules/bc-modal/dist/js/modal.js");
/* harmony import */ var _product_AttributesHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../product/AttributesHelper */ "./assets/js/theme/product/AttributesHelper.js");
/* harmony import */ var _components_SelectWrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/SelectWrapper */ "./assets/js/theme/components/SelectWrapper.js");
/* harmony import */ var _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../product/ColorSwatch */ "./assets/js/theme/product/ColorSwatch.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");





var CartEditOptions = /*#__PURE__*/function () {
  function CartEditOptions(context, callbacks) {
    var _this = this;
    this.context = context;
    this.el = '<div id="cart-options-modal">';
    this.id = null;
    this.cartOptionsModal = new bc_modal__WEBPACK_IMPORTED_MODULE_1__["default"]({
      el: this.el,
      modalClass: 'cart-options-modal',
      afterShow: function afterShow($modal) {
        _this._fetchProduct($modal, _this.id);
      }
    });
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, callbacks);

    // Abstracted attributes functionality
    this.attributesHelper = new _product_AttributesHelper__WEBPACK_IMPORTED_MODULE_2__["default"]('#CartEditProductFieldsForm');
    this._bindEvents();
  }
  var _proto = CartEditOptions.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    $('body').on('click', '[data-item-edit]', function (event) {
      event.preventDefault();
      _this2.id = $(event.currentTarget).data('item-edit');
      if (!_this2.id) {
        return;
      }
      _this2.cartOptionsModal.open();
    });
    $('body').on('submit', '#CartEditProductFieldsForm', function () {
      _this2.callbacks.willUpdate();
    });
  }

  /**
   * Run ajax fetch of product and add to modal. Bind product functionality and show the modal
   * @param {jQuery} $modal - the root (appended) modal element.
   * @param {string} $itemId - product id
   */;
  _proto._fetchProduct = function _fetchProduct($modal, $itemID) {
    var _this3 = this;
    var options = {
      template: 'cart/edit-options'
    };
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.productAttributes.configureInCart($itemID, options, function (err, response) {
      $modal.find('.modal-content').append(response.content).find('.cart-edit-options').addClass('cart-edit-options-visible');
      _this3.cartOptionsModal.position();
      $modal.addClass('loaded');
      var $select = $modal.find('select');
      if ($select.length) {
        $select.each(function (i, el) {
          new _components_SelectWrapper__WEBPACK_IMPORTED_MODULE_3__["default"](el);
        });
      }
      _this3.swatches = new _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_4__["default"](); // Init our color swatches

      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.on('product-option-change', function (event, option) {
        _this3.callbacks.willUpdate();
        var $changedOption = $(option);
        var $form = $('#CartEditProductFieldsForm');
        var $submit = $('input[type="submit"]', $form);
        var $messageBox = $('[data-reconfigure-errors]');
        var item = $('[name="item_id"]', $form).attr('value');
        _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.productAttributes.optionChange(item, $form.serialize(), 'cart/edit-options', function (err, result) {
          var data = result.data || {};
          _this3.attributesHelper.updateAttributes(data);
          if (data.purchasing_message) {
            $($messageBox).html(data.purchasing_message);
            $submit.prop('disabled', true);
            $messageBox.show();
          } else {
            $submit.prop('disabled', false);
            $messageBox.hide();
          }
          if (!data.purchasable || !data.instock) {
            $submit.prop('disabled', true);
          } else {
            $submit.prop('disabled', false);
          }
          _this3.callbacks.didUpdate();
        });
      });
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.emit('product-option-change');
    });
  };
  return CartEditOptions;
}();


/***/ }),

/***/ "./assets/js/theme/cart/GiftCertificates.js":
/*!**************************************************!*\
  !*** ./assets/js/theme/cart/GiftCertificates.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GiftCertificates)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _refreshContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./refreshContent */ "./assets/js/theme/cart/refreshContent.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");



var GiftCertificates = /*#__PURE__*/function () {
  function GiftCertificates(el, options) {
    this.$el = $(el);
    this.certificateAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_1__["default"]($('[data-alerts]'));
    this.options = $.extend({
      context: {},
      $scope: $('[data-cart-totals]'),
      visibleClass: 'visible'
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = GiftCertificates.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.options.$scope.on('click', '[data-gift-certificate-toggle]', function (event) {
      event.preventDefault();
      _this._toggle();
    });
    this.options.$scope.on('submit', '[data-gift-certificate-form]', function (event) {
      event.preventDefault();
      _this._addCode();
    });
  };
  _proto._toggle = function _toggle() {
    $('[data-gift-certificate-form]', this.options.$scope).toggleClass(this.options.visibleClass);
  };
  _proto._addCode = function _addCode() {
    var _this2 = this;
    var $input = $('[data-gift-certificate-input]', this.options.$scope);
    var code = $input.val();
    this.callbacks.willUpdate();
    if (!this._isValidCode(code)) {
      this.certificateAlerts.error(this.options.context.giftCertificateInputEmpty, true);
      return this.callbacks.didUpdate();
    }
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.applyGiftCertificate(code, function (err, response) {
      if (response.data.status === 'success') {
        (0,_refreshContent__WEBPACK_IMPORTED_MODULE_2__["default"])(_this2.callbacks.didUpdate);
      } else {
        _this2.certificateAlerts.error(response.data.errors.join('\n'), true);
        _this2.callbacks.didUpdate();
      }
    });
  };
  _proto._isValidCode = function _isValidCode(code) {
    if (typeof code !== 'string') {
      return false;
    }
    return true;
  };
  return GiftCertificates;
}();


/***/ }),

/***/ "./assets/js/theme/cart/GiftWrapping.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/cart/GiftWrapping.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GiftWrapping)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var bc_modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bc-modal */ "./node_modules/bc-modal/dist/js/modal.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var GiftWrapping = /*#__PURE__*/function () {
  function GiftWrapping(options) {
    if (options === void 0) {
      options = {};
    }
    this.options = $.extend({
      scope: '[data-cart-content]',
      trigger: '[data-item-giftwrap]',
      remove: '[data-giftwrap-remove]'
    }, options);
    this.$cartContent = $(this.options.scope);
    this.context = options.context;
    this._initialize();
  }
  var _proto = GiftWrapping.prototype;
  _proto._initialize = function _initialize() {
    var _this = this;
    this.itemId; // later assigned the id of the current product

    this.GiftWrapModal = new bc_modal__WEBPACK_IMPORTED_MODULE_1__["default"]({
      modalClass: 'giftwrap-modal',
      afterShow: function afterShow($modal) {
        _this._getForm($modal);
      }
    });
    this._bindPageEvents();
  }

  // Bind functionality to giftwrap links.
  ;
  _proto._bindPageEvents = function _bindPageEvents() {
    var _this2 = this;
    this.$cartContent.on('click', this.options.trigger, function (event) {
      event.preventDefault();
      var $target = $(event.currentTarget);
      _this2.itemId = $target.data('item-giftwrap');
      _this2.GiftWrapModal.open();
    });
    this.$cartContent.on('click', this.options.remove, function (event) {
      if (!confirm(_this2.context.removeGiftWrap)) {
        event.preventDefault();
      }
      ;
    });
    $('body').on('click', '.button-cancel-giftwrap', function () {
      event.preventDefault();
      _this2.GiftWrapModal.close();
    });
  }

  // Run once the modal has been opened..
  ;
  _proto._getForm = function _getForm($modal) {
    var _this3 = this;
    var options = {
      template: 'cart/giftwrap-form'
    };
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.getItemGiftWrappingOptions(this.itemId, options, function (err, response) {
      if (response) {
        $modal.find('.modal-content').append(response.content);
        _this3._bindModalEvents($modal);

        // reposition modal with content
        _this3.GiftWrapModal.position();

        // Class added to display the modal once content is available
        $modal.addClass('visible');
      } else {
        _this3.GiftWrapModal.close();
      }
    });
  };
  _proto._bindModalEvents = function _bindModalEvents($modal) {
    var _this4 = this;
    $modal.on('change', function () {
      _this4.GiftWrapModal.position();
    });

    // Select giftwrapping individually or together
    $modal.find('[data-giftwrap-type]').on('change', function (event) {
      _this4._toggleSingleMultiple($modal, event.currentTarget.value);
    });

    // Select the type of gift wrapping for a particular item
    $('[data-giftwrap-select]').change(function (event) {
      var $select = $(event.target);
      var index = $select.data('index');
      var id = $select.val();
      if (!id) {
        return;
      }
      var allowMessage = $select.find("option[value=" + id + "]").data('allow-message');
      $("[data-giftwrap-image-" + index + "]").addClass('hidden');
      $("[data-giftwrap-image-" + index + "=\"" + id + "\"]").removeClass('hidden');
      if (allowMessage) {
        $("[data-giftwrap-message-" + index + "]").removeClass('hidden');
      } else {
        $("[data-giftwrap-message-" + index + "]").addClass('hidden');
      }
    });
    $('[data-giftwrap-select]').trigger('change');
  }

  // Toggles displaying single / multiple wrap options
  ;
  _proto._toggleSingleMultiple = function _toggleSingleMultiple($modal, value) {
    var $singleForm = $modal.find('[data-giftwrap-single]');
    var $multiForm = $modal.find('[data-giftwrap-multiple]');
    if (value === 'different') {
      $singleForm.addClass('hidden');
      $multiForm.removeClass('hidden');
    } else {
      $singleForm.removeClass('hidden');
      $multiForm.addClass('hidden');
    }
  };
  return GiftWrapping;
}();


/***/ }),

/***/ "./assets/js/theme/cart/ShippingCalculator.js":
/*!****************************************************!*\
  !*** ./assets/js/theme/cart/ShippingCalculator.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ShippingCalculator)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _refreshContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./refreshContent */ "./assets/js/theme/cart/refreshContent.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");



var ShippingCalculator = /*#__PURE__*/function () {
  function ShippingCalculator(el, options) {
    this.$el = $(el);
    this.shippingAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_1__["default"]($('[data-alerts]'));
    this.options = $.extend({
      context: {},
      $scope: $('[data-cart-totals]'),
      visibleClass: 'visible'
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = ShippingCalculator.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.options.$scope.on('click', '[data-shipping-calculator-toggle]', function (event) {
      event.preventDefault();
      _this._toggle();
    });
    this.options.$scope.on('submit', '[data-shipping-calculator] form', function (event) {
      event.preventDefault();
      _this._calculateShipping();
    });
    this.options.$scope.on('change', 'select[name="shipping-country"]', function (event) {
      _this._updateStates(event);
      _this.options.$scope.find('[name="shipping-zip"]').val('');
    });
  };
  _proto._toggle = function _toggle() {
    $('[data-shipping-calculator]', this.options.$scope).toggleClass(this.options.visibleClass);
  };
  _proto._updateStates = function _updateStates(event) {
    var _this2 = this;
    var $target = $(event.currentTarget);
    var country = $target.val();
    var $stateElement = $('[name="shipping-state"]');
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.country.getByName(country, function (err, response) {
      if (response.data.states.length) {
        var stateArray = [];
        stateArray.push("<option value=\"\">" + response.data.prefix + "</option>");
        $.each(response.data.states, function (i, state) {
          stateArray.push("<option value=\"" + state.id + "\">" + state.name + "</option>");
        });
        $stateElement.parent().addClass('form-select-wrapper');
        $stateElement.replaceWith("<select class=\"form-select form-input form-input-short\" id=\"shipping-state\" name=\"shipping-state\" data-field-type=\"State\">" + stateArray.join(' ') + "</select>");
      } else {
        $stateElement.parent().removeClass('form-select-wrapper');
        $stateElement.replaceWith("<input class=\"form-input form-input-short\" type=\"text\" id=\"shipping-state\" name=\"shipping-state\" data-field-type=\"State\" placeholder=\"" + _this2.options.context.shippingState + "\">");
      }
    });
  };
  _proto._calculateShipping = function _calculateShipping() {
    var _this3 = this;
    this.callbacks.willUpdate();
    var params = {
      country_id: $('[name="shipping-country"]', this.$calculatorForm).val(),
      state_id: $('[name="shipping-state"]', this.$calculatorForm).val(),
      zip_code: $('[name="shipping-zip"]', this.$calculatorForm).val()
    };
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.getShippingQuotes(params, 'cart/shipping-quotes', function (err, response) {
      var $shippingQuotes = $('[data-shipping-quotes]', _this3.options.$scope);
      if (response.data.quotes) {
        _this3.shippingAlerts.clear();
        $shippingQuotes.html(response.content);
      } else {
        _this3.shippingAlerts.error(response.data.errors.join('\n'), true);
      }
      _this3.callbacks.didUpdate();

      // bind the shipping method radios
      $shippingQuotes.find('.form').on('change', function (event) {
        event.preventDefault();
        _this3.callbacks.willUpdate();
        var quoteId = $('[data-shipping-quote]:checked').val();
        _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.submitShippingQuote(quoteId, function (response) {
          (0,_refreshContent__WEBPACK_IMPORTED_MODULE_2__["default"])(_this3.callbacks.didUpdate);
        });
      });
    });
  };
  return ShippingCalculator;
}();


/***/ }),

/***/ "./assets/js/theme/cart/refreshContent.js":
/*!************************************************!*\
  !*** ./assets/js/theme/cart/refreshContent.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(didUpdate, remove) {
  var $cartTotals = $('[data-cart-totals]');
  var $cartContent = $('[data-cart-content]');
  var $cartPromos = $('[data-cart-promos]');
  var $cartItem = $('[data-cart-item]', $cartContent);
  var options = {
    template: {
      content: 'cart/content',
      totals: 'cart/totals',
      promos: 'header/shipping-messages'
    }
  };

  // Remove last item from cart? Reload
  if (remove && $cartItem.length === 1) {
    return window.location.reload();
  }
  _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.getContent(options, function (err, response) {
    // TODO: Scope the call to this function by area that needs updating
    $cartContent.html(response.content);
    $cartTotals.html(response.totals);
    $cartPromos.replaceWith(response.promos);
    $cartContent.trigger('cart-initialize-modules');

    // TODO: If the loading overlay is scoped to an area that is replaced
    // it does not fade out, but is removed abrubtly (due to being a
    // part of that area's content).
    didUpdate();
  });
}

/***/ }),

/***/ "./assets/js/theme/components/Alert.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/components/Alert.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Alert)
/* harmony export */ });
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/template */ "./node_modules/lodash/template.js");
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_template__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
var Alert = /*#__PURE__*/function () {
  function Alert($el, options) {
    if (options === void 0) {
      options = {};
    }
    this.$el = $el;
    this.options = $.extend({
      classes: {
        base: 'alert',
        error: 'alert-error',
        info: 'alert-info',
        success: 'alert-success'
      },
      limit: 1,
      template: {},
      callbacks: {}
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {},
      didUpdate: function didUpdate() {}
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = Alert.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    if (lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(this.options.template)) {
      this.options.template = lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n        <div class='" + this.options.classes.base + " <%= messageType %>'>\n          <% if (isDismissable) { %>\n            <a class=\"alert-dismiss\">&times;</a>\n          <% } %>\n          <div class=\"alert-message\">\n            <%= messageText %>\n          </div>\n        </div>\n      ");
    }
    this.$el.on('click', '.alert-dismiss', function (event) {
      event.preventDefault();
      var $alert = $(event.currentTarget).parent('.alert');
      _this._dismissMessage($alert);
    });
    this.$el.on('clear-messages', function () {
      _this.clear();
    });
  }

  /**
   * This method can be used to reset the contents of this.$el
   */;
  _proto.clear = function clear() {
    var _this2 = this;
    this.$el.find("." + this.options.classes.base).each(function (index, target) {
      _this2._dismissMessage($(target));
    });
  }

  /**
   * If bc-core becomes integrated into bc-skeleton, this method should delegate to `dismissable()`
   * @param $alert
   * @private
   */;
  _proto._dismissMessage = function _dismissMessage($alert) {
    $alert.addClass('dismissed');
    $alert.one('trend', function () {
      $alert.remove();
    });
  }

  /**
   * Explicit usage to create an error alert
   * @param text
   * @param dismissable
   */;
  _proto.error = function error(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'error', dismissable);
  }

  /**
   * Explicit usage to create a success alert
   * @param text
   * @param dismissable
   */;
  _proto.success = function success(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'success', dismissable);
  }

  /**
   * Explicit usage to create an informational alert
   * @param text
   * @param dismissable
   */;
  _proto.info = function info(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'info', dismissable);
  }

  /**
   *
   * @param text
   * @param type
   * @param dismissable
   */;
  _proto.message = function message(text, type, dismissable) {
    var _this3 = this;
    if (type === void 0) {
      type = 'info';
    }
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.callbacks.willUpdate();
    if (typeof this.options.limit === 'number' && this.$el.find("." + this.options.classes.base).length > this.options.limit) {
      this._dismissMessage(this.$el.find("." + this.options.classes.base + ":not(.dismissed)").eq(0));
    }
    var message = {
      messageType: this.options.classes[type],
      messageText: text,
      isDismissable: dismissable
    };
    var $modalBody = $('.modal-body');
    var appendMessage = function appendMessage($el) {
      $el.append(_this3.options.template(message));
    };
    if ($modalBody.length) {
      var productAlerts = $modalBody.find('[data-product-alerts]');
      appendMessage(productAlerts);
    } else {
      var alerts = $('.site-header').find('[data-alerts]');
      appendMessage(alerts);
    }
    ;
    this.callbacks.didUpdate();
  };
  return Alert;
}();


/***/ }),

/***/ "./assets/js/theme/components/QuantityWidget.js":
/*!******************************************************!*\
  !*** ./assets/js/theme/components/QuantityWidget.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ QuantityWidget)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var QuantityWidget = function QuantityWidget(options) {
  if (options === void 0) {
    options = {};
  }
  this.options = $.extend({
    el: '[data-quantity-control]',
    cntrl: '[data-quantity-control-action]',
    scope: 'body'
  }, options);

  // Bind Control Actions
  $(this.options.scope).on('click', this.options.cntrl, function (event) {
    event.preventDefault(); //in case we use <button>/<a> instead of <span>'s
    var $target = $(event.target);
    var action = $target.data('quantity-control-action');
    var $quantityInput = $target.siblings('input');
    var value = parseInt($quantityInput.val(), 10);
    var min = $quantityInput.attr('min') ? parseInt($quantityInput.attr('min'), 10) : 0;
    var max = $quantityInput.attr('max') ? parseInt($quantityInput.attr('max'), 10) : Infinity;
    if (action === 'increment' && value < max) {
      $quantityInput.val(value + 1).trigger('change');
    } else if (action === 'decrement' && value > 0 && value > min) {
      $quantityInput.val(value - 1).trigger('change');
    }
  });

  // Simple input validation (keep input within min/max range)
  // Feel free to remove and replace with another form of validation
  $(this.options.scope).on('change', 'input', function (event) {
    var $target = $(event.target);
    var value = parseInt($target.val(), 10);
    var min = $target.attr('min') ? parseInt($target.attr('min'), 10) : 0;
    var max = $target.attr('max') ? parseInt($target.attr('max'), 10) : Infinity;
    if (value > max) {
      //TODO: Integrate Alert system
      console.error("Quantity \"" + value + "\" cannot be greater than maximum (" + max + ")");
      $target.val($target.attr('value'));
    }
    if (value < min) {
      console.error("Quantity value \"" + value + "\" cannot be less than minimum (" + min + ")");
      $target.val($target.attr('value'));
    }
  });
};


/***/ }),

/***/ "./assets/js/theme/components/SelectWrapper.js":
/*!*****************************************************!*\
  !*** ./assets/js/theme/components/SelectWrapper.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectWrapper)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var SelectWrapper = /*#__PURE__*/function () {
  function SelectWrapper(el) {
    this.$el = $(el);
    if (!this.$el.parent('.form-select-wrapper').length) {
      this.$el.wrap('<div class="form-select-wrapper" />').parent().prepend("<span class=\"selected-text\">" + this.$el.find('option:selected').text() + "</span>");
    }

    // Conditional required so I can use the currency code as opposed to
    // the full currency name in the currency switcher
    if (!this.$el.closest('.currency-switcher').length) {
      this._bindEvents();
    }
  }
  var _proto = SelectWrapper.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.$el.on('change', function () {
      _this.updateSelectText();
    });
  };
  _proto.updateSelectText = function updateSelectText(option) {
    var newOption = option ? option : this.$el.find('option:selected').text();
    this.$el.siblings('.selected-text').text(newOption);
  };
  return SelectWrapper;
}();


/***/ }),

/***/ "./assets/js/theme/core/Account.js":
/*!*****************************************!*\
  !*** ./assets/js/theme/core/Account.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Account)
/* harmony export */ });
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/find */ "./node_modules/lodash/find.js");
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_find__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js");
/* harmony import */ var lodash_reduce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_reduce__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _alertDismissable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alertDismissable */ "./assets/js/theme/core/alertDismissable.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _utils_FormValidator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/FormValidator */ "./assets/js/theme/utils/FormValidator.js");
/* harmony import */ var _downloadGallery__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./downloadGallery */ "./assets/js/theme/core/downloadGallery.js");
/* harmony import */ var _updateState__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./updateState */ "./assets/js/theme/core/updateState.js");
/* harmony import */ var _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./account/paymentMethod */ "./assets/js/theme/core/account/paymentMethod.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
/**
 *
 * FormValidator does not currently exist in the core files, it is being
 * imported from the theme so that the credit card form can benefit from being
 * validated. Make sure the FormValidator file exists in the theme or that this
 * page is not called if adding it to the theme you are working on
 *
 */








var Account = /*#__PURE__*/function (_PageManager) {
  function Account() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Account, _PageManager);
  var _proto = Account.prototype;
  _proto.loaded = function loaded(next) {
    this._bindEvents();
    var $paymentMethodForm = $('form[data-payment-method-form]');
    if ($paymentMethodForm.length) {
      this.initPaymentMethodFormValidation($paymentMethodForm);
    }
    this.pageAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_4__["default"]($('[data-alerts]'));
    this.Validator = new _utils_FormValidator__WEBPACK_IMPORTED_MODULE_5__["default"](this.context);
    this.Validator.initSingle($(document.body).find('form[data-payment-method-form]'));
    (0,_updateState__WEBPACK_IMPORTED_MODULE_7__["default"])(false, this.selectWrapCallback);
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    (0,_alertDismissable__WEBPACK_IMPORTED_MODULE_3__["default"])();
    (0,_downloadGallery__WEBPACK_IMPORTED_MODULE_6__["default"])();
    (0,_updateState__WEBPACK_IMPORTED_MODULE_7__["default"])(false, this.selectWrapCallback);
    var $reorderForm = $('[data-account-reorder-form]');
    if ($reorderForm.length) {
      this.initReorderForm($reorderForm);
    }

    // Toggle - a simple way to toggle elements
    $(document.body).on('click', '[data-account-toggle]', function (event) {
      var $el = $(event.currentTarget);
      var $target = $($el.data('account-toggle'));
      $target.toggle();
    });
    this.bindDeletePaymentMethod();
  };
  _proto.initReorderForm = function initReorderForm($reorderForm) {
    $reorderForm.on('submit', function (event) {
      var submitForm = false;
      var $productReorderCheckboxes = $('.account-item .form-checkbox:checked');
      $reorderForm.find('[name^="reorderitem"]').remove();
      $productReorderCheckboxes.each(function (index, productCheckbox) {
        var productId = $(productCheckbox).val();
        var $input = $('<input>', {
          type: 'hidden',
          name: "reorderitem[" + productId + "]",
          value: '1'
        });
        submitForm = true;
        $reorderForm.append($input);
      });
      if (!submitForm) {
        event.preventDefault();
        $('.account-toolbar .alert-error').show();
      }
    });
  }

  /**
   * Optional callback fired when a fresh state <select> element is added to the DOM
   */;
  _proto.selectWrapCallback = function selectWrapCallback($selectEl) {} //eslint-disable-line no-unused-vars

  /**
  * Binds a submit hook to ensure the customer receives a confirmation dialog before deleting a payment method
  */;
  _proto.bindDeletePaymentMethod = function bindDeletePaymentMethod() {
    $('[data-delete-payment-method]').on('submit', function (event) {
      var message = $(event.currentTarget).data('deletePaymentMethod');
      if (!window.confirm(message)) {
        event.preventDefault();
      }
    });
  };
  _proto.initPaymentMethodFormValidation = function initPaymentMethodFormValidation($paymentMethodForm) {
    var _this = this;
    // Inject validations into form fields before validation runs
    $paymentMethodForm.find('#first_name.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.firstNameLabel + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#last_name.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.lastNameLabel + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#company.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.companyLabel + "\", \"required\": false, \"maxlength\": 0 }");
    $paymentMethodForm.find('#phone.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.phoneLabel + "\", \"required\": false, \"maxlength\": 0 }");
    $paymentMethodForm.find('#address1.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.address1Label + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#address2.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.address2Label + "\", \"required\": false, \"maxlength\": 0 }");
    $paymentMethodForm.find('#city.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.cityLabel + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#country.form-field').attr('data-validation', "{ \"type\": \"singleselect\", \"label\": \"" + this.context.countryLabel + "\", \"required\": true, prefix: \"" + this.context.chooseCountryLabel + "\" }");
    $paymentMethodForm.find('#state.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.stateLabel + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#postal_code.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.postalCodeLabel + "\", \"required\": true, \"maxlength\": 0 }");
    var paymentMethodSelector = 'form[data-payment-method-form]';
    var $stateElement = $(paymentMethodSelector + " [data-field-type=\"State\"]");
    var $last;

    // Use credit card number input listener to highlight credit card type
    $(paymentMethodSelector + " input[name=\"credit_card_number\"]").on('keyup', function (_ref) {
      var target = _ref.target;
      var cardType = (0,_account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.creditCardType)(target.value);
      if (cardType) {
        $(paymentMethodSelector + " img[alt=\"" + cardType + "\"").siblings().css('opacity', '.2');
      } else {
        $(paymentMethodSelector + " img").css('opacity', '1');
      }
    });

    // Set of credit card validation
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Validators.setCreditCardNumberValidation($paymentMethodForm, paymentMethodSelector + " input[name=\"credit_card_number\"]", this.context.creditCardNumber);
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Validators.setExpirationValidation($paymentMethodForm, paymentMethodSelector + " input[name=\"expiration\"]", this.context.expiration);
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Validators.setNameOnCardValidation($paymentMethodForm, paymentMethodSelector + " input[name=\"name_on_card\"]", this.context.nameOnCard);
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Validators.setCvvValidation($paymentMethodForm, paymentMethodSelector + " input[name=\"cvv\"]", this.context.cvv);

    // Set of credit card format
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Formatters.setCreditCardNumberFormat(paymentMethodSelector + " input[name=\"credit_card_number\"]");
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Formatters.setExpirationFormat(paymentMethodSelector + " input[name=\"expiration\"");

    // Billing address validation
    $paymentMethodForm.on('submit', function (event) {
      event.preventDefault();
      var $formIsValid = $paymentMethodForm.find('.form-field-invalid') > 0 ? false : true;

      // Perform final form validation
      if ($formIsValid) {
        // Serialize form data and reduce it to object
        var data = lodash_reduce__WEBPACK_IMPORTED_MODULE_1___default()($paymentMethodForm.serializeArray(), function (obj, item) {
          var refObj = obj;
          refObj[item.name] = item.value;
          return refObj;
        }, {});

        // Assign country and state code
        var country = lodash_find__WEBPACK_IMPORTED_MODULE_0___default()(_this.context.countries, function (_ref2) {
          var value = _ref2.value;
          return value === data.country;
        });
        var state = country && lodash_find__WEBPACK_IMPORTED_MODULE_0___default()(country.states, function (_ref3) {
          var value = _ref3.value;
          return value === data.state;
        });
        data.country_code = country ? country.code : data.country;
        data.state_or_province_code = state ? state.code : data.state;

        // Default Instrument
        data.default_instrument = !!data.default_instrument;

        // Store credit card
        (0,_account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.storeInstrument)(_this.context, data, function () {
          window.location.href = _this.context.paymentMethodsUrl;
        }, function () {
          _this.pageAlerts.error(_this.context.generic_error, true);
        });
      }
    });
  };
  return Account;
}(_PageManager__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./assets/js/theme/core/Auth.js":
/*!**************************************!*\
  !*** ./assets/js/theme/core/Auth.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Account)
/* harmony export */ });
/* harmony import */ var _updateState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./updateState */ "./assets/js/theme/core/updateState.js");

var Account = /*#__PURE__*/function () {
  function Account() {
    (0,_updateState__WEBPACK_IMPORTED_MODULE_0__["default"])(false, this.selectWrapCallback);
  }

  /**
   * Optional callback fired when a fresh state <select> element is added to the DOM
   */
  var _proto = Account.prototype;
  _proto.selectWrapCallback = function selectWrapCallback($selectEl) {} //eslint-disable-line no-unused-vars

  // backwards compatibility for Page Manager
  ;
  _proto.loaded = function loaded() {};
  _proto.before = function before() {};
  _proto.after = function after() {};
  return Account;
}();


/***/ }),

/***/ "./assets/js/theme/core/GiftCertificate.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/core/GiftCertificate.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GiftCertificate)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var GiftCertificate = /*#__PURE__*/function () {
  function GiftCertificate(context) {
    this.$purchaseForm = $('[data-giftcard-purchase-form]');
    this._bindEvents();
  }
  var _proto = GiftCertificate.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.$purchaseForm.on('change', function () {
      if ($('#giftcard-amount').val() != "") {
        _this._showPreview();
      }
    });
    this.$purchaseForm.find('[data-no-refresh]').on('change', function (event) {
      event.stopPropagation();
    });
  }

  /**
   * Show or update the giftcard preview.
   */;
  _proto._showPreview = function _showPreview() {
    var $theme = this.$purchaseForm.find('[data-giftcard-theme]');

    // Only show a preview if a theme is selected
    if (!$theme.find('.form-input:checked').length) {
      return;
    }

    // Calculate preview URL based on form state
    var baseUrl = $theme.data('giftcard-preview-url');
    var data = this.$purchaseForm.serialize();
    var url = baseUrl + "&" + data;

    // Create preview
    var $preview = $('<iframe>', {
      src: url
    }).on('load', function (event) {
      // Calculate iframe height based on its document height
      var height = $(event.currentTarget.contentDocument).height();
      $(event.currentTarget).height(height);
    });

    // Update preview
    $theme.find('.giftcard-form-preview').addClass('has-preview').html($preview);
  }

  // backwards compatibility for Page Manager
  ;
  _proto.loaded = function loaded() {};
  _proto.before = function before() {};
  _proto.after = function after() {};
  return GiftCertificate;
}();


/***/ }),

/***/ "./assets/js/theme/core/account/paymentMethod.js":
/*!*******************************************************!*\
  !*** ./assets/js/theme/core/account/paymentMethod.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Formatters: () => (/* binding */ Formatters),
/* harmony export */   Validators: () => (/* binding */ Validators),
/* harmony export */   creditCardType: () => (/* binding */ creditCardType),
/* harmony export */   storeInstrument: () => (/* binding */ storeInstrument)
/* harmony export */ });
/* harmony import */ var creditcards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! creditcards */ "./node_modules/creditcards/index.js");
/* harmony import */ var creditcards__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(creditcards__WEBPACK_IMPORTED_MODULE_0__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


/**
 * Omit null or empty string properties of object
 * @param {Object} object
 * @returns {Object}
 */
var omitNullString = function omitNullString(obj) {
  var refObj = obj;
  $.each(refObj, function (key, value) {
    if (value === null || value === '') {
      delete refObj[key];
    }
  });
  return refObj;
};

/**
 * Get credit card type from credit card number
 * @param {string} value
 */
var creditCardType = function creditCardType(value) {
  return creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.type(creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.parse(value), true);
};

/**
 * Wrapper for ajax request to store a new instrument in bigpay
 * @param {object} Representing the data needed for the header
 * @param {object} Representing the data needed for the body
 * @param {function} done Function to execute on a successful response
 * @param {function} fail Function to execute on a unsuccessful response
 */
var storeInstrument = function storeInstrument(_ref, _ref2, done, fail) {
  var paymentsUrl = _ref.paymentsUrl,
    shopperId = _ref.shopperId,
    storeHash = _ref.storeHash,
    vaultToken = _ref.vaultToken;
  var provider_id = _ref2.provider_id,
    currency_code = _ref2.currency_code,
    credit_card_number = _ref2.credit_card_number,
    expiration = _ref2.expiration,
    name_on_card = _ref2.name_on_card,
    cvv = _ref2.cvv,
    default_instrument = _ref2.default_instrument,
    address1 = _ref2.address1,
    address2 = _ref2.address2,
    city = _ref2.city,
    postal_code = _ref2.postal_code,
    state_or_province_code = _ref2.state_or_province_code,
    country_code = _ref2.country_code,
    company = _ref2.company,
    first_name = _ref2.first_name,
    last_name = _ref2.last_name,
    email = _ref2.email,
    phone = _ref2.phone;
  var expiry = expiration.split('/');
  $.ajax({
    url: paymentsUrl + "/stores/" + storeHash + "/customers/" + shopperId + "/stored_instruments",
    dataType: 'json',
    method: 'POST',
    cache: false,
    headers: {
      Authorization: vaultToken,
      Accept: 'application/vnd.bc.v1+json',
      'Content-Type': 'application/vnd.bc.v1+json'
    },
    data: JSON.stringify({
      instrument: {
        type: 'card',
        cardholder_name: name_on_card,
        number: creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.parse(credit_card_number),
        expiry_month: creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.month.parse(expiry[0]),
        expiry_year: creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.year.parse(expiry[1], true),
        verification_value: cvv
      },
      billing_address: omitNullString({
        address1: address1,
        address2: address2,
        city: city,
        postal_code: postal_code,
        state_or_province_code: state_or_province_code,
        country_code: country_code,
        company: company,
        first_name: first_name,
        last_name: last_name,
        email: email,
        phone: phone
      }),
      provider_id: provider_id,
      default_instrument: default_instrument,
      currency_code: currency_code
    })
  }).done(done).fail(fail);
};
var Formatters = {
  /**
   * Sets up a format for credit card number
   * @param field
   */
  setCreditCardNumberFormat: function setCreditCardNumberFormat(field) {
    if (field) {
      $(field).on('keyup', function (_ref3) {
        var target = _ref3.target;
        var refTarget = target;
        refTarget.value = creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.format(creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.parse(target.value));
      });
    }
  },
  /**
   * Sets up a format for expiration date
   * @param field
   */
  setExpirationFormat: function setExpirationFormat(field) {
    if (field) {
      $(field).on('keyup', function (_ref4) {
        var target = _ref4.target,
          which = _ref4.which;
        var refTarget = target;
        if (which === 8 && /.*(\/)$/.test(target.value)) {
          refTarget.value = target.value.slice(0, -1);
        } else if (target.value.length > 4) {
          refTarget.value = target.value.slice(0, 5);
        } else if (which !== 8) {
          refTarget.value = target.value.replace(/^([1-9]\/|[2-9])$/g, '0$1/').replace(/^(0[1-9]|1[0-2])$/g, '$1/').replace(/^([0-1])([3-9])$/g, '0$1/$2').replace(/^(0[1-9]|1[0-2])([0-9]{2})$/g, '$1/$2').replace(/^([0]+)\/|[0]+$/g, '0').replace(/[^\d\/]|^[\/]*$/g, '').replace(/\/\//g, '/');
        }
      });
    }
  }
};
var Validators = {
  /**
   * Sets up a validation for credit card number
   * @param validator
   * @param field
   */
  setCreditCardNumberValidation: function setCreditCardNumberValidation(validator, field, errorMessage) {
    if (field) {
      validator.add({
        selector: field,
        validate: function validate(cb, val) {
          var result = val.length && creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.isValid(creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.parse(val));
          cb(result);
        },
        errorMessage: errorMessage
      });
    }
  },
  /**
   * Sets up a validation for expiration date
   * @param validator
   * @param field
   */
  setExpirationValidation: function setExpirationValidation(validator, field, errorMessage) {
    if (field) {
      validator.add({
        selector: field,
        validate: function validate(cb, val) {
          var expiry = val.split('/');
          var result = val.length && /^(0[1-9]|1[0-2])\/([0-9]{2})$/.test(val);
          result = result && !creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.isPast(creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.month.parse(expiry[0]), creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.year.parse(expiry[1], true));
          cb(result);
        },
        errorMessage: errorMessage
      });
    }
  },
  /**
   * Sets up a validation for name on card
   * @param validator
   * @param field
   */
  setNameOnCardValidation: function setNameOnCardValidation(validator, field, errorMessage) {
    if (field) {
      validator.add({
        selector: field,
        validate: function validate(cb, val) {
          var result = !!val.length;
          cb(result);
        },
        errorMessage: errorMessage
      });
    }
  },
  /**
   * Sets up a validation for cvv
   * @param validator
   * @param field
   */
  setCvvValidation: function setCvvValidation(validator, field, errorMessage) {
    if (field) {
      validator.add({
        selector: field,
        validate: function validate(cb, val) {
          var result = val.length && creditcards__WEBPACK_IMPORTED_MODULE_0___default().cvc.isValid(val);
          cb(result);
        },
        errorMessage: errorMessage
      });
    }
  }
};

/***/ }),

/***/ "./assets/js/theme/core/alertDismissable.js":
/*!**************************************************!*\
  !*** ./assets/js/theme/core/alertDismissable.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dismissable)
/* harmony export */ });
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery-trend */ "./node_modules/jquery-trend/jquery.trend.js");
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery_trend__WEBPACK_IMPORTED_MODULE_0__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


/**
 * Core Alert components can be loaded with a `dismissable` param. If this
 * is true, an alert-dismiss button is included in the markup.
 *
 * This function removes the alert when the button is clicked.
 */
function dismissable() {
  $('body').on('click', '.alert-dismiss', function (event) {
    event.preventDefault();
    var $target = $(event.currentTarget);
    var $alert = $target.parent('.alert');
    $alert.one('trend', function () {
      $alert.remove();
    });
    $alert.addClass('dismissed');
  });
}

/***/ }),

/***/ "./assets/js/theme/core/amp/AmpAlert.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/core/amp/AmpAlert.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Alert)
/* harmony export */ });
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/template */ "./node_modules/lodash/template.js");
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_template__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery-trend */ "./node_modules/jquery-trend/jquery.trend.js");
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_trend__WEBPACK_IMPORTED_MODULE_2__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


/**
 *  Alerts
 *
 *  Utility module to display status messages for components.
 *  Instantiate Class: new Alert()
 *
 *  @arg $el       jQuery object
 *    The specific element that will hold new alert messages.
 *
 *  @arg options  Object
 *  An object containing additional options for the module. (see below)
 */
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }

var Alert = /*#__PURE__*/function () {
  function Alert($el, options) {
    if (options === void 0) {
      options = {};
    }
    this.$el = $el;
    this.options = $.extend({
      classes: {
        base: 'alert',
        error: 'alert-error',
        info: 'alert-info',
        success: 'alert-success'
      },
      limit: 1,
      template: {},
      callbacks: {}
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {},
      didUpdate: function didUpdate() {}
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = Alert.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    if (lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(this.options.template)) {
      this.options.template = lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n        <div class='" + this.options.classes.base + " <%= messageType %>'>\n          <% if (isDismissable) { %>\n            <a class=\"alert-dismiss\">\n              <svg class=\"icon-x\" width=\"11\" height=\"11\" viewBox=\"0 0 11 11\" xmlns=\"http://www.w3.org/2000/svg\" role=\"presentation\">\n                <path d=\"M.367.933l9.2 9.2c.156.156.41.156.566 0 .156-.156.156-.41 0-.566l-9.2-9.2C.777.21.523.21.367.367.21.523.21.777.367.933zm9.2-.566l-9.2 9.2c-.156.156-.156.41 0 .566.156.156.41.156.566 0l9.2-9.2c.156-.156.156-.41 0-.566-.156-.156-.41-.156-.566 0z\" fill-rule=\"nonzero\" fill=\"currentColor\"/>\n              </svg>\n            </a>\n          <% } %>\n          <div class=\"alert-message\">\n            <%= messageText %>\n          </div>\n        </div>\n      ");
    }
    this.$el.on('click', '.alert-dismiss', function (event) {
      event.preventDefault();
      var $alert = $(event.currentTarget).parent('.alert');
      _this._dismissMessage($alert);
    });
    this.$el.on('clear-messages', function () {
      _this.clear();
    });
  }

  /**
   * This method can be used to reset the contents of this.$el
   */;
  _proto.clear = function clear() {
    var _this2 = this;
    this.$el.find("." + this.options.classes.base).each(function (index, target) {
      _this2._dismissMessage($(target));
    });
  }

  /**
   * If bc-core becomes integrated into bc-skeleton, this method should delegate to `dismissable()`
   * @param $alert
   * @private
   */;
  _proto._dismissMessage = function _dismissMessage($alert) {
    $alert.addClass('dismissed');
    $alert.one('trend', function () {
      $alert.remove();
    });
  }

  /**
   * Explicit usage to create an error alert
   * @param text
   * @param dismissable
   */;
  _proto.error = function error(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'error', dismissable);
  }

  /**
   * Explicit usage to create a success alert
   * @param text
   * @param dismissable
   */;
  _proto.success = function success(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'success', dismissable);
  }

  /**
   * Explicit usage to create an informational alert
   * @param text
   * @param dismissable
   */;
  _proto.info = function info(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'info', dismissable);
  }

  /**
   *
   * @param text
   * @param type
   * @param dismissable
   */;
  _proto.message = function message(text, type, dismissable) {
    if (type === void 0) {
      type = 'info';
    }
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.callbacks.willUpdate(this.$el);
    if (typeof this.options.limit === 'number' && this.$el.find("." + this.options.classes.base).length > this.options.limit) {
      this._dismissMessage(this.$el.find("." + this.options.classes.base + ":not(.dismissed)").eq(0));
    }
    var message = {
      messageType: this.options.classes[type],
      messageText: text,
      isDismissable: dismissable
    };
    var $alert = this.$el.append(this.options.template(message));
    this.callbacks.didUpdate($alert, this.$el);
  };
  return Alert;
}();


/***/ }),

/***/ "./assets/js/theme/core/amp/AmpProductUtils.js":
/*!*****************************************************!*\
  !*** ./assets/js/theme/core/amp/AmpProductUtils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProductUtils)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _AmpAlert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AmpAlert */ "./assets/js/theme/core/amp/AmpAlert.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var ProductUtils = /*#__PURE__*/function () {
  function ProductUtils(el, options) {
    this.$el = $(el);
    this.options = options;
    this.$body = $(document.body);
    this.productId = this.$el.find('[data-product-id]').val();

    // class to add or remove from cart-add button depending on variation availability
    this.buttonDisabledClass = 'button-disabled';

    // two alert locations based on action
    this.cartAddAlert = new _AmpAlert__WEBPACK_IMPORTED_MODULE_1__["default"](this.$body.find('[data-product-cart-message]'));
    this.cartOptionAlert = new _AmpAlert__WEBPACK_IMPORTED_MODULE_1__["default"](this.$el.find('[data-product-option-message]'));
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {},
      didUpdate: function didUpdate() {}
    }, options.callbacks);
  }
  var _proto = ProductUtils.prototype;
  _proto.init = function init(context) {
    this.context = context;
    this._bindProductOptionChange();
    this._boundCartCallback = this._bindCartAdd.bind(this);
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.on('cart-item-add', this._boundCartCallback);
    this._updateAttributes(window.BCData.product_attributes);
  }

  /**
   * Cache an object of jQuery elements for DOM updating
   * @param  jQuery $el - a wrapping element of the scoped product
   * @return {object} - buncha jQuery elements which may or may not exist on the page
   */;
  _proto._getViewModel = function _getViewModel($el) {
    return {
      $addToCart: $('[data-button-purchase]', $el)
    };
  }

  /**
   * Bind product options changes.
   */;
  _proto._bindProductOptionChange = function _bindProductOptionChange() {
    var _this = this;
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.on('product-option-change', function (event, changedOption) {
      var $changedOption = $(changedOption);
      var $form = $changedOption.parents('form');

      // Do not trigger an ajax request if it's a file or if the browser doesn't support FormData
      if ($changedOption.attr('type') === 'file' || window.FormData === undefined) {
        return;
      }
      _this.cartAddAlert.clear();
      _this.cartOptionAlert.clear();

      // product template should be passed as a string
      var productTemplate = _this.options.template && typeof _this.options.template === 'string' ? _this.options.template : null;
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.productAttributes.optionChange(_this.productId, $form.serialize(), productTemplate, function (err, response) {
        var viewModel = _this._getViewModel(_this.$el);
        var data = response ? response.data : {};

        // If our form data doesn't include the product-options-count with a positive value, return
        if (_this.$el.find('[data-product-options-count]').val < 1) {
          return;
        }
        _this._updateAttributes(data);

        // update submit button state
        if (!data.purchasable || !data.instock) {
          _this.cartOptionAlert.error(data.purchasing_message);
          viewModel.$addToCart.addClass(_this.buttonDisabledClass).prop('disabled', true);
        } else {
          viewModel.$addToCart.removeClass(_this.buttonDisabledClass).prop('disabled', false);
        }
      });
    });
  }

  /**
   * Validate and update quantity input value
   */;
  _proto._updateQuantity = function _updateQuantity(event) {
    var $target = $(event.currentTarget);
    var $quantity = $target.closest('[data-product-quantity]').find('[data-quantity-control-input]');
    var min = parseInt($quantity.prop('min'), 10);
    var max = parseInt($quantity.prop('max'), 10);
    var newQuantity = parseInt($quantity.val(), 10);
    if (isNaN(newQuantity)) {
      newQuantity = min;
    }
    if ($target.is('[data-quantity-increment]') && (!max || newQuantity < max)) {
      newQuantity = newQuantity + 1;
    } else if ($target.is('[data-quantity-decrement]') && newQuantity > min) {
      newQuantity = newQuantity - 1;
    }
    $quantity.val(newQuantity);
  };
  _proto._updateAttributes = function _updateAttributes(data) {
    var _this2 = this;
    var behavior = data.out_of_stock_behavior;
    var inStockIds = data.in_stock_attributes;
    var outOfStockMessage = " (" + data.out_of_stock_message + ")";
    if (behavior !== 'hide_option' && behavior !== 'label_option') {
      return;
    }
    $('[data-product-attribute-value]', this.$el).each(function (i, attribute) {
      var $attribute = $(attribute);
      var attrId = parseInt($attribute.data('product-attribute-value'), 10);
      if (inStockIds.indexOf(attrId) !== -1) {
        _this2._enableAttribute($attribute, behavior, outOfStockMessage);
      } else {
        _this2._disableAttribute($attribute, behavior, outOfStockMessage);
      }
    });
  };
  _proto._disableAttribute = function _disableAttribute($attribute, behavior, outOfStockMessage) {
    if (this._getAttributeType($attribute) === 'set-select') {
      return this.disableSelectOptionAttribute($attribute, behavior, outOfStockMessage);
    }
    if (behavior === 'hide_option') {
      $attribute.hide();
    } else {
      $attribute.addClass('option-unavailable');
    }
  };
  _proto.disableSelectOptionAttribute = function disableSelectOptionAttribute($attribute, behavior, outOfStockMessage) {
    if (behavior === 'hide_option') {
      $attribute.toggleOption(false);
    } else {
      $attribute.attr('disabled', 'disabled');
      $attribute.html($attribute.html().replace(outOfStockMessage, '') + outOfStockMessage);
    }
  };
  _proto._enableAttribute = function _enableAttribute($attribute, behavior, outOfStockMessage) {
    if (this._getAttributeType($attribute) === 'set-select') {
      return this.enableSelectOptionAttribute($attribute, behavior, outOfStockMessage);
    }
    if (behavior === 'hide_option') {
      $attribute.show();
    } else {
      $attribute.removeClass('option-unavailable');
    }
  };
  _proto.enableSelectOptionAttribute = function enableSelectOptionAttribute($attribute, behavior, outOfStockMessage) {
    if (behavior === 'hide_option') {
      $attribute.toggleOption(true);
    } else {
      $attribute.removeAttr('disabled');
      $attribute.html($attribute.html().replace(outOfStockMessage, ''));
    }
  };
  _proto._getAttributeType = function _getAttributeType($attribute) {
    var $parent = $attribute.closest('[data-product-attribute]');
    return $parent ? $parent.data('product-attribute') : null;
  }

  /**
   * Add a product to cart
   */;
  _proto._bindCartAdd = function _bindCartAdd(event, form) {
    var _this3 = this;
    // Do not do AJAX if browser doesn't support FormData
    if (window.FormData === undefined) {
      return;
    }
    event.preventDefault();
    var formData = new FormData(form);
    this.callbacks.willUpdate($(form));

    // Remove old alters
    this.cartAddAlert.clear();
    this.cartOptionAlert.clear();

    // Add item to cart
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.itemAdd(formData, function (err, response) {
      if (err || response.data.error) {
        response = err || response.data.error;

        /**
         * interpret and display cart-add error message
         */
        _this3.cartAddAlert.message(response, 'error', true);
        _this3.callbacks.didUpdate(response, $(form));
      } else {
        return window.top.location = _this3.context.urlsCart;
      }
    });
  };
  return ProductUtils;
}();


/***/ }),

/***/ "./assets/js/theme/core/amp/AmpQuantityWidget.js":
/*!*******************************************************!*\
  !*** ./assets/js/theme/core/amp/AmpQuantityWidget.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AmpQuantityWidget)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var AmpQuantityWidget = function AmpQuantityWidget(options) {
  if (options === void 0) {
    options = {};
  }
  this.options = $.extend({
    el: '[data-quantity-control]',
    cntrl: '[data-quantity-control-action]',
    scope: 'body'
  }, options);

  // Bind Control Actions
  $(this.options.scope).on('click', this.options.cntrl, function (event) {
    event.preventDefault(); //in case we use <button>/<a> instead of <span>'s
    var $target = $(event.currentTarget);
    var action = $target.data('quantity-control-action');
    var $quantityInput = $target.siblings('input');
    var value = parseInt($quantityInput.val(), 10);
    var min = $quantityInput.attr('min') ? parseInt($quantityInput.attr('min'), 10) : 0;
    var max = $quantityInput.attr('max') ? parseInt($quantityInput.attr('max'), 10) : Infinity;
    if (action === 'increment' && value < max) {
      $quantityInput.val(value + 1).trigger('change');
    } else if (action === 'decrement' && value > 0 && value > min) {
      $quantityInput.val(value - 1).trigger('change');
    }
  });

  // Simple input validation (keep input within min/max range)
  // Feel free to remove and replace with another form of validation
  $(this.options.scope).on('change', 'input', function (event) {
    var $target = $(event.target);
    var value = parseInt($target.val(), 10);
    var min = $target.attr('min') ? parseInt($target.attr('min'), 10) : 0;
    var max = $target.attr('max') ? parseInt($target.attr('max'), 10) : Infinity;
    if (value > max) {
      console.error("Quantity \"" + value + "\" cannot be greater than maximum (" + max + ")");
      $target.val($target.attr('value'));
    }
    if (value < min) {
      console.error("Quantity value \"" + value + "\" cannot be less than minimum (" + min + ")");
      $target.val($target.attr('value'));
    }
  });
};


/***/ }),

/***/ "./assets/js/theme/core/downloadGallery.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/core/downloadGallery.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ gallery)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/**
 * Simple image gallery for orders with digital downloads.
 */
function gallery() {
  var $thumbs = $('[data-account-download-thumb]');
  var $image = $('[data-account-download-image]');
  $thumbs.on('click', function (event) {
    var $target = $(event.currentTarget);
    $image.attr('src', $target.attr('src'));
  });
}

/***/ }),

/***/ "./assets/js/theme/core/formSelectedValue.js":
/*!***************************************************!*\
  !*** ./assets/js/theme/core/formSelectedValue.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formSelectedValue)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var fieldSelector = '[data-swatch-selector]';
var valueSelector = '.swatch-wrap[data-swatch-value]';
var labelSelector = '.swatch-value[data-swatch-value]';

/**
 * Show selected value next to the form field title.
 *
 * Only applies to swatch form fields.
 */
function formSelectedValue() {
  $(document.body).on('click', valueSelector, function (event) {
    var $target = $(event.currentTarget);
    var $label = $target.parents(fieldSelector).find(labelSelector);
    $label.html($target.data('swatch-value'));
  });
}

/***/ }),

/***/ "./assets/js/theme/core/selectOption.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/core/selectOption.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/**
 * Visually hides the option from user by moving option to an invisible
 * and disabled select placeholder element.
 *
 * This approach is required rather than simply hiding the option because
 * hidden option can still be included when serializeArray() is called and
 * cause wrong value to be submitted.
 * (eg. if you have option 1, 2, 3 and 2 is hidden, when you select 3,
 * serializeArray() will use the value of 2 instead of 3)
 */
function toggleOption(show) {
  var currentSelectElement = $(this).closest('select'); // the select containing this
  var disabledSelectElement; // the disabled select element
  var selectElement; // the real select element

  if (currentSelectElement.is(':disabled')) {
    disabledSelectElement = currentSelectElement;
    selectElement = disabledSelectElement.data('linkedSelectElement');
  } else {
    selectElement = currentSelectElement;
    disabledSelectElement = currentSelectElement.data('linkedSelectElement');
    if (!disabledSelectElement) {
      // create the disabled placeholder select element
      disabledSelectElement = $('<select>').prop('disabled', true).hide().attr('name', currentSelectElement.attr('name')).addClass(currentSelectElement.attr('class')).data('linkedSelectElement', selectElement).insertAfter(selectElement);
      selectElement.data('linkedSelectElement', disabledSelectElement);
    }
  }

  // save the selected option
  var selectedOption = selectElement.find('option:selected');

  // update .form-selected-text element
  var text = selectElement.find("[value=\"" + selectedOption.val() + "\"]").text();
  var $prefix = selectElement.parents('.form-select-wrapper').data('selected-prefix');
  $prefix = $prefix ? "<span class=\"form-selected-text-prefix\">" + $prefix + "</span>" : '';
  selectElement.siblings('.form-selected-text').html($prefix + text);

  // move the option to the correct select element if required
  if (currentSelectElement.is(':disabled') && show) {
    var previousIndex = this.data('index');
    if (previousIndex > 0) {
      // loop through to put the select element in it's proper place
      for (var i = previousIndex; i > 0; i--) {
        if (selectElement.find("option:eq(" + (i - 1) + ")").length) {
          this.insertAfter(selectElement.find("option:eq(" + (i - 1) + ")"));
          break;
        }
      }
    } else {
      $(this).appendTo(selectElement);
    }
  } else if (!currentSelectElement.is(':disabled') && !show) {
    this.data('index', currentSelectElement.find('option').index(this));
    $(this).prependTo(disabledSelectElement);
  }

  // make sure the option is still selected
  selectedOption.prop('selected', true);
}
$.fn.toggleOption = toggleOption;

/***/ }),

/***/ "./assets/js/theme/core/updateState.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/core/updateState.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateState)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }


/**
 * Return a "State" select input
 * @param  {obj}      responseData - response from utils.api.country.getByName
 * @param  {obj}      stateAttrs - name and ID of field
 * @param  {bool}     useId - should we use the state name or ID as the value?
 * @return {jQuery}   a select input
 */
function stateAsSelect(responseData, stateAttrs, useId) {
  var stateArray = [];
  stateArray.push("<option value=\"\">" + responseData.prefix + "</option>");
  for (var _iterator = _createForOfIteratorHelperLoose(responseData.states), _step; !(_step = _iterator()).done;) {
    var state = _step.value;
    var optionValue = useId ? state.id : state.name;
    stateArray.push("<option value=\"" + optionValue + "\">" + state.name + "</option>");
  }
  var $stateSelect = $('<select>', {
    class: 'form-input form-select',
    id: stateAttrs.stateId,
    name: stateAttrs.stateName,
    required: true,
    'aria-required': true,
    'data-field-type': 'State',
    html: stateArray.join(' ')
  });
  return $stateSelect;
}

/**
 * Return a "State" text input
 * @param  {obj}      stateAttrs - name and ID of field
 * @return {jQuery}   an text input
 */
function stateAsInput(stateAttrs) {
  var $stateInput = $('<input>', {
    class: 'form-input',
    type: 'text',
    id: stateAttrs.stateId,
    name: stateAttrs.stateName,
    'data-field-type': 'State'
  });
  return $stateInput;
}

/**
 * Toggle between a state select and text input
 * @param  {obj}      event    Country select change event
 * @param  {bool}     useId    whether to use the state id or name for option value
 * @param  {Function} callback [description]
 */
function fetchAndUpdateStateInput(event, useId, callback) {
  var $target = $(event.currentTarget);
  var country = $target.val();
  var $stateElement = $('[data-field-type="State"]');
  var stateAttrs = {
    stateId: $stateElement.attr('id'),
    stateName: $stateElement.attr('name')
  };
  var $stateWrapper = $('#FormField_12');
  _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.country.getByName(country, function (err, response) {
    if (response.data.states.length) {
      // build and attach our select input
      var $stateSelect = stateAsSelect(response.data, stateAttrs, useId);
      $stateElement.replaceWith($stateSelect);
      $stateWrapper.toggleClass('form-required', true);
    } else {
      // build and attach our text input
      var $stateInput = stateAsInput(stateAttrs);
      $stateElement.replaceWith($stateInput);
      $stateWrapper.toggleClass('form-required', false);
    }
    var $newStateElement = $('[data-field-type="State"]');
    var $newStateElementParent = $newStateElement.parent();
    var $selectedText = $newStateElementParent.find('.form-selected-text');
    if (response.data.states.length) {
      $newStateElementParent.addClass('form-select-wrapper');
      if ($selectedText.length) {
        $selectedText.text(response.data.prefix);
      } else {
        $newStateElementParent.prepend("<span class=\"form-selected-text\">" + response.data.prefix + "</span>");
      }
      if (callback) {
        callback($newStateElement);
      }
    } else {
      $selectedText.remove();
      $newStateElementParent.removeClass('form-select-wrapper');
    }
  });
}

/**
 * Bind the thing to the change event and export it
 */
function updateState(useId, callback) {
  $(document.body).on('change', '[data-field-type="Country"]', function (event) {
    fetchAndUpdateStateInput(event, useId, callback);
  });
}

/***/ }),

/***/ "./assets/js/theme/global/Dropdown.js":
/*!********************************************!*\
  !*** ./assets/js/theme/global/Dropdown.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Dropdown)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var Dropdown = /*#__PURE__*/function () {
  function Dropdown(el) {
    var _this = this;
    this.$el = $(el);
    this._bindEvents();
    this.timeoutLeave = null;
    this.delayLeave = 300; // Adjust the delay to a value that works best for you

    // Add event listener for scroll
    $(window).on('scroll', function () {
      _this._handleScroll();
    });

    // Apply margin-top initially if user is at the top
    this._handleScroll();
  }
  var _proto = Dropdown.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    // Using mouseenter and mouseleave for better control
    this.$el.on('mouseenter', function (event) {
      return _this2._handleMouseEnter(event);
    });
    this.$el.on('mouseleave', function (event) {
      return _this2._handleMouseLeave(event);
    });

    // Close dropdowns when mouse leaves the navigation container
    $('.navigation-container').on('mouseleave', function () {
      _this2._hideAllChildren(true);
    });

    // Add event listener for mouseover on root list items
    this.$el.find('.mega-nav-root-item').on('mouseover', function (event) {
      _this2._handleRootItemMouseOver(event);
    });
  };
  _proto._handleMouseEnter = function _handleMouseEnter(event) {
    var $dropdown = $(event.currentTarget);
    var $dropdownPanel = $dropdown.find('.dropdown-panel');
    clearTimeout(this.timeoutLeave); // Clear previous leave timeout

    $('.dropdown-open').not($dropdown).removeClass('dropdown-open').find('.dropdown-panel').revealer('hide');

    // Only apply margin-top when at the top
    if ($(window).scrollTop() === 0) {
      $dropdownPanel.css('margin-top', '-5px');
    }
    $dropdown.addClass('dropdown-open');
    $dropdown.find('.top-level-nav-link').addClass('dropdown-open');
    $dropdownPanel.revealer('show');

    // Reset visibility of all tier 3 categories
    $dropdownPanel.find('.mega-nav-child-list-container').removeClass('visible');

    // Remove any existing hover effect
    $dropdownPanel.find('.mega-nav-root-list .mega-nav-root-item').removeClass('hovered');
    $dropdownPanel.find('.mega-nav-root-list a').removeClass('active');

    // Simulate hover for the first immediate tier 2 category
    var $firstTier2 = $dropdownPanel.find('.mega-nav-root-list .mega-nav-root-item').first();
    if ($firstTier2.length > 0) {
      $firstTier2.addClass('hovered');

      // Apply effect to the <a> element inside elements with the class 'hovered'
      $firstTier2.find('a').addClass('active');

      // Show tier 3 categories belonging to the hovered tier 2 category
      var categoryId = $firstTier2.data('category-id');
      var $childList = $dropdownPanel.find('[data-root-category-id="' + categoryId + '"]');
      if ($childList.length > 0) {
        $childList.closest('.mega-nav-child-list-container').addClass('visible');
      }
    }
  };
  _proto._handleMouseLeave = function _handleMouseLeave(event) {
    var $dropdown = $(event.currentTarget);
    var $dropdownPanel = $dropdown.find('.dropdown-panel');
    this.timeoutLeave = setTimeout(function () {
      // Check if mouse pointer is not over the dropdown or its panel
      if (!$dropdown.is(':hover') && !$dropdownPanel.is(':hover')) {
        // Close the dropdown
        $dropdown.removeClass('dropdown-open');
        $dropdownPanel.revealer('hide');
        $dropdown.removeClass('active'); // Remove active class when mouse leaves
        $dropdown.find('.top-level-nav-link').removeClass('dropdown-open');
      }
    }, this.delayLeave);
  };
  _proto._handleRootItemMouseOver = function _handleRootItemMouseOver(event) {
    var $rootItem = $(event.currentTarget);
    var $dropdownPanel = $rootItem.closest('.dropdown-panel');

    // Remove 'hovered' class from all root list items
    $dropdownPanel.find('.mega-nav-root-item').removeClass('hovered');
    // Add 'hovered' class to the current root list item
    $rootItem.addClass('hovered');
    // Show tier 3 categories belonging to the hovered tier 2 category
    var categoryId = $rootItem.data('category-id');
    var $childList = $dropdownPanel.find('[data-root-category-id="' + categoryId + '"]');

    // Hide all child containers
    $dropdownPanel.find('.mega-nav-child-list-container').removeClass('visible');
    if ($childList.length > 0) {
      $childList.closest('.mega-nav-child-list-container').addClass('visible');
    }
  }

  // Handle scroll event to remove margin-top property when scrolled down more than 50px
  ;
  _proto._handleScroll = function _handleScroll() {
    var $dropdownPanel = this.$el.find('.dropdown-panel');
    if ($(window).scrollTop() > 50) {
      $dropdownPanel.css('margin-top', '');
    } else {
      $dropdownPanel.css('margin-top', '0px');
    }
  };
  _proto._hideAllChildren = function _hideAllChildren(removeActive) {
    if (removeActive === void 0) {
      removeActive = false;
    }
    if (removeActive) {
      this.$el.find('[data-mega-nav-root-item]').removeClass('hovered active');
    }
    this.$el.find('.mega-nav-child-list-container').removeClass('visible');
  };
  return Dropdown;
}();


/***/ }),

/***/ "./assets/js/theme/global/FacetedSearch.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/global/FacetedSearch.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FacetedSearch)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var history_js_scripts_bundled_uncompressed_html4_html5_jquery_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history.js/scripts/bundled-uncompressed/html4+html5/jquery.history */ "./node_modules/history.js/scripts/bundled-uncompressed/html4+html5/jquery.history.js");
/* harmony import */ var history_js_scripts_bundled_uncompressed_html4_html5_jquery_history__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(history_js_scripts_bundled_uncompressed_html4_html5_jquery_history__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }





var FacetedSearch = /*#__PURE__*/function () {
  function FacetedSearch(options, callback) {
    var _this = this;
    this.callback = callback;
    this.$body = $(document.body);
    this.options = $.extend({
      config: {
        category: {
          shop_by_price: true
        }
      },
      template: {
        productListing: 'category/product-listing',
        sidebar: 'category/sidebar'
      },
      scope: {
        productListing: '[data-category]',
        sidebar: '[data-category-sidebar]'
      },
      facetToggle: '[data-facet-toggle]',
      moreToggle: '[data-facet-more]',
      moreFacets: '[data-show-more-facets]',
      toggleFacet: function toggleFacet() {
        return console.log('Facet toggled.');
      }
    }, options);
    this.loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_svgIcon__WEBPACK_IMPORTED_MODULE_4__["default"])('spinner') + "</div>"
    };
    this.facetedSearchOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_2__["default"](this.loadingOptions, false, '.listing-sidebar');
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return _this.facetedSearchOverlay.show();
      },
      didUpdate: function didUpdate() {
        return _this.facetedSearchOverlay.hide();
      }
    }, options.callbacks);
    this._bindEvents();
    this._sanitizeFacets();
  }
  var _proto = FacetedSearch.prototype;
  _proto.init = function init(options) {
    this.options.template = $.extend({
      productListing: this.options.template.productListing,
      sidebar: this.options.template.sidebar
    }, options.template);
    this._onStateChange();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$body.on('click', this.options.facetToggle, function (event) {
      _this2._toggleFacet(event);
    });
    this.$body.on('click', this.options.moreToggle, function (event) {
      _this2._showAdditionalFilters(event);
    });
    this.$body.on('click', this.options.moreFacets, function (event) {
      _this2._showMoreFacets(event);
    });
    $(window).on('statechange', this._onStateChange.bind(this));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.hooks.on('facetedSearch-facet-clicked', this._onFacetClick.bind(this));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.hooks.on('facetedSearch-range-submitted', this._onRangeSubmit.bind(this));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.hooks.on('sortBy-submitted', this._onSortBySubmit.bind(this));
  }

  // clean up user defined facet ids / show more links for special characters
  ;
  _proto._sanitizeFacets = function _sanitizeFacets() {
    $('.facet-list-items').each(function (index, element) {
      var oldTargetId = $(element).attr('id');
      var newTargetId = oldTargetId.toLowerCase().replace(/[^a-z0-9-]+/g, '-');
      $(element).attr('id', newTargetId);
    });
    $('.facet-toggle-more').each(function (index, element) {
      var oldHref = $(element).attr('href');
      var newHref = oldHref.toLowerCase().replace(/[^a-z0-9\-#]+/g, '-');
      $(element).attr('href', newHref);
    });
  };
  _proto._showMoreFacets = function _showMoreFacets(event) {
    var _this3 = this;
    // Show/hide extra facets based on settings for product filtering
    event.preventDefault();
    this.callbacks.willUpdate();
    var $toggle = $(event.currentTarget);
    var $navList = $($toggle.attr('href'));
    var facet = $navList.data('facet');
    var facetUrl = "" + window.location.origin + window.location.pathname;
    var params = {
      list_all: facet
    };
    if (window.location.search) {
      var queryString = window.location.search;
      var urlParams = new URLSearchParams(queryString);
      for (var _iterator = _createForOfIteratorHelperLoose(urlParams), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
        params[key] = value;
      }
    }
    if ($toggle.siblings('.faceted-search-option-columns').length == 0) {
      if (this.options.showMore) {
        _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.api.getPage(facetUrl, {
          template: this.options.showMore,
          params: params
        }, function (err, response) {
          if (err) {
            throw new Error(err);
          }
          $(response).insertAfter($navList);
          $toggle.siblings('.faceted-search-option-columns').addClass('visible');
          _this3.callbacks.didUpdate();
        });
      }
    } else {
      $toggle.siblings('.faceted-search-option-columns').toggle();
      this.callbacks.didUpdate();
    }
    $navList.toggle();

    // toggle more/less link
    $toggle.children().toggle();
    return false;
  };
  _proto._showAdditionalFilters = function _showAdditionalFilters(event) {
    event.preventDefault();
    $(event.currentTarget).addClass('hidden').parent('li').siblings('li').removeClass('hidden');
  };
  _proto._toggleFacet = function _toggleFacet(event) {
    this.options.toggleFacet(event);
  };
  _proto._onFacetClick = function _onFacetClick(event, target) {
    event.preventDefault();
    var $target = $(target);
    var url = $target.attr('href');
    this._goToUrl(url);
  };
  _proto._onRangeSubmit = function _onRangeSubmit(event, target) {
    event.preventDefault();
    var url = url__WEBPACK_IMPORTED_MODULE_1__.parse(window.location.href);
    var queryParams = $(target).serialize();
    if (this.$body.hasClass('search')) {
      var currentSearch = "search_query=" + $('[data-faceted-search]').data('search-query') || 0;
      queryParams = currentSearch + "&" + queryParams;
    }
    this._goToUrl(url__WEBPACK_IMPORTED_MODULE_1__.format({
      pathname: url.pathname,
      search: '?' + queryParams
    }));
  };
  _proto._onSortBySubmit = function _onSortBySubmit(event, target) {
    event.preventDefault();
    var url = url__WEBPACK_IMPORTED_MODULE_1__.parse(location.href, true);
    var queryParams = $(target).serialize().split('=');
    url.query[queryParams[0]] = queryParams[1];
    delete url.query['page'];
    this._goToUrl(url__WEBPACK_IMPORTED_MODULE_1__.format({
      pathname: url.pathname,
      query: url.query
    }));
  };
  _proto._onStateChange = function _onStateChange(event) {
    var _this4 = this;
    this.callbacks.willUpdate();
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.api.getPage(History.getState().url, this.options, function (err, content) {
      if (err) {
        throw new Error(err);
        _this4.callbacks.didUpdate();
        return;
      }
      if (content) {
        $(_this4.options.scope.productListing).html(content.productListing);
        $(_this4.options.scope.sidebar).html(content.sidebar);
        _this4.callbacks.didUpdate();
        _this4._sanitizeFacets();
      }
    });
  };
  _proto._goToUrl = function _goToUrl(url) {
    History.pushState({}, document.title, url);
  };
  return FacetedSearch;
}();


/***/ }),

/***/ "./assets/js/theme/global/Header.js":
/*!******************************************!*\
  !*** ./assets/js/theme/global/Header.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Header)
/* harmony export */ });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var Header = /*#__PURE__*/function () {
  function Header(el) {
    this.$el = $(el);
    this.$body = $('body');
    this.$wrapper = $('.site-wrapper');
    this.$searchWrap = $('.search-wrap');
    this.$header = $('.site-header');
    this.$topBar = this.$header.find('.top-bar');
    this.$navBar = this.$header.find('.main-nav-bar');
    this.cartOpenClass = 'mini-cart-open';
    this.searchOpenClass = 'search-open';
    this.navOpenClass = 'nav-mobile-open scroll-locked';
    this.$loginRegister = $('.login-register-block');
    this.$forgotPassword = $('.forgot-password-block');
    this._bindEvents();
    this._adjustHeights();
    this._headerScroll();
  }
  var _proto = Header.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    // Toggle mini cart panel
    this.$el.find('.button-cart-toggle').on('click', function (event) {
      _this._toggleMiniCart();
      event.stopPropagation();
    });

    // Close mini cart panel
    $('.button-cart-close').on('click', function () {
      _this._toggleMiniCart(false);
    });
    $('.on-canvas').on('click', function () {
      if ($('.mini-cart-open').length) {
        _this._toggleMiniCart(false);
      }
    });

    // Close UI elemets with esc key
    $(document).on('keyup', function (e) {
      // Mini cart
      if (e.keyCode === 27 && _this.$body.hasClass(_this.cartOpenClass)) {
        _this._toggleMiniCart(false);
      }

      // Search
      if (e.keyCode === 27 && _this.$searchWrap.hasClass(_this.searchOpenClass)) {
        _this._toggleSearch(false);
      }
    });

    // Toggle search
    $('.button-search-toggle').on('click', function () {
      _this._toggleSearch();

      // Close cart
      if (_this.$wrapper.hasClass(_this.cartOpenClass)) {
        _this._toggleMiniCart(false);
      }
    });

    // Close Search
    $('.button-search-close').on('click', function () {
      _this._toggleSearch(false);
    });

    // Toggle mobile nav
    $('.button-mobile-nav-toggle').on('click', function () {
      _this._toggleMobileNav();
    });

    // Handle resize events and provide debounce to prevent too much
    this._handleResize = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(this._handleResize.bind(this), 200);
    $(window).resize(this._handleResize);
  };
  _proto._handleResize = function _handleResize() {
    // Reset the mobile panel if window is made larger
    this._adjustHeights();

    // Check header height on resize for class application
    this._headerScroll();
  };
  _proto._toggleMiniCart = function _toggleMiniCart(open) {
    // Pass "false" to remove the class / close cart
    this.$body.toggleClass(this.cartOpenClass, open);
  };
  _proto._toggleSearch = function _toggleSearch(open) {
    this.$searchWrap.toggleClass(this.searchOpenClass, open);
    if (this.$searchWrap.hasClass(this.searchOpenClass)) {
      this.$searchWrap.find('.search-input').focus();
    }
  };
  _proto._toggleMobileNav = function _toggleMobileNav(open) {
    this.$body.toggleClass(this.navOpenClass, open);
    if (open === false) {
      $('.navigation-mobile').revealer('hide');
    } else {
      $('.navigation-mobile').revealer('toggle');
    }
  };
  _proto._headerScroll = function _headerScroll() {
    // determine whether the navigtion has a second row, and disallow "compressed" state if true
    var defaultNavbarHeight = 100;
    var $currentNavBar = this.$navBar.find('.navigation').find('ul:first-child');
    var currentNavBarHeight = $currentNavBar.outerHeight();
    if (currentNavBarHeight > defaultNavbarHeight) {
      this.$navBar.addClass('multi-row');
      $currentNavBar.addClass('enforce-max-width');
      return false;
    } else {
      this.$navBar.removeClass('multi-row');
      $currentNavBar.removeClass('enforce-max-width');
    }
    var $win = $(window);
    /*     const threshold = 80;
        const scrollClass = 'compressed';
    
        // if we load the page part way down
        if ($win.scrollTop() > threshold) {
          this.$header.addClass(scrollClass);
        }
    
        $win.resize(() => {
          const compressHeader = false;
          currentNavBarHeight = $currentNavBar.outerHeight();
    
          if (currentNavBarHeight > defaultNavbarHeight) {
            this.$header.toggleClass(scrollClass, compressHeader);
          }
        }); */

    /* $win.scroll(() => {
      const st = $win.scrollTop();
      const compressHeader = (st > 0) ? true : false; // Always compress header on scroll
         this.$header.toggleClass(scrollClass, compressHeader);
    }); */
  };
  _proto._adjustHeights = function _adjustHeights() {
    var $canvas = this.$body.find('.site-canvas');
    var defaultTopBarHeight = 56;
    var topBarHeight = this.$topBar.outerHeight();
    var defaultFullHeaderHeight = 156;
    var currentFullHeaderHeight = this.$header.outerHeight();
    if (this.$header.hasClass('compressed')) {
      $canvas.css('padding-top', defaultTopBarHeight + 'px'); // Remove padding when header is compressed
    } else {
      if (this.$navBar.is(':hidden')) {
        if (topBarHeight > defaultTopBarHeight) {
          $canvas.css('padding-top', topBarHeight + 'px');
        } else {
          $canvas.css('padding-top', defaultTopBarHeight + 'px');
        }
      } else {
        // Calculate the total height of the top bar and the main navigation bar
        var totalHeight = topBarHeight + this.$navBar.outerHeight();

        // If the total height exceeds the default full header height, reduce the top padding of the canvas
        if (totalHeight > defaultFullHeaderHeight) {
          $canvas.css('padding-top', totalHeight + 'px');
        } else {
          $canvas.css('padding-top', defaultFullHeaderHeight + 'px');
        }
      }
    }
    if (topBarHeight > defaultTopBarHeight) {
      var $mobileNav = this.$body.find('.navigation-mobile');
      $mobileNav.css({
        'top': topBarHeight + 'px'
      });
    }
  };
  return Header;
}();


/***/ }),

/***/ "./assets/js/theme/global/MegaNav.js":
/*!*******************************************!*\
  !*** ./assets/js/theme/global/MegaNav.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MegaNav)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var MegaNav = /*#__PURE__*/function () {
  function MegaNav(el) {
    this.$el = $(el);
    this.$rootMenu = this.$el.find('.mega-nav-root-list');
    this.$childContainer = this.$el.find('.mega-nav-child-container');
    this.$dropdownToggle = this.$el.closest('.dropdown').find('.dropdown-toggle');
    this._bindEvents();
    this._hideAllChildren(true);
  }
  var _proto = MegaNav.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    // Change event from 'mouseover' to 'mouseenter' for better performance
    this.$el.on('mouseenter', '[data-mega-nav-root-item]', function (e) {
      e.preventDefault();
      _this._findChildFromRoot(e);
      e.stopPropagation();
    });

    // Add event to remove hover effect when mouse leaves the entire navigation area
    this.$el.on('mouseleave', function () {
      // Remove hover effect from all root items
      _this.$el.find('[data-mega-nav-root-item]').removeClass('hovered');
    });
  };
  _proto._findChildFromRoot = function _findChildFromRoot(e) {
    if (this.dropdownOpen) {
      this._hideAllChildren(true);
    }
    this.dropdownOpen = true;
    var $rootItem = $(e.currentTarget);
    var categoryId = $rootItem.data('category-id');
    var $childList = this.$el.find('[data-root-category-id="' + categoryId + '"]');
    $rootItem.addClass('active');
    clearTimeout(this.childTimer);
    this.childTimer = setTimeout(function () {
      $childList.revealer('show');
    }, 100);
  };
  _proto._findChild = function _findChild(e) {
    if (this.dropdownOpen) {
      this._hideAllChildren(true);
    }
    var $target = $(e.currentTarget);
    var childId = $target.data('mega-nav-child-id');
    var $childList = this.$childContainer.find('[data-root-category-id="' + childId + '"]');

    // Hide all other child categories immediately

    this.$childContainer.find('.mega-nav-child-list-container').removeClass('visible');
    if ($childList.length > 0) {
      // Show the relevant child category after a short delay

      clearTimeout(this.childTimer);
      this.childTimer = setTimeout(function () {
        $childList.closest('.mega-nav-child-list-container').addClass('visible');
      }, 100); // Adjust the delay as needed
    }
    this.dropdownOpen = true;
  };
  _proto._findChild = function _findChild(e) {
    var $target = $(e.currentTarget);
    var childId = $target.data('mega-nav-child-id');
    var $childList = this.$childContainer.find('[data-root-category-id="' + childId + '"]');
    if ($childList.length > 0) {
      this._hideAllChildren();
      window.setTimeout(function () {
        $childList.revealer('show');
      }, 500);
    }
  };
  _proto._findParent = function _findParent(e) {
    var $minus = $(e.currentTarget);
    var parentId = $minus.closest('.mega-nav-child-list-container').data('root-category-id');
    var $parent = this.$childContainer.find('[data-mega-nav-child-id="' + parentId + '"]').closest('.mega-nav-child-list-container');
    if ($parent.length > 0) {
      this._hideAllChildren();
      window.setTimeout(function () {
        $parent.revealer('show');
      }, 500);
    }
  };
  _proto._hideAllChildren = function _hideAllChildren(removeActive) {
    if (removeActive === void 0) {
      removeActive = false;
    }
    if (removeActive) {
      this.$el.find('[data-mega-nav-root-item]').removeClass('active');
    }
    this.$el.find('.mega-nav-child-list-container').revealer('hide');
  };
  _proto._adjustMegaNavPanel = function _adjustMegaNavPanel() {
    var $dropdown = this.$dropdownToggle.closest('.dropdown');
    var $megaNavPanel = $dropdownToggle.find('.mega-nav-panel');
    if ($dropdown.length > 0 && $megaNavPanel.length > 0) {
      var offset = $dropdown.offset().top + $dropdown.outerHeight();
      $megaNavPanel.css({
        'top': offset + 'px'
      });
    }
  };
  return MegaNav;
}();


/***/ }),

/***/ "./assets/js/theme/global/MiniCart.js":
/*!********************************************!*\
  !*** ./assets/js/theme/global/MiniCart.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MiniCart)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var MiniCart = /*#__PURE__*/function () {
  function MiniCart() {
    this.cartChangeRemoteHooks = ['cart-item-add-remote', 'cart-item-update-remote', 'cart-item-remove-remote'];
    this._bindEvents();
  }
  var _proto = MiniCart.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    // Update minicart on successful add to cart
    $(document).on('cart-item-add-success', function () {
      _this._update();
    });

    // Remove cart item using minicart button
    $('body').on('click', '.mini-cart [data-cart-item-remove]', function (event) {
      event.preventDefault();
      _this._removeProductMiniCart(event);
    });

    // remote events: when the proper response is sent
    this.cartChangeRemoteHooks.forEach(function (hook) {
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.on(hook, function () {
        _this._update();
      });
    });

    // Custom scroll UX for minicart
    this._bindScroll();
  }

  /**
   * Update the mini cart contents
   */;
  _proto._update = function _update(callback) {
    var $miniCart = $('.mini-cart-inner');
    var $miniCartTotal = $('.site-header .mini-cart-subtotal');
    var $miniCartContents = $('.mini-cart-contents');

    // Update the minicart items when
    // a product is added / removed
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.getContent({
      template: 'mini-cart/mini-cart-contents'
    }, function (err, response) {
      $miniCartContents.html(response);

      // Update the header subtotal
      var subtotal = $(response).find('[data-cart-subtotal]').text();
      var subtotalRaw = $(response).find('.mini-cart-subtotal').attr('data-cart-subtotal');
      $miniCartTotal.html(subtotal).attr('data-cart-subtotal', subtotalRaw);
      $miniCart.animate({
        top: 0
      });
      if (callback) {
        callback();
      }
    });
  }

  /**
   * Remove a product from the mini cart
   */;
  _proto._removeProductMiniCart = function _removeProductMiniCart(event) {
    var _this2 = this;
    var $el = $(event.currentTarget);
    var itemId = $el.data('product-id');
    if (!itemId) {
      return;
    }
    $el.closest('.mini-cart-item').addClass('removing').append("" + (0,_svgIcon__WEBPACK_IMPORTED_MODULE_1__["default"])('spinner'));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.itemRemove(itemId, function (err, response) {
      if (response.data.status === 'succeed') {
        _this2._update();
      } else {
        alert(response.data.errors.join('\n'));
        $el.closest('.mini-cart-item').removeClass('removing').find('.icon-spinner').remove();
      }
    });
  }

  /**
   * Custom scroll behavior for mini cart panel
   */;
  _proto._bindScroll = function _bindScroll() {
    var $win = $(window);
    var $miniCart = $('.mini-cart-inner');
    var oldScrollTop = $(window).scrollTop();
    $win.on('scroll', function () {
      var winHeight = $win.height();
      var miniCartHeight = $miniCart.height();
      var maxScroll = miniCartHeight - winHeight;
      var newScrollTop = $win.scrollTop();
      var cartTopPos = parseInt($miniCart.css('top'));
      var scrollAmount;

      // If the menu is taller than the window and visible
      if (miniCartHeight > winHeight && $('body').hasClass('mini-cart-open')) {
        // Set the amount we've scrolled
        scrollAmount = oldScrollTop - newScrollTop;

        // Move the minicart up/down the amount we scrolled
        $miniCart.css({
          top: '+=' + scrollAmount
        });

        // Get the minicart's top value after it's updated
        cartTopPos = parseInt($miniCart.css('top'));

        // Don't scroll beyond the bottom or top limits of the menu
        // The second conditon checks for 'overscroll' that occurs in webkit
        if (cartTopPos < -maxScroll || newScrollTop + winHeight >= $('.site-wrapper').outerHeight()) {
          // stop at bottom of minicart
          $miniCart.css({
            top: -maxScroll + 'px'
          });
        } else if (cartTopPos > 0 || newScrollTop <= 0) {
          // stop at top of minicart
          $miniCart.css({
            top: 0
          });
        }
      }

      // Update oldScrollTop as we scroll
      oldScrollTop = newScrollTop;
    });
  };
  return MiniCart;
}();


/***/ }),

/***/ "./assets/js/theme/global/MobileNav.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/global/MobileNav.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MobileNav)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var MobileNav = /*#__PURE__*/function () {
  function MobileNav() {
    this.$body = $('body');
    this.navToggle = $('.button-mobile-nav-toggle');
    this.pageCover = $('.site-wrapper');
    this.$menu = $('.navigation');
    this.$navBackButton = $('.button-mobile-nav-back');
    this.getMenus = function (targetMenu) {
      return $("[data-mobile-menu=\"" + targetMenu + "\"]");
    };
    this.navPanel = '.nav-mobile-panel';
    this.classes = {
      active: 'is-active',
      left: 'is-left',
      right: 'is-right',
      forceState: 'force-state'
    };
    this.menuState = [];
    this._initMobile();
    this._bindMobileEvents();
  }
  var _proto = MobileNav.prototype;
  _proto._initMobile = function _initMobile() {
    $('.nav-mobile-item-parent').each(function (index, element) {
      var $children = $(element).children('.nav-mobile-panel');
      var counter = 1;
      while ($children.length) {
        $children.attr('data-panel-depth', counter).insertAfter($('.nav-mobile-panel-parent'));
        $children = $children.children().children('.nav-mobile-panel');
        counter += 1;
      }
    });
  };
  _proto._bindMobileEvents = function _bindMobileEvents() {
    var _this = this;
    $('.nav-mobile-item.has-children').on('click', function (event) {
      event.preventDefault();
      _this._traverseDown(event);
    });
    this.$navBackButton.on('click', function (event) {
      _this._traverseBack();
    });
  };
  _proto._traverseDown = function _traverseDown(event) {
    var targetMenu = $(event.currentTarget).children().data('toggle-mobile');
    this.$body.addClass('mobile-nav-open');

    // Move previous active to the left
    $(event.currentTarget).closest(this.navPanel).addClass(this.classes.left).removeClass(this.classes.active);

    // Active new menu and move into place from right
    this.getMenus(targetMenu).removeClass(this.classes.right).addClass(this.classes.active);

    // Update the back button id
    var prevMenu = $(event.currentTarget).parents('.nav-mobile-panel').data('mobile-menu');
    this.menuState.push(prevMenu);
  };
  _proto._traverseBack = function _traverseBack() {
    // Move previous active to the right
    $(this.navPanel).filter("." + this.classes.active).removeClass(this.classes.active).addClass(this.classes.right);

    // Position new active menu from the left
    var targetMenu = this.menuState.pop();
    this.getMenus(targetMenu).removeClass(this.classes.left).addClass(this.classes.active);
    if (targetMenu === 'all') {
      this.$body.removeClass('mobile-nav-open');
    }
  };
  return MobileNav;
}();


/***/ }),

/***/ "./assets/js/theme/global/fillFacetRatingStars.js":
/*!********************************************************!*\
  !*** ./assets/js/theme/global/fillFacetRatingStars.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  $('.product-item-rating-facet.full').prevAll('.product-item-rating-facet').addClass('full');
}

/***/ }),

/***/ "./assets/js/theme/global/initCompare.js":
/*!***********************************************!*\
  !*** ./assets/js/theme/global/initCompare.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initCompare: () => (/* binding */ initCompare),
/* harmony export */   updateCompare: () => (/* binding */ updateCompare)
/* harmony export */ });
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/template */ "./node_modules/lodash/template.js");
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_template__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var bc_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bc-compare */ "./node_modules/bc-compare/dist/js/ProductCompare.js");
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");



var compare = new bc_compare__WEBPACK_IMPORTED_MODULE_1__["default"]({
  maxItems: 4,
  itemTemplate: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <li class=\"compare-tab-item\" data-compare-item>\n      <div class=\"compare-tab-item-wrap\">\n        <a class=\"compare-tab-item-remove\" data-compare-item-remove=\"<%= id %>\">" + (0,_svgIcon__WEBPACK_IMPORTED_MODULE_2__["default"])('close') + "</a>\n        <a href=\"<%= url %>\">\n          <div class=\"compare-tab-item-thumb\" style=\"background-image: url(<%= thumbnail %>)\"></div>\n        </a>\n\n        <div class=\"compare-tab-item-description\">\n          <a href=\"<%= url %>\" class=\"compare-tab-item-title\"><%= title %></a>\n          <div class=\"compare-tab-item-price\"><%= price %></div>\n        </div>\n      </div>\n    </li>\n  ")
});
function initCompare() {
  compare.on('updated', function () {
    $('.compare-items-count').text(compare.compareList.size);
    if (compare.compareList.size > 0) {
      $('[data-compare-widget], .mobile-compare-link').addClass('compare-active');
    } else {
      $('[data-compare-widget], .mobile-compare-link').removeClass('compare-active');
    }
  }, true);
  $('[data-compare-remove-all]').on('click', function (event) {
    event.preventDefault();
    compare.removeAll();
  });
}
function updateCompare() {
  compare.updateCheckboxes();
}

/***/ }),

/***/ "./assets/js/theme/global/quick-search.js":
/*!************************************************!*\
  !*** ./assets/js/theme/global/quick-search.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var QuickSearch = /*#__PURE__*/function () {
  function QuickSearch() {
    this.debounceWaitTime = 300; // Adjust debounce time as needed
    this.$quickSearchResults = $('.quickSearchResults');
    this.$quickSearchForms = $('[data-quick-search-form]');
    this.$searchQuery = this.$quickSearchForms.find('[data-search-quick]');
    this.$quickSearchAriaMessage = $('.aria-description--hidden');
    this.searchResultsVisible = false; // Track if search results are visible

    this._bindEvents();
  }
  var _proto = QuickSearch.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    var doSearch = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(function (searchQuery) {
      if (searchQuery.length === 0) {
        _this.$quickSearchResults.empty();
        _this.$quickSearchAriaMessage.empty(); // Clear aria-live region
        _this.searchResultsVisible = false;
        return;
      }
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.search.search(searchQuery, {
        template: 'search/quick-results'
      }, function (err, response) {
        if (err) {
          return false;
        }
        _this.$quickSearchResults.html(response);
        var $quickSearchResultsCurrent = _this.$quickSearchResults.filter(':visible');
        var $noResultsMessage = $quickSearchResultsCurrent.find('.quickSearchMessage');
        if ($noResultsMessage.length) {
          $noResultsMessage.attr({
            role: 'status',
            'aria-live': 'polite'
          });
          _this.$quickSearchAriaMessage.empty(); // Clear aria-live region
        } else {
          _this.$quickSearchAriaMessage.addClass('u-hidden');
          var predefinedText = _this.$quickSearchAriaMessage.data('search-aria-message-predefined-text');
          var itemsFoundCount = $quickSearchResultsCurrent.find('.product').length;
          _this.$quickSearchAriaMessage.text(itemsFoundCount + " " + predefinedText + " " + searchQuery);
          setTimeout(function () {
            _this.$quickSearchAriaMessage.removeClass('u-hidden');
          }, 100);
        }
        _this.searchResultsVisible = true; // Mark search results as visible
      });
    }, this.debounceWaitTime);
    this.$searchQuery.on('input', function (event) {
      var searchQuery = $(event.currentTarget).val();
      if (searchQuery.length === 0) {
        _this.$quickSearchResults.empty(); // Hide results if input is cleared
        _this.$quickSearchAriaMessage.empty(); // Clear aria-live region
        _this.searchResultsVisible = false;
      }
      $(event.currentTarget).trigger('search-quick', event.currentTarget);
    });
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.on('search-quick', function (event, currentTarget) {
      var searchQuery = $(currentTarget).val();
      doSearch(searchQuery);
    });

    // Hide search results when clicking outside
    $(document).on('click', function (event) {
      if (!$(event.target).closest(_this.$quickSearchForms).length) {
        _this.$quickSearchResults.empty(); // Hide results
        _this.searchResultsVisible = false;
      }
    });

    // Show search results when focusing on the search bar
    this.$searchQuery.on('focus', function (event) {
      if (_this.searchResultsVisible && _this.$searchQuery.val().length > 0) {
        var searchQuery = _this.$searchQuery.val();
        doSearch(searchQuery); // Re-fetch the results
      }
    });
  };
  return QuickSearch;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (QuickSearch);

/***/ }),

/***/ "./assets/js/theme/global/svgIcon.js":
/*!*******************************************!*\
  !*** ./assets/js/theme/global/svgIcon.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(iconClass) {
  return "<svg class=\"icon icon-" + iconClass + "\"><use xlink:href=\"#icon-" + iconClass + "\" /></svg>";
}
;

/***/ }),

/***/ "./assets/js/theme/global/toggleFacet.js":
/*!***********************************************!*\
  !*** ./assets/js/theme/global/toggleFacet.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  var $target = $(event.currentTarget);
  var $trigger = $target.find('.facet-list-toggle');
  $target.parents('[data-facet-filter]').children('[data-facet-filter-wrapper]').toggleClass('is-open');
  if ($target.hasClass('is-open')) {
    $trigger.html((0,_svgIcon__WEBPACK_IMPORTED_MODULE_0__["default"])('minus'));
  } else {
    $trigger.html((0,_svgIcon__WEBPACK_IMPORTED_MODULE_0__["default"])('plus'));
  }
  $target.toggleClass('is-open');
}

/***/ }),

/***/ "./assets/js/theme/product/AttributesHelper.js":
/*!*****************************************************!*\
  !*** ./assets/js/theme/product/AttributesHelper.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AttributesHelper)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var AttributesHelper = /*#__PURE__*/function () {
  function AttributesHelper(el) {
    this.el = el;
  }
  var _proto = AttributesHelper.prototype;
  _proto.updateAttributes = function updateAttributes(data) {
    var _this = this;
    if (data === undefined) {
      return;
    }
    var behavior = data.out_of_stock_behavior;
    var inStockIds = data.in_stock_attributes;
    var outOfStockMessage = " (" + data.out_of_stock_message + ")";
    if (behavior !== 'hide_option' && behavior !== 'label_option') {
      return;
    }
    $('[data-product-attribute-value]', $('body').find(this.el)).each(function (i, attribute) {
      var $attribute = $(attribute);
      var attrId = parseInt($attribute.data('product-attribute-value'), 10);
      if (inStockIds.indexOf(attrId) !== -1) {
        _this.enableAttribute($attribute, behavior, outOfStockMessage);
      } else {
        _this.disableAttribute($attribute, behavior, outOfStockMessage);
      }
    });
  };
  _proto.disableAttribute = function disableAttribute($attribute, behavior, outOfStockMessage) {
    if (this.getAttributeType($attribute) === 'set-select') {
      return this.disableSelectOptionAttribute($attribute, behavior, outOfStockMessage);
    }
    if (behavior === 'hide_option') {
      $attribute.hide();
    } else {
      $attribute.addClass('option-unavailable');
    }
  };
  _proto.disableSelectOptionAttribute = function disableSelectOptionAttribute($attribute, behavior, outOfStockMessage) {
    if (behavior === 'hide_option') {
      $attribute.toggleOption(false);
    } else {
      $attribute.attr('disabled', 'disabled');
      $attribute.html($attribute.html().replace(outOfStockMessage, '') + outOfStockMessage);
    }
  };
  _proto.enableAttribute = function enableAttribute($attribute, behavior, outOfStockMessage) {
    if (this.getAttributeType($attribute) === 'set-select') {
      return this.enableSelectOptionAttribute($attribute, behavior, outOfStockMessage);
    }
    if (behavior === 'hide_option') {
      $attribute.show();
    } else {
      $attribute.removeClass('option-unavailable');
    }
  };
  _proto.enableSelectOptionAttribute = function enableSelectOptionAttribute($attribute, behavior, outOfStockMessage) {
    if (behavior === 'hide_option') {
      $attribute.toggleOption(true);
    } else {
      $attribute.removeAttr('disabled');
      $attribute.html($attribute.html().replace(outOfStockMessage, ''));
    }
  };
  _proto.getAttributeType = function getAttributeType($attribute) {
    var $parent = $attribute.closest('[data-product-attribute]');
    return $parent ? $parent.data('product-attribute') : null;
  };
  return AttributesHelper;
}();


/***/ }),

/***/ "./assets/js/theme/product/ColorSwatch.js":
/*!************************************************!*\
  !*** ./assets/js/theme/product/ColorSwatch.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ColorSwatch)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/**
 *  Attach functionality to Color Swatches
 *
 * Example: new ColorSwatch('.color-swatch-item')
 *          (defaults to [data-swatch-selector])
 */
var ColorSwatch = /*#__PURE__*/function () {
  function ColorSwatch(el) {
    if (el === void 0) {
      el = "[data-swatch-selector]";
    }
    this.$el = $(el);
    this.bindSwatchEvent();
    this.$el.find('[data-default]').click();
  }

  // Update Swatch text when color is selected
  var _proto = ColorSwatch.prototype;
  _proto.bindSwatchEvent = function bindSwatchEvent() {
    this.$el.on('click', 'label', function (e) {
      var $target = $(e.currentTarget);
      var $swatchText = $target.closest('[data-swatch-selector]').find('.swatch-value');
      var $swatchValue = $target.data('swatch-value');
      $swatchText.text($swatchValue);
    });
  };
  return ColorSwatch;
}();


/***/ }),

/***/ "./assets/js/theme/product/ImageZoom.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/product/ImageZoom.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageZoom)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var ImageZoom = /*#__PURE__*/function () {
  function ImageZoom(el) {
    this.$el = $(el);

    // create empty image
    var defaultImg = new Image();
    // set src so we can access the other attribute data
    defaultImg.src = this.$el.find('img').attr('src');
    this.image = {
      offset: this.$el.offset(),
      width: this.$el.width(),
      height: this.$el.height()
    };

    // Only init if image is wide enough to zoom
    if (defaultImg.width / this.image.width > 1.4) {
      this._bindEvents();
    } else {
      this.$el.addClass('no-zoom').height(this.$el.parent().height());
    }
  }
  var _proto = ImageZoom.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.$el.on('mousemove', function (event) {
      _this._zoomImage(event);
    });
  };
  _proto._zoomImage = function _zoomImage(event) {
    var $wrapper = $('.product-slides-wrap').offset();
    var topOffset = $wrapper.top;
    var leftOffset = $wrapper.left;
    var top = (event.pageY - topOffset) / this.image.height * 100;
    var left = (event.pageX - leftOffset) / this.image.width * 100;
    this.$el.css('background-position', left + "% " + top + "%");
  };
  return ImageZoom;
}();


/***/ }),

/***/ "./assets/js/theme/product/ProductImages.js":
/*!**************************************************!*\
  !*** ./assets/js/theme/product/ProductImages.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProductImages)
/* harmony export */ });
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slick-carousel */ "./node_modules/slick-carousel/slick/slick.js");
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(slick_carousel__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ImageZoom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ImageZoom */ "./assets/js/theme/product/ImageZoom.js");
/* harmony import */ var baguettebox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! baguettebox.js */ "./node_modules/baguettebox.js/dist/baguetteBox.min.js");
/* harmony import */ var baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(baguettebox_js__WEBPACK_IMPORTED_MODULE_3__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");




var ProductImages = /*#__PURE__*/function () {
  function ProductImages(el) {
    this.$el = $(el);
    this.maxSlidesBeforeArrows = 5;
    this.classes = {
      container: '.product-images-container',
      slidesWrap: '.product-slides-wrap',
      pagination: '.product-images-pagination',
      paginationItem: '.pagination-item',
      loader: '.product-images-loader'
    };
    this.$pagination = this.$el.closest(this.classes.container).find(this.classes.pagination);
    this._init();
  }
  var _proto = ProductImages.prototype;
  _proto._init = function _init() {
    var _this = this;
    imagesloaded__WEBPACK_IMPORTED_MODULE_1___default()(this.$el[0], function () {
      // Hide loader
      _this.$el.parents(_this.classes.container).find(_this.classes.loader).addClass('initialized');

      // Image zoom
      _this.$el.on('init', function () {
        _this.$el.find('[data-product-image]').each(function (i, el) {
          new _ImageZoom__WEBPACK_IMPORTED_MODULE_2__["default"](el);
        });
      });

      // Init carousel
      _this.$el.slick({
        infinite: false,
        arrows: false,
        dots: false,
        adaptiveHeight: true,
        asNavFor: _this.classes.pagination
      });
      _this.imageCount = _this.$pagination.find(_this.classes.paginationItem).length;
      if (_this.imageCount > _this.maxSlidesBeforeArrows) {
        _this.$pagination.addClass('pagination-has-arrows');
      }
      _this.$pagination.on('setPosition', function (event, slick) {
        if (slick.$slides.length > _this.maxSlidesBeforeArrows) {
          _this.$pagination.addClass('pagination-has-arrows');
        } else {
          _this.$pagination.removeClass('pagination-has-arrows');
        }
      });
      _this.$pagination.slick({
        infinite: false,
        centerMode: false,
        dots: false,
        lazyLoad: 'progressive',
        arrows: true,
        prevArrow: '<div class="product-images-pagination-icon pagination-prev"><svg><use xlink:href="#icon-arrow-left" /></svg></div>',
        nextArrow: '<div class="product-images-pagination-icon pagination-next"><svg><use xlink:href="#icon-arrow-right" /></svg></div>',
        slidesToShow: 5,
        slidesToScroll: 1,
        variableWidth: false,
        rows: 0,
        asNavFor: _this.classes.slidesWrap,
        focusOnSelect: true
      });
      baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().run(_this.classes.slidesWrap, {});
    });
  };
  return ProductImages;
}();


/***/ }),

/***/ "./assets/js/theme/product/ProductReviews.js":
/*!***************************************************!*\
  !*** ./assets/js/theme/product/ProductReviews.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProductReviews)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var ProductReviews = /*#__PURE__*/function () {
  function ProductReviews(context) {
    this.context = context;
    this._bindRating();
  }
  var _proto = ProductReviews.prototype;
  _proto._bindRating = function _bindRating() {
    $('#rating-stars').on('change', function (event) {
      var rating = $(event.currentTarget).val();
      var ratingLabel = $(event.currentTarget).find('option:selected').text();
      $('.review-form').find('.icon-star-wrap').removeClass('full').each(function (index, el) {
        if (index + 1 <= rating) {
          $(el).addClass('full');
        }
      });
      $('.review-form').find('.rating-stars-label').html(ratingLabel);
    });
  };
  return ProductReviews;
}();


/***/ }),

/***/ "./assets/js/theme/product/ProductUtils.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/product/ProductUtils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProductUtils)
/* harmony export */ });
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _utils_FormValidator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/FormValidator */ "./assets/js/theme/utils/FormValidator.js");
/* harmony import */ var _utils_ProgressButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/ProgressButton */ "./assets/js/theme/utils/ProgressButton.js");
/* harmony import */ var _resetProductImages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resetProductImages */ "./assets/js/theme/product/resetProductImages.js");
/* harmony import */ var _AttributesHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AttributesHelper */ "./assets/js/theme/product/AttributesHelper.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }






var ProductUtils = /*#__PURE__*/function () {
  function ProductUtils(el, options) {
    this.$el = $(el);
    this.options = $.extend({
      onImageSwitch: function onImageSwitch() {}
    }, options);
    this.productId = this.$el.find('[data-product-id]').val();
    this.pageAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_2__["default"]($('[data-alerts]'));
    this.productAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_2__["default"]($('[data-product-alerts]'));
    this.productTitle = $(el).data('product-title');
    this.$productContainer = $('[data-product-container]');
    this.productAttributesData = window.BCData.product_attributes;
    this.$form = this.$el.find('form[data-cart-item-add]');
    this.$addToCart = this.$form.find('[data-button-purchase]');
    this.attributesHelper = new _AttributesHelper__WEBPACK_IMPORTED_MODULE_6__["default"](el);
    this.progressButton = new _utils_ProgressButton__WEBPACK_IMPORTED_MODULE_4__["default"]();
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      },
      switchImage: function switchImage(url) {
        return console.log("Image switch attempted for " + url);
      }
    }, options.callbacks);
    this._boundProductOptionChange = this._bindProductOptionChange.bind(this);
    this.boundCartCallback = this._bindAddToCart.bind(this);
    this._bindEvents();
  }
  var _proto = ProductUtils.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.$el.find('.product-quantity-toggle').on('click', function (event) {
      _this._updateQuantity(event);
    });
    this.$el.find('.product-quantity').on('focusout', function (event) {
      _this._checkQuantity(event.currentTarget);
    });
  };
  _proto.init = function init(context) {
    var _this2 = this;
    this.context = context;
    var $productOptionsElement = $('[data-product-option-change]', this.$form);
    var hasOptions = $productOptionsElement.length > 0 ? true : false;
    var hasDefaultOptions = $productOptionsElement.find('[data-default]').length;
    if (hasDefaultOptions || lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default()(this.productAttributesData) && hasOptions) {
      var $productId = $('[name="product_id"]', this.$form).val();
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.productAttributes.optionChange($productId, this.$form.serialize(), 'products/add-to-cart-form', function (err, response) {
        var attributesData = response.data || {};
        var attributesContent = response.content || {};
        _this2.attributesHelper.updateAttributes(attributesData);
        if (hasDefaultOptions) {
          _this2._updateView(attributesData);
        }
      });
    } else {
      this.attributesHelper.updateAttributes(this.productAttributesData);
    }
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.on('product-option-change', this._boundProductOptionChange);
    this._bindAddWishlist();
    this.Validator = new _utils_FormValidator__WEBPACK_IMPORTED_MODULE_3__["default"](this.context);
    this.Validator.initSingle(this.$el.find('form[data-cart-item-add]'));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.on('cart-item-add', this.boundCartCallback);

    // Trigger a change event so the values are correct for pre-selected options
    this.$el.find('[data-cart-item-add]').find('input[type="radio"], input[type="checkbox"], select').first().change();
  }

  /**
   *
   * Cleanup - useful for closing quickshop modals
   *
   */;
  _proto.destroy = function destroy() {
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.off('cart-item-add', this.boundCartCallback);
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.off('product-option-change', this._boundProductOptionChange);
  }

  /**
   * Cache an object of jQuery elements for DOM updating
   * @param  jQuery $el - a wrapping element of the scoped product
   * @return {object} - buncha jQuery elements which may or may not exist on the page
   */;
  _proto._getViewModel = function _getViewModel($el) {
    return {
      $price: $('[data-product-price-wrapper="without-tax"]', $el),
      $priceWithTax: $('[data-product-price-wrapper="with-tax"]', $el),
      $saved: $('[data-product-price-saved]', $el),
      $sku: $('[data-product-sku]', $el),
      $weight: $('[data-product-weight]', $el),
      $addToCart: $('[data-button-purchase]', $el),
      $imagePreview: $('[data-variation-preview]', $el),
      stock: {
        $selector: $('[data-product-stock]', $el),
        $level: $('[data-product-stock-level]', $el)
      }
    };
  }

  /**
  * https://stackoverflow.com/questions/49672992/ajax-request-fails-when-sending-formdata-including-empty-file-input-in-safari
  * Safari browser with jquery 3.3.1 has an issue uploading empty file parameters. This function removes any empty files from the form params
  * @param formData: FormData object
  * @returns FormData object
  */;
  _proto.filterEmptyFilesFromForm = function filterEmptyFilesFromForm(formData) {
    try {
      for (var _iterator = _createForOfIteratorHelperLoose(formData), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
          key = _step$value[0],
          val = _step$value[1];
        if (val instanceof File && !val.name && !val.size) {
          formData.delete(key);
        }
      }
    } catch (e) {
      console.error(e); // eslint-disable-line no-console
    }
    return formData;
  }

  /**
   * Bind product options changes.
   */;
  _proto._bindProductOptionChange = function _bindProductOptionChange(_ref, changedOption) {
    var _this3 = this;
    var target = _ref.target;
    var formProductId = target.closest('[data-product-id]').dataset.productId;
    if (formProductId !== this.productId) {
      return;
    }
    var $changedOption = $(changedOption);
    var $form = $changedOption.parents('form');

    // Do not trigger an ajax request if it's a file or if the browser doesn't support FormData
    if ($changedOption.attr('type') === 'file' || window.FormData === undefined) {
      return;
    }
    this.pageAlerts.clear();
    this.productAlerts.clear();
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.productAttributes.optionChange(this.productId, $form.serialize(), 'products/add-to-cart-form', function (err, response) {
      var productAttributesData = response.data || {};
      var productAttributesContent = response.content || {};

      // If our form data doesn't include the product-options-count with a positive value, return
      if (_this3.$el.find('[data-product-options-count]').val < 1) {
        return;
      }
      _this3.attributesHelper.updateAttributes(productAttributesData);
      _this3._updateView(productAttributesData);
      _this3.setProductVariant();
    });
  };
  _proto._updateView = function _updateView(data) {
    var _this4 = this;
    var viewModel = this._getViewModel(this.$el);

    // updating price
    if (viewModel.$price.length) {
      var priceStrings = {
        price: data.price,
        excludingTax: this.context.productExcludingTax,
        salePriceLabel: this.context.salePriceLabel,
        nonSalePriceLabel: this.context.nonSalePriceLabel,
        retailPriceLabel: this.context.retailPriceLabel,
        priceLabel: this.context.priceLabel
      };
      viewModel.$price.html(this.options.priceWithoutTaxTemplate(priceStrings));
    }
    if (viewModel.$priceWithTax.length) {
      var _priceStrings = {
        price: data.price,
        includingTax: this.context.productIncludingTax,
        salePriceLabel: this.context.salePriceLabel,
        nonSalePriceLabel: this.context.nonSalePriceLabel,
        retailPriceLabel: this.context.retailPriceLabel,
        priceLabel: this.context.priceLabel
      };
      viewModel.$priceWithTax.html(this.options.priceWithTaxTemplate(_priceStrings));
    }
    if (viewModel.$saved.length) {
      var _priceStrings2 = {
        price: data.price,
        savedString: this.context.productYouSave
      };
      viewModel.$saved.html(this.options.priceSavedTemplate(_priceStrings2));
    }

    // if stock view is on (CP settings)
    if (viewModel.stock.$selector.length && data.stock !== null) {
      viewModel.stock.$selector.removeClass('product-details-hidden');
      viewModel.stock.$level.text(data.stock);
    } else {
      viewModel.stock.$selector.addClass('product-details-hidden');
    }

    // update sku if exists
    if (viewModel.$sku.length) {
      viewModel.$sku.html(data.sku);
    }

    // update weight if exists
    if (data.weight && viewModel.$weight.length) {
      viewModel.$weight.html(data.weight.formatted);
    }

    // handle product variant image if exists
    if (data.image) {
      var productImageUrl = _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].tools.image.getSrc(data.image.data, this.context.themeImageSizes.zoom);
      var zoomImageUrl = _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].tools.image.getSrc(data.image.data, this.context.themeImageSizes.product);

      // to maintain a reference between option images, pull out the
      // filename from the image URL and use it as an ID
      var imageId = data.image.data.replace(/^.*[\\\/]/, '');
      this.callbacks.switchImage(productImageUrl, zoomImageUrl, data.image.alt, imageId);
    } else if (this.$el.find('[data-product-image-variant]').length) {
      (0,_resetProductImages__WEBPACK_IMPORTED_MODULE_5__["default"])(this.$el.find('.product-slides-wrap'));
    }

    // update submit button state
    if (!data.purchasable || !data.instock) {
      var out_of_stock_message = data.out_of_stock_message,
        stock_message = data.stock_message,
        purchasing_message = data.purchasing_message;
      if ($('.modal-quick-shop').length) {
        this.productAlerts.error(out_of_stock_message || stock_message || purchasing_message, true);
      } else {
        setTimeout(function () {
          _this4.pageAlerts.error(out_of_stock_message || stock_message || purchasing_message, true);
        }, 50);
      }
      viewModel.$addToCart.addClass(this.buttonDisabledClass).prop('disabled', true).children('.button-text').text(this.context.soldOutButtonLabel);
    } else {
      viewModel.$addToCart.removeClass(this.buttonDisabledClass).prop('disabled', false).children('.button-text').text(this.context.addToCartButtonLabel);
    }
  };
  _proto._updateQuantity = function _updateQuantity(event) {
    var $target = $(event.currentTarget);
    var $quantity = $target.closest('.product-quantity-container').find('.product-quantity');
    var min = parseInt($quantity.prop('min'), 10);
    var max = parseInt($quantity.prop('max'), 10);
    var newQuantity = parseInt($quantity.val(), 10);
    if (isNaN(newQuantity)) {
      newQuantity = min;
    }
    if ($target.hasClass('product-quantity-increment') && (!max || newQuantity < max)) {
      newQuantity = newQuantity + 1;
    } else if ($target.hasClass('product-quantity-decrement') && newQuantity > min) {
      newQuantity = newQuantity - 1;
    }
    $quantity.val(newQuantity);
  }

  /**
   * Add to cart
   */;
  _proto._bindAddToCart = function _bindAddToCart(event, form) {
    var _this5 = this;
    event.preventDefault();

    // Skip this callback if the product isn't the one this instance is tracking
    var formProductId = event.target.querySelector('[name=product_id]').value;
    if (formProductId !== this.productId) return;

    // Bail out if browser doesn't support FormData
    if (window.FormData === undefined) {
      return;
    }
    var quantity = this.$el.find('input.product-quantity').val();
    var formData = new FormData(form);

    // Update the button state
    this.progressButton.progress(this.$addToCart);

    // Remove old alerts
    this.pageAlerts.clear();
    this.productAlerts.clear();

    // Ajax add item to cart
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.cart.itemAdd(this.filterEmptyFilesFromForm(formData), function (err, response) {
      // Parse the ajax response so we can pass it to the message.
      response = _this5._parseResponse(err, response, _this5.productTitle, quantity);
      if (response.status === 'success') {
        setTimeout(function () {
          _this5.pageAlerts.message(response.message, response.status, true);
        }, 50);

        // Custom success event to close the quick shop and open the mini cart
        $.event.trigger('cart-item-add-success');
        setTimeout(function () {
          _this5.pageAlerts.clear();
        }, 5000);
      } else {
        _this5.productAlerts.message(response.message, response.status, true);
      }

      // Reset the button state
      _this5.progressButton.complete(_this5.$addToCart);
    });
  }

  /**
   * Build our error/success messages based on response.
   * @param {object} err - the (potential) returned error object.
   * @param {object} response - the ajax response from the add-to-cart action.
   * @param {string} title - The name of the added product.
   * @param {number} quantity - The added quantity.
   */;
  _proto._parseResponse = function _parseResponse(err, response, title, quantity) {
    var message = '';
    var status = '';
    if (err || response.data.error) {
      status = 'error';
      if (response.data.error) {
        message = response.data.error;
      } else {
        message = this.context.messagesProductGeneral;
      }
    } else {
      status = 'success';
      if (this.$productContainer.hasClass('bag-icon')) {
        message = this.context.messagesProductAddSuccessBag;
        message = message.replace('*product*', "\"" + title + "\"").replace('*bag_link*', "<a href=" + this.context.urlsCart + ">" + this.context.bagLink + "</a>").replace('*checkout_link*', "<a href=" + this.context.urlsCheckout + ">" + this.context.checkoutLink + "</a>");
      } else {
        message = this.context.messagesProductAddSuccessCart;
        message = message.replace('*product*', "\"" + title + "\"").replace('*cart_link*', "<a href=" + this.context.urlsCart + ">" + this.context.cartLink + "</a>").replace('*checkout_link*', "<a href=" + this.context.urlsCheckout + ">" + this.context.checkoutLink + "</a>");
      }
    }
    return {
      status: status,
      message: message
    };
  };
  _proto._checkQuantity = function _checkQuantity(el) {
    var $el = $(el);
    var quantity = parseInt($el.val(), 10);
    var min = parseInt($el.prop('min'));
    if (isNaN(quantity) || quantity < min) {
      $el.val(min);
    }
  }

  /**
   * Ajax add to wishlist
   *
   */;
  _proto._bindAddWishlist = function _bindAddWishlist() {
    var _this6 = this;
    $('[data-wishlist]').on('click', function (event) {
      var $button = $(event.currentTarget);
      var addUrl = $button.attr('href');
      var viewUrl = $button.data('wishlist');
      if ($('[data-is-customer]').length) {
        event.preventDefault();
        _this6.progressButton.progress($button);
        $.ajax({
          type: 'POST',
          url: addUrl,
          success: function success() {
            _this6.productAlerts.success(_this6.context.messagesWishlistAddSuccess.replace('*product*', _this6.productTitle).replace('*url*', viewUrl), true);
          },
          error: function error() {
            _this6.productAlerts.error(_this6.context.messagesWishlistAddError.replace('*product*', _this6.productTitle), true);
          },
          complete: function complete() {
            _this6.progressButton.complete($button);
            $button.closest('[data-wishlist-dropdown]').find('[data-wishlist-toggle]').trigger('click');
          }
        });
      }
    });
  };
  _proto.setProductVariant = function setProductVariant() {
    var unsatisfiedRequiredFields = [];
    var options = [];
    $.each($('[data-product-attribute]'), function (index, value) {
      var optionLabel = value.children[0].innerText;
      var optionTitle = optionLabel.split(':')[0].trim();
      var required = optionLabel.toLowerCase().includes('required');
      var type = value.getAttribute('data-product-attribute');
      if ((type === 'input-file' || type === 'input-text' || type === 'input-number') && value.querySelector('input').value === '' && required) {
        unsatisfiedRequiredFields.push(value);
      }
      if (type === 'textarea' && value.querySelector('textarea').value === '' && required) {
        unsatisfiedRequiredFields.push(value);
      }
      if (type === 'date') {
        var isSatisfied = Array.from(value.querySelectorAll('select')).every(function (select) {
          return select.selectedIndex !== 0;
        });
        if (isSatisfied) {
          var dateString = Array.from(value.querySelectorAll('select')).map(function (x) {
            return x.value;
          }).join('-');
          options.push(optionTitle + ":" + dateString);
          return;
        }
        if (required) {
          unsatisfiedRequiredFields.push(value);
        }
      }
      if (type === 'set-select') {
        var select = value.querySelector('select');
        var selectedIndex = select.selectedIndex;
        if (selectedIndex !== 0) {
          options.push(optionTitle + ":" + select.options[selectedIndex].innerText);
          return;
        }
        if (required) {
          unsatisfiedRequiredFields.push(value);
        }
      }
      if (type === 'set-rectangle' || type === 'set-radio' || type === 'swatch' || type === 'input-checkbox' || type === 'product-list') {
        var checked = value.querySelector(':checked');
        if (checked) {
          if (type === 'set-rectangle' || type === 'set-radio' || type === 'product-list') {
            var label = checked.labels[0].innerText;
            if (label) {
              options.push(optionTitle + ":" + label);
            }
          }
          if (type === 'swatch') {
            var _label = checked.labels[0].children[0];
            if (_label) {
              options.push(optionTitle + ":" + _label.title);
            }
          }
          if (type === 'input-checkbox') {
            options.push(optionTitle + ":Yes");
          }
          return;
        }
        if (type === 'input-checkbox') {
          options.push(optionTitle + ":No");
        }
        if (required) {
          unsatisfiedRequiredFields.push(value);
        }
      }
    });
    var productVariant = unsatisfiedRequiredFields.length === 0 ? options.sort().join(', ') : 'unsatisfied';
    var view = $('.product-details');
    if (productVariant) {
      productVariant = productVariant === 'unsatisfied' ? '' : productVariant;
      if (view.attr('data-event-type')) {
        view.attr('data-product-variant', productVariant);
      } else {
        var productName = view.find('.product-title')[0].innerText;
        var card = $("[data-name=\"" + productName + "\"]");
        card.attr('data-product-variant', productVariant);
      }
    }
  };
  return ProductUtils;
}();


/***/ }),

/***/ "./assets/js/theme/product/QuickShop.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/product/QuickShop.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ QuickShop)
/* harmony export */ });
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _ProductUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ProductUtils */ "./assets/js/theme/product/ProductUtils.js");
/* harmony import */ var _ProductImages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ProductImages */ "./assets/js/theme/product/ProductImages.js");
/* harmony import */ var _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./productViewTemplates */ "./assets/js/theme/product/productViewTemplates.js");
/* harmony import */ var _variationImgPreview__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./variationImgPreview */ "./assets/js/theme/product/variationImgPreview.js");
/* harmony import */ var _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../product/ColorSwatch */ "./assets/js/theme/product/ColorSwatch.js");
/* harmony import */ var bc_modal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! bc-modal */ "./node_modules/bc-modal/dist/js/modal.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");








var QuickShop = /*#__PURE__*/function () {
  function QuickShop(context) {
    var _this = this;
    this.context = context;
    this.product;
    this.id = null;

    // Set up the modal options
    this.QuickShopModal = new bc_modal__WEBPACK_IMPORTED_MODULE_7__["default"]({
      modalClass: 'modal-quick-shop',
      centerVertically: false,
      afterShow: function afterShow($modal) {
        _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.off('product-option-change');
        _this._fetchProduct($modal, _this.id);
      },
      afterHide: function afterHide() {
        _this.ProductUtils = new _ProductUtils__WEBPACK_IMPORTED_MODULE_2__["default"]('[data-product-container]', {
          priceWithoutTaxTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceWithoutTax,
          priceWithTaxTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceWithTax,
          priceSavedTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceSaved,
          variationPreviewImageTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].variationPreviewImage,
          callbacks: {
            switchImage: _variationImgPreview__WEBPACK_IMPORTED_MODULE_5__["default"]
          }
        }).init(_this.context);
        _this.product.destroy();
      }
    });
    this._bindEvents();
  }

  /**
   * Launch quickshop modal on click and set up id variable
   */
  var _proto = QuickShop.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    $('body').on('click', '[data-quick-shop]', function (event) {
      event.preventDefault();
      _this2.id = $(event.currentTarget).data('product-id');
      if (!_this2.id) {
        return;
      }
      _this2.QuickShopModal.open();
      $('.modal-content').prepend('<svg class="icon icon-spinner"><use xlink:href="#icon-spinner" /></svg>');
    });
  }

  /**
   * Run ajax fetch of product and add to modal. Bind product functionality and show the modal
   * @param {jQuery} $modal - the root (appended) modal element.
   * @param {integer} id - product id
   */;
  _proto._fetchProduct = function _fetchProduct($modal, id) {
    var _this3 = this;
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.product.getById(id, {
      template: 'quick-shop/quick-shop-modal'
    }, function (err, response) {
      $modal.find('.modal-content').append(response);

      // Init FB like if necessary
      if ($modal.find('.facebook-like').length) {
        (function (d, s, id) {
          var js,
            fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return;
          js = d.createElement(s);
          js.id = id;
          js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5";
          fjs.parentNode.insertBefore(js, fjs);
        })(document, 'script', 'facebook-jssdk');
      }

      // set up product utils (adding to cart, options)
      var $el = $modal.find('[data-product-quickshop-container]');
      _this3.product = new _ProductUtils__WEBPACK_IMPORTED_MODULE_2__["default"]($el, {
        priceWithoutTaxTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceWithoutTax,
        priceWithTaxTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceWithTax,
        priceSavedTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceSaved,
        variationPreviewImageTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].variationPreviewImage,
        callbacks: {
          switchImage: _variationImgPreview__WEBPACK_IMPORTED_MODULE_5__["default"]
        }
      });
      _this3.product.init(_this3.context);

      // set up simple image slideshow
      new _ProductImages__WEBPACK_IMPORTED_MODULE_3__["default"]('.modal-quick-shop .product-slides-wrap');
      _this3.swatches = new _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_6__["default"](); // Init our color swatches

      // reposition modal with content
      _this3.QuickShopModal.position();
      $modal.addClass('loaded');
      $('.modal-content').children('.icon-spinner').remove();
    });
  };
  return QuickShop;
}();


/***/ }),

/***/ "./assets/js/theme/product/productViewTemplates.js":
/*!*********************************************************!*\
  !*** ./assets/js/theme/product/productViewTemplates.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/template */ "./node_modules/lodash/template.js");
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_template__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  priceWithoutTax: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <% if (price.rrp_without_tax) { %>\n      <div class=\"price-rrp-wrapper\">\n        <label class=\"price-rrp-label\"><%= retailPriceLabel %></label>\n        <span class=\"price-rrp\"><%= price.rrp_without_tax.formatted %></span>\n      </div>\n    <% } %>\n    <% if (price.non_sale_price_without_tax) { %>\n      <div class=\"price-ns-wrapper\">\n        <label class=\"price-ns-label\"><%= nonSalePriceLabel %></label>\n        <span class=\"price-ns\">\n          <%= price.non_sale_price_without_tax.formatted %>\n        </span>\n      </div>\n    <% } %>\n    <div class=\"price-value-wrapper\">\n      <!-- If there's another price show \"now\" label -->\n      <% if (price.non_sale_price_without_tax) { %>\n        <label class=\"price-value-label\"><%= salePriceLabel %></label>\n      <% } else { %>\n        <label class=\"price-label\"><%= priceLabel %></label>\n      <% } %>\n      <span class=\"price-value\" data-product-price>\n        <%= price.without_tax.formatted %>\n      </span>\n      <% if (price.with_tax && price.without_tax) { %>\n        <span class=\"price-tax-label\"><%= excludingTax %></span>\n      <% } %>\n    </div>\n  "),
  priceWithTax: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <% if (price.rrp_with_tax) { %>\n      <div class=\"price-rrp-wrapper\">\n        <label class=\"price-rrp-label\"><%= retailPriceLabel %></label>\n        <span class=\"price-rrp\"><%= price.rrp_with_tax.formatted %></span>\n      </div>\n    <% } %>\n    <% if (price.non_sale_price_without_tax) { %>\n      <div class=\"price-ns-wrapper\">\n        <label class=\"price-ns-label\"><%= nonSalePriceLabel %></label>\n        <span class=\"price-ns\">\n          <%= price.non_sale_price_with_tax.formatted %>\n        </span>\n      </div>\n    <% } %>\n    <div class=\"price-value-wrapper\">\n      <!-- If there's another price show \"now\" label -->\n      <% if (price.non_sale_price_with_tax) { %>\n        <label class=\"price-value-label\"><%= salePriceLabel %></label>\n      <% } else { %>\n        <label class=\"price-label\"><%= priceLabel %></label>\n      <% } %>\n      <span class=\"price-value\" data-product-price>\n        <%= price.with_tax.formatted %>\n      </span>\n      <% if (price.with_tax && price.without_tax) { %>\n        <span class=\"price-tax-label\"><%= includingTax %></span>\n      <% } %>\n    </div>\n  "),
  priceSaved: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <% if (price.saved) { %>\n      <%= savedString %> <%= price.saved.formatted %>\n    <% } %>\n  "),
  variationImage: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <a class=\"product-image\" style=\"background-image:url(<%= zoomImageSrc %>);\" href=\"<%= zoomImageSrc %>\" data-product-image data-product-image-variant>\n      <img src=\"<%= productImageSrc %>\">\n    </a>\n  "),
  variationImageNav: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <div class=\"pagination-item\" data-variant-id=\"<%= id %>\">\n      <img src=\"<%= productImageSrc %>\">\n    </div>\n  ")
});

/***/ }),

/***/ "./assets/js/theme/product/resetProductImages.js":
/*!*******************************************************!*\
  !*** ./assets/js/theme/product/resetProductImages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ resetProductImages)
/* harmony export */ });
/* harmony import */ var _utils_scrollToTop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/scrollToTop */ "./assets/js/theme/utils/scrollToTop.js");

function resetProductImages($el) {
  var numSlides = $el.find('[data-product-image]').length - 1;
  var mainSlide = $el.find('[data-product-image]').index('[data-product-main-image]');
  $el.slick('slickGoTo', mainSlide);
  $el.slick('slickRemove', numSlides);
  (0,_utils_scrollToTop__WEBPACK_IMPORTED_MODULE_0__["default"])();
}

/***/ }),

/***/ "./assets/js/theme/product/variationImgPreview.js":
/*!********************************************************!*\
  !*** ./assets/js/theme/product/variationImgPreview.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ variationImgPreview)
/* harmony export */ });
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slick-carousel */ "./node_modules/slick-carousel/slick/slick.js");
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(slick_carousel__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _productViewTemplates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./productViewTemplates */ "./assets/js/theme/product/productViewTemplates.js");
/* harmony import */ var _ProductImages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ProductImages */ "./assets/js/theme/product/ProductImages.js");
/* harmony import */ var baguettebox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! baguettebox.js */ "./node_modules/baguettebox.js/dist/baguetteBox.min.js");
/* harmony import */ var baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(baguettebox_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _ImageZoom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ImageZoom */ "./assets/js/theme/product/ImageZoom.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _utils_scrollToTop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/scrollToTop */ "./assets/js/theme/utils/scrollToTop.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");







function variationImgPreview(productImageUrl, zoomImageUrl, alt, imageId) {
  var productImgs = '.product-slides-wrap';

  // Only append if image doesn't already exist.
  // Otherwise, scroll to it.
  if (!$("img[src=\"" + productImageUrl + "\"]").length) {
    var numSlides = $('[data-product-image]').length;
    if ($('[data-product-image-variant]').length) {
      $(productImgs).slick('slickRemove', numSlides - 1);
    }
    baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().destroy();

    // Add carousel image
    $(productImgs).slick('slickAdd', _productViewTemplates__WEBPACK_IMPORTED_MODULE_1__["default"].variationImage({
      productImageSrc: productImageUrl,
      zoomImageSrc: zoomImageUrl,
      alt: alt
    }));
    imagesloaded__WEBPACK_IMPORTED_MODULE_5___default()(productImgs, {
      background: true
    }, function () {
      baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().run('.product-slides-wrap', {});
      $(productImgs).slick('slickGoTo', numSlides + 1);

      // Image zoom for newly added image
      $(productImgs).find('[data-product-image]').each(function (i, el) {
        new _ImageZoom__WEBPACK_IMPORTED_MODULE_4__["default"](el);
      });
    });
  }
}
;

/***/ }),

/***/ "./assets/js/theme/product/wishlistDropdown.js":
/*!*****************************************************!*\
  !*** ./assets/js/theme/product/wishlistDropdown.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ wishlistDropdown)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var wishlistDropdown = /*#__PURE__*/function () {
  function wishlistDropdown() {
    this.dropdown = '[data-wishlist-dropdown]';
    this.toggle = '[data-wishlist-toggle]';
    this.panel = '[data-wishlist-panel]';
    this._bindEvents();
  }
  var _proto = wishlistDropdown.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    $(document).on('click', this.toggle, function (event) {
      _this._toggleDropdown(event);
    });
  };
  _proto._toggleDropdown = function _toggleDropdown(event) {
    event.preventDefault();
    $(event.currentTarget).closest(this.dropdown).find(this.panel).revealer('toggle');
    $(this.toggle).filter($(this.toggle).not($(event.currentTarget))).closest(this.dropdown).find(this.panel).revealer('hide');
  };
  return wishlistDropdown;
}();


/***/ }),

/***/ "./assets/js/theme/utils/FormValidator.js":
/*!************************************************!*\
  !*** ./assets/js/theme/utils/FormValidator.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FormValidator)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var FormValidator = /*#__PURE__*/function () {
  function FormValidator(context) {
    this.context = context;
    this.formSelector = '[data-validated-form]';
    this.validationOptions = {};
    this.validationMessages = {
      required: this.context.validationRequired,
      email: this.context.validationEmail,
      number: this.context.validationNumber,
      numMax: this.context.validationNumberMax,
      numMin: this.context.validationNumberMin,
      numRange: this.context.validationNumberRange,
      maxLength: this.context.validationMaxLength,
      minLength: this.context.validationMinLength,
      maxChecked: this.context.validationMaxChecked,
      minChecked: this.context.validationMinChecked,
      maxSelected: this.context.validationMaxSelected,
      minSelected: this.context.validationMinSelected,
      notEqual: this.context.validationNotEqual,
      different: this.context.validationDifferent
    };
  }

  /*
   * Initialize validation on all matching forms on page load
   */
  var _proto = FormValidator.prototype;
  _proto.initGlobal = function initGlobal() {
    $(this.formSelector).validetta(this.options, this.validationMessages);
  }

  /*
   * Manually initialize validation on target form
   *
   * @param {jQuery} $form - target form to validate
   * @param {object} localOptions - a set of options separate from the ones defined here (optional)
   */;
  _proto.initSingle = function initSingle($form, localOptions) {
    var customOptions = localOptions ? localOptions : this.validationOptions;
    $($form).validetta(customOptions, this.validationMessages);
  };
  return FormValidator;
}();


/***/ }),

/***/ "./assets/js/theme/utils/ProgressButton.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/utils/ProgressButton.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProgressButton)
/* harmony export */ });
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global/svgIcon */ "./assets/js/theme/global/svgIcon.js");


/**
 * Toggle a progress button state with alternate text
 * the button needs a class of button-progress
 * the button text needs to be wrapped in an extra .button-text element within the button element itself
 * the button should probably have a data-progress-text attribute
 */
var ProgressButton = /*#__PURE__*/function () {
  function ProgressButton() {}
  var _proto = ProgressButton.prototype;
  _proto.progress = function progress($button) {
    // cache the current button text
    $button.data('defaultText', $button.text());
    var progressText = $button.attr('data-progress-text') || $button.text();
    var spinner = $button.hasClass('spinner') ? (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_0__["default"])('spinner') : '';
    $button.addClass('progress').attr('disabled', 'disabled').append(spinner).find('.button-text').html(progressText);
  };
  _proto.complete = function complete($button) {
    var defaultText = $button.data('defaultText');
    $button.removeClass('progress').attr('disabled', false).find('.button-text').html(defaultText).next('.icon-spinner').remove();
  };
  return ProgressButton;
}();


/***/ }),

/***/ "./assets/js/theme/utils/pagination-utils.js":
/*!***************************************************!*\
  !*** ./assets/js/theme/utils/pagination-utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wishlistPaginationHelper: () => (/* binding */ wishlistPaginationHelper)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var changeWishlistPaginationLinks = function changeWishlistPaginationLinks(wishlistUrl) {
  for (var _len = arguments.length, paginationItems = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    paginationItems[_key - 1] = arguments[_key];
  }
  return $.each(paginationItems, function (_, $item) {
    if ($item.length && !$item.attr('href').includes('page=')) {
      var pageNumber = $item.attr('href');
      $item.attr('href', wishlistUrl + "page=" + pageNumber);
    }
  });
};

/**
* helps to withdraw differences in structures around the stencil resource pagination
*/

var wishlistPaginationHelper = function wishlistPaginationHelper() {
  var $pagination = $('.pagination');
  if (!$pagination.length) return;
  var $nextItem = $('.next', $pagination);
  var $prevItem = $('.previous', $pagination);
  var currentHref = $('[data-pagination-current-page-link]').attr('href');
  var partialPaginationUrl = currentHref.split('page=').shift();
  changeWishlistPaginationLinks(partialPaginationUrl, $prevItem, $nextItem);
};

/***/ }),

/***/ "./assets/js/theme/utils/scrollToTop.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/utils/scrollToTop.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ scrollToTop)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function scrollToTop() {
  $('html, body').animate({
    scrollTop: $('.site-canvas').offset().top
  });
}

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/base.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _lib_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/request */ "./node_modules/@bigcommerce/stencil-utils/src/lib/request.js");

var _default = /*#__PURE__*/function () {
  /**
   * @Constructor
   */
  function _default(version) {
    this.remoteVersion = version || 'v1';
    this.remoteBaseEndpoint = '/remote/';
  }

  /**
   *
   * @param {String} url
   * @param {String} method ['GET', 'POST', 'PUT', 'DELETE']
   * @param {Object} options
   * @param {Boolean} remote
   * @param {Function} callback
   */
  var _proto = _default.prototype;
  _proto.makeRequest = function makeRequest(url, method, options, remote, callback) {
    (0,_lib_request__WEBPACK_IMPORTED_MODULE_0__["default"])(url, {
      method: method,
      remote: remote,
      requestOptions: options
    }, callback);
  }

  /**
   *
   * @param {String} endpoint
   * @param {String} method ['GET', 'POST', 'PUT', 'DELETE']
   * @param {Object} options
   * @param {Function} callback
   */;
  _proto.remoteRequest = function remoteRequest(endpoint, method, options, callback) {
    var remoteUrl = this.remoteBaseEndpoint + this.remoteVersion + endpoint;
    this.makeRequest(remoteUrl, method, options, true, callback);
  };
  return _default;
}();


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/cart.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/cart.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _bodl_emitters_cart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bodl/emitters/cart */ "./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/cart.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hooks */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }



var _default = /*#__PURE__*/function (_Base) {
  function _default(version) {
    var _this;
    _this = _Base.call(this, version) || this;
    _this.bodlEventsCart = null;
    return _this;
  }
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.getBodlEventsCart = function getBodlEventsCart() {
    if (!this.bodlEventsCart) {
      this.bodlEventsCart = new _bodl_emitters_cart__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }
    return this.bodlEventsCart;
  }

  /**
   * Get a collection of Carts. For now, this will only return an array of a single cart as multiple carts per session
   * are not currently supported.
   *
   * @param options
   * @param {Function} callback
   */;
  _proto.getCarts = function getCarts(options, callback) {
    if (options === void 0) {
      options = {};
    }
    var url = '/api/storefront/carts';
    if (options.includeOptions) {
      url = this.includeOptions(url);
    }
    this.makeRequest(url, 'GET', options, true, function (err, response) {
      callback(err, response);
    });
  }

  /**
   * Get the current Cart's details, either with or without Product Option selections.
   * Can also be used to get a particular cart provided a cartId in the options.
   *
   * @param options
   * @param {Function} callback
   */;
  _proto.getCart = function getCart(options, callback) {
    if (options === void 0) {
      options = {};
    }
    /* If no cart ID is provided, get the collection of carts and return the first one */
    if (!options.cartId) {
      return this.getCarts(options, function (err, response) {
        return callback(err, response[0]);
      });
    }
    var url = "/api/storefront/carts/" + options.cartId;
    if (options.includeOptions) {
      url = this.includeOptions(url);
    }
    this.makeRequest(url, 'GET', options, true, function (err, response) {
      callback(err, response);
    });
  }

  /**
   * Get the summary for the current primary cart. This summary does not include the full details of the cart, but
   * the response time is much faster and it's appropriate for summary use cases.
   *
   * @param options
   * @param {Function} callback
   */;
  _proto.getCartSummary = function getCartSummary(options, callback) {
    if (options === void 0) {
      options = {};
    }
    var url = '/api/storefront/cart-summary';
    this.makeRequest(url, 'GET', options, true, function (err, response) {
      callback(err, response);
    });
  }

  /**
   * Add the parameters to a URL needed to get product option details on cart line items
   * @param url
   */;
  _proto.includeOptions = function includeOptions(url) {
    return url + "?include=lineItems.physicalItems.options,lineItems.digitalItems.options";
  }

  /**
   * Get a sum of the cart line item quantities
   *
   * @param options
   * @param {Function} callback
   */;
  _proto.getCartQuantity = function getCartQuantity(options, callback) {
    if (options === void 0) {
      options = {};
    }
    this.getCartSummary(options, function (err, response) {
      if (err) {
        return callback(err);
      }
      var quantity = 0;
      if (response && response.status !== 204 && response.total_quantity) {
        quantity = response.total_quantity;
      }
      callback(null, quantity);
    });
  }

  /**
   * Enhance with Big Open Data Layer events
   *
   * @param {FormData} formData
   * @param {Function} callback
   */;
  _proto.itemAdd = function itemAdd(formData, callback) {
    var _this2 = this;
    this.handleItemAdd(formData, function (err, response) {
      if (!err) {
        _this2.getBodlEventsCart().emitAddItem(response);
      }
      callback(err, response);
    });
  }

  /**
   * Add item to cart with options (variants)
   *
   * @param {FormData} formData
   * @param {Function} callback
   */;
  _proto.handleItemAdd = function handleItemAdd(formData, callback) {
    this.remoteRequest('/cart/add', 'POST', {
      formData: formData
    }, function (err, response) {
      var emitData = {
        err: err,
        response: response
      };
      _hooks__WEBPACK_IMPORTED_MODULE_2__["default"].emit('cart-item-add-remote', emitData);
      callback(err, response);
    });
  }

  /**
   * Update cart item quantity
   *
   * @param {String|Object} itemId
   * @param {Number|Function} qty
   * @param {Function|null} callback
   */;
  _proto.itemUpdate = function itemUpdate(itemId, qty, callback) {
    var _this3 = this;
    var callbackArg = callback;
    var items;
    if (Array.isArray(itemId) && typeof qty === 'function') {
      callbackArg = qty;
      items = itemId;
    } else {
      items = [{
        id: itemId,
        quantity: qty
      }];
    }
    this.update(items, function (err, response) {
      var emitData = {
        items: items,
        err: err,
        response: response
      };
      if (qty === 0 && !err) {
        _this3.getBodlEventsCart().emitRemoveItem(response);
      }
      _hooks__WEBPACK_IMPORTED_MODULE_2__["default"].emit('cart-item-update-remote', emitData);
      callbackArg(err, response);
    });
  }

  /**
   * Enhance with Big Open Data Layer events
   *
   * @param {String} itemId
   * @param {Function} callback
   */;
  _proto.itemRemove = function itemRemove(itemId, callback) {
    var _this4 = this;
    this.handleItemRemove(itemId, function (err, response) {
      if (!err) {
        _this4.getBodlEventsCart().emitRemoveItem(response);
      }
      callback(err, response);
    });
  }

  /**
   * Remove cart items
   *
   * Calls the internal update function with quantity: 0
   *
   * @param {String} itemId
   * @param {Function} callback
   */;
  _proto.handleItemRemove = function handleItemRemove(itemId, callback) {
    var items = [{
      id: itemId,
      quantity: 0
    }];
    this.update(items, function (err, response) {
      var emitData = {
        items: items,
        err: err,
        response: response
      };
      _hooks__WEBPACK_IMPORTED_MODULE_2__["default"].emit('cart-item-remove-remote', emitData);
      callback(err, response);
    });
  }

  /**
   * Get giftwrapping options
   * @param {String} itemId
   * @param {Object|Function} options
   * @param {Function|null} callback
   */;
  _proto.getItemGiftWrappingOptions = function getItemGiftWrappingOptions(itemId, options, callback) {
    var opts = options || {};
    var callbackArg = callback;
    if (typeof opts === 'function') {
      callbackArg = opts;
      opts = {};
    }
    this.remoteRequest("/gift-wrapping/" + itemId, 'GET', opts, callbackArg);
  }

  /**
   * Submit giftwrapping options
   *
   * @param {String} itemId
   * @param {Function} callback
   */;
  _proto.submitItemGiftWrappingOption = function submitItemGiftWrappingOption(itemId, params, callback) {
    this.remoteRequest("/gift-wrapping/" + itemId, 'POST', {
      params: params
    }, callback);
  }

  /**
   * Update cart items
   *
   * @param {Array} items
   * @param {Function} callback
   */;
  _proto.update = function update(items, callback) {
    var payload = {
      items: items
    };
    this.remoteRequest('/cart/update', 'POST', {
      params: payload
    }, callback);
  }

  /**
   * Get cart content
   *
   * @param {Object} options
   * @param {Function} callback
   */;
  _proto.getContent = function getContent(options, callback) {
    var opts = options || {};
    var callbackArg = callback;
    if (typeof opts === 'function') {
      callbackArg = opts;
      opts = {};
    }
    this.makeRequest('/cart.php', 'GET', opts, false, callbackArg);
  }

  /**
   * Get cart shipping quote
   *
   * @param {Object} params
   * @param {String|Array|Object} renderWith
   * @param {Function} callback
   */;
  _proto.getShippingQuotes = function getShippingQuotes(params, renderWith, callback) {
    var options = {
      params: params
    };
    var callbackArg = callback;
    var renderWithArg = renderWith;
    if (typeof callbackArg !== 'function') {
      callbackArg = renderWithArg;
      renderWithArg = null;
    }
    if (renderWithArg) {
      options.template = renderWithArg;
    }
    this.remoteRequest('/shipping-quote', 'GET', options, callbackArg);
  }

  /**
   * Submit shipping quote based on quoteId
   *
   * @param {Number} quoteId
   * @param {Function} callback
   */;
  _proto.submitShippingQuote = function submitShippingQuote(quoteId, callback) {
    var options = {
      params: {
        shipping_method: quoteId
      }
    };
    this.remoteRequest('/shipping-quote', 'POST', options, callback);
  }

  /**
   * Apply a coupon code or gift certificate to the cart
   *
   * @param {String} code
   * @param {Function} callback
   */;
  _proto.applyCode = function applyCode(code, callback) {
    var options = {
      params: {
        code: code
      }
    };
    this.remoteRequest('/apply-code', 'POST', options, callback);
  }

  /**
   * Apply a coupon code or gift certificate to the cart
   *
   * @param {Number} code
   * @param {Function} callback
   */;
  _proto.applyGiftCertificate = function applyGiftCertificate(code, callback) {
    var options = {
      params: {
        code: code
      }
    };
    this.remoteRequest('/gift-certificates', 'POST', options, callback);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/countries.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/countries.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_Base) {
  /**
   * @Constructor
   */
  function _default(version) {
    var _this;
    // call parent
    _this = _Base.call(this, version) || this;

    // set up class variables
    _this.endpoint = '/country-states/';
    return _this;
  }

  /**
   *
   * Get country data by id wrapper
   *
   * @param {Number} id
   * @param {Function} callback
   */
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.getById = function getById(id, callback) {
    var url = this.endpoint + id;
    this.remoteRequest(url, 'GET', {}, callback);
  }

  /**
   * Get country data by country name
   * @param name
   * @param callback
   */;
  _proto.getByName = function getByName(name, callback) {
    var url = this.endpoint + name;
    this.remoteRequest(url, 'GET', {}, callback);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/request */ "./node_modules/@bigcommerce/stencil-utils/src/lib/request.js");
/* harmony import */ var _countries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countries */ "./node_modules/@bigcommerce/stencil-utils/src/api/countries.js");
/* harmony import */ var _product__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./product */ "./node_modules/@bigcommerce/stencil-utils/src/api/product.js");
/* harmony import */ var _product_attributes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./product-attributes */ "./node_modules/@bigcommerce/stencil-utils/src/api/product-attributes.js");
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./search */ "./node_modules/@bigcommerce/stencil-utils/src/api/search.js");
/* harmony import */ var _cart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cart */ "./node_modules/@bigcommerce/stencil-utils/src/api/cart.js");
/* harmony import */ var _wishlist__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wishlist */ "./node_modules/@bigcommerce/stencil-utils/src/api/wishlist.js");







var internals = {};

/**
 * Convenience function to request a page via ajax
 *
 * @param url
 * @param options
 * @param callback
 */
internals.getPage = function (url, options, callback) {
  (0,_lib_request__WEBPACK_IMPORTED_MODULE_0__["default"])(url, {
    method: 'GET',
    requestOptions: options
  }, callback);
};
internals.getPageByGQL = function (page, callback) {
  (0,_lib_request__WEBPACK_IMPORTED_MODULE_0__["default"])('/graphql-render', {
    method: 'GET',
    requestOptions: {
      params: {
        template_name: page
      }
    }
  }, callback);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  country: new _countries__WEBPACK_IMPORTED_MODULE_1__["default"](),
  productAttributes: new _product_attributes__WEBPACK_IMPORTED_MODULE_3__["default"](),
  product: new _product__WEBPACK_IMPORTED_MODULE_2__["default"](),
  search: new _search__WEBPACK_IMPORTED_MODULE_4__["default"](),
  cart: new _cart__WEBPACK_IMPORTED_MODULE_5__["default"](),
  wishlist: new _wishlist__WEBPACK_IMPORTED_MODULE_6__["default"](),
  getPage: internals.getPage,
  getPageByGQL: internals.getPageByGQL
});

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/product-attributes.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/product-attributes.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js");
/* harmony import */ var _lib_query_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/query-string */ "./node_modules/@bigcommerce/stencil-utils/src/lib/query-string.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }



var _default = /*#__PURE__*/function (_Base) {
  /**
   * @Constructor
   */
  function _default(version) {
    var _this;
    // call parent
    _this = _Base.call(this, version) || this;

    // set up class variables
    _this.endpoint = '/product-attributes/';
    _this.inCartEndpoint = '/configure-options/';
    return _this;
  }

  /**
   * @param {Number} productId
   * @param {Object} params
   * @param callback
   */
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.optionChange = function optionChange(productId, params, template, callback) {
    if (template === void 0) {
      template = null;
    }
    var templateArg = template;
    var callbackArg = callback;
    if (typeof templateArg === 'function') {
      callbackArg = templateArg;
      templateArg = null;
    }
    this.remoteRequest(this.endpoint + productId, 'POST', {
      params: (0,_lib_query_string__WEBPACK_IMPORTED_MODULE_2__.parse)(params),
      template: templateArg
    }, function (err, response) {
      var emitData = {
        err: err,
        response: response
      };
      _hooks__WEBPACK_IMPORTED_MODULE_1__["default"].emit('product-options-change-remote', emitData);
      callbackArg(err, response);
    });
  }

  /**
   * @param {Number} itemId
   * @param {Object} params
   * @param callback
   */;
  _proto.configureInCart = function configureInCart(itemId, params, callback) {
    this.remoteRequest(this.inCartEndpoint + itemId, 'GET', params, function (err, response) {
      callback(err, response);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/product.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/product.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_Base) {
  /**
   * @Constructor
   */
  function _default(version) {
    var _this;
    // call parent
    _this = _Base.call(this, version) || this;

    // set up class variables
    _this.endpoint = '/products.php?productId=';
    return _this;
  }

  /**
   *
   * @param {Number} productId
   * @param {Object} params
   * @param {Function} callback
   */
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.getById = function getById(productId, params, callback) {
    var url = this.endpoint + productId;
    var paramsArg = params;
    var callbackArg = callback;
    if (typeof paramsArg === 'function') {
      callbackArg = paramsArg;
      paramsArg = {};
    }
    this.makeRequest(url, 'GET', paramsArg, false, callbackArg);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/search.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/search.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hooks */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


var _default = /*#__PURE__*/function (_Base) {
  /**
   * @Constructor
   */
  function _default(version) {
    var _this;
    // call parent
    _this = _Base.call(this, version) || this;

    // set up class variables
    _this.endpoint = '/search.php?search_query=';
    return _this;
  }

  /**
   * Get search results
   * @param {String} query
   * @param {Object} params
   * @param {Function} callback
   */
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.search = function search(query, params, callback) {
    var url = this.endpoint + encodeURIComponent(query);
    var paramsArg = params;
    var callbackArg = callback;
    if (typeof paramsArg === 'function') {
      callbackArg = paramsArg;
      paramsArg = {};
    }
    _hooks__WEBPACK_IMPORTED_MODULE_0__["default"].emit('search-quick-remote', query);
    this.makeRequest(url, 'GET', paramsArg, false, callbackArg);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/wishlist.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/wishlist.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_Base) {
  function _default() {
    return _Base.apply(this, arguments) || this;
  }
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.itemAdd = function itemAdd(wishlistId, productId, options, callback) {
    var url = "/wishlist.php?action=add&wishlistid=" + wishlistId + "&product_id=" + productId;
    var opts = options;
    var callbackFn = callback;
    if (typeof opts === 'function') {
      callbackFn = opts;
      opts = {};
    }
    this.makeRequest(url, 'POST', opts, false, callbackFn);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/base.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/base.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./node_modules/@bigcommerce/stencil-utils/src/bodl/helpers.js");

var _default = function _default() {
  this.bodlEvents = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getBODLEvents)();
};


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/cart.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/cart.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./node_modules/@bigcommerce/stencil-utils/src/bodl/helpers.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


var Cart = /*#__PURE__*/function (_Base) {
  function Cart() {
    return _Base.apply(this, arguments) || this;
  }
  _inheritsLoose(Cart, _Base);
  var _proto = Cart.prototype;
  _proto.emitAddItem = function emitAddItem(response) {
    this.emit(this.bodlEvents.AddCartItemEvent.CREATE, response);
  };
  _proto.emitRemoveItem = function emitRemoveItem(response) {
    if (this.shouldEmitRemoveItem(response)) {
      this.emit(this.bodlEvents.RemoveCartItemEvent.CREATE, response);
    }
  };
  _proto.shouldEmitRemoveItem = function shouldEmitRemoveItem(response) {
    var _response$data$line_i;
    return ((_response$data$line_i = response.data.line_items) == null ? void 0 : _response$data$line_i.length) > 0;
  };
  _proto.emit = function emit(eventName, response) {
    var payload = this.preparePayload(response);
    this.bodlEvents.cart.emit(eventName, payload);
  };
  _proto.preparePayload = function preparePayload(response) {
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBODLEnabled)() && !response.data.error) {
      return {
        event_id: (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getEventId)(),
        channel_id: response.data.channel_id,
        currency: response.data.currency,
        product_value: response.data.product_value,
        line_items: response.data.line_items.map(function (item) {
          return Object.assign({}, item, {
            product_id: String(item.product_id)
          });
        })
      };
    }
    return {};
  };
  return Cart;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Cart);

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/bodl/helpers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/bodl/helpers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FakeBODLEvents: () => (/* binding */ FakeBODLEvents),
/* harmony export */   getBODLEvents: () => (/* binding */ getBODLEvents),
/* harmony export */   getEventId: () => (/* binding */ getEventId),
/* harmony export */   isBODLEnabled: () => (/* binding */ isBODLEnabled)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");

var isBODLEnabled = function isBODLEnabled() {
  return typeof window.bodlEvents !== 'undefined';
};
var FakeBODLEvents = {
  cart: {
    addItem: function addItem() {},
    removeItem: function removeItem() {},
    emit: function emit() {}
  },
  AddCartItemEvent: {
    CREATE: 'create_add_cart_item'
  },
  RemoveCartItemEvent: {
    CREATE: 'create_remove_cart_item'
  }
};
var getEventId = function getEventId() {
  return (0,uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
};
var getBODLEvents = function getBODLEvents() {
  if (isBODLEnabled()) {
    return window.bodlEvents;
  }
  return FakeBODLEvents;
};

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_EventEmitter) {
  function _default() {
    return _EventEmitter.apply(this, arguments) || this;
  }
  _inheritsLoose(_default, _EventEmitter);
  var _proto = _default.prototype;
  _proto.subscribe = function subscribe(eventName, elementSelector, handler) {
    document.addEventListener(eventName, function (e) {
      for (var target = e.target; target && target !== this; target = target.parentNode) {
        if (target.matches(elementSelector)) {
          handler.call(target, e, target);
          break;
        }
      }
    }, false);
  };
  return _default;
}((eventemitter3__WEBPACK_IMPORTED_MODULE_0___default()));


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/cart.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/cart.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.itemAdd();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.itemAdd = function itemAdd() {
    var _this2 = this;
    this.subscribe('submit', '[data-cart-item-add]', function (event, target) {
      _this2.emit('cart-item-add', event, target);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/cookie.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/cookie.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  function _default() {
    return _BaseHooks.apply(this, arguments) || this;
  }
  _inheritsLoose(_default, _BaseHooks);
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/currency-selector.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/currency-selector.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.currencySelector();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.currencySelector = function currencySelector() {
    var _this2 = this;
    this.subscribe('input', '[data-currency-selector-toggle]', function (event) {
      _this2.emit('currencySelector-toggle', event);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/faceted-search.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/faceted-search.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.searchEvents();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.searchEvents = function searchEvents() {
    var _this2 = this;
    this.subscribe('click', '[data-faceted-search-facet]', function (event, target) {
      _this2.emit('facetedSearch-facet-clicked', event, target);
    });
    this.subscribe('submit', '[data-faceted-search-range]', function (event, target) {
      _this2.emit('facetedSearch-range-submitted', event, target);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cart */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/cart.js");
/* harmony import */ var _cookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cookie */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/cookie.js");
/* harmony import */ var _currency_selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./currency-selector */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/currency-selector.js");
/* harmony import */ var _product__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./product */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/product.js");
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./search */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/search.js");
/* harmony import */ var _faceted_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./faceted-search */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/faceted-search.js");
/* harmony import */ var _sort_by__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort-by */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/sort-by.js");







var internals = {};
internals.classes = {
  cart: new _cart__WEBPACK_IMPORTED_MODULE_0__["default"](),
  cookie: new _cookie__WEBPACK_IMPORTED_MODULE_1__["default"](),
  currencySelector: new _currency_selector__WEBPACK_IMPORTED_MODULE_2__["default"](),
  product: new _product__WEBPACK_IMPORTED_MODULE_3__["default"](),
  search: new _search__WEBPACK_IMPORTED_MODULE_4__["default"](),
  facetedSearch: new _faceted_search__WEBPACK_IMPORTED_MODULE_5__["default"](),
  sortBy: new _sort_by__WEBPACK_IMPORTED_MODULE_6__["default"]()
};
internals.parseHooks = function (hookName) {
  var hookType = hookName.split('-')[0];
  if (internals.classes[hookType] === undefined) {
    throw new Error(hookType + " is not a valid hookType");
  }
  return internals.classes[hookType];
};
var Hooks = /*#__PURE__*/function () {
  function Hooks() {}
  var _proto = Hooks.prototype;
  _proto.on = function on(hookName, callback) {
    var hook = internals.parseHooks(hookName);
    return hook.on(hookName, callback);
  };
  _proto.off = function off(hookName, callback) {
    var hook = internals.parseHooks(hookName);
    return hook.off(hookName, callback);
  };
  _proto.emit = function emit(hookName) {
    var hook = internals.parseHooks(hookName);
    return hook.emit.apply(hook, arguments);
  };
  return Hooks;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Hooks());

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/product.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/product.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.optionsChange();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.optionsChange = function optionsChange() {
    var _this2 = this;
    this.subscribe('change', '[data-product-option-change]', function (event, target) {
      _this2.emit('product-option-change', event, target);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/search.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/search.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.quickSearch();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.quickSearch = function quickSearch() {
    var _this2 = this;
    this.subscribe('input', '[data-search-quick]', function (event, target) {
      _this2.emit('search-quick', event, target);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/sort-by.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/sort-by.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
/* harmony import */ var _lib_closest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/closest */ "./node_modules/@bigcommerce/stencil-utils/src/lib/closest.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }



// ie 11 does not support native closest
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
if (!Element.prototype.closest) {
  Element.prototype.closest = _lib_closest__WEBPACK_IMPORTED_MODULE_1__["default"];
}
var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.sortByEvents();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.sortByEvents = function sortByEvents() {
    var _this2 = this;
    this.subscribe('submit', '[data-sort-by]', function (event, target) {
      _this2.emit('sortBy-submitted', event, target);
    });
    this.subscribe('change', '[data-sort-by] select', function (event, target) {
      _this2.emit('sortBy-select-changed', event, target);
      if (!event.defaultPrevented) {
        _this2.emit('sortBy-submitted', event, target);
      }
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/lib/closest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/lib/closest.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ closest)
/* harmony export */ });
/**
 * ie 11 does not support native closest so use this polyfill function instead to find closest matching selector starting from el.
 * @param {string} params
 * @returns {any} matching selector or null
 */
function closest(s) {
  var el = this;
  do {
    if (el.matches(s)) return el;
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/lib/query-string.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/lib/query-string.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   stringify: () => (/* binding */ stringify)
/* harmony export */ });
/**
 * Encodes string by stricter rules
 * see https://github.com/kevva/strict-uri-encode
 *
 * @param {String} string
 */
var encode = function encode(string) {
  return encodeURIComponent(string).replace(/[!'()*]/g, function (x) {
    return "%" + x.charCodeAt(0).toString(16).toUpperCase();
  });
};

/**
 * Returns an array, where first element is the slice till separator and the second is the rest.
 *
 * @param {String} string
 * @param {String} separator
 */
var splitOnFirst = function splitOnFirst(string, separator) {
  var separatorIndex = string.indexOf(separator);
  if (separatorIndex === -1) {
    return [string];
  }
  return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
};

/**
 * Sorts array or object by keys
 *
 * @param {Array|Object} input
 */
var _sortByKeys = function sortByKeys(input) {
  if (Array.isArray(input)) {
    return input.sort();
  }
  if (typeof input === 'object') {
    return _sortByKeys(Object.keys(input)).sort(function (a, b) {
      return Number(a) - Number(b);
    }).map(function (key) {
      return input[key];
    });
  }
  return input;
};

/**
 * Returns an array if the key exists in the object or the value if doen't
 *
 * @param {String} key
 * @param {String} value
 * @param {Object} accumulator
 */
var getParsedValue = function getParsedValue(key, value, accumulator) {
  if (accumulator[key] === undefined) {
    return value;
  }
  return [].concat(accumulator[key], value);
};

/**
 * Reducer that formats and combines key-value pair
 *
 * @param {String} options
 */
var reduceByKey = function reduceByKey(options) {
  return function (key) {
    return function (result, value) {
      if (value === undefined) {
        return result;
      }
      if (value === null) {
        return [].concat(result, [encode(key)]);
      }
      if (options.includeArrayIndex) {
        if (typeof value === 'object') {
          var _index = result.length / Object.keys(value).length;
          return result.concat(Object.keys(value).map(function (keyOfValue) {
            return [encode(key), '[', encode(_index), ']', '[', encode(keyOfValue), ']=', encode(value[keyOfValue])].join('');
          }));
        }
        var index = result.length;
        return [].concat(result, [[encode(key), '[', encode(index), ']=', encode(value)].join('')]);
      }
      return [].concat(result, [[encode(key), '=', encode(value)].join('')]);
    };
  };
};

/**
 * Converts query string into object
 *
 * @param {String} input
 */
function parse(input) {
  var ret = Object.create(null);
  if (typeof input !== 'string') {
    return ret;
  }
  var inputParsed = input.trim().replace(/^[?#&]/, '');
  if (!inputParsed) {
    return ret;
  }
  inputParsed.split('&').forEach(function (param) {
    /* eslint-disable prefer-const */
    var _splitOnFirst = splitOnFirst(param.replace(/\+/g, ' '), '='),
      key = _splitOnFirst[0],
      value = _splitOnFirst[1];
    key = decodeURIComponent(key);
    value = value === undefined ? null : decodeURIComponent(value);
    ret[key] = getParsedValue(key, value, ret);
  });
  return Object.keys(ret).sort().reduce(function (result, key) {
    var value = ret[key];
    if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
      /* eslint-disable no-param-reassign */
      result[key] = _sortByKeys(value);
    } else {
      /* eslint-disable no-param-reassign */
      result[key] = value;
    }
    return result;
  }, Object.create(null));
}

/**
 * Converts an object to query string
 *
 * @param {Object} object
 * @param {Object} options
 * @param {Boolean} [options.filterValues] - filters empty string or undefineds
 * @param {Boolean} [options.includeArrayIndex] - includes array index in the query string
 */
function stringify(object, options) {
  if (options === void 0) {
    options = {
      filterValues: false,
      arrayIndex: false
    };
  }
  if (!object) {
    return '';
  }
  var objectCopy = {};
  var shouldFilter = function shouldFilter(key) {
    return options.filterValues && (object[key] === '' || object[key] === undefined);
  };
  Object.keys(object).forEach(function (key) {
    if (!shouldFilter(key)) {
      objectCopy[key] = object[key];
    }
  });
  var keys = Object.keys(objectCopy);
  keys.sort();
  return keys.map(function (key) {
    var value = object[key];
    if (value === undefined) {
      return '';
    }
    if (value === null) {
      return encode(key);
    }
    if (Array.isArray(value)) {
      return value.reduce(reduceByKey(options)(key), []).join('&');
    }
    return encode(key) + "=" + encode(value);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&');
}

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/lib/request.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/lib/request.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var whatwg_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! whatwg-fetch */ "./node_modules/whatwg-fetch/fetch.js");
/* harmony import */ var _query_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./query-string */ "./node_modules/@bigcommerce/stencil-utils/src/lib/query-string.js");


/**
 * Checks whether or not the current method passed in is valid
 *
 * @param {String} method
 * @returns {Boolean}
 */
var isValidHTTPMethod = function isValidHTTPMethod(method) {
  return ['GET', 'POST', 'PUT', 'DELETE'].indexOf(method) !== -1;
};

/**
 * Checks if requested template is using sections
 *
 * @param {Object|Array|String} requestedTemplate
 */
var isUsingSections = function isUsingSections(requestedTemplate) {
  return requestedTemplate !== null && typeof requestedTemplate === 'object' && !Array.isArray(requestedTemplate);
};

/**
 * Returns templates array
 *
 * @param {Object|Array|String} requestedTemplate
 * @returns {Array}
 */
var getTemplates = function getTemplates(requestedTemplate) {
  var templates = [];
  if (isUsingSections(requestedTemplate)) {
    templates = Object.values(requestedTemplate);
  } else if (typeof requestedTemplate === 'string') {
    templates = [requestedTemplate];
  } else if (Array.isArray(requestedTemplate) && requestedTemplate.length > 0) {
    templates = requestedTemplate;
  }
  return templates;
};
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(relativeUrl, opts, callback) {
  var defaultOptions = {
    method: 'GET',
    remote: false,
    requestOptions: {
      baseUrl: null,
      formData: null,
      params: {},
      config: {},
      template: []
    }
  };
  var options = Object.assign({}, defaultOptions, opts);
  var data = options.requestOptions.formData ? options.requestOptions.formData : options.requestOptions.params;
  var headers = {
    'stencil-config': options.requestOptions.config ? JSON.stringify(options.requestOptions.config) : '{}',
    'stencil-options': '{}',
    'x-xsrf-token': window.BCData && window.BCData.csrf_token ? window.BCData.csrf_token : '',
    'x-requested-with': 'stencil-utils'
  };
  if (!isValidHTTPMethod(options.method)) {
    return callback(new Error('Not a valid HTTP method'));
  }
  var templates = getTemplates(options.requestOptions.template);
  var usingSections = isUsingSections(options.requestOptions.template);
  var usingTemplates = templates.length > 0;
  if (!options.requestOptions.formData) {
    headers['content-type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
  }
  if (usingTemplates) {
    headers['stencil-options'] = JSON.stringify({
      render_with: templates.join(',')
    });
  }
  var config = {
    method: options.method,
    headers: headers,
    credentials: 'include'
  };
  var url = options.requestOptions.baseUrl ? "" + options.requestOptions.baseUrl + relativeUrl : relativeUrl;
  if (['GET', 'HEAD'].indexOf(config.method) === -1) {
    config.body = !options.requestOptions.formData ? (0,_query_string__WEBPACK_IMPORTED_MODULE_1__.stringify)(data, {
      includeArrayIndex: true
    }) : data;
  } else if (data) {
    var delimiter = !url.includes('?') ? '?' : '&';
    url += "" + delimiter + (0,_query_string__WEBPACK_IMPORTED_MODULE_1__.stringify)(data);
  }
  return fetch(url, config).then(function (response) {
    if (response.headers.get('content-type').indexOf('application/json') !== -1) {
      return response.json();
    }
    return response.text();
  }).then(function (response) {
    var content = options.remote ? response.content : response;
    var ret = response;
    if (usingTemplates) {
      // Remove the `components` prefix from the response if it's an object
      if (typeof content === 'object') {
        Object.keys(content).forEach(function (key) {
          var cleanKey = key.replace(/^components\//, '');
          content[cleanKey] = content[key];
          delete content[key];
        });
      }

      // If using "sections", morph the content into the arbitrary keys => content object.
      if (usingSections) {
        var requestedTemplate = options.requestOptions.template;
        Object.keys(requestedTemplate).forEach(function (templateVariable) {
          content[templateVariable] = content[requestedTemplate[templateVariable]];
          delete content[requestedTemplate[templateVariable]];
        });
      }
      if (!options.remote) {
        ret = content;
      }
    }
    callback(null, ret);
  }).catch(function (err) {
    return callback(err);
  });
}

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/main.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   api: () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   hooks: () => (/* reexport safe */ _hooks__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   tools: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hooks */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api */ "./node_modules/@bigcommerce/stencil-utils/src/api/index.js");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tools */ "./node_modules/@bigcommerce/stencil-utils/src/tools/index.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var StencilUtils = {
  hooks: _hooks__WEBPACK_IMPORTED_MODULE_0__["default"],
  api: _api__WEBPACK_IMPORTED_MODULE_1__["default"],
  tools: _tools__WEBPACK_IMPORTED_MODULE_2__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StencilUtils);

/* global define */
(function (root) {
  if (typeof define === 'function' && __webpack_require__.amdO && root) {
    // Ignores below for https://github.com/eslint/eslint/issues/5150
    define(function () {
      // eslint-disable-line prefer-arrow-callback
      root.stencilUtils = StencilUtils; // eslint-disable-line no-param-reassign
    });
  } else if ( true && module.exports) {
    module.exports = StencilUtils;
  } else {
    window.stencilUtils = StencilUtils;
  }
})(undefined);

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/tools/image.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/tools/image.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
var _default = /*#__PURE__*/function () {
  function _default() {}
  var _proto = _default.prototype;
  _proto.getSrc = function getSrc(path, dimensions) {
    // Regex to test size string is of the form 123x123 or 100w
    var sizeRegex = /(^\d+w$)|(^(\d+?)x(\d+?)$)/g;
    var size;
    if (typeof dimensions === 'object') {
      var width = dimensions.width || 100;
      var height = dimensions.height || 100;
      size = width + "x" + height;
    } else if (typeof dimensions === 'string' && sizeRegex.test(dimensions)) {
      // If dimensions is a string and match the NNNxNNN or NNNw format
      size = dimensions;
    } else {
      // Use the original image size
      size = 'original';
    }
    return path.replace('{:size}', size);
  };
  return _default;
}();


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/tools/imageSrcset.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/tools/imageSrcset.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
var _default = /*#__PURE__*/function () {
  function _default() {}
  var _proto = _default.prototype;
  _proto.getSrcset = function getSrcset(url, sizes) {
    // Regex to test size string is of the form 123x123 or 100w
    var sizeRegex = /(^\d+w$)|(^(\d+?)x(\d+?)$)/;
    // Regex to test to that srcset descriptor is of the form 1x 1.5x 2x OR 123w
    var descriptorRegex = /(^\d+w$)|(^([0-9](\.[0-9]+)?)x)$/;
    var srcsets = {};
    if (!sizes) {
      // Use default srcsets if none are provided
      srcsets = {
        '80w': '80w',
        '160w': '160w',
        '320w': '320w',
        '640w': '640w',
        '960w': '960w',
        '1280w': '1280w',
        '1920w': '1920w',
        '2560w': '2560w'
      };
    } else if (sizes === Object(sizes) && !Object.keys(sizes).some(function (descriptor) {
      return !(descriptorRegex.test(descriptor) && sizeRegex.test(sizes[descriptor]));
    })) {
      // If object consists of valid srcsets, use it instead
      srcsets = sizes;
      // If there's only one argument, return a `src` only (also works for `srcset`)
      if (Object.keys(srcsets).length === 1) {
        return url.replace('{:size}', srcsets[Object.keys(srcsets)[0]]);
      }
    } else {
      throw new Error('Invalid srcset descriptor or size');
    }

    // eslint-disable-next-line new-cap
    return Object.keys(srcsets).map(function (descriptor) {
      return [url.replace('{:size}', srcsets[descriptor]), descriptor].join(' ');
    }).join(', ');
  };
  return _default;
}();


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/tools/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/tools/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image */ "./node_modules/@bigcommerce/stencil-utils/src/tools/image.js");
/* harmony import */ var _imageSrcset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imageSrcset */ "./node_modules/@bigcommerce/stencil-utils/src/tools/imageSrcset.js");
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storage */ "./node_modules/@bigcommerce/stencil-utils/src/tools/storage.js");



var tools = {
  image: new _image__WEBPACK_IMPORTED_MODULE_0__["default"](),
  imageSrcset: new _imageSrcset__WEBPACK_IMPORTED_MODULE_1__["default"](),
  storage: new _storage__WEBPACK_IMPORTED_MODULE_2__["default"]()
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tools);

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/tools/storage.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/tools/storage.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
var _default = /*#__PURE__*/function () {
  function _default() {}
  var _proto = _default.prototype;
  /**
   * Check if a storage type (like localStorage or sessionStorage) is available for use
   * https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Testing_for_availability
   * @param type
   * @returns boolean
   */
  _proto.storageAvailable = function storageAvailable(type) {
    var storage = window[type];
    try {
      var x = '__storage_test__';
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && (
      // everything except Firefox
      e.code === 22
      // Firefox
      || e.code === 1014
      // test name field too, because code might not be present
      // everything except Firefox
      || e.name === 'QuotaExceededError'
      // Firefox
      || e.name === 'NS_ERROR_DOM_QUOTA_REACHED')
      // acknowledge QuotaExceededError only if there's something already stored
      && storage.length !== 0;
    }
  };
  _proto.localStorageAvailable = function localStorageAvailable() {
    return this.storageAvailable('localStorage');
  };
  return _default;
}();


/***/ }),

/***/ "./node_modules/baguettebox.js/dist/baguetteBox.min.js":
/*!*************************************************************!*\
  !*** ./node_modules/baguettebox.js/dist/baguetteBox.min.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * baguetteBox.js
 * @author  feimosi
 * @version 1.12.0
 * @url https://github.com/feimosi/baguetteBox.js
 */
!function(e,t){"use strict"; true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (t),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0}(this,function(){"use strict";var s,l,u,c,d,f='<svg width="44" height="60"><polyline points="30 10 10 30 30 50" stroke="rgba(255,255,255,0.5)" stroke-width="4"stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg>',g='<svg width="44" height="60"><polyline points="14 10 34 30 14 50" stroke="rgba(255,255,255,0.5)" stroke-width="4"stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg>',p='<svg width="30" height="30"><g stroke="rgb(160,160,160)" stroke-width="4"><line x1="5" y1="5" x2="25" y2="25"/><line x1="5" y1="25" x2="25" y2="5"/></g></svg>',b={},v={captions:!0,buttons:"auto",fullScreen:!1,noScrollbars:!1,bodyClass:"baguetteBox-open",titleTag:!1,async:!1,preload:2,animation:"slideIn",afterShow:null,afterHide:null,onChange:null,overlayBackgroundColor:"rgba(0,0,0,.8)",closeX:p,leftArrow:f,rightArrow:g},m={},h=[],o=0,n=!1,i={},a=!1,y=/.+\.(gif|jpe?g|png|webp)/i,w={},k=[],r=null,x=function(e){-1!==e.target.id.indexOf("baguette-img")&&X()},E=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,q()},C=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,j()},B=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,X()},T=function(e){i.count++,1<i.count&&(i.multitouch=!0),i.startX=e.changedTouches[0].pageX,i.startY=e.changedTouches[0].pageY},A=function(e){if(!a&&!i.multitouch){e.preventDefault?e.preventDefault():e.returnValue=!1;var t=e.touches[0]||e.changedTouches[0];40<t.pageX-i.startX?(a=!0,q()):t.pageX-i.startX<-40?(a=!0,j()):100<i.startY-t.pageY&&X()}},L=function(){i.count--,i.count<=0&&(i.multitouch=!1),a=!1},N=function(){L()},H=function(e){"block"===s.style.display&&s.contains&&!s.contains(e.target)&&(e.stopPropagation(),M())};function P(e){if(w.hasOwnProperty(e)){var t=w[e].galleries;[].forEach.call(t,function(e){[].forEach.call(e,function(e){W(e.imageElement,"click",e.eventHandler)}),h===e&&(h=[])}),delete w[e]}}function S(e){switch(e.keyCode){case 37:q();break;case 39:j();break;case 27:X();break;case 36:!function t(e){e&&e.preventDefault();return D(0)}(e);break;case 35:!function n(e){e&&e.preventDefault();return D(h.length-1)}(e)}}function F(e,t){if(h!==e){for(h=e,function r(e){e=e||{};for(var t in v)b[t]=v[t],"undefined"!=typeof e[t]&&(b[t]=e[t]);l.style.transition=l.style.webkitTransition="fadeIn"===b.animation?"opacity .4s ease":"slideIn"===b.animation?"":"none","auto"===b.buttons&&("ontouchstart"in window||1===h.length)&&(b.buttons=!1);u.style.display=c.style.display=b.buttons?"":"none",d.innerHTML=b.closeX,b.buttons&&(u.innerHTML=b.leftArrow,c.innerHTML=b.rightArrow);try{s.style.backgroundColor=b.overlayBackgroundColor}catch(n){}}(t);l.firstChild;)l.removeChild(l.firstChild);for(var n,o=[],i=[],a=k.length=0;a<e.length;a++)(n=J("div")).className="full-image",n.id="baguette-img-"+a,k.push(n),o.push("baguetteBox-figure-"+a),i.push("baguetteBox-figcaption-"+a),l.appendChild(k[a]);s.setAttribute("aria-labelledby",o.join(" ")),s.setAttribute("aria-describedby",i.join(" "))}}function I(e){b.noScrollbars&&(document.documentElement.style.overflowY="hidden",document.body.style.overflowY="scroll"),"block"!==s.style.display&&(U(document,"keydown",S),i={count:0,startX:null,startY:null},Y(o=e,function(){z(o),V(o)}),R(),s.style.display="block",b.fullScreen&&function t(){s.requestFullscreen?s.requestFullscreen():s.webkitRequestFullscreen?s.webkitRequestFullscreen():s.mozRequestFullScreen&&s.mozRequestFullScreen()}(),setTimeout(function(){s.className="visible",b.bodyClass&&document.body.classList&&document.body.classList.add(b.bodyClass),b.afterShow&&b.afterShow()},50),b.onChange&&b.onChange(o,k.length),r=document.activeElement,M(),n=!0)}function M(){b.buttons?u.focus():d.focus()}function X(){b.noScrollbars&&(document.documentElement.style.overflowY="auto",document.body.style.overflowY="auto"),"none"!==s.style.display&&(W(document,"keydown",S),s.className="",setTimeout(function(){s.style.display="none",document.fullscreen&&function e(){document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen()}(),b.bodyClass&&document.body.classList&&document.body.classList.remove(b.bodyClass),b.afterHide&&b.afterHide(),r&&r.focus(),n=!1},500))}function Y(t,n){var e=k[t],o=h[t];if(void 0!==e&&void 0!==o)if(e.getElementsByTagName("img")[0])n&&n();else{var i=o.imageElement,a=i.getElementsByTagName("img")[0],r="function"==typeof b.captions?b.captions.call(h,i):i.getAttribute("data-caption")||i.title,s=function d(e){var t=e.href;if(e.dataset){var n=[];for(var o in e.dataset)"at-"!==o.substring(0,3)||isNaN(o.substring(3))||(n[o.replace("at-","")]=e.dataset[o]);for(var i=Object.keys(n).sort(function(e,t){return parseInt(e,10)<parseInt(t,10)?-1:1}),a=window.innerWidth*window.devicePixelRatio,r=0;r<i.length-1&&i[r]<a;)r++;t=n[i[r]]||t}return t}(i),l=J("figure");if(l.id="baguetteBox-figure-"+t,l.innerHTML='<div class="baguetteBox-spinner"><div class="baguetteBox-double-bounce1"></div><div class="baguetteBox-double-bounce2"></div></div>',b.captions&&r){var u=J("figcaption");u.id="baguetteBox-figcaption-"+t,u.innerHTML=r,l.appendChild(u)}e.appendChild(l);var c=J("img");c.onload=function(){var e=document.querySelector("#baguette-img-"+t+" .baguetteBox-spinner");l.removeChild(e),!b.async&&n&&n()},c.setAttribute("src",s),c.alt=a&&a.alt||"",b.titleTag&&r&&(c.title=r),l.appendChild(c),b.async&&n&&n()}}function j(){return D(o+1)}function q(){return D(o-1)}function D(e,t){return!n&&0<=e&&e<t.length?(F(t,b),I(e),!0):e<0?(b.animation&&O("left"),!1):e>=k.length?(b.animation&&O("right"),!1):(Y(o=e,function(){z(o),V(o)}),R(),b.onChange&&b.onChange(o,k.length),!0)}function O(e){l.className="bounce-from-"+e,setTimeout(function(){l.className=""},400)}function R(){var e=100*-o+"%";"fadeIn"===b.animation?(l.style.opacity=0,setTimeout(function(){m.transforms?l.style.transform=l.style.webkitTransform="translate3d("+e+",0,0)":l.style.left=e,l.style.opacity=1},400)):m.transforms?l.style.transform=l.style.webkitTransform="translate3d("+e+",0,0)":l.style.left=e}function z(e){e-o>=b.preload||Y(e+1,function(){z(e+1)})}function V(e){o-e>=b.preload||Y(e-1,function(){V(e-1)})}function U(e,t,n,o){e.addEventListener?e.addEventListener(t,n,o):e.attachEvent("on"+t,function(e){(e=e||window.event).target=e.target||e.srcElement,n(e)})}function W(e,t,n,o){e.removeEventListener?e.removeEventListener(t,n,o):e.detachEvent("on"+t,n)}function G(e){return document.getElementById(e)}function J(e){return document.createElement(e)}return[].forEach||(Array.prototype.forEach=function(e,t){for(var n=0;n<this.length;n++)e.call(t,this[n],n,this)}),[].filter||(Array.prototype.filter=function(e,t,n,o,i){for(n=this,o=[],i=0;i<n.length;i++)e.call(t,n[i],i,n)&&o.push(n[i]);return o}),{run:function K(e,t){return m.transforms=function n(){var e=J("div");return"undefined"!=typeof e.style.perspective||"undefined"!=typeof e.style.webkitPerspective}(),m.svg=function o(){var e=J("div");return e.innerHTML="<svg/>","http://www.w3.org/2000/svg"===(e.firstChild&&e.firstChild.namespaceURI)}(),m.passiveEvents=function i(){var e=!1;try{var t=Object.defineProperty({},"passive",{get:function(){e=!0}});window.addEventListener("test",null,t)}catch(n){}return e}(),function a(){if(s=G("baguetteBox-overlay"))return l=G("baguetteBox-slider"),u=G("previous-button"),c=G("next-button"),void(d=G("close-button"));(s=J("div")).setAttribute("role","dialog"),s.id="baguetteBox-overlay",document.getElementsByTagName("body")[0].appendChild(s),(l=J("div")).id="baguetteBox-slider",s.appendChild(l),(u=J("button")).setAttribute("type","button"),u.id="previous-button",u.setAttribute("aria-label","Previous"),u.innerHTML=m.svg?f:"&lt;",s.appendChild(u),(c=J("button")).setAttribute("type","button"),c.id="next-button",c.setAttribute("aria-label","Next"),c.innerHTML=m.svg?g:"&gt;",s.appendChild(c),(d=J("button")).setAttribute("type","button"),d.id="close-button",d.setAttribute("aria-label","Close"),d.innerHTML=m.svg?p:"&times;",s.appendChild(d),u.className=c.className=d.className="baguetteBox-button",function n(){var e=m.passiveEvents?{passive:!1}:null,t=m.passiveEvents?{passive:!0}:null;U(s,"click",x),U(u,"click",E),U(c,"click",C),U(d,"click",B),U(l,"contextmenu",N),U(s,"touchstart",T,t),U(s,"touchmove",A,e),U(s,"touchend",L),U(document,"focus",H,!0)}()}(),P(e),function r(e,a){var t=document.querySelectorAll(e),n={galleries:[],nodeList:t};return w[e]=n,[].forEach.call(t,function(e){a&&a.filter&&(y=a.filter);var t=[];if(t="A"===e.tagName?[e]:e.getElementsByTagName("a"),0!==(t=[].filter.call(t,function(e){if(-1===e.className.indexOf(a&&a.ignoreClass))return y.test(e.href)})).length){var i=[];[].forEach.call(t,function(e,t){var n=function(e){e.preventDefault?e.preventDefault():e.returnValue=!1,F(i,a),I(t)},o={eventHandler:n,imageElement:e};U(e,"click",n),i.push(o)}),n.galleries.push(i)}}),n.galleries}(e,t)},show:D,showNext:j,showPrevious:q,hide:X,destroy:function e(){!function n(){var e=m.passiveEvents?{passive:!1}:null,t=m.passiveEvents?{passive:!0}:null;W(s,"click",x),W(u,"click",E),W(c,"click",C),W(d,"click",B),W(l,"contextmenu",N),W(s,"touchstart",T,t),W(s,"touchmove",A,e),W(s,"touchend",L),W(document,"focus",H,!0)}(),function t(){for(var e in w)w.hasOwnProperty(e)&&P(e)}(),W(document,"keydown",S),document.getElementsByTagName("body")[0].removeChild(document.getElementById("baguetteBox-overlay")),w={},h=[],o=0}}});

/***/ }),

/***/ "./node_modules/bc-compare/dist/js/ProductCompare.js":
/*!***********************************************************!*\
  !*** ./node_modules/bc-compare/dist/js/ProductCompare.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

var _lodash = __webpack_require__(/*! lodash.template */ "./node_modules/lodash.template/index.js");

var _lodash2 = _interopRequireDefault(_lodash);

var _jqueryTrend = __webpack_require__(/*! jquery-trend */ "./node_modules/bc-compare/node_modules/jquery-trend/jquery.trend.js");

var _jqueryTrend2 = _interopRequireDefault(_jqueryTrend);

var _jqueryRevealer = __webpack_require__(/*! jquery-revealer */ "./node_modules/bc-compare/node_modules/jquery-revealer/jquery.revealer.js");

var _jqueryRevealer2 = _interopRequireDefault(_jqueryRevealer);

var _eventemitter = __webpack_require__(/*! eventemitter2 */ "./node_modules/eventemitter2/lib/eventemitter2.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Product Comparison Widget
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ProductCompare = function (_EventEmitter) {
  _inherits(ProductCompare, _EventEmitter);

  function ProductCompare() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ProductCompare);

    var _this = _possibleConstructorReturn(this, (ProductCompare.__proto__ || Object.getPrototypeOf(ProductCompare)).call(this));

    _this.options = _jquery2.default.extend({
      scope: '[data-product-compare]',
      maxItems: 4,
      itemTemplate: (0, _lodash2.default)('\n        <div class="compare-item" data-compare-item>\n          <a href="<%= url %>">\n            <img class="compare-item-thumbnail" src="<%= thumbnail %>"/>\n            <div class="compare-item-price"><%= price %></div>\n            <div class="compare-item-title"><%= title %></div>\n          </a>\n          <button class="compare-item-remove" data-compare-item-remove="<%= id %>">&times;</button>\n        </div>\n      ')
    }, options);

    _this.$scope = (0, _jquery2.default)(_this.options.scope);
    _this.$compareItems = (0, _jquery2.default)('[data-compare-items]');
    _this.$compareLink = (0, _jquery2.default)('[data-compare-link]');

    _this.checkbox = '[data-compare-checkbox]';
    _this.compareItem = '[data-compare-item]';
    _this.compareRemove = 'data-compare-item-remove';

    _this._init();
    _this._bindEvents();
    return _this;
  }

  /**
   *
   * Set up the compare list Map
   *
   */

  _createClass(ProductCompare, [{
    key: '_init',
    value: function _init() {
      if (sessionStorage.getItem('compare')) {
        this.compareList = new Map(JSON.parse(sessionStorage.getItem('compare')));
        this._initWidget();
      } else {
        this.compareList = new Map();
      }
    }

    /**
     *
     * Bind event handlers for the compare widget
     *
     */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$scope.on('change', this.checkbox, function (event) {
        _this2._toggleItem(event.target);
      });

      (0, _jquery2.default)('body').on('click', '[' + this.compareRemove + ']', function (event) {
        var id = parseInt((0, _jquery2.default)(event.target).attr(_this2.compareRemove), 10);
        _this2._removeItem(id);

        return false;
      });
    }

    /**
     *
     * Sets the inital state of widget if loading from sessionStorage
     *
     */

  }, {
    key: '_initWidget',
    value: function _initWidget() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.compareList.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var id = _step.value;

          this._checkCheckbox(id);

          this._populateWidget(id);

          this._updateWidgetState();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     *
     * Updates a checkbox state to "checked"
     *
     * @param {id} number The ID of the item / checkbox to target
     *
     */

  }, {
    key: '_checkCheckbox',
    value: function _checkCheckbox(id) {
      (0, _jquery2.default)('[data-compare-id="' + id + '"]').prop('checked', true);
    }

    /**
     *
     * Adds an item to the widget
     *
     * @param {id} number The ID of the item it add
     *
     */

  }, {
    key: '_populateWidget',
    value: function _populateWidget(id) {
      (0, _jquery2.default)(this.options.itemTemplate(this.compareList.get(id))).appendTo(this.$compareItems).revealer('show');
    }

    /**
     *
     * Controls whether to add or remove a product from the compare list
     *
     * @param {string} checkbox The checkbox (dom element)
     *
     */

  }, {
    key: '_toggleItem',
    value: function _toggleItem(checkbox) {
      var $checkbox = (0, _jquery2.default)(checkbox);
      var id = parseInt($checkbox.data('compare-id'), 10);
      var productData = {
        id: id,
        title: $checkbox.data('compare-title'),
        url: $checkbox.data('compare-url'),
        price: $checkbox.data('compare-price'),
        thumbnail: $checkbox.data('compare-thumbnail')
      };

      // Add / remove item from compare list
      if (checkbox.checked) {
        this._addItem(id, productData);

        // Generate an array of the compare IDs so we can target the first item
        var compareIds = [].concat(_toConsumableArray(this.compareList.keys()));

        // Remove the first item from the list if > maxItems
        if (this.compareList.size > this.options.maxItems) {
          var firstItem = compareIds[0];
          this._removeItem(firstItem);
        }
      } else {
        this._removeItem(id);
      }
    }

    /**
     *
     * Adds an item to the compare list
     *
     * @param {number} id The ID of the item to add
     * @param {object} productData Object containing the data of a compare item
     *
     */

  }, {
    key: '_addItem',
    value: function _addItem(id, productData) {
      this.emit('beforeadd', id);

      this.compareList.set(id, productData);

      this._populateWidget(id);

      this._updateWidgetState();

      this.emit('afteradd', id);
    }

    /**
     *
     * Removes an item from the compare list
     *
     * @param {number} id The ID of the item to remove
     *
     */

  }, {
    key: '_removeItem',
    value: function _removeItem(id) {
      this.emit('beforeremove', id);

      this.compareList.delete(id);

      this.$compareItems.find('[' + this.compareRemove + '=' + id + ']').closest(this.compareItem).revealer('hide');

      (0, _jquery2.default)(this.compareItem).on('revealer-hide', function (event) {
        (0, _jquery2.default)(event.currentTarget).remove();
      });

      // Uncheck the checkbox if removed via button
      (0, _jquery2.default)('[data-compare-id="' + id + '"]').prop('checked', false);

      this._updateWidgetState();

      this.emit('afterremove', id);
    }

    /**
     *
     * Public method to clear the list and widget items
     *
     */

  }, {
    key: 'removeAll',
    value: function removeAll() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.compareList.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var id = _step2.value;

          this._removeItem(id);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    /**
     *
     * Sets each checkbox in the compare list to "checked".
     * Useful if products are loaded dynamically and the widget is already initialized.
     *
     */

  }, {
    key: 'updateCheckboxes',
    value: function updateCheckboxes() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.compareList.keys()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var id = _step3.value;

          this._checkCheckbox(id);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    /**
     *
     * Updates the compare widget state
     *
     */

  }, {
    key: '_updateWidgetState',
    value: function _updateWidgetState() {
      var compareLength = this.compareList.size;

      // Toggle widget state class
      (0, _jquery2.default)('[data-compare-widget]').toggleClass('is-enabled', !!compareLength);

      // Toggle compare link class
      this.$compareLink.toggleClass('is-disabled', compareLength <= 1);

      // Set compare link href
      this.$compareLink.attr('href', this.$compareLink.data('compare-link') + '/' + [].concat(_toConsumableArray(this.compareList.keys())).join('/'));

      // Save the compare data for later
      sessionStorage.setItem('compare', JSON.stringify([].concat(_toConsumableArray(this.compareList))));

      this.emit('updated');
    }

    /**
     *
     * Over-ride EventEmitter's "on" method so that events can be fired immediately after they're bound
     *
     */

  }, {
    key: 'on',
    value: function on(eventName, handler) {
      var fireOnBind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _get(ProductCompare.prototype.__proto__ || Object.getPrototypeOf(ProductCompare.prototype), 'on', this).call(this, eventName, handler);
      if (fireOnBind) {
        this.emit(eventName);
      }
    }
  }]);

  return ProductCompare;
}(_eventemitter2.default);

exports["default"] = ProductCompare;

/***/ }),

/***/ "./node_modules/bc-compare/node_modules/jquery-revealer/jquery.revealer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/bc-compare/node_modules/jquery-revealer/jquery.revealer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Revealer 3.0.0
 *
 * Copyright 2021, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
(function($){
  // check for trend event (make sure jquery.trend is included)
  if (typeof $.event.special.trend !== "object") {
    console.warn("Please make sure jquery.trend is included! Otherwise revealer won't work.");
  }

  // Simple requestAnimationFrame polyfill
  var raf = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function(fn) { window.setTimeout(fn, 1000/60); }


  // Public API
  var methods = {
    isVisible: function(el) {
      return !!el.data("revealer-visible");
    },

    show: function(el, force) {
      // Check state
      if (methods.isVisible(el)) {
        el.removeClass("animating animating-in");
        el.off("revealer-animating revealer-show");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", true);
      el.off("trend");

      if (force) {
        el.addClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-show");
        });
        return;
      }

      raf(function(){
        // Start animation state transition
        el.addClass("animating animating-in");
        el.trigger("revealer-animating");

        raf(function(){
          el.addClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in");
            el.trigger("revealer-show");
          });
        });
      });
    },

    hide: function(el, force) {
      // Check state
      if (!methods.isVisible(el)) {
        el.removeClass("animating animating-out visible");
        el.off("revealer-animating revealer-hide");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", false);
      el.off("trend");

      if (force) {
        el.removeClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-hide");
        });
        return;
      }

      raf(function(){
        el.addClass("animating animating-out");
        el.trigger("revealer-animating");

        raf(function(){
          el.removeClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in animating-out");
            el.trigger("revealer-hide");
          });
        });
      });
    },

    toggle: function(el, force) {
      if (methods.isVisible(el)) {
        methods.hide(el, force);
      } else {
        methods.show(el, force);
      }
    }
  };

  // jQuery plugin
  $.fn.revealer = function(method, force) {
    // Get action
    var action = methods[method || "toggle"];
    if (!action) return this;

    // Run action
    if (method === "isVisible") {
      return action(this);
    }

    return this.each(function(){
      action($(this), force);
    });
  };
})(jQuery);


/***/ }),

/***/ "./node_modules/bc-compare/node_modules/jquery-trend/jquery.trend.js":
/*!***************************************************************************!*\
  !*** ./node_modules/bc-compare/node_modules/jquery-trend/jquery.trend.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Trend 0.1.0
 *
 * Fail-safe TransitionEnd event for jQuery.
 *
 * Adds a new "trend" event that can be used in browsers that don't
 * support "transitionend".
 *
 * NOTE: Only supports being bound with "jQuery.one".
 *
 * Copyright 2014, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
;(function($){

  // Prefixed transitionend event names
  var transitionEndEvents =
    "webkitTransitionEnd " +
    "otransitionend " +
    "oTransitionEnd " +
    "msTransitionEnd " +
    "transitionend";

  // Prefixed transition duration property names
  var transitionDurationProperties = [
    "transition-duration",
    "-moz-transition-duration",
    "-webkit-transition-duration",
    "-ms-transition-duration",
    "-o-transition-duration",
    "-khtml-transition-duration"
  ];

  // Parses a CSS duration value into milliseconds.
  var parseDuration = function(s) {
    s = s.replace(/\s/, "");
    var v = window.parseFloat(s);

    return s.match(/[^m]s$/i)
      ? v * 1000
      : v;
  };

  // Get the transition duration for an element, as specified by CSS.
  // Returns a value in milliseconds.
  var getTransitionDuration = function(el) {
    var duration = 0;

    for (var i = 0; i < transitionDurationProperties.length; i++) {
      // Get raw CSS value
      var value = el.css(transitionDurationProperties[i]);
      if (!value) continue;

      // Multiple transitions--pick the longest
      if (value.indexOf(",") !== -1) {
        var values = value.split(",");
        var durations = (function(){
          var results = [];
          for (var i = 0; i < values.length; i++) {
            var duration = parseDuration(values[i]);
            results.push(duration);
          }
          return results;
        })();

        duration = Math.max.apply(Math, durations);
      }

      // Single transition
      else {
        duration = parseDuration(value);
      }

      // Accept first vaue
      break;
    }

    return duration;
  };

  $.event.special.trend = {
    // Triggers an event handler when an element is done transitioning.
    //
    // Handles browsers that don't support transitionend by adding a
    // timeout with the transition duration.
    add: function(handleObj) {
      var el = $(this);
      var fired = false;

      // Mark element as being in transition
      el.data("trend", true);

      // Calculate a fallback duration. + 20 because some browsers fire
      // timeouts faster than transitionend.
      var duration = getTransitionDuration(el) + 20;

      var cb = function(e) {
        // transitionend events can be sent for each property. Let's just
        // skip all but the first. Also handles the timeout callback.
        if (fired) return;

        // Child elements that also have transitions can be fired before we
        // complete. This will catch and ignore those. Unfortunately, we'll
        // have to rely on the timeout in these cases.
        if (e && e.srcElement !== el[0]) return;

        // Mark element has not being in transition
        el.data("trend", false);

        // Callback
        fired = true;
        if (handleObj.handler) handleObj.handler();
      };

      el.one(transitionEndEvents, cb);
      el.data("trend-timeout", window.setTimeout(cb, duration));
    },

    remove: function(handleObj) {
      var el = $(this);
      el.off(transitionEndEvents);
      window.clearTimeout(el.data("trend-timeout"));
    }
  };

})(jQuery);


/***/ }),

/***/ "./node_modules/bc-loading/dist/loading.js":
/*!*************************************************!*\
  !*** ./node_modules/bc-loading/dist/loading.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

var _jqueryTrend = __webpack_require__(/*! jquery-trend */ "./node_modules/bc-loading/node_modules/jquery-trend/jquery.trend.js");

var _jqueryTrend2 = _interopRequireDefault(_jqueryTrend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LoadingUtils = function () {
  function LoadingUtils(options, scrollLock, el) {
    _classCallCheck(this, LoadingUtils);

    this.scrollLock = scrollLock;
    this.$body = (0, _jquery2.default)(document.body);
    this.$el = el ? (0, _jquery2.default)(el) : this.$body;

    this.options = _jquery2.default.extend({
      loadingMarkup: '<div class="loading"><span class="loading-spinner"></span></div>',
      visibleClass: 'visible',
      scrollLockClass: 'scroll-locked'
    }, options);

    this.$loading = (0, _jquery2.default)(this.options.loadingMarkup);
  }

  _createClass(LoadingUtils, [{
    key: 'show',
    value: function show() {
      var _this = this;

      if (this.scrollLock) {
        this.$body.addClass(this.options.scrollLockClass);
      }

      var elementPositioning = this.$el.css('position');

      if (elementPositioning === 'static') {
        this.$el.css('position', 'relative');
      }

      this.$el.prepend(this.$loading);

      setTimeout(function () {
        _this.$loading.addClass(_this.options.visibleClass);
      }, 10);
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this2 = this;

      if (this.scrollLock) {
        this.$body.removeClass(this.options.scrollLockClass);
      }

      this.$loading.removeClass(this.options.visibleClass).one('trend', function () {
        _this2.$loading.remove();
      });
    }
  }]);

  return LoadingUtils;
}();

exports["default"] = LoadingUtils;

/***/ }),

/***/ "./node_modules/bc-loading/node_modules/jquery-trend/jquery.trend.js":
/*!***************************************************************************!*\
  !*** ./node_modules/bc-loading/node_modules/jquery-trend/jquery.trend.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Trend 0.1.0
 *
 * Fail-safe TransitionEnd event for jQuery.
 *
 * Adds a new "trend" event that can be used in browsers that don't
 * support "transitionend".
 *
 * NOTE: Only supports being bound with "jQuery.one".
 *
 * Copyright 2014, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
;(function($){

  // Prefixed transitionend event names
  var transitionEndEvents =
    "webkitTransitionEnd " +
    "otransitionend " +
    "oTransitionEnd " +
    "msTransitionEnd " +
    "transitionend";

  // Prefixed transition duration property names
  var transitionDurationProperties = [
    "transition-duration",
    "-moz-transition-duration",
    "-webkit-transition-duration",
    "-ms-transition-duration",
    "-o-transition-duration",
    "-khtml-transition-duration"
  ];

  // Parses a CSS duration value into milliseconds.
  var parseDuration = function(s) {
    s = s.replace(/\s/, "");
    var v = window.parseFloat(s);

    return s.match(/[^m]s$/i)
      ? v * 1000
      : v;
  };

  // Get the transition duration for an element, as specified by CSS.
  // Returns a value in milliseconds.
  var getTransitionDuration = function(el) {
    var duration = 0;

    for (var i = 0; i < transitionDurationProperties.length; i++) {
      // Get raw CSS value
      var value = el.css(transitionDurationProperties[i]);
      if (!value) continue;

      // Multiple transitions--pick the longest
      if (value.indexOf(",") !== -1) {
        var values = value.split(",");
        var durations = (function(){
          var results = [];
          for (var i = 0; i < values.length; i++) {
            var duration = parseDuration(values[i]);
            results.push(duration);
          }
          return results;
        })();

        duration = Math.max.apply(Math, durations);
      }

      // Single transition
      else {
        duration = parseDuration(value);
      }

      // Accept first vaue
      break;
    }

    return duration;
  };

  $.event.special.trend = {
    // Triggers an event handler when an element is done transitioning.
    //
    // Handles browsers that don't support transitionend by adding a
    // timeout with the transition duration.
    add: function(handleObj) {
      var el = $(this);
      var fired = false;

      // Mark element as being in transition
      el.data("trend", true);

      // Calculate a fallback duration. + 20 because some browsers fire
      // timeouts faster than transitionend.
      var duration = getTransitionDuration(el) + 20;

      var cb = function(e) {
        // transitionend events can be sent for each property. Let's just
        // skip all but the first. Also handles the timeout callback.
        if (fired) return;

        // Child elements that also have transitions can be fired before we
        // complete. This will catch and ignore those. Unfortunately, we'll
        // have to rely on the timeout in these cases.
        if (e && e.srcElement !== el[0]) return;

        // Mark element has not being in transition
        el.data("trend", false);

        // Callback
        fired = true;
        if (handleObj.handler) handleObj.handler();
      };

      el.one(transitionEndEvents, cb);
      el.data("trend-timeout", window.setTimeout(cb, duration));
    },

    remove: function(handleObj) {
      var el = $(this);
      el.off(transitionEndEvents);
      window.clearTimeout(el.data("trend-timeout"));
    }
  };

})(jQuery);


/***/ }),

/***/ "./node_modules/bc-modal/dist/js/modal.js":
/*!************************************************!*\
  !*** ./node_modules/bc-modal/dist/js/modal.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

var _jqueryTrend = __webpack_require__(/*! jquery-trend */ "./node_modules/bc-modal/node_modules/jquery-trend/jquery.trend.js");

var _jqueryTrend2 = _interopRequireDefault(_jqueryTrend);

var _jqueryRevealer = __webpack_require__(/*! jquery-revealer */ "./node_modules/bc-modal/node_modules/jquery-revealer/jquery.revealer.js");

var _jqueryRevealer2 = _interopRequireDefault(_jqueryRevealer);

var _justDebounce = __webpack_require__(/*! just-debounce */ "./node_modules/just-debounce/index.js");

var _justDebounce2 = _interopRequireDefault(_justDebounce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Modal = function () {
  function Modal(options) {
    _classCallCheck(this, Modal);

    this.$modal;
    this.$modalContent;
    this.$dialog;
    this.$body = (0, _jquery2.default)('body');
    this.$el = (0, _jquery2.default)(options.el);
    this.$backdrop = (0, _jquery2.default)('<div class="modal-overlay">');

    this.options = _jquery2.default.extend({
      modalId: 'modal',
      modalClass: '',
      bodyOverflowClass: 'scroll-locked',
      centerVertically: true,
      closeSelector: '.modal-close',
      afterShow: function afterShow() {},
      afterHide: function afterHide() {}
    }, options);

    this.wrapperHtml = '<div id="' + this.options.modalId + '" class="modal-wrapper" tabindex="-1" role="dialog"><div class="' + this.options.modalClass + ' modal" role="document"><div class="modal-content">';
  }

  /**
   * set up our fresh modal element
   */


  _createClass(Modal, [{
    key: '_init',
    value: function _init() {
      // get the contents
      this.$modalContent = this.$el.children().detach();
      // create a new wrapping element
      this.$modal = (0, _jquery2.default)(this.wrapperHtml);
      // pop our content in there
      this.$modal.find('.modal-content').append(this.$modalContent);
      // add backdrop
      this.$backdrop.appendTo(this.$body);
    }

    /**
     * Put everything back where they used to be
     */

  }, {
    key: '_reset',
    value: function _reset() {
      this.$modal.detach();
      this.$el.append(this.$modalContent);
    }

    /**
     * Show both the modal and backdrop
     */

  }, {
    key: '_open',
    value: function _open() {
      var _this = this;

      this._init();
      this._bindOverlayClick();
      this._bindCloseClick();
      this._bindCloseEsc();

      this.$body.addClass(this.options.bodyOverflowClass).append(this.$modal);

      if (this.options.centerVertically) {
        this.$dialog = this.$modal.find('.modal');
        this._bindResize();

        // position modal for the first time just after it's been unhidden
        this.$modal.one('revealer-animating', function () {
          _this._reposition();
        });
      }

      // bind callback function
      this.$modal.one('revealer-show', function (event) {
        _this.options.afterShow((0, _jquery2.default)(event.currentTarget));
      });

      // show both modal & backdrop
      this.$modal.add(this.$backdrop).revealer('show');

      // set up backdrop removal on hide
      this.$backdrop.on('revealer-hide', function () {
        _this.$backdrop.remove();
        _this.options.afterHide();
      });
    }

    /**
     * Hide  both the modal and backdrop
     */

  }, {
    key: '_close',
    value: function _close() {
      this.$modal.add(this.$backdrop).revealer('hide');

      this.$body.removeClass(this.options.bodyOverflowClass);

      this._unbindResize();
      this._reset();
    }

    /**
     * close modal if we click only on backdrop
     */

  }, {
    key: '_bindOverlayClick',
    value: function _bindOverlayClick() {
      var _this2 = this;

      this.$modal.on('click', function (event) {
        if (event.target === event.currentTarget) {
          _this2._close();
        }
      });
    }

    /**
     * close modal if we click on a close button
     */

  }, {
    key: '_bindCloseClick',
    value: function _bindCloseClick() {
      var _this3 = this;

      this.$modal.on('click', this.options.closeSelector, function (event) {
        event.preventDefault();
        _this3._close();
      });
    }

    /**
     * close modal if we press the escape button when it's visible
     */

  }, {
    key: '_bindCloseEsc',
    value: function _bindCloseEsc() {
      var _this4 = this;

      (0, _jquery2.default)(document).on('keyup', function (event) {
        if (event.keyCode === 27 && _this4.$modal.revealer('isVisible')) {
          event.preventDefault();
          _this4._close();
        }
      });
    }

    // -------------------------- Positioning -------------------------- //

    /**
     * calculate margin-top for element
     */

  }, {
    key: '_reposition',
    value: function _reposition() {
      if (!this.$dialog || !this.options.centerVertically) {
        return;
      }

      var elHeight = this.$dialog.outerHeight();
      var windowHeight = (0, _jquery2.default)(window).height();
      var diff = (windowHeight - elHeight) / 2;

      diff = diff < 0 ? 0 : diff;

      this.$dialog.css('margin-top', diff);
    }
  }, {
    key: '_bindResize',
    value: function _bindResize() {
      var _this5 = this;

      (0, _jquery2.default)(window).on('resize.modal', (0, _justDebounce2.default)(function () {
        _this5._reposition.bind(_this5);
      }, 100));
    }
  }, {
    key: '_unbindResize',
    value: function _unbindResize() {
      (0, _jquery2.default)(window).off('resize.modal');
    }

    // -------------------------- Expose Public Methods -------------------------- //

  }, {
    key: 'open',
    value: function open() {
      this._open();
    }
  }, {
    key: 'close',
    value: function close() {
      this._close();
    }
  }, {
    key: 'position',
    value: function position() {
      this._reposition();
    }
  }]);

  return Modal;
}();

exports["default"] = Modal;

/***/ }),

/***/ "./node_modules/bc-modal/node_modules/jquery-revealer/jquery.revealer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/bc-modal/node_modules/jquery-revealer/jquery.revealer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Revealer 3.0.0
 *
 * Copyright 2021, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
(function($){
  // check for trend event (make sure jquery.trend is included)
  if (typeof $.event.special.trend !== "object") {
    console.warn("Please make sure jquery.trend is included! Otherwise revealer won't work.");
  }

  // Simple requestAnimationFrame polyfill
  var raf = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function(fn) { window.setTimeout(fn, 1000/60); }


  // Public API
  var methods = {
    isVisible: function(el) {
      return !!el.data("revealer-visible");
    },

    show: function(el, force) {
      // Check state
      if (methods.isVisible(el)) {
        el.removeClass("animating animating-in");
        el.off("revealer-animating revealer-show");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", true);
      el.off("trend");

      if (force) {
        el.addClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-show");
        });
        return;
      }

      raf(function(){
        // Start animation state transition
        el.addClass("animating animating-in");
        el.trigger("revealer-animating");

        raf(function(){
          el.addClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in");
            el.trigger("revealer-show");
          });
        });
      });
    },

    hide: function(el, force) {
      // Check state
      if (!methods.isVisible(el)) {
        el.removeClass("animating animating-out visible");
        el.off("revealer-animating revealer-hide");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", false);
      el.off("trend");

      if (force) {
        el.removeClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-hide");
        });
        return;
      }

      raf(function(){
        el.addClass("animating animating-out");
        el.trigger("revealer-animating");

        raf(function(){
          el.removeClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in animating-out");
            el.trigger("revealer-hide");
          });
        });
      });
    },

    toggle: function(el, force) {
      if (methods.isVisible(el)) {
        methods.hide(el, force);
      } else {
        methods.show(el, force);
      }
    }
  };

  // jQuery plugin
  $.fn.revealer = function(method, force) {
    // Get action
    var action = methods[method || "toggle"];
    if (!action) return this;

    // Run action
    if (method === "isVisible") {
      return action(this);
    }

    return this.each(function(){
      action($(this), force);
    });
  };
})(jQuery);


/***/ }),

/***/ "./node_modules/bc-modal/node_modules/jquery-trend/jquery.trend.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bc-modal/node_modules/jquery-trend/jquery.trend.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Trend 0.1.0
 *
 * Fail-safe TransitionEnd event for jQuery.
 *
 * Adds a new "trend" event that can be used in browsers that don't
 * support "transitionend".
 *
 * NOTE: Only supports being bound with "jQuery.one".
 *
 * Copyright 2014, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
;(function($){

  // Prefixed transitionend event names
  var transitionEndEvents =
    "webkitTransitionEnd " +
    "otransitionend " +
    "oTransitionEnd " +
    "msTransitionEnd " +
    "transitionend";

  // Prefixed transition duration property names
  var transitionDurationProperties = [
    "transition-duration",
    "-moz-transition-duration",
    "-webkit-transition-duration",
    "-ms-transition-duration",
    "-o-transition-duration",
    "-khtml-transition-duration"
  ];

  // Parses a CSS duration value into milliseconds.
  var parseDuration = function(s) {
    s = s.replace(/\s/, "");
    var v = window.parseFloat(s);

    return s.match(/[^m]s$/i)
      ? v * 1000
      : v;
  };

  // Get the transition duration for an element, as specified by CSS.
  // Returns a value in milliseconds.
  var getTransitionDuration = function(el) {
    var duration = 0;

    for (var i = 0; i < transitionDurationProperties.length; i++) {
      // Get raw CSS value
      var value = el.css(transitionDurationProperties[i]);
      if (!value) continue;

      // Multiple transitions--pick the longest
      if (value.indexOf(",") !== -1) {
        var values = value.split(",");
        var durations = (function(){
          var results = [];
          for (var i = 0; i < values.length; i++) {
            var duration = parseDuration(values[i]);
            results.push(duration);
          }
          return results;
        })();

        duration = Math.max.apply(Math, durations);
      }

      // Single transition
      else {
        duration = parseDuration(value);
      }

      // Accept first vaue
      break;
    }

    return duration;
  };

  $.event.special.trend = {
    // Triggers an event handler when an element is done transitioning.
    //
    // Handles browsers that don't support transitionend by adding a
    // timeout with the transition duration.
    add: function(handleObj) {
      var el = $(this);
      var fired = false;

      // Mark element as being in transition
      el.data("trend", true);

      // Calculate a fallback duration. + 20 because some browsers fire
      // timeouts faster than transitionend.
      var duration = getTransitionDuration(el) + 20;

      var cb = function(e) {
        // transitionend events can be sent for each property. Let's just
        // skip all but the first. Also handles the timeout callback.
        if (fired) return;

        // Child elements that also have transitions can be fired before we
        // complete. This will catch and ignore those. Unfortunately, we'll
        // have to rely on the timeout in these cases.
        if (e && e.srcElement !== el[0]) return;

        // Mark element has not being in transition
        el.data("trend", false);

        // Callback
        fired = true;
        if (handleObj.handler) handleObj.handler();
      };

      el.one(transitionEndEvents, cb);
      el.data("trend-timeout", window.setTimeout(cb, duration));
    },

    remove: function(handleObj) {
      var el = $(this);
      el.off(transitionEndEvents);
      window.clearTimeout(el.data("trend-timeout"));
    }
  };

})(jQuery);


/***/ }),

/***/ "./node_modules/bc-scroll-link/dist/scroll-link.js":
/*!*********************************************************!*\
  !*** ./node_modules/bc-scroll-link/dist/scroll-link.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ScrollLink = function () {
  function ScrollLink(options) {
    _classCallCheck(this, ScrollLink);

    this.options = _jquery2.default.extend({
      selector: '[data-scroll]',
      duration: 1000,
      easing: 'swing',
      delay: 0,
      offset: 0,
      updateHash: true
    }, options);

    this._bindEvents();
  }

  _createClass(ScrollLink, [{
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this = this;

      (0, _jquery2.default)(this.options.selector).on('click', function (e) {
        e.preventDefault();
        setTimeout(function () {
          _this._scrollToContent((0, _jquery2.default)(e.currentTarget));
        }, _this.options.delay);
      });
    }
  }, {
    key: '_scrollToContent',
    value: function _scrollToContent(target) {
      var duration = this.options.duration;
      var easing = this.options.easing;
      var scrollTarget = (0, _jquery2.default)(target).data('scroll') || target;

      if (scrollTarget === '#') {
        scrollTarget = 'body';
      }

      (0, _jquery2.default)('html, body').animate({
        scrollTop: (0, _jquery2.default)(scrollTarget).offset().top + this.options.offset
      }, duration, easing);

      if (this.options.updateHash) {
        if (history.replaceState) {
          history.replaceState({}, scrollTarget, scrollTarget);
        } else {
          window.location.hash = scrollTarget;
        }
      }
    }
  }, {
    key: 'scrollToContent',
    value: function scrollToContent(target) {
      var _this2 = this;

      setTimeout(function () {
        _this2._scrollToContent(target);
      }, this.options.delay);
    }
  }]);

  return ScrollLink;
}();

exports["default"] = ScrollLink;

/***/ }),

/***/ "./node_modules/bc-tabs/dist/tabs.js":
/*!*******************************************!*\
  !*** ./node_modules/bc-tabs/dist/tabs.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

var _justDebounce = __webpack_require__(/*! just-debounce */ "./node_modules/just-debounce/index.js");

var _justDebounce2 = _interopRequireDefault(_justDebounce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tabs = function () {
  function Tabs(options) {
    _classCallCheck(this, Tabs);

    this.options = _jquery2.default.extend({

      // Scoping the tabs (event binding), link class, and content
      tabScope: '[data-tabs]',
      tabToggle: '[data-tab-link]',
      tabContent: '[data-tab-content]',
      toggleTab: this._defaultToggleTab,
      keepTabsOpen: this.keepTabsOpen,
      activeClass: 'active',
      defaultTab: '',
      afterSetup: function afterSetup() {},
      afterChange: function afterChange($element) {},
      tabHistory: false
    }, options);

    this.$scope = (0, _jquery2.default)(this.options.tabScope);
    this.$tabToggles = (0, _jquery2.default)(this.options.tabToggle);
    this.$tabContents = (0, _jquery2.default)(this.options.tabContent);

    this.defaultTab = this.options.defaultTab || this.$tabContents.get(0);

    this.currentTab = this._defaultTab();
    this.previousStyle = this._getTabStyle();

    this._bindEvents();
    this._init();
    this.options.afterSetup();
  }

  /* ----------------------------------------------------------------------- /
   Default functions: can be overridden by passing callbacks into constructor
   */

  // Find out the default tab (if none selected in options)


  _createClass(Tabs, [{
    key: '_defaultTab',
    value: function _defaultTab() {
      return this.$tabContents.first().attr('id');
    }

    // Default function to toggle a tab between active / inactive

  }, {
    key: '_defaultToggleTab',
    value: function _defaultToggleTab(element, active) {
      var $element = (0, _jquery2.default)(element);

      $element.toggleClass(this.activeClass, active);
    }
  }, {
    key: '_getTabStyle',
    value: function _getTabStyle() {
      var pseudoElem = window.getComputedStyle(this.$scope.get(0), ':before').content.replace(/"/g, '');
      return pseudoElem;
    }

    // Default function to toggle some content on or off

  }, {
    key: '_defaultToggleContent',
    value: function _defaultToggleContent(element, active) {
      var _this = this;

      var $element = (0, _jquery2.default)(element);

      if (active) {
        // Set the tab to active
        if (this.previousStyle === 'slide') {
          // show with a slidetoggle
          $element.slideDown('fast', function () {
            _this.options.afterChange($element);
          });
        } else {
          // Show simply via display
          $element.show();
          this.options.afterChange($element);
        }
      } else {
        // Set the tab to inactive
        if (this.previousStyle === 'slide') {
          // Remove via a slideToggle
          $element.slideUp('fast', function () {
            _this.options.afterChange($element);
          });
        } else {
          // Remove via a simple hide
          $element.hide();
          this.options.afterChange($element);
        }
      }
    }

    // Determine if we should target all tabs or individual tabs
    // (Swap between tab and accordion functionality.)

  }, {
    key: 'keepTabsOpen',
    value: function keepTabsOpen() {
      return window.innerWidth < 800;
    }

    /* ----------------------------------------------------------------------- /
     Activation functions: Trigger the callbacks for showing / hiding tab
     components and links
     */

    // Set a particular tab as active (and optionally disable others)
    // This function is a wrapper for activating both the tab-link and
    // tab-content at the same time.

  }, {
    key: 'activateTab',
    value: function activateTab(hash, closeOthers) {

      // necessary to check for links that link to tabs that aren't available:
      if (!(0, _jquery2.default)(hash).length) {
        console.log('tab doesn\'t exist!');
        return;
      }

      var isSticky = closeOthers || this.options.keepTabsOpen();
      this.activateTabToggle(hash, isSticky);
      this.activateTabContent(hash, isSticky);
    }

    // Remove bc-tabs if content with tabs is updated, refreshed or replaced

  }, {
    key: 'unload',
    value: function unload() {
      this.$scope.off('.bc-tabs');
      (0, _jquery2.default)(window).off('.bc-tabs');
    }

    // Set a particular [data-tab-toggle] link as active,
    // and (optionally) deactivate others

  }, {
    key: 'activateTabToggle',
    value: function activateTabToggle(hash) {
      var isSticky = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


      var $thisTab = (0, _jquery2.default)(hash);

      // Find tablinks that point to this hash
      var $tabLinks = this.$tabToggles.filter(function () {
        return (0, _jquery2.default)(this).attr('href') === hash;
      });

      if (!isSticky) {
        // Tab stickyness not active, target all other tabs in group

        if ($thisTab.is(':visible')) return;
        // Grab all the groups these links belong to
        var tabsGroups = [];
        $tabLinks.each(function () {
          var thisTabGroup = (0, _jquery2.default)(this).data('tabs-group');
          if (tabsGroups.indexOf(thisTabGroup) === -1) {
            tabsGroups.push(thisTabGroup);
          }
        });

        // Filter all the tabs to only those belonging to these groups
        var $tabsGroup = this.$tabToggles.filter(function () {
          return tabsGroups.indexOf((0, _jquery2.default)(this).data('tabs-group')) > -1;
        });

        // Disable all the tab links
        for (var i = 0; i < $tabsGroup.length; i++) {
          this.options.toggleTab($tabsGroup[i], false);
        }

        // Enable just the tab links associated with this hash
        for (var _i = 0; _i < $tabLinks.length; _i++) {
          this.options.toggleTab($tabLinks[_i], true);
        }
      } else {
        // Tabs are sticky, so we should only toggle items matching this hash
        if ($thisTab.is(':visible')) {
          // Enable just the tab links associated with this hash
          for (var _i2 = 0; _i2 < $tabLinks.length; _i2++) {
            this.options.toggleTab($tabLinks[_i2], false);
          }
        } else {
          for (var _i3 = 0; _i3 < $tabLinks.length; _i3++) {
            this.options.toggleTab($tabLinks[_i3], true);
          }
        }
      }
    }

    // Activate a content-element with the corresponding hash, and
    // (optionally) hide others in group

  }, {
    key: 'activateTabContent',
    value: function activateTabContent(hash) {
      var isSticky = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var $thisTab = (0, _jquery2.default)(hash);

      if (!isSticky) {

        if ($thisTab.is(':visible')) return;

        // Locate other tabs that share the same 'tabs-group'
        var tabsGroup = $thisTab.data('tabs-group');
        var $tabsGroup = this.$tabContents.filter(function () {
          return (0, _jquery2.default)(this).data('tabs-group') === tabsGroup;
        });

        // Disable other tabs in this group
        for (var i = 0; i < $tabsGroup.length; i++) {
          this._defaultToggleContent($tabsGroup[i], false);
        }
        // Enable this tab content
        this._defaultToggleContent($thisTab, true);
      } else {
        // Tabs are sticky, so we only toggle the individual item
        if ($thisTab.is(':visible')) {
          this._defaultToggleContent($thisTab, false);
        } else {
          this._defaultToggleContent($thisTab, true);
        }
      }
    }

    /* ----------------------------------------------------------------------- /
     Miscellaneous: deal with initing the base tab state (say after resizing
     the viewport or on page load) and event binding.
     */

    // Function to run when tabs are first init (sets one active over others)

  }, {
    key: '_init',
    value: function _init(checkStyleMatch) {
      if (checkStyleMatch) {
        var currentStyle = this._getTabStyle();

        if (this.previousStyle == currentStyle) {
          return;
        }

        this.previousStyle = currentStyle;
      }

      var hash = window.location.hash || '#' + this.defaultTab.id;
      var currentTab = hash ? 'a[href="' + hash + '"]' : '[data-tab-link]:first';

      // Disable all the tabs
      for (var i = 0; i < this.$tabToggles.length; i++) {
        this.options.toggleTab(this.$tabToggles.get(i), false);
      }

      for (var _i4 = 0; _i4 < this.$tabContents.length; _i4++) {
        this._defaultToggleContent(this.$tabContents.get(_i4), false);
      }

      this._defaultToggleContent(hash, true);
      this.options.toggleTab(currentTab, true);
    }

    // Bind event handlers to the scope target.

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$scope.on('click.bc-tabs', this.options.tabToggle, function (event) {
        event.preventDefault();
        var hash = (0, _jquery2.default)(event.target).attr('href');

        _this2.activateTab(hash);

        if (_this2.options.tabHistory) {
          history.pushState({}, hash, hash);
        } else {
          history.replaceState({}, hash, hash);
        }
      });

      (0, _jquery2.default)(window).on('hashchange.bc-tabs', function () {
        _this2.activateTab(window.location.hash);
      });

      (0, _jquery2.default)(window).on('resize.bc-tabs', (0, _justDebounce2.default)(function () {
        _this2._init(true);
      }, 300));
    }
  }]);

  return Tabs;
}();

exports["default"] = Tabs;


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/set-function-length/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");
var $max = GetIntrinsic('%Math.max%');

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/creditcards-types/index.js":
/*!*************************************************!*\
  !*** ./node_modules/creditcards-types/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./types */ "./node_modules/creditcards-types/types/index.js")


/***/ }),

/***/ "./node_modules/creditcards-types/type.js":
/*!************************************************!*\
  !*** ./node_modules/creditcards-types/type.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = CardType

function CardType (data) {
  if (!(this instanceof CardType)) return new CardType(data)
  Object.assign(this, data)
}

CardType.prototype.digits = 16
CardType.prototype.cvcLength = 3
CardType.prototype.luhn = true
CardType.prototype.groupPattern = /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?/

CardType.prototype.group = function (number) {
  return (number.match(this.groupPattern) || [])
    .slice(1)
    .filter(Boolean)
}

CardType.prototype.test = function (number, eager) {
  return this[eager ? 'eagerPattern' : 'pattern'].test(number)
}


/***/ }),

/***/ "./node_modules/creditcards-types/types/american-express.js":
/*!******************************************************************!*\
  !*** ./node_modules/creditcards-types/types/american-express.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'American Express',
  digits: 15,
  pattern: /^3[47]\d{13}$/,
  eagerPattern: /^3[47]/,
  groupPattern: /(\d{1,4})(\d{1,6})?(\d{1,5})?/,
  cvcLength: 4
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/dankort.js":
/*!*********************************************************!*\
  !*** ./node_modules/creditcards-types/types/dankort.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Dankort',
  pattern: /^5019\d{12}$/,
  eagerPattern: /^5019/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/diners-club.js":
/*!*************************************************************!*\
  !*** ./node_modules/creditcards-types/types/diners-club.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Diners Club',
  digits: [14, 19],
  pattern: /^3(0[0-5]|[68]\d)\d{11,16}$/,
  eagerPattern: /^3(0|[68])/,
  groupPattern: /(\d{1,4})?(\d{1,6})?(\d{1,9})?/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/discover.js":
/*!**********************************************************!*\
  !*** ./node_modules/creditcards-types/types/discover.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Discover',
  pattern: /^6(011(0[0-9]|[2-4]\d|74|7[7-9]|8[6-9]|9[0-9])|4[4-9]\d{3}|5\d{4})\d{10}$/,
  eagerPattern: /^6(011(0[0-9]|[2-4]|74|7[7-9]|8[6-9]|9[0-9])|4[4-9]|5)/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/elo.js":
/*!*****************************************************!*\
  !*** ./node_modules/creditcards-types/types/elo.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Elo',
  pattern: /^(4[035]|5[0]|6[235])(6[7263]|9[90]|1[2416]|7[736]|8[9]|0[04579]|5[0])([0-9])([0-9])\d{10}$/,
  eagerPattern: /^(4[035]|5[0]|6[235])(6[7263]|9[90]|1[2416]|7[736]|8[9]|0[04579]|5[0])([0-9])([0-9])/,
  groupPattern: /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?(\d{1,3})?/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/forbrugsforeningen.js":
/*!********************************************************************!*\
  !*** ./node_modules/creditcards-types/types/forbrugsforeningen.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Forbrugsforeningen',
  pattern: /^600722\d{10}$/,
  eagerPattern: /^600/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/creditcards-types/types/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = [
  __webpack_require__(/*! ./visa */ "./node_modules/creditcards-types/types/visa.js"),
  __webpack_require__(/*! ./maestro */ "./node_modules/creditcards-types/types/maestro.js"),
  __webpack_require__(/*! ./forbrugsforeningen */ "./node_modules/creditcards-types/types/forbrugsforeningen.js"),
  __webpack_require__(/*! ./dankort */ "./node_modules/creditcards-types/types/dankort.js"),
  __webpack_require__(/*! ./mastercard */ "./node_modules/creditcards-types/types/mastercard.js"),
  __webpack_require__(/*! ./american-express */ "./node_modules/creditcards-types/types/american-express.js"),
  __webpack_require__(/*! ./diners-club */ "./node_modules/creditcards-types/types/diners-club.js"),
  __webpack_require__(/*! ./discover */ "./node_modules/creditcards-types/types/discover.js"),
  __webpack_require__(/*! ./jcb */ "./node_modules/creditcards-types/types/jcb.js"),
  __webpack_require__(/*! ./unionpay */ "./node_modules/creditcards-types/types/unionpay.js"),
  __webpack_require__(/*! ./troy */ "./node_modules/creditcards-types/types/troy.js"),
  __webpack_require__(/*! ./elo */ "./node_modules/creditcards-types/types/elo.js"),
  __webpack_require__(/*! ./uatp */ "./node_modules/creditcards-types/types/uatp.js")
]


/***/ }),

/***/ "./node_modules/creditcards-types/types/jcb.js":
/*!*****************************************************!*\
  !*** ./node_modules/creditcards-types/types/jcb.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'JCB',
  pattern: /^35\d{14}$/,
  eagerPattern: /^35/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/maestro.js":
/*!*********************************************************!*\
  !*** ./node_modules/creditcards-types/types/maestro.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Maestro',
  digits: [12, 19],
  pattern: /^(?:5[06789]\d\d|(?!6011[0234])(?!60117[4789])(?!60118[6789])(?!60119)(?!64[456789])(?!65)6\d{3})\d{8,15}$/,
  eagerPattern: /^(5(018|0[23]|[68])|6[37]|60111|60115|60117([56]|7[56])|60118[0-5]|64[0-3]|66)/,
  groupPattern: /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?(\d{1,3})?/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/mastercard.js":
/*!************************************************************!*\
  !*** ./node_modules/creditcards-types/types/mastercard.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Mastercard',
  pattern: /^(5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)\d{12}$/,
  eagerPattern: /^(2[3-7]|22[2-9]|5[1-5])/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/troy.js":
/*!******************************************************!*\
  !*** ./node_modules/creditcards-types/types/troy.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Troy',
  pattern: /^9792\d{12}$/,
  eagerPattern: /^9792/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/uatp.js":
/*!******************************************************!*\
  !*** ./node_modules/creditcards-types/types/uatp.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'UATP',
  digits: 15,
  pattern: /^1\d{14}$/,
  eagerPattern: /^1/,
  groupPattern: /(\d{1,4})(\d{1,5})?(\d{1,6})?/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/unionpay.js":
/*!**********************************************************!*\
  !*** ./node_modules/creditcards-types/types/unionpay.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'UnionPay',
  pattern: /^62[0-5]\d{13,16}$/,
  eagerPattern: /^62/,
  groupPattern: /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?(\d{1,3})?/,
  luhn: false
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/visa.js":
/*!******************************************************!*\
  !*** ./node_modules/creditcards-types/types/visa.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Visa',
  digits: [13, 19],
  pattern: /^4\d{12}(\d{3}|\d{6})?$/,
  eagerPattern: /^4/,
  groupPattern: /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?(\d{1,3})?/
})


/***/ }),

/***/ "./node_modules/creditcards/card.js":
/*!******************************************!*\
  !*** ./node_modules/creditcards/card.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const luhn = __webpack_require__(/*! fast-luhn */ "./node_modules/fast-luhn/index.js")
const Types = __webpack_require__(/*! ./types */ "./node_modules/creditcards/types.js")

module.exports = Card

function Card (data) {
  const types = Types(data)

  return {
    types: data,
    parse: parseCard,
    format: formatCard,
    type: cardType,
    luhn: luhn,
    isValid: isCardValid
  }

  function parseCard (number) {
    if (typeof number !== 'string') return ''
    return number.replace(/[^\d]/g, '')
  }

  function formatCard (number, separator) {
    const type = getType(number, true)
    if (!type) return number
    return type.group(number).join(separator || ' ')
  }

  function cardType (number, eager) {
    const type = getType(number, eager)
    return type ? type.name : undefined
  }

  function isCardValid (number, type) {
    if (type) {
      type = types.get(type)
    } else {
      type = getType(number)
    }
    if (!type) return false
    return (!type.luhn || luhn(number)) && type.test(number)
  }

  function getType (number, eager) {
    return types.find(function (type) {
      return type.test(number, eager)
    })
  }
}


/***/ }),

/***/ "./node_modules/creditcards/cvc.js":
/*!*****************************************!*\
  !*** ./node_modules/creditcards/cvc.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Types = __webpack_require__(/*! ./types */ "./node_modules/creditcards/types.js")
const cvcRegex = /^\d{3,4}$/

module.exports = Cvc

function Cvc (data) {
  const types = Types(data)

  return {
    isValid: cvcIsValid
  }

  function cvcIsValid (cvc, type) {
    if (typeof cvc !== 'string') return false
    if (!cvcRegex.test(cvc)) return false

    if (!type) {
      return types.some(function (type) {
        return type.cvcLength === cvc.length
      })
    }

    return types.get(type).cvcLength === cvc.length
  }
}


/***/ }),

/***/ "./node_modules/creditcards/expiration.js":
/*!************************************************!*\
  !*** ./node_modules/creditcards/expiration.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const isValidMonth = __webpack_require__(/*! is-valid-month */ "./node_modules/is-valid-month/index.js")
const parseIntStrict = __webpack_require__(/*! parse-int */ "./node_modules/parse-int/index.js")
const parseYear = __webpack_require__(/*! parse-year */ "./node_modules/parse-year/index.js")

module.exports = {
  isPast: isPast,
  month: {
    parse: parseMonth,
    isValid: isValidMonth
  },
  year: {
    parse: parseYear,
    format: formatExpYear,
    isValid: isExpYearValid,
    isPast: isExpYearPast
  }
}

function isPast (month, year) {
  return Date.now() >= new Date(year, month)
}

function parseMonth (month) {
  return parseIntStrict(month)
}

function formatExpYear (year, strip) {
  year = year.toString()
  return strip ? year.substr(2, 4) : year
}

function isExpYearValid (year) {
  if (typeof year !== 'number') return false
  year = parseIntStrict(year)
  return year > 0
}

function isExpYearPast (year) {
  return new Date().getFullYear() > year
}


/***/ }),

/***/ "./node_modules/creditcards/index.js":
/*!*******************************************!*\
  !*** ./node_modules/creditcards/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const types = __webpack_require__(/*! creditcards-types */ "./node_modules/creditcards-types/index.js")
const Card = __webpack_require__(/*! ./card */ "./node_modules/creditcards/card.js")
const Cvc = __webpack_require__(/*! ./cvc */ "./node_modules/creditcards/cvc.js")
const expiration = __webpack_require__(/*! ./expiration */ "./node_modules/creditcards/expiration.js")

module.exports = withTypes(types)
module.exports.withTypes = withTypes

function withTypes (types) {
  return {
    card: Card(types),
    cvc: Cvc(types),
    expiration: expiration
  }
}


/***/ }),

/***/ "./node_modules/creditcards/types.js":
/*!*******************************************!*\
  !*** ./node_modules/creditcards/types.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const defaults = __webpack_require__(/*! creditcards-types */ "./node_modules/creditcards-types/index.js")

module.exports = CardTypes
module.exports.defaults = defaults

function CardTypes (types) {
  const map = types.reduce(function (acc, type) {
    acc[type.name] = type
    return acc
  }, {})

  return {
    find: types.find.bind(types),
    some: types.some.bind(types),
    get: get
  }

  function get (name) {
    const type = map[name]

    if (!type) {
      throw new Error('No type found for name: ' + name)
    }

    return type
  }
}


/***/ }),

/***/ "./node_modules/define-data-property/index.js":
/*!****************************************************!*\
  !*** ./node_modules/define-data-property/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");

var gopd = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ "./node_modules/es-define-property/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-define-property/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ "./node_modules/es-errors/eval.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/eval.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ "./node_modules/es-errors/index.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ "./node_modules/es-errors/range.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/range.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ "./node_modules/es-errors/ref.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/ref.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ "./node_modules/es-errors/syntax.js":
/*!******************************************!*\
  !*** ./node_modules/es-errors/syntax.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ "./node_modules/es-errors/type.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/type.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ "./node_modules/es-errors/uri.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/uri.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ "./node_modules/ev-emitter/ev-emitter.js":
/*!***********************************************!*\
  !*** ./node_modules/ev-emitter/ev-emitter.js ***!
  \***********************************************/
/***/ (function(module) {

/**
 * EvEmitter v2.1.1
 * Lil' event emitter
 * MIT License
 */

( function( global, factory ) {
  // universal module definition
  if (  true && module.exports ) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }

}( typeof window != 'undefined' ? window : this, function() {

function EvEmitter() {}

let proto = EvEmitter.prototype;

proto.on = function( eventName, listener ) {
  if ( !eventName || !listener ) return this;

  // set events hash
  let events = this._events = this._events || {};
  // set listeners array
  let listeners = events[ eventName ] = events[ eventName ] || [];
  // only add once
  if ( !listeners.includes( listener ) ) {
    listeners.push( listener );
  }

  return this;
};

proto.once = function( eventName, listener ) {
  if ( !eventName || !listener ) return this;

  // add event
  this.on( eventName, listener );
  // set once flag
  // set onceEvents hash
  let onceEvents = this._onceEvents = this._onceEvents || {};
  // set onceListeners object
  let onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
  // set flag
  onceListeners[ listener ] = true;

  return this;
};

proto.off = function( eventName, listener ) {
  let listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) return this;

  let index = listeners.indexOf( listener );
  if ( index != -1 ) {
    listeners.splice( index, 1 );
  }

  return this;
};

proto.emitEvent = function( eventName, args ) {
  let listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) return this;

  // copy over to avoid interference if .off() in listener
  listeners = listeners.slice( 0 );
  args = args || [];
  // once stuff
  let onceListeners = this._onceEvents && this._onceEvents[ eventName ];

  for ( let listener of listeners ) {
    let isOnce = onceListeners && onceListeners[ listener ];
    if ( isOnce ) {
      // remove listener
      // remove before trigger to prevent recursion
      this.off( eventName, listener );
      // unset once flag
      delete onceListeners[ listener ];
    }
    // trigger listener
    listener.apply( this, args );
  }

  return this;
};

proto.allOff = function() {
  delete this._events;
  delete this._onceEvents;
  return this;
};

return EvEmitter;

} ) );


/***/ }),

/***/ "./node_modules/eventemitter2/lib/eventemitter2.js":
/*!*********************************************************!*\
  !*** ./node_modules/eventemitter2/lib/eventemitter2.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
;!function(undefined) {
  var hasOwnProperty= Object.hasOwnProperty;
  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;
  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';
  var symbolsSupported= typeof Symbol==='function';
  var reflectSupported= typeof Reflect === 'object';
  var setImmediateSupported= typeof setImmediate === 'function';
  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;
  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){
    var arr= Object.getOwnPropertyNames(obj);
    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
    return arr;
  }) : Object.keys;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {
      this._conf = conf;

      conf.delimiter && (this.delimiter = conf.delimiter);

      if(conf.maxListeners!==undefined){
          this._maxListeners= conf.maxListeners;
      }

      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this._newListener = conf.newListener);
      conf.removeListener && (this._removeListener = conf.removeListener);
      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    }
  }

  function logPossibleMemoryLeak(count, eventName) {
    var errorMsg = '(node) warning: possible EventEmitter memory ' +
        'leak detected. ' + count + ' listeners added. ' +
        'Use emitter.setMaxListeners() to increase limit.';

    if(this.verboseMemoryLeak){
      errorMsg += ' Event name: ' + eventName + '.';
    }

    if(typeof process !== 'undefined' && process.emitWarning){
      var e = new Error(errorMsg);
      e.name = 'MaxListenersExceededWarning';
      e.emitter = this;
      e.count = count;
      process.emitWarning(e);
    } else {
      console.error(errorMsg);

      if (console.trace){
        console.trace();
      }
    }
  }

  var toArray = function (a, b, c) {
    var n = arguments.length;
    switch (n) {
      case 0:
        return [];
      case 1:
        return [a];
      case 2:
        return [a, b];
      case 3:
        return [a, b, c];
      default:
        var arr = new Array(n);
        while (n--) {
          arr[n] = arguments[n];
        }
        return arr;
    }
  };

  function toObject(keys, values) {
    var obj = {};
    var key;
    var len = keys.length;
    var valuesCount = values ? values.length : 0;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = i < valuesCount ? values[i] : undefined;
    }
    return obj;
  }

  function TargetObserver(emitter, target, options) {
    this._emitter = emitter;
    this._target = target;
    this._listeners = {};
    this._listenersCount = 0;

    var on, off;

    if (options.on || options.off) {
      on = options.on;
      off = options.off;
    }

    if (target.addEventListener) {
      on = target.addEventListener;
      off = target.removeEventListener;
    } else if (target.addListener) {
      on = target.addListener;
      off = target.removeListener;
    } else if (target.on) {
      on = target.on;
      off = target.off;
    }

    if (!on && !off) {
      throw Error('target does not implement any known event API');
    }

    if (typeof on !== 'function') {
      throw TypeError('on method must be a function');
    }

    if (typeof off !== 'function') {
      throw TypeError('off method must be a function');
    }

    this._on = on;
    this._off = off;

    var _observers= emitter._observers;
    if(_observers){
      _observers.push(this);
    }else{
      emitter._observers= [this];
    }
  }

  Object.assign(TargetObserver.prototype, {
    subscribe: function(event, localEvent, reducer){
      var observer= this;
      var target= this._target;
      var emitter= this._emitter;
      var listeners= this._listeners;
      var handler= function(){
        var args= toArray.apply(null, arguments);
        var eventObj= {
          data: args,
          name: localEvent,
          original: event
        };
        if(reducer){
          var result= reducer.call(target, eventObj);
          if(result!==false){
            emitter.emit.apply(emitter, [eventObj.name].concat(args))
          }
          return;
        }
        emitter.emit.apply(emitter, [localEvent].concat(args));
      };


      if(listeners[event]){
        throw Error('Event \'' + event + '\' is already listening');
      }

      this._listenersCount++;

      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){

        this._onNewListener = function (_event) {
          if (_event === localEvent && listeners[event] === null) {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        };

        emitter.on('newListener', this._onNewListener);

        this._onRemoveListener= function(_event){
          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){
            listeners[event]= null;
            observer._off.call(target, event, handler);
          }
        };

        listeners[event]= null;

        emitter.on('removeListener', this._onRemoveListener);
      }else{
        listeners[event]= handler;
        observer._on.call(target, event, handler);
      }
    },

    unsubscribe: function(event){
      var observer= this;
      var listeners= this._listeners;
      var emitter= this._emitter;
      var handler;
      var events;
      var off= this._off;
      var target= this._target;
      var i;

      if(event && typeof event!=='string'){
        throw TypeError('event must be a string');
      }

      function clearRefs(){
        if(observer._onNewListener){
          emitter.off('newListener', observer._onNewListener);
          emitter.off('removeListener', observer._onRemoveListener);
          observer._onNewListener= null;
          observer._onRemoveListener= null;
        }
        var index= findTargetIndex.call(emitter, observer);
        emitter._observers.splice(index, 1);
      }

      if(event){
        handler= listeners[event];
        if(!handler) return;
        off.call(target, event, handler);
        delete listeners[event];
        if(!--this._listenersCount){
          clearRefs();
        }
      }else{
        events= ownKeys(listeners);
        i= events.length;
        while(i-->0){
          event= events[i];
          off.call(target, event, listeners[event]);
        }
        this._listeners= {};
        this._listenersCount= 0;
        clearRefs();
      }
    }
  });

  function resolveOptions(options, schema, reducers, allowUnknown) {
    var computedOptions = Object.assign({}, schema);

    if (!options) return computedOptions;

    if (typeof options !== 'object') {
      throw TypeError('options must be an object')
    }

    var keys = Object.keys(options);
    var length = keys.length;
    var option, value;
    var reducer;

    function reject(reason) {
      throw Error('Invalid "' + option + '" option value' + (reason ? '. Reason: ' + reason : ''))
    }

    for (var i = 0; i < length; i++) {
      option = keys[i];
      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
        throw Error('Unknown "' + option + '" option');
      }
      value = options[option];
      if (value !== undefined) {
        reducer = reducers[option];
        computedOptions[option] = reducer ? reducer(value, reject) : value;
      }
    }
    return computedOptions;
  }

  function constructorReducer(value, reject) {
    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {
      reject('value must be a constructor');
    }
    return value;
  }

  function makeTypeReducer(types) {
    var message= 'value must be type of ' + types.join('|');
    var len= types.length;
    var firstType= types[0];
    var secondType= types[1];

    if (len === 1) {
      return function (v, reject) {
        if (typeof v === firstType) {
          return v;
        }
        reject(message);
      }
    }

    if (len === 2) {
      return function (v, reject) {
        var kind= typeof v;
        if (kind === firstType || kind === secondType) return v;
        reject(message);
      }
    }

    return function (v, reject) {
      var kind = typeof v;
      var i = len;
      while (i-- > 0) {
        if (kind === types[i]) return v;
      }
      reject(message);
    }
  }

  var functionReducer= makeTypeReducer(['function']);

  var objectFunctionReducer= makeTypeReducer(['object', 'function']);

  function makeCancelablePromise(Promise, executor, options) {
    var isCancelable;
    var callbacks;
    var timer= 0;
    var subscriptionClosed;

    var promise = new Promise(function (resolve, reject, onCancel) {
      options= resolveOptions(options, {
        timeout: 0,
        overload: false
      }, {
        timeout: function(value, reject){
          value*= 1;
          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {
            reject('timeout must be a positive number');
          }
          return value;
        }
      });

      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';

      function cleanup() {
        if (callbacks) {
          callbacks = null;
        }
        if (timer) {
          clearTimeout(timer);
          timer = 0;
        }
      }

      var _resolve= function(value){
        cleanup();
        resolve(value);
      };

      var _reject= function(err){
        cleanup();
        reject(err);
      };

      if (isCancelable) {
        executor(_resolve, _reject, onCancel);
      } else {
        callbacks = [function(reason){
          _reject(reason || Error('canceled'));
        }];
        executor(_resolve, _reject, function (cb) {
          if (subscriptionClosed) {
            throw Error('Unable to subscribe on cancel event asynchronously')
          }
          if (typeof cb !== 'function') {
            throw TypeError('onCancel callback must be a function');
          }
          callbacks.push(cb);
        });
        subscriptionClosed= true;
      }

      if (options.timeout > 0) {
        timer= setTimeout(function(){
          var reason= Error('timeout');
          reason.code = 'ETIMEDOUT'
          timer= 0;
          promise.cancel(reason);
          reject(reason);
        }, options.timeout);
      }
    });

    if (!isCancelable) {
      promise.cancel = function (reason) {
        if (!callbacks) {
          return;
        }
        var length = callbacks.length;
        for (var i = 1; i < length; i++) {
          callbacks[i](reason);
        }
        // internal callback to reject the promise
        callbacks[0](reason);
        callbacks = null;
      };
    }

    return promise;
  }

  function findTargetIndex(observer) {
    var observers = this._observers;
    if(!observers){
      return -1;
    }
    var len = observers.length;
    for (var i = 0; i < len; i++) {
      if (observers[i]._target === observer) return i;
    }
    return -1;
  }

  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i, typeLength) {
    if (!tree) {
      return null;
    }

    if (i === 0) {
      var kind = typeof type;
      if (kind === 'string') {
        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
        if ((n = type.indexOf(delimiter)) !== -1) {
          ns = new Array(5);
          do {
            ns[l++] = type.slice(j, n);
            j = n + dl;
          } while ((n = type.indexOf(delimiter, j)) !== -1);

          ns[l++] = type.slice(j);
          type = ns;
          typeLength = l;
        } else {
          type = [type];
          typeLength = 1;
        }
      } else if (kind === 'object') {
        typeLength = type.length;
      } else {
        type = [type];
        typeLength = 1;
      }
    }

    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],
        nextType = type[i + 1], branches, _listeners;

    if (i === typeLength) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //

      if(tree._listeners) {
        if (typeof tree._listeners === 'function') {
          handlers && handlers.push(tree._listeners);
          listeners = [tree];
        } else {
          handlers && handlers.push.apply(handlers, tree._listeners);
          listeners = [tree];
        }
      }
    } else {

      if (currentType === '*') {
        //
        // If the event emitted is '*' at this part
        // or there is a concrete match at this patch
        //
        branches = ownKeys(tree);
        n = branches.length;
        while (n-- > 0) {
          branch = branches[n];
          if (branch !== '_listeners') {
            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
            if (_listeners) {
              if (listeners) {
                listeners.push.apply(listeners, _listeners);
              } else {
                listeners = _listeners;
              }
            }
          }
        }
        return listeners;
      } else if (currentType === '**') {
        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));
        if (endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
        }

        branches = ownKeys(tree);
        n = branches.length;
        while (n-- > 0) {
          branch = branches[n];
          if (branch !== '_listeners') {
            if (branch === '*' || branch === '**') {
              if (tree[branch]._listeners && !endReached) {
                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
            } else if (branch === nextType) {
              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
            } else {
              // No match on this one, shift into the tree but not in the type array.
              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
            }
            if (_listeners) {
              if (listeners) {
                listeners.push.apply(listeners, _listeners);
              } else {
                listeners = _listeners;
              }
            }
          }
        }
        return listeners;
      } else if (tree[currentType]) {
        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
      }
    }

      xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i + 1, typeLength);
    }

    xxTree = tree['**'];
    if (xxTree) {
      if (i < typeLength) {
        if (xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
        }

        // Build arrays of matching next branches and others.
        branches= ownKeys(xxTree);
        n= branches.length;
        while(n-->0){
          branch= branches[n];
          if (branch !== '_listeners') {
            if (branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
            } else if (branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);
            }
          }
        }
      } else if (xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
      } else if (xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener, prepend) {
    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;

    if(typeof type==='string') {
      if ((i = type.indexOf(delimiter)) !== -1) {
        ns = new Array(5);
        do {
          ns[len++] = type.slice(j, i);
          j = i + dl;
        } while ((i = type.indexOf(delimiter, j)) !== -1);

        ns[len++] = type.slice(j);
      }else{
        ns= [type];
        len= 1;
      }
    }else{
      ns= type;
      len= type.length;
    }

    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    if (len > 1) {
      for (i = 0; i + 1 < len; i++) {
        if (ns[i] === '**' && ns[i + 1] === '**') {
          return;
        }
      }
    }



    var tree = this.listenerTree, name;

    for (i = 0; i < len; i++) {
      name = ns[i];

      tree = tree[name] || (tree[name] = {});

      if (i === len - 1) {
        if (!tree._listeners) {
          tree._listeners = listener;
        } else {
          if (typeof tree._listeners === 'function') {
            tree._listeners = [tree._listeners];
          }

          if (prepend) {
            tree._listeners.unshift(listener);
          } else {
            tree._listeners.push(listener);
          }

          if (
              !tree._listeners.warned &&
              this._maxListeners > 0 &&
              tree._listeners.length > this._maxListeners
          ) {
            tree._listeners.warned = true;
            logPossibleMemoryLeak.call(this, tree._listeners.length, name);
          }
        }
        return true;
      }
    }

    return true;
  }

  function collectTreeEvents(tree, events, root, asArray){
     var branches= ownKeys(tree);
     var i= branches.length;
     var branch, branchName, path;
     var hasListeners= tree['_listeners'];
     var isArrayPath;

     while(i-->0){
         branchName= branches[i];

         branch= tree[branchName];

         if(branchName==='_listeners'){
             path= root;
         }else {
             path = root ? root.concat(branchName) : [branchName];
         }

         isArrayPath= asArray || typeof branchName==='symbol';

         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));

         if(typeof branch==='object'){
             collectTreeEvents.call(this, branch, events, path, isArrayPath);
         }
     }

     return events;
  }

  function recursivelyGarbageCollect(root) {
    var keys = ownKeys(root);
    var i= keys.length;
    var obj, key, flag;
    while(i-->0){
      key = keys[i];
      obj = root[key];

      if(obj){
          flag= true;
          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){
             delete root[key];
          }
      }
    }

    return flag;
  }

  function Listener(emitter, event, listener){
    this.emitter= emitter;
    this.event= event;
    this.listener= listener;
  }

  Listener.prototype.off= function(){
    this.emitter.off(this.event, this.listener);
    return this;
  };

  function setupListener(event, listener, options){
      if (options === true) {
        promisify = true;
      } else if (options === false) {
        async = true;
      } else {
        if (!options || typeof options !== 'object') {
          throw TypeError('options should be an object or true');
        }
        var async = options.async;
        var promisify = options.promisify;
        var nextTick = options.nextTick;
        var objectify = options.objectify;
      }

      if (async || nextTick || promisify) {
        var _listener = listener;
        var _origin = listener._origin || listener;

        if (nextTick && !nextTickSupported) {
          throw Error('process.nextTick is not supported');
        }

        if (promisify === undefined) {
          promisify = listener.constructor.name === 'AsyncFunction';
        }

        listener = function () {
          var args = arguments;
          var context = this;
          var event = this.event;

          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {
            _setImmediate(resolve);
          }).then(function () {
            context.event = event;
            return _listener.apply(context, args)
          })) : (nextTick ? process.nextTick : _setImmediate)(function () {
            context.event = event;
            _listener.apply(context, args)
          });
        };

        listener._async = true;
        listener._origin = _origin;
      }

    return [listener, objectify? new Listener(this, event, listener): this];
  }

  function EventEmitter(conf) {
    this._events = {};
    this._newListener = false;
    this._removeListener = false;
    this.verboseMemoryLeak = false;
    configure.call(this, conf);
  }

  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

  EventEmitter.prototype.listenTo= function(target, events, options){
    if(typeof target!=='object'){
      throw TypeError('target musts be an object');
    }

    var emitter= this;

    options = resolveOptions(options, {
      on: undefined,
      off: undefined,
      reducers: undefined
    }, {
      on: functionReducer,
      off: functionReducer,
      reducers: objectFunctionReducer
    });

    function listen(events){
      if(typeof events!=='object'){
        throw TypeError('events must be an object');
      }

      var reducers= options.reducers;
      var index= findTargetIndex.call(emitter, target);
      var observer;

      if(index===-1){
        observer= new TargetObserver(emitter, target, options);
      }else{
        observer= emitter._observers[index];
      }

      var keys= ownKeys(events);
      var len= keys.length;
      var event;
      var isSingleReducer= typeof reducers==='function';

      for(var i=0; i<len; i++){
        event= keys[i];
        observer.subscribe(
            event,
            events[event] || event,
            isSingleReducer ? reducers : reducers && reducers[event]
        );
      }
    }

    isArray(events)?
        listen(toObject(events)) :
        (typeof events==='string'? listen(toObject(events.split(/\s+/))): listen(events));

    return this;
  };

  EventEmitter.prototype.stopListeningTo = function (target, event) {
    var observers = this._observers;

    if(!observers){
      return false;
    }

    var i = observers.length;
    var observer;
    var matched= false;

    if(target && typeof target!=='object'){
      throw TypeError('target should be an object');
    }

    while (i-- > 0) {
      observer = observers[i];
      if (!target || observer._target === target) {
        observer.unsubscribe(event);
        matched= true;
      }
    }

    return matched;
  };

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    if (n !== undefined) {
      this._maxListeners = n;
      if (!this._conf) this._conf = {};
      this._conf.maxListeners = n;
    }
  };

  EventEmitter.prototype.getMaxListeners = function() {
    return this._maxListeners;
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn, options) {
    return this._once(event, fn, false, options);
  };

  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
    return this._once(event, fn, true, options);
  };

  EventEmitter.prototype._once = function(event, fn, prepend, options) {
    return this._many(event, 1, fn, prepend, options);
  };

  EventEmitter.prototype.many = function(event, ttl, fn, options) {
    return this._many(event, ttl, fn, false, options);
  };

  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
    return this._many(event, ttl, fn, true, options);
  };

  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      return fn.apply(this, arguments);
    }

    listener._origin = fn;

    return this._on(event, listener, prepend, options);
  };

  EventEmitter.prototype.emit = function() {
    if (!this._events && !this._all) {
      return false;
    }

    this._events || init.call(this);

    var type = arguments[0], ns, wildcard= this.wildcard;
    var args,l,i,j, containsSymbol;

    if (type === 'newListener' && !this._newListener) {
      if (!this._events.newListener) {
        return false;
      }
    }

    if (wildcard) {
      ns= type;
      if(type!=='newListener' && type!=='removeListener'){
        if (typeof type === 'object') {
          l = type.length;
          if (symbolsSupported) {
            for (i = 0; i < l; i++) {
              if (typeof type[i] === 'symbol') {
                containsSymbol = true;
                break;
              }
            }
          }
          if (!containsSymbol) {
            type = type.join(this.delimiter);
          }
        }
      }
    }

    var al = arguments.length;
    var handler;

    if (this._all && this._all.length) {
      handler = this._all.slice();

      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this, type);
          break;
        case 2:
          handler[i].call(this, type, arguments[1]);
          break;
        case 3:
          handler[i].call(this, type, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, arguments);
        }
      }
    }

    if (wildcard) {
      handler = [];
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
    } else {
      handler = this._events[type];
      if (typeof handler === 'function') {
        this.event = type;
        switch (al) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          args = new Array(al - 1);
          for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          handler.apply(this, args);
        }
        return true;
      } else if (handler) {
        // need to make copy of handlers because list can change in the middle
        // of emit call
        handler = handler.slice();
      }
    }

    if (handler && handler.length) {
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this);
          break;
        case 2:
          handler[i].call(this, arguments[1]);
          break;
        case 3:
          handler[i].call(this, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, args);
        }
      }
      return true;
    } else if (!this.ignoreErrors && !this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
    }

    return !!this._all;
  };

  EventEmitter.prototype.emitAsync = function() {
    if (!this._events && !this._all) {
      return false;
    }

    this._events || init.call(this);

    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;
    var args,l,i,j;

    if (type === 'newListener' && !this._newListener) {
        if (!this._events.newListener) { return Promise.resolve([false]); }
    }

    if (wildcard) {
      ns= type;
      if(type!=='newListener' && type!=='removeListener'){
        if (typeof type === 'object') {
          l = type.length;
          if (symbolsSupported) {
            for (i = 0; i < l; i++) {
              if (typeof type[i] === 'symbol') {
                containsSymbol = true;
                break;
              }
            }
          }
          if (!containsSymbol) {
            type = type.join(this.delimiter);
          }
        }
      }
    }

    var promises= [];

    var al = arguments.length;
    var handler;

    if (this._all) {
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(this._all[i].call(this, type));
          break;
        case 2:
          promises.push(this._all[i].call(this, type, arguments[1]));
          break;
        case 3:
          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
          break;
        default:
          promises.push(this._all[i].apply(this, arguments));
        }
      }
    }

    if (wildcard) {
      handler = [];
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    } else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      switch (al) {
      case 1:
        promises.push(handler.call(this));
        break;
      case 2:
        promises.push(handler.call(this, arguments[1]));
        break;
      case 3:
        promises.push(handler.call(this, arguments[1], arguments[2]));
        break;
      default:
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
        promises.push(handler.apply(this, args));
      }
    } else if (handler && handler.length) {
      handler = handler.slice();
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(handler[i].call(this));
          break;
        case 2:
          promises.push(handler[i].call(this, arguments[1]));
          break;
        case 3:
          promises.push(handler[i].call(this, arguments[1], arguments[2]));
          break;
        default:
          promises.push(handler[i].apply(this, args));
        }
      }
    } else if (!this.ignoreErrors && !this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        return Promise.reject(arguments[1]); // Unhandled 'error' event
      } else {
        return Promise.reject("Uncaught, unspecified 'error' event.");
      }
    }

    return Promise.all(promises);
  };

  EventEmitter.prototype.on = function(type, listener, options) {
    return this._on(type, listener, false, options);
  };

  EventEmitter.prototype.prependListener = function(type, listener, options) {
    return this._on(type, listener, true, options);
  };

  EventEmitter.prototype.onAny = function(fn) {
    return this._onAny(fn, false);
  };

  EventEmitter.prototype.prependAny = function(fn) {
    return this._onAny(fn, true);
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype._onAny = function(fn, prepend){
    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    if (!this._all) {
      this._all = [];
    }

    // Add the function to the event listener collection.
    if(prepend){
      this._all.unshift(fn);
    }else{
      this._all.push(fn);
    }

    return this;
  };

  EventEmitter.prototype._on = function(type, listener, prepend, options) {
    if (typeof type === 'function') {
      this._onAny(type, listener);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    var returnValue= this, temp;

    if (options !== undefined) {
      temp = setupListener.call(this, type, listener, options);
      listener = temp[0];
      returnValue = temp[1];
    }

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    if (this._newListener) {
      this.emit('newListener', type, listener);
    }

    if (this.wildcard) {
      growListenerTree.call(this, type, listener, prepend);
      return returnValue;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    } else {
      if (typeof this._events[type] === 'function') {
        // Change to array.
        this._events[type] = [this._events[type]];
      }

      // If we've already got an array, just add
      if(prepend){
        this._events[type].unshift(listener);
      }else{
        this._events[type].push(listener);
      }

      // Check for listener leak
      if (
        !this._events[type].warned &&
        this._maxListeners > 0 &&
        this._events[type].length > this._maxListeners
      ) {
        this._events[type].warned = true;
        logPossibleMemoryLeak.call(this, this._events[type].length, type);
      }
    }

    return returnValue;
  };

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
      if(!leafs) return this;
    } else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          continue;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1);
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }
        if (this._removeListener)
          this.emit("removeListener", type, listener);

        return this;
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
        if (this._removeListener)
          this.emit("removeListener", type, listener);
      }
    }

    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          if (this._removeListener)
            this.emit("removeListenerAny", fn);
          return this;
        }
      }
    } else {
      fns = this._all;
      if (this._removeListener) {
        for(i = 0, l = fns.length; i < l; i++)
          this.emit("removeListenerAny", fns[i]);
      }
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function (type) {
    if (type === undefined) {
      !this._events || init.call(this);
      return this;
    }

    if (this.wildcard) {
      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
      if (!leafs) return this;
      for (i = 0; i < leafs.length; i++) {
        leaf = leafs[i];
        leaf._listeners = null;
      }
      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
    } else if (this._events) {
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function (type) {
    var _events = this._events;
    var keys, listeners, allListeners;
    var i;
    var listenerTree;

    if (type === undefined) {
      if (this.wildcard) {
        throw Error('event name required for wildcard emitter');
      }

      if (!_events) {
        return [];
      }

      keys = ownKeys(_events);
      i = keys.length;
      allListeners = [];
      while (i-- > 0) {
        listeners = _events[keys[i]];
        if (typeof listeners === 'function') {
          allListeners.push(listeners);
        } else {
          allListeners.push.apply(allListeners, listeners);
        }
      }
      return allListeners;
    } else {
      if (this.wildcard) {
        listenerTree= this.listenerTree;
        if(!listenerTree) return [];
        var handlers = [];
        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
        searchListenerTree.call(this, handlers, ns, listenerTree, 0);
        return handlers;
      }

      if (!_events) {
        return [];
      }

      listeners = _events[type];

      if (!listeners) {
        return [];
      }
      return typeof listeners === 'function' ? [listeners] : listeners;
    }
  };

  EventEmitter.prototype.eventNames = function(nsAsArray){
    var _events= this._events;
    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);
  };

  EventEmitter.prototype.listenerCount = function(type) {
    return this.listeners(type).length;
  };

  EventEmitter.prototype.hasListeners = function (type) {
    if (this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers.length > 0;
    }

    var _events = this._events;
    var _all = this._all;

    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  EventEmitter.prototype.waitFor = function (event, options) {
    var self = this;
    var type = typeof options;
    if (type === 'number') {
      options = {timeout: options};
    } else if (type === 'function') {
      options = {filter: options};
    }

    options= resolveOptions(options, {
      timeout: 0,
      filter: undefined,
      handleError: false,
      Promise: Promise,
      overload: false
    }, {
      filter: functionReducer,
      Promise: constructorReducer
    });

    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {
      function listener() {
        var filter= options.filter;
        if (filter && !filter.apply(self, arguments)) {
          return;
        }
        self.off(event, listener);
        if (options.handleError) {
          var err = arguments[0];
          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
        } else {
          resolve(toArray.apply(null, arguments));
        }
      }

      onCancel(function(){
        self.off(event, listener);
      });

      self._on(event, listener, false);
    }, {
      timeout: options.timeout,
      overload: options.overload
    })
  };

  function once(emitter, name, options) {
    options= resolveOptions(options, {
      Promise: Promise,
      timeout: 0,
      overload: false
    }, {
      Promise: constructorReducer
    });

    var _Promise= options.Promise;

    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){
      var handler;
      if (typeof emitter.addEventListener === 'function') {
        handler=  function () {
          resolve(toArray.apply(null, arguments));
        };

        onCancel(function(){
          emitter.removeEventListener(name, handler);
        });

        emitter.addEventListener(
            name,
            handler,
            {once: true}
        );
        return;
      }

      var eventListener = function(){
        errorListener && emitter.removeListener('error', errorListener);
        resolve(toArray.apply(null, arguments));
      };

      var errorListener;

      if (name !== 'error') {
        errorListener = function (err){
          emitter.removeListener(name, eventListener);
          reject(err);
        };

        emitter.once('error', errorListener);
      }

      onCancel(function(){
        errorListener && emitter.removeListener('error', errorListener);
        emitter.removeListener(name, eventListener);
      });

      emitter.once(name, eventListener);
    }, {
      timeout: options.timeout,
      overload: options.overload
    });
  }

  var prototype= EventEmitter.prototype;

  Object.defineProperties(EventEmitter, {
    defaultMaxListeners: {
      get: function () {
        return prototype._maxListeners;
      },
      set: function (n) {
        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {
          throw TypeError('n must be a non-negative number')
        }
        prototype._maxListeners = n;
      },
      enumerable: true
    },
    once: {
      value: once,
      writable: true,
      configurable: true
    }
  });

  Object.defineProperties(prototype, {
      _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
      },
      _observers: {value: null, writable: true, configurable: true}
  });

  if (true) {
     // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return EventEmitter;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var _global; }
}();


/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/expand-year/index.js":
/*!*******************************************!*\
  !*** ./node_modules/expand-year/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var zeroFill = __webpack_require__(/*! zero-fill */ "./node_modules/zero-fill/index.js")
var parseIntStrict = __webpack_require__(/*! parse-int */ "./node_modules/parse-int/index.js")

var pad = zeroFill(2)

module.exports = function expandYear (year, now) {
  now = now || new Date()
  var base = now.getFullYear().toString().substr(0, 2)
  year = parseIntStrict(year)
  return parseIntStrict(base + pad(year))
}


/***/ }),

/***/ "./node_modules/fast-luhn/index.js":
/*!*****************************************!*\
  !*** ./node_modules/fast-luhn/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


const lookup = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]

module.exports = function luhn (number) {
  if (typeof number !== 'string') throw new TypeError('Expected string input')
  if (!number) return false

  let index = number.length
  let x2 = true
  let sum = 0

  while (index) {
    const value = number.charCodeAt(--index) - 48
    if (value < 0 || value > 9) return false

    x2 = !x2
    sum += x2 ? lookup[value] : value
  }

  return sum % 10 === 0
}


/***/ }),

/***/ "./node_modules/fitvids/index.js":
/*!***************************************!*\
  !*** ./node_modules/fitvids/index.js ***!
  \***************************************/
/***/ ((module) => {

var selectors = [
  'iframe[src*="player.vimeo.com"]',
  'iframe[src*="youtube.com"]',
  'iframe[src*="youtube-nocookie.com"]',
  'iframe[src*="kickstarter.com"][src*="video.html"]',
  "object"
];

var css =
  ".fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}";

module.exports = function(parentSelector, opts) {
  parentSelector = parentSelector || "body";
  opts = opts || {};

  if (isObject(parentSelector)) {
    opts = parentSelector;
    parentSelector = "body";
  }

  opts.ignore = opts.ignore || "";
  opts.players = opts.players || "";

  var containers = queryAll(parentSelector);
  if (!hasLength(containers)) return;

  if (!document.getElementById("fit-vids-style")) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(styles());
  }

  var custom = toSelectorArray(opts.players);
  var ignored = toSelectorArray(opts.ignore);
  var ignoredSelector = ignored.length > 0 ? ignored.join() : null;
  var selector = selectors.concat(custom).join();

  if (!hasLength(selector)) {
    return;
  }

  containers.forEach(function(container) {
    var videos = queryAll(container, selector);

    videos.forEach(function(video) {
      if (ignoredSelector && video.matches(ignoredSelector)) {
        return;
      }
      wrap(video);
    });
  });
}

function queryAll(el, selector) {
  if (typeof el === "string") {
    selector = el;
    el = document;
  }
  return Array.prototype.slice.call(el.querySelectorAll(selector));
}

function toSelectorArray(input) {
  if (typeof input === "string") {
    return input
      .split(",")
      .map(trim)
      .filter(hasLength);
  } else if (isArray(input)) {
    return flatten(input.map(toSelectorArray).filter(hasLength));
  }
  return input || [];
}

function wrap(el) {
  if (/fluid-width-video-wrapper/.test(el.parentNode.className)) {
    return;
  }

  var widthAttr = parseInt(el.getAttribute("width"), 10);
  var heightAttr = parseInt(el.getAttribute("height"), 10);

  var width = !isNaN(widthAttr) ? widthAttr : el.clientWidth;
  var height = !isNaN(heightAttr) ? heightAttr : el.clientHeight;
  var aspect = height / width;

  el.removeAttribute("width");
  el.removeAttribute("height");

  var wrapper = document.createElement("div");
  el.parentNode.insertBefore(wrapper, el);
  wrapper.className = "fluid-width-video-wrapper";
  wrapper.style.paddingTop = aspect * 100 + "%";
  wrapper.appendChild(el);
}

function styles() {
  var div = document.createElement("div");
  div.innerHTML = '<p>x</p><style id="fit-vids-style">' + css + "</style>";
  return div.childNodes[1];
}

function hasLength(input) {
  return input.length > 0;
}

function trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}

function flatten(input) {
  return [].concat.apply([], input);
}

function isObject(input) {
  return Object.prototype.toString.call(input) === "[object Object]";
}

function isArray(input) {
  return Object.prototype.toString.call(input) === "[object Array]";
}


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Error = __webpack_require__(/*! es-errors */ "./node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/es-errors/uri.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasProto = __webpack_require__(/*! has-proto */ "./node_modules/has-proto/index.js")();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/has-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/has-proto/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


var test = {
	__proto__: null,
	foo: {}
};

var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
	// @ts-expect-error: TS errors on an inherited property for some reason
	return { __proto__: test }.foo === test.foo
		&& !(test instanceof $Object);
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/hasown/index.js":
/*!**************************************!*\
  !*** ./node_modules/hasown/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/history.js/scripts/bundled-uncompressed/html4+html5/jquery.history.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/history.js/scripts/bundled-uncompressed/html4+html5/jquery.history.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var __webpack_provided_window_dot_jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*
    json2.js
    2012-10-08

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== 'object') {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());/**
 * History.js jQuery Adapter
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

// Closure
(function(window,undefined){
	"use strict";

	// Localise Globals
	var
		History = window.History = window.History||{},
		jQuery = __webpack_provided_window_dot_jQuery;

	// Check Existence
	if ( typeof History.Adapter !== 'undefined' ) {
		throw new Error('History.js Adapter has already been loaded...');
	}

	// Add the Adapter
	History.Adapter = {
		/**
		 * History.Adapter.bind(el,event,callback)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {function} callback
		 * @return {void}
		 */
		bind: function(el,event,callback){
			jQuery(el).bind(event,callback);
		},

		/**
		 * History.Adapter.trigger(el,event)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {void}
		 */
		trigger: function(el,event,extra){
			jQuery(el).trigger(event,extra);
		},

		/**
		 * History.Adapter.extractEventData(key,event,extra)
		 * @param {string} key - key for the event data to extract
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {mixed}
		 */
		extractEventData: function(key,event,extra){
			// jQuery Native then jQuery Custom
			var result = (event && event.originalEvent && event.originalEvent[key]) || (extra && extra[key]) || undefined;

			// Return
			return result;
		},

		/**
		 * History.Adapter.onDomLoad(callback)
		 * @param {function} callback
		 * @return {void}
		 */
		onDomLoad: function(callback) {
			jQuery(callback);
		}
	};

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);

/**
 * History.js HTML4 Support
 * Depends on the HTML5 Support
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		document = window.document, // Make sure we are using the correct document
		setTimeout = window.setTimeout||setTimeout,
		clearTimeout = window.clearTimeout||clearTimeout,
		setInterval = window.setInterval||setInterval,
		History = window.History = window.History||{}; // Public History Object

	// Check Existence
	if ( typeof History.initHtml4 !== 'undefined' ) {
		throw new Error('History.js HTML4 Support has already been loaded...');
	}


	// ========================================================================
	// Initialise HTML4 Support

	// Initialise HTML4 Support
	History.initHtml4 = function(){
		// Initialise
		if ( typeof History.initHtml4.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initHtml4.initialized = true;
		}


		// ====================================================================
		// Properties

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = true;


		// ====================================================================
		// Hash Storage

		/**
		 * History.savedHashes
		 * Store the hashes in an array
		 */
		History.savedHashes = [];

		/**
		 * History.isLastHash(newHash)
		 * Checks if the hash is the last hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.isLastHash = function(newHash){
			// Prepare
			var oldHash = History.getHashByIndex(),
				isLast;

			// Check
			isLast = newHash === oldHash;

			// Return isLast
			return isLast;
		};

		/**
		 * History.isHashEqual(newHash, oldHash)
		 * Checks to see if two hashes are functionally equal
		 * @param {string} newHash
		 * @param {string} oldHash
		 * @return {boolean} true
		 */
		History.isHashEqual = function(newHash, oldHash){
			newHash = encodeURIComponent(newHash).replace(/%25/g, "%");
			oldHash = encodeURIComponent(oldHash).replace(/%25/g, "%");
			return newHash === oldHash;
		};

		/**
		 * History.saveHash(newHash)
		 * Push a Hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.saveHash = function(newHash){
			// Check Hash
			if ( History.isLastHash(newHash) ) {
				return false;
			}

			// Push the Hash
			History.savedHashes.push(newHash);

			// Return true
			return true;
		};

		/**
		 * History.getHashByIndex()
		 * Gets a hash by the index
		 * @param {integer} index
		 * @return {string}
		 */
		History.getHashByIndex = function(index){
			// Prepare
			var hash = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				hash = History.savedHashes[History.savedHashes.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				hash = History.savedHashes[History.savedHashes.length+index];
			}
			else {
				// Get from the beginning
				hash = History.savedHashes[index];
			}

			// Return hash
			return hash;
		};


		// ====================================================================
		// Discarded States

		/**
		 * History.discardedHashes
		 * A hashed array of discarded hashes
		 */
		History.discardedHashes = {};

		/**
		 * History.discardedStates
		 * A hashed array of discarded states
		 */
		History.discardedStates = {};

		/**
		 * History.discardState(State)
		 * Discards the state by ignoring it through History
		 * @param {object} State
		 * @return {true}
		 */
		History.discardState = function(discardedState,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Prepare
			var discardedStateHash = History.getHashByState(discardedState),
				discardObject;

			// Create Discard Object
			discardObject = {
				'discardedState': discardedState,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to DiscardedStates
			History.discardedStates[discardedStateHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardHash(hash)
		 * Discards the hash by ignoring it through History
		 * @param {string} hash
		 * @return {true}
		 */
		History.discardHash = function(discardedHash,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Create Discard Object
			var discardObject = {
				'discardedHash': discardedHash,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to discardedHash
			History.discardedHashes[discardedHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardedState(State)
		 * Checks to see if the state is discarded
		 * @param {object} State
		 * @return {bool}
		 */
		History.discardedState = function(State){
			// Prepare
			var StateHash = History.getHashByState(State),
				discarded;

			// Check
			discarded = History.discardedStates[StateHash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.discardedHash(hash)
		 * Checks to see if the state is discarded
		 * @param {string} State
		 * @return {bool}
		 */
		History.discardedHash = function(hash){
			// Check
			var discarded = History.discardedHashes[hash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.recycleState(State)
		 * Allows a discarded state to be used again
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {true}
		 */
		History.recycleState = function(State){
			//History.debug('History.recycleState', arguments);
			// Prepare
			var StateHash = History.getHashByState(State);

			// Remove from DiscardedStates
			if ( History.discardedState(State) ) {
				delete History.discardedStates[StateHash];
			}

			// Return true
			return true;
		};


		// ====================================================================
		// HTML4 HashChange Support

		if ( History.emulated.hashChange ) {
			/*
			 * We must emulate the HTML4 HashChange Support by manually checking for hash changes
			 */

			/**
			 * History.hashChangeInit()
			 * Init the HashChange Emulation
			 */
			History.hashChangeInit = function(){
				// Define our Checker Function
				History.checkerFunction = null;

				// Define some variables that will help in our checker function
				var lastDocumentHash = '',
					iframeId, iframe,
					lastIframeHash, checkerRunning,
					startedWithHash = Boolean(History.getHash());

				// Handle depending on the browser
				if ( History.isInternetExplorer() ) {
					// IE6 and IE7
					// We need to use an iframe to emulate the back and forward buttons

					// Create iFrame
					iframeId = 'historyjs-iframe';
					iframe = document.createElement('iframe');

					// Adjust iFarme
					// IE 6 requires iframe to have a src on HTTPS pages, otherwise it will throw a
					// "This page contains both secure and nonsecure items" warning.
					iframe.setAttribute('id', iframeId);
					iframe.setAttribute('src', '#');
					iframe.style.display = 'none';

					// Append iFrame
					document.body.appendChild(iframe);

					// Create initial history entry
					iframe.contentWindow.document.open();
					iframe.contentWindow.document.close();

					// Define some variables that will help in our checker function
					lastIframeHash = '';
					checkerRunning = false;

					// Define the checker function
					History.checkerFunction = function(){
						// Check Running
						if ( checkerRunning ) {
							return false;
						}

						// Update Running
						checkerRunning = true;

						// Fetch
						var
							documentHash = History.getHash(),
							iframeHash = History.getHash(iframe.contentWindow.document);

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Create a history entry in the iframe
							if ( iframeHash !== documentHash ) {
								//History.debug('hashchange.checker: iframe hash change', 'documentHash (new):', documentHash, 'iframeHash (old):', iframeHash);

								// Equalise
								lastIframeHash = iframeHash = documentHash;

								// Create History Entry
								iframe.contentWindow.document.open();
								iframe.contentWindow.document.close();

								// Update the iframe's hash
								iframe.contentWindow.document.location.hash = History.escapeHash(documentHash);
							}

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// The iFrame Hash has changed (back button caused)
						else if ( iframeHash !== lastIframeHash ) {
							//History.debug('hashchange.checker: iframe hash out of sync', 'iframeHash (new):', iframeHash, 'documentHash (old):', documentHash);

							// Equalise
							lastIframeHash = iframeHash;
							
							// If there is no iframe hash that means we're at the original
							// iframe state.
							// And if there was a hash on the original request, the original
							// iframe state was replaced instantly, so skip this state and take
							// the user back to where they came from.
							if (startedWithHash && iframeHash === '') {
								History.back();
							}
							else {
								// Update the Hash
								History.setHash(iframeHash,false);
							}
						}

						// Reset Running
						checkerRunning = false;

						// Return true
						return true;
					};
				}
				else {
					// We are not IE
					// Firefox 1 or 2, Opera

					// Define the checker function
					History.checkerFunction = function(){
						// Prepare
						var documentHash = History.getHash()||'';

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// Return true
						return true;
					};
				}

				// Apply the checker function
				History.intervalList.push(setInterval(History.checkerFunction, History.options.hashChangeInterval));

				// Done
				return true;
			}; // History.hashChangeInit

			// Bind hashChangeInit
			History.Adapter.onDomLoad(History.hashChangeInit);

		} // History.emulated.hashChange


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * We must emulate the HTML5 State Management by using HTML4 HashChange
			 */

			/**
			 * History.onHashChange(event)
			 * Trigger HTML5's window.onpopstate via HTML4 HashChange Support
			 */
			History.onHashChange = function(event){
				//History.debug('History.onHashChange', arguments);

				// Prepare
				var currentUrl = ((event && event.newURL) || History.getLocationHref()),
					currentHash = History.getHashByUrl(currentUrl),
					currentState = null,
					currentStateHash = null,
					currentStateHashExits = null,
					discardObject;

				// Check if we are the same state
				if ( History.isLastHash(currentHash) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onHashChange: no change');
					History.busy(false);
					return false;
				}

				// Reset the double check
				History.doubleCheckComplete();

				// Store our location for use in detecting back/forward direction
				History.saveHash(currentHash);

				// Expand Hash
				if ( currentHash && History.isTraditionalAnchor(currentHash) ) {
					//History.debug('History.onHashChange: traditional anchor', currentHash);
					// Traditional Anchor Hash
					History.Adapter.trigger(window,'anchorchange');
					History.busy(false);
					return false;
				}

				// Create State
				currentState = History.extractState(History.getFullUrl(currentHash||History.getLocationHref()),true);

				// Check if we are the same state
				if ( History.isLastSavedState(currentState) ) {
					//History.debug('History.onHashChange: no change');
					// There has been no change (just the page's hash has finally propagated)
					History.busy(false);
					return false;
				}

				// Create the state Hash
				currentStateHash = History.getHashByState(currentState);

				// Check if we are DiscardedState
				discardObject = History.discardedState(currentState);
				if ( discardObject ) {
					// Ignore this state as it has been discarded and go back to the state before it
					if ( History.getHashByIndex(-2) === History.getHashByState(discardObject.forwardState) ) {
						// We are going backwards
						//History.debug('History.onHashChange: go backwards');
						History.back(false);
					} else {
						// We are going forwards
						//History.debug('History.onHashChange: go forwards');
						History.forward(false);
					}
					return false;
				}

				// Push the new HTML5 State
				//History.debug('History.onHashChange: success hashchange');
				History.pushState(currentState.data,currentState.title,encodeURI(currentState.url),false);

				// End onHashChange closure
				return true;
			};
			History.Adapter.bind(window,'hashchange',History.onHashChange);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// We assume that the URL passed in is URI-encoded, but this makes
				// sure that it's fully URI encoded; any '%'s that are encoded are
				// converted back into '%'s
				url = encodeURI(url).replace(/%25/g, "%");

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Object
				var newState = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					html4Hash = History.getHash(),
					wasExpected = History.expectedStateId == newState.id;

				// Store the newState
				History.storeState(newState);
				History.expectedStateId = newState.id;

				// Recycle the State
				History.recycleState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Check if we are the same State
				if ( newStateHash === oldStateHash ) {
					//History.debug('History.pushState: no change', newStateHash);
					History.busy(false);
					return false;
				}

				// Update HTML5 State
				History.saveState(newState);

				// Fire HTML5 Event
				if(!wasExpected)
					History.Adapter.trigger(window,'statechange');

				// Update HTML4 Hash
				if ( !History.isHashEqual(newStateHash, html4Hash) && !History.isHashEqual(newStateHash, History.getShortUrl(History.getLocationHref())) ) {
					History.setHash(newStateHash,false);
				}
				
				History.busy(false);

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// We assume that the URL passed in is URI-encoded, but this makes
				// sure that it's fully URI encoded; any '%'s that are encoded are
				// converted back into '%'s
				url = encodeURI(url).replace(/%25/g, "%");

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Objects
				var newState        = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState        = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					previousState   = History.getStateByIndex(-2);

				// Discard Old State
				History.discardState(oldState,newState,previousState);

				// If the url hasn't changed, just store and save the state
				// and fire a statechange event to be consistent with the
				// html 5 api
				if ( newStateHash === oldStateHash ) {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;
	
					// Recycle the State
					History.recycleState(newState);
	
					// Force update of the title
					History.setTitle(newState);
					
					// Update HTML5 State
					History.saveState(newState);

					// Fire HTML5 Event
					//History.debug('History.pushState: trigger popstate');
					History.Adapter.trigger(window,'statechange');
					History.busy(false);
				}
				else {
					// Alias to PushState
					History.pushState(newState.data,newState.title,newState.url,false);
				}

				// End replaceState closure
				return true;
			};

		} // History.emulated.pushState



		// ====================================================================
		// Initialise

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/**
			 * Ensure initial state is handled correctly
			 */
			if ( History.getHash() && !History.emulated.hashChange ) {
				History.Adapter.onDomLoad(function(){
					History.Adapter.trigger(window,'hashchange');
				});
			}

		} // History.emulated.pushState

	}; // History.initHtml4

	// Try to Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);
/**
 * History.js Core
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		console = window.console||undefined, // Prevent a JSLint complain
		document = window.document, // Make sure we are using the correct document
		navigator = window.navigator, // Make sure we are using the correct navigator
		sessionStorage = false, // sessionStorage
		setTimeout = window.setTimeout,
		clearTimeout = window.clearTimeout,
		setInterval = window.setInterval,
		clearInterval = window.clearInterval,
		JSON = window.JSON,
		alert = window.alert,
		History = window.History = window.History||{}, // Public History Object
		history = window.history; // Old History Object

	try {
		sessionStorage = window.sessionStorage; // This will throw an exception in some browsers when cookies/localStorage are explicitly disabled (i.e. Chrome)
		sessionStorage.setItem('TEST', '1');
		sessionStorage.removeItem('TEST');
	} catch(e) {
		sessionStorage = false;
	}

	// MooTools Compatibility
	JSON.stringify = JSON.stringify||JSON.encode;
	JSON.parse = JSON.parse||JSON.decode;

	// Check Existence
	if ( typeof History.init !== 'undefined' ) {
		throw new Error('History.js Core has already been loaded...');
	}

	// Initialise History
	History.init = function(options){
		// Check Load Status of Adapter
		if ( typeof History.Adapter === 'undefined' ) {
			return false;
		}

		// Check Load Status of Core
		if ( typeof History.initCore !== 'undefined' ) {
			History.initCore();
		}

		// Check Load Status of HTML4 Support
		if ( typeof History.initHtml4 !== 'undefined' ) {
			History.initHtml4();
		}

		// Return true
		return true;
	};


	// ========================================================================
	// Initialise Core

	// Initialise Core
	History.initCore = function(options){
		// Initialise
		if ( typeof History.initCore.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initCore.initialized = true;
		}


		// ====================================================================
		// Options

		/**
		 * History.options
		 * Configurable options
		 */
		History.options = History.options||{};

		/**
		 * History.options.hashChangeInterval
		 * How long should the interval be before hashchange checks
		 */
		History.options.hashChangeInterval = History.options.hashChangeInterval || 100;

		/**
		 * History.options.safariPollInterval
		 * How long should the interval be before safari poll checks
		 */
		History.options.safariPollInterval = History.options.safariPollInterval || 500;

		/**
		 * History.options.doubleCheckInterval
		 * How long should the interval be before we perform a double check
		 */
		History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;

		/**
		 * History.options.disableSuid
		 * Force History not to append suid
		 */
		History.options.disableSuid = History.options.disableSuid || false;

		/**
		 * History.options.storeInterval
		 * How long should we wait between store calls
		 */
		History.options.storeInterval = History.options.storeInterval || 1000;

		/**
		 * History.options.busyDelay
		 * How long should we wait between busy events
		 */
		History.options.busyDelay = History.options.busyDelay || 250;

		/**
		 * History.options.debug
		 * If true will enable debug messages to be logged
		 */
		History.options.debug = History.options.debug || false;

		/**
		 * History.options.initialTitle
		 * What is the title of the initial state
		 */
		History.options.initialTitle = History.options.initialTitle || document.title;

		/**
		 * History.options.html4Mode
		 * If true, will force HTMl4 mode (hashtags)
		 */
		History.options.html4Mode = History.options.html4Mode || false;

		/**
		 * History.options.delayInit
		 * Want to override default options and call init manually.
		 */
		History.options.delayInit = History.options.delayInit || false;


		// ====================================================================
		// Interval record

		/**
		 * History.intervalList
		 * List of intervals set, to be cleared when document is unloaded.
		 */
		History.intervalList = [];

		/**
		 * History.clearAllIntervals
		 * Clears all setInterval instances.
		 */
		History.clearAllIntervals = function(){
			var i, il = History.intervalList;
			if (typeof il !== "undefined" && il !== null) {
				for (i = 0; i < il.length; i++) {
					clearInterval(il[i]);
				}
				History.intervalList = null;
			}
		};


		// ====================================================================
		// Debug

		/**
		 * History.debug(message,...)
		 * Logs the passed arguments if debug enabled
		 */
		History.debug = function(){
			if ( (History.options.debug||false) ) {
				History.log.apply(History,arguments);
			}
		};

		/**
		 * History.log(message,...)
		 * Logs the passed arguments
		 */
		History.log = function(){
			// Prepare
			var
				consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
				textarea = document.getElementById('log'),
				message,
				i,n,
				args,arg
				;

			// Write to Console
			if ( consoleExists ) {
				args = Array.prototype.slice.call(arguments);
				message = args.shift();
				if ( typeof console.debug !== 'undefined' ) {
					console.debug.apply(console,[message,args]);
				}
				else {
					console.log.apply(console,[message,args]);
				}
			}
			else {
				message = ("\n"+arguments[0]+"\n");
			}

			// Write to log
			for ( i=1,n=arguments.length; i<n; ++i ) {
				arg = arguments[i];
				if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
					try {
						arg = JSON.stringify(arg);
					}
					catch ( Exception ) {
						// Recursive Object
					}
				}
				message += "\n"+arg+"\n";
			}

			// Textarea
			if ( textarea ) {
				textarea.value += message+"\n-----\n";
				textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
			}
			// No Textarea, No Console
			else if ( !consoleExists ) {
				alert(message);
			}

			// Return true
			return true;
		};


		// ====================================================================
		// Emulated Status

		/**
		 * History.getInternetExplorerMajorVersion()
		 * Get's the major version of Internet Explorer
		 * @return {integer}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 * @author James Padolsey <https://gist.github.com/527683>
		 */
		History.getInternetExplorerMajorVersion = function(){
			var result = History.getInternetExplorerMajorVersion.cached =
					(typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
				?	History.getInternetExplorerMajorVersion.cached
				:	(function(){
						var v = 3,
								div = document.createElement('div'),
								all = div.getElementsByTagName('i');
						while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
						return (v > 4) ? v : false;
					})()
				;
			return result;
		};

		/**
		 * History.isInternetExplorer()
		 * Are we using Internet Explorer?
		 * @return {boolean}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 */
		History.isInternetExplorer = function(){
			var result =
				History.isInternetExplorer.cached =
				(typeof History.isInternetExplorer.cached !== 'undefined')
					?	History.isInternetExplorer.cached
					:	Boolean(History.getInternetExplorerMajorVersion())
				;
			return result;
		};

		/**
		 * History.emulated
		 * Which features require emulating?
		 */

		if (History.options.html4Mode) {
			History.emulated = {
				pushState : true,
				hashChange: true
			};
		}

		else {

			History.emulated = {
				pushState: !Boolean(
					window.history && window.history.pushState && window.history.replaceState
					&& !(
						(/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
						|| (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
					)
				),
				hashChange: Boolean(
					!(('onhashchange' in window) || ('onhashchange' in document))
					||
					(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
				)
			};
		}

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = !History.emulated.pushState;

		/**
		 * History.bugs
		 * Which bugs are present
		 */
		History.bugs = {
			/**
			 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
			 * https://bugs.webkit.org/show_bug.cgi?id=56249
			 */
			setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
			 * https://bugs.webkit.org/show_bug.cgi?id=42940
			 */
			safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
			 */
			ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),

			/**
			 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
			 */
			hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
		};

		/**
		 * History.isEmptyObject(obj)
		 * Checks to see if the Object is Empty
		 * @param {Object} obj
		 * @return {boolean}
		 */
		History.isEmptyObject = function(obj) {
			for ( var name in obj ) {
				if ( obj.hasOwnProperty(name) ) {
					return false;
				}
			}
			return true;
		};

		/**
		 * History.cloneObject(obj)
		 * Clones a object and eliminate all references to the original contexts
		 * @param {Object} obj
		 * @return {Object}
		 */
		History.cloneObject = function(obj) {
			var hash,newObj;
			if ( obj ) {
				hash = JSON.stringify(obj);
				newObj = JSON.parse(hash);
			}
			else {
				newObj = {};
			}
			return newObj;
		};


		// ====================================================================
		// URL Helpers

		/**
		 * History.getRootUrl()
		 * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
		 * @return {String} rootUrl
		 */
		History.getRootUrl = function(){
			// Create
			var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
			if ( document.location.port||false ) {
				rootUrl += ':'+document.location.port;
			}
			rootUrl += '/';

			// Return
			return rootUrl;
		};

		/**
		 * History.getBaseHref()
		 * Fetches the `href` attribute of the `<base href="...">` element if it exists
		 * @return {String} baseHref
		 */
		History.getBaseHref = function(){
			// Create
			var
				baseElements = document.getElementsByTagName('base'),
				baseElement = null,
				baseHref = '';

			// Test for Base Element
			if ( baseElements.length === 1 ) {
				// Prepare for Base Element
				baseElement = baseElements[0];
				baseHref = baseElement.href.replace(/[^\/]+$/,'');
			}

			// Adjust trailing slash
			baseHref = baseHref.replace(/\/+$/,'');
			if ( baseHref ) baseHref += '/';

			// Return
			return baseHref;
		};

		/**
		 * History.getBaseUrl()
		 * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
		 * @return {String} baseUrl
		 */
		History.getBaseUrl = function(){
			// Create
			var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();

			// Return
			return baseUrl;
		};

		/**
		 * History.getPageUrl()
		 * Fetches the URL of the current page
		 * @return {String} pageUrl
		 */
		History.getPageUrl = function(){
			// Fetch
			var
				State = History.getState(false,false),
				stateUrl = (State||{}).url||History.getLocationHref(),
				pageUrl;

			// Create
			pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/\./).test(part) ? part : part+'/';
			});

			// Return
			return pageUrl;
		};

		/**
		 * History.getBasePageUrl()
		 * Fetches the Url of the directory of the current page
		 * @return {String} basePageUrl
		 */
		History.getBasePageUrl = function(){
			// Create
			var basePageUrl = (History.getLocationHref()).replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/[^\/]$/).test(part) ? '' : part;
			}).replace(/\/+$/,'')+'/';

			// Return
			return basePageUrl;
		};

		/**
		 * History.getFullUrl(url)
		 * Ensures that we have an absolute URL and not a relative URL
		 * @param {string} url
		 * @param {Boolean} allowBaseHref
		 * @return {string} fullUrl
		 */
		History.getFullUrl = function(url,allowBaseHref){
			// Prepare
			var fullUrl = url, firstChar = url.substring(0,1);
			allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;

			// Check
			if ( /[a-z]+\:\/\//.test(url) ) {
				// Full URL
			}
			else if ( firstChar === '/' ) {
				// Root URL
				fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
			}
			else if ( firstChar === '#' ) {
				// Anchor URL
				fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
			}
			else if ( firstChar === '?' ) {
				// Query URL
				fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
			}
			else {
				// Relative URL
				if ( allowBaseHref ) {
					fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
				} else {
					fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
				}
				// We have an if condition above as we do not want hashes
				// which are relative to the baseHref in our URLs
				// as if the baseHref changes, then all our bookmarks
				// would now point to different locations
				// whereas the basePageUrl will always stay the same
			}

			// Return
			return fullUrl.replace(/\#$/,'');
		};

		/**
		 * History.getShortUrl(url)
		 * Ensures that we have a relative URL and not a absolute URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getShortUrl = function(url){
			// Prepare
			var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();

			// Trim baseUrl
			if ( History.emulated.pushState ) {
				// We are in a if statement as when pushState is not emulated
				// The actual url these short urls are relative to can change
				// So within the same session, we the url may end up somewhere different
				shortUrl = shortUrl.replace(baseUrl,'');
			}

			// Trim rootUrl
			shortUrl = shortUrl.replace(rootUrl,'/');

			// Ensure we can still detect it as a state
			if ( History.isTraditionalAnchor(shortUrl) ) {
				shortUrl = './'+shortUrl;
			}

			// Clean It
			shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');

			// Return
			return shortUrl;
		};

		/**
		 * History.getLocationHref(document)
		 * Returns a normalized version of document.location.href
		 * accounting for browser inconsistencies, etc.
		 *
		 * This URL will be URI-encoded and will include the hash
		 *
		 * @param {object} document
		 * @return {string} url
		 */
		History.getLocationHref = function(doc) {
			doc = doc || document;

			// most of the time, this will be true
			if (doc.URL === doc.location.href)
				return doc.location.href;

			// some versions of webkit URI-decode document.location.href
			// but they leave document.URL in an encoded state
			if (doc.location.href === decodeURIComponent(doc.URL))
				return doc.URL;

			// FF 3.6 only updates document.URL when a page is reloaded
			// document.location.href is updated correctly
			if (doc.location.hash && decodeURIComponent(doc.location.href.replace(/^[^#]+/, "")) === doc.location.hash)
				return doc.location.href;

			if (doc.URL.indexOf('#') == -1 && doc.location.href.indexOf('#') != -1)
				return doc.location.href;
			
			return doc.URL || doc.location.href;
		};


		// ====================================================================
		// State Storage

		/**
		 * History.store
		 * The store for all session specific data
		 */
		History.store = {};

		/**
		 * History.idToState
		 * 1-1: State ID to State Object
		 */
		History.idToState = History.idToState||{};

		/**
		 * History.stateToId
		 * 1-1: State String to State ID
		 */
		History.stateToId = History.stateToId||{};

		/**
		 * History.urlToId
		 * 1-1: State URL to State ID
		 */
		History.urlToId = History.urlToId||{};

		/**
		 * History.storedStates
		 * Store the states in an array
		 */
		History.storedStates = History.storedStates||[];

		/**
		 * History.savedStates
		 * Saved the states in an array
		 */
		History.savedStates = History.savedStates||[];

		/**
		 * History.noramlizeStore()
		 * Noramlize the store by adding necessary values
		 */
		History.normalizeStore = function(){
			History.store.idToState = History.store.idToState||{};
			History.store.urlToId = History.store.urlToId||{};
			History.store.stateToId = History.store.stateToId||{};
		};

		/**
		 * History.getState()
		 * Get an object containing the data, title and url of the current state
		 * @param {Boolean} friendly
		 * @param {Boolean} create
		 * @return {Object} State
		 */
		History.getState = function(friendly,create){
			// Prepare
			if ( typeof friendly === 'undefined' ) { friendly = true; }
			if ( typeof create === 'undefined' ) { create = true; }

			// Fetch
			var State = History.getLastSavedState();

			// Create
			if ( !State && create ) {
				State = History.createStateObject();
			}

			// Adjust
			if ( friendly ) {
				State = History.cloneObject(State);
				State.url = State.cleanUrl||State.url;
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByState(State)
		 * Gets a ID for a State
		 * @param {State} newState
		 * @return {String} id
		 */
		History.getIdByState = function(newState){

			// Fetch ID
			var id = History.extractId(newState.url),
				str;

			if ( !id ) {
				// Find ID via State String
				str = History.getStateString(newState);
				if ( typeof History.stateToId[str] !== 'undefined' ) {
					id = History.stateToId[str];
				}
				else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
					id = History.store.stateToId[str];
				}
				else {
					// Generate a new ID
					while ( true ) {
						id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
						if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
							break;
						}
					}

					// Apply the new State to the ID
					History.stateToId[str] = id;
					History.idToState[id] = newState;
				}
			}

			// Return ID
			return id;
		};

		/**
		 * History.normalizeState(State)
		 * Expands a State Object
		 * @param {object} State
		 * @return {object}
		 */
		History.normalizeState = function(oldState){
			// Variables
			var newState, dataNotEmpty;

			// Prepare
			if ( !oldState || (typeof oldState !== 'object') ) {
				oldState = {};
			}

			// Check
			if ( typeof oldState.normalized !== 'undefined' ) {
				return oldState;
			}

			// Adjust
			if ( !oldState.data || (typeof oldState.data !== 'object') ) {
				oldState.data = {};
			}

			// ----------------------------------------------------------------

			// Create
			newState = {};
			newState.normalized = true;
			newState.title = oldState.title||'';
			newState.url = History.getFullUrl(oldState.url?oldState.url:(History.getLocationHref()));
			newState.hash = History.getShortUrl(newState.url);
			newState.data = History.cloneObject(oldState.data);

			// Fetch ID
			newState.id = History.getIdByState(newState);

			// ----------------------------------------------------------------

			// Clean the URL
			newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
			newState.url = newState.cleanUrl;

			// Check to see if we have more than just a url
			dataNotEmpty = !History.isEmptyObject(newState.data);

			// Apply
			if ( (newState.title || dataNotEmpty) && History.options.disableSuid !== true ) {
				// Add ID to Hash
				newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
				if ( !/\?/.test(newState.hash) ) {
					newState.hash += '?';
				}
				newState.hash += '&_suid='+newState.id;
			}

			// Create the Hashed URL
			newState.hashedUrl = History.getFullUrl(newState.hash);

			// ----------------------------------------------------------------

			// Update the URL if we have a duplicate
			if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
				newState.url = newState.hashedUrl;
			}

			// ----------------------------------------------------------------

			// Return
			return newState;
		};

		/**
		 * History.createStateObject(data,title,url)
		 * Creates a object based on the data, title and url state params
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {object}
		 */
		History.createStateObject = function(data,title,url){
			// Hashify
			var State = {
				'data': data,
				'title': title,
				'url': url
			};

			// Expand the State
			State = History.normalizeState(State);

			// Return object
			return State;
		};

		/**
		 * History.getStateById(id)
		 * Get a state by it's UID
		 * @param {String} id
		 */
		History.getStateById = function(id){
			// Prepare
			id = String(id);

			// Retrieve
			var State = History.idToState[id] || History.store.idToState[id] || undefined;

			// Return State
			return State;
		};

		/**
		 * Get a State's String
		 * @param {State} passedState
		 */
		History.getStateString = function(passedState){
			// Prepare
			var State, cleanedState, str;

			// Fetch
			State = History.normalizeState(passedState);

			// Clean
			cleanedState = {
				data: State.data,
				title: passedState.title,
				url: passedState.url
			};

			// Fetch
			str = JSON.stringify(cleanedState);

			// Return
			return str;
		};

		/**
		 * Get a State's ID
		 * @param {State} passedState
		 * @return {String} id
		 */
		History.getStateId = function(passedState){
			// Prepare
			var State, id;

			// Fetch
			State = History.normalizeState(passedState);

			// Fetch
			id = State.id;

			// Return
			return id;
		};

		/**
		 * History.getHashByState(State)
		 * Creates a Hash for the State Object
		 * @param {State} passedState
		 * @return {String} hash
		 */
		History.getHashByState = function(passedState){
			// Prepare
			var State, hash;

			// Fetch
			State = History.normalizeState(passedState);

			// Hash
			hash = State.hash;

			// Return
			return hash;
		};

		/**
		 * History.extractId(url_or_hash)
		 * Get a State ID by it's URL or Hash
		 * @param {string} url_or_hash
		 * @return {string} id
		 */
		History.extractId = function ( url_or_hash ) {
			// Prepare
			var id,parts,url, tmp;

			// Extract
			
			// If the URL has a #, use the id from before the #
			if (url_or_hash.indexOf('#') != -1)
			{
				tmp = url_or_hash.split("#")[0];
			}
			else
			{
				tmp = url_or_hash;
			}
			
			parts = /(.*)\&_suid=([0-9]+)$/.exec(tmp);
			url = parts ? (parts[1]||url_or_hash) : url_or_hash;
			id = parts ? String(parts[2]||'') : '';

			// Return
			return id||false;
		};

		/**
		 * History.isTraditionalAnchor
		 * Checks to see if the url is a traditional anchor or not
		 * @param {String} url_or_hash
		 * @return {Boolean}
		 */
		History.isTraditionalAnchor = function(url_or_hash){
			// Check
			var isTraditional = !(/[\/\?\.]/.test(url_or_hash));

			// Return
			return isTraditional;
		};

		/**
		 * History.extractState
		 * Get a State by it's URL or Hash
		 * @param {String} url_or_hash
		 * @return {State|null}
		 */
		History.extractState = function(url_or_hash,create){
			// Prepare
			var State = null, id, url;
			create = create||false;

			// Fetch SUID
			id = History.extractId(url_or_hash);
			if ( id ) {
				State = History.getStateById(id);
			}

			// Fetch SUID returned no State
			if ( !State ) {
				// Fetch URL
				url = History.getFullUrl(url_or_hash);

				// Check URL
				id = History.getIdByUrl(url)||false;
				if ( id ) {
					State = History.getStateById(id);
				}

				// Create State
				if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
					State = History.createStateObject(null,null,url);
				}
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByUrl()
		 * Get a State ID by a State URL
		 */
		History.getIdByUrl = function(url){
			// Fetch
			var id = History.urlToId[url] || History.store.urlToId[url] || undefined;

			// Return
			return id;
		};

		/**
		 * History.getLastSavedState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastSavedState = function(){
			return History.savedStates[History.savedStates.length-1]||undefined;
		};

		/**
		 * History.getLastStoredState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastStoredState = function(){
			return History.storedStates[History.storedStates.length-1]||undefined;
		};

		/**
		 * History.hasUrlDuplicate
		 * Checks if a Url will have a url conflict
		 * @param {Object} newState
		 * @return {Boolean} hasDuplicate
		 */
		History.hasUrlDuplicate = function(newState) {
			// Prepare
			var hasDuplicate = false,
				oldState;

			// Fetch
			oldState = History.extractState(newState.url);

			// Check
			hasDuplicate = oldState && oldState.id !== newState.id;

			// Return
			return hasDuplicate;
		};

		/**
		 * History.storeState
		 * Store a State
		 * @param {Object} newState
		 * @return {Object} newState
		 */
		History.storeState = function(newState){
			// Store the State
			History.urlToId[newState.url] = newState.id;

			// Push the State
			History.storedStates.push(History.cloneObject(newState));

			// Return newState
			return newState;
		};

		/**
		 * History.isLastSavedState(newState)
		 * Tests to see if the state is the last state
		 * @param {Object} newState
		 * @return {boolean} isLast
		 */
		History.isLastSavedState = function(newState){
			// Prepare
			var isLast = false,
				newId, oldState, oldId;

			// Check
			if ( History.savedStates.length ) {
				newId = newState.id;
				oldState = History.getLastSavedState();
				oldId = oldState.id;

				// Check
				isLast = (newId === oldId);
			}

			// Return
			return isLast;
		};

		/**
		 * History.saveState
		 * Push a State
		 * @param {Object} newState
		 * @return {boolean} changed
		 */
		History.saveState = function(newState){
			// Check Hash
			if ( History.isLastSavedState(newState) ) {
				return false;
			}

			// Push the State
			History.savedStates.push(History.cloneObject(newState));

			// Return true
			return true;
		};

		/**
		 * History.getStateByIndex()
		 * Gets a state by the index
		 * @param {integer} index
		 * @return {Object}
		 */
		History.getStateByIndex = function(index){
			// Prepare
			var State = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				State = History.savedStates[History.savedStates.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				State = History.savedStates[History.savedStates.length+index];
			}
			else {
				// Get from the beginning
				State = History.savedStates[index];
			}

			// Return State
			return State;
		};
		
		/**
		 * History.getCurrentIndex()
		 * Gets the current index
		 * @return (integer)
		*/
		History.getCurrentIndex = function(){
			// Prepare
			var index = null;
			
			// No states saved
			if(History.savedStates.length < 1) {
				index = 0;
			}
			else {
				index = History.savedStates.length-1;
			}
			return index;
		};

		// ====================================================================
		// Hash Helpers

		/**
		 * History.getHash()
		 * @param {Location=} location
		 * Gets the current document hash
		 * Note: unlike location.hash, this is guaranteed to return the escaped hash in all browsers
		 * @return {string}
		 */
		History.getHash = function(doc){
			var url = History.getLocationHref(doc),
				hash;
			hash = History.getHashByUrl(url);
			return hash;
		};

		/**
		 * History.unescapeHash()
		 * normalize and Unescape a Hash
		 * @param {String} hash
		 * @return {string}
		 */
		History.unescapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Unescape hash
			result = decodeURIComponent(result);

			// Return result
			return result;
		};

		/**
		 * History.normalizeHash()
		 * normalize a hash across browsers
		 * @return {string}
		 */
		History.normalizeHash = function(hash){
			// Prepare
			var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');

			// Return result
			return result;
		};

		/**
		 * History.setHash(hash)
		 * Sets the document hash
		 * @param {string} hash
		 * @return {History}
		 */
		History.setHash = function(hash,queue){
			// Prepare
			var State, pageUrl;

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.setHash: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.setHash,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Log
			//History.debug('History.setHash: called',hash);

			// Make Busy + Continue
			History.busy(true);

			// Check if hash is a state
			State = History.extractState(hash,true);
			if ( State && !History.emulated.pushState ) {
				// Hash is a state so skip the setHash
				//History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);

				// PushState
				History.pushState(State.data,State.title,State.url,false);
			}
			else if ( History.getHash() !== hash ) {
				// Hash is a proper hash, so apply it

				// Handle browser bugs
				if ( History.bugs.setHash ) {
					// Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249

					// Fetch the base page
					pageUrl = History.getPageUrl();

					// Safari hash apply
					History.pushState(null,null,pageUrl+'#'+hash,false);
				}
				else {
					// Normal hash apply
					document.location.hash = hash;
				}
			}

			// Chain
			return History;
		};

		/**
		 * History.escape()
		 * normalize and Escape a Hash
		 * @return {string}
		 */
		History.escapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Escape hash
			result = window.encodeURIComponent(result);

			// IE6 Escape Bug
			if ( !History.bugs.hashEscape ) {
				// Restore common parts
				result = result
					.replace(/\%21/g,'!')
					.replace(/\%26/g,'&')
					.replace(/\%3D/g,'=')
					.replace(/\%3F/g,'?');
			}

			// Return result
			return result;
		};

		/**
		 * History.getHashByUrl(url)
		 * Extracts the Hash from a URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getHashByUrl = function(url){
			// Extract the hash
			var hash = String(url)
				.replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
				;

			// Unescape hash
			hash = History.unescapeHash(hash);

			// Return hash
			return hash;
		};

		/**
		 * History.setTitle(title)
		 * Applies the title to the document
		 * @param {State} newState
		 * @return {Boolean}
		 */
		History.setTitle = function(newState){
			// Prepare
			var title = newState.title,
				firstState;

			// Initial
			if ( !title ) {
				firstState = History.getStateByIndex(0);
				if ( firstState && firstState.url === newState.url ) {
					title = firstState.title||History.options.initialTitle;
				}
			}

			// Apply
			try {
				document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
			}
			catch ( Exception ) { }
			document.title = title;

			// Chain
			return History;
		};


		// ====================================================================
		// Queueing

		/**
		 * History.queues
		 * The list of queues to use
		 * First In, First Out
		 */
		History.queues = [];

		/**
		 * History.busy(value)
		 * @param {boolean} value [optional]
		 * @return {boolean} busy
		 */
		History.busy = function(value){
			// Apply
			if ( typeof value !== 'undefined' ) {
				//History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
				History.busy.flag = value;
			}
			// Default
			else if ( typeof History.busy.flag === 'undefined' ) {
				History.busy.flag = false;
			}

			// Queue
			if ( !History.busy.flag ) {
				// Execute the next item in the queue
				clearTimeout(History.busy.timeout);
				var fireNext = function(){
					var i, queue, item;
					if ( History.busy.flag ) return;
					for ( i=History.queues.length-1; i >= 0; --i ) {
						queue = History.queues[i];
						if ( queue.length === 0 ) continue;
						item = queue.shift();
						History.fireQueueItem(item);
						History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
					}
				};
				History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
			}

			// Return
			return History.busy.flag;
		};

		/**
		 * History.busy.flag
		 */
		History.busy.flag = false;

		/**
		 * History.fireQueueItem(item)
		 * Fire a Queue Item
		 * @param {Object} item
		 * @return {Mixed} result
		 */
		History.fireQueueItem = function(item){
			return item.callback.apply(item.scope||History,item.args||[]);
		};

		/**
		 * History.pushQueue(callback,args)
		 * Add an item to the queue
		 * @param {Object} item [scope,callback,args,queue]
		 */
		History.pushQueue = function(item){
			// Prepare the queue
			History.queues[item.queue||0] = History.queues[item.queue||0]||[];

			// Add to the queue
			History.queues[item.queue||0].push(item);

			// Chain
			return History;
		};

		/**
		 * History.queue (item,queue), (func,queue), (func), (item)
		 * Either firs the item now if not busy, or adds it to the queue
		 */
		History.queue = function(item,queue){
			// Prepare
			if ( typeof item === 'function' ) {
				item = {
					callback: item
				};
			}
			if ( typeof queue !== 'undefined' ) {
				item.queue = queue;
			}

			// Handle
			if ( History.busy() ) {
				History.pushQueue(item);
			} else {
				History.fireQueueItem(item);
			}

			// Chain
			return History;
		};

		/**
		 * History.clearQueue()
		 * Clears the Queue
		 */
		History.clearQueue = function(){
			History.busy.flag = false;
			History.queues = [];
			return History;
		};


		// ====================================================================
		// IE Bug Fix

		/**
		 * History.stateChanged
		 * States whether or not the state has changed since the last double check was initialised
		 */
		History.stateChanged = false;

		/**
		 * History.doubleChecker
		 * Contains the timeout used for the double checks
		 */
		History.doubleChecker = false;

		/**
		 * History.doubleCheckComplete()
		 * Complete a double check
		 * @return {History}
		 */
		History.doubleCheckComplete = function(){
			// Update
			History.stateChanged = true;

			// Clear
			History.doubleCheckClear();

			// Chain
			return History;
		};

		/**
		 * History.doubleCheckClear()
		 * Clear a double check
		 * @return {History}
		 */
		History.doubleCheckClear = function(){
			// Clear
			if ( History.doubleChecker ) {
				clearTimeout(History.doubleChecker);
				History.doubleChecker = false;
			}

			// Chain
			return History;
		};

		/**
		 * History.doubleCheck()
		 * Create a double check
		 * @return {History}
		 */
		History.doubleCheck = function(tryAgain){
			// Reset
			History.stateChanged = false;
			History.doubleCheckClear();

			// Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
			// Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
			if ( History.bugs.ieDoubleCheck ) {
				// Apply Check
				History.doubleChecker = setTimeout(
					function(){
						History.doubleCheckClear();
						if ( !History.stateChanged ) {
							//History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
							// Re-Attempt
							tryAgain();
						}
						return true;
					},
					History.options.doubleCheckInterval
				);
			}

			// Chain
			return History;
		};


		// ====================================================================
		// Safari Bug Fix

		/**
		 * History.safariStatePoll()
		 * Poll the current state
		 * @return {History}
		 */
		History.safariStatePoll = function(){
			// Poll the URL

			// Get the Last State which has the new URL
			var
				urlState = History.extractState(History.getLocationHref()),
				newState;

			// Check for a difference
			if ( !History.isLastSavedState(urlState) ) {
				newState = urlState;
			}
			else {
				return;
			}

			// Check if we have a state with that url
			// If not create it
			if ( !newState ) {
				//History.debug('History.safariStatePoll: new');
				newState = History.createStateObject();
			}

			// Apply the New State
			//History.debug('History.safariStatePoll: trigger');
			History.Adapter.trigger(window,'popstate');

			// Chain
			return History;
		};


		// ====================================================================
		// State Aliases

		/**
		 * History.back(queue)
		 * Send the browser history back one item
		 * @param {Integer} queue [optional]
		 */
		History.back = function(queue){
			//History.debug('History.back: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.back: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.back,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.back(false);
			});

			// Go back
			history.go(-1);

			// End back closure
			return true;
		};

		/**
		 * History.forward(queue)
		 * Send the browser history forward one item
		 * @param {Integer} queue [optional]
		 */
		History.forward = function(queue){
			//History.debug('History.forward: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.forward: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.forward,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.forward(false);
			});

			// Go forward
			history.go(1);

			// End forward closure
			return true;
		};

		/**
		 * History.go(index,queue)
		 * Send the browser history back or forward index times
		 * @param {Integer} queue [optional]
		 */
		History.go = function(index,queue){
			//History.debug('History.go: called', arguments);

			// Prepare
			var i;

			// Handle
			if ( index > 0 ) {
				// Forward
				for ( i=1; i<=index; ++i ) {
					History.forward(queue);
				}
			}
			else if ( index < 0 ) {
				// Backward
				for ( i=-1; i>=index; --i ) {
					History.back(queue);
				}
			}
			else {
				throw new Error('History.go: History.go requires a positive or negative integer passed.');
			}

			// Chain
			return History;
		};


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * Provide Skeleton for HTML4 Browsers
			 */

			// Prepare
			var emptyFunction = function(){};
			History.pushState = History.pushState||emptyFunction;
			History.replaceState = History.replaceState||emptyFunction;
		} // History.emulated.pushState

		// Native pushState Implementation
		else {
			/*
			 * Use native HTML5 History API Implementation
			 */

			/**
			 * History.onPopState(event,extra)
			 * Refresh the Current State
			 */
			History.onPopState = function(event,extra){
				// Prepare
				var stateId = false, newState = false, currentHash, currentState;

				// Reset the double check
				History.doubleCheckComplete();

				// Check for a Hash, and handle apporiatly
				currentHash = History.getHash();
				if ( currentHash ) {
					// Expand Hash
					currentState = History.extractState(currentHash||History.getLocationHref(),true);
					if ( currentState ) {
						// We were able to parse it, it must be a State!
						// Let's forward to replaceState
						//History.debug('History.onPopState: state anchor', currentHash, currentState);
						History.replaceState(currentState.data, currentState.title, currentState.url, false);
					}
					else {
						// Traditional Anchor
						//History.debug('History.onPopState: traditional anchor', currentHash);
						History.Adapter.trigger(window,'anchorchange');
						History.busy(false);
					}

					// We don't care for hashes
					History.expectedStateId = false;
					return false;
				}

				// Ensure
				stateId = History.Adapter.extractEventData('state',event,extra) || false;

				// Fetch State
				if ( stateId ) {
					// Vanilla: Back/forward button was used
					newState = History.getStateById(stateId);
				}
				else if ( History.expectedStateId ) {
					// Vanilla: A new state was pushed, and popstate was called manually
					newState = History.getStateById(History.expectedStateId);
				}
				else {
					// Initial State
					newState = History.extractState(History.getLocationHref());
				}

				// The State did not exist in our store
				if ( !newState ) {
					// Regenerate the State
					newState = History.createStateObject(null,null,History.getLocationHref());
				}

				// Clean
				History.expectedStateId = false;

				// Check if we are the same state
				if ( History.isLastSavedState(newState) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onPopState: no change', newState, History.savedStates);
					History.busy(false);
					return false;
				}

				// Store the State
				History.storeState(newState);
				History.saveState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Fire Our Event
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// Return true
				return true;
			};
			History.Adapter.bind(window,'popstate',History.onPopState);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.pushState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.replaceState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End replaceState closure
				return true;
			};

		} // !History.emulated.pushState


		// ====================================================================
		// Initialise

		/**
		 * Load the Store
		 */
		if ( sessionStorage ) {
			// Fetch
			try {
				History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
			}
			catch ( err ) {
				History.store = {};
			}

			// Normalize
			History.normalizeStore();
		}
		else {
			// Default Load
			History.store = {};
			History.normalizeStore();
		}

		/**
		 * Clear Intervals on exit to prevent memory leaks
		 */
		History.Adapter.bind(window,"unload",History.clearAllIntervals);

		/**
		 * Create the initial State
		 */
		History.saveState(History.storeState(History.extractState(History.getLocationHref(),true)));

		/**
		 * Bind for Saving Store
		 */
		if ( sessionStorage ) {
			// When the page is closed
			History.onUnload = function(){
				// Prepare
				var	currentStore, item, currentStoreString;

				// Fetch
				try {
					currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
				}
				catch ( err ) {
					currentStore = {};
				}

				// Ensure
				currentStore.idToState = currentStore.idToState || {};
				currentStore.urlToId = currentStore.urlToId || {};
				currentStore.stateToId = currentStore.stateToId || {};

				// Sync
				for ( item in History.idToState ) {
					if ( !History.idToState.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.idToState[item] = History.idToState[item];
				}
				for ( item in History.urlToId ) {
					if ( !History.urlToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.urlToId[item] = History.urlToId[item];
				}
				for ( item in History.stateToId ) {
					if ( !History.stateToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.stateToId[item] = History.stateToId[item];
				}

				// Update
				History.store = currentStore;
				History.normalizeStore();

				// In Safari, going into Private Browsing mode causes the
				// Session Storage object to still exist but if you try and use
				// or set any property/function of it it throws the exception
				// "QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to
				// add something to storage that exceeded the quota." infinitely
				// every second.
				currentStoreString = JSON.stringify(currentStore);
				try {
					// Store
					sessionStorage.setItem('History.store', currentStoreString);
				}
				catch (e) {
					if (e.code === DOMException.QUOTA_EXCEEDED_ERR) {
						if (sessionStorage.length) {
							// Workaround for a bug seen on iPads. Sometimes the quota exceeded error comes up and simply
							// removing/resetting the storage can work.
							sessionStorage.removeItem('History.store');
							sessionStorage.setItem('History.store', currentStoreString);
						} else {
							// Otherwise, we're probably private browsing in Safari, so we'll ignore the exception.
						}
					} else {
						throw e;
					}
				}
			};

			// For Internet Explorer
			History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));

			// For Other Browsers
			History.Adapter.bind(window,'beforeunload',History.onUnload);
			History.Adapter.bind(window,'unload',History.onUnload);

			// Both are enabled for consistency
		}

		// Non-Native pushState Implementation
		if ( !History.emulated.pushState ) {
			// Be aware, the following is only for native pushState implementations
			// If you are wanting to include something for all browsers
			// Then include it above this if block

			/**
			 * Setup Safari Fix
			 */
			if ( History.bugs.safariPoll ) {
				History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
			}

			/**
			 * Ensure Cross Browser Compatibility
			 */
			if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
				/**
				 * Fix Safari HashChange Issue
				 */

				// Setup Alias
				History.Adapter.bind(window,'hashchange',function(){
					History.Adapter.trigger(window,'popstate');
				});

				// Initialise Alias
				if ( History.getHash() ) {
					History.Adapter.onDomLoad(function(){
						History.Adapter.trigger(window,'hashchange');
					});
				}
			}

		} // !History.emulated.pushState


	}; // History.initCore

	// Try to Initialise History
	if (!History.options || !History.options.delayInit) {
		History.init();
	}

})(window);


/***/ }),

/***/ "./node_modules/imagesloaded/imagesloaded.js":
/*!***************************************************!*\
  !*** ./node_modules/imagesloaded/imagesloaded.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*!
 * imagesLoaded v5.0.0
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

( function( window, factory ) {
  // universal module definition
  if (  true && module.exports ) {
    // CommonJS
    module.exports = factory( window, __webpack_require__(/*! ev-emitter */ "./node_modules/ev-emitter/ev-emitter.js") );
  } else {
    // browser global
    window.imagesLoaded = factory( window, window.EvEmitter );
  }

} )( typeof window !== 'undefined' ? window : this,
    function factory( window, EvEmitter ) {

let $ = window.jQuery;
let console = window.console;

// -------------------------- helpers -------------------------- //

// turn element or nodeList into an array
function makeArray( obj ) {
  // use object if already an array
  if ( Array.isArray( obj ) ) return obj;

  let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
  // convert nodeList to array
  if ( isArrayLike ) return [ ...obj ];

  // array of single index
  return [ obj ];
}

// -------------------------- imagesLoaded -------------------------- //

/**
 * @param {[Array, Element, NodeList, String]} elem
 * @param {[Object, Function]} options - if function, use as callback
 * @param {Function} onAlways - callback function
 * @returns {ImagesLoaded}
 */
function ImagesLoaded( elem, options, onAlways ) {
  // coerce ImagesLoaded() without new, to be new ImagesLoaded()
  if ( !( this instanceof ImagesLoaded ) ) {
    return new ImagesLoaded( elem, options, onAlways );
  }
  // use elem as selector string
  let queryElem = elem;
  if ( typeof elem == 'string' ) {
    queryElem = document.querySelectorAll( elem );
  }
  // bail if bad element
  if ( !queryElem ) {
    console.error(`Bad element for imagesLoaded ${queryElem || elem}`);
    return;
  }

  this.elements = makeArray( queryElem );
  this.options = {};
  // shift arguments if no options set
  if ( typeof options == 'function' ) {
    onAlways = options;
  } else {
    Object.assign( this.options, options );
  }

  if ( onAlways ) this.on( 'always', onAlways );

  this.getImages();
  // add jQuery Deferred object
  if ( $ ) this.jqDeferred = new $.Deferred();

  // HACK check async to allow time to bind listeners
  setTimeout( this.check.bind( this ) );
}

ImagesLoaded.prototype = Object.create( EvEmitter.prototype );

ImagesLoaded.prototype.getImages = function() {
  this.images = [];

  // filter & find items if we have an item selector
  this.elements.forEach( this.addElementImages, this );
};

const elementNodeTypes = [ 1, 9, 11 ];

/**
 * @param {Node} elem
 */
ImagesLoaded.prototype.addElementImages = function( elem ) {
  // filter siblings
  if ( elem.nodeName === 'IMG' ) {
    this.addImage( elem );
  }
  // get background image on element
  if ( this.options.background === true ) {
    this.addElementBackgroundImages( elem );
  }

  // find children
  // no non-element nodes, #143
  let { nodeType } = elem;
  if ( !nodeType || !elementNodeTypes.includes( nodeType ) ) return;

  let childImgs = elem.querySelectorAll('img');
  // concat childElems to filterFound array
  for ( let img of childImgs ) {
    this.addImage( img );
  }

  // get child background images
  if ( typeof this.options.background == 'string' ) {
    let children = elem.querySelectorAll( this.options.background );
    for ( let child of children ) {
      this.addElementBackgroundImages( child );
    }
  }
};

const reURL = /url\((['"])?(.*?)\1\)/gi;

ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
  let style = getComputedStyle( elem );
  // Firefox returns null if in a hidden iframe https://bugzil.la/548397
  if ( !style ) return;

  // get url inside url("...")
  let matches = reURL.exec( style.backgroundImage );
  while ( matches !== null ) {
    let url = matches && matches[2];
    if ( url ) {
      this.addBackground( url, elem );
    }
    matches = reURL.exec( style.backgroundImage );
  }
};

/**
 * @param {Image} img
 */
ImagesLoaded.prototype.addImage = function( img ) {
  let loadingImage = new LoadingImage( img );
  this.images.push( loadingImage );
};

ImagesLoaded.prototype.addBackground = function( url, elem ) {
  let background = new Background( url, elem );
  this.images.push( background );
};

ImagesLoaded.prototype.check = function() {
  this.progressedCount = 0;
  this.hasAnyBroken = false;
  // complete if no images
  if ( !this.images.length ) {
    this.complete();
    return;
  }

  /* eslint-disable-next-line func-style */
  let onProgress = ( image, elem, message ) => {
    // HACK - Chrome triggers event before object properties have changed. #83
    setTimeout( () => {
      this.progress( image, elem, message );
    } );
  };

  this.images.forEach( function( loadingImage ) {
    loadingImage.once( 'progress', onProgress );
    loadingImage.check();
  } );
};

ImagesLoaded.prototype.progress = function( image, elem, message ) {
  this.progressedCount++;
  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
  // progress event
  this.emitEvent( 'progress', [ this, image, elem ] );
  if ( this.jqDeferred && this.jqDeferred.notify ) {
    this.jqDeferred.notify( this, image );
  }
  // check if completed
  if ( this.progressedCount === this.images.length ) {
    this.complete();
  }

  if ( this.options.debug && console ) {
    console.log( `progress: ${message}`, image, elem );
  }
};

ImagesLoaded.prototype.complete = function() {
  let eventName = this.hasAnyBroken ? 'fail' : 'done';
  this.isComplete = true;
  this.emitEvent( eventName, [ this ] );
  this.emitEvent( 'always', [ this ] );
  if ( this.jqDeferred ) {
    let jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
    this.jqDeferred[ jqMethod ]( this );
  }
};

// --------------------------  -------------------------- //

function LoadingImage( img ) {
  this.img = img;
}

LoadingImage.prototype = Object.create( EvEmitter.prototype );

LoadingImage.prototype.check = function() {
  // If complete is true and browser supports natural sizes,
  // try to check for image status manually.
  let isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    // report based on naturalWidth
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    return;
  }

  // If none of the checks above matched, simulate loading on detached element.
  this.proxyImage = new Image();
  // add crossOrigin attribute. #204
  if ( this.img.crossOrigin ) {
    this.proxyImage.crossOrigin = this.img.crossOrigin;
  }
  this.proxyImage.addEventListener( 'load', this );
  this.proxyImage.addEventListener( 'error', this );
  // bind to image as well for Firefox. #191
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.proxyImage.src = this.img.currentSrc || this.img.src;
};

LoadingImage.prototype.getIsImageComplete = function() {
  // check for non-zero, non-undefined naturalWidth
  // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
  return this.img.complete && this.img.naturalWidth;
};

LoadingImage.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  let { parentNode } = this.img;
  // emit progress with parent <picture> or self <img>
  let elem = parentNode.nodeName === 'PICTURE' ? parentNode : this.img;
  this.emitEvent( 'progress', [ this, elem, message ] );
};

// ----- events ----- //

// trigger specified handler for event type
LoadingImage.prototype.handleEvent = function( event ) {
  let method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

LoadingImage.prototype.onload = function() {
  this.confirm( true, 'onload' );
  this.unbindEvents();
};

LoadingImage.prototype.onerror = function() {
  this.confirm( false, 'onerror' );
  this.unbindEvents();
};

LoadingImage.prototype.unbindEvents = function() {
  this.proxyImage.removeEventListener( 'load', this );
  this.proxyImage.removeEventListener( 'error', this );
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

// -------------------------- Background -------------------------- //

function Background( url, element ) {
  this.url = url;
  this.element = element;
  this.img = new Image();
}

// inherit LoadingImage prototype
Background.prototype = Object.create( LoadingImage.prototype );

Background.prototype.check = function() {
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.img.src = this.url;
  // check if image is already complete
  let isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    this.unbindEvents();
  }
};

Background.prototype.unbindEvents = function() {
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

Background.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  this.emitEvent( 'progress', [ this, this.element, message ] );
};

// -------------------------- jQuery -------------------------- //

ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
  jQuery = jQuery || window.jQuery;
  if ( !jQuery ) return;

  // set local variable
  $ = jQuery;
  // $().imagesLoaded()
  $.fn.imagesLoaded = function( options, onAlways ) {
    let instance = new ImagesLoaded( this, options, onAlways );
    return instance.jqDeferred.promise( $( this ) );
  };
};
// try making plugin
ImagesLoaded.makeJQueryPlugin();

// --------------------------  -------------------------- //

return ImagesLoaded;

} );


/***/ }),

/***/ "./node_modules/is-finite/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-finite/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


module.exports = Number.isFinite || function (value) {
	return !(typeof value !== 'number' || value !== value || value === Infinity || value === -Infinity);
};


/***/ }),

/***/ "./node_modules/is-integer/index.js":
/*!******************************************!*\
  !*** ./node_modules/is-integer/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/paulmillr/es6-shim
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isinteger
var isFinite = __webpack_require__(/*! is-finite */ "./node_modules/is-finite/index.js");
module.exports = Number.isInteger || function(val) {
  return typeof val === "number" &&
    isFinite(val) &&
    Math.floor(val) === val;
};


/***/ }),

/***/ "./node_modules/is-valid-month/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-valid-month/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isInteger = __webpack_require__(/*! is-integer */ "./node_modules/is-integer/index.js")

module.exports = function isValidMonth (month) {
  if (typeof month !== 'number' || !isInteger(month)) return false
  return month >= 1 && month <= 12
}


/***/ }),

/***/ "./node_modules/jquery-revealer/jquery.revealer.js":
/*!*********************************************************!*\
  !*** ./node_modules/jquery-revealer/jquery.revealer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Revealer 3.0.0
 *
 * Copyright 2021, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
(function($){
  // check for trend event (make sure jquery.trend is included)
  if (typeof $.event.special.trend !== "object") {
    console.warn("Please make sure jquery.trend is included! Otherwise revealer won't work.");
  }

  // Simple requestAnimationFrame polyfill
  var raf = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function(fn) { window.setTimeout(fn, 1000/60); }


  // Public API
  var methods = {
    isVisible: function(el) {
      return !!el.data("revealer-visible");
    },

    show: function(el, force) {
      // Check state
      if (methods.isVisible(el)) {
        el.removeClass("animating animating-in");
        el.off("revealer-animating revealer-show");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", true);
      el.off("trend");

      if (force) {
        el.addClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-show");
        });
        return;
      }

      raf(function(){
        // Start animation state transition
        el.addClass("animating animating-in");
        el.trigger("revealer-animating");

        raf(function(){
          el.addClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in");
            el.trigger("revealer-show");
          });
        });
      });
    },

    hide: function(el, force) {
      // Check state
      if (!methods.isVisible(el)) {
        el.removeClass("animating animating-out visible");
        el.off("revealer-animating revealer-hide");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", false);
      el.off("trend");

      if (force) {
        el.removeClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-hide");
        });
        return;
      }

      raf(function(){
        el.addClass("animating animating-out");
        el.trigger("revealer-animating");

        raf(function(){
          el.removeClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in animating-out");
            el.trigger("revealer-hide");
          });
        });
      });
    },

    toggle: function(el, force) {
      if (methods.isVisible(el)) {
        methods.hide(el, force);
      } else {
        methods.show(el, force);
      }
    }
  };

  // jQuery plugin
  $.fn.revealer = function(method, force) {
    // Get action
    var action = methods[method || "toggle"];
    if (!action) return this;

    // Run action
    if (method === "isVisible") {
      return action(this);
    }

    return this.each(function(){
      action($(this), force);
    });
  };
})(jQuery);


/***/ }),

/***/ "./node_modules/jquery-trend/jquery.trend.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery-trend/jquery.trend.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Trend 1.0.0
 *
 * Fail-safe TransitionEnd event for jQuery.
 *
 * Adds a new "trend" event that can be used in browsers that don't
 * support "transitionend".
 *
 * NOTE: Only supports being bound with "jQuery.one".
 *
 * Copyright 2021, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
;(function($){

  // Prefixed transitionend event names
  var transitionEndEvents =
    "webkitTransitionEnd " +
    "otransitionend " +
    "oTransitionEnd " +
    "msTransitionEnd " +
    "transitionend";

  // Prefixed transition duration property names
  var transitionDurationProperties = [
    "transition-duration",
    "-moz-transition-duration",
    "-webkit-transition-duration",
    "-ms-transition-duration",
    "-o-transition-duration",
    "-khtml-transition-duration"
  ];

  // Prefixed transition delay property names
  var transitionDelayProperties = [
    "transition-delay",
    "-moz-transition-delay",
    "-webkit-transition-delay",
    "-ms-transition-delay",
    "-o-transition-delay",
    "-khtml-transition-delay"
  ];

  // Parses a CSS time value into milliseconds.
  var parseTime = function(s) {
    s = s.replace(/\s/, "");
    var v = window.parseFloat(s);

    return s.match(/[^m]s$/i)
      ? v * 1000
      : v;
  };

  // Parses the longest time unit found in a series of CSS properties.
  // Returns a value in milliseconds.
  var parseProperties = function(el, properties) {
    var duration = 0;

    for (var i = 0; i < properties.length; i++) {
      // Get raw CSS value
      var value = el.css(properties[i]);
      if (!value) continue;

      // Multiple transitions--pick the longest
      if (value.indexOf(",") !== -1) {
        var values = value.split(",");
        var durations = (function(){
          var results = [];
          for (var i = 0; i < values.length; i++) {
            var duration = parseTime(values[i]);
            results.push(duration);
          }
          return results;
        })();

        duration = Math.max.apply(Math, durations);
      }

      // Single transition
      else {
        duration = parseTime(value);
      }

      // Accept first vaue
      break;
    }

    return duration;
  };

  $.event.special.trend = {
    // Triggers an event handler when an element is done transitioning.
    //
    // Handles browsers that don't support transitionend by adding a
    // timeout with the transition duration.
    add: function(handleObj) {
      var el = $(this);
      var fired = false;

      // Mark element as being in transition
      el.data("trend", true);

      // Calculate a fallback duration. + 20 because some browsers fire
      // timeouts faster than transitionend.
      var time =
        parseProperties(el, transitionDurationProperties) +
        parseProperties(el, transitionDelayProperties) +
        20;

      var cb = function(e) {
        // transitionend events can be sent for each property. Let's just
        // skip all but the first. Also handles the timeout callback.
        if (fired) return;

        // Child elements that also have transitions can be fired before we
        // complete. This will catch and ignore those. Unfortunately, we'll
        // have to rely on the timeout in these cases.
        if (e && e.srcElement !== el[0]) return;

        // Mark element has not being in transition
        el.data("trend", false);

        // Callback
        fired = true;
        if (handleObj.handler) handleObj.handler();
      };

      el.one(transitionEndEvents, cb);
      el.data("trend-timeout", window.setTimeout(cb, time));
    },

    remove: function(handleObj) {
      var el = $(this);
      el.off(transitionEndEvents);
      window.clearTimeout(el.data("trend-timeout"));
    }
  };

})(jQuery);


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.min.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/dist/jquery.min.js ***!
  \************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery v3.7.1 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict"; true&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(ie,e){"use strict";var oe=[],r=Object.getPrototypeOf,ae=oe.slice,g=oe.flat?function(e){return oe.flat.call(e)}:function(e){return oe.concat.apply([],e)},s=oe.push,se=oe.indexOf,n={},i=n.toString,ue=n.hasOwnProperty,o=ue.toString,a=o.call(Object),le={},v=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType&&"function"!=typeof e.item},y=function(e){return null!=e&&e===e.window},C=ie.document,u={type:!0,src:!0,nonce:!0,noModule:!0};function m(e,t,n){var r,i,o=(n=n||C).createElement("script");if(o.text=e,t)for(r in u)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[i.call(e)]||"object":typeof e}var t="3.7.1",l=/HTML$/i,ce=function(e,t){return new ce.fn.init(e,t)};function c(e){var t=!!e&&"length"in e&&e.length,n=x(e);return!v(e)&&!y(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}function fe(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}ce.fn=ce.prototype={jquery:t,constructor:ce,length:0,toArray:function(){return ae.call(this)},get:function(e){return null==e?ae.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=ce.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return ce.each(this,e)},map:function(n){return this.pushStack(ce.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(ae.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(ce.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(ce.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:s,sort:oe.sort,splice:oe.splice},ce.extend=ce.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||v(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(ce.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||ce.isPlainObject(n)?n:{},i=!1,a[t]=ce.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},ce.extend({expando:"jQuery"+(t+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==i.call(e))&&(!(t=r(e))||"function"==typeof(n=ue.call(t,"constructor")&&t.constructor)&&o.call(n)===a)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){m(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(c(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},text:function(e){var t,n="",r=0,i=e.nodeType;if(!i)while(t=e[r++])n+=ce.text(t);return 1===i||11===i?e.textContent:9===i?e.documentElement.textContent:3===i||4===i?e.nodeValue:n},makeArray:function(e,t){var n=t||[];return null!=e&&(c(Object(e))?ce.merge(n,"string"==typeof e?[e]:e):s.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:se.call(t,e,n)},isXMLDoc:function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!l.test(t||n&&n.nodeName||"HTML")},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(c(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:le}),"function"==typeof Symbol&&(ce.fn[Symbol.iterator]=oe[Symbol.iterator]),ce.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var pe=oe.pop,de=oe.sort,he=oe.splice,ge="[\\x20\\t\\r\\n\\f]",ve=new RegExp("^"+ge+"+|((?:^|[^\\\\])(?:\\\\.)*)"+ge+"+$","g");ce.contains=function(e,t){var n=t&&t.parentNode;return e===n||!(!n||1!==n.nodeType||!(e.contains?e.contains(n):e.compareDocumentPosition&&16&e.compareDocumentPosition(n)))};var f=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;function p(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e}ce.escapeSelector=function(e){return(e+"").replace(f,p)};var ye=C,me=s;!function(){var e,b,w,o,a,T,r,C,d,i,k=me,S=ce.expando,E=0,n=0,s=W(),c=W(),u=W(),h=W(),l=function(e,t){return e===t&&(a=!0),0},f="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",t="(?:\\\\[\\da-fA-F]{1,6}"+ge+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",p="\\["+ge+"*("+t+")(?:"+ge+"*([*^$|!~]?=)"+ge+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+t+"))|)"+ge+"*\\]",g=":("+t+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+p+")*)|.*)\\)|)",v=new RegExp(ge+"+","g"),y=new RegExp("^"+ge+"*,"+ge+"*"),m=new RegExp("^"+ge+"*([>+~]|"+ge+")"+ge+"*"),x=new RegExp(ge+"|>"),j=new RegExp(g),A=new RegExp("^"+t+"$"),D={ID:new RegExp("^#("+t+")"),CLASS:new RegExp("^\\.("+t+")"),TAG:new RegExp("^("+t+"|[*])"),ATTR:new RegExp("^"+p),PSEUDO:new RegExp("^"+g),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+ge+"*(even|odd|(([+-]|)(\\d*)n|)"+ge+"*(?:([+-]|)"+ge+"*(\\d+)|))"+ge+"*\\)|)","i"),bool:new RegExp("^(?:"+f+")$","i"),needsContext:new RegExp("^"+ge+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+ge+"*((?:-\\d)?\\d*)"+ge+"*\\)|)(?=[^-]|$)","i")},N=/^(?:input|select|textarea|button)$/i,q=/^h\d$/i,L=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,H=/[+~]/,O=new RegExp("\\\\[\\da-fA-F]{1,6}"+ge+"?|\\\\([^\\r\\n\\f])","g"),P=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},M=function(){V()},R=J(function(e){return!0===e.disabled&&fe(e,"fieldset")},{dir:"parentNode",next:"legend"});try{k.apply(oe=ae.call(ye.childNodes),ye.childNodes),oe[ye.childNodes.length].nodeType}catch(e){k={apply:function(e,t){me.apply(e,ae.call(t))},call:function(e){me.apply(e,ae.call(arguments,1))}}}function I(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(V(e),e=e||T,C)){if(11!==p&&(u=L.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return k.call(n,a),n}else if(f&&(a=f.getElementById(i))&&I.contains(e,a)&&a.id===i)return k.call(n,a),n}else{if(u[2])return k.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&e.getElementsByClassName)return k.apply(n,e.getElementsByClassName(i)),n}if(!(h[t+" "]||d&&d.test(t))){if(c=t,f=e,1===p&&(x.test(t)||m.test(t))){(f=H.test(t)&&U(e.parentNode)||e)==e&&le.scope||((s=e.getAttribute("id"))?s=ce.escapeSelector(s):e.setAttribute("id",s=S)),o=(l=Y(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+Q(l[o]);c=l.join(",")}try{return k.apply(n,f.querySelectorAll(c)),n}catch(e){h(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return re(t.replace(ve,"$1"),e,n,r)}function W(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function F(e){return e[S]=!0,e}function $(e){var t=T.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function B(t){return function(e){return fe(e,"input")&&e.type===t}}function _(t){return function(e){return(fe(e,"input")||fe(e,"button"))&&e.type===t}}function z(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&R(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function X(a){return F(function(o){return o=+o,F(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function U(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}function V(e){var t,n=e?e.ownerDocument||e:ye;return n!=T&&9===n.nodeType&&n.documentElement&&(r=(T=n).documentElement,C=!ce.isXMLDoc(T),i=r.matches||r.webkitMatchesSelector||r.msMatchesSelector,r.msMatchesSelector&&ye!=T&&(t=T.defaultView)&&t.top!==t&&t.addEventListener("unload",M),le.getById=$(function(e){return r.appendChild(e).id=ce.expando,!T.getElementsByName||!T.getElementsByName(ce.expando).length}),le.disconnectedMatch=$(function(e){return i.call(e,"*")}),le.scope=$(function(){return T.querySelectorAll(":scope")}),le.cssHas=$(function(){try{return T.querySelector(":has(*,:jqfake)"),!1}catch(e){return!0}}),le.getById?(b.filter.ID=function(e){var t=e.replace(O,P);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&C){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(O,P);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&C){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):t.querySelectorAll(e)},b.find.CLASS=function(e,t){if("undefined"!=typeof t.getElementsByClassName&&C)return t.getElementsByClassName(e)},d=[],$(function(e){var t;r.appendChild(e).innerHTML="<a id='"+S+"' href='' disabled='disabled'></a><select id='"+S+"-\r\\' disabled='disabled'><option selected=''></option></select>",e.querySelectorAll("[selected]").length||d.push("\\["+ge+"*(?:value|"+f+")"),e.querySelectorAll("[id~="+S+"-]").length||d.push("~="),e.querySelectorAll("a#"+S+"+*").length||d.push(".#.+[+~]"),e.querySelectorAll(":checked").length||d.push(":checked"),(t=T.createElement("input")).setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),r.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&d.push(":enabled",":disabled"),(t=T.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||d.push("\\["+ge+"*name"+ge+"*="+ge+"*(?:''|\"\")")}),le.cssHas||d.push(":has"),d=d.length&&new RegExp(d.join("|")),l=function(e,t){if(e===t)return a=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!le.sortDetached&&t.compareDocumentPosition(e)===n?e===T||e.ownerDocument==ye&&I.contains(ye,e)?-1:t===T||t.ownerDocument==ye&&I.contains(ye,t)?1:o?se.call(o,e)-se.call(o,t):0:4&n?-1:1)}),T}for(e in I.matches=function(e,t){return I(e,null,null,t)},I.matchesSelector=function(e,t){if(V(e),C&&!h[t+" "]&&(!d||!d.test(t)))try{var n=i.call(e,t);if(n||le.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){h(t,!0)}return 0<I(t,T,null,[e]).length},I.contains=function(e,t){return(e.ownerDocument||e)!=T&&V(e),ce.contains(e,t)},I.attr=function(e,t){(e.ownerDocument||e)!=T&&V(e);var n=b.attrHandle[t.toLowerCase()],r=n&&ue.call(b.attrHandle,t.toLowerCase())?n(e,t,!C):void 0;return void 0!==r?r:e.getAttribute(t)},I.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},ce.uniqueSort=function(e){var t,n=[],r=0,i=0;if(a=!le.sortStable,o=!le.sortStable&&ae.call(e,0),de.call(e,l),a){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)he.call(e,n[r],1)}return o=null,e},ce.fn.uniqueSort=function(){return this.pushStack(ce.uniqueSort(ae.apply(this)))},(b=ce.expr={cacheLength:50,createPseudo:F,match:D,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(O,P),e[3]=(e[3]||e[4]||e[5]||"").replace(O,P),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||I.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&I.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return D.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&j.test(n)&&(t=Y(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(O,P).toLowerCase();return"*"===e?function(){return!0}:function(e){return fe(e,t)}},CLASS:function(e){var t=s[e+" "];return t||(t=new RegExp("(^|"+ge+")"+e+"("+ge+"|$)"))&&s(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=I.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(v," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(d,e,t,h,g){var v="nth"!==d.slice(0,3),y="last"!==d.slice(-4),m="of-type"===e;return 1===h&&0===g?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u=v!==y?"nextSibling":"previousSibling",l=e.parentNode,c=m&&e.nodeName.toLowerCase(),f=!n&&!m,p=!1;if(l){if(v){while(u){o=e;while(o=o[u])if(m?fe(o,c):1===o.nodeType)return!1;s=u="only"===d&&!s&&"nextSibling"}return!0}if(s=[y?l.firstChild:l.lastChild],y&&f){p=(a=(r=(i=l[S]||(l[S]={}))[d]||[])[0]===E&&r[1])&&r[2],o=a&&l.childNodes[a];while(o=++a&&o&&o[u]||(p=a=0)||s.pop())if(1===o.nodeType&&++p&&o===e){i[d]=[E,a,p];break}}else if(f&&(p=a=(r=(i=e[S]||(e[S]={}))[d]||[])[0]===E&&r[1]),!1===p)while(o=++a&&o&&o[u]||(p=a=0)||s.pop())if((m?fe(o,c):1===o.nodeType)&&++p&&(f&&((i=o[S]||(o[S]={}))[d]=[E,p]),o===e))break;return(p-=g)===h||p%h==0&&0<=p/h}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||I.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?F(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=se.call(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:F(function(e){var r=[],i=[],s=ne(e.replace(ve,"$1"));return s[S]?F(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:F(function(t){return function(e){return 0<I(t,e).length}}),contains:F(function(t){return t=t.replace(O,P),function(e){return-1<(e.textContent||ce.text(e)).indexOf(t)}}),lang:F(function(n){return A.test(n||"")||I.error("unsupported lang: "+n),n=n.replace(O,P).toLowerCase(),function(e){var t;do{if(t=C?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=ie.location&&ie.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===r},focus:function(e){return e===function(){try{return T.activeElement}catch(e){}}()&&T.hasFocus()&&!!(e.type||e.href||~e.tabIndex)},enabled:z(!1),disabled:z(!0),checked:function(e){return fe(e,"input")&&!!e.checked||fe(e,"option")&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return q.test(e.nodeName)},input:function(e){return N.test(e.nodeName)},button:function(e){return fe(e,"input")&&"button"===e.type||fe(e,"button")},text:function(e){var t;return fe(e,"input")&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:X(function(){return[0]}),last:X(function(e,t){return[t-1]}),eq:X(function(e,t,n){return[n<0?n+t:n]}),even:X(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:X(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:X(function(e,t,n){var r;for(r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:X(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=B(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=_(e);function G(){}function Y(e,t){var n,r,i,o,a,s,u,l=c[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=y.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=m.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(ve," ")}),a=a.slice(n.length)),b.filter)!(r=D[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?I.error(e):c(e,s).slice(0)}function Q(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function J(a,e,t){var s=e.dir,u=e.next,l=u||s,c=t&&"parentNode"===l,f=n++;return e.first?function(e,t,n){while(e=e[s])if(1===e.nodeType||c)return a(e,t,n);return!1}:function(e,t,n){var r,i,o=[E,f];if(n){while(e=e[s])if((1===e.nodeType||c)&&a(e,t,n))return!0}else while(e=e[s])if(1===e.nodeType||c)if(i=e[S]||(e[S]={}),u&&fe(e,u))e=e[s]||e;else{if((r=i[l])&&r[0]===E&&r[1]===f)return o[2]=r[2];if((i[l]=o)[2]=a(e,t,n))return!0}return!1}}function K(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Z(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function ee(d,h,g,v,y,e){return v&&!v[S]&&(v=ee(v)),y&&!y[S]&&(y=ee(y,e)),F(function(e,t,n,r){var i,o,a,s,u=[],l=[],c=t.length,f=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)I(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),p=!d||!e&&h?f:Z(f,u,d,n,r);if(g?g(p,s=y||(e?d:c||v)?[]:t,n,r):s=p,v){i=Z(s,l),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(s[l[o]]=!(p[l[o]]=a))}if(e){if(y||d){if(y){i=[],o=s.length;while(o--)(a=s[o])&&i.push(p[o]=a);y(null,s=[],i,r)}o=s.length;while(o--)(a=s[o])&&-1<(i=y?se.call(e,a):u[o])&&(e[i]=!(t[i]=a))}}else s=Z(s===t?s.splice(c,s.length):s),y?y(null,t,s,r):k.apply(t,s)})}function te(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=J(function(e){return e===i},a,!0),l=J(function(e){return-1<se.call(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!=w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[J(K(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return ee(1<s&&K(c),1<s&&Q(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(ve,"$1"),t,s<n&&te(e.slice(s,n)),n<r&&te(e=e.slice(n)),n<r&&Q(e))}c.push(t)}return K(c)}function ne(e,t){var n,v,y,m,x,r,i=[],o=[],a=u[e+" "];if(!a){t||(t=Y(e)),n=t.length;while(n--)(a=te(t[n]))[S]?i.push(a):o.push(a);(a=u(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=E+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==T||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==T||(V(o),n=!C);while(s=v[a++])if(s(o,t||T,n)){k.call(r,o);break}i&&(E=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=pe.call(r));f=Z(f)}k.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&ce.uniqueSort(r)}return i&&(E=h,w=p),c},m?F(r):r))).selector=e}return a}function re(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&Y(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&C&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(O,P),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=D.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(O,P),H.test(o[0].type)&&U(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&Q(o)))return k.apply(n,r),n;break}}}return(l||ne(e,c))(r,t,!C,n,!t||H.test(e)&&U(t.parentNode)||t),n}G.prototype=b.filters=b.pseudos,b.setFilters=new G,le.sortStable=S.split("").sort(l).join("")===S,V(),le.sortDetached=$(function(e){return 1&e.compareDocumentPosition(T.createElement("fieldset"))}),ce.find=I,ce.expr[":"]=ce.expr.pseudos,ce.unique=ce.uniqueSort,I.compile=ne,I.select=re,I.setDocument=V,I.tokenize=Y,I.escape=ce.escapeSelector,I.getText=ce.text,I.isXML=ce.isXMLDoc,I.selectors=ce.expr,I.support=ce.support,I.uniqueSort=ce.uniqueSort}();var d=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&ce(e).is(n))break;r.push(e)}return r},h=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},b=ce.expr.match.needsContext,w=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function T(e,n,r){return v(n)?ce.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?ce.grep(e,function(e){return e===n!==r}):"string"!=typeof n?ce.grep(e,function(e){return-1<se.call(n,e)!==r}):ce.filter(n,e,r)}ce.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?ce.find.matchesSelector(r,e)?[r]:[]:ce.find.matches(e,ce.grep(t,function(e){return 1===e.nodeType}))},ce.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(ce(e).filter(function(){for(t=0;t<r;t++)if(ce.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)ce.find(e,i[t],n);return 1<r?ce.uniqueSort(n):n},filter:function(e){return this.pushStack(T(this,e||[],!1))},not:function(e){return this.pushStack(T(this,e||[],!0))},is:function(e){return!!T(this,"string"==typeof e&&b.test(e)?ce(e):e||[],!1).length}});var k,S=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(ce.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||k,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:S.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof ce?t[0]:t,ce.merge(this,ce.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:C,!0)),w.test(r[1])&&ce.isPlainObject(t))for(r in t)v(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=C.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):v(e)?void 0!==n.ready?n.ready(e):e(ce):ce.makeArray(e,this)}).prototype=ce.fn,k=ce(C);var E=/^(?:parents|prev(?:Until|All))/,j={children:!0,contents:!0,next:!0,prev:!0};function A(e,t){while((e=e[t])&&1!==e.nodeType);return e}ce.fn.extend({has:function(e){var t=ce(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(ce.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&ce(e);if(!b.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&ce.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?ce.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?se.call(ce(e),this[0]):se.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(ce.uniqueSort(ce.merge(this.get(),ce(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),ce.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return d(e,"parentNode")},parentsUntil:function(e,t,n){return d(e,"parentNode",n)},next:function(e){return A(e,"nextSibling")},prev:function(e){return A(e,"previousSibling")},nextAll:function(e){return d(e,"nextSibling")},prevAll:function(e){return d(e,"previousSibling")},nextUntil:function(e,t,n){return d(e,"nextSibling",n)},prevUntil:function(e,t,n){return d(e,"previousSibling",n)},siblings:function(e){return h((e.parentNode||{}).firstChild,e)},children:function(e){return h(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(fe(e,"template")&&(e=e.content||e),ce.merge([],e.childNodes))}},function(r,i){ce.fn[r]=function(e,t){var n=ce.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=ce.filter(t,n)),1<this.length&&(j[r]||ce.uniqueSort(n),E.test(r)&&n.reverse()),this.pushStack(n)}});var D=/[^\x20\t\r\n\f]+/g;function N(e){return e}function q(e){throw e}function L(e,t,n,r){var i;try{e&&v(i=e.promise)?i.call(e).done(t).fail(n):e&&v(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}ce.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},ce.each(e.match(D)||[],function(e,t){n[t]=!0}),n):ce.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){ce.each(e,function(e,t){v(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==x(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return ce.each(arguments,function(e,t){var n;while(-1<(n=ce.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<ce.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},ce.extend({Deferred:function(e){var o=[["notify","progress",ce.Callbacks("memory"),ce.Callbacks("memory"),2],["resolve","done",ce.Callbacks("once memory"),ce.Callbacks("once memory"),0,"resolved"],["reject","fail",ce.Callbacks("once memory"),ce.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return ce.Deferred(function(r){ce.each(o,function(e,t){var n=v(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&v(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,v(t)?s?t.call(e,l(u,o,N,s),l(u,o,q,s)):(u++,t.call(e,l(u,o,N,s),l(u,o,q,s),l(u,o,N,o.notifyWith))):(a!==N&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){ce.Deferred.exceptionHook&&ce.Deferred.exceptionHook(e,t.error),u<=i+1&&(a!==q&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(ce.Deferred.getErrorHook?t.error=ce.Deferred.getErrorHook():ce.Deferred.getStackHook&&(t.error=ce.Deferred.getStackHook()),ie.setTimeout(t))}}return ce.Deferred(function(e){o[0][3].add(l(0,e,v(r)?r:N,e.notifyWith)),o[1][3].add(l(0,e,v(t)?t:N)),o[2][3].add(l(0,e,v(n)?n:q))}).promise()},promise:function(e){return null!=e?ce.extend(e,a):a}},s={};return ce.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=ae.call(arguments),o=ce.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?ae.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(L(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||v(i[t]&&i[t].then)))return o.then();while(t--)L(i[t],a(t),o.reject);return o.promise()}});var H=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;ce.Deferred.exceptionHook=function(e,t){ie.console&&ie.console.warn&&e&&H.test(e.name)&&ie.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},ce.readyException=function(e){ie.setTimeout(function(){throw e})};var O=ce.Deferred();function P(){C.removeEventListener("DOMContentLoaded",P),ie.removeEventListener("load",P),ce.ready()}ce.fn.ready=function(e){return O.then(e)["catch"](function(e){ce.readyException(e)}),this},ce.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--ce.readyWait:ce.isReady)||(ce.isReady=!0)!==e&&0<--ce.readyWait||O.resolveWith(C,[ce])}}),ce.ready.then=O.then,"complete"===C.readyState||"loading"!==C.readyState&&!C.documentElement.doScroll?ie.setTimeout(ce.ready):(C.addEventListener("DOMContentLoaded",P),ie.addEventListener("load",P));var M=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===x(n))for(s in i=!0,n)M(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,v(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(ce(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},R=/^-ms-/,I=/-([a-z])/g;function W(e,t){return t.toUpperCase()}function F(e){return e.replace(R,"ms-").replace(I,W)}var $=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function B(){this.expando=ce.expando+B.uid++}B.uid=1,B.prototype={cache:function(e){var t=e[this.expando];return t||(t={},$(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[F(t)]=n;else for(r in t)i[F(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][F(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(F):(t=F(t))in r?[t]:t.match(D)||[]).length;while(n--)delete r[t[n]]}(void 0===t||ce.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!ce.isEmptyObject(t)}};var _=new B,z=new B,X=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,U=/[A-Z]/g;function V(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(U,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:X.test(i)?JSON.parse(i):i)}catch(e){}z.set(e,t,n)}else n=void 0;return n}ce.extend({hasData:function(e){return z.hasData(e)||_.hasData(e)},data:function(e,t,n){return z.access(e,t,n)},removeData:function(e,t){z.remove(e,t)},_data:function(e,t,n){return _.access(e,t,n)},_removeData:function(e,t){_.remove(e,t)}}),ce.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=z.get(o),1===o.nodeType&&!_.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=F(r.slice(5)),V(o,r,i[r]));_.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){z.set(this,n)}):M(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=z.get(o,n))?t:void 0!==(t=V(o,n))?t:void 0;this.each(function(){z.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){z.remove(this,e)})}}),ce.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=_.get(e,t),n&&(!r||Array.isArray(n)?r=_.access(e,t,ce.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=ce.queue(e,t),r=n.length,i=n.shift(),o=ce._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){ce.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return _.get(e,n)||_.access(e,n,{empty:ce.Callbacks("once memory").add(function(){_.remove(e,[t+"queue",n])})})}}),ce.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?ce.queue(this[0],t):void 0===n?this:this.each(function(){var e=ce.queue(this,t,n);ce._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&ce.dequeue(this,t)})},dequeue:function(e){return this.each(function(){ce.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=ce.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=_.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var G=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,Y=new RegExp("^(?:([+-])=|)("+G+")([a-z%]*)$","i"),Q=["Top","Right","Bottom","Left"],J=C.documentElement,K=function(e){return ce.contains(e.ownerDocument,e)},Z={composed:!0};J.getRootNode&&(K=function(e){return ce.contains(e.ownerDocument,e)||e.getRootNode(Z)===e.ownerDocument});var ee=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&K(e)&&"none"===ce.css(e,"display")};function te(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return ce.css(e,t,"")},u=s(),l=n&&n[3]||(ce.cssNumber[t]?"":"px"),c=e.nodeType&&(ce.cssNumber[t]||"px"!==l&&+u)&&Y.exec(ce.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)ce.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,ce.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ne={};function re(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=_.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ee(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ne[s])||(o=a.body.appendChild(a.createElement(s)),u=ce.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ne[s]=u)))):"none"!==n&&(l[c]="none",_.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}ce.fn.extend({show:function(){return re(this,!0)},hide:function(){return re(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ee(this)?ce(this).show():ce(this).hide()})}});var xe,be,we=/^(?:checkbox|radio)$/i,Te=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,Ce=/^$|^module$|\/(?:java|ecma)script/i;xe=C.createDocumentFragment().appendChild(C.createElement("div")),(be=C.createElement("input")).setAttribute("type","radio"),be.setAttribute("checked","checked"),be.setAttribute("name","t"),xe.appendChild(be),le.checkClone=xe.cloneNode(!0).cloneNode(!0).lastChild.checked,xe.innerHTML="<textarea>x</textarea>",le.noCloneChecked=!!xe.cloneNode(!0).lastChild.defaultValue,xe.innerHTML="<option></option>",le.option=!!xe.lastChild;var ke={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function Se(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&fe(e,t)?ce.merge([e],n):n}function Ee(e,t){for(var n=0,r=e.length;n<r;n++)_.set(e[n],"globalEval",!t||_.get(t[n],"globalEval"))}ke.tbody=ke.tfoot=ke.colgroup=ke.caption=ke.thead,ke.th=ke.td,le.option||(ke.optgroup=ke.option=[1,"<select multiple='multiple'>","</select>"]);var je=/<|&#?\w+;/;function Ae(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===x(o))ce.merge(p,o.nodeType?[o]:o);else if(je.test(o)){a=a||f.appendChild(t.createElement("div")),s=(Te.exec(o)||["",""])[1].toLowerCase(),u=ke[s]||ke._default,a.innerHTML=u[1]+ce.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;ce.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<ce.inArray(o,r))i&&i.push(o);else if(l=K(o),a=Se(f.appendChild(o),"script"),l&&Ee(a),n){c=0;while(o=a[c++])Ce.test(o.type||"")&&n.push(o)}return f}var De=/^([^.]*)(?:\.(.+)|)/;function Ne(){return!0}function qe(){return!1}function Le(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Le(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=qe;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return ce().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=ce.guid++)),e.each(function(){ce.event.add(this,t,i,r,n)})}function He(e,r,t){t?(_.set(e,r,!1),ce.event.add(e,r,{namespace:!1,handler:function(e){var t,n=_.get(this,r);if(1&e.isTrigger&&this[r]){if(n)(ce.event.special[r]||{}).delegateType&&e.stopPropagation();else if(n=ae.call(arguments),_.set(this,r,n),this[r](),t=_.get(this,r),_.set(this,r,!1),n!==t)return e.stopImmediatePropagation(),e.preventDefault(),t}else n&&(_.set(this,r,ce.event.trigger(n[0],n.slice(1),this)),e.stopPropagation(),e.isImmediatePropagationStopped=Ne)}})):void 0===_.get(e,r)&&ce.event.add(e,r,Ne)}ce.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=_.get(t);if($(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&ce.find.matchesSelector(J,i),n.guid||(n.guid=ce.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof ce&&ce.event.triggered!==e.type?ce.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(D)||[""]).length;while(l--)d=g=(s=De.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=ce.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=ce.event.special[d]||{},c=ce.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&ce.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),ce.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=_.hasData(e)&&_.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(D)||[""]).length;while(l--)if(d=g=(s=De.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=ce.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||ce.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)ce.event.remove(e,d+t[l],n,r,!0);ce.isEmptyObject(u)&&_.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=ce.event.fix(e),l=(_.get(this,"events")||Object.create(null))[u.type]||[],c=ce.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=ce.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((ce.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<ce(i,this).index(l):ce.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(ce.Event.prototype,t,{enumerable:!0,configurable:!0,get:v(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[ce.expando]?e:new ce.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return we.test(t.type)&&t.click&&fe(t,"input")&&He(t,"click",!0),!1},trigger:function(e){var t=this||e;return we.test(t.type)&&t.click&&fe(t,"input")&&He(t,"click"),!0},_default:function(e){var t=e.target;return we.test(t.type)&&t.click&&fe(t,"input")&&_.get(t,"click")||fe(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},ce.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},ce.Event=function(e,t){if(!(this instanceof ce.Event))return new ce.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ne:qe,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&ce.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[ce.expando]=!0},ce.Event.prototype={constructor:ce.Event,isDefaultPrevented:qe,isPropagationStopped:qe,isImmediatePropagationStopped:qe,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ne,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ne,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ne,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},ce.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},ce.event.addProp),ce.each({focus:"focusin",blur:"focusout"},function(r,i){function o(e){if(C.documentMode){var t=_.get(this,"handle"),n=ce.event.fix(e);n.type="focusin"===e.type?"focus":"blur",n.isSimulated=!0,t(e),n.target===n.currentTarget&&t(n)}else ce.event.simulate(i,e.target,ce.event.fix(e))}ce.event.special[r]={setup:function(){var e;if(He(this,r,!0),!C.documentMode)return!1;(e=_.get(this,i))||this.addEventListener(i,o),_.set(this,i,(e||0)+1)},trigger:function(){return He(this,r),!0},teardown:function(){var e;if(!C.documentMode)return!1;(e=_.get(this,i)-1)?_.set(this,i,e):(this.removeEventListener(i,o),_.remove(this,i))},_default:function(e){return _.get(e.target,r)},delegateType:i},ce.event.special[i]={setup:function(){var e=this.ownerDocument||this.document||this,t=C.documentMode?this:e,n=_.get(t,i);n||(C.documentMode?this.addEventListener(i,o):e.addEventListener(r,o,!0)),_.set(t,i,(n||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=C.documentMode?this:e,n=_.get(t,i)-1;n?_.set(t,i,n):(C.documentMode?this.removeEventListener(i,o):e.removeEventListener(r,o,!0),_.remove(t,i))}}}),ce.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){ce.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||ce.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),ce.fn.extend({on:function(e,t,n,r){return Le(this,e,t,n,r)},one:function(e,t,n,r){return Le(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,ce(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=qe),this.each(function(){ce.event.remove(this,e,n,t)})}});var Oe=/<script|<style|<link/i,Pe=/checked\s*(?:[^=]|=\s*.checked.)/i,Me=/^\s*<!\[CDATA\[|\]\]>\s*$/g;function Re(e,t){return fe(e,"table")&&fe(11!==t.nodeType?t:t.firstChild,"tr")&&ce(e).children("tbody")[0]||e}function Ie(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function We(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Fe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(_.hasData(e)&&(s=_.get(e).events))for(i in _.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)ce.event.add(t,i,s[i][n]);z.hasData(e)&&(o=z.access(e),a=ce.extend({},o),z.set(t,a))}}function $e(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=v(d);if(h||1<f&&"string"==typeof d&&!le.checkClone&&Pe.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),$e(t,r,i,o)});if(f&&(t=(e=Ae(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=ce.map(Se(e,"script"),Ie)).length;c<f;c++)u=e,c!==p&&(u=ce.clone(u,!0,!0),s&&ce.merge(a,Se(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,ce.map(a,We),c=0;c<s;c++)u=a[c],Ce.test(u.type||"")&&!_.access(u,"globalEval")&&ce.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?ce._evalUrl&&!u.noModule&&ce._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):m(u.textContent.replace(Me,""),u,l))}return n}function Be(e,t,n){for(var r,i=t?ce.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||ce.cleanData(Se(r)),r.parentNode&&(n&&K(r)&&Ee(Se(r,"script")),r.parentNode.removeChild(r));return e}ce.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=K(e);if(!(le.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||ce.isXMLDoc(e)))for(a=Se(c),r=0,i=(o=Se(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&we.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||Se(e),a=a||Se(c),r=0,i=o.length;r<i;r++)Fe(o[r],a[r]);else Fe(e,c);return 0<(a=Se(c,"script")).length&&Ee(a,!f&&Se(e,"script")),c},cleanData:function(e){for(var t,n,r,i=ce.event.special,o=0;void 0!==(n=e[o]);o++)if($(n)){if(t=n[_.expando]){if(t.events)for(r in t.events)i[r]?ce.event.remove(n,r):ce.removeEvent(n,r,t.handle);n[_.expando]=void 0}n[z.expando]&&(n[z.expando]=void 0)}}}),ce.fn.extend({detach:function(e){return Be(this,e,!0)},remove:function(e){return Be(this,e)},text:function(e){return M(this,function(e){return void 0===e?ce.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return $e(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Re(this,e).appendChild(e)})},prepend:function(){return $e(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Re(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return $e(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return $e(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(ce.cleanData(Se(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return ce.clone(this,e,t)})},html:function(e){return M(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Oe.test(e)&&!ke[(Te.exec(e)||["",""])[1].toLowerCase()]){e=ce.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(ce.cleanData(Se(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return $e(this,arguments,function(e){var t=this.parentNode;ce.inArray(this,n)<0&&(ce.cleanData(Se(this)),t&&t.replaceChild(e,this))},n)}}),ce.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){ce.fn[e]=function(e){for(var t,n=[],r=ce(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),ce(r[o])[a](t),s.apply(n,t.get());return this.pushStack(n)}});var _e=new RegExp("^("+G+")(?!px)[a-z%]+$","i"),ze=/^--/,Xe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=ie),t.getComputedStyle(e)},Ue=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Ve=new RegExp(Q.join("|"),"i");function Ge(e,t,n){var r,i,o,a,s=ze.test(t),u=e.style;return(n=n||Xe(e))&&(a=n.getPropertyValue(t)||n[t],s&&a&&(a=a.replace(ve,"$1")||void 0),""!==a||K(e)||(a=ce.style(e,t)),!le.pixelBoxStyles()&&_e.test(a)&&Ve.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=n.width,u.width=r,u.minWidth=i,u.maxWidth=o)),void 0!==a?a+"":a}function Ye(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",J.appendChild(u).appendChild(l);var e=ie.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),J.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=C.createElement("div"),l=C.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",le.clearCloneStyle="content-box"===l.style.backgroundClip,ce.extend(le,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=C.createElement("table"),t=C.createElement("tr"),n=C.createElement("div"),e.style.cssText="position:absolute;left:-11111px;border-collapse:separate",t.style.cssText="box-sizing:content-box;border:1px solid",t.style.height="1px",n.style.height="9px",n.style.display="block",J.appendChild(e).appendChild(t).appendChild(n),r=ie.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,J.removeChild(e)),a}}))}();var Qe=["Webkit","Moz","ms"],Je=C.createElement("div").style,Ke={};function Ze(e){var t=ce.cssProps[e]||Ke[e];return t||(e in Je?e:Ke[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Qe.length;while(n--)if((e=Qe[n]+t)in Je)return e}(e)||e)}var et=/^(none|table(?!-c[ea]).+)/,tt={position:"absolute",visibility:"hidden",display:"block"},nt={letterSpacing:"0",fontWeight:"400"};function rt(e,t,n){var r=Y.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function it(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0,l=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(l+=ce.css(e,n+Q[a],!0,i)),r?("content"===n&&(u-=ce.css(e,"padding"+Q[a],!0,i)),"margin"!==n&&(u-=ce.css(e,"border"+Q[a]+"Width",!0,i))):(u+=ce.css(e,"padding"+Q[a],!0,i),"padding"!==n?u+=ce.css(e,"border"+Q[a]+"Width",!0,i):s+=ce.css(e,"border"+Q[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u+l}function ot(e,t,n){var r=Xe(e),i=(!le.boxSizingReliable()||n)&&"border-box"===ce.css(e,"boxSizing",!1,r),o=i,a=Ge(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(_e.test(a)){if(!n)return a;a="auto"}return(!le.boxSizingReliable()&&i||!le.reliableTrDimensions()&&fe(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===ce.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===ce.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+it(e,t,n||(i?"border":"content"),o,r,a)+"px"}function at(e,t,n,r,i){return new at.prototype.init(e,t,n,r,i)}ce.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Ge(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,aspectRatio:!0,borderImageSlice:!0,columnCount:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,scale:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeMiterlimit:!0,strokeOpacity:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=F(t),u=ze.test(t),l=e.style;if(u||(t=Ze(s)),a=ce.cssHooks[t]||ce.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=Y.exec(n))&&i[1]&&(n=te(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(ce.cssNumber[s]?"":"px")),le.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=F(t);return ze.test(t)||(t=Ze(s)),(a=ce.cssHooks[t]||ce.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Ge(e,t,r)),"normal"===i&&t in nt&&(i=nt[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),ce.each(["height","width"],function(e,u){ce.cssHooks[u]={get:function(e,t,n){if(t)return!et.test(ce.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?ot(e,u,n):Ue(e,tt,function(){return ot(e,u,n)})},set:function(e,t,n){var r,i=Xe(e),o=!le.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===ce.css(e,"boxSizing",!1,i),s=n?it(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-it(e,u,"border",!1,i)-.5)),s&&(r=Y.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=ce.css(e,u)),rt(0,t,s)}}}),ce.cssHooks.marginLeft=Ye(le.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Ge(e,"marginLeft"))||e.getBoundingClientRect().left-Ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),ce.each({margin:"",padding:"",border:"Width"},function(i,o){ce.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+Q[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(ce.cssHooks[i+o].set=rt)}),ce.fn.extend({css:function(e,t){return M(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Xe(e),i=t.length;a<i;a++)o[t[a]]=ce.css(e,t[a],!1,r);return o}return void 0!==n?ce.style(e,t,n):ce.css(e,t)},e,t,1<arguments.length)}}),((ce.Tween=at).prototype={constructor:at,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||ce.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(ce.cssNumber[n]?"":"px")},cur:function(){var e=at.propHooks[this.prop];return e&&e.get?e.get(this):at.propHooks._default.get(this)},run:function(e){var t,n=at.propHooks[this.prop];return this.options.duration?this.pos=t=ce.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):at.propHooks._default.set(this),this}}).init.prototype=at.prototype,(at.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=ce.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){ce.fx.step[e.prop]?ce.fx.step[e.prop](e):1!==e.elem.nodeType||!ce.cssHooks[e.prop]&&null==e.elem.style[Ze(e.prop)]?e.elem[e.prop]=e.now:ce.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=at.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},ce.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},ce.fx=at.prototype.init,ce.fx.step={};var st,ut,lt,ct,ft=/^(?:toggle|show|hide)$/,pt=/queueHooks$/;function dt(){ut&&(!1===C.hidden&&ie.requestAnimationFrame?ie.requestAnimationFrame(dt):ie.setTimeout(dt,ce.fx.interval),ce.fx.tick())}function ht(){return ie.setTimeout(function(){st=void 0}),st=Date.now()}function gt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=Q[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function vt(e,t,n){for(var r,i=(yt.tweeners[t]||[]).concat(yt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function yt(o,e,t){var n,a,r=0,i=yt.prefilters.length,s=ce.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=st||ht(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:ce.extend({},e),opts:ce.extend(!0,{specialEasing:{},easing:ce.easing._default},t),originalProperties:e,originalOptions:t,startTime:st||ht(),duration:t.duration,tweens:[],createTween:function(e,t){var n=ce.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=F(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=ce.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=yt.prefilters[r].call(l,o,c,l.opts))return v(n.stop)&&(ce._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return ce.map(c,vt,l),v(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),ce.fx.timer(ce.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}ce.Animation=ce.extend(yt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return te(n.elem,e,Y.exec(t),n),n}]},tweener:function(e,t){v(e)?(t=e,e=["*"]):e=e.match(D);for(var n,r=0,i=e.length;r<i;r++)n=e[r],yt.tweeners[n]=yt.tweeners[n]||[],yt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ee(e),v=_.get(e,"fxshow");for(r in n.queue||(null==(a=ce._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,ce.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ft.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||ce.style(e,r)}if((u=!ce.isEmptyObject(t))||!ce.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=_.get(e,"display")),"none"===(c=ce.css(e,"display"))&&(l?c=l:(re([e],!0),l=e.style.display||l,c=ce.css(e,"display"),re([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===ce.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=_.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&re([e],!0),p.done(function(){for(r in g||re([e]),_.remove(e,"fxshow"),d)ce.style(e,r,d[r])})),u=vt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?yt.prefilters.unshift(e):yt.prefilters.push(e)}}),ce.speed=function(e,t,n){var r=e&&"object"==typeof e?ce.extend({},e):{complete:n||!n&&t||v(e)&&e,duration:e,easing:n&&t||t&&!v(t)&&t};return ce.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in ce.fx.speeds?r.duration=ce.fx.speeds[r.duration]:r.duration=ce.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){v(r.old)&&r.old.call(this),r.queue&&ce.dequeue(this,r.queue)},r},ce.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ee).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=ce.isEmptyObject(t),o=ce.speed(e,n,r),a=function(){var e=yt(this,ce.extend({},t),o);(i||_.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=ce.timers,r=_.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&pt.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||ce.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=_.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=ce.timers,o=n?n.length:0;for(t.finish=!0,ce.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),ce.each(["toggle","show","hide"],function(e,r){var i=ce.fn[r];ce.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(gt(r,!0),e,t,n)}}),ce.each({slideDown:gt("show"),slideUp:gt("hide"),slideToggle:gt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){ce.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),ce.timers=[],ce.fx.tick=function(){var e,t=0,n=ce.timers;for(st=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||ce.fx.stop(),st=void 0},ce.fx.timer=function(e){ce.timers.push(e),ce.fx.start()},ce.fx.interval=13,ce.fx.start=function(){ut||(ut=!0,dt())},ce.fx.stop=function(){ut=null},ce.fx.speeds={slow:600,fast:200,_default:400},ce.fn.delay=function(r,e){return r=ce.fx&&ce.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=ie.setTimeout(e,r);t.stop=function(){ie.clearTimeout(n)}})},lt=C.createElement("input"),ct=C.createElement("select").appendChild(C.createElement("option")),lt.type="checkbox",le.checkOn=""!==lt.value,le.optSelected=ct.selected,(lt=C.createElement("input")).value="t",lt.type="radio",le.radioValue="t"===lt.value;var mt,xt=ce.expr.attrHandle;ce.fn.extend({attr:function(e,t){return M(this,ce.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){ce.removeAttr(this,e)})}}),ce.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?ce.prop(e,t,n):(1===o&&ce.isXMLDoc(e)||(i=ce.attrHooks[t.toLowerCase()]||(ce.expr.match.bool.test(t)?mt:void 0)),void 0!==n?null===n?void ce.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=ce.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!le.radioValue&&"radio"===t&&fe(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(D);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),mt={set:function(e,t,n){return!1===t?ce.removeAttr(e,n):e.setAttribute(n,n),n}},ce.each(ce.expr.match.bool.source.match(/\w+/g),function(e,t){var a=xt[t]||ce.find.attr;xt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=xt[o],xt[o]=r,r=null!=a(e,t,n)?o:null,xt[o]=i),r}});var bt=/^(?:input|select|textarea|button)$/i,wt=/^(?:a|area)$/i;function Tt(e){return(e.match(D)||[]).join(" ")}function Ct(e){return e.getAttribute&&e.getAttribute("class")||""}function kt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(D)||[]}ce.fn.extend({prop:function(e,t){return M(this,ce.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[ce.propFix[e]||e]})}}),ce.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&ce.isXMLDoc(e)||(t=ce.propFix[t]||t,i=ce.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=ce.find.attr(e,"tabindex");return t?parseInt(t,10):bt.test(e.nodeName)||wt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),le.optSelected||(ce.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),ce.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){ce.propFix[this.toLowerCase()]=this}),ce.fn.extend({addClass:function(t){var e,n,r,i,o,a;return v(t)?this.each(function(e){ce(this).addClass(t.call(this,e,Ct(this)))}):(e=kt(t)).length?this.each(function(){if(r=Ct(this),n=1===this.nodeType&&" "+Tt(r)+" "){for(o=0;o<e.length;o++)i=e[o],n.indexOf(" "+i+" ")<0&&(n+=i+" ");a=Tt(n),r!==a&&this.setAttribute("class",a)}}):this},removeClass:function(t){var e,n,r,i,o,a;return v(t)?this.each(function(e){ce(this).removeClass(t.call(this,e,Ct(this)))}):arguments.length?(e=kt(t)).length?this.each(function(){if(r=Ct(this),n=1===this.nodeType&&" "+Tt(r)+" "){for(o=0;o<e.length;o++){i=e[o];while(-1<n.indexOf(" "+i+" "))n=n.replace(" "+i+" "," ")}a=Tt(n),r!==a&&this.setAttribute("class",a)}}):this:this.attr("class","")},toggleClass:function(t,n){var e,r,i,o,a=typeof t,s="string"===a||Array.isArray(t);return v(t)?this.each(function(e){ce(this).toggleClass(t.call(this,e,Ct(this),n),n)}):"boolean"==typeof n&&s?n?this.addClass(t):this.removeClass(t):(e=kt(t),this.each(function(){if(s)for(o=ce(this),i=0;i<e.length;i++)r=e[i],o.hasClass(r)?o.removeClass(r):o.addClass(r);else void 0!==t&&"boolean"!==a||((r=Ct(this))&&_.set(this,"__className__",r),this.setAttribute&&this.setAttribute("class",r||!1===t?"":_.get(this,"__className__")||""))}))},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+Tt(Ct(n))+" ").indexOf(t))return!0;return!1}});var St=/\r/g;ce.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=v(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,ce(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=ce.map(t,function(e){return null==e?"":e+""})),(r=ce.valHooks[this.type]||ce.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=ce.valHooks[t.type]||ce.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(St,""):null==e?"":e:void 0}}),ce.extend({valHooks:{option:{get:function(e){var t=ce.find.attr(e,"value");return null!=t?t:Tt(ce.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!fe(n.parentNode,"optgroup"))){if(t=ce(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=ce.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<ce.inArray(ce.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),ce.each(["radio","checkbox"],function(){ce.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<ce.inArray(ce(e).val(),t)}},le.checkOn||(ce.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Et=ie.location,jt={guid:Date.now()},At=/\?/;ce.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{t=(new ie.DOMParser).parseFromString(e,"text/xml")}catch(e){}return n=t&&t.getElementsByTagName("parsererror")[0],t&&!n||ce.error("Invalid XML: "+(n?ce.map(n.childNodes,function(e){return e.textContent}).join("\n"):e)),t};var Dt=/^(?:focusinfocus|focusoutblur)$/,Nt=function(e){e.stopPropagation()};ce.extend(ce.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||C],d=ue.call(e,"type")?e.type:e,h=ue.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||C,3!==n.nodeType&&8!==n.nodeType&&!Dt.test(d+ce.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[ce.expando]?e:new ce.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:ce.makeArray(t,[e]),c=ce.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!y(n)){for(s=c.delegateType||d,Dt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||C)&&p.push(a.defaultView||a.parentWindow||ie)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(_.get(o,"events")||Object.create(null))[e.type]&&_.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&$(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!$(n)||u&&v(n[d])&&!y(n)&&((a=n[u])&&(n[u]=null),ce.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Nt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Nt),ce.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=ce.extend(new ce.Event,n,{type:e,isSimulated:!0});ce.event.trigger(r,null,t)}}),ce.fn.extend({trigger:function(e,t){return this.each(function(){ce.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return ce.event.trigger(e,t,n,!0)}});var qt=/\[\]$/,Lt=/\r?\n/g,Ht=/^(?:submit|button|image|reset|file)$/i,Ot=/^(?:input|select|textarea|keygen)/i;function Pt(n,e,r,i){var t;if(Array.isArray(e))ce.each(e,function(e,t){r||qt.test(n)?i(n,t):Pt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==x(e))i(n,e);else for(t in e)Pt(n+"["+t+"]",e[t],r,i)}ce.param=function(e,t){var n,r=[],i=function(e,t){var n=v(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!ce.isPlainObject(e))ce.each(e,function(){i(this.name,this.value)});else for(n in e)Pt(n,e[n],t,i);return r.join("&")},ce.fn.extend({serialize:function(){return ce.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=ce.prop(this,"elements");return e?ce.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!ce(this).is(":disabled")&&Ot.test(this.nodeName)&&!Ht.test(e)&&(this.checked||!we.test(e))}).map(function(e,t){var n=ce(this).val();return null==n?null:Array.isArray(n)?ce.map(n,function(e){return{name:t.name,value:e.replace(Lt,"\r\n")}}):{name:t.name,value:n.replace(Lt,"\r\n")}}).get()}});var Mt=/%20/g,Rt=/#.*$/,It=/([?&])_=[^&]*/,Wt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ft=/^(?:GET|HEAD)$/,$t=/^\/\//,Bt={},_t={},zt="*/".concat("*"),Xt=C.createElement("a");function Ut(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(D)||[];if(v(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Vt(t,i,o,a){var s={},u=t===_t;function l(e){var r;return s[e]=!0,ce.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function Gt(e,t){var n,r,i=ce.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&ce.extend(!0,e,r),e}Xt.href=Et.href,ce.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":zt,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":ce.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Gt(Gt(e,ce.ajaxSettings),t):Gt(ce.ajaxSettings,e)},ajaxPrefilter:Ut(Bt),ajaxTransport:Ut(_t),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=ce.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?ce(y):ce.event,x=ce.Deferred(),b=ce.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Wt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace($t,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(D)||[""],null==v.crossDomain){r=C.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Xt.protocol+"//"+Xt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=ce.param(v.data,v.traditional)),Vt(Bt,v,t,T),h)return T;for(i in(g=ce.event&&v.global)&&0==ce.active++&&ce.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Ft.test(v.type),f=v.url.replace(Rt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Mt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(At.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(It,"$1"),o=(At.test(f)?"&":"?")+"_="+jt.guid+++o),v.url=f+o),v.ifModified&&(ce.lastModified[f]&&T.setRequestHeader("If-Modified-Since",ce.lastModified[f]),ce.etag[f]&&T.setRequestHeader("If-None-Match",ce.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+zt+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Vt(_t,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=ie.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&ie.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<ce.inArray("script",v.dataTypes)&&ce.inArray("json",v.dataTypes)<0&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(ce.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(ce.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--ce.active||ce.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return ce.get(e,t,n,"json")},getScript:function(e,t){return ce.get(e,void 0,t,"script")}}),ce.each(["get","post"],function(e,i){ce[i]=function(e,t,n,r){return v(t)&&(r=r||n,n=t,t=void 0),ce.ajax(ce.extend({url:e,type:i,dataType:r,data:t,success:n},ce.isPlainObject(e)&&e))}}),ce.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),ce._evalUrl=function(e,t,n){return ce.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){ce.globalEval(e,t,n)}})},ce.fn.extend({wrapAll:function(e){var t;return this[0]&&(v(e)&&(e=e.call(this[0])),t=ce(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return v(n)?this.each(function(e){ce(this).wrapInner(n.call(this,e))}):this.each(function(){var e=ce(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=v(t);return this.each(function(e){ce(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){ce(this).replaceWith(this.childNodes)}),this}}),ce.expr.pseudos.hidden=function(e){return!ce.expr.pseudos.visible(e)},ce.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},ce.ajaxSettings.xhr=function(){try{return new ie.XMLHttpRequest}catch(e){}};var Yt={0:200,1223:204},Qt=ce.ajaxSettings.xhr();le.cors=!!Qt&&"withCredentials"in Qt,le.ajax=Qt=!!Qt,ce.ajaxTransport(function(i){var o,a;if(le.cors||Qt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Yt[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&ie.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),ce.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),ce.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return ce.globalEval(e),e}}}),ce.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),ce.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=ce("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),C.head.appendChild(r[0])},abort:function(){i&&i()}}});var Jt,Kt=[],Zt=/(=)\?(?=&|$)|\?\?/;ce.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Kt.pop()||ce.expando+"_"+jt.guid++;return this[e]=!0,e}}),ce.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Zt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Zt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=v(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Zt,"$1"+r):!1!==e.jsonp&&(e.url+=(At.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||ce.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=ie[r],ie[r]=function(){o=arguments},n.always(function(){void 0===i?ce(ie).removeProp(r):ie[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Kt.push(r)),o&&v(i)&&i(o[0]),o=i=void 0}),"script"}),le.createHTMLDocument=((Jt=C.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Jt.childNodes.length),ce.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(le.createHTMLDocument?((r=(t=C.implementation.createHTMLDocument("")).createElement("base")).href=C.location.href,t.head.appendChild(r)):t=C),o=!n&&[],(i=w.exec(e))?[t.createElement(i[1])]:(i=Ae([e],t,o),o&&o.length&&ce(o).remove(),ce.merge([],i.childNodes)));var r,i,o},ce.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=Tt(e.slice(s)),e=e.slice(0,s)),v(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&ce.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?ce("<div>").append(ce.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},ce.expr.pseudos.animated=function(t){return ce.grep(ce.timers,function(e){return t===e.elem}).length},ce.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=ce.css(e,"position"),c=ce(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=ce.css(e,"top"),u=ce.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),v(t)&&(t=t.call(e,n,ce.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},ce.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){ce.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===ce.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===ce.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=ce(e).offset()).top+=ce.css(e,"borderTopWidth",!0),i.left+=ce.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-ce.css(r,"marginTop",!0),left:t.left-i.left-ce.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===ce.css(e,"position"))e=e.offsetParent;return e||J})}}),ce.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;ce.fn[t]=function(e){return M(this,function(e,t,n){var r;if(y(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),ce.each(["top","left"],function(e,n){ce.cssHooks[n]=Ye(le.pixelPosition,function(e,t){if(t)return t=Ge(e,n),_e.test(t)?ce(e).position()[n]+"px":t})}),ce.each({Height:"height",Width:"width"},function(a,s){ce.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){ce.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return M(this,function(e,t,n){var r;return y(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?ce.css(e,t,i):ce.style(e,t,n,i)},s,n?e:void 0,n)}})}),ce.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){ce.fn[t]=function(e){return this.on(t,e)}}),ce.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.on("mouseenter",e).on("mouseleave",t||e)}}),ce.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){ce.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var en=/^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;ce.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),v(e))return r=ae.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(ae.call(arguments)))}).guid=e.guid=e.guid||ce.guid++,i},ce.holdReady=function(e){e?ce.readyWait++:ce.ready(!0)},ce.isArray=Array.isArray,ce.parseJSON=JSON.parse,ce.nodeName=fe,ce.isFunction=v,ce.isWindow=y,ce.camelCase=F,ce.type=x,ce.now=Date.now,ce.isNumeric=function(e){var t=ce.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},ce.trim=function(e){return null==e?"":(e+"").replace(en,"$1")}, true&&!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return ce}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));var tn=ie.jQuery,nn=ie.$;return ce.noConflict=function(e){return ie.$===ce&&(ie.$=nn),e&&ie.jQuery===ce&&(ie.jQuery=tn),ce},"undefined"==typeof e&&(ie.jQuery=ie.$=ce),ce});


/***/ }),

/***/ "./node_modules/just-debounce/index.js":
/*!*********************************************!*\
  !*** ./node_modules/just-debounce/index.js ***!
  \*********************************************/
/***/ ((module) => {

module.exports = debounce;

function debounce(fn, delay, atStart, guarantee) {
  var timeout;
  var args;
  var self;

  return function debounced() {
    self = this;
    args = Array.prototype.slice.call(arguments);

    if (timeout && (atStart || guarantee)) {
      return;
    } else if (!atStart) {
      clear();

      timeout = setTimeout(run, delay);
      return timeout;
    }

    timeout = setTimeout(clear, delay);
    fn.apply(self, args);

    function run() {
      clear();
      fn.apply(self, args);
    }

    function clear() {
      clearTimeout(timeout);
      timeout = null;
    }
  };
}


/***/ }),

/***/ "./node_modules/lodash._reinterpolate/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash._reinterpolate/index.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

module.exports = reInterpolate;


/***/ }),

/***/ "./node_modules/lodash.template/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.template/index.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = __webpack_require__(/*! lodash._reinterpolate */ "./node_modules/lodash._reinterpolate/index.js"),
    templateSettings = __webpack_require__(/*! lodash.templatesettings */ "./node_modules/lodash.templatesettings/index.js");

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    domExcTag = '[object DOMException]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max,
    nativeNow = Date.now;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);

  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
  // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
  var sourceURL = hasOwnProperty.call(options, 'sourceURL')
    ? ('//# sourceURL=' +
       (options.sourceURL + '').replace(/[\r\n]/g, ' ') +
       '\n')
    : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  // Like with sourceURL, we take care to not check the option's prototype,
  // as this configuration is a code injection vector.
  var variable = hasOwnProperty.call(options, 'variable') && options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = template;


/***/ }),

/***/ "./node_modules/lodash.templatesettings/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/lodash.templatesettings/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = __webpack_require__(/*! lodash._reinterpolate */ "./node_modules/lodash._reinterpolate/index.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]';

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g,
    reEvaluate = /<%([\s\S]+?)%>/g;

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = templateSettings;


/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyOf.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_basePropertyOf.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "./node_modules/lodash/_baseValues.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseValues.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js");

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_createAssigner.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createAssigner.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "./node_modules/lodash/_createCtor.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createCtor.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtor(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

module.exports = createCtor;


/***/ }),

/***/ "./node_modules/lodash/_createFind.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createFind.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),

/***/ "./node_modules/lodash/_createWrap.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createWrap.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js"),
    createCtor = __webpack_require__(/*! ./_createCtor */ "./node_modules/lodash/_createCtor.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG,
      Ctor = createCtor(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

module.exports = createPartial;


/***/ }),

/***/ "./node_modules/lodash/_customDefaultsAssignIn.js":
/*!********************************************************!*\
  !*** ./node_modules/lodash/_customDefaultsAssignIn.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

module.exports = customDefaultsAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_escapeHtmlChar.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_escapeHtmlChar.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePropertyOf = __webpack_require__(/*! ./_basePropertyOf */ "./node_modules/lodash/_basePropertyOf.js");

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

module.exports = escapeHtmlChar;


/***/ }),

/***/ "./node_modules/lodash/_escapeStringChar.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_escapeStringChar.js ***!
  \**************************************************/
/***/ ((module) => {

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

module.exports = escapeStringChar;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "./node_modules/lodash/_getHolder.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getHolder.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "./node_modules/lodash/_reEscape.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_reEscape.js ***!
  \******************************************/
/***/ ((module) => {

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

module.exports = reEscape;


/***/ }),

/***/ "./node_modules/lodash/_reEvaluate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_reEvaluate.js ***!
  \********************************************/
/***/ ((module) => {

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

module.exports = reEvaluate;


/***/ }),

/***/ "./node_modules/lodash/_reInterpolate.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_reInterpolate.js ***!
  \***********************************************/
/***/ ((module) => {

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

module.exports = reInterpolate;


/***/ }),

/***/ "./node_modules/lodash/_replaceHolders.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_replaceHolders.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/assignInWith.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/assignInWith.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

module.exports = assignInWith;


/***/ }),

/***/ "./node_modules/lodash/attempt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/attempt.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isError = __webpack_require__(/*! ./isError */ "./node_modules/lodash/isError.js");

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

module.exports = attempt;


/***/ }),

/***/ "./node_modules/lodash/bind.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/bind.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    createWrap = __webpack_require__(/*! ./_createWrap */ "./node_modules/lodash/_createWrap.js"),
    getHolder = __webpack_require__(/*! ./_getHolder */ "./node_modules/lodash/_getHolder.js"),
    replaceHolders = __webpack_require__(/*! ./_replaceHolders */ "./node_modules/lodash/_replaceHolders.js");

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_PARTIAL_FLAG = 32;

/**
 * Creates a function that invokes `func` with the `this` binding of `thisArg`
 * and `partials` prepended to the arguments it receives.
 *
 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for partially applied arguments.
 *
 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
 * property of bound functions.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new bound function.
 * @example
 *
 * function greet(greeting, punctuation) {
 *   return greeting + ' ' + this.user + punctuation;
 * }
 *
 * var object = { 'user': 'fred' };
 *
 * var bound = _.bind(greet, object, 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * // Bound with placeholders.
 * var bound = _.bind(greet, object, _, '!');
 * bound('hi');
 * // => 'hi fred!'
 */
var bind = baseRest(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bind));
    bitmask |= WRAP_PARTIAL_FLAG;
  }
  return createWrap(func, bitmask, thisArg, partials, holders);
});

// Assign default placeholders.
bind.placeholder = {};

module.exports = bind;


/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "./node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/escape.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/escape.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escapeHtmlChar = __webpack_require__(/*! ./_escapeHtmlChar */ "./node_modules/lodash/_escapeHtmlChar.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;


/***/ }),

/***/ "./node_modules/lodash/find.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/find.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createFind = __webpack_require__(/*! ./_createFind */ "./node_modules/lodash/_createFind.js"),
    findIndex = __webpack_require__(/*! ./findIndex */ "./node_modules/lodash/findIndex.js");

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),

/***/ "./node_modules/lodash/findIndex.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/findIndex.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    toInteger = __webpack_require__(/*! ./toInteger */ "./node_modules/lodash/toInteger.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),

/***/ "./node_modules/lodash/isError.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isError.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js");

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}

module.exports = isError;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),

/***/ "./node_modules/lodash/template.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/template.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignInWith = __webpack_require__(/*! ./assignInWith */ "./node_modules/lodash/assignInWith.js"),
    attempt = __webpack_require__(/*! ./attempt */ "./node_modules/lodash/attempt.js"),
    baseValues = __webpack_require__(/*! ./_baseValues */ "./node_modules/lodash/_baseValues.js"),
    customDefaultsAssignIn = __webpack_require__(/*! ./_customDefaultsAssignIn */ "./node_modules/lodash/_customDefaultsAssignIn.js"),
    escapeStringChar = __webpack_require__(/*! ./_escapeStringChar */ "./node_modules/lodash/_escapeStringChar.js"),
    isError = __webpack_require__(/*! ./isError */ "./node_modules/lodash/isError.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js"),
    reInterpolate = __webpack_require__(/*! ./_reInterpolate */ "./node_modules/lodash/_reInterpolate.js"),
    templateSettings = __webpack_require__(/*! ./templateSettings */ "./node_modules/lodash/templateSettings.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/** Error message constants. */
var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to validate the `validate` option in `_.template` variable.
 *
 * Forbids characters which could potentially change the meaning of the function argument definition:
 * - "()," (modification of function parameters)
 * - "=" (default value)
 * - "[]{}" (destructuring of function parameters)
 * - "/" (beginning of a comment)
 * - whitespace
 */
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);

  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.
  var sourceURL = hasOwnProperty.call(options, 'sourceURL')
    ? ('//# sourceURL=' +
       (options.sourceURL + '').replace(/\s/g, ' ') +
       '\n')
    : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = hasOwnProperty.call(options, 'variable') && options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }

  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

module.exports = template;


/***/ }),

/***/ "./node_modules/lodash/templateSettings.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/templateSettings.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escape = __webpack_require__(/*! ./escape */ "./node_modules/lodash/escape.js"),
    reEscape = __webpack_require__(/*! ./_reEscape */ "./node_modules/lodash/_reEscape.js"),
    reEvaluate = __webpack_require__(/*! ./_reEvaluate */ "./node_modules/lodash/_reEvaluate.js"),
    reInterpolate = __webpack_require__(/*! ./_reInterpolate */ "./node_modules/lodash/_reInterpolate.js");

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

module.exports = templateSettings;


/***/ }),

/***/ "./node_modules/lodash/toInteger.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/toInteger.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(/*! ./util.inspect */ "?4f7e");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof __webpack_require__.g !== 'undefined' && obj === __webpack_require__.g)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ "./node_modules/parse-int/index.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-int/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isInteger = __webpack_require__(/*! is-integer */ "./node_modules/is-integer/index.js")
var isIntegerRegex = /^-?\d+$/

module.exports = function parseIntStrict (integer) {
  if (typeof integer === 'number') {
    return isInteger(integer) ? integer : undefined
  }
  if (typeof integer === 'string') {
    return isIntegerRegex.test(integer) ? parseInt(integer, 10) : undefined
  }
}


/***/ }),

/***/ "./node_modules/parse-year/index.js":
/*!******************************************!*\
  !*** ./node_modules/parse-year/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var parseIntStrict = __webpack_require__(/*! parse-int */ "./node_modules/parse-int/index.js")
var expandYear = __webpack_require__(/*! expand-year */ "./node_modules/expand-year/index.js")

module.exports = function parseYear (year, expand, now) {
  year = parseIntStrict(year)
  if (year == null) return
  if (!expand) return year
  return expandYear(year, now)
}


/***/ }),

/***/ "./node_modules/punycode/punycode.js":
/*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ "./node_modules/set-function-length/index.js":
/*!***************************************************!*\
  !*** ./node_modules/set-function-length/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var define = __webpack_require__(/*! define-data-property */ "./node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('.').listGetNode} */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	for (; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			// eslint-disable-next-line no-extra-parens
			curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

/** @type {import('.').listGet} */
var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('.').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('.').ListNode<typeof value>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('.').listHas} */
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @type {WeakMap<object, unknown>} */ var $wm;
	/** @type {Map<object, unknown>} */ var $m;
	/** @type {import('.').RootNode<unknown>} */ var $o;

	/** @type {import('.').Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ "./node_modules/slick-carousel/slick/slick.js":
/*!****************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.1
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
;(function(factory) {
    'use strict';
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}

}(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this, dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function(slider, i) {
                    return $('<button type="button" />').text(i + 1);
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                focusOnChange: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnFocus: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                useTransform: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                scrolling: false,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                swiping: false,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.focussed = false;
            _.interrupted = false;
            _.hidden = 'hidden';
            _.paused = true;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, settings, dataSettings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


            _.registerBreakpoints();
            _.init(true);

        }

        return Slick;

    }());

    Slick.prototype.activateADA = function() {
        var _ = this;

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });

    };

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof(index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function(targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -(_.currentLeft);
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' +
                                now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' +
                                now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function() {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function() {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    };

    Slick.prototype.getNavTarget = function() {

        var _ = this,
            asNavFor = _.options.asNavFor;

        if ( asNavFor && asNavFor !== null ) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        return asNavFor;

    };

    Slick.prototype.asNavFor = function(index) {

        var _ = this,
            asNavFor = _.getNavTarget();

        if ( asNavFor !== null && typeof asNavFor === 'object' ) {
            asNavFor.each(function() {
                var target = $(this).slick('getSlick');
                if(!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }

    };

    Slick.prototype.applyTransition = function(slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.autoPlay = function() {

        var _ = this;

        _.autoPlayClear();

        if ( _.slideCount > _.options.slidesToShow ) {
            _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );
        }

    };

    Slick.prototype.autoPlayClear = function() {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    };

    Slick.prototype.autoPlayIterator = function() {

        var _ = this,
            slideTo = _.currentSlide + _.options.slidesToScroll;

        if ( !_.paused && !_.interrupted && !_.focussed ) {

            if ( _.options.infinite === false ) {

                if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {
                    _.direction = 0;
                }

                else if ( _.direction === 0 ) {

                    slideTo = _.currentSlide - _.options.slidesToScroll;

                    if ( _.currentSlide - 1 === 0 ) {
                        _.direction = 1;
                    }

                }

            }

            _.slideHandler( slideTo );

        }

    };

    Slick.prototype.buildArrows = function() {

        var _ = this;

        if (_.options.arrows === true ) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if( _.slideCount > _.options.slidesToShow ) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow
                        .addClass('slick-disabled')
                        .attr('aria-disabled', 'true');
                }

            } else {

                _.$prevArrow.add( _.$nextArrow )

                    .addClass('slick-hidden')
                    .attr({
                        'aria-disabled': 'true',
                        'tabindex': '-1'
                    });

            }

        }

    };

    Slick.prototype.buildDots = function() {

        var _ = this,
            i, dot;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$slider.addClass('slick-dotted');

            dot = $('<ul />').addClass(_.options.dotsClass);

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
            }

            _.$dots = dot.appendTo(_.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active');

        }

    };

    Slick.prototype.buildOut = function() {

        var _ = this;

        _.$slides =
            _.$slider
                .children( _.options.slide + ':not(.slick-cloned)')
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function(index, element) {
            $(element)
                .attr('data-slick-index', index)
                .data('originalStyling', $(element).attr('style') || '');
        });

        _.$slider.addClass('slick-slider');

        _.$slideTrack = (_.slideCount === 0) ?
            $('<div class="slick-track"/>').appendTo(_.$slider) :
            _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap(
            '<div class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();


        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    };

    Slick.prototype.buildRows = function() {

        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if(_.options.rows > 0) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(
                originalSlides.length / slidesPerSection
            );

            for(a = 0; a < numOfSlides; a++){
                var slide = document.createElement('div');
                for(b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for(c = 0; c < _.options.slidesPerRow; c++) {
                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children()
                .css({
                    'width':(100 / _.options.slidesPerRow) + '%',
                    'display': 'inline-block'
                });

        }

    };

    Slick.prototype.checkResponsive = function(initial, forceUpdate) {

        var _ = this,
            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if ( _.options.responsive &&
            _.options.responsive.length &&
            _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint =
                            targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings,
                                _.breakpointSettings[
                                    targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings,
                            _.breakpointSettings[
                                targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if( !initial && triggerBreakpoint !== false ) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }

    };

    Slick.prototype.changeSlide = function(event, dontAnimate) {

        var _ = this,
            $target = $(event.currentTarget),
            indexOffset, slideOffset, unevenOffset;

        // If target is a link, prevent default action.
        if($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if(!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 :
                    event.data.index || $target.index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                $target.children().trigger('focus');
                break;

            default:
                return;
        }

    };

    Slick.prototype.checkNavigable = function(index) {

        var _ = this,
            navigables, prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function() {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots)
                .off('click.slick', _.changeSlide)
                .off('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .off('mouseleave.slick', $.proxy(_.interrupt, _, false));

            if (_.options.accessibility === true) {
                _.$dots.off('keydown.slick', _.keyHandler);
            }
        }

        _.$slider.off('focus.slick blur.slick');

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
                _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
            }
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.cleanUpSlideEvents();

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.cleanUpSlideEvents = function() {

        var _ = this;

        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

    };

    Slick.prototype.cleanUpRows = function() {

        var _ = this, originalSlides;

        if(_.options.rows > 0) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.empty().append(originalSlides);
        }

    };

    Slick.prototype.clickHandler = function(event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }

    };

    Slick.prototype.destroy = function(refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }

        if ( _.$prevArrow && _.$prevArrow.length ) {

            _.$prevArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.prevArrow )) {
                _.$prevArrow.remove();
            }
        }

        if ( _.$nextArrow && _.$nextArrow.length ) {

            _.$nextArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.nextArrow )) {
                _.$nextArrow.remove();
            }
        }


        if (_.$slides) {

            _.$slides
                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
                .removeAttr('aria-hidden')
                .removeAttr('data-slick-index')
                .each(function(){
                    $(this).attr('style', $(this).data('originalStyling'));
                });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');
        _.$slider.removeClass('slick-dotted');

        _.unslicked = true;

        if(!refresh) {
            _.$slider.trigger('destroy', [_]);
        }

    };

    Slick.prototype.disableTransition = function(slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function() {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    };

    Slick.prototype.fadeSlideOut = function(slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });

        }

    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

        var _ = this;

        if (filter !== null) {

            _.$slidesCache = _.$slides;

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.focusHandler = function() {

        var _ = this;

        _.$slider
            .off('focus.slick blur.slick')
            .on('focus.slick blur.slick', '*', function(event) {

            event.stopImmediatePropagation();
            var $sf = $(this);

            setTimeout(function() {

                if( _.options.pauseOnFocus ) {
                    _.focussed = $sf.is(':focus');
                    _.autoPlay();
                }

            }, 0);

        });
    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

        var _ = this;
        return _.currentSlide;

    };

    Slick.prototype.getDotCount = function() {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            if (_.slideCount <= _.options.slidesToShow) {
                 ++pagerQty;
            } else {
                while (breakPoint < _.slideCount) {
                    ++pagerQty;
                    breakPoint = counter + _.options.slidesToScroll;
                    counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                }
            }
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else if(!_.options.asNavFor) {
            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        }else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;

    };

    Slick.prototype.getLeft = function(slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide,
            coef;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                coef = -1

                if (_.options.vertical === true && _.options.centerMode === true) {
                    if (_.options.slidesToShow === 2) {
                        coef = -1.5;
                    } else if (_.options.slidesToShow === 1) {
                        coef = -2
                    }
                }
                verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                    } else {
                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
            _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);
        } else if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            if (_.options.rtl === true) {
                if (targetSlide[0]) {
                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                } else {
                    targetLeft =  0;
                }
            } else {
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            }

            if (_.options.centerMode === true) {
                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }

                if (_.options.rtl === true) {
                    if (targetSlide[0]) {
                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                    } else {
                        targetLeft =  0;
                    }
                } else {
                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                }

                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;

    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

        var _ = this;

        return _.options[option];

    };

    Slick.prototype.getNavigableIndexes = function() {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;

    };

    Slick.prototype.getSlick = function() {

        return this;

    };

    Slick.prototype.getSlideCount = function() {

        var _ = this,
            slidesTraversed, swipedSlide, centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;

        } else {
            return _.options.slidesToScroll;
        }

    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);

    };

    Slick.prototype.init = function(creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(true);
            _.focusHandler();

        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

        if ( _.options.autoplay ) {

            _.paused = false;
            _.autoPlay();

        }

    };

    Slick.prototype.initADA = function() {
        var _ = this,
                numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
                tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
                    return (val >= 0) && (val < _.slideCount);
                });

        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        if (_.$dots !== null) {
            _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
                var slideControlIndex = tabControlIndexes.indexOf(i);

                $(this).attr({
                    'role': 'tabpanel',
                    'id': 'slick-slide' + _.instanceUid + i,
                    'tabindex': -1
                });

                if (slideControlIndex !== -1) {
                   var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex
                   if ($('#' + ariaButtonControl).length) {
                     $(this).attr({
                         'aria-describedby': ariaButtonControl
                     });
                   }
                }
            });

            _.$dots.attr('role', 'tablist').find('li').each(function(i) {
                var mappedSlideIndex = tabControlIndexes[i];

                $(this).attr({
                    'role': 'presentation'
                });

                $(this).find('button').first().attr({
                    'role': 'tab',
                    'id': 'slick-slide-control' + _.instanceUid + i,
                    'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
                    'aria-label': (i + 1) + ' of ' + numDotGroups,
                    'aria-selected': null,
                    'tabindex': '-1'
                });

            }).eq(_.currentSlide).find('button').attr({
                'aria-selected': 'true',
                'tabindex': '0'
            }).end();
        }

        for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {
          if (_.options.focusOnChange) {
            _.$slides.eq(i).attr({'tabindex': '0'});
          } else {
            _.$slides.eq(i).removeAttr('tabindex');
          }
        }

        _.activateADA();

    };

    Slick.prototype.initArrowEvents = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow
               .off('click.slick')
               .on('click.slick', {
                    message: 'previous'
               }, _.changeSlide);
            _.$nextArrow
               .off('click.slick')
               .on('click.slick', {
                    message: 'next'
               }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow.on('keydown.slick', _.keyHandler);
                _.$nextArrow.on('keydown.slick', _.keyHandler);
            }
        }

    };

    Slick.prototype.initDotEvents = function() {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$dots.on('keydown.slick', _.keyHandler);
            }
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {

            $('li', _.$dots)
                .on('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initSlideEvents = function() {

        var _ = this;

        if ( _.options.pauseOnHover ) {

            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initializeEvents = function() {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();
        _.initSlideEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(_.setPosition);

    };

    Slick.prototype.initUI = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();

        }

    };

    Slick.prototype.keyHandler = function(event) {

        var _ = this;
         //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'next' :  'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'previous' : 'next'
                    }
                });
            }
        }

    };

    Slick.prototype.lazyLoad = function() {

        var _ = this,
            loadRange, cloneRange, rangeStart, rangeEnd;

        function loadImages(imagesScope) {

            $('img[data-lazy]', imagesScope).each(function() {

                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageSrcSet = $(this).attr('data-srcset'),
                    imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function() {

                    image
                        .animate({ opacity: 0 }, 100, function() {

                            if (imageSrcSet) {
                                image
                                    .attr('srcset', imageSrcSet );

                                if (imageSizes) {
                                    image
                                        .attr('sizes', imageSizes );
                                }
                            }

                            image
                                .attr('src', imageSource)
                                .animate({ opacity: 1 }, 200, function() {
                                    image
                                        .removeAttr('data-lazy data-srcset data-sizes')
                                        .removeClass('slick-loading');
                                });
                            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                        });

                };

                imageToLoad.onerror = function() {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                };

                imageToLoad.src = imageSource;

            });

        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

        if (_.options.lazyLoad === 'anticipated') {
            var prevSlide = rangeStart - 1,
                nextSlide = rangeEnd,
                $slides = _.$slider.find('.slick-slide');

            for (var i = 0; i < _.options.slidesToScroll; i++) {
                if (prevSlide < 0) prevSlide = _.slideCount - 1;
                loadRange = loadRange.add($slides.eq(prevSlide));
                loadRange = loadRange.add($slides.eq(nextSlide));
                prevSlide--;
                nextSlide++;
            }
        }

        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else
        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }

    };

    Slick.prototype.loadSlider = function() {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    };

    Slick.prototype.next = Slick.prototype.slickNext = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });

    };

    Slick.prototype.orientationChange = function() {

        var _ = this;

        _.checkResponsive();
        _.setPosition();

    };

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;

    };

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

        var _ = this;

        _.autoPlay();
        _.options.autoplay = true;
        _.paused = false;
        _.focussed = false;
        _.interrupted = false;

    };

    Slick.prototype.postSlide = function(index) {

        var _ = this;

        if( !_.unslicked ) {

            _.$slider.trigger('afterChange', [_, index]);

            _.animating = false;

            if (_.slideCount > _.options.slidesToShow) {
                _.setPosition();
            }

            _.swipeLeft = null;

            if ( _.options.autoplay ) {
                _.autoPlay();
            }

            if (_.options.accessibility === true) {
                _.initADA();

                if (_.options.focusOnChange) {
                    var $currentSlide = $(_.$slides.get(_.currentSlide));
                    $currentSlide.attr('tabindex', 0).focus();
                }
            }

        }

    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });

    };

    Slick.prototype.preventDefault = function(event) {

        event.preventDefault();

    };

    Slick.prototype.progressiveLazyLoad = function( tryCount ) {

        tryCount = tryCount || 1;

        var _ = this,
            $imgsToLoad = $( 'img[data-lazy]', _.$slider ),
            image,
            imageSource,
            imageSrcSet,
            imageSizes,
            imageToLoad;

        if ( $imgsToLoad.length ) {

            image = $imgsToLoad.first();
            imageSource = image.attr('data-lazy');
            imageSrcSet = image.attr('data-srcset');
            imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');
            imageToLoad = document.createElement('img');

            imageToLoad.onload = function() {

                if (imageSrcSet) {
                    image
                        .attr('srcset', imageSrcSet );

                    if (imageSizes) {
                        image
                            .attr('sizes', imageSizes );
                    }
                }

                image
                    .attr( 'src', imageSource )
                    .removeAttr('data-lazy data-srcset data-sizes')
                    .removeClass('slick-loading');

                if ( _.options.adaptiveHeight === true ) {
                    _.setPosition();
                }

                _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);
                _.progressiveLazyLoad();

            };

            imageToLoad.onerror = function() {

                if ( tryCount < 3 ) {

                    /**
                     * try to load the image 3 times,
                     * leave a slight delay so we don't get
                     * servers blocking the request.
                     */
                    setTimeout( function() {
                        _.progressiveLazyLoad( tryCount + 1 );
                    }, 500 );

                } else {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                    _.progressiveLazyLoad();

                }

            };

            imageToLoad.src = imageSource;

        } else {

            _.$slider.trigger('allImagesLoaded', [ _ ]);

        }

    };

    Slick.prototype.refresh = function( initializing ) {

        var _ = this, currentSlide, lastVisibleIndex;

        lastVisibleIndex = _.slideCount - _.options.slidesToShow;

        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {
            _.currentSlide = lastVisibleIndex;
        }

        // if less slides than to show, go to start.
        if ( _.slideCount <= _.options.slidesToShow ) {
            _.currentSlide = 0;

        }

        currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, { currentSlide: currentSlide });

        _.init();

        if( !initializing ) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);

        }

    };

    Slick.prototype.registerBreakpoints = function() {

        var _ = this, breakpoint, currentBreakpoint, l,
            responsiveSettings = _.options.responsive || null;

        if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {

            _.respondTo = _.options.respondTo || 'window';

            for ( breakpoint in responsiveSettings ) {

                l = _.breakpoints.length-1;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {
                    currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while( l >= 0 ) {
                        if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
                            _.breakpoints.splice(l,1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

                }

            }

            _.breakpoints.sort(function(a, b) {
                return ( _.options.mobileFirst ) ? a-b : b-a;
            });

        }

    };

    Slick.prototype.reinit = function() {

        var _ = this;

        _.$slides =
            _.$slideTrack
                .children(_.options.slide)
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        _.setPosition();
        _.focusHandler();

        _.paused = !_.options.autoplay;
        _.autoPlay();

        _.$slider.trigger('reInit', [_]);

    };

    Slick.prototype.resize = function() {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if( !_.unslicked ) { _.setPosition(); }
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.setCSS = function(position) {

        var _ = this,
            positionProps = {},
            x, y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    };

    Slick.prototype.setDimensions = function() {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();


        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

    };

    Slick.prototype.setFade = function() {

        var _ = this,
            targetLeft;

        _.$slides.each(function(index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });

    };

    Slick.prototype.setHeight = function() {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }

    };

    Slick.prototype.setOption =
    Slick.prototype.slickSetOption = function() {

        /**
         * accepts arguments in format of:
         *
         *  - for changing a single option's value:
         *     .slick("setOption", option, value, refresh )
         *
         *  - for changing a set of responsive options:
         *     .slick("setOption", 'responsive', [{}, ...], refresh )
         *
         *  - for updating multiple values at once (not responsive)
         *     .slick("setOption", { 'option': value, ... }, refresh )
         */

        var _ = this, l, item, option, value, refresh = false, type;

        if( $.type( arguments[0] ) === 'object' ) {

            option =  arguments[0];
            refresh = arguments[1];
            type = 'multiple';

        } else if ( $.type( arguments[0] ) === 'string' ) {

            option =  arguments[0];
            value = arguments[1];
            refresh = arguments[2];

            if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {

                type = 'responsive';

            } else if ( typeof arguments[1] !== 'undefined' ) {

                type = 'single';

            }

        }

        if ( type === 'single' ) {

            _.options[option] = value;


        } else if ( type === 'multiple' ) {

            $.each( option , function( opt, val ) {

                _.options[opt] = val;

            });


        } else if ( type === 'responsive' ) {

            for ( item in value ) {

                if( $.type( _.options.responsive ) !== 'array' ) {

                    _.options.responsive = [ value[item] ];

                } else {

                    l = _.options.responsive.length-1;

                    // loop through the responsive object and splice out duplicates.
                    while( l >= 0 ) {

                        if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {

                            _.options.responsive.splice(l,1);

                        }

                        l--;

                    }

                    _.options.responsive.push( value[item] );

                }

            }

        }

        if ( refresh ) {

            _.unload();
            _.reinit();

        }

    };

    Slick.prototype.setPosition = function() {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);

    };

    Slick.prototype.setProps = function() {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined ||
            bodyStyle.MozTransition !== undefined ||
            bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if ( _.options.fade ) {
            if ( typeof _.options.zIndex === 'number' ) {
                if( _.options.zIndex < 3 ) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
    };


    Slick.prototype.setSlideClasses = function(index) {

        var _ = this,
            centerOffset, allSlides, indexOffset, remainder;

        allSlides = _.$slider
            .find('.slick-slide')
            .removeClass('slick-active slick-center slick-current')
            .attr('aria-hidden', 'true');

        _.$slides
            .eq(index)
            .addClass('slick-current');

        if (_.options.centerMode === true) {

            var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
                    _.$slides
                        .slice(index - centerOffset + evenCoef, index + centerOffset + 1)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides
                        .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

                if (index === 0) {

                    allSlides
                        .eq(allSlides.length - 1 - _.options.slidesToShow)
                        .addClass('slick-center');

                } else if (index === _.slideCount - 1) {

                    allSlides
                        .eq(_.options.slidesToShow)
                        .addClass('slick-center');

                }

            }

            _.$slides
                .eq(index)
                .addClass('slick-center');

        } else {

            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

                _.$slides
                    .slice(index, index + _.options.slidesToShow)
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                    allSlides
                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    allSlides
                        .slice(indexOffset, indexOffset + _.options.slidesToShow)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

            }

        }

        if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
            _.lazyLoad();
        }
    };

    Slick.prototype.setupInfinite = function() {

        var _ = this,
            i, slideIndex, infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > (_.slideCount -
                        infiniteCount); i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex - _.slideCount)
                        .prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex + _.slideCount)
                        .appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                    $(this).attr('id', '');
                });

            }

        }

    };

    Slick.prototype.interrupt = function( toggle ) {

        var _ = this;

        if( !toggle ) {
            _.autoPlay();
        }
        _.interrupted = toggle;

    };

    Slick.prototype.selectHandler = function(event) {

        var _ = this;

        var targetElement =
            $(event.target).is('.slick-slide') ?
                $(event.target) :
                $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.slideHandler(index, false, true);
            return;

        }

        _.slideHandler(index);

    };

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
            _ = this, navTarget;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if ( _.options.autoplay ) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        if ( _.options.asNavFor ) {

            navTarget = _.getNavTarget();
            navTarget = navTarget.slick('getSlick');

            if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {
                navTarget.setSlideClasses(_.currentSlide);
            }

        }

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function() {
                    _.postSlide(animSlide);
                });

            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
            _.animateSlide(targetLeft, function() {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }

    };

    Slick.prototype.startLoad = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();

        }

        _.$slider.addClass('slick-loading');

    };

    Slick.prototype.swipeDirection = function() {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return (_.options.rtl === false ? 'right' : 'left');
        }
        if (_.options.verticalSwiping === true) {
            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                return 'down';
            } else {
                return 'up';
            }
        }

        return 'vertical';

    };

    Slick.prototype.swipeEnd = function(event) {

        var _ = this,
            slideCount,
            direction;

        _.dragging = false;
        _.swiping = false;

        if (_.scrolling) {
            _.scrolling = false;
            return false;
        }

        _.interrupted = false;
        _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;

        if ( _.touchObject.curX === undefined ) {
            return false;
        }

        if ( _.touchObject.edgeHit === true ) {
            _.$slider.trigger('edge', [_, _.swipeDirection() ]);
        }

        if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {

            direction = _.swipeDirection();

            switch ( direction ) {

                case 'left':
                case 'down':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide + _.getSlideCount() ) :
                            _.currentSlide + _.getSlideCount();

                    _.currentDirection = 0;

                    break;

                case 'right':
                case 'up':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide - _.getSlideCount() ) :
                            _.currentSlide - _.getSlideCount();

                    _.currentDirection = 1;

                    break;

                default:


            }

            if( direction != 'vertical' ) {

                _.slideHandler( slideCount );
                _.touchObject = {};
                _.$slider.trigger('swipe', [_, direction ]);

            }

        } else {

            if ( _.touchObject.startX !== _.touchObject.curX ) {

                _.slideHandler( _.currentSlide );
                _.touchObject = {};

            }

        }

    };

    Slick.prototype.swipeHandler = function(event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
            event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options
            .touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options
                .touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }

    };

    Slick.prototype.swipeMove = function(event) {

        var _ = this,
            edgeWasHit = false,
            curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        verticalSwipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

        if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
            _.scrolling = true;
            return false;
        }

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = verticalSwipeLength;
        }

        swipeDirection = _.swipeDirection();

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            _.swiping = true;
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }


        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function(event) {

        var _ = this,
            touches;

        _.interrupted = true;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;

    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.unload = function() {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides
            .removeClass('slick-slide slick-active slick-visible slick-current')
            .attr('aria-hidden', 'true')
            .css('width', '');

    };

    Slick.prototype.unslick = function(fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();

    };

    Slick.prototype.updateArrows = function() {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if ( _.options.arrows === true &&
            _.slideCount > _.options.slidesToShow &&
            !_.options.infinite ) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            }

        }

    };

    Slick.prototype.updateDots = function() {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots
                .find('li')
                    .removeClass('slick-active')
                    .end();

            _.$dots
                .find('li')
                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
                .addClass('slick-active');

        }

    };

    Slick.prototype.visibility = function() {

        var _ = this;

        if ( _.options.autoplay ) {

            if ( document[_.hidden] ) {

                _.interrupted = true;

            } else {

                _.interrupted = false;

            }

        }

    };

    $.fn.slick = function() {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i,
            ret;
        for (i = 0; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined')
                _[i].slick = new Slick(_[i], opt);
            else
                ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };

}));


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



var punycode = __webpack_require__(/*! punycode/ */ "./node_modules/punycode/punycode.js");

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  randomUUID
});

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/esm-browser/native.js");
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");




function v4(options, buf, offset) {
  if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
    return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./node_modules/validetta/dist/validetta.js":
/*!**************************************************!*\
  !*** ./node_modules/validetta/dist/validetta.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Validetta (https://github.com/PixelUnion/validetta)
 * Version 2.0.3
 * Licensed under MIT (https://github.com/hsnayd/validetta/blob/master/LICENCE)
 * Copyright 2013-2017 Hasan Aydoğdu - http://www.hasanaydogdu.com 
 */
/*eslint-env es6:false*/

(function($) {
  'use strict';
  /**
   *  Declare variables
   */
  var FIELDS = {}; // Current fields/fields
  // RegExp for input validation rules
  var RRULE = new RegExp(/^(minChecked|maxChecked|minSelected|maxSelected|minLength|maxLength|equalTo|different|regExp|remote|callback)\[(\w{1,15})\]/i);
  // RegExp for mail control method
  // @from (http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#e-mail-state-%28type=email%29)
  var RMAIL = new RegExp(/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/);
  //RegExp for input number control method
  var RNUMBER = new RegExp(/^[\-\+]?(\d+|\d+\.?\d+)$/);

  /**
   *  Form validate error messages
   */
  var messages = {
    required  : 'This field is required.',
    email     : 'Your E-mail address appears to be invalid.',
    number    : 'You can enter only numbers in this field.',
    numMax    : 'Please enter a number less than {max}.',
    numMin    : 'Please enter a number greater than {min}.',
    numRange  : 'Please enter a number greater than {min} and less than {max}.',
    maxLength : 'Maximum {count} characters allowed.',
    minLength : 'Minimum {count} characters allowed.',
    maxChecked  : 'Maximum {count} options allowed.',
    minChecked  : 'Please select minimum {count} options.',
    maxSelected : 'Maximum {count} selection allowed.',
    minSelected : 'Minimum {count} selection allowed.',
    notEqual    : 'Fields do not match.',
    different   : 'Fields cannot be the same as each other',
    creditCard  : 'Invalid credit card number.',
  };

  /**
   *  Plugin defaults
   */
  var defaults = {
    showErrorMessage : true, // If you dont want to display error messages set this options false
    showMultiple: false, // whether or not to show all errors on an input at once
    disableNative: true, // whether or not to show all errors on an input at once
    validationClass: 'form-input', // Class of elements to be validated
    inputWrapperClass : 'form-field', // Class of the parent container we want to append the error message to
    errorTemplateClass : 'form-inline-message', // Class of the error message string
    errorClass : 'form-field-invalid', // Class added to parent of each failing validation field
    validClass : 'form-field-valid', // Same for valid validation
    realTime: false, // To enable real-time form control, set this option true.
    onValid: function(){}, // This function to be called when the user submits the form and there is no error.
    onError: function(){}, // This function to be called when the user submits the form and there are some errors
    validators: {}, // Custom validators stored in this variable
  };

  /**
   * Clears the left and right spaces of given parameter.
   * This is the function for string parameter!
   * If parameter is an array, function will return the untrimmed parameter
   *
   * @param {string} value
   * @return {mixed}
   */
  var trim = function(value) {
    return typeof value === 'string' ? value.replace(/^\s+|\s+$/g, '') : value;
  };

  /**
   * Validator
   * {count} which used below is the specified maximum or minimum value
   * e.g if method is minLength and  rule is 2 (minLength[2])
   * Output error messages text will be : 'Please select minimum 2 options.'
   *
   * @namespace
   * @param {object} tmp = this.tmp Tmp object for store current field and its value
   * @param {String} val: field value
   */
  var Validator = {
    required: function(tmp, self) {
      switch (tmp.el.type) {
        case 'checkbox' : return tmp.el.checked || messages.required;
        case 'radio' : return this.radio.call(self, tmp.el) || messages.required;
        case 'select-multiple' : return tmp.val !== null || messages.required;
        case 'select-one' : return tmp.val !== null || messages.required;
        default : return tmp.val !== '' || messages.required;
      }
    },

    //  Mail check - it checks the value if it's a valid email address or not
    email: function(tmp) {
      return RMAIL.test(tmp.val) || messages.email;
    },

    // Number check
    number: function(tmp, self) {
      if (RNUMBER.test(tmp.val)) {
        var message;
        var val = parseInt(tmp.val, 10);
        var max = tmp.el.max ? parseInt(tmp.el.max, 10) : Infinity;
        var min = tmp.el.min ? parseInt(tmp.el.min, 10) : -Infinity;

        // check attributes and assign error messages, auto-validate if neither is applied to element
        if (tmp.el.max && tmp.el.min) {
          message = messages.numRange;
        } else if (tmp.el.max) {
          message = messages.numMax;
        } else if (tmp.el.min) {
          message = messages.numMin;
        } else {
          return true;
        }

        if (val >= min && val <= max) {
          return true;
        } else {
          return self.processNumberMessage(message, tmp.el.min, tmp.el.max);
        }
      } else {
        return messages.number;
      }
    },

    // Minimum length check
    minLength: function(tmp) {
      var _length = tmp.val.length;
      return _length === 0 || _length >= tmp.arg || messages.minLength.replace('{count}', tmp.arg);
    },

    // Maximum lenght check
    maxLength: function(tmp) {
      return tmp.val.length <= tmp.arg || messages.maxLength.replace('{count}', tmp.arg);
    },

    // equalTo check
    equalTo: function(tmp, self) {
      return self.form.querySelector('input[name="' + tmp.arg + '"]').value === tmp.val || messages.notEqual;
    },

    different: function(tmp, self) {
      return self.form.querySelector('input[name="' + tmp.arg + '"]').value !== tmp.val || messages.different;
    },

    /**
     * Credit Card Control
     * @from : http://af-design.com/blog/2010/08/18/validating-credit-card-numbers
     */
    creditCard: function(tmp) {
      if (tmp.val === '') return true; // allow empty because empty check does by required metheod
      var reg;
      var cardNumber;
      var pos;
      var digit;
      var i;
      var subTotal;
      var sum = 0;
      var strlen;
      reg = new RegExp(/[^0-9]+/g);
      cardNumber = tmp.val.replace(reg, '');
      strlen = cardNumber.length;
      if (strlen < 16) return messages.creditCard;
      for (i = 0 ; i < strlen ; i++) {
        pos = strlen - i;
        digit = parseInt(cardNumber.substring(pos - 1, pos), 10);
        if (i % 2 === 1) {
          subTotal = digit * 2 ;
          if (subTotal > 9) {
            subTotal = 1 + (subTotal - 10);
          }
        } else {
          subTotal = digit ;
        }
        sum += subTotal ;
      }
      if (sum > 0 && sum % 10 === 0) return true;
      return messages.creditCard;
    },

    //Checkbox check
    maxChecked: function(tmp, self) {
      var cont = $(self.form.querySelectorAll('input[type=checkbox][name="' + tmp.el.name + '"]'));
      var count =  cont.filter(':checked').length;
      if (count === 0) return;
      return count <= tmp.arg || messages.maxChecked.replace('{count}', tmp.arg);
    },

    minChecked: function(tmp, self) {
      var cont = $(self.form.querySelectorAll('input[type=checkbox][name="' + tmp.el.name + '"]'));
      var count =  cont.filter(':checked').length;
      return count >= tmp.arg || messages.minChecked.replace('{count}', tmp.arg);
    },

    //Selectbox check
    maxSelected: function(tmp) {
      if (tmp.val === null) return;
      return tmp.val.length <= tmp.arg || messages.maxSelected.replace('{count}', tmp.arg);
    },

    minSelected: function(tmp) {
      return (tmp.val !== null && tmp.val.length >= tmp.arg) || messages.minSelected.replace('{count}', tmp.arg);
    },

    // Radio
    radio: function(el) {
      var count = this.form.querySelectorAll('input[type=radio][name="' + el.name + '"]:checked').length;
      return count === 1;
    },

    // Custom reg check
    regExp: function(tmp, self) {
      var _arg = self.options.validators.regExp[tmp.arg];
      var _reg = new RegExp(_arg.pattern);
      return _reg.test(tmp.val) || _arg.errorMessage;
    },

    // Remote
    remote: function(tmp) {
      tmp.remote = tmp.arg;
      return;
    },

    // Callback
    callback: function(tmp, self) {
      var _cb = self.options.validators.callback[tmp.arg];
      return _cb.callback(tmp.el, tmp.val) || _cb.errorMessage;
    },
  };

  /**
   * Plugin Class
   *
   * @constructor
   * @param {object} form : <form> element which being controlled
   * @param {object} options : User-specified settings
   * @return {method} events
   */
  var Validetta = function(form, options) {
    /**
     *  Public  Properties
     *  @property {mixed} handler It is used to stop or resume submit event handler
     *  @property {object} options Property is stored in plugin options
     *  @property {object} xhr Stores xhr requests
     *  @property {object} form Property is stored in <form> element
     */
    this.handler = false;
    this.options = $.extend(true, {}, defaults, options);
    this.form = form;
    this.xhr = {};
    this.initializeForm();
    this.events();
  };

  Validetta.prototype = {

    constructor : Validetta,

    /**
     * Remove native browser validation from target form if applicable
     */
    initializeForm: function() {
      if (this.options.disableNative) {
        this.form.setAttribute('novalidate', true);
      }
    },

    /**
     * This is the method of handling events
     *
     * @return {mixed}
     */
    events: function() {
      var self = this; // stored this
      // Handle submit event
      $(this.form).submit(function(event) {
        // fields to be controlled transferred to global variable
        FIELDS = event.currentTarget.getElementsByClassName(self.options.validationClass);
        return self.init(event);
      });
      // real-time option control
      if (this.options.realTime === true) {
        // handle change event for form elements (without checkbox)
        $(this.form).find('.' + this.options.validationClass).not('[type=checkbox]').on('change', function(event) {
          // field to be controlled transferred to global variable
          FIELDS = $(self);
          return self.init(event);
        });
        // handle click event for checkboxes
        $(this.form).find('.' + this.options.validationClass + '[type=checkbox]').on('click', function(event) {
          // fields to be controlled transferred to global variable
          FIELDS = self.form.querySelectorAll('.' + self.options.validationClass + '[type=checkbox][name="' + self.name + '"]');
          return self.init(event);
        });
      }
      // handle <form> reset button to clear error messages
      $(this.form).on('reset', function() {
        $(self.form.querySelectorAll('.' + self.options.errorClass + ' , .' + self.options.validClass))
          .removeClass(self.options.errorClass + ' ' + self.options.validClass);
        return self.reset();
      });
    },

    /**
     * In this method, fields are validated
     *
     * @params {object} e : event object
     * @return {mixed}
     */
    init: function(event) {
      // Reset error messages from all elements
      this.reset(FIELDS);
      // Start control each elements
      this.checkFields(event);
      if (event.type !== 'submit') return; // if event type is not submit, break
      // This is for when running remote request, return false and wait request response
      else if (this.handler === 'pending') return false;
      // if event type is submit and handler is true, break submit and call onError() function
      else if (this.handler === true) { this.options.onError.call(this, event); return false; }
      else return this.options.onValid.call(this, event); // if form is valid call onValid() function
    },

    /**
     * Checks Fields
     *
     * @param  {object} e event object
     * @return {void}
     */
    checkFields: function(event) {
      var self = this; // stored this
      var invalidFields = [];

      // Make invalidFields accessible
      this.getInvalidFields = function(){
        return invalidFields;
      };

      for (var i = 0, _lengthFields = FIELDS.length; i < _lengthFields; i++) {
        // if field is disabled, do not check
        if (FIELDS[i].disabled) continue;
        var el = FIELDS[i]; //current field
        var errorMessages = ''; //current field's errors
        var val = trim($(el).val()); //current field's value
        var methods = self.getInputValidators(el); //current field's control methods
        var state; // Validation state
        // Create tmp
        this.tmp = {};
        // store el and val variables in tmp
        this.tmp = { el : el, val : val, parent : this.parents(el) };
        // Start to check fields
        // Validator : Fields Control Object
        for (var j = 0, _lengthMethods = methods.length; j < _lengthMethods; j++) {
          // Check Rule
          var rule = methods[j].match(RRULE);
          var method;
          // Does it have rule?
          if (rule !== null) {
            // Does it have any argument ?
            if (typeof rule[2] !== 'undefined') this.tmp.arg = rule[2];
            // Set method name
            method = rule[1];
          } else { method = methods[j]; }
          // prevent empty validation if method is not required
          if (val === '' && method !== 'required' && method !== 'equalTo') continue;
          // Is there a method in Validator ?
          if (Validator.hasOwnProperty(method)) {
            // Validator returns error message if method invalid
            state = Validator[method](self.tmp, self);
            if (typeof state !== 'undefined' && state !== true) {
              var _dataMsg = el.getAttribute('data-vd-message-' + method);
              // is there a custom message?
              if (_dataMsg !== null) {
                state = _dataMsg;
                // add our min and max values if it's a number input
                if (method === 'number') {
                  state = this.processNumberMessage(state, this.tmp.el.min, this.tmp.el.max);
                }
              }
              if (this.options.showMultiple) {
                // show all states that return invalid
                errorMessages += state + '<br>';
              } else {
                // just show the last one
                errorMessages = state;
              }
            }
          }
        }

        // Check the errors
        if (errorMessages !== '') {
          invalidFields.push({
            field: el,
            errors: errorMessages,
          });
          // if parent element has valid class, remove and add error class
          this.addErrorClass(this.tmp.parent);
          // show error message
          this.notify.show.call(this , el, errorMessages);
        // Check remote validation
        } else if (typeof this.tmp.remote !== 'undefined') {
          this.checkRemote(el, event);
        } else { // Nice, there are no error
          if (typeof state !== 'undefined') this.addValidClass(this.tmp.parent);
          else $(this.tmp.parent).removeClass(this.options.errorClass + ' ' + this.options.validClass);
          state = undefined; // Reset state variable
        }
      }
    },

    /**
     * Determines what validators to run per input
     *
     * @param  {object} el current field
     * @return {array} a list of all validators to run against the input's value
     */
    getInputValidators: function(el) {
      // validators defined outside of native html5 attrs
      var validators = el.hasAttribute('data-validates') ? el.getAttribute('data-validates').split(',') : [];

      if (el.required && validators.indexOf('required') === -1) validators.push('required');
      if (el.type === 'number' && validators.indexOf('number') === -1) validators.push('number');
      if (el.type === 'email' && validators.indexOf('email') === -1) validators.push('email');

      return validators;
    },

    /**
     * Checks remote validations
     *
     * @param  {object} el current field
     * @param  {object} e event object
     * @throws {error} If previous remote request for same value has rejected
     * @return {void}
     */
    checkRemote: function(el, event) {
      var ajaxOptions = {};
      var data = {};
      var fieldName = el.name || el.id;

      if (typeof this.remoteCache === 'undefined') this.remoteCache = {};

      data[fieldName] = this.tmp.val; // Set data
      // exends ajax options
      ajaxOptions = $.extend(true, {}, {
        data: data,
      }, this.options.validators.remote[this.tmp.remote] || {});

      // use $.param() function for generate specific cache key
      var cacheKey = $.param(ajaxOptions);

      // Check cache
      var cache = this.remoteCache[cacheKey];

      if (typeof cache !== 'undefined') {
        switch(cache.state) {
          case 'pending' : // pending means remote request not finished yet
            this.handler = 'pending'; // update handler and cache event type
            cache.event = event.type;
            break;
          case 'rejected' : // rejected means remote request could not be performed
            event.preventDefault(); // we have to break submit because of throw error
            throw new Error(cache.result.message);
          case 'resolved' : // resolved means remote request has done
            // Check to cache, if result is invalid, show an error message
            if (cache.result.valid === false) {
              this.addErrorClass(this.tmp.parent);
              this.notify.show.call(this, el, cache.result.message);
            } else {
              this.addValidClass(this.tmp.parent);
            }
        }
      } else {
        // Abort if previous ajax request still running
        var _xhr = this.xhr[fieldName];
        if (typeof _xhr !== 'undefined' && _xhr.state() === 'pending') _xhr.abort();
        // Start caching
        cache = this.remoteCache[cacheKey] = { state : 'pending', event : event.type };
        // make a remote request
        this.remoteRequest(ajaxOptions, cache, el, fieldName);
      }
    },

    /**
     * Calls ajax request for remote validations
     *
     * @param  {object} ajaxOptions Ajax options
     * @param  {object} cache Cache object
     * @param  {object} el processing element
     * @param  {string} fieldName Field name for make specific caching
     * @param  {object} event Event object
     */
    remoteRequest: function(ajaxOptions, cache, el, fieldName) {
      var self = this;

      $(this.tmp.parent).addClass('validetta-pending');

      // cache xhr
      this.xhr[fieldName] = $.ajax(ajaxOptions)
        .done(function(result) {
          if (typeof result !== 'object') result = JSON.parse(result);
          cache.state = 'resolved';
          cache.result = result;
          if (cache.event === 'submit') {
            self.handler = false;
            $(self.form).trigger('submit');
          } else if (result.valid === false) {
            self.addErrorClass(self.tmp.parent);
            self.notify.show.call(self, el, result.message);
          } else {
            self.addValidClass(self.tmp.parent);
          }
        })
        .fail(function(jqXHR, textStatus) {
          if (textStatus !== 'abort') { // Dont throw error if request is aborted
            var _msg = 'Ajax request failed for field (' + fieldName + ') : ' + jqXHR.status + ' ' + jqXHR.statusText;
            cache.state = 'rejected';
            cache.result = { valid: false, message : _msg };
            throw new Error(_msg);
          }
        })
        .always(function() { $(self.tmp.parent).removeClass('validetta-pending'); });

      this.handler = 'pending';
    },

    /**
     * Showing or hiding error messages
     *
     * @namespace
     */
    notify: {
      /**
       * Error message shows
       *
       * @params {object} el : element which has an error (it can be native element or jQuery object)
       * @params {string} error : error messages
       */
      show: function(el, error) {
        // We want display errors ?
        if (!this.options.showErrorMessage) {
          // because of form not valid, set handler true for break submit
          this.handler = true;
          return;
        }
        var elParent = this.parents(el);
        // If the parent element undefined, that means el is an object. So we need to transform to the element
        if (typeof elParent === 'undefined') elParent = el[0].parentNode;
        // if there is an error message which previously shown for el, return
        if (elParent.querySelectorAll('.' + this.options.errorTemplateClass).length) return;
        // Create the error message object
        var errorObject = document.createElement('span');
        errorObject.className = this.options.errorTemplateClass;
        elParent.appendChild(errorObject);
        errorObject.innerHTML = error ;

        // we have an error so we need to break submit
        // set to handler true
        this.handler = true;
      },
      /**
       * Error message hides
       *
       * @params el : the error message which will be disappear
       */
      hide: function(el) {
        el.parentNode.removeChild(el);
      },
    },


    /**
     * Removes all error messages
     *
     * @param {object} or {void} el : form elements which have an error message
     */
    reset: function(el) {
      var _errorMessages = {};
      // if el is undefined (This is the process of resetting all <form>)
      // or el is an object that has element more than one
      // and these elements are not checkbox
      if (typeof el === 'undefined' || (el.length > 1 && el[0].type !== 'checkbox')) {
        _errorMessages = this.form.querySelectorAll('.' + this.options.errorTemplateClass);
      } else {
        _errorMessages = this.parents(el[0]).querySelectorAll('.' + this.options.errorTemplateClass);
      }
      for (var i = 0, _lengthErrorMessages = _errorMessages.length; i < _lengthErrorMessages; i++) {
        this.notify.hide.call(this, _errorMessages[i]);
      }
      // set to handler false
      // otherwise at the next validation attempt, submit will not continue even the validation is successful
      this.handler = false;
    },

    /**
     * Adds error class and removes valid class if exist
     *
     * @param {object} el element
     */
    addErrorClass: function(el) {
      $(el).removeClass(this.options.validClass).addClass(this.options.errorClass);
    },

    /**
     * Adds valid class and removes error class if exist
     * if error class not exist, do not add valid class
     *
     * @param {object} el element
     */
    addValidClass: function(el) {
      $(el).removeClass(this.options.errorClass).addClass(this.options.validClass);
    },

    /**
     * Finds parent element
     *
     * @param  {object} el element
     * @return {object} el parent element
     */
    parents: function(el) {
      return $(el).parents('.' + this.options.inputWrapperClass)[0];
    },

    /**
     * Replaces min & ma placeholders in number inputs
     *
     * @param {string} message - raw error message
     * @param {string} min - the input's min range (can be null)
     * @param {string} max - the input's max range (can be null)
     * @return {string} message - processed message
     */
    processNumberMessage: function(message, min, max) {
      if (min) message = message.replace('{min}', min);
      if (max) message = message.replace('{max}', max);
      return message;
    },
  };

  /**
   * Plugin Validetta
   *
   * @param {object} options : User-specified settings
   * @return {object} this
   */
  $.fn.validetta = function(options, _messages) {
    if (typeof _messages !== 'undefined') {
      messages = $.extend(true, {}, messages, _messages);
    }
    return this.each(function() {
      new Validetta(this, options);
    });
  };
})(jQuery);


/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DOMException: () => (/* binding */ DOMException),
/* harmony export */   Headers: () => (/* binding */ Headers),
/* harmony export */   Request: () => (/* binding */ Request),
/* harmony export */   Response: () => (/* binding */ Response),
/* harmony export */   fetch: () => (/* binding */ fetch)
/* harmony export */ });
/* eslint-disable no-prototype-builtins */
var g =
  (typeof globalThis !== 'undefined' && globalThis) ||
  (typeof self !== 'undefined' && self) ||
  // eslint-disable-next-line no-undef
  (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g) ||
  {}

var support = {
  searchParams: 'URLSearchParams' in g,
  iterable: 'Symbol' in g && 'iterator' in Symbol,
  blob:
    'FileReader' in g &&
    'Blob' in g &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in g,
  arrayBuffer: 'ArrayBuffer' in g
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length)
      }
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body._noBody) return
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type)
  var encoding = match ? match[1] : 'utf-8'
  reader.readAsText(blob, encoding)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    // eslint-disable-next-line no-self-assign
    this.bodyUsed = this.bodyUsed
    this._bodyInit = body
    if (!body) {
      this._noBody = true;
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }
  }

  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this)
      if (isConsumed) {
        return isConsumed
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        )
      } else {
        return Promise.resolve(this._bodyArrayBuffer)
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer)
    } else {
      throw new Error('could not read as ArrayBuffer')
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }

  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal || (function () {
    if ('AbortController' in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }());
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
      }
    }
  }
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders
    .split('\r')
    .map(function(header) {
      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
    })
    .forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        try {
          headers.append(key, value)
        } catch (error) {
          console.warn('Response ' + error.message)
        }
      }
    })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].")
  }
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 200, statusText: ''})
  response.ok = false
  response.status = 0
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = g.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      // This check if specifically for when a user fetches a file locally from the file system
      // Only if the status is out of a normal range
      if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      setTimeout(function() {
        resolve(new Response(body, options))
      }, 0)
    }

    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError('Network request timed out'))
      }, 0)
    }

    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException('Aborted', 'AbortError'))
      }, 0)
    }

    function fixUrl(url) {
      try {
        return url === '' && g.location.href ? g.location.href : url
      } catch (e) {
        return url
      }
    }

    xhr.open(request.method, fixUrl(request.url), true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob'
      } else if (
        support.arrayBuffer
      ) {
        xhr.responseType = 'arraybuffer'
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name))
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))
      })
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value)
        }
      })
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!g.fetch) {
  g.fetch = fetch
  g.Headers = Headers
  g.Request = Request
  g.Response = Response
}


/***/ }),

/***/ "./node_modules/zero-fill/index.js":
/*!*****************************************!*\
  !*** ./node_modules/zero-fill/index.js ***!
  \*****************************************/
/***/ ((module) => {

/*! zero-fill. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Given a number, return a zero-filled string.
 * From http://stackoverflow.com/questions/1267283/
 * @param  {number} width
 * @param  {number} number
 * @return {string}
 */
module.exports = function zeroFill (width, number, pad) {
  if (number === undefined) {
    return function (number, pad) {
      return zeroFill(width, number, pad)
    }
  }
  if (pad === undefined) pad = '0'
  width -= number.toString().length
  if (width > 0) return new Array(width + (/\./.test(number) ? 2 : 1)).join(pad) + number
  return number + ''
}


/***/ }),

/***/ "?4f7e":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/async/dist/async.mjs":
/*!*******************************************!*\
  !*** ./node_modules/async/dist/async.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* binding */ every$1),
/* harmony export */   allLimit: () => (/* binding */ everyLimit$1),
/* harmony export */   allSeries: () => (/* binding */ everySeries$1),
/* harmony export */   any: () => (/* binding */ some$1),
/* harmony export */   anyLimit: () => (/* binding */ someLimit$1),
/* harmony export */   anySeries: () => (/* binding */ someSeries$1),
/* harmony export */   apply: () => (/* binding */ apply),
/* harmony export */   applyEach: () => (/* binding */ applyEach),
/* harmony export */   applyEachSeries: () => (/* binding */ applyEachSeries),
/* harmony export */   asyncify: () => (/* binding */ asyncify),
/* harmony export */   auto: () => (/* binding */ auto),
/* harmony export */   autoInject: () => (/* binding */ autoInject),
/* harmony export */   cargo: () => (/* binding */ cargo$1),
/* harmony export */   cargoQueue: () => (/* binding */ cargo),
/* harmony export */   compose: () => (/* binding */ compose),
/* harmony export */   concat: () => (/* binding */ concat$1),
/* harmony export */   concatLimit: () => (/* binding */ concatLimit$1),
/* harmony export */   concatSeries: () => (/* binding */ concatSeries$1),
/* harmony export */   constant: () => (/* binding */ constant$1),
/* harmony export */   "default": () => (/* binding */ index),
/* harmony export */   detect: () => (/* binding */ detect$1),
/* harmony export */   detectLimit: () => (/* binding */ detectLimit$1),
/* harmony export */   detectSeries: () => (/* binding */ detectSeries$1),
/* harmony export */   dir: () => (/* binding */ dir),
/* harmony export */   doDuring: () => (/* binding */ doWhilst$1),
/* harmony export */   doUntil: () => (/* binding */ doUntil),
/* harmony export */   doWhilst: () => (/* binding */ doWhilst$1),
/* harmony export */   during: () => (/* binding */ whilst$1),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   eachLimit: () => (/* binding */ eachLimit$1),
/* harmony export */   eachOf: () => (/* binding */ eachOf$1),
/* harmony export */   eachOfLimit: () => (/* binding */ eachOfLimit$1),
/* harmony export */   eachOfSeries: () => (/* binding */ eachOfSeries$1),
/* harmony export */   eachSeries: () => (/* binding */ eachSeries$1),
/* harmony export */   ensureAsync: () => (/* binding */ ensureAsync),
/* harmony export */   every: () => (/* binding */ every$1),
/* harmony export */   everyLimit: () => (/* binding */ everyLimit$1),
/* harmony export */   everySeries: () => (/* binding */ everySeries$1),
/* harmony export */   filter: () => (/* binding */ filter$1),
/* harmony export */   filterLimit: () => (/* binding */ filterLimit$1),
/* harmony export */   filterSeries: () => (/* binding */ filterSeries$1),
/* harmony export */   find: () => (/* binding */ detect$1),
/* harmony export */   findLimit: () => (/* binding */ detectLimit$1),
/* harmony export */   findSeries: () => (/* binding */ detectSeries$1),
/* harmony export */   flatMap: () => (/* binding */ concat$1),
/* harmony export */   flatMapLimit: () => (/* binding */ concatLimit$1),
/* harmony export */   flatMapSeries: () => (/* binding */ concatSeries$1),
/* harmony export */   foldl: () => (/* binding */ reduce$1),
/* harmony export */   foldr: () => (/* binding */ reduceRight),
/* harmony export */   forEach: () => (/* binding */ each),
/* harmony export */   forEachLimit: () => (/* binding */ eachLimit$1),
/* harmony export */   forEachOf: () => (/* binding */ eachOf$1),
/* harmony export */   forEachOfLimit: () => (/* binding */ eachOfLimit$1),
/* harmony export */   forEachOfSeries: () => (/* binding */ eachOfSeries$1),
/* harmony export */   forEachSeries: () => (/* binding */ eachSeries$1),
/* harmony export */   forever: () => (/* binding */ forever$1),
/* harmony export */   groupBy: () => (/* binding */ groupBy),
/* harmony export */   groupByLimit: () => (/* binding */ groupByLimit$1),
/* harmony export */   groupBySeries: () => (/* binding */ groupBySeries),
/* harmony export */   inject: () => (/* binding */ reduce$1),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   map: () => (/* binding */ map$1),
/* harmony export */   mapLimit: () => (/* binding */ mapLimit$1),
/* harmony export */   mapSeries: () => (/* binding */ mapSeries$1),
/* harmony export */   mapValues: () => (/* binding */ mapValues),
/* harmony export */   mapValuesLimit: () => (/* binding */ mapValuesLimit$1),
/* harmony export */   mapValuesSeries: () => (/* binding */ mapValuesSeries),
/* harmony export */   memoize: () => (/* binding */ memoize),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   parallel: () => (/* binding */ parallel),
/* harmony export */   parallelLimit: () => (/* binding */ parallelLimit),
/* harmony export */   priorityQueue: () => (/* binding */ priorityQueue),
/* harmony export */   queue: () => (/* binding */ queue),
/* harmony export */   race: () => (/* binding */ race$1),
/* harmony export */   reduce: () => (/* binding */ reduce$1),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   reflect: () => (/* binding */ reflect),
/* harmony export */   reflectAll: () => (/* binding */ reflectAll),
/* harmony export */   reject: () => (/* binding */ reject$1),
/* harmony export */   rejectLimit: () => (/* binding */ rejectLimit$1),
/* harmony export */   rejectSeries: () => (/* binding */ rejectSeries$1),
/* harmony export */   retry: () => (/* binding */ retry),
/* harmony export */   retryable: () => (/* binding */ retryable),
/* harmony export */   select: () => (/* binding */ filter$1),
/* harmony export */   selectLimit: () => (/* binding */ filterLimit$1),
/* harmony export */   selectSeries: () => (/* binding */ filterSeries$1),
/* harmony export */   seq: () => (/* binding */ seq),
/* harmony export */   series: () => (/* binding */ series),
/* harmony export */   setImmediate: () => (/* binding */ setImmediate$1),
/* harmony export */   some: () => (/* binding */ some$1),
/* harmony export */   someLimit: () => (/* binding */ someLimit$1),
/* harmony export */   someSeries: () => (/* binding */ someSeries$1),
/* harmony export */   sortBy: () => (/* binding */ sortBy$1),
/* harmony export */   timeout: () => (/* binding */ timeout),
/* harmony export */   times: () => (/* binding */ times),
/* harmony export */   timesLimit: () => (/* binding */ timesLimit),
/* harmony export */   timesSeries: () => (/* binding */ timesSeries),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   tryEach: () => (/* binding */ tryEach$1),
/* harmony export */   unmemoize: () => (/* binding */ unmemoize),
/* harmony export */   until: () => (/* binding */ until),
/* harmony export */   waterfall: () => (/* binding */ waterfall$1),
/* harmony export */   whilst: () => (/* binding */ whilst$1),
/* harmony export */   wrapSync: () => (/* binding */ asyncify)
/* harmony export */ });
/**
 * Creates a continuation function with some arguments already applied.
 *
 * Useful as a shorthand when combined with other control flow functions. Any
 * arguments passed to the returned function are added to the arguments
 * originally passed to apply.
 *
 * @name apply
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {Function} fn - The function you want to eventually apply all
 * arguments to. Invokes with (arguments...).
 * @param {...*} arguments... - Any number of arguments to automatically apply
 * when the continuation is called.
 * @returns {Function} the partially-applied function
 * @example
 *
 * // using apply
 * async.parallel([
 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
 *     async.apply(fs.writeFile, 'testfile2', 'test2')
 * ]);
 *
 *
 * // the same process without using apply
 * async.parallel([
 *     function(callback) {
 *         fs.writeFile('testfile1', 'test1', callback);
 *     },
 *     function(callback) {
 *         fs.writeFile('testfile2', 'test2', callback);
 *     }
 * ]);
 *
 * // It's possible to pass any number of additional arguments when calling the
 * // continuation:
 *
 * node> var fn = async.apply(sys.puts, 'one');
 * node> fn('two', 'three');
 * one
 * two
 * three
 */
function apply(fn, ...args) {
    return (...callArgs) => fn(...args,...callArgs);
}

function initialParams (fn) {
    return function (...args/*, callback*/) {
        var callback = args.pop();
        return fn.call(this, args, callback);
    };
}

/* istanbul ignore file */

var hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;
var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
}

var _defer$1;

if (hasQueueMicrotask) {
    _defer$1 = queueMicrotask;
} else if (hasSetImmediate) {
    _defer$1 = setImmediate;
} else if (hasNextTick) {
    _defer$1 = process.nextTick;
} else {
    _defer$1 = fallback;
}

var setImmediate$1 = wrap(_defer$1);

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    if (isAsync(func)) {
        return function (...args/*, callback*/) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback)
        }
    }

    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (result && typeof result.then === 'function') {
            return handlePromise(result, callback)
        } else {
            callback(null, result);
        }
    });
}

function handlePromise(promise, callback) {
    return promise.then(value => {
        invokeCallback(callback, null, value);
    }, err => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (err) {
        setImmediate$1(e => { throw e }, err);
    }
}

function isAsync(fn) {
    return fn[Symbol.toStringTag] === 'AsyncFunction';
}

function isAsyncGenerator(fn) {
    return fn[Symbol.toStringTag] === 'AsyncGenerator';
}

function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === 'function';
}

function wrapAsync(asyncFn) {
    if (typeof asyncFn !== 'function') throw new Error('expected a function')
    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}

// conditionally promisify a function.
// only return a promise if a callback is omitted
function awaitify (asyncFn, arity) {
    if (!arity) arity = asyncFn.length;
    if (!arity) throw new Error('arity is undefined')
    function awaitable (...args) {
        if (typeof args[arity - 1] === 'function') {
            return asyncFn.apply(this, args)
        }

        return new Promise((resolve, reject) => {
            args[arity - 1] = (err, ...cbArgs) => {
                if (err) return reject(err)
                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
        })
    }

    return awaitable
}

function applyEach$1 (eachfn) {
    return function applyEach(fns, ...callArgs) {
        const go = awaitify(function (callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
                wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
        });
        return go;
    };
}

function _asyncMap(eachfn, arr, iteratee, callback) {
    arr = arr || [];
    var results = [];
    var counter = 0;
    var _iteratee = wrapAsync(iteratee);

    return eachfn(arr, (value, _, iterCb) => {
        var index = counter++;
        _iteratee(value, (err, v) => {
            results[index] = v;
            iterCb(err);
        });
    }, err => {
        callback(err, results);
    });
}

function isArrayLike(value) {
    return value &&
        typeof value.length === 'number' &&
        value.length >= 0 &&
        value.length % 1 === 0;
}

// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
const breakLoop = {};

function once(fn) {
    function wrapper (...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper
}

function getIterator (coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
}

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? {value: coll[i], key: i} : null;
    }
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done)
            return null;
        i++;
        return {value: item.value, key: i};
    }
}

function createObjectIterator(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        if (key === '__proto__') {
            return next();
        }
        return i < len ? {value: obj[key], key} : null;
    };
}

function createIterator(coll) {
    if (isArrayLike(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = getIterator(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}

function onlyOnce(fn) {
    return function (...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    };
}

// for async generators
function asyncEachOfLimit(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;

    function replenish() {
        //console.log('replenish')
        if (running >= limit || awaiting || done) return
        //console.log('replenish awaiting')
        awaiting = true;
        generator.next().then(({value, done: iterDone}) => {
            //console.log('got value', value)
            if (canceled || done) return
            awaiting = false;
            if (iterDone) {
                done = true;
                if (running <= 0) {
                    //console.log('done nextCb')
                    callback(null);
                }
                return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
        }).catch(handleError);
    }

    function iterateeCallback(err, result) {
        //console.log('iterateeCallback')
        running -= 1;
        if (canceled) return
        if (err) return handleError(err)

        if (err === false) {
            done = true;
            canceled = true;
            return
        }

        if (result === breakLoop || (done && running <= 0)) {
            done = true;
            //console.log('done iterCb')
            return callback(null);
        }
        replenish();
    }

    function handleError(err) {
        if (canceled) return
        awaiting = false;
        done = true;
        callback(err);
    }

    replenish();
}

var eachOfLimit$2 = (limit) => {
    return (obj, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
            throw new RangeError('concurrency limit cannot be less than 1')
        }
        if (!obj) {
            return callback(null);
        }
        if (isAsyncGenerator(obj)) {
            return asyncEachOfLimit(obj, limit, iteratee, callback)
        }
        if (isAsyncIterable(obj)) {
            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)
        }
        var nextElem = createIterator(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;

        function iterateeCallback(err, value) {
            if (canceled) return
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            }
            else if (err === false) {
                done = true;
                canceled = true;
            }
            else if (value === breakLoop || (done && running <= 0)) {
                done = true;
                return callback(null);
            }
            else if (!looping) {
                replenish();
            }
        }

        function replenish () {
            looping = true;
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
        }

        replenish();
    };
};

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfLimit(coll, limit, iteratee, callback) {
    return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
}

var eachOfLimit$1 = awaitify(eachOfLimit, 4);

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = once(callback);
    var index = 0,
        completed = 0,
        {length} = coll,
        canceled = false;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err === false) {
            canceled = true;
        }
        if (canceled === true) return
        if (err) {
            callback(err);
        } else if ((++completed === length) || value === breakLoop) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, onlyOnce(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
function eachOfGeneric (coll, iteratee, callback) {
    return eachOfLimit$1(coll, Infinity, iteratee, callback);
}

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dev.json is a file containing a valid json object config for dev environment
 * // dev.json is a file containing a valid json object config for test environment
 * // prod.json is a file containing a valid json object config for prod environment
 * // invalid.json is a file with a malformed json object
 *
 * let configs = {}; //global variable
 * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};
 * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};
 *
 * // asynchronous function that reads a json file and parses the contents as json object
 * function parseFile(file, key, callback) {
 *     fs.readFile(file, "utf8", function(err, data) {
 *         if (err) return calback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }
 *
 * // Using callbacks
 * async.forEachOf(validConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *     } else {
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *         // JSON parse error exception
 *     } else {
 *         console.log(configs);
 *     }
 * });
 *
 * // Using Promises
 * async.forEachOf(validConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 *     // configs is now a map of JSON data, e.g.
 *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 * }).catch( err => {
 *     console.error(err);
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 * }).catch( err => {
 *     console.error(err);
 *     // JSON parse error exception
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.forEachOf(validConfigFileMap, parseFile);
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * //Error handing
 * async () => {
 *     try {
 *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);
 *         console.log(configs);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // JSON parse error exception
 *     }
 * }
 *
 */
function eachOf(coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, wrapAsync(iteratee), callback);
}

var eachOf$1 = awaitify(eachOf, 3);

/**
 * Produces a new collection of values by mapping each value in `coll` through
 * the `iteratee` function. The `iteratee` is called with an item from `coll`
 * and a callback for when it has finished processing. Each of these callbacks
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
 * `iteratee` passes an error to its callback, the main `callback` (for the
 * `map` function) is immediately called with the error.
 *
 * Note, that since this function applies the `iteratee` to each item in
 * parallel, there is no guarantee that the `iteratee` functions will complete
 * in order. However, the results array will be in the same order as the
 * original `coll`.
 *
 * If `map` is passed an Object, the results will be an Array.  The results
 * will roughly be in the order of the original Objects' keys (but this can
 * vary across JavaScript engines).
 *
 * @name map
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an Array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 * // file4.txt does not exist
 *
 * const fileList = ['file1.txt','file2.txt','file3.txt'];
 * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
 *
 * // asynchronous function that returns the file size in bytes
 * function getFileSizeInBytes(file, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         callback(null, stat.size);
 *     });
 * }
 *
 * // Using callbacks
 * async.map(fileList, getFileSizeInBytes, function(err, results) {
 *     if (err) {
 *         console.log(err);
 *     } else {
 *         console.log(results);
 *         // results is now an array of the file size in bytes for each file, e.g.
 *         // [ 1000, 2000, 3000]
 *     }
 * });
 *
 * // Error Handling
 * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {
 *     if (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     } else {
 *         console.log(results);
 *     }
 * });
 *
 * // Using Promises
 * async.map(fileList, getFileSizeInBytes)
 * .then( results => {
 *     console.log(results);
 *     // results is now an array of the file size in bytes for each file, e.g.
 *     // [ 1000, 2000, 3000]
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.map(withMissingFileList, getFileSizeInBytes)
 * .then( results => {
 *     console.log(results);
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let results = await async.map(fileList, getFileSizeInBytes);
 *         console.log(results);
 *         // results is now an array of the file size in bytes for each file, e.g.
 *         // [ 1000, 2000, 3000]
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         let results = await async.map(withMissingFileList, getFileSizeInBytes);
 *         console.log(results);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     }
 * }
 *
 */
function map (coll, iteratee, callback) {
    return _asyncMap(eachOf$1, coll, iteratee, callback)
}
var map$1 = awaitify(map, 3);

/**
 * Applies the provided arguments to each function in the array, calling
 * `callback` after all functions have completed. If you only provide the first
 * argument, `fns`, then it will return a function which lets you pass in the
 * arguments as if it were a single function call. If more arguments are
 * provided, `callback` is required while `args` is still optional. The results
 * for each of the applied async functions are passed to the final callback
 * as an array.
 *
 * @name applyEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s
 * to all call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {AsyncFunction} - Returns a function that takes no args other than
 * an optional callback, that is the result of applying the `args` to each
 * of the functions.
 * @example
 *
 * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')
 *
 * appliedFn((err, results) => {
 *     // results[0] is the results for `enableSearch`
 *     // results[1] is the results for `updateSchema`
 * });
 *
 * // partial application example:
 * async.each(
 *     buckets,
 *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),
 *     callback
 * );
 */
var applyEach = applyEach$1(map$1);

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfSeries(coll, iteratee, callback) {
    return eachOfLimit$1(coll, 1, iteratee, callback)
}
var eachOfSeries$1 = awaitify(eachOfSeries, 3);

/**
 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
 *
 * @name mapSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 */
function mapSeries (coll, iteratee, callback) {
    return _asyncMap(eachOfSeries$1, coll, iteratee, callback)
}
var mapSeries$1 = awaitify(mapSeries, 3);

/**
 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
 *
 * @name applyEachSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all
 * call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {AsyncFunction} - A function, that when called, is the result of
 * appling the `args` to the list of functions.  It takes no args, other than
 * a callback.
 */
var applyEachSeries = applyEach$1(mapSeries$1);

const PROMISE_SYMBOL = Symbol('promiseCallback');

function promiseCallback () {
    let resolve, reject;
    function callback (err, ...args) {
        if (err) return reject(err)
        resolve(args.length > 1 ? args : args[0]);
    }

    callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res,
        reject = rej;
    });

    return callback
}

/**
 * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
 * their requirements. Each function can optionally depend on other functions
 * being completed first, and each function is run as soon as its requirements
 * are satisfied.
 *
 * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
 * will stop. Further tasks will not execute (so any other functions depending
 * on it will not run), and the main `callback` is immediately called with the
 * error.
 *
 * {@link AsyncFunction}s also receive an object containing the results of functions which
 * have completed so far as the first argument, if they have dependencies. If a
 * task function has no dependencies, it will only be passed a callback.
 *
 * @name auto
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Object} tasks - An object. Each of its properties is either a
 * function or an array of requirements, with the {@link AsyncFunction} itself the last item
 * in the array. The object's key of a property serves as the name of the task
 * defined by that property, i.e. can be used when specifying requirements for
 * other tasks. The function receives one or two arguments:
 * * a `results` object, containing the results of the previously executed
 *   functions, only passed if the task has any dependencies,
 * * a `callback(err, result)` function, which must be called when finished,
 *   passing an `error` (which can be `null`) and the result of the function's
 *   execution.
 * @param {number} [concurrency=Infinity] - An optional `integer` for
 * determining the maximum number of tasks that can be run in parallel. By
 * default, as many as possible.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback. Results are always returned; however, if an
 * error occurs, no further `tasks` will be performed, and the results object
 * will only contain partial results. Invoked with (err, results).
 * @returns {Promise} a promise, if a callback is not passed
 * @example
 *
 * //Using Callbacks
 * async.auto({
 *     get_data: function(callback) {
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: ['get_data', 'make_folder', function(results, callback) {
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(results, callback) {
 *         // once the file is written let's email a link to it...
 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
 *     }]
 * }, function(err, results) {
 *     if (err) {
 *         console.log('err = ', err);
 *     }
 *     console.log('results = ', results);
 *     // results = {
 *     //     get_data: ['data', 'converted to array']
 *     //     make_folder; 'folder',
 *     //     write_file: 'filename'
 *     //     email_link: { file: 'filename', email: 'user@example.com' }
 *     // }
 * });
 *
 * //Using Promises
 * async.auto({
 *     get_data: function(callback) {
 *         console.log('in get_data');
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         console.log('in make_folder');
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: ['get_data', 'make_folder', function(results, callback) {
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(results, callback) {
 *         // once the file is written let's email a link to it...
 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
 *     }]
 * }).then(results => {
 *     console.log('results = ', results);
 *     // results = {
 *     //     get_data: ['data', 'converted to array']
 *     //     make_folder; 'folder',
 *     //     write_file: 'filename'
 *     //     email_link: { file: 'filename', email: 'user@example.com' }
 *     // }
 * }).catch(err => {
 *     console.log('err = ', err);
 * });
 *
 * //Using async/await
 * async () => {
 *     try {
 *         let results = await async.auto({
 *             get_data: function(callback) {
 *                 // async code to get some data
 *                 callback(null, 'data', 'converted to array');
 *             },
 *             make_folder: function(callback) {
 *                 // async code to create a directory to store a file in
 *                 // this is run at the same time as getting the data
 *                 callback(null, 'folder');
 *             },
 *             write_file: ['get_data', 'make_folder', function(results, callback) {
 *                 // once there is some data and the directory exists,
 *                 // write the data to a file in the directory
 *                 callback(null, 'filename');
 *             }],
 *             email_link: ['write_file', function(results, callback) {
 *                 // once the file is written let's email a link to it...
 *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});
 *             }]
 *         });
 *         console.log('results = ', results);
 *         // results = {
 *         //     get_data: ['data', 'converted to array']
 *         //     make_folder; 'folder',
 *         //     write_file: 'filename'
 *         //     email_link: { file: 'filename', email: 'user@example.com' }
 *         // }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function auto(tasks, concurrency, callback) {
    if (typeof concurrency !== 'number') {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || promiseCallback());
    var numTasks = Object.keys(tasks).length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var canceled = false;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    Object.keys(tasks).forEach(key => {
        var task = tasks[key];
        if (!Array.isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        dependencies.forEach(dependencyName => {
            if (!tasks[dependencyName]) {
                throw new Error('async.auto task `' + key +
                    '` has a non-existent dependency `' +
                    dependencyName + '` in ' +
                    dependencies.join(', '));
            }
            addListener(dependencyName, () => {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(() => runTask(key, task));
    }

    function processQueue() {
        if (canceled) return
        if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
        }
        while(readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
        }

    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        taskListeners.forEach(fn => fn());
        processQueue();
    }


    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce((err, ...result) => {
            runningTasks--;
            if (err === false) {
                canceled = true;
                return
            }
            if (result.length < 2) {
                [result] = result;
            }
            if (err) {
                var safeResults = {};
                Object.keys(results).forEach(rkey => {
                    safeResults[rkey] = results[rkey];
                });
                safeResults[key] = result;
                hasError = true;
                listeners = Object.create(null);
                if (canceled) return
                callback(err, safeResults);
            } else {
                results[key] = result;
                taskComplete(key);
            }
        });

        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach(dependent => {
                if (--uncheckedDependencies[dependent] === 0) {
                    readyToCheck.push(dependent);
                }
            });
        }

        if (counter !== numTasks) {
            throw new Error(
                'async.auto cannot execute tasks due to a recursive dependency'
            );
        }
    }

    function getDependents(taskName) {
        var result = [];
        Object.keys(tasks).forEach(key => {
            const task = tasks[key];
            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
                result.push(key);
            }
        });
        return result;
    }

    return callback[PROMISE_SYMBOL]
}

var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /(=.+)?(\s*)$/;

function stripComments(string) {
    let stripped = '';
    let index = 0;
    let endBlockComment = string.indexOf('*/');
    while (index < string.length) {
        if (string[index] === '/' && string[index+1] === '/') {
            // inline comment
            let endIndex = string.indexOf('\n', index);
            index = (endIndex === -1) ? string.length : endIndex;
        } else if ((endBlockComment !== -1) && (string[index] === '/') && (string[index+1] === '*')) {
            // block comment
            let endIndex = string.indexOf('*/', index);
            if (endIndex !== -1) {
                index = endIndex + 2;
                endBlockComment = string.indexOf('*/', index);
            } else {
                stripped += string[index];
                index++;
            }
        } else {
            stripped += string[index];
            index++;
        }
    }
    return stripped;
}

function parseParams(func) {
    const src = stripComments(func.toString());
    let match = src.match(FN_ARGS);
    if (!match) {
        match = src.match(ARROW_FN_ARGS);
    }
    if (!match) throw new Error('could not parse args in autoInject\nSource:\n' + src)
    let [, args] = match;
    return args
        .replace(/\s/g, '')
        .split(FN_ARG_SPLIT)
        .map((arg) => arg.replace(FN_ARG, '').trim());
}

/**
 * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
 * tasks are specified as parameters to the function, after the usual callback
 * parameter, with the parameter names matching the names of the tasks it
 * depends on. This can provide even more readable task graphs which can be
 * easier to maintain.
 *
 * If a final callback is specified, the task results are similarly injected,
 * specified as named parameters after the initial error parameter.
 *
 * The autoInject function is purely syntactic sugar and its semantics are
 * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
 *
 * @name autoInject
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.auto]{@link module:ControlFlow.auto}
 * @category Control Flow
 * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
 * the form 'func([dependencies...], callback). The object's key of a property
 * serves as the name of the task defined by that property, i.e. can be used
 * when specifying requirements for other tasks.
 * * The `callback` parameter is a `callback(err, result)` which must be called
 *   when finished, passing an `error` (which can be `null`) and the result of
 *   the function's execution. The remaining parameters name other tasks on
 *   which the task is dependent, and the results from those tasks are the
 *   arguments of those parameters.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback, and a `results` object with any completed
 * task results, similar to `auto`.
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * //  The example from `auto` can be rewritten as follows:
 * async.autoInject({
 *     get_data: function(callback) {
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: function(get_data, make_folder, callback) {
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     },
 *     email_link: function(write_file, callback) {
 *         // once the file is written let's email a link to it...
 *         // write_file contains the filename returned by write_file.
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 *
 * // If you are using a JS minifier that mangles parameter names, `autoInject`
 * // will not work with plain functions, since the parameter names will be
 * // collapsed to a single letter identifier.  To work around this, you can
 * // explicitly specify the names of the parameters your task function needs
 * // in an array, similar to Angular.js dependency injection.
 *
 * // This still has an advantage over plain `auto`, since the results a task
 * // depends on are still spread into arguments.
 * async.autoInject({
 *     //...
 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(write_file, callback) {
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }]
 *     //...
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 */
function autoInject(tasks, callback) {
    var newTasks = {};

    Object.keys(tasks).forEach(key => {
        var taskFn = tasks[key];
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps =
            (!fnIsAsync && taskFn.length === 1) ||
            (fnIsAsync && taskFn.length === 0);

        if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();

            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = params.map(name => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
        }
    });

    return auto(newTasks, callback);
}

// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.
class DLL {
    constructor() {
        this.head = this.tail = null;
        this.length = 0;
    }

    removeLink(node) {
        if (node.prev) node.prev.next = node.next;
        else this.head = node.next;
        if (node.next) node.next.prev = node.prev;
        else this.tail = node.prev;

        node.prev = node.next = null;
        this.length -= 1;
        return node;
    }

    empty () {
        while(this.head) this.shift();
        return this;
    }

    insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next) node.next.prev = newNode;
        else this.tail = newNode;
        node.next = newNode;
        this.length += 1;
    }

    insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev) node.prev.next = newNode;
        else this.head = newNode;
        node.prev = newNode;
        this.length += 1;
    }

    unshift(node) {
        if (this.head) this.insertBefore(this.head, node);
        else setInitial(this, node);
    }

    push(node) {
        if (this.tail) this.insertAfter(this.tail, node);
        else setInitial(this, node);
    }

    shift() {
        return this.head && this.removeLink(this.head);
    }

    pop() {
        return this.tail && this.removeLink(this.tail);
    }

    toArray() {
        return [...this]
    }

    *[Symbol.iterator] () {
        var cur = this.head;
        while (cur) {
            yield cur.data;
            cur = cur.next;
        }
    }

    remove (testFn) {
        var curr = this.head;
        while(curr) {
            var {next} = curr;
            if (testFn(curr)) {
                this.removeLink(curr);
            }
            curr = next;
        }
        return this;
    }
}

function setInitial(dll, node) {
    dll.length = 1;
    dll.head = dll.tail = node;
}

function queue$1(worker, concurrency, payload) {
    if (concurrency == null) {
        concurrency = 1;
    }
    else if(concurrency === 0) {
        throw new RangeError('Concurrency must not be zero');
    }

    var _worker = wrapAsync(worker);
    var numRunning = 0;
    var workersList = [];
    const events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
    };

    function on (event, handler) {
        events[event].push(handler);
    }

    function once (event, handler) {
        const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler(...args);
        };
        events[event].push(handleAndRemove);
    }

    function off (event, handler) {
        if (!event) return Object.keys(events).forEach(ev => events[ev] = [])
        if (!handler) return events[event] = []
        events[event] = events[event].filter(ev => ev !== handler);
    }

    function trigger (event, ...args) {
        events[event].forEach(handler => handler(...args));
    }

    var processingScheduled = false;
    function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;

        var res, rej;
        function promiseCallback (err, ...args) {
            // we don't care about the error, let the global error handler
            // deal with it
            if (err) return rejectOnError ? rej(err) : res()
            if (args.length <= 1) return res(args[0])
            res(args);
        }

        var item = q._createTaskItem(
            data,
            rejectOnError ? promiseCallback :
                (callback || promiseCallback)
        );

        if (insertAtFront) {
            q._tasks.unshift(item);
        } else {
            q._tasks.push(item);
        }

        if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
                processingScheduled = false;
                q.process();
            });
        }

        if (rejectOnError || !callback) {
            return new Promise((resolve, reject) => {
                res = resolve;
                rej = reject;
            })
        }
    }

    function _createCB(tasks) {
        return function (err, ...args) {
            numRunning -= 1;

            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];

                var index = workersList.indexOf(task);
                if (index === 0) {
                    workersList.shift();
                } else if (index > 0) {
                    workersList.splice(index, 1);
                }

                task.callback(err, ...args);

                if (err != null) {
                    trigger('error', err, task.data);
                }
            }

            if (numRunning <= (q.concurrency - q.buffer) ) {
                trigger('unsaturated');
            }

            if (q.idle()) {
                trigger('drain');
            }
            q.process();
        };
    }

    function _maybeDrain(data) {
        if (data.length === 0 && q.idle()) {
            // call drain immediately if there are no tasks
            setImmediate$1(() => trigger('drain'));
            return true
        }
        return false
    }

    const eventMethod = (name) => (handler) => {
        if (!handler) {
            return new Promise((resolve, reject) => {
                once(name, (err, data) => {
                    if (err) return reject(err)
                    resolve(data);
                });
            })
        }
        off(name);
        on(name, handler);

    };

    var isProcessing = false;
    var q = {
        _tasks: new DLL(),
        _createTaskItem (data, callback) {
            return {
                data,
                callback
            };
        },
        *[Symbol.iterator] () {
            yield* q._tasks[Symbol.iterator]();
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: false,
        paused: false,
        push (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, false, false, callback))
            }
            return _insert(data, false, false, callback);
        },
        pushAsync (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, false, true, callback))
            }
            return _insert(data, false, true, callback);
        },
        kill () {
            off();
            q._tasks.empty();
        },
        unshift (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, true, false, callback))
            }
            return _insert(data, true, false, callback);
        },
        unshiftAsync (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, true, true, callback))
            }
            return _insert(data, true, true, callback);
        },
        remove (testFn) {
            q._tasks.remove(testFn);
        },
        process () {
            // Avoid trying to start too many processing operations. This can occur
            // when callbacks resolve synchronously (#1267).
            if (isProcessing) {
                return;
            }
            isProcessing = true;
            while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload) l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                    var node = q._tasks.shift();
                    tasks.push(node);
                    workersList.push(node);
                    data.push(node.data);
                }

                numRunning += 1;

                if (q._tasks.length === 0) {
                    trigger('empty');
                }

                if (numRunning === q.concurrency) {
                    trigger('saturated');
                }

                var cb = onlyOnce(_createCB(tasks));
                _worker(data, cb);
            }
            isProcessing = false;
        },
        length () {
            return q._tasks.length;
        },
        running () {
            return numRunning;
        },
        workersList () {
            return workersList;
        },
        idle() {
            return q._tasks.length + numRunning === 0;
        },
        pause () {
            q.paused = true;
        },
        resume () {
            if (q.paused === false) { return; }
            q.paused = false;
            setImmediate$1(q.process);
        }
    };
    // define these as fixed properties, so people get useful errors when updating
    Object.defineProperties(q, {
        saturated: {
            writable: false,
            value: eventMethod('saturated')
        },
        unsaturated: {
            writable: false,
            value: eventMethod('unsaturated')
        },
        empty: {
            writable: false,
            value: eventMethod('empty')
        },
        drain: {
            writable: false,
            value: eventMethod('drain')
        },
        error: {
            writable: false,
            value: eventMethod('error')
        },
    });
    return q;
}

/**
 * Creates a `cargo` object with the specified payload. Tasks added to the
 * cargo will be processed altogether (up to the `payload` limit). If the
 * `worker` is in progress, the task is queued until it becomes available. Once
 * the `worker` has completed some tasks, each callback of those tasks is
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
 * for how `cargo` and `queue` work.
 *
 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
 * at a time, cargo passes an array of tasks to a single worker, repeating
 * when the worker is finished.
 *
 * @name cargo
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An asynchronous function for processing an array
 * of queued tasks. Invoked with `(tasks, callback)`.
 * @param {number} [payload=Infinity] - An optional `integer` for determining
 * how many tasks should be processed per round; if omitted, the default is
 * unlimited.
 * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the cargo and inner queue.
 * @example
 *
 * // create a cargo object with payload 2
 * var cargo = async.cargo(function(tasks, callback) {
 *     for (var i=0; i<tasks.length; i++) {
 *         console.log('hello ' + tasks[i].name);
 *     }
 *     callback();
 * }, 2);
 *
 * // add some items
 * cargo.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * cargo.push({name: 'bar'}, function(err) {
 *     console.log('finished processing bar');
 * });
 * await cargo.push({name: 'baz'});
 * console.log('finished processing baz');
 */
function cargo$1(worker, payload) {
    return queue$1(worker, 1, payload);
}

/**
 * Creates a `cargoQueue` object with the specified payload. Tasks added to the
 * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.
 * If the all `workers` are in progress, the task is queued until one becomes available. Once
 * a `worker` has completed some tasks, each callback of those tasks is
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
 * for how `cargo` and `queue` work.
 *
 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
 * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,
 * the cargoQueue passes an array of tasks to multiple parallel workers.
 *
 * @name cargoQueue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @see [async.cargo]{@link module:ControlFLow.cargo}
 * @category Control Flow
 * @param {AsyncFunction} worker - An asynchronous function for processing an array
 * of queued tasks. Invoked with `(tasks, callback)`.
 * @param {number} [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @param {number} [payload=Infinity] - An optional `integer` for determining
 * how many tasks should be processed per round; if omitted, the default is
 * unlimited.
 * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the cargoQueue and inner queue.
 * @example
 *
 * // create a cargoQueue object with payload 2 and concurrency 2
 * var cargoQueue = async.cargoQueue(function(tasks, callback) {
 *     for (var i=0; i<tasks.length; i++) {
 *         console.log('hello ' + tasks[i].name);
 *     }
 *     callback();
 * }, 2, 2);
 *
 * // add some items
 * cargoQueue.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * cargoQueue.push({name: 'bar'}, function(err) {
 *     console.log('finished processing bar');
 * });
 * cargoQueue.push({name: 'baz'}, function(err) {
 *     console.log('finished processing baz');
 * });
 * cargoQueue.push({name: 'boo'}, function(err) {
 *     console.log('finished processing boo');
 * });
 */
function cargo(worker, concurrency, payload) {
    return queue$1(worker, concurrency, payload);
}

/**
 * Reduces `coll` into a single value using an async `iteratee` to return each
 * successive step. `memo` is the initial state of the reduction. This function
 * only operates in series.
 *
 * For performance reasons, it may make sense to split a call to this function
 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
 * results. This function is for situations where each step in the reduction
 * needs to be async; if you can get the data before reducing it, then it's
 * probably a good idea to do so.
 *
 * @name reduce
 * @static
 * @memberOf module:Collections
 * @method
 * @alias inject
 * @alias foldl
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee completes with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 * // file4.txt does not exist
 *
 * const fileList = ['file1.txt','file2.txt','file3.txt'];
 * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];
 *
 * // asynchronous function that computes the file size in bytes
 * // file size is added to the memoized value, then returned
 * function getFileSizeInBytes(memo, file, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         callback(null, memo + stat.size);
 *     });
 * }
 *
 * // Using callbacks
 * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {
 *     if (err) {
 *         console.log(err);
 *     } else {
 *         console.log(result);
 *         // 6000
 *         // which is the sum of the file sizes of the three files
 *     }
 * });
 *
 * // Error Handling
 * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {
 *     if (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     } else {
 *         console.log(result);
 *     }
 * });
 *
 * // Using Promises
 * async.reduce(fileList, 0, getFileSizeInBytes)
 * .then( result => {
 *     console.log(result);
 *     // 6000
 *     // which is the sum of the file sizes of the three files
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.reduce(withMissingFileList, 0, getFileSizeInBytes)
 * .then( result => {
 *     console.log(result);
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);
 *         console.log(result);
 *         // 6000
 *         // which is the sum of the file sizes of the three files
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);
 *         console.log(result);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     }
 * }
 *
 */
function reduce(coll, memo, iteratee, callback) {
    callback = once(callback);
    var _iteratee = wrapAsync(iteratee);
    return eachOfSeries$1(coll, (x, i, iterCb) => {
        _iteratee(memo, x, (err, v) => {
            memo = v;
            iterCb(err);
        });
    }, err => callback(err, memo));
}
var reduce$1 = awaitify(reduce, 4);

/**
 * Version of the compose function that is more natural to read. Each function
 * consumes the return value of the previous function. It is the equivalent of
 * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name seq
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.compose]{@link module:ControlFlow.compose}
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} a function that composes the `functions` in order
 * @example
 *
 * // Requires lodash (or underscore), express3 and dresende's orm2.
 * // Part of an app, that fetches cats of the logged user.
 * // This example uses `seq` function to avoid overnesting and error
 * // handling clutter.
 * app.get('/cats', function(request, response) {
 *     var User = request.models.User;
 *     async.seq(
 *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))
 *         function(user, fn) {
 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
 *         }
 *     )(req.session.user_id, function (err, cats) {
 *         if (err) {
 *             console.error(err);
 *             response.json({ status: 'error', message: err.message });
 *         } else {
 *             response.json({ status: 'ok', message: 'Cats found', data: cats });
 *         }
 *     });
 * });
 */
function seq(...functions) {
    var _functions = functions.map(wrapAsync);
    return function (...args) {
        var that = this;

        var cb = args[args.length - 1];
        if (typeof cb == 'function') {
            args.pop();
        } else {
            cb = promiseCallback();
        }

        reduce$1(_functions, args, (newargs, fn, iterCb) => {
            fn.apply(that, newargs.concat((err, ...nextargs) => {
                iterCb(err, nextargs);
            }));
        },
        (err, results) => cb(err, ...results));

        return cb[PROMISE_SYMBOL]
    };
}

/**
 * Creates a function which is a composition of the passed asynchronous
 * functions. Each function consumes the return value of the function that
 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
 *
 * If the last argument to the composed function is not a function, a promise
 * is returned when you call it.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name compose
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} an asynchronous function that is the composed
 * asynchronous `functions`
 * @example
 *
 * function add1(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n + 1);
 *     }, 10);
 * }
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.compose(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
function compose(...args) {
    return seq(...args.reverse());
}

/**
 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
 *
 * @name mapLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 */
function mapLimit (coll, limit, iteratee, callback) {
    return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback)
}
var mapLimit$1 = awaitify(mapLimit, 4);

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
 *
 * @name concatLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @alias flatMapLimit
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @returns A Promise, if no callback is passed
 */
function concatLimit(coll, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, ...args) => {
            if (err) return iterCb(err);
            return iterCb(err, args);
        });
    }, (err, mapResults) => {
        var result = [];
        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                result = result.concat(...mapResults[i]);
            }
        }

        return callback(err, result);
    });
}
var concatLimit$1 = awaitify(concatLimit, 4);

/**
 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
 * the concatenated list. The `iteratee`s are called in parallel, and the
 * results are concatenated as they return. The results array will be returned in
 * the original order of `coll` passed to the `iteratee` function.
 *
 * @name concat
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @alias flatMap
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @returns A Promise, if no callback is passed
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * let directoryList = ['dir1','dir2','dir3'];
 * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];
 *
 * // Using callbacks
 * async.concat(directoryList, fs.readdir, function(err, results) {
 *    if (err) {
 *        console.log(err);
 *    } else {
 *        console.log(results);
 *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
 *    }
 * });
 *
 * // Error Handling
 * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {
 *    if (err) {
 *        console.log(err);
 *        // [ Error: ENOENT: no such file or directory ]
 *        // since dir4 does not exist
 *    } else {
 *        console.log(results);
 *    }
 * });
 *
 * // Using Promises
 * async.concat(directoryList, fs.readdir)
 * .then(results => {
 *     console.log(results);
 *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
 * }).catch(err => {
 *      console.log(err);
 * });
 *
 * // Error Handling
 * async.concat(withMissingDirectoryList, fs.readdir)
 * .then(results => {
 *     console.log(results);
 * }).catch(err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4 does not exist
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let results = await async.concat(directoryList, fs.readdir);
 *         console.log(results);
 *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
 *     } catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         let results = await async.concat(withMissingDirectoryList, fs.readdir);
 *         console.log(results);
 *     } catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *         // since dir4 does not exist
 *     }
 * }
 *
 */
function concat(coll, iteratee, callback) {
    return concatLimit$1(coll, Infinity, iteratee, callback)
}
var concat$1 = awaitify(concat, 3);

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
 *
 * @name concatSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @alias flatMapSeries
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
 * The iteratee should complete with an array an array of results.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @returns A Promise, if no callback is passed
 */
function concatSeries(coll, iteratee, callback) {
    return concatLimit$1(coll, 1, iteratee, callback)
}
var concatSeries$1 = awaitify(concatSeries, 3);

/**
 * Returns a function that when called, calls-back with the values provided.
 * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
 * [`auto`]{@link module:ControlFlow.auto}.
 *
 * @name constant
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {...*} arguments... - Any number of arguments to automatically invoke
 * callback with.
 * @returns {AsyncFunction} Returns a function that when invoked, automatically
 * invokes the callback with the previous given arguments.
 * @example
 *
 * async.waterfall([
 *     async.constant(42),
 *     function (value, next) {
 *         // value === 42
 *     },
 *     //...
 * ], callback);
 *
 * async.waterfall([
 *     async.constant(filename, "utf8"),
 *     fs.readFile,
 *     function (fileData, next) {
 *         //...
 *     }
 *     //...
 * ], callback);
 *
 * async.auto({
 *     hostname: async.constant("https://server.net/"),
 *     port: findFreePort,
 *     launchServer: ["hostname", "port", function (options, cb) {
 *         startServer(options, cb);
 *     }],
 *     //...
 * }, callback);
 */
function constant$1(...args) {
    return function (...ignoredArgs/*, callback*/) {
        var callback = ignoredArgs.pop();
        return callback(null, ...args);
    };
}

function _createTester(check, getResult) {
    return (eachfn, arr, _iteratee, cb) => {
        var testPassed = false;
        var testResult;
        const iteratee = wrapAsync(_iteratee);
        eachfn(arr, (value, _, callback) => {
            iteratee(value, (err, result) => {
                if (err || err === false) return callback(err);

                if (check(result) && !testResult) {
                    testPassed = true;
                    testResult = getResult(true, value);
                    return callback(null, breakLoop);
                }
                callback();
            });
        }, err => {
            if (err) return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
        });
    };
}

/**
 * Returns the first value in `coll` that passes an async truth test. The
 * `iteratee` is applied in parallel, meaning the first iteratee to return
 * `true` will fire the detect `callback` with that result. That means the
 * result might not be the first item in the original `coll` (in terms of order)
 * that passes the test.

 * If order within the original `coll` is important, then look at
 * [`detectSeries`]{@link module:Collections.detectSeries}.
 *
 * @name detect
 * @static
 * @memberOf module:Collections
 * @method
 * @alias find
 * @category Collections
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,
 *    function(err, result) {
 *        console.log(result);
 *        // dir1/file1.txt
 *        // result now equals the first file in the list that exists
 *    }
 *);
 *
 * // Using Promises
 * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)
 * .then(result => {
 *     console.log(result);
 *     // dir1/file1.txt
 *     // result now equals the first file in the list that exists
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);
 *         console.log(result);
 *         // dir1/file1.txt
 *         // result now equals the file in the list that exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function detect(coll, iteratee, callback) {
    return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)
}
var detect$1 = awaitify(detect, 3);

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name detectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findLimit
 * @category Collections
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if a callback is omitted
 */
function detectLimit(coll, limit, iteratee, callback) {
    return _createTester(bool => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback)
}
var detectLimit$1 = awaitify(detectLimit, 4);

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
 *
 * @name detectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findSeries
 * @category Collections
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if a callback is omitted
 */
function detectSeries(coll, iteratee, callback) {
    return _createTester(bool => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback)
}

var detectSeries$1 = awaitify(detectSeries, 3);

function consoleFunc(name) {
    return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
        /* istanbul ignore else */
        if (typeof console === 'object') {
            /* istanbul ignore else */
            if (err) {
                /* istanbul ignore else */
                if (console.error) {
                    console.error(err);
                }
            } else if (console[name]) { /* istanbul ignore else */
                resultArgs.forEach(x => console[name](x));
            }
        }
    })
}

/**
 * Logs the result of an [`async` function]{@link AsyncFunction} to the
 * `console` using `console.dir` to display the properties of the resulting object.
 * Only works in Node.js or in browsers that support `console.dir` and
 * `console.error` (such as FF and Chrome).
 * If multiple arguments are returned from the async function,
 * `console.dir` is called on each argument in order.
 *
 * @name dir
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.dir(hello, 'world');
 * {hello: 'world'}
 */
var dir = consoleFunc('dir');

/**
 * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
 * the order of operations, the arguments `test` and `iteratee` are switched.
 *
 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
 *
 * @name doWhilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - A function which is called each time `test`
 * passes. Invoked with (callback).
 * @param {AsyncFunction} test - asynchronous truth test to perform after each
 * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
 * non-error args from the previous callback of `iteratee`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped.
 * `callback` will be passed an error and any arguments passed to the final
 * `iteratee`'s callback. Invoked with (err, [results]);
 * @returns {Promise} a promise, if no callback is passed
 */
function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback);
    var _fn = wrapAsync(iteratee);
    var _test = wrapAsync(test);
    var results;

    function next(err, ...args) {
        if (err) return callback(err);
        if (err === false) return;
        results = args;
        _test(...args, check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (err === false) return;
        if (!truth) return callback(null, ...results);
        _fn(next);
    }

    return check(null, true);
}

var doWhilst$1 = awaitify(doWhilst, 3);

/**
 * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
 * argument ordering differs from `until`.
 *
 * @name doUntil
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {AsyncFunction} test - asynchronous truth test to perform after each
 * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
 * non-error args from the previous callback of `iteratee`
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns {Promise} a promise, if no callback is passed
 */
function doUntil(iteratee, test, callback) {
    const _test = wrapAsync(test);
    return doWhilst$1(iteratee, (...args) => {
        const cb = args.pop();
        _test(...args, (err, truth) => cb (err, !truth));
    }, callback);
}

function _withoutIndex(iteratee) {
    return (value, index, callback) => iteratee(value, callback);
}

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];
 * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];
 *
 * // asynchronous function that deletes a file
 * const deleteFile = function(file, callback) {
 *     fs.unlink(file, callback);
 * };
 *
 * // Using callbacks
 * async.each(fileList, deleteFile, function(err) {
 *     if( err ) {
 *         console.log(err);
 *     } else {
 *         console.log('All files have been deleted successfully');
 *     }
 * });
 *
 * // Error Handling
 * async.each(withMissingFileList, deleteFile, function(err){
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using Promises
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         await async.each(files, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         await async.each(withMissingFileList, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *         // since dir4/file2.txt does not exist
 *         // dir1/file1.txt could have been deleted
 *     }
 * }
 *
 */
function eachLimit$2(coll, iteratee, callback) {
    return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}

var each = awaitify(eachLimit$2, 3);

/**
 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
 *
 * @name eachLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfLimit`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachLimit(coll, limit, iteratee, callback) {
    return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
var eachLimit$1 = awaitify(eachLimit, 4);

/**
 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
 *
 * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item
 * in series and therefore the iteratee functions will complete in order.

 * @name eachSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfSeries`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachSeries(coll, iteratee, callback) {
    return eachLimit$1(coll, 1, iteratee, callback)
}
var eachSeries$1 = awaitify(eachSeries, 3);

/**
 * Wrap an async function and ensure it calls its callback on a later tick of
 * the event loop.  If the function already calls its callback on a next tick,
 * no extra deferral is added. This is useful for preventing stack overflows
 * (`RangeError: Maximum call stack size exceeded`) and generally keeping
 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
 * contained. ES2017 `async` functions are returned as-is -- they are immune
 * to Zalgo's corrupting influences, as they always resolve on a later tick.
 *
 * @name ensureAsync
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - an async function, one that expects a node-style
 * callback as its last argument.
 * @returns {AsyncFunction} Returns a wrapped function with the exact same call
 * signature as the function passed in.
 * @example
 *
 * function sometimesAsync(arg, callback) {
 *     if (cache[arg]) {
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.mapSeries(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return function (...args/*, callback*/) {
        var callback = args.pop();
        var sync = true;
        args.push((...innerArgs) => {
            if (sync) {
                setImmediate$1(() => callback(...innerArgs));
            } else {
                callback(...innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    };
}

/**
 * Returns `true` if every element in `coll` satisfies an async test. If any
 * iteratee call returns `false`, the main `callback` is immediately called.
 *
 * @name every
 * @static
 * @memberOf module:Collections
 * @method
 * @alias all
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];
 * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * // Using callbacks
 * async.every(fileList, fileExists, function(err, result) {
 *     console.log(result);
 *     // true
 *     // result is true since every file exists
 * });
 *
 * async.every(withMissingFileList, fileExists, function(err, result) {
 *     console.log(result);
 *     // false
 *     // result is false since NOT every file exists
 * });
 *
 * // Using Promises
 * async.every(fileList, fileExists)
 * .then( result => {
 *     console.log(result);
 *     // true
 *     // result is true since every file exists
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * async.every(withMissingFileList, fileExists)
 * .then( result => {
 *     console.log(result);
 *     // false
 *     // result is false since NOT every file exists
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.every(fileList, fileExists);
 *         console.log(result);
 *         // true
 *         // result is true since every file exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * async () => {
 *     try {
 *         let result = await async.every(withMissingFileList, fileExists);
 *         console.log(result);
 *         // false
 *         // result is false since NOT every file exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function every(coll, iteratee, callback) {
    return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)
}
var every$1 = awaitify(every, 3);

/**
 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
 *
 * @name everyLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 */
function everyLimit(coll, limit, iteratee, callback) {
    return _createTester(bool => !bool, res => !res)(eachOfLimit$2(limit), coll, iteratee, callback)
}
var everyLimit$1 = awaitify(everyLimit, 4);

/**
 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
 *
 * @name everySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in series.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 */
function everySeries(coll, iteratee, callback) {
    return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)
}
var everySeries$1 = awaitify(everySeries, 3);

function filterArray(eachfn, arr, iteratee, callback) {
    var truthValues = new Array(arr.length);
    eachfn(arr, (x, index, iterCb) => {
        iteratee(x, (err, v) => {
            truthValues[index] = !!v;
            iterCb(err);
        });
    }, err => {
        if (err) return callback(err);
        var results = [];
        for (var i = 0; i < arr.length; i++) {
            if (truthValues[i]) results.push(arr[i]);
        }
        callback(null, results);
    });
}

function filterGeneric(eachfn, coll, iteratee, callback) {
    var results = [];
    eachfn(coll, (x, index, iterCb) => {
        iteratee(x, (err, v) => {
            if (err) return iterCb(err);
            if (v) {
                results.push({index, value: x});
            }
            iterCb(err);
        });
    }, err => {
        if (err) return callback(err);
        callback(null, results
            .sort((a, b) => a.index - b.index)
            .map(v => v.value));
    });
}

function _filter(eachfn, coll, iteratee, callback) {
    var filter = isArrayLike(coll) ? filterArray : filterGeneric;
    return filter(eachfn, coll, wrapAsync(iteratee), callback);
}

/**
 * Returns a new array of all the values in `coll` which pass an async truth
 * test. This operation is performed in parallel, but the results array will be
 * in the same order as the original.
 *
 * @name filter
 * @static
 * @memberOf module:Collections
 * @method
 * @alias select
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback provided
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 *
 * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * // Using callbacks
 * async.filter(files, fileExists, function(err, results) {
 *    if(err) {
 *        console.log(err);
 *    } else {
 *        console.log(results);
 *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
 *        // results is now an array of the existing files
 *    }
 * });
 *
 * // Using Promises
 * async.filter(files, fileExists)
 * .then(results => {
 *     console.log(results);
 *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
 *     // results is now an array of the existing files
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let results = await async.filter(files, fileExists);
 *         console.log(results);
 *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
 *         // results is now an array of the existing files
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function filter (coll, iteratee, callback) {
    return _filter(eachOf$1, coll, iteratee, callback)
}
var filter$1 = awaitify(filter, 3);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name filterLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback provided
 */
function filterLimit (coll, limit, iteratee, callback) {
    return _filter(eachOfLimit$2(limit), coll, iteratee, callback)
}
var filterLimit$1 = awaitify(filterLimit, 4);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
 *
 * @name filterSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results)
 * @returns {Promise} a promise, if no callback provided
 */
function filterSeries (coll, iteratee, callback) {
    return _filter(eachOfSeries$1, coll, iteratee, callback)
}
var filterSeries$1 = awaitify(filterSeries, 3);

/**
 * Calls the asynchronous function `fn` with a callback parameter that allows it
 * to call itself again, in series, indefinitely.

 * If an error is passed to the callback then `errback` is called with the
 * error, and execution stops, otherwise it will never be called.
 *
 * @name forever
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} fn - an async function to call repeatedly.
 * Invoked with (next).
 * @param {Function} [errback] - when `fn` passes an error to it's callback,
 * this function will be called, and execution stops. Invoked with (err).
 * @returns {Promise} a promise that rejects if an error occurs and an errback
 * is not passed
 * @example
 *
 * async.forever(
 *     function(next) {
 *         // next is suitable for passing to things that need a callback(err [, whatever]);
 *         // it will result in this function being called again.
 *     },
 *     function(err) {
 *         // if next is called with a value in its first parameter, it will appear
 *         // in here as 'err', and execution will stop.
 *     }
 * );
 */
function forever(fn, errback) {
    var done = onlyOnce(errback);
    var task = wrapAsync(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        if (err === false) return;
        task(next);
    }
    return next();
}
var forever$1 = awaitify(forever, 2);

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
 *
 * @name groupByLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 * @returns {Promise} a promise, if no callback is passed
 */
function groupByLimit(coll, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, key) => {
            if (err) return iterCb(err);
            return iterCb(err, {key, val});
        });
    }, (err, mapResults) => {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var {hasOwnProperty} = Object.prototype;

        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                var {key} = mapResults[i];
                var {val} = mapResults[i];

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
}

var groupByLimit$1 = awaitify(groupByLimit, 4);

/**
 * Returns a new object, where each value corresponds to an array of items, from
 * `coll`, that returned the corresponding key. That is, the keys of the object
 * correspond to the values passed to the `iteratee` callback.
 *
 * Note: Since this function applies the `iteratee` to each item in parallel,
 * there is no guarantee that the `iteratee` functions will complete in order.
 * However, the values for each key in the `result` will be in the same order as
 * the original `coll`. For Objects, the values will roughly be in the order of
 * the original Objects' keys (but this can vary across JavaScript engines).
 *
 * @name groupBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * const files = ['dir1/file1.txt','dir2','dir4']
 *
 * // asynchronous function that detects file type as none, file, or directory
 * function detectFile(file, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(null, 'none');
 *         }
 *         callback(null, stat.isDirectory() ? 'directory' : 'file');
 *     });
 * }
 *
 * //Using callbacks
 * async.groupBy(files, detectFile, function(err, result) {
 *     if(err) {
 *         console.log(err);
 *     } else {
 *	       console.log(result);
 *         // {
 *         //     file: [ 'dir1/file1.txt' ],
 *         //     none: [ 'dir4' ],
 *         //     directory: [ 'dir2']
 *         // }
 *         // result is object containing the files grouped by type
 *     }
 * });
 *
 * // Using Promises
 * async.groupBy(files, detectFile)
 * .then( result => {
 *     console.log(result);
 *     // {
 *     //     file: [ 'dir1/file1.txt' ],
 *     //     none: [ 'dir4' ],
 *     //     directory: [ 'dir2']
 *     // }
 *     // result is object containing the files grouped by type
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.groupBy(files, detectFile);
 *         console.log(result);
 *         // {
 *         //     file: [ 'dir1/file1.txt' ],
 *         //     none: [ 'dir4' ],
 *         //     directory: [ 'dir2']
 *         // }
 *         // result is object containing the files grouped by type
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function groupBy (coll, iteratee, callback) {
    return groupByLimit$1(coll, Infinity, iteratee, callback)
}

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
 *
 * @name groupBySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whose
 * properties are arrays of values which returned the corresponding key.
 * @returns {Promise} a promise, if no callback is passed
 */
function groupBySeries (coll, iteratee, callback) {
    return groupByLimit$1(coll, 1, iteratee, callback)
}

/**
 * Logs the result of an `async` function to the `console`. Only works in
 * Node.js or in browsers that support `console.log` and `console.error` (such
 * as FF and Chrome). If multiple arguments are returned from the async
 * function, `console.log` is called on each argument in order.
 *
 * @name log
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, 'hello ' + name);
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.log(hello, 'world');
 * 'hello world'
 */
var log = consoleFunc('log');

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name mapValuesLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @returns {Promise} a promise, if no callback is passed
 */
function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback);
    var newObj = {};
    var _iteratee = wrapAsync(iteratee);
    return eachOfLimit$2(limit)(obj, (val, key, next) => {
        _iteratee(val, key, (err, result) => {
            if (err) return next(err);
            newObj[key] = result;
            next(err);
        });
    }, err => callback(err, newObj));
}

var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);

/**
 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
 *
 * Produces a new Object by mapping each value of `obj` through the `iteratee`
 * function. The `iteratee` is called each `value` and `key` from `obj` and a
 * callback for when it has finished processing. Each of these callbacks takes
 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
 * passes an error to its callback, the main `callback` (for the `mapValues`
 * function) is immediately called with the error.
 *
 * Note, the order of the keys in the result is not guaranteed.  The keys will
 * be roughly in the order they complete, (but this is very engine-specific)
 *
 * @name mapValues
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 * // file4.txt does not exist
 *
 * const fileMap = {
 *     f1: 'file1.txt',
 *     f2: 'file2.txt',
 *     f3: 'file3.txt'
 * };
 *
 * const withMissingFileMap = {
 *     f1: 'file1.txt',
 *     f2: 'file2.txt',
 *     f3: 'file4.txt'
 * };
 *
 * // asynchronous function that returns the file size in bytes
 * function getFileSizeInBytes(file, key, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         callback(null, stat.size);
 *     });
 * }
 *
 * // Using callbacks
 * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {
 *     if (err) {
 *         console.log(err);
 *     } else {
 *         console.log(result);
 *         // result is now a map of file size in bytes for each file, e.g.
 *         // {
 *         //     f1: 1000,
 *         //     f2: 2000,
 *         //     f3: 3000
 *         // }
 *     }
 * });
 *
 * // Error handling
 * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {
 *     if (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     } else {
 *         console.log(result);
 *     }
 * });
 *
 * // Using Promises
 * async.mapValues(fileMap, getFileSizeInBytes)
 * .then( result => {
 *     console.log(result);
 *     // result is now a map of file size in bytes for each file, e.g.
 *     // {
 *     //     f1: 1000,
 *     //     f2: 2000,
 *     //     f3: 3000
 *     // }
 * }).catch (err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.mapValues(withMissingFileMap, getFileSizeInBytes)
 * .then( result => {
 *     console.log(result);
 * }).catch (err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.mapValues(fileMap, getFileSizeInBytes);
 *         console.log(result);
 *         // result is now a map of file size in bytes for each file, e.g.
 *         // {
 *         //     f1: 1000,
 *         //     f2: 2000,
 *         //     f3: 3000
 *         // }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);
 *         console.log(result);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     }
 * }
 *
 */
function mapValues(obj, iteratee, callback) {
    return mapValuesLimit$1(obj, Infinity, iteratee, callback)
}

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
 *
 * @name mapValuesSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @returns {Promise} a promise, if no callback is passed
 */
function mapValuesSeries(obj, iteratee, callback) {
    return mapValuesLimit$1(obj, 1, iteratee, callback)
}

/**
 * Caches the results of an async function. When creating a hash to store
 * function results against, the callback is omitted from the hash and an
 * optional hash function can be used.
 *
 * **Note: if the async function errs, the result will not be cached and
 * subsequent calls will call the wrapped function.**
 *
 * If no hash function is specified, the first argument is used as a hash key,
 * which may work reasonably if it is a string or a data type that converts to a
 * distinct string. Note that objects and arrays will not behave reasonably.
 * Neither will cases where the other arguments are significant. In such cases,
 * specify your own hash function.
 *
 * The cache of results is exposed as the `memo` property of the function
 * returned by `memoize`.
 *
 * @name memoize
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function to proxy and cache results from.
 * @param {Function} hasher - An optional function for generating a custom hash
 * for storing results. It has all the arguments applied to it apart from the
 * callback, and must be synchronous.
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.memoize(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() {
 *     // callback
 * });
 */
function memoize(fn, hasher = v => v) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    var _fn = wrapAsync(fn);
    var memoized = initialParams((args, callback) => {
        var key = hasher(...args);
        if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
        } else if (key in queues) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
                // #1465 don't memoize if an error occurred
                if (!err) {
                    memo[key] = resultArgs;
                }
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                    q[i](err, ...resultArgs);
                }
            });
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}

/* istanbul ignore file */

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `process.nextTick`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name nextTick
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.setImmediate]{@link module:Utils.setImmediate}
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer;

if (hasNextTick) {
    _defer = process.nextTick;
} else if (hasSetImmediate) {
    _defer = setImmediate;
} else {
    _defer = fallback;
}

var nextTick = wrap(_defer);

var _parallel = awaitify((eachfn, tasks, callback) => {
    var results = isArrayLike(tasks) ? [] : {};

    eachfn(tasks, (task, key, taskCb) => {
        wrapAsync(task)((err, ...result) => {
            if (result.length < 2) {
                [result] = result;
            }
            results[key] = result;
            taskCb(err);
        });
    }, err => callback(err, results));
}, 3);

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
 * execution of other tasks when a task fails.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @returns {Promise} a promise, if a callback is not passed
 *
 * @example
 *
 * //Using Callbacks
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ], function(err, results) {
 *     console.log(results);
 *     // results is equal to ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * });
 *
 * //Using Promises
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ]).then(results => {
 *     console.log(results);
 *     // results is equal to ['one','two'] even though
 *     // the second function had a shorter timeout.
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }).then(results => {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * //Using async/await
 * async () => {
 *     try {
 *         let results = await async.parallel([
 *             function(callback) {
 *                 setTimeout(function() {
 *                     callback(null, 'one');
 *                 }, 200);
 *             },
 *             function(callback) {
 *                 setTimeout(function() {
 *                     callback(null, 'two');
 *                 }, 100);
 *             }
 *         ]);
 *         console.log(results);
 *         // results is equal to ['one','two'] even though
 *         // the second function had a shorter timeout.
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // an example using an object instead of an array
 * async () => {
 *     try {
 *         let results = await async.parallel({
 *             one: function(callback) {
 *                 setTimeout(function() {
 *                     callback(null, 1);
 *                 }, 200);
 *             },
 *            two: function(callback) {
 *                 setTimeout(function() {
 *                     callback(null, 2);
 *                 }, 100);
 *            }
 *         });
 *         console.log(results);
 *         // results is equal to: { one: 1, two: 2 }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function parallel(tasks, callback) {
    return _parallel(eachOf$1, tasks, callback);
}

/**
 * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name parallelLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.parallel]{@link module:ControlFlow.parallel}
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @returns {Promise} a promise, if a callback is not passed
 */
function parallelLimit(tasks, limit, callback) {
    return _parallel(eachOfLimit$2(limit), tasks, callback);
}

/**
 * A queue of tasks for the worker function to complete.
 * @typedef {Iterable} QueueObject
 * @memberOf module:ControlFlow
 * @property {Function} length - a function returning the number of items
 * waiting to be processed. Invoke with `queue.length()`.
 * @property {boolean} started - a boolean indicating whether or not any
 * items have been pushed and processed by the queue.
 * @property {Function} running - a function returning the number of items
 * currently being processed. Invoke with `queue.running()`.
 * @property {Function} workersList - a function returning the array of items
 * currently being processed. Invoke with `queue.workersList()`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
 * @property {number} concurrency - an integer for determining how many `worker`
 * functions should be run in parallel. This property can be changed after a
 * `queue` is created to alter the concurrency on-the-fly.
 * @property {number} payload - an integer that specifies how many items are
 * passed to the worker function at a time. only applies if this is a
 * [cargo]{@link module:ControlFlow.cargo} object
 * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`
 * once the `worker` has finished processing the task. Instead of a single task,
 * a `tasks` array can be submitted. The respective callback is used for every
 * task in the list. Invoke with `queue.push(task, [callback])`,
 * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.
 * Invoke with `queue.unshift(task, [callback])`.
 * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns
 * a promise that rejects if an error occurs.
 * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns
 * a promise that rejects if an error occurs.
 * @property {Function} remove - remove items from the queue that match a test
 * function.  The test function will be passed an object with a `data` property,
 * and a `priority` property, if this is a
 * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
 * `function ({data, priority}) {}` and returns a Boolean.
 * @property {Function} saturated - a function that sets a callback that is
 * called when the number of running workers hits the `concurrency` limit, and
 * further tasks will be queued.  If the callback is omitted, `q.saturated()`
 * returns a promise for the next occurrence.
 * @property {Function} unsaturated - a function that sets a callback that is
 * called when the number of running workers is less than the `concurrency` &
 * `buffer` limits, and further tasks will not be queued. If the callback is
 * omitted, `q.unsaturated()` returns a promise for the next occurrence.
 * @property {number} buffer - A minimum threshold buffer in order to say that
 * the `queue` is `unsaturated`.
 * @property {Function} empty - a function that sets a callback that is called
 * when the last item from the `queue` is given to a `worker`. If the callback
 * is omitted, `q.empty()` returns a promise for the next occurrence.
 * @property {Function} drain - a function that sets a callback that is called
 * when the last item from the `queue` has returned from the `worker`. If the
 * callback is omitted, `q.drain()` returns a promise for the next occurrence.
 * @property {Function} error - a function that sets a callback that is called
 * when a task errors. Has the signature `function(error, task)`. If the
 * callback is omitted, `error()` returns a promise that rejects on the next
 * error.
 * @property {boolean} paused - a boolean for determining whether the queue is
 * in a paused state.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke with `queue.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. No more tasks
 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
 *
 * @example
 * const q = async.queue(worker, 2)
 * q.push(item1)
 * q.push(item2)
 * q.push(item3)
 * // queues are iterable, spread into an array to inspect
 * const items = [...q] // [item1, item2, item3]
 * // or use for of
 * for (let item of q) {
 *     console.log(item)
 * }
 *
 * q.drain(() => {
 *     console.log('all done')
 * })
 * // or
 * await q.drain()
 */

/**
 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
 * `queue` are processed in parallel (up to the `concurrency` limit). If all
 * `worker`s are in progress, the task is queued until one becomes available.
 * Once a `worker` completes a `task`, that `task`'s callback is called.
 *
 * @name queue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`. Invoked with (task, callback).
 * @param {number} [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be
 * attached as certain properties to listen for specific events during the
 * lifecycle of the queue.
 * @example
 *
 * // create a queue object with concurrency 2
 * var q = async.queue(function(task, callback) {
 *     console.log('hello ' + task.name);
 *     callback();
 * }, 2);
 *
 * // assign a callback
 * q.drain(function() {
 *     console.log('all items have been processed');
 * });
 * // or await the end
 * await q.drain()
 *
 * // assign an error callback
 * q.error(function(err, task) {
 *     console.error('task experienced an error');
 * });
 *
 * // add some items to the queue
 * q.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * // callback is optional
 * q.push({name: 'bar'});
 *
 * // add some items to the queue (batch-wise)
 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
 *     console.log('finished processing item');
 * });
 *
 * // add some items to the front of the queue
 * q.unshift({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 */
function queue (worker, concurrency) {
    var _worker = wrapAsync(worker);
    return queue$1((items, cb) => {
        _worker(items[0], cb);
    }, concurrency, 1);
}

// Binary min-heap implementation used for priority queue.
// Implementation is stable, i.e. push time is considered for equal priorities
class Heap {
    constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
    }

    get length() {
        return this.heap.length;
    }

    empty () {
        this.heap = [];
        return this;
    }

    percUp(index) {
        let p;

        while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {
            let t = this.heap[index];
            this.heap[index] = this.heap[p];
            this.heap[p] = t;

            index = p;
        }
    }

    percDown(index) {
        let l;

        while ((l=leftChi(index)) < this.heap.length) {
            if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {
                l = l+1;
            }

            if (smaller(this.heap[index], this.heap[l])) {
                break;
            }

            let t = this.heap[index];
            this.heap[index] = this.heap[l];
            this.heap[l] = t;

            index = l;
        }
    }

    push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length-1);
    }

    unshift(node) {
        return this.heap.push(node);
    }

    shift() {
        let [top] = this.heap;

        this.heap[0] = this.heap[this.heap.length-1];
        this.heap.pop();
        this.percDown(0);

        return top;
    }

    toArray() {
        return [...this];
    }

    *[Symbol.iterator] () {
        for (let i = 0; i < this.heap.length; i++) {
            yield this.heap[i].data;
        }
    }

    remove (testFn) {
        let j = 0;
        for (let i = 0; i < this.heap.length; i++) {
            if (!testFn(this.heap[i])) {
                this.heap[j] = this.heap[i];
                j++;
            }
        }

        this.heap.splice(j);

        for (let i = parent(this.heap.length-1); i >= 0; i--) {
            this.percDown(i);
        }

        return this;
    }
}

function leftChi(i) {
    return (i<<1)+1;
}

function parent(i) {
    return ((i+1)>>1)-1;
}

function smaller(x, y) {
    if (x.priority !== y.priority) {
        return x.priority < y.priority;
    }
    else {
        return x.pushCount < y.pushCount;
    }
}

/**
 * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
 * completed in ascending priority order.
 *
 * @name priorityQueue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`.
 * Invoked with (task, callback).
 * @param {number} concurrency - An `integer` for determining how many `worker`
 * functions should be run in parallel.  If omitted, the concurrency defaults to
 * `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three
 * differences between `queue` and `priorityQueue` objects:
 * * `push(task, priority, [callback])` - `priority` should be a number. If an
 *   array of `tasks` is given, all tasks will be assigned the same priority.
 * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,
 *   except this returns a promise that rejects if an error occurs.
 * * The `unshift` and `unshiftAsync` methods were removed.
 */
function priorityQueue(worker, concurrency) {
    // Start with a normal queue
    var q = queue(worker, concurrency);

    var {
        push,
        pushAsync
    } = q;

    q._tasks = new Heap();
    q._createTaskItem = ({data, priority}, callback) => {
        return {
            data,
            priority,
            callback
        };
    };

    function createDataItems(tasks, priority) {
        if (!Array.isArray(tasks)) {
            return {data: tasks, priority};
        }
        return tasks.map(data => { return {data, priority}; });
    }

    // Override push to accept second parameter representing priority
    q.push = function(data, priority = 0, callback) {
        return push(createDataItems(data, priority), callback);
    };

    q.pushAsync = function(data, priority = 0, callback) {
        return pushAsync(createDataItems(data, priority), callback);
    };

    // Remove unshift functions
    delete q.unshift;
    delete q.unshiftAsync;

    return q;
}

/**
 * Runs the `tasks` array of functions in parallel, without waiting until the
 * previous function has completed. Once any of the `tasks` complete or pass an
 * error to its callback, the main `callback` is immediately called. It's
 * equivalent to `Promise.race()`.
 *
 * @name race
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
 * to run. Each function can complete with an optional `result` value.
 * @param {Function} callback - A callback to run once any of the functions have
 * completed. This function gets an error or result from the first function that
 * completed. Invoked with (err, result).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * async.race([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // main callback
 * function(err, result) {
 *     // the result will be equal to 'two' as it finishes earlier
 * });
 */
function race(tasks, callback) {
    callback = once(callback);
    if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i < l; i++) {
        wrapAsync(tasks[i])(callback);
    }
}

var race$1 = awaitify(race, 2);

/**
 * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
 *
 * @name reduceRight
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reduce]{@link module:Collections.reduce}
 * @alias foldr
 * @category Collection
 * @param {Array} array - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee completes with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if no callback is passed
 */
function reduceRight (array, memo, iteratee, callback) {
    var reversed = [...array].reverse();
    return reduce$1(reversed, memo, iteratee, callback);
}

/**
 * Wraps the async function in another function that always completes with a
 * result object, even when it errors.
 *
 * The result object has either the property `error` or `value`.
 *
 * @name reflect
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function you want to wrap
 * @returns {Function} - A function that always passes null to it's callback as
 * the error. The second argument to the callback will be an `object` with
 * either an `error` or a `value` property.
 * @example
 *
 * async.parallel([
 *     async.reflect(function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff but error ...
 *         callback('bad stuff happened');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     })
 * ],
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = 'bad stuff happened'
 *     // results[2].value = 'two'
 * });
 */
function reflect(fn) {
    var _fn = wrapAsync(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error) {
                retVal.error = error;
            }
            if (cbArgs.length > 0){
                var value = cbArgs;
                if (cbArgs.length <= 1) {
                    [value] = cbArgs;
                }
                retVal.value = value;
            }
            reflectCallback(null, retVal);
        });

        return _fn.apply(this, args);
    });
}

/**
 * A helper function that wraps an array or an object of functions with `reflect`.
 *
 * @name reflectAll
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.reflect]{@link module:Utils.reflect}
 * @category Util
 * @param {Array|Object|Iterable} tasks - The collection of
 * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
 * @returns {Array} Returns an array of async functions, each wrapped in
 * `async.reflect`
 * @example
 *
 * let tasks = [
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         // do some more stuff but error ...
 *         callback(new Error('bad stuff happened'));
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ];
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = Error('bad stuff happened')
 *     // results[2].value = 'two'
 * });
 *
 * // an example using an object instead of an array
 * let tasks = {
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         callback('two');
 *     },
 *     three: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'three');
 *         }, 100);
 *     }
 * };
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results.one.value = 'one'
 *     // results.two.error = 'two'
 *     // results.three.value = 'three'
 * });
 */
function reflectAll(tasks) {
    var results;
    if (Array.isArray(tasks)) {
        results = tasks.map(reflect);
    } else {
        results = {};
        Object.keys(tasks).forEach(key => {
            results[key] = reflect.call(this, tasks[key]);
        });
    }
    return results;
}

function reject$2(eachfn, arr, _iteratee, callback) {
    const iteratee = wrapAsync(_iteratee);
    return _filter(eachfn, arr, (value, cb) => {
        iteratee(value, (err, v) => {
            cb(err, !v);
        });
    }, callback);
}

/**
 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
 *
 * @name reject
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 *
 * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * // Using callbacks
 * async.reject(fileList, fileExists, function(err, results) {
 *    // [ 'dir3/file6.txt' ]
 *    // results now equals an array of the non-existing files
 * });
 *
 * // Using Promises
 * async.reject(fileList, fileExists)
 * .then( results => {
 *     console.log(results);
 *     // [ 'dir3/file6.txt' ]
 *     // results now equals an array of the non-existing files
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let results = await async.reject(fileList, fileExists);
 *         console.log(results);
 *         // [ 'dir3/file6.txt' ]
 *         // results now equals an array of the non-existing files
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function reject (coll, iteratee, callback) {
    return reject$2(eachOf$1, coll, iteratee, callback)
}
var reject$1 = awaitify(reject, 3);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name rejectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 */
function rejectLimit (coll, limit, iteratee, callback) {
    return reject$2(eachOfLimit$2(limit), coll, iteratee, callback)
}
var rejectLimit$1 = awaitify(rejectLimit, 4);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
 *
 * @name rejectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 */
function rejectSeries (coll, iteratee, callback) {
    return reject$2(eachOfSeries$1, coll, iteratee, callback)
}
var rejectSeries$1 = awaitify(rejectSeries, 3);

function constant(value) {
    return function () {
        return value;
    }
}

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @see [async.retryable]{@link module:ControlFlow.retryable}
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param {AsyncFunction} task - An async function to retry.
 * Invoked with (callback).
 * @param {Function} [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 * @returns {Promise} a promise if no callback provided
 *
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry({
 *   times: 10,
 *   interval: function(retryCount) {
 *     return 50 * Math.pow(2, retryCount);
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry({
 *   errorFilter: function(err) {
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // to retry individual methods that are not as reliable within other
 * // control flow functions, use the `retryable` wrapper:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.retryable(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
const DEFAULT_TIMES = 5;
const DEFAULT_INTERVAL = 0;

function retry(opts, task, callback) {
    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant(DEFAULT_INTERVAL)
    };

    if (arguments.length < 3 && typeof opts === 'function') {
        callback = task || promiseCallback();
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || promiseCallback();
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = wrapAsync(task);

    var attempt = 1;
    function retryAttempt() {
        _task((err, ...args) => {
            if (err === false) return
            if (err && attempt++ < options.times &&
                (typeof options.errorFilter != 'function' ||
                    options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
                callback(err, ...args);
            }
        });
    }

    retryAttempt();
    return callback[PROMISE_SYMBOL]
}

function parseTimes(acc, t) {
    if (typeof t === 'object') {
        acc.times = +t.times || DEFAULT_TIMES;

        acc.intervalFunc = typeof t.interval === 'function' ?
            t.interval :
            constant(+t.interval || DEFAULT_INTERVAL);

        acc.errorFilter = t.errorFilter;
    } else if (typeof t === 'number' || typeof t === 'string') {
        acc.times = +t || DEFAULT_TIMES;
    } else {
        throw new Error("Invalid arguments for async.retry");
    }
}

/**
 * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
 * wraps a task and makes it retryable, rather than immediately calling it
 * with retries.
 *
 * @name retryable
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.retry]{@link module:ControlFlow.retry}
 * @category Control Flow
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
 * options, exactly the same as from `retry`, except for a `opts.arity` that
 * is the arity of the `task` function, defaulting to `task.length`
 * @param {AsyncFunction} task - the asynchronous function to wrap.
 * This function will be passed any arguments passed to the returned wrapper.
 * Invoked with (...args, callback).
 * @returns {AsyncFunction} The wrapped function, which when invoked, will
 * retry on an error, based on the parameters specified in `opts`.
 * This function will accept the same parameters as `task`.
 * @example
 *
 * async.auto({
 *     dep1: async.retryable(3, getFromFlakyService),
 *     process: ["dep1", async.retryable(3, function (results, cb) {
 *         maybeProcessData(results.dep1, cb);
 *     })]
 * }, callback);
 */
function retryable (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    let arity = (opts && opts.arity) || task.length;
    if (isAsync(task)) {
        arity += 1;
    }
    var _task = wrapAsync(task);
    return initialParams((args, callback) => {
        if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
        }
        function taskFn(cb) {
            _task(...args, cb);
        }

        if (opts) retry(opts, taskFn, callback);
        else retry(taskFn, callback);

        return callback[PROMISE_SYMBOL]
    });
}

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
 * [async functions]{@link AsyncFunction} to run in series.
 * Each function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @return {Promise} a promise, if no callback is passed
 * @example
 *
 * //Using Callbacks
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ], function(err, results) {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * });
 *
 * // an example using objects instead of arrays
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * });
 *
 * //Using Promises
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ]).then(results => {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // an example using an object instead of an array
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }).then(results => {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * //Using async/await
 * async () => {
 *     try {
 *         let results = await async.series([
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 'one');
 *                 }, 200);
 *             },
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 'two');
 *                 }, 100);
 *             }
 *         ]);
 *         console.log(results);
 *         // results is equal to ['one','two']
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // an example using an object instead of an array
 * async () => {
 *     try {
 *         let results = await async.parallel({
 *             one: function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 1);
 *                 }, 200);
 *             },
 *            two: function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 2);
 *                 }, 100);
 *            }
 *         });
 *         console.log(results);
 *         // results is equal to: { one: 1, two: 2 }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function series(tasks, callback) {
    return _parallel(eachOfSeries$1, tasks, callback);
}

/**
 * Returns `true` if at least one element in the `coll` satisfies an async test.
 * If any iteratee call returns `true`, the main `callback` is immediately
 * called.
 *
 * @name some
 * @static
 * @memberOf module:Collections
 * @method
 * @alias any
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * // Using callbacks
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,
 *    function(err, result) {
 *        console.log(result);
 *        // true
 *        // result is true since some file in the list exists
 *    }
 *);
 *
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,
 *    function(err, result) {
 *        console.log(result);
 *        // false
 *        // result is false since none of the files exists
 *    }
 *);
 *
 * // Using Promises
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)
 * .then( result => {
 *     console.log(result);
 *     // true
 *     // result is true since some file in the list exists
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)
 * .then( result => {
 *     console.log(result);
 *     // false
 *     // result is false since none of the files exists
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);
 *         console.log(result);
 *         // true
 *         // result is true since some file in the list exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * async () => {
 *     try {
 *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);
 *         console.log(result);
 *         // false
 *         // result is false since none of the files exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function some(coll, iteratee, callback) {
    return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)
}
var some$1 = awaitify(some, 3);

/**
 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
 *
 * @name someLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anyLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 */
function someLimit(coll, limit, iteratee, callback) {
    return _createTester(Boolean, res => res)(eachOfLimit$2(limit), coll, iteratee, callback)
}
var someLimit$1 = awaitify(someLimit, 4);

/**
 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
 *
 * @name someSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anySeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in series.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 */
function someSeries(coll, iteratee, callback) {
    return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)
}
var someSeries$1 = awaitify(someSeries, 3);

/**
 * Sorts a list by the results of running each `coll` value through an async
 * `iteratee`.
 *
 * @name sortBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a value to use as the sort criteria as
 * its `result`.
 * Invoked with (item, callback).
 * @param {Function} callback - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is the items
 * from the original `coll` sorted by the values returned by the `iteratee`
 * calls. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback passed
 * @example
 *
 * // bigfile.txt is a file that is 251100 bytes in size
 * // mediumfile.txt is a file that is 11000 bytes in size
 * // smallfile.txt is a file that is 121 bytes in size
 *
 * // asynchronous function that returns the file size in bytes
 * function getFileSizeInBytes(file, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         callback(null, stat.size);
 *     });
 * }
 *
 * // Using callbacks
 * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,
 *     function(err, results) {
 *         if (err) {
 *             console.log(err);
 *         } else {
 *             console.log(results);
 *             // results is now the original array of files sorted by
 *             // file size (ascending by default), e.g.
 *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
 *         }
 *     }
 * );
 *
 * // By modifying the callback parameter the
 * // sorting order can be influenced:
 *
 * // ascending order
 * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {
 *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
 *         if (getFileSizeErr) return callback(getFileSizeErr);
 *         callback(null, fileSize);
 *     });
 * }, function(err, results) {
 *         if (err) {
 *             console.log(err);
 *         } else {
 *             console.log(results);
 *             // results is now the original array of files sorted by
 *             // file size (ascending by default), e.g.
 *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
 *         }
 *     }
 * );
 *
 * // descending order
 * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {
 *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
 *         if (getFileSizeErr) {
 *             return callback(getFileSizeErr);
 *         }
 *         callback(null, fileSize * -1);
 *     });
 * }, function(err, results) {
 *         if (err) {
 *             console.log(err);
 *         } else {
 *             console.log(results);
 *             // results is now the original array of files sorted by
 *             // file size (ascending by default), e.g.
 *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']
 *         }
 *     }
 * );
 *
 * // Error handling
 * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,
 *     function(err, results) {
 *         if (err) {
 *             console.log(err);
 *             // [ Error: ENOENT: no such file or directory ]
 *         } else {
 *             console.log(results);
 *         }
 *     }
 * );
 *
 * // Using Promises
 * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)
 * .then( results => {
 *     console.log(results);
 *     // results is now the original array of files sorted by
 *     // file size (ascending by default), e.g.
 *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error handling
 * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)
 * .then( results => {
 *     console.log(results);
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 * });
 *
 * // Using async/await
 * (async () => {
 *     try {
 *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
 *         console.log(results);
 *         // results is now the original array of files sorted by
 *         // file size (ascending by default), e.g.
 *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * })();
 *
 * // Error handling
 * async () => {
 *     try {
 *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
 *         console.log(results);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     }
 * }
 *
 */
function sortBy (coll, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    return map$1(coll, (x, iterCb) => {
        _iteratee(x, (err, criteria) => {
            if (err) return iterCb(err);
            iterCb(err, {value: x, criteria});
        });
    }, (err, results) => {
        if (err) return callback(err);
        callback(null, results.sort(comparator).map(v => v.value));
    });

    function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
    }
}
var sortBy$1 = awaitify(sortBy, 3);

/**
 * Sets a time limit on an asynchronous function. If the function does not call
 * its callback within the specified milliseconds, it will be called with a
 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
 *
 * @name timeout
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} asyncFn - The async function to limit in time.
 * @param {number} milliseconds - The specified time limit.
 * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
 * to timeout Error for more information..
 * @returns {AsyncFunction} Returns a wrapped function that can be used with any
 * of the control flow functions.
 * Invoke this function with the same parameters as you would `asyncFunc`.
 * @example
 *
 * function myFunction(foo, callback) {
 *     doAsyncTask(foo, function(err, data) {
 *         // handle errors
 *         if (err) return callback(err);
 *
 *         // do some stuff ...
 *
 *         // return processed data
 *         return callback(null, data);
 *     });
 * }
 *
 * var wrapped = async.timeout(myFunction, 1000);
 *
 * // call `wrapped` as you would `myFunction`
 * wrapped({ bar: 'bar' }, function(err, data) {
 *     // if `myFunction` takes < 1000 ms to execute, `err`
 *     // and `data` will have their expected values
 *
 *     // else `err` will be an Error with the code 'ETIMEDOUT'
 * });
 */
function timeout(asyncFn, milliseconds, info) {
    var fn = wrapAsync(asyncFn);

    return initialParams((args, callback) => {
        var timedOut = false;
        var timer;

        function timeoutCallback() {
            var name = asyncFn.name || 'anonymous';
            var error  = new Error('Callback function "' + name + '" timed out.');
            error.code = 'ETIMEDOUT';
            if (info) {
                error.info = info;
            }
            timedOut = true;
            callback(error);
        }

        args.push((...cbArgs) => {
            if (!timedOut) {
                callback(...cbArgs);
                clearTimeout(timer);
            }
        });

        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn(...args);
    });
}

function range(size) {
    var result = Array(size);
    while (size--) {
        result[size] = size;
    }
    return result;
}

/**
 * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name timesLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} count - The number of times to run the function.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see [async.map]{@link module:Collections.map}.
 * @returns {Promise} a promise, if no callback is provided
 */
function timesLimit(count, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    return mapLimit$1(range(count), limit, _iteratee, callback);
}

/**
 * Calls the `iteratee` function `n` times, and accumulates results in the same
 * manner you would use with [map]{@link module:Collections.map}.
 *
 * @name times
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 * @returns {Promise} a promise, if no callback is provided
 * @example
 *
 * // Pretend this is some complicated async factory
 * var createUser = function(id, callback) {
 *     callback(null, {
 *         id: 'user' + id
 *     });
 * };
 *
 * // generate 5 users
 * async.times(5, function(n, next) {
 *     createUser(n, function(err, user) {
 *         next(err, user);
 *     });
 * }, function(err, users) {
 *     // we should now have 5 users
 * });
 */
function times (n, iteratee, callback) {
    return timesLimit(n, Infinity, iteratee, callback)
}

/**
 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
 *
 * @name timesSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 * @returns {Promise} a promise, if no callback is provided
 */
function timesSeries (n, iteratee, callback) {
    return timesLimit(n, 1, iteratee, callback)
}

/**
 * A relative of `reduce`.  Takes an Object or Array, and iterates over each
 * element in parallel, each step potentially mutating an `accumulator` value.
 * The type of the accumulator defaults to the type of collection passed in.
 *
 * @name transform
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {*} [accumulator] - The initial state of the transform.  If omitted,
 * it will default to an empty Object or Array, depending on the type of `coll`
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * collection that potentially modifies the accumulator.
 * Invoked with (accumulator, item, key, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the transformed accumulator.
 * Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 *
 * // helper function that returns human-readable size format from bytes
 * function formatBytes(bytes, decimals = 2) {
 *   // implementation not included for brevity
 *   return humanReadbleFilesize;
 * }
 *
 * const fileList = ['file1.txt','file2.txt','file3.txt'];
 *
 * // asynchronous function that returns the file size, transformed to human-readable format
 * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
 * function transformFileSize(acc, value, key, callback) {
 *     fs.stat(value, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         acc[key] = formatBytes(stat.size);
 *         callback(null);
 *     });
 * }
 *
 * // Using callbacks
 * async.transform(fileList, transformFileSize, function(err, result) {
 *     if(err) {
 *         console.log(err);
 *     } else {
 *         console.log(result);
 *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
 *     }
 * });
 *
 * // Using Promises
 * async.transform(fileList, transformFileSize)
 * .then(result => {
 *     console.log(result);
 *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * (async () => {
 *     try {
 *         let result = await async.transform(fileList, transformFileSize);
 *         console.log(result);
 *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * })();
 *
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 *
 * // helper function that returns human-readable size format from bytes
 * function formatBytes(bytes, decimals = 2) {
 *   // implementation not included for brevity
 *   return humanReadbleFilesize;
 * }
 *
 * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };
 *
 * // asynchronous function that returns the file size, transformed to human-readable format
 * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
 * function transformFileSize(acc, value, key, callback) {
 *     fs.stat(value, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         acc[key] = formatBytes(stat.size);
 *         callback(null);
 *     });
 * }
 *
 * // Using callbacks
 * async.transform(fileMap, transformFileSize, function(err, result) {
 *     if(err) {
 *         console.log(err);
 *     } else {
 *         console.log(result);
 *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
 *     }
 * });
 *
 * // Using Promises
 * async.transform(fileMap, transformFileSize)
 * .then(result => {
 *     console.log(result);
 *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.transform(fileMap, transformFileSize);
 *         console.log(result);
 *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function transform (coll, accumulator, iteratee, callback) {
    if (arguments.length <= 3 && typeof accumulator === 'function') {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = Array.isArray(coll) ? [] : {};
    }
    callback = once(callback || promiseCallback());
    var _iteratee = wrapAsync(iteratee);

    eachOf$1(coll, (v, k, cb) => {
        _iteratee(accumulator, v, k, cb);
    }, err => callback(err, accumulator));
    return callback[PROMISE_SYMBOL]
}

/**
 * It runs each task in series but stops whenever any of the functions were
 * successful. If one of the tasks were successful, the `callback` will be
 * passed the result of the successful task. If all tasks fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name tryEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to
 * run, each function is passed a `callback(err, result)` it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback which is called when one
 * of the tasks has succeeded, or all have failed. It receives the `err` and
 * `result` arguments of the last attempt at completing the `task`. Invoked with
 * (err, results).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 * async.tryEach([
 *     function getDataFromFirstWebsite(callback) {
 *         // Try getting the data from the first website
 *         callback(err, data);
 *     },
 *     function getDataFromSecondWebsite(callback) {
 *         // First website failed,
 *         // Try getting the data from the backup website
 *         callback(err, data);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     Now do something with the data.
 * });
 *
 */
function tryEach(tasks, callback) {
    var error = null;
    var result;
    return eachSeries$1(tasks, (task, taskCb) => {
        wrapAsync(task)((err, ...args) => {
            if (err === false) return taskCb(err);

            if (args.length < 2) {
                [result] = args;
            } else {
                result = args;
            }
            error = err;
            taskCb(err ? null : {});
        });
    }, () => callback(error, result));
}

var tryEach$1 = awaitify(tryEach);

/**
 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
 * unmemoized form. Handy for testing.
 *
 * @name unmemoize
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.memoize]{@link module:Utils.memoize}
 * @category Util
 * @param {AsyncFunction} fn - the memoized function
 * @returns {AsyncFunction} a function that calls the original unmemoized function
 */
function unmemoize(fn) {
    return (...args) => {
        return (fn.unmemoized || fn)(...args);
    };
}

/**
 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs.
 *
 * @name whilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `iteratee`. Invoked with (callback).
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * var count = 0;
 * async.whilst(
 *     function test(cb) { cb(null, count < 5); },
 *     function iter(callback) {
 *         count++;
 *         setTimeout(function() {
 *             callback(null, count);
 *         }, 1000);
 *     },
 *     function (err, n) {
 *         // 5 seconds have passed, n = 5
 *     }
 * );
 */
function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback);
    var _fn = wrapAsync(iteratee);
    var _test = wrapAsync(test);
    var results = [];

    function next(err, ...rest) {
        if (err) return callback(err);
        results = rest;
        if (err === false) return;
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (err === false) return;
        if (!truth) return callback(null, ...results);
        _fn(next);
    }

    return _test(check);
}
var whilst$1 = awaitify(whilst, 3);

/**
 * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs. `callback` will be passed an error and any
 * arguments passed to the final `iteratee`'s callback.
 *
 * The inverse of [whilst]{@link module:ControlFlow.whilst}.
 *
 * @name until
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `iteratee`. Invoked with (callback).
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns {Promise} a promise, if a callback is not passed
 *
 * @example
 * const results = []
 * let finished = false
 * async.until(function test(cb) {
 *     cb(null, finished)
 * }, function iter(next) {
 *     fetchPage(url, (err, body) => {
 *         if (err) return next(err)
 *         results = results.concat(body.objects)
 *         finished = !!body.next
 *         next(err)
 *     })
 * }, function done (err) {
 *     // all pages have been fetched
 * })
 */
function until(test, iteratee, callback) {
    const _test = wrapAsync(test);
    return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);
}

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
 * to run.
 * Each function should complete with any number of `result` values.
 * The `result` values will be passed as arguments, in order, to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
function waterfall (tasks, callback) {
    callback = once(callback);
    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        task(...args, onlyOnce(next));
    }

    function next(err, ...args) {
        if (err === false) return
        if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
        }
        nextTask(args);
    }

    nextTask([]);
}

var waterfall$1 = awaitify(waterfall);

/**
 * An "async function" in the context of Async is an asynchronous function with
 * a variable number of parameters, with the final parameter being a callback.
 * (`function (arg1, arg2, ..., callback) {}`)
 * The final callback is of the form `callback(err, results...)`, which must be
 * called once the function is completed.  The callback should be called with a
 * Error as its first argument to signal that an error occurred.
 * Otherwise, if no error occurred, it should be called with `null` as the first
 * argument, and any additional `result` arguments that may apply, to signal
 * successful completion.
 * The callback must be called exactly once, ideally on a later tick of the
 * JavaScript event loop.
 *
 * This type of function is also referred to as a "Node-style async function",
 * or a "continuation passing-style function" (CPS). Most of the methods of this
 * library are themselves CPS/Node-style async functions, or functions that
 * return CPS/Node-style async functions.
 *
 * Wherever we accept a Node-style async function, we also directly accept an
 * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
 * In this case, the `async` function will not be passed a final callback
 * argument, and any thrown error will be used as the `err` argument of the
 * implicit callback, and the return value will be used as the `result` value.
 * (i.e. a `rejected` of the returned Promise becomes the `err` callback
 * argument, and a `resolved` value becomes the `result`.)
 *
 * Note, due to JavaScript limitations, we can only detect native `async`
 * functions and not transpilied implementations.
 * Your environment must have `async`/`await` support for this to work.
 * (e.g. Node > v7.6, or a recent version of a modern browser).
 * If you are using `async` functions through a transpiler (e.g. Babel), you
 * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
 * because the `async function` will be compiled to an ordinary function that
 * returns a promise.
 *
 * @typedef {Function} AsyncFunction
 * @static
 */


var index = {
    apply,
    applyEach,
    applyEachSeries,
    asyncify,
    auto,
    autoInject,
    cargo: cargo$1,
    cargoQueue: cargo,
    compose,
    concat: concat$1,
    concatLimit: concatLimit$1,
    concatSeries: concatSeries$1,
    constant: constant$1,
    detect: detect$1,
    detectLimit: detectLimit$1,
    detectSeries: detectSeries$1,
    dir,
    doUntil,
    doWhilst: doWhilst$1,
    each,
    eachLimit: eachLimit$1,
    eachOf: eachOf$1,
    eachOfLimit: eachOfLimit$1,
    eachOfSeries: eachOfSeries$1,
    eachSeries: eachSeries$1,
    ensureAsync,
    every: every$1,
    everyLimit: everyLimit$1,
    everySeries: everySeries$1,
    filter: filter$1,
    filterLimit: filterLimit$1,
    filterSeries: filterSeries$1,
    forever: forever$1,
    groupBy,
    groupByLimit: groupByLimit$1,
    groupBySeries,
    log,
    map: map$1,
    mapLimit: mapLimit$1,
    mapSeries: mapSeries$1,
    mapValues,
    mapValuesLimit: mapValuesLimit$1,
    mapValuesSeries,
    memoize,
    nextTick,
    parallel,
    parallelLimit,
    priorityQueue,
    queue,
    race: race$1,
    reduce: reduce$1,
    reduceRight,
    reflect,
    reflectAll,
    reject: reject$1,
    rejectLimit: rejectLimit$1,
    rejectSeries: rejectSeries$1,
    retry,
    retryable,
    seq,
    series,
    setImmediate: setImmediate$1,
    some: some$1,
    someLimit: someLimit$1,
    someSeries: someSeries$1,
    sortBy: sortBy$1,
    timeout,
    times,
    timesLimit,
    timesSeries,
    transform,
    tryEach: tryEach$1,
    unmemoize,
    until,
    waterfall: waterfall$1,
    whilst: whilst$1,

    // aliases
    all: every$1,
    allLimit: everyLimit$1,
    allSeries: everySeries$1,
    any: some$1,
    anyLimit: someLimit$1,
    anySeries: someSeries$1,
    find: detect$1,
    findLimit: detectLimit$1,
    findSeries: detectSeries$1,
    flatMap: concat$1,
    flatMapLimit: concatLimit$1,
    flatMapSeries: concatSeries$1,
    forEach: each,
    forEachSeries: eachSeries$1,
    forEachLimit: eachLimit$1,
    forEachOf: eachOf$1,
    forEachOfSeries: eachOfSeries$1,
    forEachOfLimit: eachOfLimit$1,
    inject: reduce$1,
    foldl: reduce$1,
    foldr: reduceRight,
    select: filter$1,
    selectLimit: filterLimit$1,
    selectSeries: filterSeries$1,
    wrapSync: asyncify,
    during: whilst$1,
    doDuring: doWhilst$1
};




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**************************!*\
  !*** ./assets/js/app.js ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery-trend */ "./node_modules/jquery-trend/jquery.trend.js");
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery_trend__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery_revealer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-revealer */ "./node_modules/jquery-revealer/jquery.revealer.js");
/* harmony import */ var jquery_revealer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_revealer__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var validetta__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! validetta */ "./node_modules/validetta/dist/validetta.js");
/* harmony import */ var validetta__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(validetta__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var async__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! async */ "./node_modules/async/dist/async.mjs");
/* harmony import */ var _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./theme/core/Account */ "./assets/js/theme/core/Account.js");
/* harmony import */ var _theme_Auth__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./theme/Auth */ "./assets/js/theme/Auth.js");
/* harmony import */ var _theme_Blog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./theme/Blog */ "./assets/js/theme/Blog.js");
/* harmony import */ var _theme_Brand__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./theme/Brand */ "./assets/js/theme/Brand.js");
/* harmony import */ var _theme_Brands__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./theme/Brands */ "./assets/js/theme/Brands.js");
/* harmony import */ var _theme_Cart__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./theme/Cart */ "./assets/js/theme/Cart.js");
/* harmony import */ var _theme_Category__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./theme/Category */ "./assets/js/theme/Category.js");
/* harmony import */ var _theme_Compare__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./theme/Compare */ "./assets/js/theme/Compare.js");
/* harmony import */ var _theme_ContactUs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./theme/ContactUs */ "./assets/js/theme/ContactUs.js");
/* harmony import */ var _theme_Errors__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./theme/Errors */ "./assets/js/theme/Errors.js");
/* harmony import */ var _theme_404_error__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./theme/404-error */ "./assets/js/theme/404-error.js");
/* harmony import */ var _theme_core_GiftCertificate__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./theme/core/GiftCertificate */ "./assets/js/theme/core/GiftCertificate.js");
/* harmony import */ var _theme_Global__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./theme/Global */ "./assets/js/theme/Global.js");
/* harmony import */ var _theme_Home__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./theme/Home */ "./assets/js/theme/Home.js");
/* harmony import */ var _theme_OrderComplete__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./theme/OrderComplete */ "./assets/js/theme/OrderComplete.js");
/* harmony import */ var _theme_Page__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./theme/Page */ "./assets/js/theme/Page.js");
/* harmony import */ var _theme_Product__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./theme/Product */ "./assets/js/theme/Product.js");
/* harmony import */ var _theme_AmpProduct__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./theme/AmpProduct */ "./assets/js/theme/AmpProduct.js");
/* harmony import */ var _theme_Search__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./theme/Search */ "./assets/js/theme/Search.js");
/* harmony import */ var _theme_Sitemap__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./theme/Sitemap */ "./assets/js/theme/Sitemap.js");
/* harmony import */ var _theme_Subscribe__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./theme/Subscribe */ "./assets/js/theme/Subscribe.js");
/* harmony import */ var _theme_Wishlist__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./theme/Wishlist */ "./assets/js/theme/Wishlist.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
// Load plugins



























var PageClasses = {
  mapping: {
    'pages/account/orders/all': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/orders/details': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/addresses': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/add-address': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/add-return': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/add-wishlist': _theme_Wishlist__WEBPACK_IMPORTED_MODULE_26__["default"],
    'pages/account/download-item': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/edit': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/inbox': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/add-payment-method': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/edit-payment-method': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/payment-methods': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/recent-items': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/return-saved': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/returns': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/auth/login': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/auth/account-created': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/auth/create-account': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/auth/new-password': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/auth/forgot-password': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/blog': _theme_Blog__WEBPACK_IMPORTED_MODULE_7__["default"],
    'pages/blog-post': _theme_Blog__WEBPACK_IMPORTED_MODULE_7__["default"],
    'pages/brand': _theme_Brand__WEBPACK_IMPORTED_MODULE_8__["default"],
    'pages/brands': _theme_Brand__WEBPACK_IMPORTED_MODULE_8__["default"],
    'pages/cart': _theme_Cart__WEBPACK_IMPORTED_MODULE_10__["default"],
    'pages/category': _theme_Category__WEBPACK_IMPORTED_MODULE_11__["default"],
    'pages/compare': _theme_Compare__WEBPACK_IMPORTED_MODULE_12__["default"],
    'pages/contact-us': _theme_ContactUs__WEBPACK_IMPORTED_MODULE_13__["default"],
    'pages/errors': _theme_Errors__WEBPACK_IMPORTED_MODULE_14__["default"],
    'pages/errors/404': _theme_404_error__WEBPACK_IMPORTED_MODULE_15__["default"],
    'pages/gift-certificate/purchase': _theme_core_GiftCertificate__WEBPACK_IMPORTED_MODULE_16__["default"],
    'pages/gift-certificate/balance': _theme_core_GiftCertificate__WEBPACK_IMPORTED_MODULE_16__["default"],
    'pages/gift-certificate/redeem': _theme_core_GiftCertificate__WEBPACK_IMPORTED_MODULE_16__["default"],
    'global': _theme_Global__WEBPACK_IMPORTED_MODULE_17__["default"],
    'pages/home': _theme_Home__WEBPACK_IMPORTED_MODULE_18__["default"],
    'pages/order-complete': _theme_OrderComplete__WEBPACK_IMPORTED_MODULE_19__["default"],
    'pages/page': _theme_Page__WEBPACK_IMPORTED_MODULE_20__["default"],
    'pages/product': _theme_Product__WEBPACK_IMPORTED_MODULE_21__["default"],
    'pages/search': _theme_Search__WEBPACK_IMPORTED_MODULE_23__["default"],
    'pages/sitemap': _theme_Sitemap__WEBPACK_IMPORTED_MODULE_24__["default"],
    'pages/subscribed': _theme_Subscribe__WEBPACK_IMPORTED_MODULE_25__["default"],
    'pages/account/wishlist-details': _theme_Wishlist__WEBPACK_IMPORTED_MODULE_26__["default"],
    'pages/account/wishlists': _theme_Wishlist__WEBPACK_IMPORTED_MODULE_26__["default"],
    'pages/amp/product-options': _theme_AmpProduct__WEBPACK_IMPORTED_MODULE_22__["default"]
  },
  /**
   * Getter method to ensure a good page type is accessed.
   * @param page
   * @returns {*}
   */
  get: function get(page) {
    if (this.mapping[page]) {
      return this.mapping[page];
    }
    return false;
  }
};

/**
 *
 * @param {Object} pageObj
 */
function series(pageObj) {
  async__WEBPACK_IMPORTED_MODULE_4__["default"].series([pageObj.before.bind(pageObj),
  // Executed first after constructor()
  pageObj.loaded.bind(pageObj),
  // Main module logic
  pageObj.after.bind(pageObj) // Clean up method that can be overridden for cleanup.
  ], function (err) {
    if (err) {
      throw new Error(err);
    }
  });
}

/**
 * Loads the global module that gets executed on every page load.
 * Code that you want to run on every page goes in the global module.
 * @param {object} pages
 * @returns {*}
 */
function loadGlobal(pages) {
  var Global = pages.get('global');
  return new Global();
}

/**
 *
 * @param {function} pageFunc
 * @param {} pages
 */
function loader(pageFunc, pages) {
  if (pages.get('global')) {
    var globalPageManager = loadGlobal(pages);
    globalPageManager.context = pageFunc.context;
    series(globalPageManager);
  }
  series(pageFunc);
}

/**
 * This function gets added to the global window and then called
 * on page load with the current template loaded and JS Context passed in
 * @param templateFile String
 * @param context
 * @returns {*}
 */
window.stencilBootstrap = function stencilBootstrap(templateFile, context) {
  var pages = PageClasses;
  context = context || '{}';
  context = JSON.parse(context);
  return {
    load: function load() {
      $(function () {
        var PageTypeFn = pages.get(templateFile); // Finds the appropriate module from the pageType object and store the result as a function.

        if (PageTypeFn) {
          var pageType = new PageTypeFn();
          pageType.context = context;
          return loader(pageType, pages);
        }
        throw new Error(templateFile + ' Module not found');
      });
    }
  };
};
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMENBQTBDOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7Ozs7QUFJSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsSUFBSTs7QUFFSixJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyw0QkFBNEI7O0FBRTVCO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QywwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUZBQWlGLG9CQUFvQix5QkFBeUI7QUFDOUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxJQUFJOzs7QUFHSixJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7O0FDM3RHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLEtBQXlCO0FBQ2hDO0FBQ0Esc0NBQXNDLG1CQUFPLENBQUMsMkRBQVk7QUFDMUQsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0MsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7Ozs7Ozs7Ozs7OztBQzlVVzs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNQWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBWTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7OztBQUduQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLEVBQUUsTUFBTTs7Ozs7Ozs7Ozs7O0FDMUhUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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UztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZTYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQywwREFBYztBQUMzQyxZQUFZLG1CQUFPLENBQUMsK0NBQVM7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLG1EQUFXO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnRUFBZ0U7QUFDckYsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWIsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWIsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxr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LGlDQUFpQztBQUNqQztBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQixrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLDRCQUE0Qjs7QUFFOUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxxQ0FBcUMsc0JBQXNCO0FBQzNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjOztBQUVkOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQSxVQUFVOztBQUVWOztBQUVBOztBQUVBLGFBQWE7OztBQUdiLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLHVDQUF1QztBQUN2Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTs7QUFFVjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWM7O0FBRWQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7OztBQ2w4RkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNEQUFXOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FB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QUMsRUFBRSxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9vQlQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQU0sb0JBQW9CLHFCQUFNO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QiwwQkFBMEIsZUFBZTtBQUN0RTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsOEJBQThCLG9CQUFvQjtBQUNsRCxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsaURBQWlEO0FBQ2pEO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFFO1VBQ2QsSUFBSUMsUUFBUSxHQUFHLElBQUlELFVBQVUsQ0FBQyxDQUFDO1VBRS9CQyxRQUFRLENBQUMzcEMsT0FBTyxHQUFHQSxPQUFPO1VBRTFCLE9BQU9pd0IsTUFBTSxDQUFDMFosUUFBUSxFQUFFUCxLQUFLLENBQUM7UUFDaEM7UUFFQSxNQUFNLElBQUloaUIsS0FBSyxDQUFDb2lCLFlBQVksR0FBRyxtQkFBbUIsQ0FBQztNQUNyRCxDQUFDLENBQUM7SUFDSjtFQUNGLENBQUM7QUFDSCxDQUFDLEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL1BhZ2VNYW5hZ2VyLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvNDA0LWVycm9yLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvQW1wUHJvZHVjdC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL0F1dGguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9CbG9nLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvQnJhbmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9CcmFuZHMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9DYXJ0LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvQ2F0ZWdvcnkuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9Db21wYXJlLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvQ29udGFjdFVzLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvRXJyb3JzLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvR2xvYmFsLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvSG9tZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL09yZGVyQ29tcGxldGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9QYWdlLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvUHJvZHVjdC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL1NlYXJjaC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL1NpdGVtYXAuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9TdWJzY3JpYmUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9XaXNobGlzdC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NhcnQvQ2FydFV0aWxzLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY2FydC9Db3Vwb25Db2Rlcy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NhcnQvRWRpdE9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jYXJ0L0dpZnRDZXJ0aWZpY2F0ZXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jYXJ0L0dpZnRXcmFwcGluZy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NhcnQvU2hpcHBpbmdDYWxjdWxhdG9yLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY2FydC9yZWZyZXNoQ29udGVudC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NvbXBvbmVudHMvQWxlcnQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb21wb25lbnRzL1F1YW50aXR5V2lkZ2V0LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29tcG9uZW50cy9TZWxlY3RXcmFwcGVyLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29yZS9BY2NvdW50LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29yZS9BdXRoLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29yZS9HaWZ0Q2VydGlmaWNhdGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb3JlL2FjY291bnQvcGF5bWVudE1ldGhvZC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NvcmUvYWxlcnREaXNtaXNzYWJsZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NvcmUvYW1wL0FtcEFsZXJ0LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29yZS9hbXAvQW1wUHJvZHVjdFV0aWxzLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29yZS9hbXAvQW1wUXVhbnRpdHlXaWRnZXQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb3JlL2Rvd25sb2FkR2FsbGVyeS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NvcmUvZm9ybVNlbGVjdGVkVmFsdWUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb3JlL3NlbGVjdE9wdGlvbi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NvcmUvdXBkYXRlU3RhdGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9nbG9iYWwvRHJvcGRvd24uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9nbG9iYWwvRmFjZXRlZFNlYXJjaC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC9IZWFkZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9nbG9iYWwvTWVnYU5hdi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC9NaW5pQ2FydC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC9Nb2JpbGVOYXYuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9nbG9iYWwvZmlsbEZhY2V0UmF0aW5nU3RhcnMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9nbG9iYWwvaW5pdENvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9nbG9iYWwvcXVpY2stc2VhcmNoLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvZ2xvYmFsL3N2Z0ljb24uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9nbG9iYWwvdG9nZ2xlRmFjZXQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9wcm9kdWN0L0F0dHJpYnV0ZXNIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9wcm9kdWN0L0NvbG9yU3dhdGNoLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvcHJvZHVjdC9JbWFnZVpvb20uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9wcm9kdWN0L1Byb2R1Y3RJbWFnZXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9wcm9kdWN0L1Byb2R1Y3RSZXZpZXdzLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvcHJvZHVjdC9Qcm9kdWN0VXRpbHMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9wcm9kdWN0L1F1aWNrU2hvcC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3Byb2R1Y3QvcHJvZHVjdFZpZXdUZW1wbGF0ZXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9wcm9kdWN0L3Jlc2V0UHJvZHVjdEltYWdlcy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3Byb2R1Y3QvdmFyaWF0aW9uSW1nUHJldmlldy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3Byb2R1Y3Qvd2lzaGxpc3REcm9wZG93bi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3V0aWxzL0Zvcm1WYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS91dGlscy9Qcm9ncmVzc0J1dHRvbi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3V0aWxzL3BhZ2luYXRpb24tdXRpbHMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS91dGlscy9zY3JvbGxUb1RvcC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9hcGkvYmFzZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9hcGkvY2FydC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9hcGkvY291bnRyaWVzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2FwaS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9hcGkvcHJvZHVjdC1hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2FwaS9wcm9kdWN0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2FwaS9zZWFyY2guanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvYXBpL3dpc2hsaXN0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2JvZGwvZW1pdHRlcnMvYmFzZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ib2RsL2VtaXR0ZXJzL2NhcnQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvYm9kbC9oZWxwZXJzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2hvb2tzL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvaG9va3MvY2FydC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ob29rcy9jb29raWUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvaG9va3MvY3VycmVuY3ktc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvaG9va3MvZmFjZXRlZC1zZWFyY2guanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvaG9va3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvaG9va3MvcHJvZHVjdC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ob29rcy9zZWFyY2guanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvaG9va3Mvc29ydC1ieS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9saWIvY2xvc2VzdC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9saWIvcXVlcnktc3RyaW5nLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2xpYi9yZXF1ZXN0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvdG9vbHMvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvdG9vbHMvaW1hZ2VTcmNzZXQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvdG9vbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvdG9vbHMvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2JhZ3VldHRlYm94LmpzL2Rpc3QvYmFndWV0dGVCb3gubWluLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvYmMtY29tcGFyZS9kaXN0L2pzL1Byb2R1Y3RDb21wYXJlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvYmMtY29tcGFyZS9ub2RlX21vZHVsZXMvanF1ZXJ5LXJldmVhbGVyL2pxdWVyeS5yZXZlYWxlci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2JjLWNvbXBhcmUvbm9kZV9tb2R1bGVzL2pxdWVyeS10cmVuZC9qcXVlcnkudHJlbmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9iYy1sb2FkaW5nL2Rpc3QvbG9hZGluZy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2JjLWxvYWRpbmcvbm9kZV9tb2R1bGVzL2pxdWVyeS10cmVuZC9qcXVlcnkudHJlbmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9iYy1tb2RhbC9kaXN0L2pzL21vZGFsLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvYmMtbW9kYWwvbm9kZV9tb2R1bGVzL2pxdWVyeS1yZXZlYWxlci9qcXVlcnkucmV2ZWFsZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9iYy1tb2RhbC9ub2RlX21vZHVsZXMvanF1ZXJ5LXRyZW5kL2pxdWVyeS50cmVuZC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2JjLXNjcm9sbC1saW5rL2Rpc3Qvc2Nyb2xsLWxpbmsuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9iYy10YWJzL2Rpc3QvdGFicy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy90eXBlcy9hbWVyaWNhbi1leHByZXNzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMtdHlwZXMvdHlwZXMvZGFua29ydC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL2RpbmVycy1jbHViLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMtdHlwZXMvdHlwZXMvZGlzY292ZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy90eXBlcy9lbG8uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy90eXBlcy9mb3JicnVnc2ZvcmVuaW5nZW4uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy90eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL2pjYi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL21hZXN0cm8uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy90eXBlcy9tYXN0ZXJjYXJkLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMtdHlwZXMvdHlwZXMvdHJveS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL3VhdHAuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy90eXBlcy91bmlvbnBheS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL3Zpc2EuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy9jYXJkLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMvY3ZjLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMvZXhwaXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9kZWZpbmUtZGF0YS1wcm9wZXJ0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2VzLWRlZmluZS1wcm9wZXJ0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9ldmFsLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3JhbmdlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3JlZi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9zeW50YXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvdHlwZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy91cmkuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9ldi1lbWl0dGVyL2V2LWVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIyL2xpYi9ldmVudGVtaXR0ZXIyLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2V4cGFuZC15ZWFyL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZmFzdC1sdWhuL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZml0dmlkcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2dvcGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9oYXMtcHJvcGVydHktZGVzY3JpcHRvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9oYXMtcHJvdG8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvaGFzb3duL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvaGlzdG9yeS5qcy9zY3JpcHRzL2J1bmRsZWQtdW5jb21wcmVzc2VkL2h0bWw0K2h0bWw1L2pxdWVyeS5oaXN0b3J5LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvaW1hZ2VzbG9hZGVkL2ltYWdlc2xvYWRlZC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2lzLWZpbml0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2lzLWludGVnZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9pcy12YWxpZC1tb250aC9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS1yZXZlYWxlci9qcXVlcnkucmV2ZWFsZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9qcXVlcnktdHJlbmQvanF1ZXJ5LnRyZW5kLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5Lm1pbi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2p1c3QtZGVib3VuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2guX3JlaW50ZXJwb2xhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gudGVtcGxhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gudGVtcGxhdGVzZXR0aW5ncy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmluZEluZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlPZi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVDdG9yLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVGaW5kLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVXcmFwLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXNjYXBlSHRtbENoYXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VzY2FwZVN0cmluZ0NoYXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEhvbGRlci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcmVFc2NhcGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3JlRXZhbHVhdGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3JlSW50ZXJwb2xhdGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3JlcGxhY2VIb2xkZXJzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9hc3NpZ25JbldpdGguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvYXR0ZW1wdC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9iaW5kLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9maW5kLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFcnJvci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcmVkdWNlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RlbXBsYXRlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RlbXBsYXRlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWluc3BlY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9wYXJzZS1pbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9wYXJzZS15ZWFyL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9wYXJzZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9xcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9zZXQtZnVuY3Rpb24tbGVuZ3RoL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvc2lkZS1jaGFubmVsL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvc2xpY2stY2Fyb3VzZWwvc2xpY2svc2xpY2suanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL25hdGl2ZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvdmFsaWRldHRhL2Rpc3QvdmFsaWRldHRhLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvemVyby1maWxsL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvaWdub3JlZHxDOlxcVXNlcnNcXE15IFBDXFxEb3dubG9hZHNcXHVuaWNhdGVyXFxub2RlX21vZHVsZXNcXG9iamVjdC1pbnNwZWN0fC4vdXRpbC5pbnNwZWN0Iiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvYXN5bmMvZGlzdC9hc3luYy5tanMiLCJ3ZWJwYWNrOi8vcGVhay93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9wZWFrL3dlYnBhY2svcnVudGltZS9hbWQgb3B0aW9ucyIsIndlYnBhY2s6Ly9wZWFrL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3BlYWsvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3BlYWsvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9wZWFrL3dlYnBhY2svcnVudGltZS9oYXJtb255IG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vcGVhay93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3BlYWsvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9wZWFrL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy9hcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIGJlZm9yZShuZXh0KSB7XG4gICAgbmV4dCgpO1xuICB9XG5cbiAgbG9hZGVkKG5leHQpIHtcbiAgICBuZXh0KCk7XG4gIH1cblxuICBhZnRlcihuZXh0KSB7XG4gICAgbmV4dCgpO1xuICB9XG5cbiAgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG59XG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvcnM0MDQgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbn1cblxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcclxuaW1wb3J0IEFtcFByb2R1Y3RVdGlscyBmcm9tICcuL2NvcmUvYW1wL0FtcFByb2R1Y3RVdGlscyc7XHJcbmltcG9ydCBBbXBRdWFudGl0eVdpZGdldCBmcm9tICcuL2NvcmUvYW1wL0FtcFF1YW50aXR5V2lkZ2V0JztcclxuaW1wb3J0IGluaXRGb3JtU3dhdGNoRmllbGRzIGZyb20gJy4vY29yZS9mb3JtU2VsZWN0ZWRWYWx1ZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbXBQcm9kdWN0IGV4dGVuZHMgUGFnZU1hbmFnZXIge1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmVsID0gJ1tkYXRhLXByb2R1Y3QtY29udGFpbmVyXSc7XHJcbiAgfVxyXG5cclxuICBsb2FkZWQoKSB7XHJcbiAgICBpbml0Rm9ybVN3YXRjaEZpZWxkcygpO1xyXG5cclxuICAgIC8vIFF0eSBDb250cm9sXHJcbiAgICBuZXcgQW1wUXVhbnRpdHlXaWRnZXQoe3Njb3BlOiAnW2RhdGEtY2FydC1pdGVtLWFkZF0nfSk7XHJcblxyXG4gICAgdGhpcy5Qcm9kdWN0VXRpbHMgPSBuZXcgQW1wUHJvZHVjdFV0aWxzKHRoaXMuZWwsIHtcclxuICAgICAgY2FsbGJhY2tzOiB7fSxcclxuICAgICAgdGVtcGxhdGU6ICdwcm9kdWN0cy9hZGQtdG8tY2FydC1mb3JtJyxcclxuICAgIH0pLmluaXQodGhpcy5jb250ZXh0KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IENvcmVBdXRoIGZyb20gJy4vY29yZS9BdXRoJztcbmltcG9ydCBTZWxlY3RXcmFwcGVyIGZyb20gJy4vY29tcG9uZW50cy9TZWxlY3RXcmFwcGVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0aCBleHRlbmRzIENvcmVBdXRoIHtcbiAgc2VsZWN0V3JhcENhbGxiYWNrKCRzZWxlY3RFbCkge1xuICAgIG5ldyBTZWxlY3RXcmFwcGVyKCRzZWxlY3RFbCk7XG4gIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsb2cgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xuaW1wb3J0IEZhY2V0ZWRTZWFyY2ggZnJvbSAnLi9nbG9iYWwvRmFjZXRlZFNlYXJjaCc7XG5pbXBvcnQge2luaXRDb21wYXJlLCB1cGRhdGVDb21wYXJlfSBmcm9tICcuL2dsb2JhbC9pbml0Q29tcGFyZSc7XG5pbXBvcnQgTG9hZGluZyBmcm9tICdiYy1sb2FkaW5nJztcbmltcG9ydCBzdmdJY29uIGZyb20gJy4vZ2xvYmFsL3N2Z0ljb24nO1xuaW1wb3J0IGZpbGxGYWNldFJhdGluZ1N0YXJzIGZyb20gJy4vZ2xvYmFsL2ZpbGxGYWNldFJhdGluZ1N0YXJzJztcbmltcG9ydCB0b2dnbGVGYWNldCBmcm9tICcuL2dsb2JhbC90b2dnbGVGYWNldCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyYW5kIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy4kYm9keSA9ICQoZG9jdW1lbnQuYm9keSk7XG5cbiAgICBpZiAoJCgnW2RhdGEtcHJvZHVjdC1jb21wYXJlXScpLmxlbmd0aCkge1xuICAgICAgaW5pdENvbXBhcmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG5cbiAgICBmaWxsRmFjZXRSYXRpbmdTdGFycygpO1xuICB9XG5cbiAgbG9hZGVkKG5leHQpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplRmFjZXRlZFNlYXJjaCh0aGlzLmNvbnRleHQubGlzdGluZ1Byb2R1Y3RDb3VudCk7XG5cbiAgICBuZXh0KCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsICdbZGF0YS1saXN0aW5nLXZpZXddJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl90b2dnbGVWaWV3KGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJ1tkYXRhLWZhY2V0ZWQtc2VhcmNoLXRvZ2dsZV0nLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLnRvZ2dsZUNsYXNzKCdpcy1vcGVuJykubmV4dCgpLnRvZ2dsZUNsYXNzKCd2aXNpYmxlJyk7XG4gICAgfSk7XG4gIH1cblxuICBfaW5pdGlhbGl6ZUZhY2V0ZWRTZWFyY2gocHJvZHVjdENvdW50KSB7XG4gICAgY29uc3QgbG9hZGluZ09wdGlvbnMgPSB7XG4gICAgICBsb2FkaW5nTWFya3VwOiBgPGRpdiBjbGFzcz1cImxvYWRpbmctb3ZlcmxheVwiPiR7c3ZnSWNvbignc3Bpbm5lcicpfTwvZGl2PmAsXG4gICAgfTtcblxuICAgIGNvbnN0IGZhY2V0ZWRTZWFyY2hPdmVybGF5ID0gbmV3IExvYWRpbmcobG9hZGluZ09wdGlvbnMsIGZhbHNlLCAnLnByb2R1Y3QtbGlzdGluZycpO1xuXG4gICAgY29uc3QgZmFjZXRlZFNlYXJjaE9wdGlvbnMgPSB7XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgYnJhbmQ6IHtcbiAgICAgICAgICBzaG9wX2J5X3ByaWNlOiB0cnVlLFxuICAgICAgICAgIHByb2R1Y3RzOiB7XG4gICAgICAgICAgICBsaW1pdDogcHJvZHVjdENvdW50LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdGVtcGxhdGU6IHtcbiAgICAgICAgcHJvZHVjdExpc3Rpbmc6ICdicmFuZC9wcm9kdWN0LWxpc3RpbmcnLFxuICAgICAgICBzaWRlYmFyOiAnYnJhbmQvc2lkZWJhcidcbiAgICAgIH0sXG4gICAgICBzY29wZToge1xuICAgICAgICBwcm9kdWN0TGlzdGluZzogJ1tkYXRhLWJyYW5kXScsXG4gICAgICAgIHNpZGViYXI6ICdbZGF0YS1icmFuZC1zaWRlYmFyXScsXG4gICAgICB9LFxuICAgICAgc2hvd01vcmU6ICdicmFuZC9zaG93LW1vcmUnLFxuICAgICAgdG9nZ2xlRmFjZXQ6IChldmVudCkgPT4gdG9nZ2xlRmFjZXQoZXZlbnQpLFxuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHdpbGxVcGRhdGU6ICgpID0+IHtcbiAgICAgICAgICBmYWNldGVkU2VhcmNoT3ZlcmxheS5zaG93KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpZFVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGZhY2V0ZWRTZWFyY2hPdmVybGF5LmhpZGUoKTtcblxuICAgICAgICAgIGlmICgkKCdbZGF0YS1wcm9kdWN0LWNvbXBhcmVdJykubGVuZ3RoKSB7XG4gICAgICAgICAgICB1cGRhdGVDb21wYXJlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsbEZhY2V0UmF0aW5nU3RhcnMoKTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2hhbmdlIHRlcGxhdGUgb3B0aW9uIGlmIHZpZXcgbW9kZSB0aGVtZSBzZXR0aW5nIGlzIFwibGlzdFwiXG4gICAgaWYgKHRoaXMuY29udGV4dC5saXN0aW5nVmlld01vZGUgPT09ICdsaXN0Jykge1xuICAgICAgZmFjZXRlZFNlYXJjaE9wdGlvbnMudGVtcGxhdGUgPSB7XG4gICAgICAgIHByb2R1Y3RMaXN0aW5nOiAnYnJhbmQvcHJvZHVjdC1saXN0aW5nLWxpc3QnLFxuICAgICAgICBzaWRlYmFyOiAnYnJhbmQvc2lkZWJhcicsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5GYWNldGVkU2VhcmNoID0gbmV3IEZhY2V0ZWRTZWFyY2goZmFjZXRlZFNlYXJjaE9wdGlvbnMpO1xuICB9XG5cbiAgX3RvZ2dsZVZpZXcoZXZlbnQpIHtcbiAgICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9ICR0YXJnZXQuZGF0YSgnbGlzdGluZy12aWV3JykgPT09ICdncmlkJyA/ICdicmFuZC9wcm9kdWN0LWxpc3RpbmcnIDogJ2JyYW5kL3Byb2R1Y3QtbGlzdGluZy1saXN0JztcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgdGVtcGxhdGU6IHtcbiAgICAgICAgcHJvZHVjdExpc3Rpbmc6IHRlbXBsYXRlXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlLWluaXQgZmFjZXRlZCBzZWFyY2ggd2l0aCBuZXcgdGVtcGxhdGUgb3B0aW9uXG4gICAgdGhpcy5GYWNldGVkU2VhcmNoLmluaXQob3B0aW9ucyk7XG5cbiAgICAvLyB0b2dnbGUgYnV0dG9uIGNsYXNzZXNcbiAgICAkdGFyZ2V0LmFkZENsYXNzKCdhY3RpdmUnKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJhbmRzIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XHJcbmltcG9ydCB1dGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XHJcbmltcG9ydCBDYXJ0VXRpbHMgZnJvbSAnLi9jYXJ0L0NhcnRVdGlscyc7XHJcbmltcG9ydCBTaGlwcGluZ0NhbGN1bGF0b3IgZnJvbSAnLi9jYXJ0L1NoaXBwaW5nQ2FsY3VsYXRvcic7XHJcbmltcG9ydCBDb3Vwb25Db2RlcyBmcm9tICcuL2NhcnQvQ291cG9uQ29kZXMnO1xyXG5pbXBvcnQgR2lmdENlcnRpZmljYXRlcyBmcm9tICcuL2NhcnQvR2lmdENlcnRpZmljYXRlcyc7XHJcbmltcG9ydCBHaWZ0V3JhcHBpbmcgZnJvbSAnLi9jYXJ0L0dpZnRXcmFwcGluZyc7XHJcbmltcG9ydCBMb2FkaW5nIGZyb20gJ2JjLWxvYWRpbmcnO1xyXG5pbXBvcnQgUXVhbnRpdHlXaWRnZXQgZnJvbSAnLi9jb21wb25lbnRzL1F1YW50aXR5V2lkZ2V0JztcclxuaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi9nbG9iYWwvc3ZnSWNvbic7XHJcbmltcG9ydCBFZGl0T3B0aW9ucyBmcm9tICcuL2NhcnQvRWRpdE9wdGlvbnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FydCBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy4kY2FydENvbnRlbnQgPSAkKCdbZGF0YS1jYXJ0LWNvbnRlbnRdJyk7XHJcblxyXG4gICAgLy8gYnJ1dGUtZm9yY2UgYXBwbGUtcGF5IGJvZHljbGFzcyBpbiBsb2NhbCBlbnZpcm9ubWVudFxyXG4gICAgaWYgKHdpbmRvdy5BcHBsZVBheVNlc3Npb24gJiYgJCgnLmRldi1lbnZpcm9ubWVudCcpLmxlbmd0aCkge1xyXG4gICAgICAkKGRvY3VtZW50LmJvZHkpLmFkZENsYXNzKCdhcHBsZS1wYXktc3VwcG9ydGVkJyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9iaW5kRXZlbnRzKCl7XHJcbiAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5hZGQtdG8tY2FydC1idXR0b24nLCAoZXZlbnQpID0+IHRoaXMuX2FkZFRvQ2FydChldmVudCkpO1xyXG5cclxuICB9XHJcblxyXG4gIGxvYWRlZChuZXh0KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuICAgIG5ldyBRdWFudGl0eVdpZGdldCh7c2NvcGU6ICdbZGF0YS1jYXJ0LWNvbnRlbnRdJ30pO1xyXG5cclxuICAgIGNvbnN0IGxvYWRpbmdPcHRpb25zID0ge1xyXG4gICAgICBsb2FkaW5nTWFya3VwOiBgPGRpdiBjbGFzcz1cImxvYWRpbmctb3ZlcmxheVwiPiR7c3ZnSWNvbignc3Bpbm5lcicpfTwvZGl2PmAsXHJcbiAgICB9O1xyXG5cclxuICAgIG5ldyBHaWZ0V3JhcHBpbmcoe3Njb3BlOiAnW2RhdGEtY2FydC1jb250ZW50XScsIGNvbnRleHR9KTtcclxuICAgIGNvbnN0IGNhcnRDb250ZW50T3ZlcmxheSA9IG5ldyBMb2FkaW5nKGxvYWRpbmdPcHRpb25zLCB0cnVlLCAnLnByb2R1Y3QtbGlzdGluZycpO1xyXG4gICAgY29uc3QgY2FydFRvdGFsc092ZXJsYXkgPSBuZXcgTG9hZGluZyhsb2FkaW5nT3B0aW9ucywgdHJ1ZSwgJ1tkYXRhLWNhcnQtdG90YWxzXScpO1xyXG5cclxuICAgIHRoaXMuU2hpcHBpbmdDYWxjdWxhdG9yID0gbmV3IFNoaXBwaW5nQ2FsY3VsYXRvcignW2RhdGEtc2hpcHBpbmctY2FsY3VsYXRvcl0nLCB7XHJcbiAgICAgIGNvbnRleHQsXHJcbiAgICAgIHZpc2libGVDbGFzczogJ3Zpc2libGUnLFxyXG4gICAgICBjYWxsYmFja3M6IHtcclxuICAgICAgICB3aWxsVXBkYXRlOiAoKSA9PiBjYXJ0VG90YWxzT3ZlcmxheS5zaG93KCksXHJcbiAgICAgICAgZGlkVXBkYXRlOiAoKSA9PiBjYXJ0VG90YWxzT3ZlcmxheS5oaWRlKCksXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLkNvdXBvbkNvZGVzID0gbmV3IENvdXBvbkNvZGVzKCdbZGF0YS1jb3Vwb24tY29kZXNdJywge1xyXG4gICAgICBjb250ZXh0LFxyXG4gICAgICB2aXNpYmxlQ2xhc3M6ICd2aXNpYmxlJyxcclxuICAgICAgY2FsbGJhY2tzOiB7XHJcbiAgICAgICAgd2lsbFVwZGF0ZTogKCkgPT4gY2FydFRvdGFsc092ZXJsYXkuc2hvdygpLFxyXG4gICAgICAgIGRpZFVwZGF0ZTogKCkgPT4gY2FydFRvdGFsc092ZXJsYXkuaGlkZSgpLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5HaWZ0Q2VydGlmaWNhdGVzID0gbmV3IEdpZnRDZXJ0aWZpY2F0ZXMoJ1tkYXRhLWdpZnQtY2VydGlmaWNhdGVzXScsIHtcclxuICAgICAgY29udGV4dCxcclxuICAgICAgdmlzaWJsZUNsYXNzOiAndmlzaWJsZScsXHJcbiAgICAgIGNhbGxiYWNrczoge1xyXG4gICAgICAgIHdpbGxVcGRhdGU6ICgpID0+IGNhcnRUb3RhbHNPdmVybGF5LnNob3coKSxcclxuICAgICAgICBkaWRVcGRhdGU6ICgpID0+IGNhcnRUb3RhbHNPdmVybGF5LmhpZGUoKSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuQ2FydFV0aWxzID0gbmV3IENhcnRVdGlscyh7XHJcbiAgICAgIFNoaXBwaW5nQ2FsY3VsYXRvcjogdGhpcy5TaGlwcGluZ0NhbGN1bGF0b3IsXHJcbiAgICAgIENvdXBvbkNvZGVzOiB0aGlzLkNvdXBvbkNvZGVzLFxyXG4gICAgICBHaWZ0Q2VydGlmaWNhdGVzOiB0aGlzLkdpZnRDZXJ0aWZpY2F0ZXMsXHJcbiAgfSwge1xyXG4gICAgICBjYWxsYmFja3M6IHtcclxuICAgICAgICAgIHdpbGxVcGRhdGU6ICgpID0+IGNhcnRDb250ZW50T3ZlcmxheS5zaG93KCksXHJcbiAgICAgICAgICBkaWRVcGRhdGU6ICgpID0+IGNhcnRDb250ZW50T3ZlcmxheS5oaWRlKCksXHJcbiAgICAgIH0sXHJcbiAgfSkuaW5pdCgpO1xyXG4gIFxyXG5cclxuICAgIHRoaXMuY2FydEVkaXRPcHRpb25zID0gbmV3IEVkaXRPcHRpb25zKHRoaXMuY29udGV4dCwge1xyXG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiBjYXJ0Q29udGVudE92ZXJsYXkuc2hvdygpLFxyXG4gICAgICBkaWRVcGRhdGU6ICgpID0+IGNhcnRDb250ZW50T3ZlcmxheS5oaWRlKCksXHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXh0KCk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5pbXBvcnQgRmFjZXRlZFNlYXJjaCBmcm9tICcuL2dsb2JhbC9GYWNldGVkU2VhcmNoJztcbmltcG9ydCB7aW5pdENvbXBhcmUsIHVwZGF0ZUNvbXBhcmV9IGZyb20gJy4vZ2xvYmFsL2luaXRDb21wYXJlJztcbmltcG9ydCBMb2FkaW5nIGZyb20gJ2JjLWxvYWRpbmcnO1xuaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi9nbG9iYWwvc3ZnSWNvbic7XG5pbXBvcnQgZmlsbEZhY2V0UmF0aW5nU3RhcnMgZnJvbSAnLi9nbG9iYWwvZmlsbEZhY2V0UmF0aW5nU3RhcnMnO1xuaW1wb3J0IHRvZ2dsZUZhY2V0IGZyb20gJy4vZ2xvYmFsL3RvZ2dsZUZhY2V0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2F0ZWdvcnkgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLiRib2R5ID0gJChkb2N1bWVudC5ib2R5KTtcblxuICAgIGlmICgkKCdbZGF0YS1wcm9kdWN0LWNvbXBhcmVdJykubGVuZ3RoKSB7XG4gICAgICBpbml0Q29tcGFyZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgIGZpbGxGYWNldFJhdGluZ1N0YXJzKCk7XG4gIH1cblxuICBsb2FkZWQobmV4dCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVGYWNldGVkU2VhcmNoKHRoaXMuY29udGV4dC5saXN0aW5nUHJvZHVjdENvdW50KTtcblxuICAgIG5leHQoKTtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJ1tkYXRhLWxpc3Rpbmctdmlld10nLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZVZpZXcoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnW2RhdGEtZmFjZXRlZC1zZWFyY2gtdG9nZ2xlXScsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkudG9nZ2xlQ2xhc3MoJ2lzLW9wZW4nKS5uZXh0KCkudG9nZ2xlQ2xhc3MoJ3Zpc2libGUnKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9pbml0aWFsaXplRmFjZXRlZFNlYXJjaChwcm9kdWN0Q291bnQpIHtcbiAgICBjb25zdCBsb2FkaW5nT3B0aW9ucyA9IHtcbiAgICAgIGxvYWRpbmdNYXJrdXA6IGA8ZGl2IGNsYXNzPVwibG9hZGluZy1vdmVybGF5XCI+JHtzdmdJY29uKCdzcGlubmVyJyl9PC9kaXY+YCxcbiAgICB9O1xuXG4gICAgY29uc3QgZmFjZXRlZFNlYXJjaE92ZXJsYXkgPSBuZXcgTG9hZGluZyhsb2FkaW5nT3B0aW9ucywgZmFsc2UsICcucHJvZHVjdC1saXN0aW5nJyk7XG5cbiAgICBjb25zdCBmYWNldGVkU2VhcmNoT3B0aW9ucyA9IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBjYXRlZ29yeToge1xuICAgICAgICAgIHNob3BfYnlfcHJpY2U6IHRydWUsXG4gICAgICAgICAgcHJvZHVjdHM6IHtcbiAgICAgICAgICAgIGxpbWl0OiBwcm9kdWN0Q291bnQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0b2dnbGVGYWNldDogKGV2ZW50KSA9PiB0b2dnbGVGYWNldChldmVudCksXG4gICAgICBzaG93TW9yZTogJ2NhdGVnb3J5L3Nob3ctbW9yZScsXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgd2lsbFVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGZhY2V0ZWRTZWFyY2hPdmVybGF5LnNob3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlkVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgZmFjZXRlZFNlYXJjaE92ZXJsYXkuaGlkZSgpO1xuXG4gICAgICAgICAgaWYgKCQoJ1tkYXRhLXByb2R1Y3QtY29tcGFyZV0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNvbXBhcmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWxsRmFjZXRSYXRpbmdTdGFycygpO1xuICAgICAgICB9LFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBZGQgdGVwbGF0ZSBvcHRpb24gaWYgdmlldyBtb2RlIHRoZW1lIHNldHRpbmcgaXMgXCJsaXN0XCJcbiAgICBpZiAodGhpcy5jb250ZXh0Lmxpc3RpbmdWaWV3TW9kZSA9PT0gJ2xpc3QnKSB7XG4gICAgICBmYWNldGVkU2VhcmNoT3B0aW9ucy50ZW1wbGF0ZSA9IHtcbiAgICAgICAgcHJvZHVjdExpc3Rpbmc6ICdjYXRlZ29yeS9wcm9kdWN0LWxpc3RpbmctbGlzdCcsXG4gICAgICAgIHNpZGViYXI6ICdjYXRlZ29yeS9zaWRlYmFyJyxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLkZhY2V0ZWRTZWFyY2ggPSBuZXcgRmFjZXRlZFNlYXJjaChmYWNldGVkU2VhcmNoT3B0aW9ucyk7XG4gIH1cblxuICBfdG9nZ2xlVmlldyhldmVudCkge1xuICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gJHRhcmdldC5kYXRhKCdsaXN0aW5nLXZpZXcnKSA9PT0gJ2dyaWQnID8gJ2NhdGVnb3J5L3Byb2R1Y3QtbGlzdGluZycgOiAnY2F0ZWdvcnkvcHJvZHVjdC1saXN0aW5nLWxpc3QnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICB0ZW1wbGF0ZToge1xuICAgICAgICBwcm9kdWN0TGlzdGluZzogdGVtcGxhdGVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmUtaW5pdCBmYWNldGVkIHNlYXJjaCB3aXRoIG5ldyB0ZW1wbGF0ZSBvcHRpb25cbiAgICB0aGlzLkZhY2V0ZWRTZWFyY2guaW5pdChvcHRpb25zKTtcblxuICAgIC8vIHRvZ2dsZSBidXR0b24gY2xhc3Nlc1xuICAgICR0YXJnZXQuYWRkQ2xhc3MoJ2FjdGl2ZScpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXG4gICAgLy8gVE9ETyAtIHBvc3NpYmx5IGFkZCB0aGlzIGJhY2sgYWZ0ZXIgdGVzdGluZyBpbiBsaXZlIGVudmlyb25cbiAgICAvLyBpZiAodHlwZW9mKFN0b3JhZ2UpICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xpc3RpbmdWaWV3JywgJHRhcmdldC5kYXRhKCdsaXN0aW5nLXZpZXcnKSk7XG4gICAgLy8gfVxuICB9XG59XG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wYXJlIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRhY3RVcyBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JzIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5pbXBvcnQgU2Nyb2xsTGluayBmcm9tICdiYy1zY3JvbGwtbGluayc7XG5pbXBvcnQgRm9ybVZhbGlkYXRvciBmcm9tICcuL3V0aWxzL0Zvcm1WYWxpZGF0b3InO1xuaW1wb3J0IERyb3Bkb3duIGZyb20gJy4vZ2xvYmFsL0Ryb3Bkb3duJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi9nbG9iYWwvSGVhZGVyJztcbmltcG9ydCBRdWlja1NlYXJjaCBmcm9tICcuL2dsb2JhbC9xdWljay1zZWFyY2gnOyAvLyBJbXBvcnQgUXVpY2tTZWFyY2hcbmltcG9ydCBNaW5pQ2FydCBmcm9tICcuL2dsb2JhbC9NaW5pQ2FydCc7XG5pbXBvcnQgUXVpY2tTaG9wIGZyb20gJy4vcHJvZHVjdC9RdWlja1Nob3AnO1xuaW1wb3J0IHdpc2hsaXN0RHJvcGRvd24gZnJvbSAnLi9wcm9kdWN0L3dpc2hsaXN0RHJvcGRvd24nO1xuaW1wb3J0IE1lZ2FOYXYgZnJvbSAnLi9nbG9iYWwvTWVnYU5hdic7XG5pbXBvcnQgTW9iaWxlTmF2IGZyb20gJy4vZ2xvYmFsL01vYmlsZU5hdic7XG5pbXBvcnQgJy4vY29yZS9zZWxlY3RPcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHbG9iYWwgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgbmV3IERyb3Bkb3duKCQoJy5kcm9wZG93bicpKTtcbiAgICAgICAgbmV3IEhlYWRlcigkKCcuc2l0ZS1oZWFkZXInKSk7XG4gICAgICAgIG5ldyBTY3JvbGxMaW5rKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnLmJ1dHRvbi10b3AnXG4gICAgICAgIH0pO1xuICAgICAgICBuZXcgTWVnYU5hdigkKCcubWVnYS1uYXYtdmFyaWFudC1jb250YWluZXInKSk7XG4gICAgICAgIG5ldyBNb2JpbGVOYXYoKTtcbiAgICAgICAgbmV3IE1pbmlDYXJ0KCk7XG4gICAgICAgIG5ldyB3aXNobGlzdERyb3Bkb3duKCk7XG5cbiAgICAgICAgdGhpcy5fdG9nZ2xlU2Nyb2xsTGluaygpO1xuICAgICAgICB0aGlzLl9pbml0QW5jaG9ycygpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplUXVpY2tTZWFyY2goKTsgIC8vIEluaXRpYWxpemUgcXVpY2sgc2VhcmNoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiB3cmFwIHRoZSBleGVjdXRpb24gaW4gdGhpcyBtZXRob2Qgd2l0aCBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gbWFwIHVzaW5nIHRoZSBhc3luYyBsaWJyYXJ5XG4gICAgICogaWYgeW91ciBnbG9iYWwgbW9kdWxlcyBuZWVkIGFzeW5jIGNhbGxiYWNrIGhhbmRsaW5nLlxuICAgICAqIEBwYXJhbSBuZXh0XG4gICAgICovXG4gICAgbG9hZGVkKG5leHQpIHtcbiAgICAgICAgLy8gZ2xvYmFsIGZvcm0gdmFsaWRhdGlvblxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IG5ldyBGb3JtVmFsaWRhdG9yKHRoaXMuY29udGV4dCk7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yLmluaXRHbG9iYWwoKTtcblxuICAgICAgICAvLyBRdWlja1Nob3BcbiAgICAgICAgaWYgKCQoJ1tkYXRhLXF1aWNrLXNob3BdJykubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXcgUXVpY2tTaG9wKHRoaXMuY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgX2luaXRBbmNob3JzKCkge1xuICAgICAgICBjb25zdCBhbmNob3JTZWxlY3RvciA9ICcuY21zLXBhZ2UgW2hyZWZePVwiI1wiXSc7XG5cbiAgICAgICAgJChhbmNob3JTZWxlY3RvcikuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldElkID0gJChlbGVtZW50KS5hdHRyKCdocmVmJyk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRJZC5zdWJzdHJpbmcoMSk7XG5cbiAgICAgICAgICAgICQoZWxlbWVudCkuYXR0cignZGF0YS1zY3JvbGwnLCB0YXJnZXRJZCk7XG4gICAgICAgICAgICAkKGBbbmFtZT0nJHt0YXJnZXR9J11gKS5hdHRyKCdpZCcsIHRhcmdldCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTY3JvbGxMaW5rKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBhbmNob3JTZWxlY3RvcixcbiAgICAgICAgICAgIG9mZnNldDogLTE1MCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3RvZ2dsZVNjcm9sbExpbmsoKSB7XG4gICAgICAgICQod2luZG93KS5vbignc2Nyb2xsJywgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdpblNjcm9sbFRvcCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpbkhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKTtcblxuICAgICAgICAgICAgaWYgKHdpblNjcm9sbFRvcCA+IHdpbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICQoJy5idXR0b24tdG9wJykuYWRkQ2xhc3MoJ3Nob3cnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCgnLmJ1dHRvbi10b3AnKS5yZW1vdmVDbGFzcygnc2hvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZVF1aWNrU2VhcmNoKCkge1xuICAgICAgICBuZXcgUXVpY2tTZWFyY2goKTsgLy8gSW5pdGlhbGl6ZSBxdWljayBzZWFyY2hcbiAgICB9XG59XG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xuaW1wb3J0IFByb2R1Y3RVdGlscyBmcm9tICcuL3Byb2R1Y3QvUHJvZHVjdFV0aWxzJztcbmltcG9ydCBUYWJzIGZyb20gJ2JjLXRhYnMnO1xuaW1wb3J0IHNsaWNrIGZyb20gJ3NsaWNrLWNhcm91c2VsJztcbmltcG9ydCBpbWFnZXNMb2FkZWQgZnJvbSAnaW1hZ2VzbG9hZGVkJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG9tZSBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGxvYWRlZChuZXh0KSB7XG4gICAgdGhpcy5faW5pdFNsaWNrKCk7XG5cbiAgICB0aGlzLl9pbml0VGFicygpO1xuXG4gICAgbmV4dCgpO1xuICB9XG5cbiAgX2luaXRUYWJzKCkge1xuICAgIHRoaXMudGFicyA9IG5ldyBUYWJzKHtcbiAgICAgIGFmdGVyU2V0dXA6ICgpID0+IHtcbiAgICAgICAgJCgnLnByb2R1Y3QtY2Fyb3VzZWwnKS5zbGljaygnc2V0UG9zaXRpb24nKTtcbiAgICAgIH0sXG4gICAgICBhZnRlckNoYW5nZTogKCkgPT4ge1xuICAgICAgICAkKCcucHJvZHVjdC1jYXJvdXNlbCcpLnNsaWNrKCdzZXRQb3NpdGlvbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2luaXRTbGljaygpIHtcbiAgICAvLyBIZXJvIGNhcm91c2VsXG4gICAgY29uc3QgJGNhcm91c2VsID0gJCgnLmNhcm91c2VsJyk7XG4gICAgY29uc3QgaXNOYXR1cmFsQXNwZWN0UmF0aW8gPSAkY2Fyb3VzZWwuaGFzQ2xhc3MoJ3JhdGlvLW5hdHVyYWwnKTtcbiAgICBjb25zdCBzcGVlZCA9ICRjYXJvdXNlbC5kYXRhKCdzd2FwLWZyZXF1ZW5jeScpO1xuXG4gICAgJGNhcm91c2VsXG4gICAgICAub24oJ2luaXQnLCAoZXZlbnQsIHNsaWNrKSA9PiB7XG4gICAgICAgICQoJy5zbGljay1hY3RpdmUgLmNhcm91c2VsLWl0ZW0taW5mbzpoYXMoKiknKS5hZGRDbGFzcygnc2hvdycpO1xuICAgICAgICAvLyBGaXggbWlzYWxpZ25tZW50IGJlY2F1c2Ugbm8gc2Nyb2xsYmFyIG9uIGxvYWRcbiAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuICAgICAgfSlcbiAgICAgIC5zbGljayh7XG4gICAgICAgIGRvdHM6IHRydWUsXG4gICAgICAgIGZhZGU6IHRydWUsXG4gICAgICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgICAgICBhdXRvcGxheVNwZWVkOiBzcGVlZCxcbiAgICAgICAgbGF6eUxvYWQ6ICdwcm9ncmVzc2l2ZScsXG4gICAgICAgIGFkYXB0aXZlSGVpZ2h0OiB0cnVlLFxuICAgICAgICBwcmV2QXJyb3c6ICc8c3BhbiBjbGFzcz1cImNhcm91c2VsLW5hdmlnYXRpb24taXRlbSBwcmV2aW91c1wiPjxzdmcgY2xhc3M9XCJpY29uIGljb24tYXJyb3ctbGVmdFwiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uLWFycm93LWxlZnRcIiAvPjwvc3ZnPjwvc3Bhbj4nLFxuICAgICAgICBuZXh0QXJyb3c6ICc8c3BhbiBjbGFzcz1cImNhcm91c2VsLW5hdmlnYXRpb24taXRlbSBuZXh0XCI+PHN2ZyBjbGFzcz1cImljb24gaWNvbi1hcnJvdy1yaWdodFwiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uLWFycm93LXJpZ2h0XCIgLz48L3N2Zz48L3NwYW4+J1xuICAgICAgfSlcbiAgICAgIC5vbignYmVmb3JlQ2hhbmdlJywgKGV2ZW50LCBzbGljaywgY3VycmVudFNsaWRlLCBuZXh0U2xpZGUpID0+IHtcbiAgICAgICAgJCgnLnNsaWNrLWFjdGl2ZSAuY2Fyb3VzZWwtaXRlbS1pbmZvOmhhcygqKScpLnJlbW92ZUNsYXNzKCdzaG93Jyk7XG4gICAgICB9KS5vbignYWZ0ZXJDaGFuZ2UnLCAoZXZlbnQsIHNsaWNrLCBjdXJyZW50U2xpZGUpID0+IHtcbiAgICAgICAgJCgnLnNsaWNrLWFjdGl2ZSAuY2Fyb3VzZWwtaXRlbS1pbmZvOmhhcygqKScpLmFkZENsYXNzKCdzaG93Jyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgIGluZmluaXRlOiB0cnVlLFxuICAgICAgICBzbGlkZXNUb1Nob3c6IDQsXG4gICAgICAgIHNsaWRlc1RvU2Nyb2xsOiA0LFxuICAgICAgICBhdXRvcGxheVNwZWVkOiAzMDAwLCAvLyBBdXRvcGxheSBzcGVlZCBpbiBtaWxsaXNlY29uZHMgKDMgc2Vjb25kcylcbiAgICAgICAgYXV0b3BsYXk6IHRydWUsIC8vIEVuYWJsZSBhdXRvcGxheVxuICAgICAgICBsYXp5TG9hZDogJ3Byb2dyZXNzaXZlJyxcbiAgICAgICAgc3BlZWQ6IDgwMCxcbiAgICAgICAgcHJldkFycm93OiAnPHNwYW4gY2xhc3M9XCJjYXJvdXNlbC1uYXZpZ2F0aW9uLWl0ZW0gcHJldmlvdXNcIj48c3ZnIGNsYXNzPVwiaWNvbiBpY29uLWFycm93LWxlZnRcIj48dXNlIHhsaW5rOmhyZWY9XCIjaWNvbi1hcnJvdy1sZWZ0XCIgLz48L3N2Zz48L3NwYW4+JyxcbiAgICAgICAgbmV4dEFycm93OiAnPHNwYW4gY2xhc3M9XCJjYXJvdXNlbC1uYXZpZ2F0aW9uLWl0ZW0gbmV4dFwiPjxzdmcgY2xhc3M9XCJpY29uIGljb24tYXJyb3ctcmlnaHRcIj48dXNlIHhsaW5rOmhyZWY9XCIjaWNvbi1hcnJvdy1yaWdodFwiIC8+PC9zdmc+PC9zcGFuPicsXG4gICAgICAgIHJlc3BvbnNpdmU6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVha3BvaW50OiAxMDI0LFxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgc2xpZGVzVG9TaG93OiAzLFxuICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbDogMyxcbiAgICAgICAgICAgICAgYXV0b3BsYXk6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVha3BvaW50OiA3NjgsXG4gICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICBzbGlkZXNUb1Nob3c6IDIsXG4gICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAyLFxuICAgICAgICAgICAgICBhdXRvcGxheTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgYnJlYWtwb2ludDogNDgwLFxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgc2xpZGVzVG9TaG93OiAyLFxuICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbDogMixcbiAgICAgICAgICAgICAgYXV0b3BsYXk6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG5cbiAgICBjb25zdCAkcHJvZHVjdENhcm91c2VsID0gJCgnLnByb2R1Y3QtY2Fyb3VzZWwnKTtcbiAgICAkcHJvZHVjdENhcm91c2VsLnNsaWNrKHNldHRpbmdzKTtcblxuICAgICQod2luZG93KS5vbigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoJCh0aGlzKS53aWR0aCgpID4gNDIwICYmICEkcHJvZHVjdENhcm91c2VsLmhhc0NsYXNzKCdzbGljay1pbml0aWFsaXplZCcpKSB7XG4gICAgICAgICAgJHByb2R1Y3RDYXJvdXNlbC5zbGljayhzZXR0aW5ncyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9yZGVyQ29tcGxldGUgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZSBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVXcmFwcGVyRm9yVGFibGUoKTtcbiAgICB9XG5cbiAgICBjcmVhdGVXcmFwcGVyRm9yVGFibGUoKSB7XG4gICAgICAgICQoJ3RhYmxlJywgJy5wYWdlLWNvbnRlbnQnKS5lYWNoKChpbmRleCwgdGFibGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0ICRwYXJlbnQgPSAkKHRhYmxlKS5wYXJlbnQoKTtcbiAgICAgICAgICAgIGNvbnN0ICRwcmV2U2libGluZyA9ICQodGFibGUpLnByZXYoKTtcblxuICAgICAgICAgICAgY29uc3QgJGRpdiA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdob3Jpem9udGFsLXNjcm9sbGJhcicpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCh0YWJsZSk7XG5cbiAgICAgICAgICAgIGlmICgkcHJldlNpYmxpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgJGRpdi5pbnNlcnRBZnRlcigkcHJldlNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcGFyZW50LnByZXBlbmQoJGRpdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5pbXBvcnQgQWxlcnQgZnJvbSAnLi9jb21wb25lbnRzL0FsZXJ0JztcbmltcG9ydCBQcm9kdWN0VXRpbHMgZnJvbSAnLi9wcm9kdWN0L1Byb2R1Y3RVdGlscyc7XG5pbXBvcnQgUHJvZHVjdEltYWdlcyBmcm9tICcuL3Byb2R1Y3QvUHJvZHVjdEltYWdlcyc7XG5pbXBvcnQgUHJvZHVjdFJldmlld3MgZnJvbSAnLi9wcm9kdWN0L1Byb2R1Y3RSZXZpZXdzJztcbmltcG9ydCBDb2xvclN3YXRjaCBmcm9tICcuL3Byb2R1Y3QvQ29sb3JTd2F0Y2gnO1xuaW1wb3J0IHByb2R1Y3RWaWV3VGVtcGxhdGVzIGZyb20gJy4vcHJvZHVjdC9wcm9kdWN0Vmlld1RlbXBsYXRlcyc7XG5pbXBvcnQgdmFyaWF0aW9uSW1nUHJldmlldyBmcm9tICcuL3Byb2R1Y3QvdmFyaWF0aW9uSW1nUHJldmlldyc7XG5pbXBvcnQgVGFicyBmcm9tICdiYy10YWJzJztcbmltcG9ydCBmaXRWaWRzIGZyb20gJ2ZpdHZpZHMnO1xuaW1wb3J0IFNjcm9sbExpbmsgZnJvbSAnYmMtc2Nyb2xsLWxpbmsnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9kdWN0IGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5lbCA9ICdbZGF0YS1wcm9kdWN0LWNvbnRhaW5lcl0nO1xuICAgIHRoaXMuJGVsID0gJCh0aGlzLmVsKTtcbiAgICB0aGlzLnByb2R1Y3RJbWdzID0gJy5wcm9kdWN0LXNsaWRlcy13cmFwJztcblxuICAgIHRoaXMuZml0Vmlkc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICBuZXcgQWxlcnQoJCgnW2RhdGEtYWxlcnRzXScpKTtcblxuICAgIG5ldyBTY3JvbGxMaW5rKHtcbiAgICAgIHNlbGVjdG9yOiAnLmFjY29yZGlvbi10aXRsZSBhJyxcbiAgICAgIG9mZnNldDogLTExN1xuICAgIH0pO1xuXG4gICAgbmV3IFNjcm9sbExpbmsoe1xuICAgICAgc2VsZWN0b3I6ICcucmV2aWV3cy1qdW1wbGluaydcbiAgICB9KTtcbiAgfVxuXG4gIGxvYWRlZChuZXh0KSB7XG4gICAgLy8gUHJvZHVjdCBVdGlsc1xuICAgIHRoaXMuUHJvZHVjdFV0aWxzID0gbmV3IFByb2R1Y3RVdGlscyh0aGlzLmVsLCB7XG4gICAgICBwcmljZVdpdGhvdXRUYXhUZW1wbGF0ZTogcHJvZHVjdFZpZXdUZW1wbGF0ZXMucHJpY2VXaXRob3V0VGF4LFxuICAgICAgcHJpY2VXaXRoVGF4VGVtcGxhdGU6IHByb2R1Y3RWaWV3VGVtcGxhdGVzLnByaWNlV2l0aFRheCxcbiAgICAgIHByaWNlU2F2ZWRUZW1wbGF0ZTogcHJvZHVjdFZpZXdUZW1wbGF0ZXMucHJpY2VTYXZlZCxcbiAgICAgIHZhcmlhdGlvblByZXZpZXdJbWFnZVRlbXBsYXRlOiBwcm9kdWN0Vmlld1RlbXBsYXRlcy52YXJpYXRpb25QcmV2aWV3SW1hZ2UsXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgc3dpdGNoSW1hZ2U6IHZhcmlhdGlvbkltZ1ByZXZpZXdcbiAgICAgIH1cbiAgICB9KS5pbml0KHRoaXMuY29udGV4dCk7XG5cbiAgICAvLyBQcm9kdWN0IEltYWdlc1xuICAgIG5ldyBQcm9kdWN0SW1hZ2VzKHRoaXMucHJvZHVjdEltZ3MpO1xuXG4gICAgLy8gUHJvZHVjdCBTd2F0Y2hlc1xuICAgIHRoaXMuc3dhdGNoZXMgPSBuZXcgQ29sb3JTd2F0Y2goKTsgLy8gSW5pdCBvdXIgY29sb3Igc3dhdGNoZXNcblxuICAgIC8vIFJldmlld3NcbiAgICBuZXcgUHJvZHVjdFJldmlld3ModGhpcy5jb250ZXh0KTtcblxuICAgIC8vIFByb2R1Y3QgVUlcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5faW5pdFRhYnMoKTtcbiAgICB0aGlzLl9pbml0U2xpY2soKTtcblxuICAgIG5leHQoKTtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIC8vIEFjdGl2YXRlIHRoZSByZXZpZXdzIHRhYiB3aGVuIHdlIGp1bXAgZG93biB0byBpdFxuICAgICQoJy5wcm9kdWN0LXJldmlld3MtbGluaycpLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMudGFicy5hY3RpdmF0ZVRhYignI3Byb2R1Y3QtcmV2aWV3cycpO1xuICAgICAgJCgnLmFjY29yZGlvbi10aXRsZScpLnJlbW92ZUNsYXNzKCdpcy1vcGVuJyk7XG4gICAgICAkKCdbaHJlZj1cIiNwcm9kdWN0LXJldmlld3NcIl0nKS5wYXJlbnQoJy5hY2NvcmRpb24tdGl0bGUnKS5hZGRDbGFzcygnaXMtb3BlbicpO1xuICAgIH0pO1xuXG4gICAgLy8gU2hvdyBhbGwgdGhlIHJldmlld3NcbiAgICAkKCcucmV2aWV3cy1zaG93LW1vcmUtbGluaycpLm9uKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgJCgnLnJldmlldy1pdGVtLmhpZGRlbicpLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAkKGVsKS5yZXZlYWxlcignc2hvdycpO1xuICAgICAgICB9LCBpbmRleCAqIDI1MCk7XG4gICAgICB9KTtcblxuICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5oaWRlKCk7XG4gICAgfSk7XG5cbiAgICAkKCcuYWNjb3JkaW9uLXRpdGxlJykub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fYWNjb3JkaW9uVGFiVG9nZ2xlKGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9pbml0VGFicygpIHtcbiAgICBpZiAoJCgnW2RhdGEtdGFiLWxpbmtdJykubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRhYnMgPSBuZXcgVGFicyhcbiAgICAgICAge1xuICAgICAgICAgIGFmdGVyU2V0dXA6ICh0YWJJZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faW5pdFZpZHModGFiSWQpO1xuICAgICAgICAgICAgJCgnLnRhYi1jb250ZW50LXBhbmVsLmFjdGl2ZScpLnByZXYoJy5hY2NvcmRpb24tdGl0bGUnKS5hZGRDbGFzcygnaXMtb3BlbicpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWZ0ZXJDaGFuZ2U6ICh0YWJJZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faW5pdFZpZHModGFiSWQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAga2VlcFRhYnNPcGVuOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCgnLnByb2R1Y3QtdGFicycpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFjY29yZGlvbiBzdHlsZSBidXR0b25zIHRvIHRvZ2dsZSB0YWIgcGFuZWxzXG4gIF9hY2NvcmRpb25UYWJUb2dnbGUoZXZlbnQpIHtcbiAgICBjb25zdCB0YWIgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmZpbmQoJ2EnKS5hdHRyKCdocmVmJyk7XG4gICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5hZGRDbGFzcygnaXMtb3BlbicpLnNpYmxpbmdzKCcuYWNjb3JkaW9uLXRpdGxlJykucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKTtcbiAgICB0aGlzLnRhYnMuZGlzcGxheVRhYkNvbnRlbnQodGFiKTtcbiAgfVxuXG4gIC8vIGlmIHBhZ2UgbG9hZHMgd2l0aCB0YWJzIGhpZGRlbiwgd2UgbmVlZCB0byB3YWl0IHVudGlsIHRoZSBwcm9wZXIgdGFiIGlzIGNsaWNrZWQgYmVmb3JlIHJ1bm5pbmcgZml0Vmlkcy5cbiAgX2luaXRWaWRzKHRhYklkKSB7XG4gICAgaWYgKHRhYklkID09ICcjcHJvZHVjdC12aWRlb3MnICYmICF0aGlzLmZpdFZpZHNJbml0aWFsaXplZCkge1xuICAgICAgZml0VmlkcygnLnByb2R1Y3QtdmlkZW9zLWxpc3QnKTtcbiAgICAgIHRoaXMuZml0Vmlkc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfaW5pdFNsaWNrKCkge1xuICAgIC8vIFJlbGF0ZWQgUHJvZHVjdCBjYXJvdXNlbHNcbiAgICAkKCcucHJvZHVjdC1jYXJvdXNlbCcpLnNsaWNrKHtcbiAgICAgICAgaW5maW5pdGU6IHRydWUsXG4gICAgICAgIHNsaWRlc1RvU2hvdzogNCxcbiAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDQsXG4gICAgICAgIGF1dG9wbGF5U3BlZWQ6IDQwMDAsXG4gICAgICAgIHNwZWVkOiA4MDAsXG4gICAgICAgIHByZXZBcnJvdzogJzxzcGFuIGNsYXNzPVwiY2Fyb3VzZWwtbmF2aWdhdGlvbi1pdGVtIHByZXZpb3VzXCI+PHN2ZyBjbGFzcz1cImljb24gaWNvbi1hcnJvdy1sZWZ0XCI+PHVzZSB4bGluazpocmVmPVwiI2ljb24tYXJyb3ctbGVmdFwiIC8+PC9zdmc+PC9zcGFuPicsXG4gICAgICAgIG5leHRBcnJvdzogJzxzcGFuIGNsYXNzPVwiY2Fyb3VzZWwtbmF2aWdhdGlvbi1pdGVtIG5leHRcIj48c3ZnIGNsYXNzPVwiaWNvbiBpY29uLWFycm93LXJpZ2h0XCI+PHVzZSB4bGluazpocmVmPVwiI2ljb24tYXJyb3ctcmlnaHRcIiAvPjwvc3ZnPjwvc3Bhbj4nLFxuICAgICAgICByZXNwb25zaXZlOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYnJlYWtwb2ludDogMTAyNCxcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIHNsaWRlc1RvU2hvdzogMyxcbiAgICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDMsXG4gICAgICAgICAgICAgIGF1dG9wbGF5OiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgYnJlYWtwb2ludDogNzY4LFxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgc2xpZGVzVG9TaG93OiAyLFxuICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbDogMixcbiAgICAgICAgICAgICAgYXV0b3BsYXk6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQ6IDQ4MCxcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIHNsaWRlc1RvU2hvdzogMSxcbiAgICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gICAgICAgICAgICAgIGF1dG9wbGF5OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5pbXBvcnQgRmFjZXRlZFNlYXJjaCBmcm9tICcuL2dsb2JhbC9GYWNldGVkU2VhcmNoJztcbmltcG9ydCB7IGluaXRDb21wYXJlLCB1cGRhdGVDb21wYXJlIH0gZnJvbSAnLi9nbG9iYWwvaW5pdENvbXBhcmUnO1xuaW1wb3J0IExvYWRpbmcgZnJvbSAnYmMtbG9hZGluZyc7XG5pbXBvcnQgVGFicyBmcm9tICdiYy10YWJzJztcbmltcG9ydCBNaW5pQ2FydCBmcm9tICcuL2dsb2JhbC9NaW5pQ2FydCc7XG5pbXBvcnQgUXVpY2tTZWFyY2ggZnJvbSAnLi9nbG9iYWwvcXVpY2stc2VhcmNoJzsgLy8gSW1wb3J0IFF1aWNrU2VhcmNoXG5pbXBvcnQgRHJvcGRvd24gZnJvbSAnLi9nbG9iYWwvRHJvcGRvd24nO1xuaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi9nbG9iYWwvc3ZnSWNvbic7XG5pbXBvcnQgZmlsbEZhY2V0UmF0aW5nU3RhcnMgZnJvbSAnLi9nbG9iYWwvZmlsbEZhY2V0UmF0aW5nU3RhcnMnO1xuaW1wb3J0IHRvZ2dsZUZhY2V0IGZyb20gJy4vZ2xvYmFsL3RvZ2dsZUZhY2V0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIG5ldyBEcm9wZG93bigkKCcuZHJvcGRvd24nKSk7XG4gICAgbmV3IE1pbmlDYXJ0KCk7XG4gICAgdGhpcy4kYm9keSA9ICQoZG9jdW1lbnQuYm9keSk7XG5cbiAgICBpZiAoJCgnW2RhdGEtcHJvZHVjdC1jb21wYXJlXScpLmxlbmd0aCkge1xuICAgICAgaW5pdENvbXBhcmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5faW5pdFRhYnMoKTtcbiAgICB0aGlzLl9pbml0aWFsaXplUXVpY2tTZWFyY2goKTtcbiAgICBcbiAgICBmaWxsRmFjZXRSYXRpbmdTdGFycygpO1xuICB9XG5cbiAgbG9hZGVkKG5leHQpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplRmFjZXRlZFNlYXJjaCh0aGlzLmNvbnRleHQubGlzdGluZ1Byb2R1Y3RDb3VudCk7XG5cbiAgICBuZXh0KCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsICdbZGF0YS1saXN0aW5nLXZpZXddJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl90b2dnbGVWaWV3KGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJ1tkYXRhLWZhY2V0ZWQtc2VhcmNoLXRvZ2dsZV0nLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLnRvZ2dsZUNsYXNzKCdpcy1vcGVuJykubmV4dCgpLnRvZ2dsZUNsYXNzKCd2aXNpYmxlJyk7XG4gICAgfSk7XG4gIH1cblxuICBfaW5pdFRhYnMoKSB7XG4gICAgdGhpcy50YWJzID0gbmV3IFRhYnMoe1xuICAgICAgYWZ0ZXJDaGFuZ2U6ICgpID0+IHt9LFxuICAgICAga2VlcFRhYnNPcGVuOiAoKSA9PiB7fSxcbiAgICB9KTtcblxuICAgIGlmICghJCgnI3Byb2R1Y3QtcmVzdWx0cyAucHJvZHVjdC1ibG9jaycpLmxlbmd0aCB8fCAod2luZG93LmxvY2F0aW9uLnNlYXJjaC5pbmRleE9mKCdzZWN0aW9uPWNvbnRlbnQnKSA+IC0xKSkge1xuICAgICAgdGhpcy50YWJzLmRpc3BsYXlUYWJDb250ZW50KCcjY29udGVudC1yZXN1bHRzJyk7XG4gICAgfVxuICB9XG4gIF9pbml0aWFsaXplUXVpY2tTZWFyY2goKSB7XG4gICAgbmV3IFF1aWNrU2VhcmNoKCk7IC8vIEluaXRpYWxpemUgcXVpY2sgc2VhcmNoXG59XG4gIF9pbml0aWFsaXplRmFjZXRlZFNlYXJjaChwcm9kdWN0Q291bnQpIHtcbiAgICBjb25zdCBsb2FkaW5nT3B0aW9ucyA9IHtcbiAgICAgIGxvYWRpbmdNYXJrdXA6IGA8ZGl2IGNsYXNzPVwibG9hZGluZy1vdmVybGF5XCI+JHtzdmdJY29uKCdzcGlubmVyJyl9PC9kaXY+YCxcbiAgICB9O1xuXG4gICAgY29uc3QgZmFjZXRlZFNlYXJjaE92ZXJsYXkgPSBuZXcgTG9hZGluZyhsb2FkaW5nT3B0aW9ucywgZmFsc2UsICcucHJvZHVjdC1saXN0aW5nJyk7XG5cbiAgICBjb25zdCBmYWNldGVkU2VhcmNoT3B0aW9ucyA9IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBwcm9kdWN0X3Jlc3VsdHM6IHtcbiAgICAgICAgICBsaW1pdDogcHJvZHVjdENvdW50LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgIHByb2R1Y3RMaXN0aW5nOiAnc2VhcmNoL3Byb2R1Y3QtbGlzdGluZycsXG4gICAgICAgIHNpZGViYXI6ICdzZWFyY2gvc2lkZWJhcidcbiAgICAgIH0sXG4gICAgICBzY29wZToge1xuICAgICAgICBwcm9kdWN0TGlzdGluZzogJ1tkYXRhLXNlYXJjaF0nLFxuICAgICAgICBzaWRlYmFyOiAnW2RhdGEtc2VhcmNoLXNpZGViYXJdJyxcbiAgICAgIH0sXG4gICAgICB0b2dnbGVGYWNldDogKGV2ZW50KSA9PiB0b2dnbGVGYWNldChldmVudCksXG4gICAgICBzaG93TW9yZTogJ3NlYXJjaC9zaG93LW1vcmUnLFxuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHdpbGxVcGRhdGU6ICgpID0+IHtcbiAgICAgICAgICBmYWNldGVkU2VhcmNoT3ZlcmxheS5zaG93KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpZFVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGZhY2V0ZWRTZWFyY2hPdmVybGF5LmhpZGUoKTtcblxuICAgICAgICAgIGlmICgkKCdbZGF0YS1wcm9kdWN0LWNvbXBhcmVdJykubGVuZ3RoKSB7XG4gICAgICAgICAgICB1cGRhdGVDb21wYXJlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsbEZhY2V0UmF0aW5nU3RhcnMoKTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuY29udGV4dC5saXN0aW5nVmlld01vZGUgPT09ICdsaXN0Jykge1xuICAgICAgZmFjZXRlZFNlYXJjaE9wdGlvbnMudGVtcGxhdGUgPSB7XG4gICAgICAgIHByb2R1Y3RMaXN0aW5nOiAnc2VhcmNoL3Byb2R1Y3QtbGlzdGluZy1saXN0JyxcbiAgICAgICAgc2lkZWJhcjogJ3NlYXJjaC9zaWRlYmFyJyxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLkZhY2V0ZWRTZWFyY2ggPSBuZXcgRmFjZXRlZFNlYXJjaChmYWNldGVkU2VhcmNoT3B0aW9ucyk7XG4gIH1cblxuICBfdG9nZ2xlVmlldyhldmVudCkge1xuICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gJHRhcmdldC5kYXRhKCdsaXN0aW5nLXZpZXcnKSA9PT0gJ2dyaWQnID8gJ3NlYXJjaC9wcm9kdWN0LWxpc3RpbmcnIDogJ3NlYXJjaC9wcm9kdWN0LWxpc3RpbmctbGlzdCc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgIHByb2R1Y3RMaXN0aW5nOiB0ZW1wbGF0ZVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLkZhY2V0ZWRTZWFyY2guaW5pdChvcHRpb25zKTtcblxuICAgICR0YXJnZXQuYWRkQ2xhc3MoJ2FjdGl2ZScpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICB9XG59XG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaXRlTWFwIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1YnNjcmliZSBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xuaW1wb3J0IHsgd2lzaGxpc3RQYWdpbmF0aW9uSGVscGVyIH0gZnJvbSAnLi91dGlscy9wYWdpbmF0aW9uLXV0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lzaExpc3QgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub25SZWFkeSgpO1xuICAgIH1cblxuICAgIG9uUmVhZHkoKSB7XG4gICAgICAgIGlmICgkKCdbZGF0YS1wYWdpbmF0aW9uLXdpc2hsaXN0XScpLmxlbmd0aCkge1xuICAgICAgICAgICAgd2lzaGxpc3RQYWdpbmF0aW9uSGVscGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xyXG5pbXBvcnQgQWxlcnQgZnJvbSAnLi4vY29tcG9uZW50cy9BbGVydCc7XHJcbmltcG9ydCByZWZyZXNoQ29udGVudCBmcm9tICcuL3JlZnJlc2hDb250ZW50JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcnRVdGlscyB7XHJcbiAgY29uc3RydWN0b3IobW9kdWxlcywgb3B0aW9ucykge1xyXG4gICAgdGhpcy5tb2R1bGVzID0gbW9kdWxlcztcclxuICAgIHRoaXMuJGNhcnRDb250ZW50ID0gJCgnW2RhdGEtY2FydC1jb250ZW50XScpO1xyXG4gICAgdGhpcy4kYWRkVG9DYXJ0ID0gJCgnW2RhdGEtYnV0dG9uLXB1cmNoYXNlXScpOyAvLyBJbml0aWFsaXplICRhZGRUb0NhcnRcclxuICAgIHRoaXMucXVhbnRpdHlJbnB1dCA9ICdbZGF0YS1xdWFudGl0eS1jb250cm9sLWlucHV0XSc7XHJcbiAgICB0aGlzLmNhcnRBbGVydHMgPSBuZXcgQWxlcnQoJCgnW2RhdGEtYWxlcnRzXScpKTtcclxuICAgIHRoaXMuY2FydFByb21vcyA9ICQoJ1tkYXRhLWNhcnQtcHJvbW9zXScpO1xyXG4gICAgdGhpcy5wcm9kdWN0RGF0YSA9IHt9O1xyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzID0gJC5leHRlbmQoe1xyXG4gICAgICAgIHdpbGxVcGRhdGU6ICgpID0+IGNvbnNvbGUubG9nKCdVcGRhdGUgcmVxdWVzdGVkLicpLFxyXG4gICAgICAgIGRpZFVwZGF0ZTogKCkgPT4gY29uc29sZS5sb2coJ1VwZGF0ZSBleGVjdXRlZC4nKSxcclxuICAgIH0sIG9wdGlvbnMuY2FsbGJhY2tzKTtcclxufVxyXG5cclxuICBpbml0KCkge1xyXG4gICAgdGhpcy5fY2FjaGVJbml0aWFsUXVhbnRpdGllcygpO1xyXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xyXG4gIH1cclxuXHJcbiAgX2FkZFRvQ2FydChldmVudCkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIFxyXG4gICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICBjb25zdCAkZm9ybSA9ICR0YXJnZXQuY2xvc2VzdCgnZm9ybScpO1xyXG4gICAgY29uc3QgZm9ybURhdGEgPSAkZm9ybS5zZXJpYWxpemUoKTsgXHJcblxyXG4gICAgY29uc29sZS5sb2coJ0Zvcm0gZGF0YSBiZWluZyBzZW50IHRvIEFQSTonLCBmb3JtRGF0YSk7IC8vIERlYnVnIGxpbmVcclxuXHJcbiAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCk7XHJcblxyXG4gICAgLy8gVXNlIHRoZSBCaWdDb21tZXJjZSBTdGVuY2lsIHV0aWxpdHkgdG8gYWRkIHRoZSBpdGVtIHRvIHRoZSBjYXJ0XHJcbiAgICB1dGlscy5hcGkuY2FydC5pdGVtQWRkKGZvcm1EYXRhLCAoZXJyLCByZXNwb25zZSkgPT4ge1xyXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSAnc3VjY2VlZCcpIHtcclxuICAgICAgICAgICAgcmVmcmVzaENvbnRlbnQodGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlLCB0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5kYXRhLmVycm9ycy5qb2luKCdcXG4nKSB8fCBcIlVuZm9ydHVuYXRlbHksIHRoaXMgcHJvZHVjdCBpcyBub3QgYXZhaWxhYmxlIGZvciBwdXJjaGFzZS5cIjtcclxuICAgICAgICAgICAgdGhpcy5jYXJ0QWxlcnRzLmVycm9yKGVycm9yTWVzc2FnZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbl9iaW5kRXZlbnRzKCkge1xyXG4gIHRoaXMuJGNhcnRDb250ZW50Lm9uKCdjaGFuZ2UnLCB0aGlzLnF1YW50aXR5SW5wdXQsIF8uYmluZChfLmRlYm91bmNlKHRoaXMuX3VwZGF0ZUNhcnRJdGVtLCA3NTApLCB0aGlzKSk7XHJcblxyXG4gIC8vIEF0dGFjaCBldmVudCBoYW5kbGVyIGZvciBhZGQtdG8tY2FydCBidXR0b25zXHJcbiAgJCgnYm9keScpLm9uKCdjbGljaycsICdbZGF0YS1idXR0b24tcHVyY2hhc2VdJywgKGV2ZW50KSA9PiB0aGlzLl9hZGRUb0NhcnQoZXZlbnQpKTtcclxuXHJcbiAgdGhpcy4kY2FydENvbnRlbnQub24oJ2NoYW5nZScsICdbZGF0YS1xdWFudGl0eS1jb250cm9sLWlucHV0XScsIChldnQpID0+IHtcclxuICAgICAgY29uc3QgJHRhcmdldCA9ICQoZXZ0LnRhcmdldCk7XHJcbiAgICAgIGNvbnN0IGl0ZW1JZCA9ICR0YXJnZXQuY2xvc2VzdCgnW2RhdGEtcXVhbnRpdHktY29udHJvbF0nKS5kYXRhKCdxdWFudGl0eS1jb250cm9sJyk7XHJcblxyXG4gICAgICB0aGlzLnByb2R1Y3REYXRhW2l0ZW1JZF0ucXVhbnRpdHlBbHRlcmVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5wcm9kdWN0RGF0YVtpdGVtSWRdLm5ld1F1YW50aXR5ID0gcGFyc2VJbnQoJHRhcmdldC52YWwoKSwgMTApO1xyXG4gIH0pO1xyXG5cclxuICB0aGlzLiRjYXJ0Q29udGVudC5vbignY2xpY2snLCAnW2RhdGEtY2FydC1pdGVtLXJlbW92ZV0nLCAoZXZlbnQpID0+IHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgdGhpcy5fcmVtb3ZlQ2FydEl0ZW0oZXZlbnQpO1xyXG4gIH0pO1xyXG5cclxuICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5taW5pLWNhcnQgW2RhdGEtY2FydC1pdGVtLXJlbW92ZV0nLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLndpbGxVcGRhdGUoKTtcclxuICB9KTtcclxuXHJcbiAgdXRpbHMuaG9va3Mub24oJ2NhcnQtaXRlbS1yZW1vdmUtcmVtb3RlJywgKCkgPT4ge1xyXG4gICAgICByZWZyZXNoQ29udGVudCh0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUsIHRydWUpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBFbnN1cmUgdGhlIENhcnRVdGlscyBpcyBpbml0aWFsaXplZCBhZnRlciBkb2N1bWVudCBpcyByZWFkeVxyXG4gICQoZG9jdW1lbnQpLnJlYWR5KCgpID0+IHtcclxuICAgICAgY29uc3QgY2FydFV0aWxzID0gbmV3IENhcnRVdGlscygpO1xyXG4gICAgICBjYXJ0VXRpbHMuaW5pdCgpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbiAgX2NhY2hlSW5pdGlhbFF1YW50aXRpZXMoKSB7XHJcbiAgICAkKCdbZGF0YS1jYXJ0LWl0ZW1dJykuZWFjaCgoaSwgZWwpID0+IHtcclxuICAgICAgY29uc3QgJGNhcnRJdGVtID0gJChlbCk7XHJcbiAgICAgIGNvbnN0IGl0ZW1JZCA9ICRjYXJ0SXRlbS5kYXRhKCdpdGVtLWlkJyk7XHJcbiAgICAgIHRoaXMucHJvZHVjdERhdGFbaXRlbUlkXSA9IHtcclxuICAgICAgICBvbGRRdWFudGl0eTogcGFyc2VJbnQoJGNhcnRJdGVtLmZpbmQoJ1tkYXRhLXF1YW50aXR5LWNvbnRyb2wtaW5wdXRdJykuYXR0cigndmFsdWUnKSwgMTApLFxyXG4gICAgICAgIHF1YW50aXR5QWx0ZXJlZDogZmFsc2UsXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVDYXJ0SXRlbShldmVudCkge1xyXG4gICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICBjb25zdCAkY2FydEl0ZW0gPSAkdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWNhcnQtaXRlbV0nKTtcclxuICAgIGNvbnN0IGl0ZW1JZCA9ICRjYXJ0SXRlbS5kYXRhKCdpdGVtLWlkJyk7XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgpO1xyXG5cclxuICAgIGlmICh0aGlzLnByb2R1Y3REYXRhW2l0ZW1JZF0ucXVhbnRpdHlBbHRlcmVkKSB7XHJcbiAgICAgIGNvbnN0ICRxdWFudGl0eUlucHV0ID0gJGNhcnRJdGVtLmZpbmQoJ1tkYXRhLWNhcnQtaXRlbS1xdWFudGl0eS1pbnB1dF0nKTtcclxuICAgICAgY29uc3QgbmV3UXVhbnRpdHkgPSB0aGlzLnByb2R1Y3REYXRhW2l0ZW1JZF0ubmV3UXVhbnRpdHk7XHJcblxyXG4gICAgICB1dGlscy5hcGkuY2FydC5pdGVtVXBkYXRlKGl0ZW1JZCwgbmV3UXVhbnRpdHksIChlcnIsIHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSAnc3VjY2VlZCcpIHtcclxuICAgICAgICAgIGNvbnN0IHJlbW92ZSA9IChuZXdRdWFudGl0eSA9PT0gMCk7XHJcblxyXG4gICAgICAgICAgdGhpcy5wcm9kdWN0RGF0YVtpdGVtSWRdLm9sZFF1YW50aXR5ID0gbmV3UXVhbnRpdHk7XHJcbiAgICAgICAgICByZWZyZXNoQ29udGVudCh0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUsIHJlbW92ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICRxdWFudGl0eUlucHV0LnZhbCh0aGlzLnByb2R1Y3REYXRhW2l0ZW1JZF0ub2xkUXVhbnRpdHkpO1xyXG4gICAgICAgICAgdGhpcy5jYXJ0QWxlcnRzLmVycm9yKHJlc3BvbnNlLmRhdGEuZXJyb3JzLmpvaW4oJ1xcbicpLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRoaXMuY2FydFByb21vcy5lbXB0eSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9yZW1vdmVDYXJ0SXRlbShldmVudCkge1xyXG4gICAgY29uc3QgaXRlbUlkID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KCdbZGF0YS1jYXJ0LWl0ZW1dJykuZGF0YSgnaXRlbS1pZCcpO1xyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzLndpbGxVcGRhdGUoKTtcclxuXHJcbiAgICB1dGlscy5hcGkuY2FydC5pdGVtUmVtb3ZlKGl0ZW1JZCwgKGVyciwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSAnc3VjY2VlZCcpIHtcclxuICAgICAgICByZWZyZXNoQ29udGVudCh0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUsIHRydWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY2FydEFsZXJ0cy5lcnJvcihyZXNwb25zZS5kYXRhLmVycm9ycy5qb2luKCdcXG4nKSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cbiIsImltcG9ydCB1dGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XG5pbXBvcnQgQWxlcnQgZnJvbSAnLi4vY29tcG9uZW50cy9BbGVydCc7XG5pbXBvcnQgcmVmcmVzaENvbnRlbnQgZnJvbSAnLi9yZWZyZXNoQ29udGVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvdXBvbkNvZGVzIHtcbiAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbCA9ICQoZWwpO1xuICAgIHRoaXMuY291cG9uQWxlcnRzID0gbmV3IEFsZXJ0KCQoJ1tkYXRhLWFsZXJ0c10nKSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICBjb250ZXh0OiB7fSxcbiAgICAgICRzY29wZTogJCgnW2RhdGEtY2FydC10b3RhbHNdJyksXG4gICAgICB2aXNpYmxlQ2xhc3M6ICd2aXNpYmxlJyxcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuY2FsbGJhY2tzID0gJC5leHRlbmQoe1xuICAgICAgd2lsbFVwZGF0ZTogKCkgPT4gY29uc29sZS5sb2coJ1VwZGF0ZSByZXF1ZXN0ZWQuJyksXG4gICAgICBkaWRVcGRhdGU6ICgpID0+IGNvbnNvbGUubG9nKCdVcGRhdGUgZXhlY3V0ZWQuJyksXG4gICAgfSwgb3B0aW9ucy5jYWxsYmFja3MpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5vcHRpb25zLiRzY29wZS5vbignc3VibWl0JywgJ1tkYXRhLWNvdXBvbi1jb2RlLWZvcm1dJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fYWRkQ29kZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2FkZENvZGUoKSB7XG4gICAgY29uc3QgJGlucHV0ID0gJCgnW2RhdGEtY291cG9uLWNvZGUtaW5wdXRdJywgdGhpcy5vcHRpb25zLiRzY29wZSk7XG4gICAgY29uc3QgY29kZSA9ICRpbnB1dC52YWwoKTtcblxuICAgIHRoaXMuY291cG9uQWxlcnRzLmNsZWFyKCk7XG4gICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgpO1xuXG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICB0aGlzLmNvdXBvbkFsZXJ0cy5lcnJvcih0aGlzLm9wdGlvbnMuY29udGV4dC5jb3Vwb25Db2RlRW1wdHlJbnB1dCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgdXRpbHMuYXBpLmNhcnQuYXBwbHlDb2RlKGNvZGUsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UuZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICByZWZyZXNoQ29udGVudCh0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3Vwb25BbGVydHMuZXJyb3IocmVzcG9uc2UuZGF0YS5lcnJvcnMuam9pbignXFxuJyksIHRydWUpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcbmltcG9ydCBNb2RhbCBmcm9tICdiYy1tb2RhbCc7XG5pbXBvcnQgQXR0cmlidXRlc0hlbHBlciBmcm9tICcuLi9wcm9kdWN0L0F0dHJpYnV0ZXNIZWxwZXInO1xuaW1wb3J0IFNlbGVjdFdyYXBwZXIgZnJvbSAnLi4vY29tcG9uZW50cy9TZWxlY3RXcmFwcGVyJztcbmltcG9ydCBDb2xvclN3YXRjaCBmcm9tICcuLi9wcm9kdWN0L0NvbG9yU3dhdGNoJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FydEVkaXRPcHRpb25zIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmVsID0gJzxkaXYgaWQ9XCJjYXJ0LW9wdGlvbnMtbW9kYWxcIj4nO1xuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgdGhpcy5jYXJ0T3B0aW9uc01vZGFsID0gbmV3IE1vZGFsKHtcbiAgICAgIGVsOiB0aGlzLmVsLFxuICAgICAgbW9kYWxDbGFzczogJ2NhcnQtb3B0aW9ucy1tb2RhbCcsXG4gICAgICBhZnRlclNob3c6ICgkbW9kYWwpID0+IHtcbiAgICAgICAgdGhpcy5fZmV0Y2hQcm9kdWN0KCRtb2RhbCwgdGhpcy5pZCk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiBjb25zb2xlLmxvZygnVXBkYXRlIHJlcXVlc3RlZC4nKSxcbiAgICAgIGRpZFVwZGF0ZTogKCkgPT4gY29uc29sZS5sb2coJ1VwZGF0ZSBleGVjdXRlZC4nKSxcbiAgICB9LCBjYWxsYmFja3MpO1xuXG4gICAgLy8gQWJzdHJhY3RlZCBhdHRyaWJ1dGVzIGZ1bmN0aW9uYWxpdHlcbiAgICB0aGlzLmF0dHJpYnV0ZXNIZWxwZXIgPSBuZXcgQXR0cmlidXRlc0hlbHBlcignI0NhcnRFZGl0UHJvZHVjdEZpZWxkc0Zvcm0nKTtcblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgICQoJ2JvZHknKS5vbignY2xpY2snLCAnW2RhdGEtaXRlbS1lZGl0XScsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5pZCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YSgnaXRlbS1lZGl0Jyk7XG5cbiAgICAgIGlmICghdGhpcy5pZCkgeyByZXR1cm47IH1cblxuICAgICAgdGhpcy5jYXJ0T3B0aW9uc01vZGFsLm9wZW4oKTtcbiAgICB9KTtcblxuICAgICQoJ2JvZHknKS5vbignc3VibWl0JywgJyNDYXJ0RWRpdFByb2R1Y3RGaWVsZHNGb3JtJywgKCkgPT4ge1xuICAgICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBhamF4IGZldGNoIG9mIHByb2R1Y3QgYW5kIGFkZCB0byBtb2RhbC4gQmluZCBwcm9kdWN0IGZ1bmN0aW9uYWxpdHkgYW5kIHNob3cgdGhlIG1vZGFsXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkbW9kYWwgLSB0aGUgcm9vdCAoYXBwZW5kZWQpIG1vZGFsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAkaXRlbUlkIC0gcHJvZHVjdCBpZFxuICAgKi9cbiAgX2ZldGNoUHJvZHVjdCgkbW9kYWwsICRpdGVtSUQpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgdGVtcGxhdGU6ICdjYXJ0L2VkaXQtb3B0aW9ucycsXG4gICAgfTtcblxuICAgIHV0aWxzLmFwaS5wcm9kdWN0QXR0cmlidXRlcy5jb25maWd1cmVJbkNhcnQoJGl0ZW1JRCwgb3B0aW9ucywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICRtb2RhbFxuICAgICAgICAuZmluZCgnLm1vZGFsLWNvbnRlbnQnKVxuICAgICAgICAuYXBwZW5kKHJlc3BvbnNlLmNvbnRlbnQpXG4gICAgICAgIC5maW5kKCcuY2FydC1lZGl0LW9wdGlvbnMnKVxuICAgICAgICAuYWRkQ2xhc3MoJ2NhcnQtZWRpdC1vcHRpb25zLXZpc2libGUnKTtcblxuICAgICAgdGhpcy5jYXJ0T3B0aW9uc01vZGFsLnBvc2l0aW9uKCk7XG4gICAgICAkbW9kYWwuYWRkQ2xhc3MoJ2xvYWRlZCcpO1xuXG4gICAgICBjb25zdCAkc2VsZWN0ID0gJG1vZGFsLmZpbmQoJ3NlbGVjdCcpO1xuICAgICAgaWYgKCRzZWxlY3QubGVuZ3RoKSB7XG4gICAgICAgICRzZWxlY3QuZWFjaCgoaSwgZWwpID0+IHtcbiAgICAgICAgICBuZXcgU2VsZWN0V3JhcHBlcihlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN3YXRjaGVzID0gbmV3IENvbG9yU3dhdGNoKCk7IC8vIEluaXQgb3VyIGNvbG9yIHN3YXRjaGVzXG5cbiAgICAgIHV0aWxzLmhvb2tzLm9uKCdwcm9kdWN0LW9wdGlvbi1jaGFuZ2UnLCAoZXZlbnQsIG9wdGlvbikgPT4ge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCk7XG4gICAgICAgIGNvbnN0ICRjaGFuZ2VkT3B0aW9uID0gJChvcHRpb24pO1xuICAgICAgICBjb25zdCAkZm9ybSA9ICQoJyNDYXJ0RWRpdFByb2R1Y3RGaWVsZHNGb3JtJyk7XG4gICAgICAgIGNvbnN0ICRzdWJtaXQgPSAkKCdpbnB1dFt0eXBlPVwic3VibWl0XCJdJywgJGZvcm0pO1xuICAgICAgICBjb25zdCAkbWVzc2FnZUJveCA9ICQoJ1tkYXRhLXJlY29uZmlndXJlLWVycm9yc10nKTtcbiAgICAgICAgY29uc3QgaXRlbSA9ICQoJ1tuYW1lPVwiaXRlbV9pZFwiXScsICRmb3JtKS5hdHRyKCd2YWx1ZScpO1xuXG4gICAgICAgIHV0aWxzLmFwaS5wcm9kdWN0QXR0cmlidXRlcy5vcHRpb25DaGFuZ2UoaXRlbSwgJGZvcm0uc2VyaWFsaXplKCksICdjYXJ0L2VkaXQtb3B0aW9ucycsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSByZXN1bHQuZGF0YSB8fCB7fTtcblxuICAgICAgICAgIHRoaXMuYXR0cmlidXRlc0hlbHBlci51cGRhdGVBdHRyaWJ1dGVzKGRhdGEpO1xuXG4gICAgICAgICAgaWYgKGRhdGEucHVyY2hhc2luZ19tZXNzYWdlKSB7XG4gICAgICAgICAgICAkKCRtZXNzYWdlQm94KS5odG1sKGRhdGEucHVyY2hhc2luZ19tZXNzYWdlKTtcbiAgICAgICAgICAgICRzdWJtaXQucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICRtZXNzYWdlQm94LnNob3coKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHN1Ym1pdC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICRtZXNzYWdlQm94LmhpZGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRhdGEucHVyY2hhc2FibGUgfHwgIWRhdGEuaW5zdG9jaykge1xuICAgICAgICAgICAgJHN1Ym1pdC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc3VibWl0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgdXRpbHMuaG9va3MuZW1pdCgncHJvZHVjdC1vcHRpb24tY2hhbmdlJyk7XG4gICAgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcbmltcG9ydCBBbGVydCBmcm9tICcuLi9jb21wb25lbnRzL0FsZXJ0JztcbmltcG9ydCByZWZyZXNoQ29udGVudCBmcm9tICcuL3JlZnJlc2hDb250ZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2lmdENlcnRpZmljYXRlcyB7XG4gIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcbiAgICB0aGlzLmNlcnRpZmljYXRlQWxlcnRzID0gbmV3IEFsZXJ0KCQoJ1tkYXRhLWFsZXJ0c10nKSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICBjb250ZXh0OiB7fSxcbiAgICAgICRzY29wZTogJCgnW2RhdGEtY2FydC10b3RhbHNdJyksXG4gICAgICB2aXNpYmxlQ2xhc3M6ICd2aXNpYmxlJyxcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuY2FsbGJhY2tzID0gJC5leHRlbmQoe1xuICAgICAgd2lsbFVwZGF0ZTogKCkgPT4gY29uc29sZS5sb2coJ1VwZGF0ZSByZXF1ZXN0ZWQuJyksXG4gICAgICBkaWRVcGRhdGU6ICgpID0+IGNvbnNvbGUubG9nKCdVcGRhdGUgZXhlY3V0ZWQuJyksXG4gICAgfSwgb3B0aW9ucy5jYWxsYmFja3MpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5vcHRpb25zLiRzY29wZS5vbignY2xpY2snLCAnW2RhdGEtZ2lmdC1jZXJ0aWZpY2F0ZS10b2dnbGVdJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fdG9nZ2xlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuJHNjb3BlLm9uKCdzdWJtaXQnLCAnW2RhdGEtZ2lmdC1jZXJ0aWZpY2F0ZS1mb3JtXScsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX2FkZENvZGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF90b2dnbGUoKSB7XG4gICAgJCgnW2RhdGEtZ2lmdC1jZXJ0aWZpY2F0ZS1mb3JtXScsIHRoaXMub3B0aW9ucy4kc2NvcGUpLnRvZ2dsZUNsYXNzKHRoaXMub3B0aW9ucy52aXNpYmxlQ2xhc3MpO1xuICB9XG5cbiAgX2FkZENvZGUoKSB7XG4gICAgY29uc3QgJGlucHV0ID0gJCgnW2RhdGEtZ2lmdC1jZXJ0aWZpY2F0ZS1pbnB1dF0nLCB0aGlzLm9wdGlvbnMuJHNjb3BlKTtcbiAgICBjb25zdCBjb2RlID0gJGlucHV0LnZhbCgpO1xuXG4gICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgpO1xuXG4gICAgaWYgKCEgdGhpcy5faXNWYWxpZENvZGUoY29kZSkpIHtcbiAgICAgIHRoaXMuY2VydGlmaWNhdGVBbGVydHMuZXJyb3IodGhpcy5vcHRpb25zLmNvbnRleHQuZ2lmdENlcnRpZmljYXRlSW5wdXRFbXB0eSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgdXRpbHMuYXBpLmNhcnQuYXBwbHlHaWZ0Q2VydGlmaWNhdGUoY29kZSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgIHJlZnJlc2hDb250ZW50KHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlQWxlcnRzLmVycm9yKHJlc3BvbnNlLmRhdGEuZXJyb3JzLmpvaW4oJ1xcbicpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfaXNWYWxpZENvZGUoY29kZSkge1xuICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcbmltcG9ydCBNb2RhbCBmcm9tICdiYy1tb2RhbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdpZnRXcmFwcGluZyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgIHNjb3BlOiAnW2RhdGEtY2FydC1jb250ZW50XScsXG4gICAgICB0cmlnZ2VyOiAnW2RhdGEtaXRlbS1naWZ0d3JhcF0nLFxuICAgICAgcmVtb3ZlOiAnW2RhdGEtZ2lmdHdyYXAtcmVtb3ZlXScsXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLiRjYXJ0Q29udGVudCA9ICQodGhpcy5vcHRpb25zLnNjb3BlKTtcbiAgICB0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gIH1cblxuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLml0ZW1JZDsgLy8gbGF0ZXIgYXNzaWduZWQgdGhlIGlkIG9mIHRoZSBjdXJyZW50IHByb2R1Y3RcblxuICAgIHRoaXMuR2lmdFdyYXBNb2RhbCA9IG5ldyBNb2RhbCh7XG4gICAgICBtb2RhbENsYXNzOiAnZ2lmdHdyYXAtbW9kYWwnLFxuICAgICAgYWZ0ZXJTaG93OiAoJG1vZGFsKSA9PiB7XG4gICAgICAgIHRoaXMuX2dldEZvcm0oJG1vZGFsKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLl9iaW5kUGFnZUV2ZW50cygpO1xuICB9XG5cbiAgLy8gQmluZCBmdW5jdGlvbmFsaXR5IHRvIGdpZnR3cmFwIGxpbmtzLlxuICBfYmluZFBhZ2VFdmVudHMoKSB7XG4gICAgdGhpcy4kY2FydENvbnRlbnQub24oJ2NsaWNrJywgdGhpcy5vcHRpb25zLnRyaWdnZXIsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgdGhpcy5pdGVtSWQgPSAkdGFyZ2V0LmRhdGEoJ2l0ZW0tZ2lmdHdyYXAnKTtcblxuICAgICAgdGhpcy5HaWZ0V3JhcE1vZGFsLm9wZW4oKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGNhcnRDb250ZW50Lm9uKCdjbGljaycsIHRoaXMub3B0aW9ucy5yZW1vdmUsIChldmVudCkgPT4ge1xuICAgICAgaWYoIWNvbmZpcm0odGhpcy5jb250ZXh0LnJlbW92ZUdpZnRXcmFwKSkge2V2ZW50LnByZXZlbnREZWZhdWx0KCl9O1xuICAgIH0pO1xuXG4gICAgJCgnYm9keScpLm9uKCdjbGljaycsICcuYnV0dG9uLWNhbmNlbC1naWZ0d3JhcCcsICgpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHRoaXMuR2lmdFdyYXBNb2RhbC5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUnVuIG9uY2UgdGhlIG1vZGFsIGhhcyBiZWVuIG9wZW5lZC4uXG4gIF9nZXRGb3JtKCRtb2RhbCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IHRlbXBsYXRlOiAnY2FydC9naWZ0d3JhcC1mb3JtJyB9O1xuXG4gICAgdXRpbHMuYXBpLmNhcnQuZ2V0SXRlbUdpZnRXcmFwcGluZ09wdGlvbnModGhpcy5pdGVtSWQsIG9wdGlvbnMsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgJG1vZGFsLmZpbmQoJy5tb2RhbC1jb250ZW50JykuYXBwZW5kKHJlc3BvbnNlLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLl9iaW5kTW9kYWxFdmVudHMoJG1vZGFsKTtcblxuICAgICAgICAvLyByZXBvc2l0aW9uIG1vZGFsIHdpdGggY29udGVudFxuICAgICAgICB0aGlzLkdpZnRXcmFwTW9kYWwucG9zaXRpb24oKTtcblxuICAgICAgICAvLyBDbGFzcyBhZGRlZCB0byBkaXNwbGF5IHRoZSBtb2RhbCBvbmNlIGNvbnRlbnQgaXMgYXZhaWxhYmxlXG4gICAgICAgICRtb2RhbC5hZGRDbGFzcygndmlzaWJsZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5HaWZ0V3JhcE1vZGFsLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfYmluZE1vZGFsRXZlbnRzKCRtb2RhbCkge1xuICAgICRtb2RhbC5vbignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgdGhpcy5HaWZ0V3JhcE1vZGFsLnBvc2l0aW9uKCk7XG4gICAgfSk7XG5cbiAgICAvLyBTZWxlY3QgZ2lmdHdyYXBwaW5nIGluZGl2aWR1YWxseSBvciB0b2dldGhlclxuICAgICRtb2RhbC5maW5kKCdbZGF0YS1naWZ0d3JhcC10eXBlXScpLm9uKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZVNpbmdsZU11bHRpcGxlKCRtb2RhbCwgZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBTZWxlY3QgdGhlIHR5cGUgb2YgZ2lmdCB3cmFwcGluZyBmb3IgYSBwYXJ0aWN1bGFyIGl0ZW1cbiAgICAkKCdbZGF0YS1naWZ0d3JhcC1zZWxlY3RdJykuY2hhbmdlKChldmVudCkgPT4ge1xuICAgICAgY29uc3QgJHNlbGVjdCA9ICQoZXZlbnQudGFyZ2V0KTtcbiAgICAgIGNvbnN0IGluZGV4ID0gJHNlbGVjdC5kYXRhKCdpbmRleCcpO1xuICAgICAgY29uc3QgaWQgPSAkc2VsZWN0LnZhbCgpO1xuXG4gICAgICBpZiAoIWlkKSB7IHJldHVybjsgfVxuICAgICAgY29uc3QgYWxsb3dNZXNzYWdlID0gJHNlbGVjdC5maW5kKGBvcHRpb25bdmFsdWU9JHtpZH1dYCkuZGF0YSgnYWxsb3ctbWVzc2FnZScpO1xuXG4gICAgICAkKGBbZGF0YS1naWZ0d3JhcC1pbWFnZS0ke2luZGV4fV1gKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAkKGBbZGF0YS1naWZ0d3JhcC1pbWFnZS0ke2luZGV4fT1cIiR7aWR9XCJdYCkucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuXG4gICAgICBpZiAoYWxsb3dNZXNzYWdlKSB7XG4gICAgICAgICQoYFtkYXRhLWdpZnR3cmFwLW1lc3NhZ2UtJHtpbmRleH1dYCkucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChgW2RhdGEtZ2lmdHdyYXAtbWVzc2FnZS0ke2luZGV4fV1gKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAkKCdbZGF0YS1naWZ0d3JhcC1zZWxlY3RdJykudHJpZ2dlcignY2hhbmdlJyk7XG4gIH1cblxuICAvLyBUb2dnbGVzIGRpc3BsYXlpbmcgc2luZ2xlIC8gbXVsdGlwbGUgd3JhcCBvcHRpb25zXG4gIF90b2dnbGVTaW5nbGVNdWx0aXBsZSgkbW9kYWwsIHZhbHVlKSB7XG4gICAgY29uc3QgJHNpbmdsZUZvcm0gPSAkbW9kYWwuZmluZCgnW2RhdGEtZ2lmdHdyYXAtc2luZ2xlXScpO1xuICAgIGNvbnN0ICRtdWx0aUZvcm0gID0gJG1vZGFsLmZpbmQoJ1tkYXRhLWdpZnR3cmFwLW11bHRpcGxlXScpO1xuXG4gICAgaWYgKHZhbHVlID09PSAnZGlmZmVyZW50Jykge1xuICAgICAgJHNpbmdsZUZvcm0uYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgJG11bHRpRm9ybS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgfSAgZWxzZSB7XG4gICAgICAkc2luZ2xlRm9ybS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAkbXVsdGlGb3JtLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB1dGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XG5pbXBvcnQgQWxlcnQgZnJvbSAnLi4vY29tcG9uZW50cy9BbGVydCc7XG5pbXBvcnQgcmVmcmVzaENvbnRlbnQgZnJvbSAnLi9yZWZyZXNoQ29udGVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoaXBwaW5nQ2FsY3VsYXRvciB7XG4gIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcbiAgICB0aGlzLnNoaXBwaW5nQWxlcnRzID0gbmV3IEFsZXJ0KCQoJ1tkYXRhLWFsZXJ0c10nKSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICBjb250ZXh0OiB7fSxcbiAgICAgICRzY29wZTogJCgnW2RhdGEtY2FydC10b3RhbHNdJyksXG4gICAgICB2aXNpYmxlQ2xhc3M6ICd2aXNpYmxlJyxcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuY2FsbGJhY2tzID0gJC5leHRlbmQoe1xuICAgICAgd2lsbFVwZGF0ZTogKCkgPT4gY29uc29sZS5sb2coJ1VwZGF0ZSByZXF1ZXN0ZWQuJyksXG4gICAgICBkaWRVcGRhdGU6ICgpID0+IGNvbnNvbGUubG9nKCdVcGRhdGUgZXhlY3V0ZWQuJyksXG4gICAgfSwgb3B0aW9ucy5jYWxsYmFja3MpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5vcHRpb25zLiRzY29wZS5vbignY2xpY2snLCAnW2RhdGEtc2hpcHBpbmctY2FsY3VsYXRvci10b2dnbGVdJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fdG9nZ2xlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuJHNjb3BlLm9uKCdzdWJtaXQnLCAnW2RhdGEtc2hpcHBpbmctY2FsY3VsYXRvcl0gZm9ybScsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZVNoaXBwaW5nKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuJHNjb3BlLm9uKCdjaGFuZ2UnLCAnc2VsZWN0W25hbWU9XCJzaGlwcGluZy1jb3VudHJ5XCJdJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVTdGF0ZXMoZXZlbnQpO1xuICAgICAgdGhpcy5vcHRpb25zLiRzY29wZS5maW5kKCdbbmFtZT1cInNoaXBwaW5nLXppcFwiXScpLnZhbCgnJyk7XG4gICAgfSk7XG4gIH1cblxuICBfdG9nZ2xlKCkge1xuICAgICQoJ1tkYXRhLXNoaXBwaW5nLWNhbGN1bGF0b3JdJywgdGhpcy5vcHRpb25zLiRzY29wZSkudG9nZ2xlQ2xhc3ModGhpcy5vcHRpb25zLnZpc2libGVDbGFzcyk7XG4gIH1cblxuICBfdXBkYXRlU3RhdGVzKGV2ZW50KSB7XG4gICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgY29uc3QgY291bnRyeSA9ICR0YXJnZXQudmFsKCk7XG4gICAgY29uc3QgJHN0YXRlRWxlbWVudCA9ICQoJ1tuYW1lPVwic2hpcHBpbmctc3RhdGVcIl0nKTtcblxuICAgIHV0aWxzLmFwaS5jb3VudHJ5LmdldEJ5TmFtZShjb3VudHJ5LCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuc3RhdGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBzdGF0ZUFycmF5ID0gW107XG4gICAgICAgIHN0YXRlQXJyYXkucHVzaChgPG9wdGlvbiB2YWx1ZT1cIlwiPiR7cmVzcG9uc2UuZGF0YS5wcmVmaXh9PC9vcHRpb24+YCk7XG4gICAgICAgICQuZWFjaChyZXNwb25zZS5kYXRhLnN0YXRlcywgKGksIHN0YXRlKSA9PiB7XG4gICAgICAgICAgc3RhdGVBcnJheS5wdXNoKGA8b3B0aW9uIHZhbHVlPVwiJHtzdGF0ZS5pZH1cIj4ke3N0YXRlLm5hbWV9PC9vcHRpb24+YCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkc3RhdGVFbGVtZW50LnBhcmVudCgpLmFkZENsYXNzKCdmb3JtLXNlbGVjdC13cmFwcGVyJyk7XG4gICAgICAgICRzdGF0ZUVsZW1lbnQucmVwbGFjZVdpdGgoYDxzZWxlY3QgY2xhc3M9XCJmb3JtLXNlbGVjdCBmb3JtLWlucHV0IGZvcm0taW5wdXQtc2hvcnRcIiBpZD1cInNoaXBwaW5nLXN0YXRlXCIgbmFtZT1cInNoaXBwaW5nLXN0YXRlXCIgZGF0YS1maWVsZC10eXBlPVwiU3RhdGVcIj4ke3N0YXRlQXJyYXkuam9pbignICcpfTwvc2VsZWN0PmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHN0YXRlRWxlbWVudC5wYXJlbnQoKS5yZW1vdmVDbGFzcygnZm9ybS1zZWxlY3Qtd3JhcHBlcicpO1xuICAgICAgICAkc3RhdGVFbGVtZW50LnJlcGxhY2VXaXRoKGA8aW5wdXQgY2xhc3M9XCJmb3JtLWlucHV0IGZvcm0taW5wdXQtc2hvcnRcIiB0eXBlPVwidGV4dFwiIGlkPVwic2hpcHBpbmctc3RhdGVcIiBuYW1lPVwic2hpcHBpbmctc3RhdGVcIiBkYXRhLWZpZWxkLXR5cGU9XCJTdGF0ZVwiIHBsYWNlaG9sZGVyPVwiJHt0aGlzLm9wdGlvbnMuY29udGV4dC5zaGlwcGluZ1N0YXRlfVwiPmApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2NhbGN1bGF0ZVNoaXBwaW5nKCkge1xuICAgIHRoaXMuY2FsbGJhY2tzLndpbGxVcGRhdGUoKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGNvdW50cnlfaWQ6ICQoJ1tuYW1lPVwic2hpcHBpbmctY291bnRyeVwiXScsIHRoaXMuJGNhbGN1bGF0b3JGb3JtKS52YWwoKSxcbiAgICAgIHN0YXRlX2lkOiAkKCdbbmFtZT1cInNoaXBwaW5nLXN0YXRlXCJdJywgdGhpcy4kY2FsY3VsYXRvckZvcm0pLnZhbCgpLFxuICAgICAgemlwX2NvZGU6ICQoJ1tuYW1lPVwic2hpcHBpbmctemlwXCJdJywgdGhpcy4kY2FsY3VsYXRvckZvcm0pLnZhbCgpXG4gICAgfTtcblxuICAgIHV0aWxzLmFwaS5jYXJ0LmdldFNoaXBwaW5nUXVvdGVzKHBhcmFtcywgJ2NhcnQvc2hpcHBpbmctcXVvdGVzJywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGNvbnN0ICRzaGlwcGluZ1F1b3RlcyA9ICQoJ1tkYXRhLXNoaXBwaW5nLXF1b3Rlc10nLCB0aGlzLm9wdGlvbnMuJHNjb3BlKTtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhLnF1b3Rlcykge1xuICAgICAgICB0aGlzLnNoaXBwaW5nQWxlcnRzLmNsZWFyKCk7XG4gICAgICAgICRzaGlwcGluZ1F1b3Rlcy5odG1sKHJlc3BvbnNlLmNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaGlwcGluZ0FsZXJ0cy5lcnJvcihyZXNwb25zZS5kYXRhLmVycm9ycy5qb2luKCdcXG4nKSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSgpO1xuXG4gICAgICAvLyBiaW5kIHRoZSBzaGlwcGluZyBtZXRob2QgcmFkaW9zXG4gICAgICAkc2hpcHBpbmdRdW90ZXMuZmluZCgnLmZvcm0nKS5vbignY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgpO1xuXG4gICAgICAgIGNvbnN0IHF1b3RlSWQgPSAkKCdbZGF0YS1zaGlwcGluZy1xdW90ZV06Y2hlY2tlZCcpLnZhbCgpO1xuXG4gICAgICAgIHV0aWxzLmFwaS5jYXJ0LnN1Ym1pdFNoaXBwaW5nUXVvdGUocXVvdGVJZCwgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgcmVmcmVzaENvbnRlbnQodGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGlkVXBkYXRlLCByZW1vdmUpIHtcbiAgY29uc3QgJGNhcnRUb3RhbHMgPSAkKCdbZGF0YS1jYXJ0LXRvdGFsc10nKTtcbiAgY29uc3QgJGNhcnRDb250ZW50ID0gJCgnW2RhdGEtY2FydC1jb250ZW50XScpO1xuICBjb25zdCAkY2FydFByb21vcyA9ICQoJ1tkYXRhLWNhcnQtcHJvbW9zXScpO1xuICBjb25zdCAkY2FydEl0ZW0gPSAkKCdbZGF0YS1jYXJ0LWl0ZW1dJywgJGNhcnRDb250ZW50KTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICB0ZW1wbGF0ZToge1xuICAgICAgY29udGVudDogJ2NhcnQvY29udGVudCcsXG4gICAgICB0b3RhbHM6ICdjYXJ0L3RvdGFscycsXG4gICAgICBwcm9tb3M6ICdoZWFkZXIvc2hpcHBpbmctbWVzc2FnZXMnXG4gICAgfSxcbiAgfTtcblxuICAvLyBSZW1vdmUgbGFzdCBpdGVtIGZyb20gY2FydD8gUmVsb2FkXG4gIGlmIChyZW1vdmUgJiYgJGNhcnRJdGVtLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cblxuICB1dGlscy5hcGkuY2FydC5nZXRDb250ZW50KG9wdGlvbnMsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgLy8gVE9ETzogU2NvcGUgdGhlIGNhbGwgdG8gdGhpcyBmdW5jdGlvbiBieSBhcmVhIHRoYXQgbmVlZHMgdXBkYXRpbmdcbiAgICAkY2FydENvbnRlbnQuaHRtbChyZXNwb25zZS5jb250ZW50KTtcbiAgICAkY2FydFRvdGFscy5odG1sKHJlc3BvbnNlLnRvdGFscyk7XG4gICAgJGNhcnRQcm9tb3MucmVwbGFjZVdpdGgocmVzcG9uc2UucHJvbW9zKTtcbiAgICAkY2FydENvbnRlbnQudHJpZ2dlcignY2FydC1pbml0aWFsaXplLW1vZHVsZXMnKTtcblxuICAgIC8vIFRPRE86IElmIHRoZSBsb2FkaW5nIG92ZXJsYXkgaXMgc2NvcGVkIHRvIGFuIGFyZWEgdGhhdCBpcyByZXBsYWNlZFxuICAgIC8vIGl0IGRvZXMgbm90IGZhZGUgb3V0LCBidXQgaXMgcmVtb3ZlZCBhYnJ1YnRseSAoZHVlIHRvIGJlaW5nIGFcbiAgICAvLyBwYXJ0IG9mIHRoYXQgYXJlYSdzIGNvbnRlbnQpLlxuICAgIGRpZFVwZGF0ZSgpO1xuICB9KTtcbn1cbiIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbGVydCB7XHJcbiAgY29uc3RydWN0b3IoJGVsLCBvcHRpb25zID0ge30pIHtcclxuXHJcbiAgICB0aGlzLiRlbCA9ICRlbDtcclxuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgIGJhc2U6ICdhbGVydCcsXHJcbiAgICAgICAgZXJyb3I6ICdhbGVydC1lcnJvcicsXHJcbiAgICAgICAgaW5mbzogJ2FsZXJ0LWluZm8nLFxyXG4gICAgICAgIHN1Y2Nlc3M6ICdhbGVydC1zdWNjZXNzJyxcclxuICAgICAgfSxcclxuICAgICAgbGltaXQ6IDEsXHJcbiAgICAgIHRlbXBsYXRlOiB7fSxcclxuICAgICAgY2FsbGJhY2tzOiB7fSxcclxuICAgIH0sIG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzID0gJC5leHRlbmQoe1xyXG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiB7fSxcclxuICAgICAgZGlkVXBkYXRlOiAoKSA9PiB7fSxcclxuICAgIH0sIG9wdGlvbnMuY2FsbGJhY2tzKTtcclxuXHJcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XHJcbiAgfVxyXG5cclxuICBfYmluZEV2ZW50cygpIHtcclxuICAgIGlmIChfLmlzRW1wdHkodGhpcy5vcHRpb25zLnRlbXBsYXRlKSkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMudGVtcGxhdGUgPSBfLnRlbXBsYXRlKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPScke3RoaXMub3B0aW9ucy5jbGFzc2VzLmJhc2V9IDwlPSBtZXNzYWdlVHlwZSAlPic+XHJcbiAgICAgICAgICA8JSBpZiAoaXNEaXNtaXNzYWJsZSkgeyAlPlxyXG4gICAgICAgICAgICA8YSBjbGFzcz1cImFsZXJ0LWRpc21pc3NcIj4mdGltZXM7PC9hPlxyXG4gICAgICAgICAgPCUgfSAlPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LW1lc3NhZ2VcIj5cclxuICAgICAgICAgICAgPCU9IG1lc3NhZ2VUZXh0ICU+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgYCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy4kZWwub24oJ2NsaWNrJywgJy5hbGVydC1kaXNtaXNzJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGNvbnN0ICRhbGVydCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkucGFyZW50KCcuYWxlcnQnKTtcclxuICAgICAgdGhpcy5fZGlzbWlzc01lc3NhZ2UoJGFsZXJ0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuJGVsLm9uKCdjbGVhci1tZXNzYWdlcycsICgpID0+IHtcclxuICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byByZXNldCB0aGUgY29udGVudHMgb2YgdGhpcy4kZWxcclxuICAgKi9cclxuICBjbGVhcigpIHtcclxuICAgIHRoaXMuJGVsLmZpbmQoYC4ke3RoaXMub3B0aW9ucy5jbGFzc2VzLmJhc2V9YCkuZWFjaCgoaW5kZXgsIHRhcmdldCkgPT4ge1xyXG4gICAgICB0aGlzLl9kaXNtaXNzTWVzc2FnZSgkKHRhcmdldCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiBiYy1jb3JlIGJlY29tZXMgaW50ZWdyYXRlZCBpbnRvIGJjLXNrZWxldG9uLCB0aGlzIG1ldGhvZCBzaG91bGQgZGVsZWdhdGUgdG8gYGRpc21pc3NhYmxlKClgXHJcbiAgICogQHBhcmFtICRhbGVydFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2Rpc21pc3NNZXNzYWdlKCRhbGVydCkge1xyXG4gICAgJGFsZXJ0LmFkZENsYXNzKCdkaXNtaXNzZWQnKTtcclxuICAgICRhbGVydC5vbmUoJ3RyZW5kJywgKCkgPT4ge1xyXG4gICAgICAkYWxlcnQucmVtb3ZlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4cGxpY2l0IHVzYWdlIHRvIGNyZWF0ZSBhbiBlcnJvciBhbGVydFxyXG4gICAqIEBwYXJhbSB0ZXh0XHJcbiAgICogQHBhcmFtIGRpc21pc3NhYmxlXHJcbiAgICovXHJcbiAgZXJyb3IodGV4dCwgZGlzbWlzc2FibGUgPSBmYWxzZSl7XHJcbiAgICB0aGlzLm1lc3NhZ2UodGV4dCwgJ2Vycm9yJywgZGlzbWlzc2FibGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhwbGljaXQgdXNhZ2UgdG8gY3JlYXRlIGEgc3VjY2VzcyBhbGVydFxyXG4gICAqIEBwYXJhbSB0ZXh0XHJcbiAgICogQHBhcmFtIGRpc21pc3NhYmxlXHJcbiAgICovXHJcbiAgc3VjY2Vzcyh0ZXh0LCBkaXNtaXNzYWJsZSA9IGZhbHNlKXtcclxuICAgIHRoaXMubWVzc2FnZSh0ZXh0LCAnc3VjY2VzcycsIGRpc21pc3NhYmxlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4cGxpY2l0IHVzYWdlIHRvIGNyZWF0ZSBhbiBpbmZvcm1hdGlvbmFsIGFsZXJ0XHJcbiAgICogQHBhcmFtIHRleHRcclxuICAgKiBAcGFyYW0gZGlzbWlzc2FibGVcclxuICAgKi9cclxuICBpbmZvKHRleHQsIGRpc21pc3NhYmxlID0gZmFsc2Upe1xyXG4gICAgdGhpcy5tZXNzYWdlKHRleHQsICdpbmZvJywgZGlzbWlzc2FibGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdGV4dFxyXG4gICAqIEBwYXJhbSB0eXBlXHJcbiAgICogQHBhcmFtIGRpc21pc3NhYmxlXHJcbiAgICovXHJcbiAgbWVzc2FnZSh0ZXh0LCB0eXBlID0gJ2luZm8nLCBkaXNtaXNzYWJsZSA9IGZhbHNlKSB7XHJcbiAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubGltaXQgPT09ICdudW1iZXInICYmIHRoaXMuJGVsLmZpbmQoYC4ke3RoaXMub3B0aW9ucy5jbGFzc2VzLmJhc2V9YCkubGVuZ3RoID4gdGhpcy5vcHRpb25zLmxpbWl0KSB7XHJcbiAgICAgIHRoaXMuX2Rpc21pc3NNZXNzYWdlKHRoaXMuJGVsLmZpbmQoYC4ke3RoaXMub3B0aW9ucy5jbGFzc2VzLmJhc2V9Om5vdCguZGlzbWlzc2VkKWApLmVxKDApKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtZXNzYWdlID0ge1xyXG4gICAgICBtZXNzYWdlVHlwZTogdGhpcy5vcHRpb25zLmNsYXNzZXNbdHlwZV0sXHJcbiAgICAgIG1lc3NhZ2VUZXh0OiB0ZXh0LFxyXG4gICAgICBpc0Rpc21pc3NhYmxlOiBkaXNtaXNzYWJsZSxcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnN0ICRtb2RhbEJvZHkgPSAkKCcubW9kYWwtYm9keScpO1xyXG5cclxuICAgIGNvbnN0IGFwcGVuZE1lc3NhZ2UgPSAoJGVsKSA9PiB7XHJcbiAgICAgICRlbC5hcHBlbmQodGhpcy5vcHRpb25zLnRlbXBsYXRlKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJG1vZGFsQm9keS5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgcHJvZHVjdEFsZXJ0cyA9ICRtb2RhbEJvZHkuZmluZCgnW2RhdGEtcHJvZHVjdC1hbGVydHNdJyk7XHJcbiAgICAgIGFwcGVuZE1lc3NhZ2UocHJvZHVjdEFsZXJ0cyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBhbGVydHMgPSAkKCcuc2l0ZS1oZWFkZXInKS5maW5kKCdbZGF0YS1hbGVydHNdJyk7XHJcbiAgICAgIGFwcGVuZE1lc3NhZ2UoYWxlcnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YW50aXR5V2lkZ2V0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgZWw6ICdbZGF0YS1xdWFudGl0eS1jb250cm9sXScsXG4gICAgICBjbnRybDogJ1tkYXRhLXF1YW50aXR5LWNvbnRyb2wtYWN0aW9uXScsXG4gICAgICBzY29wZTogJ2JvZHknLFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gQmluZCBDb250cm9sIEFjdGlvbnNcbiAgICAkKHRoaXMub3B0aW9ucy5zY29wZSkub24oJ2NsaWNrJywgdGhpcy5vcHRpb25zLmNudHJsLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vaW4gY2FzZSB3ZSB1c2UgPGJ1dHRvbj4vPGE+IGluc3RlYWQgb2YgPHNwYW4+J3NcbiAgICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCk7XG4gICAgICBjb25zdCBhY3Rpb24gPSAkdGFyZ2V0LmRhdGEoJ3F1YW50aXR5LWNvbnRyb2wtYWN0aW9uJyk7XG5cbiAgICAgIGNvbnN0ICRxdWFudGl0eUlucHV0ID0gJHRhcmdldC5zaWJsaW5ncygnaW5wdXQnKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQoJHF1YW50aXR5SW5wdXQudmFsKCksMTApO1xuICAgICAgY29uc3QgbWluID0gJHF1YW50aXR5SW5wdXQuYXR0cignbWluJykgPyBwYXJzZUludCgkcXVhbnRpdHlJbnB1dC5hdHRyKCdtaW4nKSwxMCkgOiAwO1xuICAgICAgY29uc3QgbWF4ID0gJHF1YW50aXR5SW5wdXQuYXR0cignbWF4JykgPyBwYXJzZUludCgkcXVhbnRpdHlJbnB1dC5hdHRyKCdtYXgnKSwxMCkgOiBJbmZpbml0eTtcblxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ2luY3JlbWVudCcgJiYgdmFsdWUgPCBtYXgpIHtcbiAgICAgICAgJHF1YW50aXR5SW5wdXQudmFsKHZhbHVlICsgMSkudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2RlY3JlbWVudCcgJiYgdmFsdWUgPiAwICYmIHZhbHVlID4gbWluKSB7XG4gICAgICAgICRxdWFudGl0eUlucHV0LnZhbCh2YWx1ZSAtIDEpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2ltcGxlIGlucHV0IHZhbGlkYXRpb24gKGtlZXAgaW5wdXQgd2l0aGluIG1pbi9tYXggcmFuZ2UpXG4gICAgLy8gRmVlbCBmcmVlIHRvIHJlbW92ZSBhbmQgcmVwbGFjZSB3aXRoIGFub3RoZXIgZm9ybSBvZiB2YWxpZGF0aW9uXG4gICAgJCh0aGlzLm9wdGlvbnMuc2NvcGUpLm9uKCdjaGFuZ2UnLCAnaW5wdXQnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KCR0YXJnZXQudmFsKCksMTApO1xuICAgICAgY29uc3QgbWluID0gJHRhcmdldC5hdHRyKCdtaW4nKSA/IHBhcnNlSW50KCR0YXJnZXQuYXR0cignbWluJyksMTApIDogMDtcbiAgICAgIGNvbnN0IG1heCA9ICR0YXJnZXQuYXR0cignbWF4JykgPyBwYXJzZUludCgkdGFyZ2V0LmF0dHIoJ21heCcpLDEwKSA6IEluZmluaXR5O1xuXG4gICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgLy9UT0RPOiBJbnRlZ3JhdGUgQWxlcnQgc3lzdGVtXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFF1YW50aXR5IFwiJHt2YWx1ZX1cIiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG1heGltdW0gKCR7bWF4fSlgKTtcbiAgICAgICAgJHRhcmdldC52YWwoJHRhcmdldC5hdHRyKCd2YWx1ZScpKTtcbiAgICAgIH0gaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFF1YW50aXR5IHZhbHVlIFwiJHt2YWx1ZX1cIiBjYW5ub3QgYmUgbGVzcyB0aGFuIG1pbmltdW0gKCR7bWlufSlgKTtcbiAgICAgICAgJHRhcmdldC52YWwoJHRhcmdldC5hdHRyKCd2YWx1ZScpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0V3JhcHBlciB7XG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcblxuICAgIGlmICghdGhpcy4kZWwucGFyZW50KCcuZm9ybS1zZWxlY3Qtd3JhcHBlcicpLmxlbmd0aCkge1xuICAgICAgdGhpcy4kZWwud3JhcCgnPGRpdiBjbGFzcz1cImZvcm0tc2VsZWN0LXdyYXBwZXJcIiAvPicpLnBhcmVudCgpLnByZXBlbmQoYDxzcGFuIGNsYXNzPVwic2VsZWN0ZWQtdGV4dFwiPiR7dGhpcy4kZWwuZmluZCgnb3B0aW9uOnNlbGVjdGVkJykudGV4dCgpfTwvc3Bhbj5gKTtcbiAgICB9XG5cbiAgICAvLyBDb25kaXRpb25hbCByZXF1aXJlZCBzbyBJIGNhbiB1c2UgdGhlIGN1cnJlbmN5IGNvZGUgYXMgb3Bwb3NlZCB0b1xuICAgIC8vIHRoZSBmdWxsIGN1cnJlbmN5IG5hbWUgaW4gdGhlIGN1cnJlbmN5IHN3aXRjaGVyXG4gICAgaWYgKCF0aGlzLiRlbC5jbG9zZXN0KCcuY3VycmVuY3ktc3dpdGNoZXInKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICB9XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRlbC5vbignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVTZWxlY3RUZXh0KCk7XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTZWxlY3RUZXh0KG9wdGlvbikge1xuICAgIGNvbnN0IG5ld09wdGlvbiA9IG9wdGlvbiA/IG9wdGlvbiA6IHRoaXMuJGVsLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLnRleHQoKTtcbiAgICB0aGlzLiRlbC5zaWJsaW5ncygnLnNlbGVjdGVkLXRleHQnKS50ZXh0KG5ld09wdGlvbik7XG4gIH1cbn1cbiIsIi8qKlxuICpcbiAqIEZvcm1WYWxpZGF0b3IgZG9lcyBub3QgY3VycmVudGx5IGV4aXN0IGluIHRoZSBjb3JlIGZpbGVzLCBpdCBpcyBiZWluZ1xuICogaW1wb3J0ZWQgZnJvbSB0aGUgdGhlbWUgc28gdGhhdCB0aGUgY3JlZGl0IGNhcmQgZm9ybSBjYW4gYmVuZWZpdCBmcm9tIGJlaW5nXG4gKiB2YWxpZGF0ZWQuIE1ha2Ugc3VyZSB0aGUgRm9ybVZhbGlkYXRvciBmaWxlIGV4aXN0cyBpbiB0aGUgdGhlbWUgb3IgdGhhdCB0aGlzXG4gKiBwYWdlIGlzIG5vdCBjYWxsZWQgaWYgYWRkaW5nIGl0IHRvIHRoZSB0aGVtZSB5b3UgYXJlIHdvcmtpbmcgb25cbiAqXG4gKi9cblxuaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uLy4uL1BhZ2VNYW5hZ2VyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgaW5pdEFsZXJ0RGlzbWlzc2FibGUgZnJvbSAnLi9hbGVydERpc21pc3NhYmxlJztcbmltcG9ydCBBbGVydCBmcm9tICcuLi9jb21wb25lbnRzL0FsZXJ0JztcbmltcG9ydCBGb3JtVmFsaWRhdG9yIGZyb20gJy4uL3V0aWxzL0Zvcm1WYWxpZGF0b3InO1xuaW1wb3J0IGluaXREb3dubG9hZEdhbGxlcnkgZnJvbSAnLi9kb3dubG9hZEdhbGxlcnknO1xuaW1wb3J0IHVwZGF0ZVN0YXRlIGZyb20gJy4vdXBkYXRlU3RhdGUnO1xuaW1wb3J0IHsgY3JlZGl0Q2FyZFR5cGUsIHN0b3JlSW5zdHJ1bWVudCwgVmFsaWRhdG9ycyBhcyBDQ1ZhbGlkYXRvcnMsIEZvcm1hdHRlcnMgYXMgQ0NGb3JtYXR0ZXJzIH0gZnJvbSAnLi9hY2NvdW50L3BheW1lbnRNZXRob2QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY2NvdW50IGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgbG9hZGVkKG5leHQpIHtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG5cbiAgICBjb25zdCAkcGF5bWVudE1ldGhvZEZvcm0gPSAkKCdmb3JtW2RhdGEtcGF5bWVudC1tZXRob2QtZm9ybV0nKTtcblxuICAgIGlmICgkcGF5bWVudE1ldGhvZEZvcm0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluaXRQYXltZW50TWV0aG9kRm9ybVZhbGlkYXRpb24oJHBheW1lbnRNZXRob2RGb3JtKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhZ2VBbGVydHMgPSBuZXcgQWxlcnQoJCgnW2RhdGEtYWxlcnRzXScpKTtcbiAgICB0aGlzLlZhbGlkYXRvciA9IG5ldyBGb3JtVmFsaWRhdG9yKHRoaXMuY29udGV4dCk7XG4gICAgdGhpcy5WYWxpZGF0b3IuaW5pdFNpbmdsZSgkKGRvY3VtZW50LmJvZHkpLmZpbmQoJ2Zvcm1bZGF0YS1wYXltZW50LW1ldGhvZC1mb3JtXScpKTtcbiAgICB1cGRhdGVTdGF0ZShmYWxzZSwgdGhpcy5zZWxlY3RXcmFwQ2FsbGJhY2spO1xuXG4gICAgbmV4dCgpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgaW5pdEFsZXJ0RGlzbWlzc2FibGUoKTtcbiAgICBpbml0RG93bmxvYWRHYWxsZXJ5KCk7XG5cbiAgICB1cGRhdGVTdGF0ZShmYWxzZSwgdGhpcy5zZWxlY3RXcmFwQ2FsbGJhY2spO1xuXG4gICAgY29uc3QgJHJlb3JkZXJGb3JtID0gJCgnW2RhdGEtYWNjb3VudC1yZW9yZGVyLWZvcm1dJyk7XG5cbiAgICBpZiAoJHJlb3JkZXJGb3JtLmxlbmd0aCkge1xuICAgICAgdGhpcy5pbml0UmVvcmRlckZvcm0oJHJlb3JkZXJGb3JtKTtcbiAgICB9XG5cbiAgICAvLyBUb2dnbGUgLSBhIHNpbXBsZSB3YXkgdG8gdG9nZ2xlIGVsZW1lbnRzXG4gICAgJChkb2N1bWVudC5ib2R5KS5vbignY2xpY2snLCAnW2RhdGEtYWNjb3VudC10b2dnbGVdJywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCAkZWwgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgY29uc3QgJHRhcmdldCA9ICQoJGVsLmRhdGEoJ2FjY291bnQtdG9nZ2xlJykpO1xuICAgICAgJHRhcmdldC50b2dnbGUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYmluZERlbGV0ZVBheW1lbnRNZXRob2QoKTtcbiAgfVxuXG4gIGluaXRSZW9yZGVyRm9ybSgkcmVvcmRlckZvcm0pIHtcbiAgICAkcmVvcmRlckZvcm0ub24oJ3N1Ym1pdCcsIChldmVudCkgPT4ge1xuICAgICAgbGV0IHN1Ym1pdEZvcm0gPSBmYWxzZTtcbiAgICAgIGxldCAkcHJvZHVjdFJlb3JkZXJDaGVja2JveGVzID0gJCgnLmFjY291bnQtaXRlbSAuZm9ybS1jaGVja2JveDpjaGVja2VkJyk7XG5cbiAgICAgICRyZW9yZGVyRm9ybS5maW5kKCdbbmFtZV49XCJyZW9yZGVyaXRlbVwiXScpLnJlbW92ZSgpO1xuXG4gICAgICAkcHJvZHVjdFJlb3JkZXJDaGVja2JveGVzLmVhY2goKGluZGV4LCBwcm9kdWN0Q2hlY2tib3gpID0+IHtcbiAgICAgICAgbGV0IHByb2R1Y3RJZCA9ICQocHJvZHVjdENoZWNrYm94KS52YWwoKTtcbiAgICAgICAgY29uc3QgJGlucHV0ID0gJCgnPGlucHV0PicsIHtcbiAgICAgICAgICB0eXBlOiAnaGlkZGVuJyxcbiAgICAgICAgICBuYW1lOiBgcmVvcmRlcml0ZW1bJHtwcm9kdWN0SWR9XWAsXG4gICAgICAgICAgdmFsdWU6ICcxJ1xuICAgICAgICB9KTtcblxuICAgICAgICBzdWJtaXRGb3JtID0gdHJ1ZTtcblxuICAgICAgICAkcmVvcmRlckZvcm0uYXBwZW5kKCRpbnB1dCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzdWJtaXRGb3JtKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICQoJy5hY2NvdW50LXRvb2xiYXIgLmFsZXJ0LWVycm9yJykuc2hvdygpO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjYWxsYmFjayBmaXJlZCB3aGVuIGEgZnJlc2ggc3RhdGUgPHNlbGVjdD4gZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgRE9NXG4gICAqL1xuICBzZWxlY3RXcmFwQ2FsbGJhY2soJHNlbGVjdEVsKSB7fSAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcbiAgKiBCaW5kcyBhIHN1Ym1pdCBob29rIHRvIGVuc3VyZSB0aGUgY3VzdG9tZXIgcmVjZWl2ZXMgYSBjb25maXJtYXRpb24gZGlhbG9nIGJlZm9yZSBkZWxldGluZyBhIHBheW1lbnQgbWV0aG9kXG4gICovXG4gIGJpbmREZWxldGVQYXltZW50TWV0aG9kKCkge1xuICAgICQoJ1tkYXRhLWRlbGV0ZS1wYXltZW50LW1ldGhvZF0nKS5vbignc3VibWl0JywgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YSgnZGVsZXRlUGF5bWVudE1ldGhvZCcpO1xuXG4gICAgICBpZiAoIXdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpbml0UGF5bWVudE1ldGhvZEZvcm1WYWxpZGF0aW9uKCRwYXltZW50TWV0aG9kRm9ybSkge1xuICAgIC8vIEluamVjdCB2YWxpZGF0aW9ucyBpbnRvIGZvcm0gZmllbGRzIGJlZm9yZSB2YWxpZGF0aW9uIHJ1bnNcbiAgICAkcGF5bWVudE1ldGhvZEZvcm0uZmluZCgnI2ZpcnN0X25hbWUuZm9ybS1maWVsZCcpLmF0dHIoJ2RhdGEtdmFsaWRhdGlvbicsIGB7IFwidHlwZVwiOiBcInNpbmdsZWxpbmVcIiwgXCJsYWJlbFwiOiBcIiR7dGhpcy5jb250ZXh0LmZpcnN0TmFtZUxhYmVsfVwiLCBcInJlcXVpcmVkXCI6IHRydWUsIFwibWF4bGVuZ3RoXCI6IDAgfWApO1xuICAgICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcjbGFzdF9uYW1lLmZvcm0tZmllbGQnKS5hdHRyKCdkYXRhLXZhbGlkYXRpb24nLCBgeyBcInR5cGVcIjogXCJzaW5nbGVsaW5lXCIsIFwibGFiZWxcIjogXCIke3RoaXMuY29udGV4dC5sYXN0TmFtZUxhYmVsfVwiLCBcInJlcXVpcmVkXCI6IHRydWUsIFwibWF4bGVuZ3RoXCI6IDAgfWApO1xuICAgICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcjY29tcGFueS5mb3JtLWZpZWxkJykuYXR0cignZGF0YS12YWxpZGF0aW9uJywgYHsgXCJ0eXBlXCI6IFwic2luZ2xlbGluZVwiLCBcImxhYmVsXCI6IFwiJHt0aGlzLmNvbnRleHQuY29tcGFueUxhYmVsfVwiLCBcInJlcXVpcmVkXCI6IGZhbHNlLCBcIm1heGxlbmd0aFwiOiAwIH1gKTtcbiAgICAkcGF5bWVudE1ldGhvZEZvcm0uZmluZCgnI3Bob25lLmZvcm0tZmllbGQnKS5hdHRyKCdkYXRhLXZhbGlkYXRpb24nLCBgeyBcInR5cGVcIjogXCJzaW5nbGVsaW5lXCIsIFwibGFiZWxcIjogXCIke3RoaXMuY29udGV4dC5waG9uZUxhYmVsfVwiLCBcInJlcXVpcmVkXCI6IGZhbHNlLCBcIm1heGxlbmd0aFwiOiAwIH1gKTtcbiAgICAkcGF5bWVudE1ldGhvZEZvcm0uZmluZCgnI2FkZHJlc3MxLmZvcm0tZmllbGQnKS5hdHRyKCdkYXRhLXZhbGlkYXRpb24nLCBgeyBcInR5cGVcIjogXCJzaW5nbGVsaW5lXCIsIFwibGFiZWxcIjogXCIke3RoaXMuY29udGV4dC5hZGRyZXNzMUxhYmVsfVwiLCBcInJlcXVpcmVkXCI6IHRydWUsIFwibWF4bGVuZ3RoXCI6IDAgfWApO1xuICAgICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcjYWRkcmVzczIuZm9ybS1maWVsZCcpLmF0dHIoJ2RhdGEtdmFsaWRhdGlvbicsIGB7IFwidHlwZVwiOiBcInNpbmdsZWxpbmVcIiwgXCJsYWJlbFwiOiBcIiR7dGhpcy5jb250ZXh0LmFkZHJlc3MyTGFiZWx9XCIsIFwicmVxdWlyZWRcIjogZmFsc2UsIFwibWF4bGVuZ3RoXCI6IDAgfWApO1xuICAgICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcjY2l0eS5mb3JtLWZpZWxkJykuYXR0cignZGF0YS12YWxpZGF0aW9uJywgYHsgXCJ0eXBlXCI6IFwic2luZ2xlbGluZVwiLCBcImxhYmVsXCI6IFwiJHt0aGlzLmNvbnRleHQuY2l0eUxhYmVsfVwiLCBcInJlcXVpcmVkXCI6IHRydWUsIFwibWF4bGVuZ3RoXCI6IDAgfWApO1xuICAgICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcjY291bnRyeS5mb3JtLWZpZWxkJykuYXR0cignZGF0YS12YWxpZGF0aW9uJywgYHsgXCJ0eXBlXCI6IFwic2luZ2xlc2VsZWN0XCIsIFwibGFiZWxcIjogXCIke3RoaXMuY29udGV4dC5jb3VudHJ5TGFiZWx9XCIsIFwicmVxdWlyZWRcIjogdHJ1ZSwgcHJlZml4OiBcIiR7dGhpcy5jb250ZXh0LmNob29zZUNvdW50cnlMYWJlbH1cIiB9YCk7XG4gICAgJHBheW1lbnRNZXRob2RGb3JtLmZpbmQoJyNzdGF0ZS5mb3JtLWZpZWxkJykuYXR0cignZGF0YS12YWxpZGF0aW9uJywgYHsgXCJ0eXBlXCI6IFwic2luZ2xlbGluZVwiLCBcImxhYmVsXCI6IFwiJHt0aGlzLmNvbnRleHQuc3RhdGVMYWJlbH1cIiwgXCJyZXF1aXJlZFwiOiB0cnVlLCBcIm1heGxlbmd0aFwiOiAwIH1gKTtcbiAgICAkcGF5bWVudE1ldGhvZEZvcm0uZmluZCgnI3Bvc3RhbF9jb2RlLmZvcm0tZmllbGQnKS5hdHRyKCdkYXRhLXZhbGlkYXRpb24nLCBgeyBcInR5cGVcIjogXCJzaW5nbGVsaW5lXCIsIFwibGFiZWxcIjogXCIke3RoaXMuY29udGV4dC5wb3N0YWxDb2RlTGFiZWx9XCIsIFwicmVxdWlyZWRcIjogdHJ1ZSwgXCJtYXhsZW5ndGhcIjogMCB9YCk7XG5cbiAgICBjb25zdCBwYXltZW50TWV0aG9kU2VsZWN0b3IgPSAnZm9ybVtkYXRhLXBheW1lbnQtbWV0aG9kLWZvcm1dJztcbiAgICBjb25zdCAkc3RhdGVFbGVtZW50ID0gJChgJHtwYXltZW50TWV0aG9kU2VsZWN0b3J9IFtkYXRhLWZpZWxkLXR5cGU9XCJTdGF0ZVwiXWApO1xuXG4gICAgbGV0ICRsYXN0O1xuXG4gICAgLy8gVXNlIGNyZWRpdCBjYXJkIG51bWJlciBpbnB1dCBsaXN0ZW5lciB0byBoaWdobGlnaHQgY3JlZGl0IGNhcmQgdHlwZVxuICAgICQoYCR7cGF5bWVudE1ldGhvZFNlbGVjdG9yfSBpbnB1dFtuYW1lPVwiY3JlZGl0X2NhcmRfbnVtYmVyXCJdYCkub24oJ2tleXVwJywgKHsgdGFyZ2V0IH0pID0+IHtcbiAgICAgIGNvbnN0IGNhcmRUeXBlID0gY3JlZGl0Q2FyZFR5cGUodGFyZ2V0LnZhbHVlKTtcbiAgICAgIGlmIChjYXJkVHlwZSkge1xuICAgICAgICAkKGAke3BheW1lbnRNZXRob2RTZWxlY3Rvcn0gaW1nW2FsdD1cIiR7Y2FyZFR5cGV9XCJgKS5zaWJsaW5ncygpLmNzcygnb3BhY2l0eScsICcuMicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChgJHtwYXltZW50TWV0aG9kU2VsZWN0b3J9IGltZ2ApLmNzcygnb3BhY2l0eScsICcxJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgb2YgY3JlZGl0IGNhcmQgdmFsaWRhdGlvblxuICAgIENDVmFsaWRhdG9ycy5zZXRDcmVkaXRDYXJkTnVtYmVyVmFsaWRhdGlvbigkcGF5bWVudE1ldGhvZEZvcm0sIGAke3BheW1lbnRNZXRob2RTZWxlY3Rvcn0gaW5wdXRbbmFtZT1cImNyZWRpdF9jYXJkX251bWJlclwiXWAsIHRoaXMuY29udGV4dC5jcmVkaXRDYXJkTnVtYmVyKTtcbiAgICBDQ1ZhbGlkYXRvcnMuc2V0RXhwaXJhdGlvblZhbGlkYXRpb24oJHBheW1lbnRNZXRob2RGb3JtLCBgJHtwYXltZW50TWV0aG9kU2VsZWN0b3J9IGlucHV0W25hbWU9XCJleHBpcmF0aW9uXCJdYCwgdGhpcy5jb250ZXh0LmV4cGlyYXRpb24pO1xuICAgIENDVmFsaWRhdG9ycy5zZXROYW1lT25DYXJkVmFsaWRhdGlvbigkcGF5bWVudE1ldGhvZEZvcm0sIGAke3BheW1lbnRNZXRob2RTZWxlY3Rvcn0gaW5wdXRbbmFtZT1cIm5hbWVfb25fY2FyZFwiXWAsIHRoaXMuY29udGV4dC5uYW1lT25DYXJkKTtcbiAgICBDQ1ZhbGlkYXRvcnMuc2V0Q3Z2VmFsaWRhdGlvbigkcGF5bWVudE1ldGhvZEZvcm0sIGAke3BheW1lbnRNZXRob2RTZWxlY3Rvcn0gaW5wdXRbbmFtZT1cImN2dlwiXWAsIHRoaXMuY29udGV4dC5jdnYpO1xuXG4gICAgLy8gU2V0IG9mIGNyZWRpdCBjYXJkIGZvcm1hdFxuICAgIENDRm9ybWF0dGVycy5zZXRDcmVkaXRDYXJkTnVtYmVyRm9ybWF0KGAke3BheW1lbnRNZXRob2RTZWxlY3Rvcn0gaW5wdXRbbmFtZT1cImNyZWRpdF9jYXJkX251bWJlclwiXWApO1xuICAgIENDRm9ybWF0dGVycy5zZXRFeHBpcmF0aW9uRm9ybWF0KGAke3BheW1lbnRNZXRob2RTZWxlY3Rvcn0gaW5wdXRbbmFtZT1cImV4cGlyYXRpb25cImApO1xuXG4gICAgLy8gQmlsbGluZyBhZGRyZXNzIHZhbGlkYXRpb25cbiAgICAkcGF5bWVudE1ldGhvZEZvcm0ub24oJ3N1Ym1pdCcsIGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCAkZm9ybUlzVmFsaWQgPSAkcGF5bWVudE1ldGhvZEZvcm0uZmluZCgnLmZvcm0tZmllbGQtaW52YWxpZCcpID4gMCA/IGZhbHNlIDogdHJ1ZTtcblxuICAgICAgLy8gUGVyZm9ybSBmaW5hbCBmb3JtIHZhbGlkYXRpb25cbiAgICAgIGlmICgkZm9ybUlzVmFsaWQpIHtcbiAgICAgICAgLy8gU2VyaWFsaXplIGZvcm0gZGF0YSBhbmQgcmVkdWNlIGl0IHRvIG9iamVjdFxuICAgICAgICBjb25zdCBkYXRhID0gXy5yZWR1Y2UoJHBheW1lbnRNZXRob2RGb3JtLnNlcmlhbGl6ZUFycmF5KCksIChvYmosIGl0ZW0pID0+IHtcbiAgICAgICAgICBjb25zdCByZWZPYmogPSBvYmo7XG4gICAgICAgICAgcmVmT2JqW2l0ZW0ubmFtZV0gPSBpdGVtLnZhbHVlO1xuICAgICAgICAgIHJldHVybiByZWZPYmo7XG4gICAgICAgIH0sIHt9KTtcblxuICAgICAgICAvLyBBc3NpZ24gY291bnRyeSBhbmQgc3RhdGUgY29kZVxuICAgICAgICBjb25zdCBjb3VudHJ5ID0gXy5maW5kKHRoaXMuY29udGV4dC5jb3VudHJpZXMsICh7IHZhbHVlIH0pID0+IHZhbHVlID09PSBkYXRhLmNvdW50cnkpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvdW50cnkgJiYgXy5maW5kKGNvdW50cnkuc3RhdGVzLCAoeyB2YWx1ZSB9KSA9PiB2YWx1ZSA9PT0gZGF0YS5zdGF0ZSk7XG4gICAgICAgIGRhdGEuY291bnRyeV9jb2RlID0gY291bnRyeSA/IGNvdW50cnkuY29kZSA6IGRhdGEuY291bnRyeTtcbiAgICAgICAgZGF0YS5zdGF0ZV9vcl9wcm92aW5jZV9jb2RlID0gc3RhdGUgPyBzdGF0ZS5jb2RlIDogZGF0YS5zdGF0ZTtcblxuICAgICAgICAvLyBEZWZhdWx0IEluc3RydW1lbnRcbiAgICAgICAgZGF0YS5kZWZhdWx0X2luc3RydW1lbnQgPSAhIWRhdGEuZGVmYXVsdF9pbnN0cnVtZW50O1xuXG4gICAgICAgIC8vIFN0b3JlIGNyZWRpdCBjYXJkXG4gICAgICAgIHN0b3JlSW5zdHJ1bWVudCh0aGlzLmNvbnRleHQsIGRhdGEsICgpID0+IHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRoaXMuY29udGV4dC5wYXltZW50TWV0aG9kc1VybDtcbiAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucGFnZUFsZXJ0cy5lcnJvcih0aGlzLmNvbnRleHQuZ2VuZXJpY19lcnJvciwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgdXBkYXRlU3RhdGUgZnJvbSAnLi91cGRhdGVTdGF0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjY291bnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB1cGRhdGVTdGF0ZShmYWxzZSwgdGhpcy5zZWxlY3RXcmFwQ2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNhbGxiYWNrIGZpcmVkIHdoZW4gYSBmcmVzaCBzdGF0ZSA8c2VsZWN0PiBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET01cbiAgICovXG4gIHNlbGVjdFdyYXBDYWxsYmFjaygkc2VsZWN0RWwpIHt9IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBQYWdlIE1hbmFnZXJcbiAgbG9hZGVkKCkge31cbiAgYmVmb3JlKCkge31cbiAgYWZ0ZXIoKSB7fVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2lmdENlcnRpZmljYXRlIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgIHRoaXMuJHB1cmNoYXNlRm9ybSA9ICQoJ1tkYXRhLWdpZnRjYXJkLXB1cmNoYXNlLWZvcm1dJyk7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy4kcHVyY2hhc2VGb3JtLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBpZiAoJCgnI2dpZnRjYXJkLWFtb3VudCcpLnZhbCgpICE9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5fc2hvd1ByZXZpZXcoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuJHB1cmNoYXNlRm9ybS5maW5kKCdbZGF0YS1uby1yZWZyZXNoXScpLm9uKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgb3IgdXBkYXRlIHRoZSBnaWZ0Y2FyZCBwcmV2aWV3LlxuICAgKi9cbiAgX3Nob3dQcmV2aWV3KCkge1xuICAgIGNvbnN0ICR0aGVtZSA9IHRoaXMuJHB1cmNoYXNlRm9ybS5maW5kKCdbZGF0YS1naWZ0Y2FyZC10aGVtZV0nKTtcblxuICAgIC8vIE9ubHkgc2hvdyBhIHByZXZpZXcgaWYgYSB0aGVtZSBpcyBzZWxlY3RlZFxuICAgIGlmICghJHRoZW1lLmZpbmQoJy5mb3JtLWlucHV0OmNoZWNrZWQnKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgcHJldmlldyBVUkwgYmFzZWQgb24gZm9ybSBzdGF0ZVxuICAgIGNvbnN0IGJhc2VVcmwgPSAkdGhlbWUuZGF0YSgnZ2lmdGNhcmQtcHJldmlldy11cmwnKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4kcHVyY2hhc2VGb3JtLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9JiR7ZGF0YX1gO1xuXG4gICAgLy8gQ3JlYXRlIHByZXZpZXdcbiAgICBjb25zdCAkcHJldmlldyA9ICQoJzxpZnJhbWU+Jywge1xuICAgICAgc3JjOiB1cmwsXG4gICAgfSkub24oJ2xvYWQnLCAoZXZlbnQpID0+IHtcbiAgICAgIC8vIENhbGN1bGF0ZSBpZnJhbWUgaGVpZ2h0IGJhc2VkIG9uIGl0cyBkb2N1bWVudCBoZWlnaHRcbiAgICAgIGNvbnN0IGhlaWdodCA9ICQoZXZlbnQuY3VycmVudFRhcmdldC5jb250ZW50RG9jdW1lbnQpLmhlaWdodCgpO1xuICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5oZWlnaHQoaGVpZ2h0KTtcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBwcmV2aWV3XG4gICAgJHRoZW1lLmZpbmQoJy5naWZ0Y2FyZC1mb3JtLXByZXZpZXcnKVxuICAgICAgLmFkZENsYXNzKCdoYXMtcHJldmlldycpXG4gICAgICAuaHRtbCgkcHJldmlldyk7XG4gIH1cblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgUGFnZSBNYW5hZ2VyXG4gIGxvYWRlZCgpIHt9XG4gIGJlZm9yZSgpIHt9XG4gIGFmdGVyKCkge31cbn1cbiIsImltcG9ydCBjcmVkaXRjYXJkcyBmcm9tICdjcmVkaXRjYXJkcyc7XG5cbi8qKlxuICogT21pdCBudWxsIG9yIGVtcHR5IHN0cmluZyBwcm9wZXJ0aWVzIG9mIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuIGNvbnN0IG9taXROdWxsU3RyaW5nID0gb2JqID0+IHtcbiAgIGNvbnN0IHJlZk9iaiA9IG9iajtcblxuICAgJC5lYWNoKHJlZk9iaiwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgIGRlbGV0ZSByZWZPYmpba2V5XTtcbiAgICAgfVxuICAgfSk7XG5cbiAgIHJldHVybiByZWZPYmo7XG4gfTtcblxuLyoqXG4gKiBHZXQgY3JlZGl0IGNhcmQgdHlwZSBmcm9tIGNyZWRpdCBjYXJkIG51bWJlclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVkaXRDYXJkVHlwZSA9IHZhbHVlID0+IGNyZWRpdGNhcmRzLmNhcmQudHlwZShjcmVkaXRjYXJkcy5jYXJkLnBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG5cbi8qKlxuICogV3JhcHBlciBmb3IgYWpheCByZXF1ZXN0IHRvIHN0b3JlIGEgbmV3IGluc3RydW1lbnQgaW4gYmlncGF5XG4gKiBAcGFyYW0ge29iamVjdH0gUmVwcmVzZW50aW5nIHRoZSBkYXRhIG5lZWRlZCBmb3IgdGhlIGhlYWRlclxuICogQHBhcmFtIHtvYmplY3R9IFJlcHJlc2VudGluZyB0aGUgZGF0YSBuZWVkZWQgZm9yIHRoZSBib2R5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gYSBzdWNjZXNzZnVsIHJlc3BvbnNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmYWlsIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gYSB1bnN1Y2Nlc3NmdWwgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNvbnN0IHN0b3JlSW5zdHJ1bWVudCA9ICh7XG4gIC8vIEhvc3RuYW1lLCBJZHMgJiBUb2tlblxuICBwYXltZW50c1VybCxcbiAgc2hvcHBlcklkLFxuICBzdG9yZUhhc2gsXG4gIHZhdWx0VG9rZW4sXG59LCB7XG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIC8vIFByb3ZpZGVyIEluZm9cbiAgcHJvdmlkZXJfaWQsXG4gIGN1cnJlbmN5X2NvZGUsXG4gICAvLyBJbnN0cnVtZW50IERldGFpbHNcbiAgY3JlZGl0X2NhcmRfbnVtYmVyLFxuICBleHBpcmF0aW9uLFxuICBuYW1lX29uX2NhcmQsXG4gIGN2dixcbiAgZGVmYXVsdF9pbnN0cnVtZW50LFxuICAgLy8gQmlsbGluZyBBZGRyZXNzXG4gIGFkZHJlc3MxLFxuICBhZGRyZXNzMixcbiAgY2l0eSxcbiAgcG9zdGFsX2NvZGUsXG4gIHN0YXRlX29yX3Byb3ZpbmNlX2NvZGUsXG4gIGNvdW50cnlfY29kZSxcbiAgY29tcGFueSxcbiAgZmlyc3RfbmFtZSxcbiAgbGFzdF9uYW1lLFxuICBlbWFpbCxcbiAgcGhvbmUsXG4gIC8qIGVzbGludC1lbmFibGUgKi9cbn0sIGRvbmUsIGZhaWwpID0+IHtcbiAgY29uc3QgZXhwaXJ5ID0gZXhwaXJhdGlvbi5zcGxpdCgnLycpO1xuXG4gICQuYWpheCh7XG4gICAgdXJsOiBgJHtwYXltZW50c1VybH0vc3RvcmVzLyR7c3RvcmVIYXNofS9jdXN0b21lcnMvJHtzaG9wcGVySWR9L3N0b3JlZF9pbnN0cnVtZW50c2AsXG4gICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBjYWNoZTogZmFsc2UsXG4gICAgaGVhZGVyczoge1xuICAgICAgQXV0aG9yaXphdGlvbjogdmF1bHRUb2tlbixcbiAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL3ZuZC5iYy52MStqc29uJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vdm5kLmJjLnYxK2pzb24nLFxuICAgIH0sXG4gICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgaW5zdHJ1bWVudDoge1xuICAgICAgICB0eXBlOiAnY2FyZCcsXG4gICAgICAgIGNhcmRob2xkZXJfbmFtZTogbmFtZV9vbl9jYXJkLFxuICAgICAgICBudW1iZXI6IGNyZWRpdGNhcmRzLmNhcmQucGFyc2UoY3JlZGl0X2NhcmRfbnVtYmVyKSxcbiAgICAgICAgZXhwaXJ5X21vbnRoOiBjcmVkaXRjYXJkcy5leHBpcmF0aW9uLm1vbnRoLnBhcnNlKGV4cGlyeVswXSksXG4gICAgICAgIGV4cGlyeV95ZWFyOiBjcmVkaXRjYXJkcy5leHBpcmF0aW9uLnllYXIucGFyc2UoZXhwaXJ5WzFdLCB0cnVlKSxcbiAgICAgICAgdmVyaWZpY2F0aW9uX3ZhbHVlOiBjdnYsXG4gICAgICB9LFxuICAgICAgYmlsbGluZ19hZGRyZXNzOiBvbWl0TnVsbFN0cmluZyh7XG4gICAgICAgIGFkZHJlc3MxLFxuICAgICAgICBhZGRyZXNzMixcbiAgICAgICAgY2l0eSxcbiAgICAgICAgcG9zdGFsX2NvZGUsXG4gICAgICAgIHN0YXRlX29yX3Byb3ZpbmNlX2NvZGUsXG4gICAgICAgIGNvdW50cnlfY29kZSxcbiAgICAgICAgY29tcGFueSxcbiAgICAgICAgZmlyc3RfbmFtZSxcbiAgICAgICAgbGFzdF9uYW1lLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgcGhvbmUsXG4gICAgICB9KSxcbiAgICAgIHByb3ZpZGVyX2lkLFxuICAgICAgZGVmYXVsdF9pbnN0cnVtZW50LFxuICAgICAgY3VycmVuY3lfY29kZSxcbiAgICB9KSxcbiAgfSlcbiAgICAuZG9uZShkb25lKVxuICAgIC5mYWlsKGZhaWwpO1xufTtcblxuZXhwb3J0IGNvbnN0IEZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgZm9ybWF0IGZvciBjcmVkaXQgY2FyZCBudW1iZXJcbiAgICogQHBhcmFtIGZpZWxkXG4gICAqL1xuICBzZXRDcmVkaXRDYXJkTnVtYmVyRm9ybWF0OiBmaWVsZCA9PiB7XG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICAkKGZpZWxkKS5vbigna2V5dXAnLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICBjb25zdCByZWZUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHJlZlRhcmdldC52YWx1ZSA9IGNyZWRpdGNhcmRzLmNhcmQuZm9ybWF0KGNyZWRpdGNhcmRzLmNhcmQucGFyc2UodGFyZ2V0LnZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYSBmb3JtYXQgZm9yIGV4cGlyYXRpb24gZGF0ZVxuICAgKiBAcGFyYW0gZmllbGRcbiAgICovXG4gIHNldEV4cGlyYXRpb25Gb3JtYXQ6IGZpZWxkID0+IHtcbiAgICBpZiAoZmllbGQpIHtcbiAgICAgICQoZmllbGQpLm9uKCdrZXl1cCcsICh7IHRhcmdldCwgd2hpY2ggfSkgPT4ge1xuICAgICAgICBjb25zdCByZWZUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGlmICh3aGljaCA9PT0gOCAmJiAvLiooXFwvKSQvLnRlc3QodGFyZ2V0LnZhbHVlKSkge1xuICAgICAgICAgIHJlZlRhcmdldC52YWx1ZSA9IHRhcmdldC52YWx1ZS5zbGljZSgwLCAtMSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnZhbHVlLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICByZWZUYXJnZXQudmFsdWUgPSB0YXJnZXQudmFsdWUuc2xpY2UoMCwgNSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2hpY2ggIT09IDgpIHtcbiAgICAgICAgICByZWZUYXJnZXQudmFsdWUgPSB0YXJnZXQudmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eKFsxLTldXFwvfFsyLTldKSQvZywgJzAkMS8nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL14oMFsxLTldfDFbMC0yXSkkL2csICckMS8nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL14oWzAtMV0pKFszLTldKSQvZywgJzAkMS8kMicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXigwWzEtOV18MVswLTJdKShbMC05XXsyfSkkL2csICckMS8kMicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXihbMF0rKVxcL3xbMF0rJC9nLCAnMCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvW15cXGRcXC9dfF5bXFwvXSokL2csICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgVmFsaWRhdG9ycyA9IHtcbiAgLyoqXG4gICAqIFNldHMgdXAgYSB2YWxpZGF0aW9uIGZvciBjcmVkaXQgY2FyZCBudW1iZXJcbiAgICogQHBhcmFtIHZhbGlkYXRvclxuICAgKiBAcGFyYW0gZmllbGRcbiAgICovXG4gIHNldENyZWRpdENhcmROdW1iZXJWYWxpZGF0aW9uOiAodmFsaWRhdG9yLCBmaWVsZCwgZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICB2YWxpZGF0b3IuYWRkKHtcbiAgICAgICAgc2VsZWN0b3I6IGZpZWxkLFxuICAgICAgICB2YWxpZGF0ZTogKGNiLCB2YWwpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWwubGVuZ3RoICYmIGNyZWRpdGNhcmRzLmNhcmQuaXNWYWxpZChjcmVkaXRjYXJkcy5jYXJkLnBhcnNlKHZhbCkpO1xuXG4gICAgICAgICAgY2IocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYSB2YWxpZGF0aW9uIGZvciBleHBpcmF0aW9uIGRhdGVcbiAgICogQHBhcmFtIHZhbGlkYXRvclxuICAgKiBAcGFyYW0gZmllbGRcbiAgICovXG4gIHNldEV4cGlyYXRpb25WYWxpZGF0aW9uOiAodmFsaWRhdG9yLCBmaWVsZCwgZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICB2YWxpZGF0b3IuYWRkKHtcbiAgICAgICAgc2VsZWN0b3I6IGZpZWxkLFxuICAgICAgICB2YWxpZGF0ZTogKGNiLCB2YWwpID0+IHtcbiAgICAgICAgICBjb25zdCBleHBpcnkgPSB2YWwuc3BsaXQoJy8nKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsLmxlbmd0aCAmJiAvXigwWzEtOV18MVswLTJdKVxcLyhbMC05XXsyfSkkLy50ZXN0KHZhbCk7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmICFjcmVkaXRjYXJkcy5leHBpcmF0aW9uLmlzUGFzdChjcmVkaXRjYXJkcy5leHBpcmF0aW9uLm1vbnRoLnBhcnNlKGV4cGlyeVswXSksIGNyZWRpdGNhcmRzLmV4cGlyYXRpb24ueWVhci5wYXJzZShleHBpcnlbMV0sIHRydWUpKTtcblxuICAgICAgICAgIGNiKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB1cCBhIHZhbGlkYXRpb24gZm9yIG5hbWUgb24gY2FyZFxuICAgKiBAcGFyYW0gdmFsaWRhdG9yXG4gICAqIEBwYXJhbSBmaWVsZFxuICAgKi9cbiAgc2V0TmFtZU9uQ2FyZFZhbGlkYXRpb246ICh2YWxpZGF0b3IsIGZpZWxkLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIHZhbGlkYXRvci5hZGQoe1xuICAgICAgICBzZWxlY3RvcjogZmllbGQsXG4gICAgICAgIHZhbGlkYXRlOiAoY2IsIHZhbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICEhdmFsLmxlbmd0aDtcblxuICAgICAgICAgIGNiKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB1cCBhIHZhbGlkYXRpb24gZm9yIGN2dlxuICAgKiBAcGFyYW0gdmFsaWRhdG9yXG4gICAqIEBwYXJhbSBmaWVsZFxuICAgKi9cbiAgc2V0Q3Z2VmFsaWRhdGlvbjogKHZhbGlkYXRvciwgZmllbGQsIGVycm9yTWVzc2FnZSkgPT4ge1xuICAgIGlmIChmaWVsZCkge1xuICAgICAgdmFsaWRhdG9yLmFkZCh7XG4gICAgICAgIHNlbGVjdG9yOiBmaWVsZCxcbiAgICAgICAgdmFsaWRhdGU6IChjYiwgdmFsKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsLmxlbmd0aCAmJiBjcmVkaXRjYXJkcy5jdmMuaXNWYWxpZCh2YWwpO1xuXG4gICAgICAgICAgY2IocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxufTtcbiIsImltcG9ydCAnanF1ZXJ5LXRyZW5kJztcblxuLyoqXG4gKiBDb3JlIEFsZXJ0IGNvbXBvbmVudHMgY2FuIGJlIGxvYWRlZCB3aXRoIGEgYGRpc21pc3NhYmxlYCBwYXJhbS4gSWYgdGhpc1xuICogaXMgdHJ1ZSwgYW4gYWxlcnQtZGlzbWlzcyBidXR0b24gaXMgaW5jbHVkZWQgaW4gdGhlIG1hcmt1cC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJlbW92ZXMgdGhlIGFsZXJ0IHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXNtaXNzYWJsZSgpIHtcbiAgJCgnYm9keScpLm9uKCdjbGljaycsICcuYWxlcnQtZGlzbWlzcycsIChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICBjb25zdCAkYWxlcnQgPSAkdGFyZ2V0LnBhcmVudCgnLmFsZXJ0Jyk7XG5cbiAgICAkYWxlcnQub25lKCd0cmVuZCcsICgpID0+IHtcbiAgICAgICRhbGVydC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgICRhbGVydC5hZGRDbGFzcygnZGlzbWlzc2VkJyk7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiAgQWxlcnRzXG4gKlxuICogIFV0aWxpdHkgbW9kdWxlIHRvIGRpc3BsYXkgc3RhdHVzIG1lc3NhZ2VzIGZvciBjb21wb25lbnRzLlxuICogIEluc3RhbnRpYXRlIENsYXNzOiBuZXcgQWxlcnQoKVxuICpcbiAqICBAYXJnICRlbCAgICAgICBqUXVlcnkgb2JqZWN0XG4gKiAgICBUaGUgc3BlY2lmaWMgZWxlbWVudCB0aGF0IHdpbGwgaG9sZCBuZXcgYWxlcnQgbWVzc2FnZXMuXG4gKlxuICogIEBhcmcgb3B0aW9ucyAgT2JqZWN0XG4gKiAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgbW9kdWxlLiAoc2VlIGJlbG93KVxuICovXG5cbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgdHJlbmQgZnJvbSAnanF1ZXJ5LXRyZW5kJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnQge1xuICBjb25zdHJ1Y3RvcigkZWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgdGhpcy4kZWwgPSAkZWw7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICBiYXNlOiAnYWxlcnQnLFxuICAgICAgICBlcnJvcjogJ2FsZXJ0LWVycm9yJyxcbiAgICAgICAgaW5mbzogJ2FsZXJ0LWluZm8nLFxuICAgICAgICBzdWNjZXNzOiAnYWxlcnQtc3VjY2VzcycsXG4gICAgICB9LFxuICAgICAgbGltaXQ6IDEsXG4gICAgICB0ZW1wbGF0ZToge30sXG4gICAgICBjYWxsYmFja3M6IHt9LFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiB7fSxcbiAgICAgIGRpZFVwZGF0ZTogKCkgPT4ge30sXG4gICAgfSwgb3B0aW9ucy5jYWxsYmFja3MpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgaWYgKF8uaXNFbXB0eSh0aGlzLm9wdGlvbnMudGVtcGxhdGUpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGVtcGxhdGUgPSBfLnRlbXBsYXRlKGBcbiAgICAgICAgPGRpdiBjbGFzcz0nJHt0aGlzLm9wdGlvbnMuY2xhc3Nlcy5iYXNlfSA8JT0gbWVzc2FnZVR5cGUgJT4nPlxuICAgICAgICAgIDwlIGlmIChpc0Rpc21pc3NhYmxlKSB7ICU+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImFsZXJ0LWRpc21pc3NcIj5cbiAgICAgICAgICAgICAgPHN2ZyBjbGFzcz1cImljb24teFwiIHdpZHRoPVwiMTFcIiBoZWlnaHQ9XCIxMVwiIHZpZXdCb3g9XCIwIDAgMTEgMTFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNLjM2Ny45MzNsOS4yIDkuMmMuMTU2LjE1Ni40MS4xNTYuNTY2IDAgLjE1Ni0uMTU2LjE1Ni0uNDEgMC0uNTY2bC05LjItOS4yQy43NzcuMjEuNTIzLjIxLjM2Ny4zNjcuMjEuNTIzLjIxLjc3Ny4zNjcuOTMzem05LjItLjU2NmwtOS4yIDkuMmMtLjE1Ni4xNTYtLjE1Ni40MSAwIC41NjYuMTU2LjE1Ni40MS4xNTYuNTY2IDBsOS4yLTkuMmMuMTU2LS4xNTYuMTU2LS40MSAwLS41NjYtLjE1Ni0uMTU2LS40MS0uMTU2LS41NjYgMHpcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiLz5cbiAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgPCUgfSAlPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJhbGVydC1tZXNzYWdlXCI+XG4gICAgICAgICAgICA8JT0gbWVzc2FnZVRleHQgJT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICBgKTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbC5vbignY2xpY2snLCAnLmFsZXJ0LWRpc21pc3MnLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCAkYWxlcnQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLnBhcmVudCgnLmFsZXJ0Jyk7XG4gICAgICB0aGlzLl9kaXNtaXNzTWVzc2FnZSgkYWxlcnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kZWwub24oJ2NsZWFyLW1lc3NhZ2VzJywgKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHJlc2V0IHRoZSBjb250ZW50cyBvZiB0aGlzLiRlbFxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy4kZWwuZmluZChgLiR7dGhpcy5vcHRpb25zLmNsYXNzZXMuYmFzZX1gKS5lYWNoKChpbmRleCwgdGFyZ2V0KSA9PiB7XG4gICAgICB0aGlzLl9kaXNtaXNzTWVzc2FnZSgkKHRhcmdldCkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGJjLWNvcmUgYmVjb21lcyBpbnRlZ3JhdGVkIGludG8gYmMtc2tlbGV0b24sIHRoaXMgbWV0aG9kIHNob3VsZCBkZWxlZ2F0ZSB0byBgZGlzbWlzc2FibGUoKWBcbiAgICogQHBhcmFtICRhbGVydFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rpc21pc3NNZXNzYWdlKCRhbGVydCkge1xuICAgICRhbGVydC5hZGRDbGFzcygnZGlzbWlzc2VkJyk7XG4gICAgJGFsZXJ0Lm9uZSgndHJlbmQnLCAoKSA9PiB7XG4gICAgICAkYWxlcnQucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGljaXQgdXNhZ2UgdG8gY3JlYXRlIGFuIGVycm9yIGFsZXJ0XG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBwYXJhbSBkaXNtaXNzYWJsZVxuICAgKi9cbiAgZXJyb3IodGV4dCwgZGlzbWlzc2FibGUgPSBmYWxzZSl7XG4gICAgdGhpcy5tZXNzYWdlKHRleHQsICdlcnJvcicsIGRpc21pc3NhYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsaWNpdCB1c2FnZSB0byBjcmVhdGUgYSBzdWNjZXNzIGFsZXJ0XG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBwYXJhbSBkaXNtaXNzYWJsZVxuICAgKi9cbiAgc3VjY2Vzcyh0ZXh0LCBkaXNtaXNzYWJsZSA9IGZhbHNlKXtcbiAgICB0aGlzLm1lc3NhZ2UodGV4dCwgJ3N1Y2Nlc3MnLCBkaXNtaXNzYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGljaXQgdXNhZ2UgdG8gY3JlYXRlIGFuIGluZm9ybWF0aW9uYWwgYWxlcnRcbiAgICogQHBhcmFtIHRleHRcbiAgICogQHBhcmFtIGRpc21pc3NhYmxlXG4gICAqL1xuICBpbmZvKHRleHQsIGRpc21pc3NhYmxlID0gZmFsc2Upe1xuICAgIHRoaXMubWVzc2FnZSh0ZXh0LCAnaW5mbycsIGRpc21pc3NhYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dFxuICAgKiBAcGFyYW0gdHlwZVxuICAgKiBAcGFyYW0gZGlzbWlzc2FibGVcbiAgICovXG4gIG1lc3NhZ2UodGV4dCwgdHlwZSA9ICdpbmZvJywgZGlzbWlzc2FibGUgPSBmYWxzZSkge1xuICAgIHRoaXMuY2FsbGJhY2tzLndpbGxVcGRhdGUodGhpcy4kZWwpO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubGltaXQgPT09ICdudW1iZXInICYmIHRoaXMuJGVsLmZpbmQoYC4ke3RoaXMub3B0aW9ucy5jbGFzc2VzLmJhc2V9YCkubGVuZ3RoID4gdGhpcy5vcHRpb25zLmxpbWl0KSB7XG4gICAgICB0aGlzLl9kaXNtaXNzTWVzc2FnZSh0aGlzLiRlbC5maW5kKGAuJHt0aGlzLm9wdGlvbnMuY2xhc3Nlcy5iYXNlfTpub3QoLmRpc21pc3NlZClgKS5lcSgwKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgIG1lc3NhZ2VUeXBlOiB0aGlzLm9wdGlvbnMuY2xhc3Nlc1t0eXBlXSxcbiAgICAgIG1lc3NhZ2VUZXh0OiB0ZXh0LFxuICAgICAgaXNEaXNtaXNzYWJsZTogZGlzbWlzc2FibGUsXG4gICAgfTtcblxuICAgIGNvbnN0ICRhbGVydCA9IHRoaXMuJGVsLmFwcGVuZCh0aGlzLm9wdGlvbnMudGVtcGxhdGUobWVzc2FnZSkpO1xuXG4gICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCRhbGVydCwgdGhpcy4kZWwpO1xuICB9XG59XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xuaW1wb3J0IEFtcEFsZXJ0IGZyb20gJy4vQW1wQWxlcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9kdWN0VXRpbHMge1xuICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsID0gJChlbCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLiRib2R5ID0gJChkb2N1bWVudC5ib2R5KTtcbiAgICB0aGlzLnByb2R1Y3RJZCA9IHRoaXMuJGVsLmZpbmQoJ1tkYXRhLXByb2R1Y3QtaWRdJykudmFsKCk7XG5cbiAgICAvLyBjbGFzcyB0byBhZGQgb3IgcmVtb3ZlIGZyb20gY2FydC1hZGQgYnV0dG9uIGRlcGVuZGluZyBvbiB2YXJpYXRpb24gYXZhaWxhYmlsaXR5XG4gICAgdGhpcy5idXR0b25EaXNhYmxlZENsYXNzID0gJ2J1dHRvbi1kaXNhYmxlZCc7XG5cbiAgICAvLyB0d28gYWxlcnQgbG9jYXRpb25zIGJhc2VkIG9uIGFjdGlvblxuICAgIHRoaXMuY2FydEFkZEFsZXJ0ID0gbmV3IEFtcEFsZXJ0KHRoaXMuJGJvZHkuZmluZCgnW2RhdGEtcHJvZHVjdC1jYXJ0LW1lc3NhZ2VdJykpO1xuICAgIHRoaXMuY2FydE9wdGlvbkFsZXJ0ID0gbmV3IEFtcEFsZXJ0KHRoaXMuJGVsLmZpbmQoJ1tkYXRhLXByb2R1Y3Qtb3B0aW9uLW1lc3NhZ2VdJykpO1xuXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiB7fSxcbiAgICAgIGRpZFVwZGF0ZTogKCkgPT4ge30sXG4gICAgfSwgb3B0aW9ucy5jYWxsYmFja3MpO1xuICB9XG5cbiAgaW5pdChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9iaW5kUHJvZHVjdE9wdGlvbkNoYW5nZSgpO1xuXG4gICAgdGhpcy5fYm91bmRDYXJ0Q2FsbGJhY2sgPSB0aGlzLl9iaW5kQ2FydEFkZC5iaW5kKHRoaXMpO1xuICAgIHV0aWxzLmhvb2tzLm9uKCdjYXJ0LWl0ZW0tYWRkJywgdGhpcy5fYm91bmRDYXJ0Q2FsbGJhY2spO1xuXG4gICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcyh3aW5kb3cuQkNEYXRhLnByb2R1Y3RfYXR0cmlidXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FjaGUgYW4gb2JqZWN0IG9mIGpRdWVyeSBlbGVtZW50cyBmb3IgRE9NIHVwZGF0aW5nXG4gICAqIEBwYXJhbSAgalF1ZXJ5ICRlbCAtIGEgd3JhcHBpbmcgZWxlbWVudCBvZiB0aGUgc2NvcGVkIHByb2R1Y3RcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIGJ1bmNoYSBqUXVlcnkgZWxlbWVudHMgd2hpY2ggbWF5IG9yIG1heSBub3QgZXhpc3Qgb24gdGhlIHBhZ2VcbiAgICovXG4gIF9nZXRWaWV3TW9kZWwoJGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICRhZGRUb0NhcnQ6ICQoJ1tkYXRhLWJ1dHRvbi1wdXJjaGFzZV0nLCAkZWwpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQmluZCBwcm9kdWN0IG9wdGlvbnMgY2hhbmdlcy5cbiAgICovXG4gIF9iaW5kUHJvZHVjdE9wdGlvbkNoYW5nZSgpIHtcbiAgICB1dGlscy5ob29rcy5vbigncHJvZHVjdC1vcHRpb24tY2hhbmdlJywgKGV2ZW50LCBjaGFuZ2VkT3B0aW9uKSA9PiB7XG4gICAgICBjb25zdCAkY2hhbmdlZE9wdGlvbiA9ICQoY2hhbmdlZE9wdGlvbik7XG4gICAgICBjb25zdCAkZm9ybSA9ICRjaGFuZ2VkT3B0aW9uLnBhcmVudHMoJ2Zvcm0nKTtcblxuICAgICAgLy8gRG8gbm90IHRyaWdnZXIgYW4gYWpheCByZXF1ZXN0IGlmIGl0J3MgYSBmaWxlIG9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBGb3JtRGF0YVxuICAgICAgaWYgKCRjaGFuZ2VkT3B0aW9uLmF0dHIoJ3R5cGUnKSA9PT0gJ2ZpbGUnIHx8IHdpbmRvdy5Gb3JtRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYXJ0QWRkQWxlcnQuY2xlYXIoKTtcbiAgICAgIHRoaXMuY2FydE9wdGlvbkFsZXJ0LmNsZWFyKCk7XG5cbiAgICAgIC8vIHByb2R1Y3QgdGVtcGxhdGUgc2hvdWxkIGJlIHBhc3NlZCBhcyBhIHN0cmluZ1xuICAgICAgY29uc3QgcHJvZHVjdFRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMudGVtcGxhdGUgPT09ICdzdHJpbmcnID8gdGhpcy5vcHRpb25zLnRlbXBsYXRlIDogbnVsbDtcblxuICAgICAgdXRpbHMuYXBpLnByb2R1Y3RBdHRyaWJ1dGVzLm9wdGlvbkNoYW5nZSh0aGlzLnByb2R1Y3RJZCwgJGZvcm0uc2VyaWFsaXplKCksIHByb2R1Y3RUZW1wbGF0ZSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3Qgdmlld01vZGVsID0gdGhpcy5fZ2V0Vmlld01vZGVsKHRoaXMuJGVsKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlID8gcmVzcG9uc2UuZGF0YSA6IHt9O1xuXG4gICAgICAgIC8vIElmIG91ciBmb3JtIGRhdGEgZG9lc24ndCBpbmNsdWRlIHRoZSBwcm9kdWN0LW9wdGlvbnMtY291bnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLCByZXR1cm5cbiAgICAgICAgaWYgKHRoaXMuJGVsLmZpbmQoJ1tkYXRhLXByb2R1Y3Qtb3B0aW9ucy1jb3VudF0nKS52YWwgPCAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcyhkYXRhKTtcblxuICAgICAgICAvLyB1cGRhdGUgc3VibWl0IGJ1dHRvbiBzdGF0ZVxuICAgICAgICBpZiAoIWRhdGEucHVyY2hhc2FibGUgfHwgIWRhdGEuaW5zdG9jaykge1xuICAgICAgICAgIHRoaXMuY2FydE9wdGlvbkFsZXJ0LmVycm9yKGRhdGEucHVyY2hhc2luZ19tZXNzYWdlKTtcbiAgICAgICAgICB2aWV3TW9kZWwuJGFkZFRvQ2FydFxuICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMuYnV0dG9uRGlzYWJsZWRDbGFzcylcbiAgICAgICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXdNb2RlbC4kYWRkVG9DYXJ0XG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhpcy5idXR0b25EaXNhYmxlZENsYXNzKVxuICAgICAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhbmQgdXBkYXRlIHF1YW50aXR5IGlucHV0IHZhbHVlXG4gICAqL1xuICBfdXBkYXRlUXVhbnRpdHkoZXZlbnQpIHtcbiAgICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICBjb25zdCAkcXVhbnRpdHkgPSAkdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLXByb2R1Y3QtcXVhbnRpdHldJykuZmluZCgnW2RhdGEtcXVhbnRpdHktY29udHJvbC1pbnB1dF0nKTtcbiAgICBjb25zdCBtaW4gPSBwYXJzZUludCgkcXVhbnRpdHkucHJvcCgnbWluJyksIDEwKTtcbiAgICBjb25zdCBtYXggPSBwYXJzZUludCgkcXVhbnRpdHkucHJvcCgnbWF4JyksIDEwKTtcbiAgICBsZXQgbmV3UXVhbnRpdHkgPSBwYXJzZUludCgkcXVhbnRpdHkudmFsKCksIDEwKTtcblxuICAgIGlmIChpc05hTihuZXdRdWFudGl0eSkpIHtcbiAgICAgIG5ld1F1YW50aXR5ID0gbWluO1xuICAgIH1cblxuICAgIGlmICgkdGFyZ2V0LmlzKCdbZGF0YS1xdWFudGl0eS1pbmNyZW1lbnRdJykgJiYgKCFtYXggfHwgbmV3UXVhbnRpdHkgPCBtYXgpKSB7XG4gICAgICBuZXdRdWFudGl0eSA9IG5ld1F1YW50aXR5ICsgMTtcbiAgICB9IGVsc2UgaWYgKCR0YXJnZXQuaXMoJ1tkYXRhLXF1YW50aXR5LWRlY3JlbWVudF0nKSAmJiBuZXdRdWFudGl0eSA+IG1pbikge1xuICAgICAgbmV3UXVhbnRpdHkgPSBuZXdRdWFudGl0eSAtIDE7XG4gICAgfVxuXG4gICAgJHF1YW50aXR5LnZhbChuZXdRdWFudGl0eSk7XG4gIH1cblxuICBfdXBkYXRlQXR0cmlidXRlcyhkYXRhKSB7XG4gICAgY29uc3QgYmVoYXZpb3IgPSBkYXRhLm91dF9vZl9zdG9ja19iZWhhdmlvcjtcbiAgICBjb25zdCBpblN0b2NrSWRzID0gZGF0YS5pbl9zdG9ja19hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IG91dE9mU3RvY2tNZXNzYWdlID0gYCAoJHtkYXRhLm91dF9vZl9zdG9ja19tZXNzYWdlfSlgO1xuXG4gICAgaWYgKGJlaGF2aW9yICE9PSAnaGlkZV9vcHRpb24nICYmIGJlaGF2aW9yICE9PSAnbGFiZWxfb3B0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICQoJ1tkYXRhLXByb2R1Y3QtYXR0cmlidXRlLXZhbHVlXScsIHRoaXMuJGVsKS5lYWNoKChpLCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgIGNvbnN0ICRhdHRyaWJ1dGUgPSAkKGF0dHJpYnV0ZSk7XG4gICAgICBjb25zdCBhdHRySWQgPSBwYXJzZUludCgkYXR0cmlidXRlLmRhdGEoJ3Byb2R1Y3QtYXR0cmlidXRlLXZhbHVlJyksIDEwKTtcblxuICAgICAgaWYgKGluU3RvY2tJZHMuaW5kZXhPZihhdHRySWQpICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9lbmFibGVBdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVBdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9kaXNhYmxlQXR0cmlidXRlKCRhdHRyaWJ1dGUsIGJlaGF2aW9yLCBvdXRPZlN0b2NrTWVzc2FnZSkge1xuICAgIGlmICh0aGlzLl9nZXRBdHRyaWJ1dGVUeXBlKCRhdHRyaWJ1dGUpID09PSAnc2V0LXNlbGVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc2FibGVTZWxlY3RPcHRpb25BdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBpZiAoYmVoYXZpb3IgPT09ICdoaWRlX29wdGlvbicpIHtcbiAgICAgICRhdHRyaWJ1dGUuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkYXR0cmlidXRlLmFkZENsYXNzKCdvcHRpb24tdW5hdmFpbGFibGUnKTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlU2VsZWN0T3B0aW9uQXR0cmlidXRlKCRhdHRyaWJ1dGUsIGJlaGF2aW9yLCBvdXRPZlN0b2NrTWVzc2FnZSkge1xuICAgIGlmIChiZWhhdmlvciA9PT0gJ2hpZGVfb3B0aW9uJykge1xuICAgICAgJGF0dHJpYnV0ZS50b2dnbGVPcHRpb24oZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkYXR0cmlidXRlLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAkYXR0cmlidXRlLmh0bWwoJGF0dHJpYnV0ZS5odG1sKCkucmVwbGFjZShvdXRPZlN0b2NrTWVzc2FnZSwgJycpICsgb3V0T2ZTdG9ja01lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIF9lbmFibGVBdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX2dldEF0dHJpYnV0ZVR5cGUoJGF0dHJpYnV0ZSkgPT09ICdzZXQtc2VsZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlU2VsZWN0T3B0aW9uQXR0cmlidXRlKCRhdHRyaWJ1dGUsIGJlaGF2aW9yLCBvdXRPZlN0b2NrTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChiZWhhdmlvciA9PT0gJ2hpZGVfb3B0aW9uJykge1xuICAgICAgJGF0dHJpYnV0ZS5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRhdHRyaWJ1dGUucmVtb3ZlQ2xhc3MoJ29wdGlvbi11bmF2YWlsYWJsZScpO1xuICAgIH1cbiAgfVxuXG4gIGVuYWJsZVNlbGVjdE9wdGlvbkF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpIHtcbiAgICBpZiAoYmVoYXZpb3IgPT09ICdoaWRlX29wdGlvbicpIHtcbiAgICAgICRhdHRyaWJ1dGUudG9nZ2xlT3B0aW9uKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkYXR0cmlidXRlLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAkYXR0cmlidXRlLmh0bWwoJGF0dHJpYnV0ZS5odG1sKCkucmVwbGFjZShvdXRPZlN0b2NrTWVzc2FnZSwgJycpKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0QXR0cmlidXRlVHlwZSgkYXR0cmlidXRlKSB7XG4gICAgY29uc3QgJHBhcmVudCA9ICRhdHRyaWJ1dGUuY2xvc2VzdCgnW2RhdGEtcHJvZHVjdC1hdHRyaWJ1dGVdJyk7XG4gICAgcmV0dXJuICRwYXJlbnQgPyAkcGFyZW50LmRhdGEoJ3Byb2R1Y3QtYXR0cmlidXRlJykgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHByb2R1Y3QgdG8gY2FydFxuICAgKi9cbiAgX2JpbmRDYXJ0QWRkKGV2ZW50LCBmb3JtKSB7XG4gICAgLy8gRG8gbm90IGRvIEFKQVggaWYgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgRm9ybURhdGFcbiAgICBpZiAod2luZG93LkZvcm1EYXRhID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xuXG4gICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgkKGZvcm0pKTtcblxuICAgIC8vIFJlbW92ZSBvbGQgYWx0ZXJzXG4gICAgdGhpcy5jYXJ0QWRkQWxlcnQuY2xlYXIoKTtcbiAgICB0aGlzLmNhcnRPcHRpb25BbGVydC5jbGVhcigpO1xuXG4gICAgLy8gQWRkIGl0ZW0gdG8gY2FydFxuICAgIHV0aWxzLmFwaS5jYXJ0Lml0ZW1BZGQoZm9ybURhdGEsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG5cbiAgICAgIGlmIChlcnIgfHwgcmVzcG9uc2UuZGF0YS5lcnJvcikge1xuICAgICAgICByZXNwb25zZSA9IGVyciB8fCByZXNwb25zZS5kYXRhLmVycm9yO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnRlcnByZXQgYW5kIGRpc3BsYXkgY2FydC1hZGQgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgKi9cbiAgICAgICAgIHRoaXMuY2FydEFkZEFsZXJ0Lm1lc3NhZ2UocmVzcG9uc2UsICdlcnJvcicsIHRydWUpO1xuICAgICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKHJlc3BvbnNlLCAkKGZvcm0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cudG9wLmxvY2F0aW9uID0gdGhpcy5jb250ZXh0LnVybHNDYXJ0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBBbXBRdWFudGl0eVdpZGdldCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgIGVsOiAnW2RhdGEtcXVhbnRpdHktY29udHJvbF0nLFxuICAgICAgY250cmw6ICdbZGF0YS1xdWFudGl0eS1jb250cm9sLWFjdGlvbl0nLFxuICAgICAgc2NvcGU6ICdib2R5JyxcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIEJpbmQgQ29udHJvbCBBY3Rpb25zXG4gICAgJCh0aGlzLm9wdGlvbnMuc2NvcGUpLm9uKCdjbGljaycsIHRoaXMub3B0aW9ucy5jbnRybCwgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvL2luIGNhc2Ugd2UgdXNlIDxidXR0b24+LzxhPiBpbnN0ZWFkIG9mIDxzcGFuPidzXG4gICAgICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFjdGlvbiA9ICR0YXJnZXQuZGF0YSgncXVhbnRpdHktY29udHJvbC1hY3Rpb24nKTtcblxuICAgICAgY29uc3QgJHF1YW50aXR5SW5wdXQgPSAkdGFyZ2V0LnNpYmxpbmdzKCdpbnB1dCcpO1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludCgkcXVhbnRpdHlJbnB1dC52YWwoKSwxMCk7XG4gICAgICBjb25zdCBtaW4gPSAkcXVhbnRpdHlJbnB1dC5hdHRyKCdtaW4nKSA/IHBhcnNlSW50KCRxdWFudGl0eUlucHV0LmF0dHIoJ21pbicpLDEwKSA6IDA7XG4gICAgICBjb25zdCBtYXggPSAkcXVhbnRpdHlJbnB1dC5hdHRyKCdtYXgnKSA/IHBhcnNlSW50KCRxdWFudGl0eUlucHV0LmF0dHIoJ21heCcpLDEwKSA6IEluZmluaXR5O1xuXG4gICAgICBpZiAoYWN0aW9uID09PSAnaW5jcmVtZW50JyAmJiB2YWx1ZSA8IG1heCkge1xuICAgICAgICAkcXVhbnRpdHlJbnB1dC52YWwodmFsdWUgKyAxKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSAnZGVjcmVtZW50JyAmJiB2YWx1ZSA+IDAgJiYgdmFsdWUgPiBtaW4pIHtcbiAgICAgICAgJHF1YW50aXR5SW5wdXQudmFsKHZhbHVlIC0gMSkudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaW1wbGUgaW5wdXQgdmFsaWRhdGlvbiAoa2VlcCBpbnB1dCB3aXRoaW4gbWluL21heCByYW5nZSlcbiAgICAvLyBGZWVsIGZyZWUgdG8gcmVtb3ZlIGFuZCByZXBsYWNlIHdpdGggYW5vdGhlciBmb3JtIG9mIHZhbGlkYXRpb25cbiAgICAkKHRoaXMub3B0aW9ucy5zY29wZSkub24oJ2NoYW5nZScsICdpbnB1dCcsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQoJHRhcmdldC52YWwoKSwxMCk7XG4gICAgICBjb25zdCBtaW4gPSAkdGFyZ2V0LmF0dHIoJ21pbicpID8gcGFyc2VJbnQoJHRhcmdldC5hdHRyKCdtaW4nKSwxMCkgOiAwO1xuICAgICAgY29uc3QgbWF4ID0gJHRhcmdldC5hdHRyKCdtYXgnKSA/IHBhcnNlSW50KCR0YXJnZXQuYXR0cignbWF4JyksMTApIDogSW5maW5pdHk7XG5cbiAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBRdWFudGl0eSBcIiR7dmFsdWV9XCIgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBtYXhpbXVtICgke21heH0pYCk7XG4gICAgICAgICR0YXJnZXQudmFsKCR0YXJnZXQuYXR0cigndmFsdWUnKSk7XG4gICAgICB9IGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBRdWFudGl0eSB2YWx1ZSBcIiR7dmFsdWV9XCIgY2Fubm90IGJlIGxlc3MgdGhhbiBtaW5pbXVtICgke21pbn0pYCk7XG4gICAgICAgICR0YXJnZXQudmFsKCR0YXJnZXQuYXR0cigndmFsdWUnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogU2ltcGxlIGltYWdlIGdhbGxlcnkgZm9yIG9yZGVycyB3aXRoIGRpZ2l0YWwgZG93bmxvYWRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnYWxsZXJ5KCkge1xuICBjb25zdCAkdGh1bWJzID0gJCgnW2RhdGEtYWNjb3VudC1kb3dubG9hZC10aHVtYl0nKTtcbiAgY29uc3QgJGltYWdlID0gJCgnW2RhdGEtYWNjb3VudC1kb3dubG9hZC1pbWFnZV0nKTtcblxuICAkdGh1bWJzLm9uKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICRpbWFnZS5hdHRyKCdzcmMnLCAkdGFyZ2V0LmF0dHIoJ3NyYycpKTtcbiAgfSk7XG59XG4iLCJjb25zdCBmaWVsZFNlbGVjdG9yID0gJ1tkYXRhLXN3YXRjaC1zZWxlY3Rvcl0nO1xuY29uc3QgdmFsdWVTZWxlY3RvciA9ICcuc3dhdGNoLXdyYXBbZGF0YS1zd2F0Y2gtdmFsdWVdJztcbmNvbnN0IGxhYmVsU2VsZWN0b3IgPSAnLnN3YXRjaC12YWx1ZVtkYXRhLXN3YXRjaC12YWx1ZV0nO1xuXG4vKipcbiAqIFNob3cgc2VsZWN0ZWQgdmFsdWUgbmV4dCB0byB0aGUgZm9ybSBmaWVsZCB0aXRsZS5cbiAqXG4gKiBPbmx5IGFwcGxpZXMgdG8gc3dhdGNoIGZvcm0gZmllbGRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtU2VsZWN0ZWRWYWx1ZSgpIHtcbiAgJChkb2N1bWVudC5ib2R5KS5vbignY2xpY2snLCB2YWx1ZVNlbGVjdG9yLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICBjb25zdCAkbGFiZWwgPSAkdGFyZ2V0LnBhcmVudHMoZmllbGRTZWxlY3RvcikuZmluZChsYWJlbFNlbGVjdG9yKTtcbiAgICAkbGFiZWwuaHRtbCgkdGFyZ2V0LmRhdGEoJ3N3YXRjaC12YWx1ZScpKTtcbiAgfSk7XG59XG4iLCIvKipcbiAqIFZpc3VhbGx5IGhpZGVzIHRoZSBvcHRpb24gZnJvbSB1c2VyIGJ5IG1vdmluZyBvcHRpb24gdG8gYW4gaW52aXNpYmxlXG4gKiBhbmQgZGlzYWJsZWQgc2VsZWN0IHBsYWNlaG9sZGVyIGVsZW1lbnQuXG4gKlxuICogVGhpcyBhcHByb2FjaCBpcyByZXF1aXJlZCByYXRoZXIgdGhhbiBzaW1wbHkgaGlkaW5nIHRoZSBvcHRpb24gYmVjYXVzZVxuICogaGlkZGVuIG9wdGlvbiBjYW4gc3RpbGwgYmUgaW5jbHVkZWQgd2hlbiBzZXJpYWxpemVBcnJheSgpIGlzIGNhbGxlZCBhbmRcbiAqIGNhdXNlIHdyb25nIHZhbHVlIHRvIGJlIHN1Ym1pdHRlZC5cbiAqIChlZy4gaWYgeW91IGhhdmUgb3B0aW9uIDEsIDIsIDMgYW5kIDIgaXMgaGlkZGVuLCB3aGVuIHlvdSBzZWxlY3QgMyxcbiAqIHNlcmlhbGl6ZUFycmF5KCkgd2lsbCB1c2UgdGhlIHZhbHVlIG9mIDIgaW5zdGVhZCBvZiAzKVxuICovXG5mdW5jdGlvbiB0b2dnbGVPcHRpb24oc2hvdykge1xuICBjb25zdCBjdXJyZW50U2VsZWN0RWxlbWVudCA9ICQodGhpcykuY2xvc2VzdCgnc2VsZWN0Jyk7IC8vIHRoZSBzZWxlY3QgY29udGFpbmluZyB0aGlzXG4gIGxldCBkaXNhYmxlZFNlbGVjdEVsZW1lbnQ7IC8vIHRoZSBkaXNhYmxlZCBzZWxlY3QgZWxlbWVudFxuICBsZXQgc2VsZWN0RWxlbWVudDsgLy8gdGhlIHJlYWwgc2VsZWN0IGVsZW1lbnRcblxuICBpZiAoY3VycmVudFNlbGVjdEVsZW1lbnQuaXMoJzpkaXNhYmxlZCcpKSB7XG4gICAgZGlzYWJsZWRTZWxlY3RFbGVtZW50ID0gY3VycmVudFNlbGVjdEVsZW1lbnQ7XG4gICAgc2VsZWN0RWxlbWVudCA9IGRpc2FibGVkU2VsZWN0RWxlbWVudC5kYXRhKCdsaW5rZWRTZWxlY3RFbGVtZW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0RWxlbWVudCA9IGN1cnJlbnRTZWxlY3RFbGVtZW50O1xuICAgIGRpc2FibGVkU2VsZWN0RWxlbWVudCA9IGN1cnJlbnRTZWxlY3RFbGVtZW50LmRhdGEoJ2xpbmtlZFNlbGVjdEVsZW1lbnQnKTtcbiAgICBpZiAoIWRpc2FibGVkU2VsZWN0RWxlbWVudCkge1xuICAgICAgLy8gY3JlYXRlIHRoZSBkaXNhYmxlZCBwbGFjZWhvbGRlciBzZWxlY3QgZWxlbWVudFxuICAgICAgZGlzYWJsZWRTZWxlY3RFbGVtZW50ID0gJCgnPHNlbGVjdD4nKVxuICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCB0cnVlKVxuICAgICAgICAuaGlkZSgpXG4gICAgICAgIC5hdHRyKCduYW1lJywgY3VycmVudFNlbGVjdEVsZW1lbnQuYXR0cignbmFtZScpKVxuICAgICAgICAuYWRkQ2xhc3MoY3VycmVudFNlbGVjdEVsZW1lbnQuYXR0cignY2xhc3MnKSlcbiAgICAgICAgLmRhdGEoJ2xpbmtlZFNlbGVjdEVsZW1lbnQnLCBzZWxlY3RFbGVtZW50KVxuICAgICAgICAuaW5zZXJ0QWZ0ZXIoc2VsZWN0RWxlbWVudCk7XG5cbiAgICAgIHNlbGVjdEVsZW1lbnQuZGF0YSgnbGlua2VkU2VsZWN0RWxlbWVudCcsIGRpc2FibGVkU2VsZWN0RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2F2ZSB0aGUgc2VsZWN0ZWQgb3B0aW9uXG4gIGNvbnN0IHNlbGVjdGVkT3B0aW9uID0gc2VsZWN0RWxlbWVudC5maW5kKCdvcHRpb246c2VsZWN0ZWQnKTtcblxuICAvLyB1cGRhdGUgLmZvcm0tc2VsZWN0ZWQtdGV4dCBlbGVtZW50XG4gIGNvbnN0IHRleHQgPSBzZWxlY3RFbGVtZW50LmZpbmQoYFt2YWx1ZT1cIiR7c2VsZWN0ZWRPcHRpb24udmFsKCl9XCJdYCkudGV4dCgpO1xuXG4gIGxldCAkcHJlZml4ID0gc2VsZWN0RWxlbWVudC5wYXJlbnRzKCcuZm9ybS1zZWxlY3Qtd3JhcHBlcicpLmRhdGEoJ3NlbGVjdGVkLXByZWZpeCcpO1xuICAkcHJlZml4ID0gKCRwcmVmaXggPyBgPHNwYW4gY2xhc3M9XCJmb3JtLXNlbGVjdGVkLXRleHQtcHJlZml4XCI+JHskcHJlZml4fTwvc3Bhbj5gIDogJycpO1xuXG4gIHNlbGVjdEVsZW1lbnQuc2libGluZ3MoJy5mb3JtLXNlbGVjdGVkLXRleHQnKS5odG1sKCRwcmVmaXggKyB0ZXh0KTtcblxuICAvLyBtb3ZlIHRoZSBvcHRpb24gdG8gdGhlIGNvcnJlY3Qgc2VsZWN0IGVsZW1lbnQgaWYgcmVxdWlyZWRcbiAgaWYgKGN1cnJlbnRTZWxlY3RFbGVtZW50LmlzKCc6ZGlzYWJsZWQnKSAmJiBzaG93KSB7XG4gICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuZGF0YSgnaW5kZXgnKTtcblxuICAgIGlmIChwcmV2aW91c0luZGV4ID4gMCkge1xuICAgICAgLy8gbG9vcCB0aHJvdWdoIHRvIHB1dCB0aGUgc2VsZWN0IGVsZW1lbnQgaW4gaXQncyBwcm9wZXIgcGxhY2VcbiAgICAgIGZvciAobGV0IGkgPSBwcmV2aW91c0luZGV4OyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGlmIChzZWxlY3RFbGVtZW50LmZpbmQoYG9wdGlvbjplcSgke2kgLSAxfSlgKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmluc2VydEFmdGVyKHNlbGVjdEVsZW1lbnQuZmluZChgb3B0aW9uOmVxKCR7aSAtIDF9KWApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkKHRoaXMpLmFwcGVuZFRvKHNlbGVjdEVsZW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghY3VycmVudFNlbGVjdEVsZW1lbnQuaXMoJzpkaXNhYmxlZCcpICYmICFzaG93KSB7XG4gICAgdGhpcy5kYXRhKCdpbmRleCcsIGN1cnJlbnRTZWxlY3RFbGVtZW50LmZpbmQoJ29wdGlvbicpLmluZGV4KHRoaXMpKTtcbiAgICAkKHRoaXMpLnByZXBlbmRUbyhkaXNhYmxlZFNlbGVjdEVsZW1lbnQpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHRoZSBvcHRpb24gaXMgc3RpbGwgc2VsZWN0ZWRcbiAgc2VsZWN0ZWRPcHRpb24ucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTtcbn1cblxuJC5mbi50b2dnbGVPcHRpb24gPSB0b2dnbGVPcHRpb247XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xuXG4vKipcbiAqIFJldHVybiBhIFwiU3RhdGVcIiBzZWxlY3QgaW5wdXRcbiAqIEBwYXJhbSAge29ian0gICAgICByZXNwb25zZURhdGEgLSByZXNwb25zZSBmcm9tIHV0aWxzLmFwaS5jb3VudHJ5LmdldEJ5TmFtZVxuICogQHBhcmFtICB7b2JqfSAgICAgIHN0YXRlQXR0cnMgLSBuYW1lIGFuZCBJRCBvZiBmaWVsZFxuICogQHBhcmFtICB7Ym9vbH0gICAgIHVzZUlkIC0gc2hvdWxkIHdlIHVzZSB0aGUgc3RhdGUgbmFtZSBvciBJRCBhcyB0aGUgdmFsdWU/XG4gKiBAcmV0dXJuIHtqUXVlcnl9ICAgYSBzZWxlY3QgaW5wdXRcbiAqL1xuZnVuY3Rpb24gc3RhdGVBc1NlbGVjdChyZXNwb25zZURhdGEsIHN0YXRlQXR0cnMsIHVzZUlkKSB7XG4gIGNvbnN0IHN0YXRlQXJyYXkgPSBbXTtcbiAgc3RhdGVBcnJheS5wdXNoKGA8b3B0aW9uIHZhbHVlPVwiXCI+JHtyZXNwb25zZURhdGEucHJlZml4fTwvb3B0aW9uPmApO1xuXG4gIGZvciAoY29uc3Qgc3RhdGUgb2YgcmVzcG9uc2VEYXRhLnN0YXRlcykge1xuICAgIGNvbnN0IG9wdGlvblZhbHVlID0gdXNlSWQgPyBzdGF0ZS5pZCA6IHN0YXRlLm5hbWU7XG4gICAgc3RhdGVBcnJheS5wdXNoKGA8b3B0aW9uIHZhbHVlPVwiJHtvcHRpb25WYWx1ZX1cIj4ke3N0YXRlLm5hbWV9PC9vcHRpb24+YCk7XG4gIH1cblxuICBjb25zdCAkc3RhdGVTZWxlY3QgPSAkKCc8c2VsZWN0PicsIHtcbiAgICBjbGFzczogJ2Zvcm0taW5wdXQgZm9ybS1zZWxlY3QnLFxuICAgIGlkOiBzdGF0ZUF0dHJzLnN0YXRlSWQsXG4gICAgbmFtZTogc3RhdGVBdHRycy5zdGF0ZU5hbWUsXG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgJ2FyaWEtcmVxdWlyZWQnOiB0cnVlLFxuICAgICdkYXRhLWZpZWxkLXR5cGUnOiAnU3RhdGUnLFxuICAgIGh0bWw6IHN0YXRlQXJyYXkuam9pbignICcpLFxuICB9KTtcblxuICByZXR1cm4gJHN0YXRlU2VsZWN0O1xufVxuXG4vKipcbiAqIFJldHVybiBhIFwiU3RhdGVcIiB0ZXh0IGlucHV0XG4gKiBAcGFyYW0gIHtvYmp9ICAgICAgc3RhdGVBdHRycyAtIG5hbWUgYW5kIElEIG9mIGZpZWxkXG4gKiBAcmV0dXJuIHtqUXVlcnl9ICAgYW4gdGV4dCBpbnB1dFxuICovXG5mdW5jdGlvbiBzdGF0ZUFzSW5wdXQoc3RhdGVBdHRycykge1xuICBjb25zdCAkc3RhdGVJbnB1dCA9ICQoJzxpbnB1dD4nLCB7XG4gICAgY2xhc3M6ICdmb3JtLWlucHV0JyxcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgaWQ6IHN0YXRlQXR0cnMuc3RhdGVJZCxcbiAgICBuYW1lOiBzdGF0ZUF0dHJzLnN0YXRlTmFtZSxcbiAgICAnZGF0YS1maWVsZC10eXBlJzogJ1N0YXRlJyxcbiAgfSk7XG5cbiAgcmV0dXJuICRzdGF0ZUlucHV0O1xufVxuXG4vKipcbiAqIFRvZ2dsZSBiZXR3ZWVuIGEgc3RhdGUgc2VsZWN0IGFuZCB0ZXh0IGlucHV0XG4gKiBAcGFyYW0gIHtvYmp9ICAgICAgZXZlbnQgICAgQ291bnRyeSBzZWxlY3QgY2hhbmdlIGV2ZW50XG4gKiBAcGFyYW0gIHtib29sfSAgICAgdXNlSWQgICAgd2hldGhlciB0byB1c2UgdGhlIHN0YXRlIGlkIG9yIG5hbWUgZm9yIG9wdGlvbiB2YWx1ZVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gZmV0Y2hBbmRVcGRhdGVTdGF0ZUlucHV0KGV2ZW50LCB1c2VJZCwgY2FsbGJhY2spIHtcbiAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gIGNvbnN0IGNvdW50cnkgPSAkdGFyZ2V0LnZhbCgpO1xuICBjb25zdCAkc3RhdGVFbGVtZW50ID0gJCgnW2RhdGEtZmllbGQtdHlwZT1cIlN0YXRlXCJdJyk7XG4gIGNvbnN0IHN0YXRlQXR0cnMgPSB7XG4gICAgc3RhdGVJZDogJHN0YXRlRWxlbWVudC5hdHRyKCdpZCcpLFxuICAgIHN0YXRlTmFtZTogJHN0YXRlRWxlbWVudC5hdHRyKCduYW1lJyksXG4gIH07XG4gIGNvbnN0ICRzdGF0ZVdyYXBwZXIgPSAkKCcjRm9ybUZpZWxkXzEyJyk7XG5cbiAgdXRpbHMuYXBpLmNvdW50cnkuZ2V0QnlOYW1lKGNvdW50cnksIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlLmRhdGEuc3RhdGVzLmxlbmd0aCkge1xuICAgICAgLy8gYnVpbGQgYW5kIGF0dGFjaCBvdXIgc2VsZWN0IGlucHV0XG4gICAgICBjb25zdCAkc3RhdGVTZWxlY3QgPSBzdGF0ZUFzU2VsZWN0KHJlc3BvbnNlLmRhdGEsIHN0YXRlQXR0cnMsIHVzZUlkKTtcbiAgICAgICRzdGF0ZUVsZW1lbnQucmVwbGFjZVdpdGgoJHN0YXRlU2VsZWN0KTtcbiAgICAgICRzdGF0ZVdyYXBwZXIudG9nZ2xlQ2xhc3MoJ2Zvcm0tcmVxdWlyZWQnLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnVpbGQgYW5kIGF0dGFjaCBvdXIgdGV4dCBpbnB1dFxuICAgICAgY29uc3QgJHN0YXRlSW5wdXQgPSBzdGF0ZUFzSW5wdXQoc3RhdGVBdHRycyk7XG4gICAgICAkc3RhdGVFbGVtZW50LnJlcGxhY2VXaXRoKCRzdGF0ZUlucHV0KTtcbiAgICAgICRzdGF0ZVdyYXBwZXIudG9nZ2xlQ2xhc3MoJ2Zvcm0tcmVxdWlyZWQnLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgY29uc3QgJG5ld1N0YXRlRWxlbWVudCA9ICQoJ1tkYXRhLWZpZWxkLXR5cGU9XCJTdGF0ZVwiXScpO1xuICAgIGNvbnN0ICRuZXdTdGF0ZUVsZW1lbnRQYXJlbnQgPSAkbmV3U3RhdGVFbGVtZW50LnBhcmVudCgpO1xuICAgIGNvbnN0ICRzZWxlY3RlZFRleHQgPSAkbmV3U3RhdGVFbGVtZW50UGFyZW50LmZpbmQoJy5mb3JtLXNlbGVjdGVkLXRleHQnKTtcblxuICAgIGlmIChyZXNwb25zZS5kYXRhLnN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICRuZXdTdGF0ZUVsZW1lbnRQYXJlbnQuYWRkQ2xhc3MoJ2Zvcm0tc2VsZWN0LXdyYXBwZXInKTtcblxuICAgICAgaWYgKCRzZWxlY3RlZFRleHQubGVuZ3RoKSB7XG4gICAgICAgICRzZWxlY3RlZFRleHQudGV4dChyZXNwb25zZS5kYXRhLnByZWZpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkbmV3U3RhdGVFbGVtZW50UGFyZW50LnByZXBlbmQoYDxzcGFuIGNsYXNzPVwiZm9ybS1zZWxlY3RlZC10ZXh0XCI+JHtyZXNwb25zZS5kYXRhLnByZWZpeH08L3NwYW4+YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjaygkbmV3U3RhdGVFbGVtZW50KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkc2VsZWN0ZWRUZXh0LnJlbW92ZSgpO1xuICAgICAgJG5ld1N0YXRlRWxlbWVudFBhcmVudC5yZW1vdmVDbGFzcygnZm9ybS1zZWxlY3Qtd3JhcHBlcicpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQmluZCB0aGUgdGhpbmcgdG8gdGhlIGNoYW5nZSBldmVudCBhbmQgZXhwb3J0IGl0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHVzZUlkLCBjYWxsYmFjaykge1xuICAkKGRvY3VtZW50LmJvZHkpLm9uKCdjaGFuZ2UnLCAnW2RhdGEtZmllbGQtdHlwZT1cIkNvdW50cnlcIl0nLCAoZXZlbnQpID0+IHtcbiAgICBmZXRjaEFuZFVwZGF0ZVN0YXRlSW5wdXQoZXZlbnQsIHVzZUlkLCBjYWxsYmFjayk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJvcGRvd24ge1xyXG4gIGNvbnN0cnVjdG9yKGVsKSB7XHJcbiAgICB0aGlzLiRlbCA9ICQoZWwpO1xyXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xyXG4gICAgdGhpcy50aW1lb3V0TGVhdmUgPSBudWxsO1xyXG4gICAgdGhpcy5kZWxheUxlYXZlID0gMzAwOyAvLyBBZGp1c3QgdGhlIGRlbGF5IHRvIGEgdmFsdWUgdGhhdCB3b3JrcyBiZXN0IGZvciB5b3VcclxuXHJcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIHNjcm9sbFxyXG4gICAgJCh3aW5kb3cpLm9uKCdzY3JvbGwnLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZVNjcm9sbCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXBwbHkgbWFyZ2luLXRvcCBpbml0aWFsbHkgaWYgdXNlciBpcyBhdCB0aGUgdG9wXHJcbiAgICB0aGlzLl9oYW5kbGVTY3JvbGwoKTtcclxuICB9XHJcblxyXG4gIF9iaW5kRXZlbnRzKCkge1xyXG4gICAgLy8gVXNpbmcgbW91c2VlbnRlciBhbmQgbW91c2VsZWF2ZSBmb3IgYmV0dGVyIGNvbnRyb2xcclxuICAgIHRoaXMuJGVsLm9uKCdtb3VzZWVudGVyJywgKGV2ZW50KSA9PiB0aGlzLl9oYW5kbGVNb3VzZUVudGVyKGV2ZW50KSk7XHJcbiAgICB0aGlzLiRlbC5vbignbW91c2VsZWF2ZScsIChldmVudCkgPT4gdGhpcy5faGFuZGxlTW91c2VMZWF2ZShldmVudCkpO1xyXG5cclxuICAgIC8vIENsb3NlIGRyb3Bkb3ducyB3aGVuIG1vdXNlIGxlYXZlcyB0aGUgbmF2aWdhdGlvbiBjb250YWluZXJcclxuICAgICQoJy5uYXZpZ2F0aW9uLWNvbnRhaW5lcicpLm9uKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9oaWRlQWxsQ2hpbGRyZW4odHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIG1vdXNlb3ZlciBvbiByb290IGxpc3QgaXRlbXNcclxuICAgIHRoaXMuJGVsLmZpbmQoJy5tZWdhLW5hdi1yb290LWl0ZW0nKS5vbignbW91c2VvdmVyJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZVJvb3RJdGVtTW91c2VPdmVyKGV2ZW50KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2hhbmRsZU1vdXNlRW50ZXIoZXZlbnQpIHtcclxuICAgIGNvbnN0ICRkcm9wZG93biA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICBjb25zdCAkZHJvcGRvd25QYW5lbCA9ICRkcm9wZG93bi5maW5kKCcuZHJvcGRvd24tcGFuZWwnKTtcclxuXHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0TGVhdmUpOyAvLyBDbGVhciBwcmV2aW91cyBsZWF2ZSB0aW1lb3V0XHJcblxyXG4gICAgJCgnLmRyb3Bkb3duLW9wZW4nKS5ub3QoJGRyb3Bkb3duKS5yZW1vdmVDbGFzcygnZHJvcGRvd24tb3BlbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoJy5kcm9wZG93bi1wYW5lbCcpLnJldmVhbGVyKCdoaWRlJyk7XHJcblxyXG4gICAgLy8gT25seSBhcHBseSBtYXJnaW4tdG9wIHdoZW4gYXQgdGhlIHRvcFxyXG4gICAgaWYgKCQod2luZG93KS5zY3JvbGxUb3AoKSA9PT0gMCkge1xyXG4gICAgICAkZHJvcGRvd25QYW5lbC5jc3MoJ21hcmdpbi10b3AnLCAnLTVweCcpO1xyXG4gICAgfVxyXG5cclxuICAgICRkcm9wZG93bi5hZGRDbGFzcygnZHJvcGRvd24tb3BlbicpO1xyXG4gICAgJGRyb3Bkb3duLmZpbmQoJy50b3AtbGV2ZWwtbmF2LWxpbmsnKS5hZGRDbGFzcygnZHJvcGRvd24tb3BlbicpO1xyXG4gICAgJGRyb3Bkb3duUGFuZWwucmV2ZWFsZXIoJ3Nob3cnKTtcclxuXHJcbiAgICAvLyBSZXNldCB2aXNpYmlsaXR5IG9mIGFsbCB0aWVyIDMgY2F0ZWdvcmllc1xyXG4gICAgJGRyb3Bkb3duUGFuZWwuZmluZCgnLm1lZ2EtbmF2LWNoaWxkLWxpc3QtY29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ3Zpc2libGUnKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGhvdmVyIGVmZmVjdFxyXG4gICAgJGRyb3Bkb3duUGFuZWwuZmluZCgnLm1lZ2EtbmF2LXJvb3QtbGlzdCAubWVnYS1uYXYtcm9vdC1pdGVtJykucmVtb3ZlQ2xhc3MoJ2hvdmVyZWQnKTtcclxuICAgICRkcm9wZG93blBhbmVsLmZpbmQoJy5tZWdhLW5hdi1yb290LWxpc3QgYScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuXHJcbiAgICAvLyBTaW11bGF0ZSBob3ZlciBmb3IgdGhlIGZpcnN0IGltbWVkaWF0ZSB0aWVyIDIgY2F0ZWdvcnlcclxuICAgIGNvbnN0ICRmaXJzdFRpZXIyID0gJGRyb3Bkb3duUGFuZWwuZmluZCgnLm1lZ2EtbmF2LXJvb3QtbGlzdCAubWVnYS1uYXYtcm9vdC1pdGVtJykuZmlyc3QoKTtcclxuICAgIGlmICgkZmlyc3RUaWVyMi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICRmaXJzdFRpZXIyLmFkZENsYXNzKCdob3ZlcmVkJyk7XHJcblxyXG4gICAgICAvLyBBcHBseSBlZmZlY3QgdG8gdGhlIDxhPiBlbGVtZW50IGluc2lkZSBlbGVtZW50cyB3aXRoIHRoZSBjbGFzcyAnaG92ZXJlZCdcclxuICAgICAgJGZpcnN0VGllcjIuZmluZCgnYScpLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuXHJcbiAgICAgIC8vIFNob3cgdGllciAzIGNhdGVnb3JpZXMgYmVsb25naW5nIHRvIHRoZSBob3ZlcmVkIHRpZXIgMiBjYXRlZ29yeVxyXG4gICAgICBjb25zdCBjYXRlZ29yeUlkID0gJGZpcnN0VGllcjIuZGF0YSgnY2F0ZWdvcnktaWQnKTtcclxuICAgICAgY29uc3QgJGNoaWxkTGlzdCA9ICRkcm9wZG93blBhbmVsLmZpbmQoJ1tkYXRhLXJvb3QtY2F0ZWdvcnktaWQ9XCInICsgY2F0ZWdvcnlJZCArICdcIl0nKTtcclxuICAgICAgaWYgKCRjaGlsZExpc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICRjaGlsZExpc3QuY2xvc2VzdCgnLm1lZ2EtbmF2LWNoaWxkLWxpc3QtY29udGFpbmVyJykuYWRkQ2xhc3MoJ3Zpc2libGUnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2hhbmRsZU1vdXNlTGVhdmUoZXZlbnQpIHtcclxuICAgIGNvbnN0ICRkcm9wZG93biA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICBjb25zdCAkZHJvcGRvd25QYW5lbCA9ICRkcm9wZG93bi5maW5kKCcuZHJvcGRvd24tcGFuZWwnKTtcclxuXHJcbiAgICB0aGlzLnRpbWVvdXRMZWF2ZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAvLyBDaGVjayBpZiBtb3VzZSBwb2ludGVyIGlzIG5vdCBvdmVyIHRoZSBkcm9wZG93biBvciBpdHMgcGFuZWxcclxuICAgICAgaWYgKCEkZHJvcGRvd24uaXMoJzpob3ZlcicpICYmICEkZHJvcGRvd25QYW5lbC5pcygnOmhvdmVyJykpIHtcclxuICAgICAgICAvLyBDbG9zZSB0aGUgZHJvcGRvd25cclxuICAgICAgICAkZHJvcGRvd24ucmVtb3ZlQ2xhc3MoJ2Ryb3Bkb3duLW9wZW4nKTtcclxuICAgICAgICAkZHJvcGRvd25QYW5lbC5yZXZlYWxlcignaGlkZScpO1xyXG4gICAgICAgICRkcm9wZG93bi5yZW1vdmVDbGFzcygnYWN0aXZlJyk7IC8vIFJlbW92ZSBhY3RpdmUgY2xhc3Mgd2hlbiBtb3VzZSBsZWF2ZXNcclxuICAgICAgICAkZHJvcGRvd24uZmluZCgnLnRvcC1sZXZlbC1uYXYtbGluaycpLnJlbW92ZUNsYXNzKCdkcm9wZG93bi1vcGVuJyk7XHJcbiAgICAgIH1cclxuICAgIH0sIHRoaXMuZGVsYXlMZWF2ZSk7XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlUm9vdEl0ZW1Nb3VzZU92ZXIoZXZlbnQpIHtcclxuICAgIGNvbnN0ICRyb290SXRlbSA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICBjb25zdCAkZHJvcGRvd25QYW5lbCA9ICRyb290SXRlbS5jbG9zZXN0KCcuZHJvcGRvd24tcGFuZWwnKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgJ2hvdmVyZWQnIGNsYXNzIGZyb20gYWxsIHJvb3QgbGlzdCBpdGVtc1xyXG4gICAgJGRyb3Bkb3duUGFuZWwuZmluZCgnLm1lZ2EtbmF2LXJvb3QtaXRlbScpLnJlbW92ZUNsYXNzKCdob3ZlcmVkJyk7XHJcbiAgICAvLyBBZGQgJ2hvdmVyZWQnIGNsYXNzIHRvIHRoZSBjdXJyZW50IHJvb3QgbGlzdCBpdGVtXHJcbiAgICAkcm9vdEl0ZW0uYWRkQ2xhc3MoJ2hvdmVyZWQnKTtcclxuICAgIC8vIFNob3cgdGllciAzIGNhdGVnb3JpZXMgYmVsb25naW5nIHRvIHRoZSBob3ZlcmVkIHRpZXIgMiBjYXRlZ29yeVxyXG4gICAgY29uc3QgY2F0ZWdvcnlJZCA9ICRyb290SXRlbS5kYXRhKCdjYXRlZ29yeS1pZCcpO1xyXG4gICAgY29uc3QgJGNoaWxkTGlzdCA9ICRkcm9wZG93blBhbmVsLmZpbmQoJ1tkYXRhLXJvb3QtY2F0ZWdvcnktaWQ9XCInICsgY2F0ZWdvcnlJZCArICdcIl0nKTtcclxuICAgIFxyXG4gICAgLy8gSGlkZSBhbGwgY2hpbGQgY29udGFpbmVyc1xyXG4gICAgJGRyb3Bkb3duUGFuZWwuZmluZCgnLm1lZ2EtbmF2LWNoaWxkLWxpc3QtY29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ3Zpc2libGUnKTtcclxuICAgIFxyXG4gICAgaWYgKCRjaGlsZExpc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAkY2hpbGRMaXN0LmNsb3Nlc3QoJy5tZWdhLW5hdi1jaGlsZC1saXN0LWNvbnRhaW5lcicpLmFkZENsYXNzKCd2aXNpYmxlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBIYW5kbGUgc2Nyb2xsIGV2ZW50IHRvIHJlbW92ZSBtYXJnaW4tdG9wIHByb3BlcnR5IHdoZW4gc2Nyb2xsZWQgZG93biBtb3JlIHRoYW4gNTBweFxyXG4gIF9oYW5kbGVTY3JvbGwoKSB7XHJcbiAgICBjb25zdCAkZHJvcGRvd25QYW5lbCA9IHRoaXMuJGVsLmZpbmQoJy5kcm9wZG93bi1wYW5lbCcpO1xyXG4gICAgaWYgKCQod2luZG93KS5zY3JvbGxUb3AoKSA+IDUwKSB7XHJcbiAgICAgICRkcm9wZG93blBhbmVsLmNzcygnbWFyZ2luLXRvcCcsICcnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICRkcm9wZG93blBhbmVsLmNzcygnbWFyZ2luLXRvcCcsICcwcHgnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oaWRlQWxsQ2hpbGRyZW4ocmVtb3ZlQWN0aXZlID0gZmFsc2UpIHtcclxuICAgIGlmIChyZW1vdmVBY3RpdmUpIHtcclxuICAgICAgdGhpcy4kZWwuZmluZCgnW2RhdGEtbWVnYS1uYXYtcm9vdC1pdGVtXScpLnJlbW92ZUNsYXNzKCdob3ZlcmVkIGFjdGl2ZScpO1xyXG4gICAgfVxyXG4gICAgdGhpcy4kZWwuZmluZCgnLm1lZ2EtbmF2LWNoaWxkLWxpc3QtY29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ3Zpc2libGUnKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaG9va3MsIGFwaSB9IGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcbmltcG9ydCBVcmwgZnJvbSAndXJsJztcbmltcG9ydCBMb2FkaW5nIGZyb20gJ2JjLWxvYWRpbmcnO1xuaW1wb3J0ICdoaXN0b3J5LmpzL3NjcmlwdHMvYnVuZGxlZC11bmNvbXByZXNzZWQvaHRtbDQraHRtbDUvanF1ZXJ5Lmhpc3RvcnknO1xuaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi9zdmdJY29uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjZXRlZFNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuJGJvZHkgPSAkKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGNhdGVnb3J5OiB7XG4gICAgICAgICAgc2hvcF9ieV9wcmljZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGVtcGxhdGU6IHtcbiAgICAgICAgcHJvZHVjdExpc3Rpbmc6ICdjYXRlZ29yeS9wcm9kdWN0LWxpc3RpbmcnLFxuICAgICAgICBzaWRlYmFyOiAnY2F0ZWdvcnkvc2lkZWJhcidcbiAgICAgIH0sXG4gICAgICBzY29wZToge1xuICAgICAgICBwcm9kdWN0TGlzdGluZzogJ1tkYXRhLWNhdGVnb3J5XScsXG4gICAgICAgIHNpZGViYXI6ICdbZGF0YS1jYXRlZ29yeS1zaWRlYmFyXScsXG4gICAgICB9LFxuICAgICAgZmFjZXRUb2dnbGU6ICdbZGF0YS1mYWNldC10b2dnbGVdJyxcbiAgICAgIG1vcmVUb2dnbGU6ICdbZGF0YS1mYWNldC1tb3JlXScsXG4gICAgICBtb3JlRmFjZXRzOiAnW2RhdGEtc2hvdy1tb3JlLWZhY2V0c10nLFxuICAgICAgdG9nZ2xlRmFjZXQ6ICgpID0+IGNvbnNvbGUubG9nKCdGYWNldCB0b2dnbGVkLicpLFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5sb2FkaW5nT3B0aW9ucyA9IHtcbiAgICAgIGxvYWRpbmdNYXJrdXA6IGA8ZGl2IGNsYXNzPVwibG9hZGluZy1vdmVybGF5XCI+JHtzdmdJY29uKCdzcGlubmVyJyl9PC9kaXY+YCxcbiAgICB9O1xuXG4gICAgdGhpcy5mYWNldGVkU2VhcmNoT3ZlcmxheSA9IG5ldyBMb2FkaW5nKHRoaXMubG9hZGluZ09wdGlvbnMsIGZhbHNlLCAnLmxpc3Rpbmctc2lkZWJhcicpO1xuXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiB0aGlzLmZhY2V0ZWRTZWFyY2hPdmVybGF5LnNob3coKSxcbiAgICAgIGRpZFVwZGF0ZTogKCkgPT4gdGhpcy5mYWNldGVkU2VhcmNoT3ZlcmxheS5oaWRlKCksXG4gICAgfSwgb3B0aW9ucy5jYWxsYmFja3MpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIHRoaXMuX3Nhbml0aXplRmFjZXRzKCk7XG4gIH1cblxuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMudGVtcGxhdGUgPSAkLmV4dGVuZCh7XG4gICAgICBwcm9kdWN0TGlzdGluZzogdGhpcy5vcHRpb25zLnRlbXBsYXRlLnByb2R1Y3RMaXN0aW5nLFxuICAgICAgc2lkZWJhcjogdGhpcy5vcHRpb25zLnRlbXBsYXRlLnNpZGViYXIsXG4gICAgfSwgb3B0aW9ucy50ZW1wbGF0ZSk7XG5cbiAgICB0aGlzLl9vblN0YXRlQ2hhbmdlKCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsIHRoaXMub3B0aW9ucy5mYWNldFRvZ2dsZSwgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl90b2dnbGVGYWNldChldmVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsIHRoaXMub3B0aW9ucy5tb3JlVG9nZ2xlLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3Nob3dBZGRpdGlvbmFsRmlsdGVycyhldmVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsIHRoaXMub3B0aW9ucy5tb3JlRmFjZXRzLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3Nob3dNb3JlRmFjZXRzKGV2ZW50KTtcbiAgICB9KTtcblxuICAgICQod2luZG93KS5vbignc3RhdGVjaGFuZ2UnLCB0aGlzLl9vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIGhvb2tzLm9uKCdmYWNldGVkU2VhcmNoLWZhY2V0LWNsaWNrZWQnLCB0aGlzLl9vbkZhY2V0Q2xpY2suYmluZCh0aGlzKSk7XG4gICAgaG9va3Mub24oJ2ZhY2V0ZWRTZWFyY2gtcmFuZ2Utc3VibWl0dGVkJywgdGhpcy5fb25SYW5nZVN1Ym1pdC5iaW5kKHRoaXMpKTtcbiAgICBob29rcy5vbignc29ydEJ5LXN1Ym1pdHRlZCcsIHRoaXMuX29uU29ydEJ5U3VibWl0LmJpbmQodGhpcykpO1xuICB9XG5cbiAgLy8gY2xlYW4gdXAgdXNlciBkZWZpbmVkIGZhY2V0IGlkcyAvIHNob3cgbW9yZSBsaW5rcyBmb3Igc3BlY2lhbCBjaGFyYWN0ZXJzXG4gIF9zYW5pdGl6ZUZhY2V0cygpIHtcbiAgICAkKCcuZmFjZXQtbGlzdC1pdGVtcycpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBvbGRUYXJnZXRJZCA9ICQoZWxlbWVudCkuYXR0cignaWQnKTtcbiAgICAgIGNvbnN0IG5ld1RhcmdldElkID0gb2xkVGFyZ2V0SWQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOS1dKy9nLCAnLScpO1xuICAgICAgJChlbGVtZW50KS5hdHRyKCdpZCcsIG5ld1RhcmdldElkKTtcbiAgICB9KTtcblxuICAgICQoJy5mYWNldC10b2dnbGUtbW9yZScpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBvbGRIcmVmID0gJChlbGVtZW50KS5hdHRyKCdocmVmJyk7XG4gICAgICBjb25zdCBuZXdIcmVmID0gb2xkSHJlZi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XFwtI10rL2csICctJyk7XG4gICAgICAkKGVsZW1lbnQpLmF0dHIoJ2hyZWYnLCBuZXdIcmVmKTtcbiAgICB9KVxuICB9XG5cbiAgX3Nob3dNb3JlRmFjZXRzKGV2ZW50KSB7XG4gICAgLy8gU2hvdy9oaWRlIGV4dHJhIGZhY2V0cyBiYXNlZCBvbiBzZXR0aW5ncyBmb3IgcHJvZHVjdCBmaWx0ZXJpbmdcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY2FsbGJhY2tzLndpbGxVcGRhdGUoKTtcblxuICAgIGNvbnN0ICR0b2dnbGUgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0ICRuYXZMaXN0ID0gJCgkdG9nZ2xlLmF0dHIoJ2hyZWYnKSk7XG4gICAgY29uc3QgZmFjZXQgPSAkbmF2TGlzdC5kYXRhKCdmYWNldCcpO1xuICAgIGNvbnN0IGZhY2V0VXJsID0gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0ke3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZX1gO1xuXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgbGlzdF9hbGw6IGZhY2V0XG4gICAgfTtcblxuICAgIGlmICh3aW5kb3cubG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBjb25zdCBxdWVyeVN0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5U3RyaW5nKTtcblxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdXJsUGFyYW1zKSB7XG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJHRvZ2dsZS5zaWJsaW5ncygnLmZhY2V0ZWQtc2VhcmNoLW9wdGlvbi1jb2x1bW5zJykubGVuZ3RoID09IDApIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd01vcmUpIHtcbiAgICAgICAgYXBpLmdldFBhZ2UoZmFjZXRVcmwsIHtcbiAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy5vcHRpb25zLnNob3dNb3JlLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgfSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJChyZXNwb25zZSkuaW5zZXJ0QWZ0ZXIoJG5hdkxpc3QpO1xuICAgICAgICAgICR0b2dnbGUuc2libGluZ3MoJy5mYWNldGVkLXNlYXJjaC1vcHRpb24tY29sdW1ucycpLmFkZENsYXNzKCd2aXNpYmxlJyk7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkdG9nZ2xlLnNpYmxpbmdzKCcuZmFjZXRlZC1zZWFyY2gtb3B0aW9uLWNvbHVtbnMnKS50b2dnbGUoKTtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgICRuYXZMaXN0LnRvZ2dsZSgpO1xuXG4gICAgLy8gdG9nZ2xlIG1vcmUvbGVzcyBsaW5rXG4gICAgJHRvZ2dsZS5jaGlsZHJlbigpLnRvZ2dsZSgpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX3Nob3dBZGRpdGlvbmFsRmlsdGVycyhldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpXG4gICAgICAuYWRkQ2xhc3MoJ2hpZGRlbicpXG4gICAgICAucGFyZW50KCdsaScpXG4gICAgICAuc2libGluZ3MoJ2xpJylcbiAgICAgIC5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gIH1cblxuICBfdG9nZ2xlRmFjZXQoZXZlbnQpIHtcbiAgICB0aGlzLm9wdGlvbnMudG9nZ2xlRmFjZXQoZXZlbnQpO1xuICB9XG5cbiAgX29uRmFjZXRDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0ICR0YXJnZXQgPSAkKHRhcmdldCk7XG4gICAgY29uc3QgdXJsID0gJHRhcmdldC5hdHRyKCdocmVmJyk7XG5cbiAgICB0aGlzLl9nb1RvVXJsKHVybCk7XG4gIH1cblxuICBfb25SYW5nZVN1Ym1pdChldmVudCwgdGFyZ2V0KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHVybCA9IFVybC5wYXJzZSh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgbGV0IHF1ZXJ5UGFyYW1zID0gJCh0YXJnZXQpLnNlcmlhbGl6ZSgpO1xuXG4gICAgaWYgKHRoaXMuJGJvZHkuaGFzQ2xhc3MoJ3NlYXJjaCcpKSB7XG4gICAgICBjb25zdCBjdXJyZW50U2VhcmNoID0gYHNlYXJjaF9xdWVyeT0keyQoJ1tkYXRhLWZhY2V0ZWQtc2VhcmNoXScpLmRhdGEoJ3NlYXJjaC1xdWVyeScpfWAgfHwgJyc7XG4gICAgICBxdWVyeVBhcmFtcyA9IGAke2N1cnJlbnRTZWFyY2h9JiR7cXVlcnlQYXJhbXN9YDtcbiAgICB9XG5cbiAgICB0aGlzLl9nb1RvVXJsKFVybC5mb3JtYXQoeyBwYXRobmFtZTogdXJsLnBhdGhuYW1lLCBzZWFyY2g6ICc/JyArIHF1ZXJ5UGFyYW1zIH0pKTtcbiAgfVxuXG4gIF9vblNvcnRCeVN1Ym1pdChldmVudCwgdGFyZ2V0KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHVybCA9IFVybC5wYXJzZShsb2NhdGlvbi5ocmVmLCB0cnVlKTtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9ICQodGFyZ2V0KS5zZXJpYWxpemUoKS5zcGxpdCgnPScpO1xuXG4gICAgdXJsLnF1ZXJ5W3F1ZXJ5UGFyYW1zWzBdXSA9IHF1ZXJ5UGFyYW1zWzFdO1xuICAgIGRlbGV0ZSB1cmwucXVlcnlbJ3BhZ2UnXTtcblxuICAgIHRoaXMuX2dvVG9VcmwoVXJsLmZvcm1hdCh7IHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsIHF1ZXJ5OiB1cmwucXVlcnkgfSkpO1xuICB9XG5cbiAgX29uU3RhdGVDaGFuZ2UoZXZlbnQpIHtcbiAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCk7XG5cbiAgICBhcGkuZ2V0UGFnZShIaXN0b3J5LmdldFN0YXRlKCkudXJsLCB0aGlzLm9wdGlvbnMsIChlcnIsIGNvbnRlbnQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICQodGhpcy5vcHRpb25zLnNjb3BlLnByb2R1Y3RMaXN0aW5nKS5odG1sKGNvbnRlbnQucHJvZHVjdExpc3RpbmcpO1xuICAgICAgICAkKHRoaXMub3B0aW9ucy5zY29wZS5zaWRlYmFyKS5odG1sKGNvbnRlbnQuc2lkZWJhcik7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9zYW5pdGl6ZUZhY2V0cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2dvVG9VcmwodXJsKSB7XG4gICAgSGlzdG9yeS5wdXNoU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB1cmwpO1xuICB9XG59XG4iLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi9zdmdJY29uJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWFkZXIge1xuICBjb25zdHJ1Y3RvcihlbCkge1xuICAgIHRoaXMuJGVsID0gJChlbCk7XG4gICAgdGhpcy4kYm9keSA9ICQoJ2JvZHknKTtcbiAgICB0aGlzLiR3cmFwcGVyID0gJCgnLnNpdGUtd3JhcHBlcicpO1xuICAgIHRoaXMuJHNlYXJjaFdyYXAgPSAkKCcuc2VhcmNoLXdyYXAnKTtcbiAgICB0aGlzLiRoZWFkZXIgPSAkKCcuc2l0ZS1oZWFkZXInKTtcblxuICAgIHRoaXMuJHRvcEJhciA9IHRoaXMuJGhlYWRlci5maW5kKCcudG9wLWJhcicpO1xuICAgIHRoaXMuJG5hdkJhciA9IHRoaXMuJGhlYWRlci5maW5kKCcubWFpbi1uYXYtYmFyJyk7XG5cbiAgICB0aGlzLmNhcnRPcGVuQ2xhc3MgPSAnbWluaS1jYXJ0LW9wZW4nO1xuICAgIHRoaXMuc2VhcmNoT3BlbkNsYXNzID0gJ3NlYXJjaC1vcGVuJztcbiAgICB0aGlzLm5hdk9wZW5DbGFzcyA9ICduYXYtbW9iaWxlLW9wZW4gc2Nyb2xsLWxvY2tlZCc7XG5cbiAgICB0aGlzLiRsb2dpblJlZ2lzdGVyID0gJCgnLmxvZ2luLXJlZ2lzdGVyLWJsb2NrJyk7XG4gICAgdGhpcy4kZm9yZ290UGFzc3dvcmQgPSAkKCcuZm9yZ290LXBhc3N3b3JkLWJsb2NrJyk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5fYWRqdXN0SGVpZ2h0cygpO1xuICAgIHRoaXMuX2hlYWRlclNjcm9sbCgpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgLy8gVG9nZ2xlIG1pbmkgY2FydCBwYW5lbFxuICAgIHRoaXMuJGVsLmZpbmQoJy5idXR0b24tY2FydC10b2dnbGUnKS5vbignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZU1pbmlDYXJ0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcblxuICAgIC8vIENsb3NlIG1pbmkgY2FydCBwYW5lbFxuICAgICQoJy5idXR0b24tY2FydC1jbG9zZScpLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZU1pbmlDYXJ0KGZhbHNlKTtcbiAgICB9KTtcblxuICAgICQoJy5vbi1jYW52YXMnKS5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICBpZiAoJCgnLm1pbmktY2FydC1vcGVuJykubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZU1pbmlDYXJ0KGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsb3NlIFVJIGVsZW1ldHMgd2l0aCBlc2Mga2V5XG4gICAgJChkb2N1bWVudCkub24oJ2tleXVwJywgKGUpID0+IHtcbiAgICAgIC8vIE1pbmkgY2FydFxuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcgJiYgdGhpcy4kYm9keS5oYXNDbGFzcyh0aGlzLmNhcnRPcGVuQ2xhc3MpKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZU1pbmlDYXJ0KGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VhcmNoXG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAyNyAmJiB0aGlzLiRzZWFyY2hXcmFwLmhhc0NsYXNzKHRoaXMuc2VhcmNoT3BlbkNsYXNzKSkge1xuICAgICAgICB0aGlzLl90b2dnbGVTZWFyY2goZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVG9nZ2xlIHNlYXJjaFxuICAgICQoJy5idXR0b24tc2VhcmNoLXRvZ2dsZScpLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZVNlYXJjaCgpO1xuXG4gICAgICAvLyBDbG9zZSBjYXJ0XG4gICAgICBpZiAodGhpcy4kd3JhcHBlci5oYXNDbGFzcyh0aGlzLmNhcnRPcGVuQ2xhc3MpKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZU1pbmlDYXJ0KGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsb3NlIFNlYXJjaFxuICAgICQoJy5idXR0b24tc2VhcmNoLWNsb3NlJykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlU2VhcmNoKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIC8vIFRvZ2dsZSBtb2JpbGUgbmF2XG4gICAgJCgnLmJ1dHRvbi1tb2JpbGUtbmF2LXRvZ2dsZScpLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZU1vYmlsZU5hdigpO1xuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIHJlc2l6ZSBldmVudHMgYW5kIHByb3ZpZGUgZGVib3VuY2UgdG8gcHJldmVudCB0b28gbXVjaFxuICAgIHRoaXMuX2hhbmRsZVJlc2l6ZSA9IF8uZGVib3VuY2UodGhpcy5faGFuZGxlUmVzaXplLmJpbmQodGhpcyksIDIwMCk7XG5cbiAgICAkKHdpbmRvdykucmVzaXplKHRoaXMuX2hhbmRsZVJlc2l6ZSk7XG4gIH1cblxuICBfaGFuZGxlUmVzaXplKCkge1xuICAgIC8vIFJlc2V0IHRoZSBtb2JpbGUgcGFuZWwgaWYgd2luZG93IGlzIG1hZGUgbGFyZ2VyXG4gICAgdGhpcy5fYWRqdXN0SGVpZ2h0cygpO1xuXG4gICAgLy8gQ2hlY2sgaGVhZGVyIGhlaWdodCBvbiByZXNpemUgZm9yIGNsYXNzIGFwcGxpY2F0aW9uXG4gICAgdGhpcy5faGVhZGVyU2Nyb2xsKCk7XG4gIH1cblxuICBfdG9nZ2xlTWluaUNhcnQob3Blbikge1xuICAgIC8vIFBhc3MgXCJmYWxzZVwiIHRvIHJlbW92ZSB0aGUgY2xhc3MgLyBjbG9zZSBjYXJ0XG4gICAgdGhpcy4kYm9keS50b2dnbGVDbGFzcyh0aGlzLmNhcnRPcGVuQ2xhc3MsIG9wZW4pO1xuICB9XG5cbiAgX3RvZ2dsZVNlYXJjaChvcGVuKSB7XG4gICAgdGhpcy4kc2VhcmNoV3JhcC50b2dnbGVDbGFzcyh0aGlzLnNlYXJjaE9wZW5DbGFzcywgb3Blbik7XG5cbiAgICBpZiAodGhpcy4kc2VhcmNoV3JhcC5oYXNDbGFzcyh0aGlzLnNlYXJjaE9wZW5DbGFzcykpIHtcbiAgICAgIHRoaXMuJHNlYXJjaFdyYXAuZmluZCgnLnNlYXJjaC1pbnB1dCcpLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgX3RvZ2dsZU1vYmlsZU5hdihvcGVuKSB7XG4gICAgdGhpcy4kYm9keS50b2dnbGVDbGFzcyh0aGlzLm5hdk9wZW5DbGFzcywgb3Blbik7XG5cbiAgICBpZiAob3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgICQoJy5uYXZpZ2F0aW9uLW1vYmlsZScpLnJldmVhbGVyKCdoaWRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoJy5uYXZpZ2F0aW9uLW1vYmlsZScpLnJldmVhbGVyKCd0b2dnbGUnKTtcbiAgICB9XG4gIH1cblxuICBfaGVhZGVyU2Nyb2xsKCkge1xuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBuYXZpZ3Rpb24gaGFzIGEgc2Vjb25kIHJvdywgYW5kIGRpc2FsbG93IFwiY29tcHJlc3NlZFwiIHN0YXRlIGlmIHRydWVcbiAgICBjb25zdCBkZWZhdWx0TmF2YmFySGVpZ2h0ID0gMTAwO1xuICAgIGNvbnN0ICRjdXJyZW50TmF2QmFyID0gdGhpcy4kbmF2QmFyLmZpbmQoJy5uYXZpZ2F0aW9uJykuZmluZCgndWw6Zmlyc3QtY2hpbGQnKTtcbiAgICB2YXIgY3VycmVudE5hdkJhckhlaWdodCA9ICRjdXJyZW50TmF2QmFyLm91dGVySGVpZ2h0KCk7XG5cbiAgICBpZihjdXJyZW50TmF2QmFySGVpZ2h0ID4gZGVmYXVsdE5hdmJhckhlaWdodCkge1xuICAgICAgdGhpcy4kbmF2QmFyLmFkZENsYXNzKCdtdWx0aS1yb3cnKTtcbiAgICAgICRjdXJyZW50TmF2QmFyLmFkZENsYXNzKCdlbmZvcmNlLW1heC13aWR0aCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRuYXZCYXIucmVtb3ZlQ2xhc3MoJ211bHRpLXJvdycpO1xuICAgICAgJGN1cnJlbnROYXZCYXIucmVtb3ZlQ2xhc3MoJ2VuZm9yY2UtbWF4LXdpZHRoJyk7XG4gICAgfVxuXG4gICAgY29uc3QgJHdpbiA9ICQod2luZG93KTtcbi8qICAgICBjb25zdCB0aHJlc2hvbGQgPSA4MDtcbiAgICBjb25zdCBzY3JvbGxDbGFzcyA9ICdjb21wcmVzc2VkJztcblxuICAgIC8vIGlmIHdlIGxvYWQgdGhlIHBhZ2UgcGFydCB3YXkgZG93blxuICAgIGlmICgkd2luLnNjcm9sbFRvcCgpID4gdGhyZXNob2xkKSB7XG4gICAgICB0aGlzLiRoZWFkZXIuYWRkQ2xhc3Moc2Nyb2xsQ2xhc3MpO1xuICAgIH1cblxuICAgICR3aW4ucmVzaXplKCgpID0+IHtcbiAgICAgIGNvbnN0IGNvbXByZXNzSGVhZGVyID0gZmFsc2U7XG4gICAgICBjdXJyZW50TmF2QmFySGVpZ2h0ID0gJGN1cnJlbnROYXZCYXIub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgaWYgKGN1cnJlbnROYXZCYXJIZWlnaHQgPiBkZWZhdWx0TmF2YmFySGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuJGhlYWRlci50b2dnbGVDbGFzcyhzY3JvbGxDbGFzcywgY29tcHJlc3NIZWFkZXIpO1xuICAgICAgfVxuICAgIH0pOyAqL1xuXG4gICAgLyogJHdpbi5zY3JvbGwoKCkgPT4ge1xuICAgICAgY29uc3Qgc3QgPSAkd2luLnNjcm9sbFRvcCgpO1xuICAgICAgY29uc3QgY29tcHJlc3NIZWFkZXIgPSAoc3QgPiAwKSA/IHRydWUgOiBmYWxzZTsgLy8gQWx3YXlzIGNvbXByZXNzIGhlYWRlciBvbiBzY3JvbGxcbiAgXG4gICAgICB0aGlzLiRoZWFkZXIudG9nZ2xlQ2xhc3Moc2Nyb2xsQ2xhc3MsIGNvbXByZXNzSGVhZGVyKTtcbiAgICB9KTsgKi9cbiAgfVxuXG4gIF9hZGp1c3RIZWlnaHRzKCkge1xuICAgIGNvbnN0ICRjYW52YXMgPSB0aGlzLiRib2R5LmZpbmQoJy5zaXRlLWNhbnZhcycpO1xuICAgIGNvbnN0IGRlZmF1bHRUb3BCYXJIZWlnaHQgPSA1NjtcbiAgICBjb25zdCB0b3BCYXJIZWlnaHQgPSB0aGlzLiR0b3BCYXIub3V0ZXJIZWlnaHQoKTtcbiAgICBjb25zdCBkZWZhdWx0RnVsbEhlYWRlckhlaWdodCA9IDE1NjtcbiAgICBjb25zdCBjdXJyZW50RnVsbEhlYWRlckhlaWdodCA9IHRoaXMuJGhlYWRlci5vdXRlckhlaWdodCgpO1xuICBcbiAgICBpZiAodGhpcy4kaGVhZGVyLmhhc0NsYXNzKCdjb21wcmVzc2VkJykpIHtcbiAgICAgICRjYW52YXMuY3NzKCdwYWRkaW5nLXRvcCcsIGRlZmF1bHRUb3BCYXJIZWlnaHQgKyAncHgnKTsgLy8gUmVtb3ZlIHBhZGRpbmcgd2hlbiBoZWFkZXIgaXMgY29tcHJlc3NlZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy4kbmF2QmFyLmlzKCc6aGlkZGVuJykpIHtcbiAgICAgICAgaWYgKHRvcEJhckhlaWdodCA+IGRlZmF1bHRUb3BCYXJIZWlnaHQpIHtcbiAgICAgICAgICAkY2FudmFzLmNzcygncGFkZGluZy10b3AnLCB0b3BCYXJIZWlnaHQgKyAncHgnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkY2FudmFzLmNzcygncGFkZGluZy10b3AnLCBkZWZhdWx0VG9wQmFySGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSB0b3AgYmFyIGFuZCB0aGUgbWFpbiBuYXZpZ2F0aW9uIGJhclxuICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IHRvcEJhckhlaWdodCArIHRoaXMuJG5hdkJhci5vdXRlckhlaWdodCgpO1xuICBcbiAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGhlaWdodCBleGNlZWRzIHRoZSBkZWZhdWx0IGZ1bGwgaGVhZGVyIGhlaWdodCwgcmVkdWNlIHRoZSB0b3AgcGFkZGluZyBvZiB0aGUgY2FudmFzXG4gICAgICAgIGlmICh0b3RhbEhlaWdodCA+IGRlZmF1bHRGdWxsSGVhZGVySGVpZ2h0KSB7XG4gICAgICAgICAgJGNhbnZhcy5jc3MoJ3BhZGRpbmctdG9wJywgdG90YWxIZWlnaHQgKyAncHgnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkY2FudmFzLmNzcygncGFkZGluZy10b3AnLCBkZWZhdWx0RnVsbEhlYWRlckhlaWdodCArICdweCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBcbiAgICBpZiAodG9wQmFySGVpZ2h0ID4gZGVmYXVsdFRvcEJhckhlaWdodCkge1xuICAgICAgY29uc3QgJG1vYmlsZU5hdiA9IHRoaXMuJGJvZHkuZmluZCgnLm5hdmlnYXRpb24tbW9iaWxlJyk7XG4gICAgICAkbW9iaWxlTmF2LmNzcyh7ICd0b3AnIDogdG9wQmFySGVpZ2h0ICsgJ3B4JyB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIFxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVnYU5hdiB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGVsKSB7XHJcblxyXG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcclxuXHJcbiAgICB0aGlzLiRyb290TWVudSA9IHRoaXMuJGVsLmZpbmQoJy5tZWdhLW5hdi1yb290LWxpc3QnKTtcclxuXHJcbiAgICB0aGlzLiRjaGlsZENvbnRhaW5lciA9IHRoaXMuJGVsLmZpbmQoJy5tZWdhLW5hdi1jaGlsZC1jb250YWluZXInKTtcclxuXHJcbiAgICB0aGlzLiRkcm9wZG93blRvZ2dsZSA9IHRoaXMuJGVsLmNsb3Nlc3QoJy5kcm9wZG93bicpLmZpbmQoJy5kcm9wZG93bi10b2dnbGUnKTtcclxuXHJcblxyXG5cclxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcclxuXHJcbiAgICB0aGlzLl9oaWRlQWxsQ2hpbGRyZW4odHJ1ZSk7XHJcblxyXG4gIH1cclxuXHJcblxyXG5cclxuICBfYmluZEV2ZW50cygpIHtcclxuICAgIC8vIENoYW5nZSBldmVudCBmcm9tICdtb3VzZW92ZXInIHRvICdtb3VzZWVudGVyJyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXHJcbiAgICB0aGlzLiRlbC5vbignbW91c2VlbnRlcicsICdbZGF0YS1tZWdhLW5hdi1yb290LWl0ZW1dJywgKGUpID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5fZmluZENoaWxkRnJvbVJvb3QoZSk7XHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCBldmVudCB0byByZW1vdmUgaG92ZXIgZWZmZWN0IHdoZW4gbW91c2UgbGVhdmVzIHRoZSBlbnRpcmUgbmF2aWdhdGlvbiBhcmVhXHJcbiAgICB0aGlzLiRlbC5vbignbW91c2VsZWF2ZScsICgpID0+IHtcclxuICAgICAgICAvLyBSZW1vdmUgaG92ZXIgZWZmZWN0IGZyb20gYWxsIHJvb3QgaXRlbXNcclxuICAgICAgICB0aGlzLiRlbC5maW5kKCdbZGF0YS1tZWdhLW5hdi1yb290LWl0ZW1dJykucmVtb3ZlQ2xhc3MoJ2hvdmVyZWQnKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbiAgX2ZpbmRDaGlsZEZyb21Sb290KGUpIHtcclxuXHJcbiAgICBpZiAodGhpcy5kcm9wZG93bk9wZW4pIHtcclxuXHJcbiAgICAgIHRoaXMuX2hpZGVBbGxDaGlsZHJlbih0cnVlKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IHRydWU7XHJcblxyXG5cclxuXHJcbiAgICBjb25zdCAkcm9vdEl0ZW0gPSAkKGUuY3VycmVudFRhcmdldCk7XHJcblxyXG4gICAgY29uc3QgY2F0ZWdvcnlJZCA9ICRyb290SXRlbS5kYXRhKCdjYXRlZ29yeS1pZCcpO1xyXG5cclxuICAgIGNvbnN0ICRjaGlsZExpc3QgPSB0aGlzLiRlbC5maW5kKCdbZGF0YS1yb290LWNhdGVnb3J5LWlkPVwiJyArIGNhdGVnb3J5SWQgKyAnXCJdJyk7XHJcblxyXG5cclxuXHJcbiAgICAkcm9vdEl0ZW0uYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuXHJcblxyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY2hpbGRUaW1lcik7XHJcblxyXG4gICAgdGhpcy5jaGlsZFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcblxyXG4gICAgICAkY2hpbGRMaXN0LnJldmVhbGVyKCdzaG93Jyk7XHJcblxyXG4gICAgfSwgMTAwKTtcclxuXHJcbiAgfVxyXG5cclxuXHJcblxyXG4gIF9maW5kQ2hpbGQoZSkge1xyXG5cclxuICAgIGlmICh0aGlzLmRyb3Bkb3duT3Blbikge1xyXG5cclxuICAgICAgdGhpcy5faGlkZUFsbENoaWxkcmVuKHRydWUpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGNvbnN0ICR0YXJnZXQgPSAkKGUuY3VycmVudFRhcmdldCk7XHJcblxyXG4gICAgY29uc3QgY2hpbGRJZCA9ICR0YXJnZXQuZGF0YSgnbWVnYS1uYXYtY2hpbGQtaWQnKTtcclxuXHJcbiAgICBjb25zdCAkY2hpbGRMaXN0ID0gdGhpcy4kY2hpbGRDb250YWluZXIuZmluZCgnW2RhdGEtcm9vdC1jYXRlZ29yeS1pZD1cIicgKyBjaGlsZElkICsgJ1wiXScpO1xyXG5cclxuXHJcblxyXG4gICAgLy8gSGlkZSBhbGwgb3RoZXIgY2hpbGQgY2F0ZWdvcmllcyBpbW1lZGlhdGVseVxyXG5cclxuICAgIHRoaXMuJGNoaWxkQ29udGFpbmVyLmZpbmQoJy5tZWdhLW5hdi1jaGlsZC1saXN0LWNvbnRhaW5lcicpLnJlbW92ZUNsYXNzKCd2aXNpYmxlJyk7XHJcblxyXG5cclxuXHJcbiAgICBpZiAoJGNoaWxkTGlzdC5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICAvLyBTaG93IHRoZSByZWxldmFudCBjaGlsZCBjYXRlZ29yeSBhZnRlciBhIHNob3J0IGRlbGF5XHJcblxyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jaGlsZFRpbWVyKTtcclxuXHJcbiAgICAgIHRoaXMuY2hpbGRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cclxuICAgICAgICAkY2hpbGRMaXN0LmNsb3Nlc3QoJy5tZWdhLW5hdi1jaGlsZC1saXN0LWNvbnRhaW5lcicpLmFkZENsYXNzKCd2aXNpYmxlJyk7XHJcblxyXG4gICAgICB9LCAxMDApOyAvLyBBZGp1c3QgdGhlIGRlbGF5IGFzIG5lZWRlZFxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIHRoaXMuZHJvcGRvd25PcGVuID0gdHJ1ZTtcclxuXHJcbiAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgX2ZpbmRDaGlsZChlKSB7XHJcblxyXG4gICAgY29uc3QgJHRhcmdldCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHJcbiAgICBjb25zdCBjaGlsZElkID0gJHRhcmdldC5kYXRhKCdtZWdhLW5hdi1jaGlsZC1pZCcpO1xyXG5cclxuICAgIGNvbnN0ICRjaGlsZExpc3QgPSB0aGlzLiRjaGlsZENvbnRhaW5lci5maW5kKCdbZGF0YS1yb290LWNhdGVnb3J5LWlkPVwiJyArIGNoaWxkSWQgKyAnXCJdJyk7XHJcblxyXG5cclxuXHJcbiAgICBpZiAoJGNoaWxkTGlzdC5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICB0aGlzLl9oaWRlQWxsQ2hpbGRyZW4oKTtcclxuXHJcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsgJGNoaWxkTGlzdC5yZXZlYWxlcignc2hvdycpOyB9LCA1MDApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuXHJcblxyXG4gIF9maW5kUGFyZW50KGUpIHtcclxuXHJcbiAgICBjb25zdCAkbWludXMgPSAkKGUuY3VycmVudFRhcmdldCk7XHJcblxyXG4gICAgY29uc3QgcGFyZW50SWQgPSAkbWludXMuY2xvc2VzdCgnLm1lZ2EtbmF2LWNoaWxkLWxpc3QtY29udGFpbmVyJykuZGF0YSgncm9vdC1jYXRlZ29yeS1pZCcpO1xyXG5cclxuICAgIGNvbnN0ICRwYXJlbnQgPSB0aGlzLiRjaGlsZENvbnRhaW5lci5maW5kKCdbZGF0YS1tZWdhLW5hdi1jaGlsZC1pZD1cIicgKyBwYXJlbnRJZCArICdcIl0nKS5jbG9zZXN0KCcubWVnYS1uYXYtY2hpbGQtbGlzdC1jb250YWluZXInKTtcclxuXHJcblxyXG5cclxuICAgIGlmICgkcGFyZW50Lmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgIHRoaXMuX2hpZGVBbGxDaGlsZHJlbigpO1xyXG5cclxuICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4geyAkcGFyZW50LnJldmVhbGVyKCdzaG93Jyk7IH0sIDUwMCk7XHJcblxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG5cclxuXHJcbiAgX2hpZGVBbGxDaGlsZHJlbihyZW1vdmVBY3RpdmUgPSBmYWxzZSkge1xyXG5cclxuICAgIGlmIChyZW1vdmVBY3RpdmUpIHtcclxuXHJcbiAgICAgIHRoaXMuJGVsLmZpbmQoJ1tkYXRhLW1lZ2EtbmF2LXJvb3QtaXRlbV0nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuJGVsLmZpbmQoJy5tZWdhLW5hdi1jaGlsZC1saXN0LWNvbnRhaW5lcicpLnJldmVhbGVyKCdoaWRlJyk7XHJcblxyXG4gIH1cclxuXHJcblxyXG5cclxuICBfYWRqdXN0TWVnYU5hdlBhbmVsKCkge1xyXG5cclxuICAgIGNvbnN0ICRkcm9wZG93biA9IHRoaXMuJGRyb3Bkb3duVG9nZ2xlLmNsb3Nlc3QoJy5kcm9wZG93bicpO1xyXG5cclxuICAgIGNvbnN0ICRtZWdhTmF2UGFuZWwgPSAkZHJvcGRvd25Ub2dnbGUuZmluZCgnLm1lZ2EtbmF2LXBhbmVsJyk7XHJcblxyXG5cclxuXHJcbiAgICBpZiAoJGRyb3Bkb3duLmxlbmd0aCA+IDAgJiYgJG1lZ2FOYXZQYW5lbC5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICBjb25zdCBvZmZzZXQgPSAkZHJvcGRvd24ub2Zmc2V0KCkudG9wICsgJGRyb3Bkb3duLm91dGVySGVpZ2h0KCk7XHJcblxyXG5cclxuXHJcbiAgICAgICRtZWdhTmF2UGFuZWwuY3NzKHsgJ3RvcCc6IG9mZnNldCArICdweCcgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG59XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xuaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi9zdmdJY29uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWluaUNhcnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhcnRDaGFuZ2VSZW1vdGVIb29rcyA9IFtcbiAgICAgICdjYXJ0LWl0ZW0tYWRkLXJlbW90ZScsXG4gICAgICAnY2FydC1pdGVtLXVwZGF0ZS1yZW1vdGUnLFxuICAgICAgJ2NhcnQtaXRlbS1yZW1vdmUtcmVtb3RlJyxcbiAgICBdO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgLy8gVXBkYXRlIG1pbmljYXJ0IG9uIHN1Y2Nlc3NmdWwgYWRkIHRvIGNhcnRcbiAgICAkKGRvY3VtZW50KS5vbignY2FydC1pdGVtLWFkZC1zdWNjZXNzJywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBSZW1vdmUgY2FydCBpdGVtIHVzaW5nIG1pbmljYXJ0IGJ1dHRvblxuICAgICQoJ2JvZHknKS5vbignY2xpY2snLCAnLm1pbmktY2FydCBbZGF0YS1jYXJ0LWl0ZW0tcmVtb3ZlXScsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlUHJvZHVjdE1pbmlDYXJ0KGV2ZW50KTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW90ZSBldmVudHM6IHdoZW4gdGhlIHByb3BlciByZXNwb25zZSBpcyBzZW50XG4gICAgdGhpcy5jYXJ0Q2hhbmdlUmVtb3RlSG9va3MuZm9yRWFjaCgoaG9vaykgPT4ge1xuICAgICAgdXRpbHMuaG9va3Mub24oaG9vaywgKCkgPT4ge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gQ3VzdG9tIHNjcm9sbCBVWCBmb3IgbWluaWNhcnRcbiAgICB0aGlzLl9iaW5kU2Nyb2xsKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBtaW5pIGNhcnQgY29udGVudHNcbiAgICovXG4gIF91cGRhdGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCAkbWluaUNhcnQgPSAkKCcubWluaS1jYXJ0LWlubmVyJyk7XG5cbiAgICBjb25zdCAkbWluaUNhcnRUb3RhbCA9ICQoJy5zaXRlLWhlYWRlciAubWluaS1jYXJ0LXN1YnRvdGFsJyk7XG4gICAgY29uc3QgJG1pbmlDYXJ0Q29udGVudHMgPSAkKCcubWluaS1jYXJ0LWNvbnRlbnRzJyk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIG1pbmljYXJ0IGl0ZW1zIHdoZW5cbiAgICAvLyBhIHByb2R1Y3QgaXMgYWRkZWQgLyByZW1vdmVkXG4gICAgdXRpbHMuYXBpLmNhcnQuZ2V0Q29udGVudCh7IHRlbXBsYXRlOiAnbWluaS1jYXJ0L21pbmktY2FydC1jb250ZW50cycgfSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICRtaW5pQ2FydENvbnRlbnRzLmh0bWwocmVzcG9uc2UpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGhlYWRlciBzdWJ0b3RhbFxuICAgICAgY29uc3Qgc3VidG90YWwgPSAkKHJlc3BvbnNlKS5maW5kKCdbZGF0YS1jYXJ0LXN1YnRvdGFsXScpLnRleHQoKTtcbiAgICAgIGNvbnN0IHN1YnRvdGFsUmF3ID0gJChyZXNwb25zZSkuZmluZCgnLm1pbmktY2FydC1zdWJ0b3RhbCcpLmF0dHIoJ2RhdGEtY2FydC1zdWJ0b3RhbCcpO1xuICAgICAgJG1pbmlDYXJ0VG90YWwuaHRtbChzdWJ0b3RhbCkuYXR0cignZGF0YS1jYXJ0LXN1YnRvdGFsJywgc3VidG90YWxSYXcpO1xuXG4gICAgICAkbWluaUNhcnQuYW5pbWF0ZSh7XG4gICAgICAgIHRvcDogMFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHByb2R1Y3QgZnJvbSB0aGUgbWluaSBjYXJ0XG4gICAqL1xuICBfcmVtb3ZlUHJvZHVjdE1pbmlDYXJ0KGV2ZW50KSB7XG4gICAgY29uc3QgJGVsID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICBjb25zdCBpdGVtSWQgPSAkZWwuZGF0YSgncHJvZHVjdC1pZCcpO1xuXG4gICAgaWYgKCEgaXRlbUlkKSB7IHJldHVybjsgfVxuXG4gICAgJGVsXG4gICAgICAuY2xvc2VzdCgnLm1pbmktY2FydC1pdGVtJylcbiAgICAgIC5hZGRDbGFzcygncmVtb3ZpbmcnKVxuICAgICAgLmFwcGVuZChgJHtzdmdJY29uKCdzcGlubmVyJyl9YCk7XG5cbiAgICB1dGlscy5hcGkuY2FydC5pdGVtUmVtb3ZlKGl0ZW1JZCwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhLnN0YXR1cyA9PT0gJ3N1Y2NlZWQnKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQocmVzcG9uc2UuZGF0YS5lcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICAkZWxcbiAgICAgICAgICAuY2xvc2VzdCgnLm1pbmktY2FydC1pdGVtJylcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3JlbW92aW5nJylcbiAgICAgICAgICAuZmluZCgnLmljb24tc3Bpbm5lcicpXG4gICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1c3RvbSBzY3JvbGwgYmVoYXZpb3IgZm9yIG1pbmkgY2FydCBwYW5lbFxuICAgKi9cbiAgX2JpbmRTY3JvbGwoKSB7XG4gICAgY29uc3QgJHdpbiA9ICQod2luZG93KTtcbiAgICBjb25zdCAkbWluaUNhcnQgPSAkKCcubWluaS1jYXJ0LWlubmVyJyk7XG4gICAgbGV0IG9sZFNjcm9sbFRvcCA9ICQod2luZG93KS5zY3JvbGxUb3AoKTtcblxuICAgICR3aW4ub24oJ3Njcm9sbCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHdpbkhlaWdodCA9ICR3aW4uaGVpZ2h0KCk7XG4gICAgICBjb25zdCBtaW5pQ2FydEhlaWdodCA9ICRtaW5pQ2FydC5oZWlnaHQoKTtcbiAgICAgIGNvbnN0IG1heFNjcm9sbCA9IG1pbmlDYXJ0SGVpZ2h0IC0gd2luSGVpZ2h0O1xuICAgICAgY29uc3QgbmV3U2Nyb2xsVG9wID0gJHdpbi5zY3JvbGxUb3AoKTtcblxuICAgICAgbGV0IGNhcnRUb3BQb3MgPSBwYXJzZUludCgkbWluaUNhcnQuY3NzKCd0b3AnKSk7XG4gICAgICBsZXQgc2Nyb2xsQW1vdW50O1xuXG4gICAgICAvLyBJZiB0aGUgbWVudSBpcyB0YWxsZXIgdGhhbiB0aGUgd2luZG93IGFuZCB2aXNpYmxlXG4gICAgICBpZiAoIChtaW5pQ2FydEhlaWdodCA+IHdpbkhlaWdodCkgJiYgJCgnYm9keScpLmhhc0NsYXNzKCdtaW5pLWNhcnQtb3BlbicpICkge1xuXG4gICAgICAgIC8vIFNldCB0aGUgYW1vdW50IHdlJ3ZlIHNjcm9sbGVkXG4gICAgICAgIHNjcm9sbEFtb3VudCA9IG9sZFNjcm9sbFRvcCAtIG5ld1Njcm9sbFRvcDtcblxuICAgICAgICAvLyBNb3ZlIHRoZSBtaW5pY2FydCB1cC9kb3duIHRoZSBhbW91bnQgd2Ugc2Nyb2xsZWRcbiAgICAgICAgJG1pbmlDYXJ0LmNzcyh7XG4gICAgICAgICAgdG9wOiAnKz0nICsgc2Nyb2xsQW1vdW50LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBHZXQgdGhlIG1pbmljYXJ0J3MgdG9wIHZhbHVlIGFmdGVyIGl0J3MgdXBkYXRlZFxuICAgICAgICBjYXJ0VG9wUG9zID0gcGFyc2VJbnQoJG1pbmlDYXJ0LmNzcygndG9wJykpO1xuXG4gICAgICAgIC8vIERvbid0IHNjcm9sbCBiZXlvbmQgdGhlIGJvdHRvbSBvciB0b3AgbGltaXRzIG9mIHRoZSBtZW51XG4gICAgICAgIC8vIFRoZSBzZWNvbmQgY29uZGl0b24gY2hlY2tzIGZvciAnb3ZlcnNjcm9sbCcgdGhhdCBvY2N1cnMgaW4gd2Via2l0XG4gICAgICAgIGlmICggKGNhcnRUb3BQb3MgPCAtbWF4U2Nyb2xsKSB8fCAoKG5ld1Njcm9sbFRvcCArIHdpbkhlaWdodCkgPj0gJCgnLnNpdGUtd3JhcHBlcicpLm91dGVySGVpZ2h0KCkpICkge1xuICAgICAgICAgIC8vIHN0b3AgYXQgYm90dG9tIG9mIG1pbmljYXJ0XG4gICAgICAgICAgJG1pbmlDYXJ0LmNzcyh7XG4gICAgICAgICAgICB0b3A6IC1tYXhTY3JvbGwgKyAncHgnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIGNhcnRUb3BQb3MgPiAwIHx8IG5ld1Njcm9sbFRvcCA8PSAwICkge1xuICAgICAgICAgIC8vIHN0b3AgYXQgdG9wIG9mIG1pbmljYXJ0XG4gICAgICAgICAgJG1pbmlDYXJ0LmNzcyh7XG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgb2xkU2Nyb2xsVG9wIGFzIHdlIHNjcm9sbFxuICAgICAgb2xkU2Nyb2xsVG9wID0gbmV3U2Nyb2xsVG9wO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9iaWxlTmF2IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuJGJvZHkgPSAkKCdib2R5Jyk7XHJcbiAgICB0aGlzLm5hdlRvZ2dsZSA9ICQoJy5idXR0b24tbW9iaWxlLW5hdi10b2dnbGUnKTtcclxuICAgIHRoaXMucGFnZUNvdmVyID0gJCgnLnNpdGUtd3JhcHBlcicpO1xyXG4gICAgdGhpcy4kbWVudSA9ICQoJy5uYXZpZ2F0aW9uJyk7XHJcbiAgICB0aGlzLiRuYXZCYWNrQnV0dG9uID0gJCgnLmJ1dHRvbi1tb2JpbGUtbmF2LWJhY2snKTtcclxuICAgIHRoaXMuZ2V0TWVudXMgPSAodGFyZ2V0TWVudSkgPT4ge1xyXG4gICAgICByZXR1cm4gJChgW2RhdGEtbW9iaWxlLW1lbnU9XCIke3RhcmdldE1lbnV9XCJdYCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMubmF2UGFuZWwgPSAnLm5hdi1tb2JpbGUtcGFuZWwnO1xyXG4gICAgdGhpcy5jbGFzc2VzID0ge1xyXG4gICAgICBhY3RpdmU6ICdpcy1hY3RpdmUnLFxyXG4gICAgICBsZWZ0OiAnaXMtbGVmdCcsXHJcbiAgICAgIHJpZ2h0OiAnaXMtcmlnaHQnLFxyXG4gICAgICBmb3JjZVN0YXRlOiAnZm9yY2Utc3RhdGUnLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm1lbnVTdGF0ZSA9IFtdO1xyXG5cclxuICAgIHRoaXMuX2luaXRNb2JpbGUoKTtcclxuICAgIHRoaXMuX2JpbmRNb2JpbGVFdmVudHMoKTtcclxuICB9XHJcblxyXG4gIF9pbml0TW9iaWxlKCkge1xyXG4gICAgJCgnLm5hdi1tb2JpbGUtaXRlbS1wYXJlbnQnKS5lYWNoKChpbmRleCwgZWxlbWVudCkgPT4ge1xyXG4gICAgICBsZXQgJGNoaWxkcmVuID0gJChlbGVtZW50KS5jaGlsZHJlbignLm5hdi1tb2JpbGUtcGFuZWwnKTtcclxuICAgICAgbGV0IGNvdW50ZXIgPSAxO1xyXG5cclxuICAgICAgd2hpbGUgKCRjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAkY2hpbGRyZW4uYXR0cignZGF0YS1wYW5lbC1kZXB0aCcsIGNvdW50ZXIpLmluc2VydEFmdGVyKCQoJy5uYXYtbW9iaWxlLXBhbmVsLXBhcmVudCcpKTtcclxuICAgICAgICAkY2hpbGRyZW4gPSAkY2hpbGRyZW4uY2hpbGRyZW4oKS5jaGlsZHJlbignLm5hdi1tb2JpbGUtcGFuZWwnKTtcclxuICAgICAgICBjb3VudGVyICs9IDE7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2JpbmRNb2JpbGVFdmVudHMoKSB7XHJcbiAgICAkKCcubmF2LW1vYmlsZS1pdGVtLmhhcy1jaGlsZHJlbicpLm9uKCdjbGljaycsIChldmVudCkgPT4ge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB0aGlzLl90cmF2ZXJzZURvd24oZXZlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy4kbmF2QmFja0J1dHRvbi5vbignY2xpY2snLCAoZXZlbnQpID0+IHtcclxuICAgICAgdGhpcy5fdHJhdmVyc2VCYWNrKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF90cmF2ZXJzZURvd24oZXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldE1lbnUgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmNoaWxkcmVuKCkuZGF0YSgndG9nZ2xlLW1vYmlsZScpO1xyXG4gICAgdGhpcy4kYm9keS5hZGRDbGFzcygnbW9iaWxlLW5hdi1vcGVuJyk7XHJcblxyXG4gICAgLy8gTW92ZSBwcmV2aW91cyBhY3RpdmUgdG8gdGhlIGxlZnRcclxuICAgICQoZXZlbnQuY3VycmVudFRhcmdldClcclxuICAgICAgLmNsb3Nlc3QodGhpcy5uYXZQYW5lbClcclxuICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5sZWZ0KVxyXG4gICAgICAucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmFjdGl2ZSk7XHJcblxyXG4gICAgLy8gQWN0aXZlIG5ldyBtZW51IGFuZCBtb3ZlIGludG8gcGxhY2UgZnJvbSByaWdodFxyXG4gICAgdGhpcy5nZXRNZW51cyh0YXJnZXRNZW51KVxyXG4gICAgICAucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLnJpZ2h0KVxyXG4gICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmFjdGl2ZSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBiYWNrIGJ1dHRvbiBpZFxyXG4gICAgY29uc3QgcHJldk1lbnUgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLnBhcmVudHMoJy5uYXYtbW9iaWxlLXBhbmVsJykuZGF0YSgnbW9iaWxlLW1lbnUnKTtcclxuICAgIHRoaXMubWVudVN0YXRlLnB1c2gocHJldk1lbnUpO1xyXG5cclxuICB9XHJcblxyXG4gIF90cmF2ZXJzZUJhY2soKSB7XHJcbiAgICAvLyBNb3ZlIHByZXZpb3VzIGFjdGl2ZSB0byB0aGUgcmlnaHRcclxuICAgICQodGhpcy5uYXZQYW5lbClcclxuICAgICAgLmZpbHRlcihgLiR7dGhpcy5jbGFzc2VzLmFjdGl2ZX1gKVxyXG4gICAgICAucmVtb3ZlQ2xhc3ModGhpcy5jbGFzc2VzLmFjdGl2ZSlcclxuICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5yaWdodCk7XHJcblxyXG4gICAgLy8gUG9zaXRpb24gbmV3IGFjdGl2ZSBtZW51IGZyb20gdGhlIGxlZnRcclxuICAgIGNvbnN0IHRhcmdldE1lbnUgPSB0aGlzLm1lbnVTdGF0ZS5wb3AoKTtcclxuXHJcbiAgICB0aGlzLmdldE1lbnVzKHRhcmdldE1lbnUpXHJcbiAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMubGVmdClcclxuICAgICAgLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5hY3RpdmUpO1xyXG5cclxuICAgIGlmICh0YXJnZXRNZW51ID09PSAnYWxsJykge1xyXG4gICAgICB0aGlzLiRib2R5LnJlbW92ZUNsYXNzKCdtb2JpbGUtbmF2LW9wZW4nKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICAkKCcucHJvZHVjdC1pdGVtLXJhdGluZy1mYWNldC5mdWxsJylcbiAgICAucHJldkFsbCgnLnByb2R1Y3QtaXRlbS1yYXRpbmctZmFjZXQnKVxuICAgIC5hZGRDbGFzcygnZnVsbCcpO1xufVxuIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBQcm9kdWN0Q29tcGFyZSBmcm9tICdiYy1jb21wYXJlJztcbmltcG9ydCBzdmdJY29uIGZyb20gJy4vc3ZnSWNvbic7XG5cbmNvbnN0IGNvbXBhcmUgPSBuZXcgUHJvZHVjdENvbXBhcmUoe1xuICBtYXhJdGVtczogNCxcbiAgaXRlbVRlbXBsYXRlOiBfLnRlbXBsYXRlKGBcbiAgICA8bGkgY2xhc3M9XCJjb21wYXJlLXRhYi1pdGVtXCIgZGF0YS1jb21wYXJlLWl0ZW0+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29tcGFyZS10YWItaXRlbS13cmFwXCI+XG4gICAgICAgIDxhIGNsYXNzPVwiY29tcGFyZS10YWItaXRlbS1yZW1vdmVcIiBkYXRhLWNvbXBhcmUtaXRlbS1yZW1vdmU9XCI8JT0gaWQgJT5cIj4ke3N2Z0ljb24oJ2Nsb3NlJyl9PC9hPlxuICAgICAgICA8YSBocmVmPVwiPCU9IHVybCAlPlwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb21wYXJlLXRhYi1pdGVtLXRodW1iXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoPCU9IHRodW1ibmFpbCAlPilcIj48L2Rpdj5cbiAgICAgICAgPC9hPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb21wYXJlLXRhYi1pdGVtLWRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgPGEgaHJlZj1cIjwlPSB1cmwgJT5cIiBjbGFzcz1cImNvbXBhcmUtdGFiLWl0ZW0tdGl0bGVcIj48JT0gdGl0bGUgJT48L2E+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbXBhcmUtdGFiLWl0ZW0tcHJpY2VcIj48JT0gcHJpY2UgJT48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2xpPlxuICBgKSxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdENvbXBhcmUoKSB7XG4gIGNvbXBhcmUub24oJ3VwZGF0ZWQnLCAoKSA9PiB7XG4gICAgJCgnLmNvbXBhcmUtaXRlbXMtY291bnQnKS50ZXh0KGNvbXBhcmUuY29tcGFyZUxpc3Quc2l6ZSk7XG5cbiAgICBpZiAoY29tcGFyZS5jb21wYXJlTGlzdC5zaXplID4gMCkge1xuICAgICAgJCgnW2RhdGEtY29tcGFyZS13aWRnZXRdLCAubW9iaWxlLWNvbXBhcmUtbGluaycpLmFkZENsYXNzKCdjb21wYXJlLWFjdGl2ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKCdbZGF0YS1jb21wYXJlLXdpZGdldF0sIC5tb2JpbGUtY29tcGFyZS1saW5rJykucmVtb3ZlQ2xhc3MoJ2NvbXBhcmUtYWN0aXZlJyk7XG4gICAgfVxuICB9LCB0cnVlKTtcblxuICAkKCdbZGF0YS1jb21wYXJlLXJlbW92ZS1hbGxdJykub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb21wYXJlLnJlbW92ZUFsbCgpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNvbXBhcmUoKSB7XG4gIGNvbXBhcmUudXBkYXRlQ2hlY2tib3hlcygpO1xufVxuIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHV0aWxzIGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcclxuXHJcbmNsYXNzIFF1aWNrU2VhcmNoIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZGVib3VuY2VXYWl0VGltZSA9IDMwMDsgLy8gQWRqdXN0IGRlYm91bmNlIHRpbWUgYXMgbmVlZGVkXHJcbiAgICAgICAgdGhpcy4kcXVpY2tTZWFyY2hSZXN1bHRzID0gJCgnLnF1aWNrU2VhcmNoUmVzdWx0cycpO1xyXG4gICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoRm9ybXMgPSAkKCdbZGF0YS1xdWljay1zZWFyY2gtZm9ybV0nKTtcclxuICAgICAgICB0aGlzLiRzZWFyY2hRdWVyeSA9IHRoaXMuJHF1aWNrU2VhcmNoRm9ybXMuZmluZCgnW2RhdGEtc2VhcmNoLXF1aWNrXScpO1xyXG4gICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoQXJpYU1lc3NhZ2UgPSAkKCcuYXJpYS1kZXNjcmlwdGlvbi0taGlkZGVuJyk7XHJcbiAgICAgICAgdGhpcy5zZWFyY2hSZXN1bHRzVmlzaWJsZSA9IGZhbHNlOyAvLyBUcmFjayBpZiBzZWFyY2ggcmVzdWx0cyBhcmUgdmlzaWJsZVxyXG5cclxuICAgICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2JpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgY29uc3QgZG9TZWFyY2ggPSBfLmRlYm91bmNlKChzZWFyY2hRdWVyeSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2VhcmNoUXVlcnkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRxdWlja1NlYXJjaFJlc3VsdHMuZW1wdHkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoQXJpYU1lc3NhZ2UuZW1wdHkoKTsgLy8gQ2xlYXIgYXJpYS1saXZlIHJlZ2lvblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hSZXN1bHRzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1dGlscy5hcGkuc2VhcmNoLnNlYXJjaChzZWFyY2hRdWVyeSwgeyB0ZW1wbGF0ZTogJ3NlYXJjaC9xdWljay1yZXN1bHRzJyB9LCAoZXJyLCByZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLiRxdWlja1NlYXJjaFJlc3VsdHMuaHRtbChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkcXVpY2tTZWFyY2hSZXN1bHRzQ3VycmVudCA9IHRoaXMuJHF1aWNrU2VhcmNoUmVzdWx0cy5maWx0ZXIoJzp2aXNpYmxlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgJG5vUmVzdWx0c01lc3NhZ2UgPSAkcXVpY2tTZWFyY2hSZXN1bHRzQ3VycmVudC5maW5kKCcucXVpY2tTZWFyY2hNZXNzYWdlJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoJG5vUmVzdWx0c01lc3NhZ2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJG5vUmVzdWx0c01lc3NhZ2UuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICdzdGF0dXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcXVpY2tTZWFyY2hBcmlhTWVzc2FnZS5lbXB0eSgpOyAvLyBDbGVhciBhcmlhLWxpdmUgcmVnaW9uXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoQXJpYU1lc3NhZ2UuYWRkQ2xhc3MoJ3UtaGlkZGVuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWRlZmluZWRUZXh0ID0gdGhpcy4kcXVpY2tTZWFyY2hBcmlhTWVzc2FnZS5kYXRhKCdzZWFyY2gtYXJpYS1tZXNzYWdlLXByZWRlZmluZWQtdGV4dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zRm91bmRDb3VudCA9ICRxdWlja1NlYXJjaFJlc3VsdHNDdXJyZW50LmZpbmQoJy5wcm9kdWN0JykubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRxdWlja1NlYXJjaEFyaWFNZXNzYWdlLnRleHQoYCR7aXRlbXNGb3VuZENvdW50fSAke3ByZWRlZmluZWRUZXh0fSAke3NlYXJjaFF1ZXJ5fWApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kcXVpY2tTZWFyY2hBcmlhTWVzc2FnZS5yZW1vdmVDbGFzcygndS1oaWRkZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hSZXN1bHRzVmlzaWJsZSA9IHRydWU7IC8vIE1hcmsgc2VhcmNoIHJlc3VsdHMgYXMgdmlzaWJsZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCB0aGlzLmRlYm91bmNlV2FpdFRpbWUpO1xyXG5cclxuICAgICAgICB0aGlzLiRzZWFyY2hRdWVyeS5vbignaW5wdXQnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VhcmNoUXVlcnkgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLnZhbCgpO1xyXG4gICAgICAgICAgICBpZiAoc2VhcmNoUXVlcnkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRxdWlja1NlYXJjaFJlc3VsdHMuZW1wdHkoKTsgLy8gSGlkZSByZXN1bHRzIGlmIGlucHV0IGlzIGNsZWFyZWRcclxuICAgICAgICAgICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoQXJpYU1lc3NhZ2UuZW1wdHkoKTsgLy8gQ2xlYXIgYXJpYS1saXZlIHJlZ2lvblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hSZXN1bHRzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkudHJpZ2dlcignc2VhcmNoLXF1aWNrJywgZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHV0aWxzLmhvb2tzLm9uKCdzZWFyY2gtcXVpY2snLCAoZXZlbnQsIGN1cnJlbnRUYXJnZXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VhcmNoUXVlcnkgPSAkKGN1cnJlbnRUYXJnZXQpLnZhbCgpO1xyXG4gICAgICAgICAgICBkb1NlYXJjaChzZWFyY2hRdWVyeSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEhpZGUgc2VhcmNoIHJlc3VsdHMgd2hlbiBjbGlja2luZyBvdXRzaWRlXHJcbiAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghJChldmVudC50YXJnZXQpLmNsb3Nlc3QodGhpcy4kcXVpY2tTZWFyY2hGb3JtcykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRxdWlja1NlYXJjaFJlc3VsdHMuZW1wdHkoKTsgLy8gSGlkZSByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdHNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU2hvdyBzZWFyY2ggcmVzdWx0cyB3aGVuIGZvY3VzaW5nIG9uIHRoZSBzZWFyY2ggYmFyXHJcbiAgICAgICAgdGhpcy4kc2VhcmNoUXVlcnkub24oJ2ZvY3VzJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlYXJjaFJlc3VsdHNWaXNpYmxlICYmIHRoaXMuJHNlYXJjaFF1ZXJ5LnZhbCgpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaFF1ZXJ5ID0gdGhpcy4kc2VhcmNoUXVlcnkudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBkb1NlYXJjaChzZWFyY2hRdWVyeSk7IC8vIFJlLWZldGNoIHRoZSByZXN1bHRzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUXVpY2tTZWFyY2g7XHJcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChpY29uQ2xhc3MpIHtcbiAgcmV0dXJuIGA8c3ZnIGNsYXNzPVwiaWNvbiBpY29uLSR7aWNvbkNsYXNzfVwiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uLSR7aWNvbkNsYXNzfVwiIC8+PC9zdmc+YFxufTtcbiIsImltcG9ydCBzdmdJY29uIGZyb20gJy4vc3ZnSWNvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgY29uc3QgJHRyaWdnZXIgPSAkdGFyZ2V0LmZpbmQoJy5mYWNldC1saXN0LXRvZ2dsZScpO1xuXG4gICR0YXJnZXRcbiAgICAucGFyZW50cygnW2RhdGEtZmFjZXQtZmlsdGVyXScpXG4gICAgLmNoaWxkcmVuKCdbZGF0YS1mYWNldC1maWx0ZXItd3JhcHBlcl0nKVxuICAgIC50b2dnbGVDbGFzcygnaXMtb3BlbicpO1xuXG4gIGlmICgkdGFyZ2V0Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcbiAgICAkdHJpZ2dlci5odG1sKHN2Z0ljb24oJ21pbnVzJykpO1xuICB9IGVsc2Uge1xuICAgICR0cmlnZ2VyLmh0bWwoc3ZnSWNvbigncGx1cycpKTtcbiAgfVxuXG4gICR0YXJnZXQudG9nZ2xlQ2xhc3MoJ2lzLW9wZW4nKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dHJpYnV0ZXNIZWxwZXIge1xuICBjb25zdHJ1Y3RvcihlbCkge1xuICAgIHRoaXMuZWwgPSBlbDtcbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZXMoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBiZWhhdmlvciA9IGRhdGEub3V0X29mX3N0b2NrX2JlaGF2aW9yO1xuICAgIGNvbnN0IGluU3RvY2tJZHMgPSBkYXRhLmluX3N0b2NrX2F0dHJpYnV0ZXM7XG4gICAgY29uc3Qgb3V0T2ZTdG9ja01lc3NhZ2UgPSBgICgke2RhdGEub3V0X29mX3N0b2NrX21lc3NhZ2V9KWA7XG5cbiAgICBpZiAoYmVoYXZpb3IgIT09ICdoaWRlX29wdGlvbicgJiYgYmVoYXZpb3IgIT09ICdsYWJlbF9vcHRpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJCgnW2RhdGEtcHJvZHVjdC1hdHRyaWJ1dGUtdmFsdWVdJywgJCgnYm9keScpLmZpbmQodGhpcy5lbCkpLmVhY2goKGksIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgY29uc3QgJGF0dHJpYnV0ZSA9ICQoYXR0cmlidXRlKTtcbiAgICAgIGNvbnN0IGF0dHJJZCA9IHBhcnNlSW50KCRhdHRyaWJ1dGUuZGF0YSgncHJvZHVjdC1hdHRyaWJ1dGUtdmFsdWUnKSwgMTApO1xuXG4gICAgICBpZiAoaW5TdG9ja0lkcy5pbmRleE9mKGF0dHJJZCkgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlQXR0cmlidXRlKCRhdHRyaWJ1dGUsIGJlaGF2aW9yLCBvdXRPZlN0b2NrTWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc2FibGVBdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRpc2FibGVBdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlVHlwZSgkYXR0cmlidXRlKSA9PT0gJ3NldC1zZWxlY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXNhYmxlU2VsZWN0T3B0aW9uQXR0cmlidXRlKCRhdHRyaWJ1dGUsIGJlaGF2aW9yLCBvdXRPZlN0b2NrTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgaWYgKGJlaGF2aW9yID09PSAnaGlkZV9vcHRpb24nKSB7XG4gICAgICAkYXR0cmlidXRlLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGF0dHJpYnV0ZS5hZGRDbGFzcygnb3B0aW9uLXVuYXZhaWxhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZVNlbGVjdE9wdGlvbkF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpIHtcbiAgICBpZiAoYmVoYXZpb3IgPT09ICdoaWRlX29wdGlvbicpIHtcbiAgICAgICRhdHRyaWJ1dGUudG9nZ2xlT3B0aW9uKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGF0dHJpYnV0ZS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgJGF0dHJpYnV0ZS5odG1sKCRhdHRyaWJ1dGUuaHRtbCgpLnJlcGxhY2Uob3V0T2ZTdG9ja01lc3NhZ2UsICcnKSArIG91dE9mU3RvY2tNZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBlbmFibGVBdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlVHlwZSgkYXR0cmlidXRlKSA9PT0gJ3NldC1zZWxlY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmFibGVTZWxlY3RPcHRpb25BdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKGJlaGF2aW9yID09PSAnaGlkZV9vcHRpb24nKSB7XG4gICAgICAkYXR0cmlidXRlLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGF0dHJpYnV0ZS5yZW1vdmVDbGFzcygnb3B0aW9uLXVuYXZhaWxhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgZW5hYmxlU2VsZWN0T3B0aW9uQXR0cmlidXRlKCRhdHRyaWJ1dGUsIGJlaGF2aW9yLCBvdXRPZlN0b2NrTWVzc2FnZSkge1xuICAgIGlmIChiZWhhdmlvciA9PT0gJ2hpZGVfb3B0aW9uJykge1xuICAgICAgJGF0dHJpYnV0ZS50b2dnbGVPcHRpb24odHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRhdHRyaWJ1dGUucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICRhdHRyaWJ1dGUuaHRtbCgkYXR0cmlidXRlLmh0bWwoKS5yZXBsYWNlKG91dE9mU3RvY2tNZXNzYWdlLCAnJykpO1xuICAgIH1cbiAgfVxuXG4gIGdldEF0dHJpYnV0ZVR5cGUoJGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0ICRwYXJlbnQgPSAkYXR0cmlidXRlLmNsb3Nlc3QoJ1tkYXRhLXByb2R1Y3QtYXR0cmlidXRlXScpO1xuICAgIHJldHVybiAkcGFyZW50ID8gJHBhcmVudC5kYXRhKCdwcm9kdWN0LWF0dHJpYnV0ZScpIDogbnVsbDtcbiAgfVxufVxuXG4iLCIvKipcbiAqICBBdHRhY2ggZnVuY3Rpb25hbGl0eSB0byBDb2xvciBTd2F0Y2hlc1xuICpcbiAqIEV4YW1wbGU6IG5ldyBDb2xvclN3YXRjaCgnLmNvbG9yLXN3YXRjaC1pdGVtJylcbiAqICAgICAgICAgIChkZWZhdWx0cyB0byBbZGF0YS1zd2F0Y2gtc2VsZWN0b3JdKVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvclN3YXRjaCB7XG4gIGNvbnN0cnVjdG9yKGVsID0gYFtkYXRhLXN3YXRjaC1zZWxlY3Rvcl1gKSB7XG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcblxuICAgIHRoaXMuYmluZFN3YXRjaEV2ZW50KCk7XG4gICAgdGhpcy4kZWwuZmluZCgnW2RhdGEtZGVmYXVsdF0nKS5jbGljaygpO1xuICB9XG5cbiAgLy8gVXBkYXRlIFN3YXRjaCB0ZXh0IHdoZW4gY29sb3IgaXMgc2VsZWN0ZWRcbiAgYmluZFN3YXRjaEV2ZW50KCkge1xuXG4gICAgdGhpcy4kZWwub24oJ2NsaWNrJywgJ2xhYmVsJywgKGUpID0+IHtcbiAgICAgIGNvbnN0ICR0YXJnZXQgPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgICBjb25zdCAkc3dhdGNoVGV4dCA9ICR0YXJnZXQuY2xvc2VzdCgnW2RhdGEtc3dhdGNoLXNlbGVjdG9yXScpLmZpbmQoJy5zd2F0Y2gtdmFsdWUnKTtcbiAgICAgIGNvbnN0ICRzd2F0Y2hWYWx1ZSA9ICR0YXJnZXQuZGF0YSgnc3dhdGNoLXZhbHVlJyk7XG5cbiAgICAgICRzd2F0Y2hUZXh0LnRleHQoJHN3YXRjaFZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZVpvb20ge1xuICBjb25zdHJ1Y3RvcihlbCkge1xuICAgIHRoaXMuJGVsID0gJChlbCk7XG5cbiAgICAvLyBjcmVhdGUgZW1wdHkgaW1hZ2VcbiAgICBjb25zdCBkZWZhdWx0SW1nID0gbmV3IEltYWdlKCk7XG4gICAgLy8gc2V0IHNyYyBzbyB3ZSBjYW4gYWNjZXNzIHRoZSBvdGhlciBhdHRyaWJ1dGUgZGF0YVxuICAgIGRlZmF1bHRJbWcuc3JjID0gdGhpcy4kZWwuZmluZCgnaW1nJykuYXR0cignc3JjJyk7XG5cbiAgICB0aGlzLmltYWdlID0ge1xuICAgICAgb2Zmc2V0OiB0aGlzLiRlbC5vZmZzZXQoKSxcbiAgICAgIHdpZHRoOiB0aGlzLiRlbC53aWR0aCgpLFxuICAgICAgaGVpZ2h0OiB0aGlzLiRlbC5oZWlnaHQoKSxcbiAgICB9XG5cbiAgICAvLyBPbmx5IGluaXQgaWYgaW1hZ2UgaXMgd2lkZSBlbm91Z2ggdG8gem9vbVxuICAgIGlmICgoZGVmYXVsdEltZy53aWR0aCAvIHRoaXMuaW1hZ2Uud2lkdGgpID4gMS40KSB7XG4gICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCduby16b29tJykuaGVpZ2h0KHRoaXMuJGVsLnBhcmVudCgpLmhlaWdodCgpKTtcbiAgICB9XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRlbC5vbignbW91c2Vtb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl96b29tSW1hZ2UoZXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgX3pvb21JbWFnZShldmVudCkge1xuICAgIGNvbnN0ICR3cmFwcGVyID0gJCgnLnByb2R1Y3Qtc2xpZGVzLXdyYXAnKS5vZmZzZXQoKVxuICAgIGNvbnN0IHRvcE9mZnNldCA9ICR3cmFwcGVyLnRvcFxuICAgIGNvbnN0IGxlZnRPZmZzZXQgPSAkd3JhcHBlci5sZWZ0XG5cbiAgICBjb25zdCB0b3AgPSAoZXZlbnQucGFnZVkgLSB0b3BPZmZzZXQpIC8gdGhpcy5pbWFnZS5oZWlnaHQgKiAxMDA7XG4gICAgY29uc3QgbGVmdCA9IChldmVudC5wYWdlWCAtIGxlZnRPZmZzZXQpIC8gdGhpcy5pbWFnZS53aWR0aCAqIDEwMDtcblxuICAgIHRoaXMuJGVsLmNzcygnYmFja2dyb3VuZC1wb3NpdGlvbicsIGAke2xlZnR9JSAke3RvcH0lYClcbiAgfVxufVxuIiwiaW1wb3J0IHNsaWNrIGZyb20gJ3NsaWNrLWNhcm91c2VsJztcbmltcG9ydCBpbWFnZXNMb2FkZWQgZnJvbSAnaW1hZ2VzbG9hZGVkJztcbmltcG9ydCBJbWFnZVpvb20gZnJvbSAnLi9JbWFnZVpvb20nO1xuaW1wb3J0IGJhZ3VldHRlQm94IGZyb20gJ2JhZ3VldHRlYm94LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZHVjdEltYWdlcyB7XG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcbiAgICB0aGlzLm1heFNsaWRlc0JlZm9yZUFycm93cyA9IDU7XG5cbiAgICB0aGlzLmNsYXNzZXMgPSB7XG4gICAgICBjb250YWluZXI6ICcucHJvZHVjdC1pbWFnZXMtY29udGFpbmVyJyxcbiAgICAgIHNsaWRlc1dyYXA6ICcucHJvZHVjdC1zbGlkZXMtd3JhcCcsXG4gICAgICBwYWdpbmF0aW9uOiAnLnByb2R1Y3QtaW1hZ2VzLXBhZ2luYXRpb24nLFxuICAgICAgcGFnaW5hdGlvbkl0ZW06ICcucGFnaW5hdGlvbi1pdGVtJyxcbiAgICAgIGxvYWRlcjogJy5wcm9kdWN0LWltYWdlcy1sb2FkZXInLFxuICAgIH07XG5cbiAgICB0aGlzLiRwYWdpbmF0aW9uID0gdGhpcy4kZWxcbiAgICAgIC5jbG9zZXN0KHRoaXMuY2xhc3Nlcy5jb250YWluZXIpXG4gICAgICAuZmluZCh0aGlzLmNsYXNzZXMucGFnaW5hdGlvbik7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cblxuICBfaW5pdCgpIHtcbiAgICBpbWFnZXNMb2FkZWQodGhpcy4kZWxbMF0sICgpID0+IHtcbiAgICAgIC8vIEhpZGUgbG9hZGVyXG4gICAgICB0aGlzLiRlbFxuICAgICAgICAucGFyZW50cyh0aGlzLmNsYXNzZXMuY29udGFpbmVyKVxuICAgICAgICAuZmluZCh0aGlzLmNsYXNzZXMubG9hZGVyKVxuICAgICAgICAuYWRkQ2xhc3MoJ2luaXRpYWxpemVkJyk7XG5cbiAgICAgIC8vIEltYWdlIHpvb21cbiAgICAgIHRoaXMuJGVsLm9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbC5maW5kKCdbZGF0YS1wcm9kdWN0LWltYWdlXScpLmVhY2goKGksIGVsKSA9PiB7XG4gICAgICAgICAgbmV3IEltYWdlWm9vbShlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEluaXQgY2Fyb3VzZWxcbiAgICAgIHRoaXMuJGVsLnNsaWNrKHtcbiAgICAgICAgaW5maW5pdGU6IGZhbHNlLFxuICAgICAgICBhcnJvd3M6IGZhbHNlLFxuICAgICAgICBkb3RzOiBmYWxzZSxcbiAgICAgICAgYWRhcHRpdmVIZWlnaHQ6IHRydWUsXG4gICAgICAgIGFzTmF2Rm9yOiB0aGlzLmNsYXNzZXMucGFnaW5hdGlvbixcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmltYWdlQ291bnQgPSB0aGlzLiRwYWdpbmF0aW9uXG4gICAgICAgIC5maW5kKHRoaXMuY2xhc3Nlcy5wYWdpbmF0aW9uSXRlbSlcbiAgICAgICAgLmxlbmd0aDtcblxuICAgICAgaWYgKHRoaXMuaW1hZ2VDb3VudCA+IHRoaXMubWF4U2xpZGVzQmVmb3JlQXJyb3dzKSB7XG4gICAgICAgIHRoaXMuJHBhZ2luYXRpb24uYWRkQ2xhc3MoJ3BhZ2luYXRpb24taGFzLWFycm93cycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRwYWdpbmF0aW9uLm9uKCdzZXRQb3NpdGlvbicsIChldmVudCwgc2xpY2spID0+IHtcbiAgICAgICAgaWYgKHNsaWNrLiRzbGlkZXMubGVuZ3RoID4gdGhpcy5tYXhTbGlkZXNCZWZvcmVBcnJvd3MpIHtcbiAgICAgICAgICB0aGlzLiRwYWdpbmF0aW9uLmFkZENsYXNzKCdwYWdpbmF0aW9uLWhhcy1hcnJvd3MnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRwYWdpbmF0aW9uLnJlbW92ZUNsYXNzKCdwYWdpbmF0aW9uLWhhcy1hcnJvd3MnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJHBhZ2luYXRpb25cbiAgICAgICAgLnNsaWNrKHtcbiAgICAgICAgICBpbmZpbml0ZTogZmFsc2UsXG4gICAgICAgICAgY2VudGVyTW9kZTogZmFsc2UsXG4gICAgICAgICAgZG90czogZmFsc2UsXG4gICAgICAgICAgbGF6eUxvYWQ6ICdwcm9ncmVzc2l2ZScsXG4gICAgICAgICAgYXJyb3dzOiB0cnVlLFxuICAgICAgICAgIHByZXZBcnJvdzogJzxkaXYgY2xhc3M9XCJwcm9kdWN0LWltYWdlcy1wYWdpbmF0aW9uLWljb24gcGFnaW5hdGlvbi1wcmV2XCI+PHN2Zz48dXNlIHhsaW5rOmhyZWY9XCIjaWNvbi1hcnJvdy1sZWZ0XCIgLz48L3N2Zz48L2Rpdj4nLFxuICAgICAgICAgIG5leHRBcnJvdzogJzxkaXYgY2xhc3M9XCJwcm9kdWN0LWltYWdlcy1wYWdpbmF0aW9uLWljb24gcGFnaW5hdGlvbi1uZXh0XCI+PHN2Zz48dXNlIHhsaW5rOmhyZWY9XCIjaWNvbi1hcnJvdy1yaWdodFwiIC8+PC9zdmc+PC9kaXY+JyxcbiAgICAgICAgICBzbGlkZXNUb1Nob3c6IDUsXG4gICAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gICAgICAgICAgdmFyaWFibGVXaWR0aDogZmFsc2UsXG4gICAgICAgICAgcm93czogMCxcbiAgICAgICAgICBhc05hdkZvcjogdGhpcy5jbGFzc2VzLnNsaWRlc1dyYXAsXG4gICAgICAgICAgZm9jdXNPblNlbGVjdDogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgIGJhZ3VldHRlQm94LnJ1bih0aGlzLmNsYXNzZXMuc2xpZGVzV3JhcCwge30pO1xuICAgIH0pO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9kdWN0UmV2aWV3cyB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgdGhpcy5fYmluZFJhdGluZygpO1xuICB9XG5cbiAgX2JpbmRSYXRpbmcoKSB7XG4gICAgJCgnI3JhdGluZy1zdGFycycpLm9uKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHJhdGluZyA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkudmFsKCk7XG4gICAgICBjb25zdCByYXRpbmdMYWJlbCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZmluZCgnb3B0aW9uOnNlbGVjdGVkJykudGV4dCgpO1xuXG4gICAgICAkKCcucmV2aWV3LWZvcm0nKVxuICAgICAgICAuZmluZCgnLmljb24tc3Rhci13cmFwJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdmdWxsJylcbiAgICAgICAgLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICAgIGlmICgoaW5kZXggKyAxKSA8PSByYXRpbmcpIHtcbiAgICAgICAgICAgICQoZWwpLmFkZENsYXNzKCdmdWxsJyk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgICQoJy5yZXZpZXctZm9ybScpXG4gICAgICAgIC5maW5kKCcucmF0aW5nLXN0YXJzLWxhYmVsJylcbiAgICAgICAgLmh0bWwocmF0aW5nTGFiZWwpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xyXG5pbXBvcnQgQWxlcnQgZnJvbSAnLi4vY29tcG9uZW50cy9BbGVydCc7XHJcbmltcG9ydCBGb3JtVmFsaWRhdG9yIGZyb20gJy4uL3V0aWxzL0Zvcm1WYWxpZGF0b3InO1xyXG5pbXBvcnQgUHJvZ3Jlc3NCdXR0b24gZnJvbSAnLi4vdXRpbHMvUHJvZ3Jlc3NCdXR0b24nO1xyXG5pbXBvcnQgcmVzZXRQcm9kdWN0SW1hZ2VzIGZyb20gJy4vcmVzZXRQcm9kdWN0SW1hZ2VzJztcclxuaW1wb3J0IEF0dHJpYnV0ZXNIZWxwZXIgZnJvbSAnLi9BdHRyaWJ1dGVzSGVscGVyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2R1Y3RVdGlscyB7XHJcbiAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMuJGVsID0gJChlbCk7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7XHJcbiAgICAgIG9uSW1hZ2VTd2l0Y2g6ICgpID0+IHt9LFxyXG4gICAgfSwgb3B0aW9ucyk7XHJcbiAgICB0aGlzLnByb2R1Y3RJZCA9IHRoaXMuJGVsLmZpbmQoJ1tkYXRhLXByb2R1Y3QtaWRdJykudmFsKCk7XHJcblxyXG4gICAgdGhpcy5wYWdlQWxlcnRzID0gbmV3IEFsZXJ0KCQoJ1tkYXRhLWFsZXJ0c10nKSk7XHJcbiAgICB0aGlzLnByb2R1Y3RBbGVydHMgPSBuZXcgQWxlcnQoJCgnW2RhdGEtcHJvZHVjdC1hbGVydHNdJykpO1xyXG4gICAgdGhpcy5wcm9kdWN0VGl0bGUgPSAkKGVsKS5kYXRhKCdwcm9kdWN0LXRpdGxlJyk7XHJcbiAgICB0aGlzLiRwcm9kdWN0Q29udGFpbmVyID0gJCgnW2RhdGEtcHJvZHVjdC1jb250YWluZXJdJyk7XHJcbiAgICB0aGlzLnByb2R1Y3RBdHRyaWJ1dGVzRGF0YSA9IHdpbmRvdy5CQ0RhdGEucHJvZHVjdF9hdHRyaWJ1dGVzO1xyXG4gICAgdGhpcy4kZm9ybSA9IHRoaXMuJGVsLmZpbmQoJ2Zvcm1bZGF0YS1jYXJ0LWl0ZW0tYWRkXScpO1xyXG4gICAgdGhpcy4kYWRkVG9DYXJ0ID0gdGhpcy4kZm9ybS5maW5kKCdbZGF0YS1idXR0b24tcHVyY2hhc2VdJyk7XHJcblxyXG4gICAgdGhpcy5hdHRyaWJ1dGVzSGVscGVyID0gbmV3IEF0dHJpYnV0ZXNIZWxwZXIoZWwpO1xyXG4gICAgdGhpcy5wcm9ncmVzc0J1dHRvbiA9IG5ldyBQcm9ncmVzc0J1dHRvbigpO1xyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzID0gJC5leHRlbmQoe1xyXG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiBjb25zb2xlLmxvZygnVXBkYXRlIHJlcXVlc3RlZC4nKSxcclxuICAgICAgZGlkVXBkYXRlOiAoKSA9PiBjb25zb2xlLmxvZygnVXBkYXRlIGV4ZWN1dGVkLicpLFxyXG4gICAgICBzd2l0Y2hJbWFnZTogKHVybCkgPT4gY29uc29sZS5sb2coYEltYWdlIHN3aXRjaCBhdHRlbXB0ZWQgZm9yICR7dXJsfWApLFxyXG4gICAgfSwgb3B0aW9ucy5jYWxsYmFja3MpO1xyXG5cclxuICAgIHRoaXMuX2JvdW5kUHJvZHVjdE9wdGlvbkNoYW5nZSA9IHRoaXMuX2JpbmRQcm9kdWN0T3B0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmJvdW5kQ2FydENhbGxiYWNrID0gdGhpcy5fYmluZEFkZFRvQ2FydC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xyXG4gIH1cclxuXHJcbiAgX2JpbmRFdmVudHMoKSB7XHJcbiAgICB0aGlzLiRlbC5maW5kKCcucHJvZHVjdC1xdWFudGl0eS10b2dnbGUnKS5vbignY2xpY2snLCAoZXZlbnQpID0+IHtcclxuICAgICAgdGhpcy5fdXBkYXRlUXVhbnRpdHkoZXZlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy4kZWwuZmluZCgnLnByb2R1Y3QtcXVhbnRpdHknKS5vbignZm9jdXNvdXQnLCAoZXZlbnQpID0+IHtcclxuICAgICAgdGhpcy5fY2hlY2tRdWFudGl0eShldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaW5pdChjb250ZXh0KSB7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgY29uc3QgJHByb2R1Y3RPcHRpb25zRWxlbWVudCA9ICQoJ1tkYXRhLXByb2R1Y3Qtb3B0aW9uLWNoYW5nZV0nLCB0aGlzLiRmb3JtKTtcclxuICAgIGNvbnN0IGhhc09wdGlvbnMgPSAkcHJvZHVjdE9wdGlvbnNFbGVtZW50Lmxlbmd0aCA+IDAgPyB0cnVlIDogZmFsc2U7XHJcbiAgICBjb25zdCBoYXNEZWZhdWx0T3B0aW9ucyA9ICRwcm9kdWN0T3B0aW9uc0VsZW1lbnQuZmluZCgnW2RhdGEtZGVmYXVsdF0nKS5sZW5ndGg7XHJcbiAgICBpZiAoaGFzRGVmYXVsdE9wdGlvbnMgfHwgKF8uaXNFbXB0eSh0aGlzLnByb2R1Y3RBdHRyaWJ1dGVzRGF0YSkgJiYgaGFzT3B0aW9ucykpIHtcclxuICAgICAgY29uc3QgJHByb2R1Y3RJZCA9ICQoJ1tuYW1lPVwicHJvZHVjdF9pZFwiXScsIHRoaXMuJGZvcm0pLnZhbCgpO1xyXG4gICAgICB1dGlscy5hcGkucHJvZHVjdEF0dHJpYnV0ZXMub3B0aW9uQ2hhbmdlKCRwcm9kdWN0SWQsIHRoaXMuJGZvcm0uc2VyaWFsaXplKCksICdwcm9kdWN0cy9hZGQtdG8tY2FydC1mb3JtJywgKGVyciwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzRGF0YSA9IHJlc3BvbnNlLmRhdGEgfHwge307XHJcbiAgICAgICAgY29uc3QgYXR0cmlidXRlc0NvbnRlbnQgPSByZXNwb25zZS5jb250ZW50IHx8IHt9O1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlc0hlbHBlci51cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXNEYXRhKTtcclxuXHJcbiAgICAgICAgaWYgKGhhc0RlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICB0aGlzLl91cGRhdGVWaWV3KGF0dHJpYnV0ZXNEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5hdHRyaWJ1dGVzSGVscGVyLnVwZGF0ZUF0dHJpYnV0ZXModGhpcy5wcm9kdWN0QXR0cmlidXRlc0RhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHV0aWxzLmhvb2tzLm9uKCdwcm9kdWN0LW9wdGlvbi1jaGFuZ2UnLCB0aGlzLl9ib3VuZFByb2R1Y3RPcHRpb25DaGFuZ2UpO1xyXG4gICAgdGhpcy5fYmluZEFkZFdpc2hsaXN0KCk7XHJcblxyXG4gICAgdGhpcy5WYWxpZGF0b3IgPSBuZXcgRm9ybVZhbGlkYXRvcih0aGlzLmNvbnRleHQpO1xyXG4gICAgdGhpcy5WYWxpZGF0b3IuaW5pdFNpbmdsZSh0aGlzLiRlbC5maW5kKCdmb3JtW2RhdGEtY2FydC1pdGVtLWFkZF0nKSk7XHJcblxyXG4gICAgdXRpbHMuaG9va3Mub24oJ2NhcnQtaXRlbS1hZGQnLCB0aGlzLmJvdW5kQ2FydENhbGxiYWNrKTtcclxuXHJcbiAgICAvLyBUcmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHNvIHRoZSB2YWx1ZXMgYXJlIGNvcnJlY3QgZm9yIHByZS1zZWxlY3RlZCBvcHRpb25zXHJcbiAgICB0aGlzLiRlbC5maW5kKCdbZGF0YS1jYXJ0LWl0ZW0tYWRkXScpLmZpbmQoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXSwgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdLCBzZWxlY3QnKS5maXJzdCgpLmNoYW5nZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICpcclxuICAgKiBDbGVhbnVwIC0gdXNlZnVsIGZvciBjbG9zaW5nIHF1aWNrc2hvcCBtb2RhbHNcclxuICAgKlxyXG4gICAqL1xyXG4gICBkZXN0cm95KCkge1xyXG4gICAgIHV0aWxzLmhvb2tzLm9mZignY2FydC1pdGVtLWFkZCcsIHRoaXMuYm91bmRDYXJ0Q2FsbGJhY2spO1xyXG4gICAgIHV0aWxzLmhvb2tzLm9mZigncHJvZHVjdC1vcHRpb24tY2hhbmdlJywgdGhpcy5fYm91bmRQcm9kdWN0T3B0aW9uQ2hhbmdlKTtcclxuICAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWNoZSBhbiBvYmplY3Qgb2YgalF1ZXJ5IGVsZW1lbnRzIGZvciBET00gdXBkYXRpbmdcclxuICAgKiBAcGFyYW0gIGpRdWVyeSAkZWwgLSBhIHdyYXBwaW5nIGVsZW1lbnQgb2YgdGhlIHNjb3BlZCBwcm9kdWN0XHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIGJ1bmNoYSBqUXVlcnkgZWxlbWVudHMgd2hpY2ggbWF5IG9yIG1heSBub3QgZXhpc3Qgb24gdGhlIHBhZ2VcclxuICAgKi9cclxuICBfZ2V0Vmlld01vZGVsKCRlbCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJHByaWNlOiAkKCdbZGF0YS1wcm9kdWN0LXByaWNlLXdyYXBwZXI9XCJ3aXRob3V0LXRheFwiXScsICRlbCksXHJcbiAgICAgICRwcmljZVdpdGhUYXg6ICQoJ1tkYXRhLXByb2R1Y3QtcHJpY2Utd3JhcHBlcj1cIndpdGgtdGF4XCJdJywgJGVsKSxcclxuICAgICAgJHNhdmVkOiAkKCdbZGF0YS1wcm9kdWN0LXByaWNlLXNhdmVkXScsICRlbCksXHJcbiAgICAgICRza3U6ICQoJ1tkYXRhLXByb2R1Y3Qtc2t1XScsICRlbCksXHJcbiAgICAgICR3ZWlnaHQ6ICQoJ1tkYXRhLXByb2R1Y3Qtd2VpZ2h0XScsICRlbCksXHJcbiAgICAgICRhZGRUb0NhcnQ6ICQoJ1tkYXRhLWJ1dHRvbi1wdXJjaGFzZV0nLCAkZWwpLFxyXG4gICAgICAkaW1hZ2VQcmV2aWV3OiAkKCdbZGF0YS12YXJpYXRpb24tcHJldmlld10nLCAkZWwpLFxyXG4gICAgICBzdG9jazoge1xyXG4gICAgICAgICRzZWxlY3RvcjogJCgnW2RhdGEtcHJvZHVjdC1zdG9ja10nLCAkZWwpLFxyXG4gICAgICAgICRsZXZlbDogJCgnW2RhdGEtcHJvZHVjdC1zdG9jay1sZXZlbF0nLCAkZWwpLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk2NzI5OTIvYWpheC1yZXF1ZXN0LWZhaWxzLXdoZW4tc2VuZGluZy1mb3JtZGF0YS1pbmNsdWRpbmctZW1wdHktZmlsZS1pbnB1dC1pbi1zYWZhcmlcclxuICAqIFNhZmFyaSBicm93c2VyIHdpdGgganF1ZXJ5IDMuMy4xIGhhcyBhbiBpc3N1ZSB1cGxvYWRpbmcgZW1wdHkgZmlsZSBwYXJhbWV0ZXJzLiBUaGlzIGZ1bmN0aW9uIHJlbW92ZXMgYW55IGVtcHR5IGZpbGVzIGZyb20gdGhlIGZvcm0gcGFyYW1zXHJcbiAgKiBAcGFyYW0gZm9ybURhdGE6IEZvcm1EYXRhIG9iamVjdFxyXG4gICogQHJldHVybnMgRm9ybURhdGEgb2JqZWN0XHJcbiAgKi9cclxuICBmaWx0ZXJFbXB0eUZpbGVzRnJvbUZvcm0oZm9ybURhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBmb3JtRGF0YSkge1xyXG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGaWxlICYmICF2YWwubmFtZSAmJiAhdmFsLnNpemUpIHtcclxuICAgICAgICAgIGZvcm1EYXRhLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcclxuICAgIH1cclxuICAgIHJldHVybiBmb3JtRGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgcHJvZHVjdCBvcHRpb25zIGNoYW5nZXMuXHJcbiAgICovXHJcbiAgX2JpbmRQcm9kdWN0T3B0aW9uQ2hhbmdlKHsgdGFyZ2V0IH0sIGNoYW5nZWRPcHRpb24pIHtcclxuICAgIGNvbnN0IGZvcm1Qcm9kdWN0SWQgPSB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtcHJvZHVjdC1pZF0nKS5kYXRhc2V0LnByb2R1Y3RJZDtcclxuICAgIGlmIChmb3JtUHJvZHVjdElkICE9PSB0aGlzLnByb2R1Y3RJZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgJGNoYW5nZWRPcHRpb24gPSAkKGNoYW5nZWRPcHRpb24pO1xyXG4gICAgY29uc3QgJGZvcm0gPSAkY2hhbmdlZE9wdGlvbi5wYXJlbnRzKCdmb3JtJyk7XHJcblxyXG4gICAgLy8gRG8gbm90IHRyaWdnZXIgYW4gYWpheCByZXF1ZXN0IGlmIGl0J3MgYSBmaWxlIG9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBGb3JtRGF0YVxyXG4gICAgaWYgKCRjaGFuZ2VkT3B0aW9uLmF0dHIoJ3R5cGUnKSA9PT0gJ2ZpbGUnIHx8IHdpbmRvdy5Gb3JtRGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBhZ2VBbGVydHMuY2xlYXIoKTtcclxuICAgIHRoaXMucHJvZHVjdEFsZXJ0cy5jbGVhcigpO1xyXG5cclxuICAgIHV0aWxzLmFwaS5wcm9kdWN0QXR0cmlidXRlcy5vcHRpb25DaGFuZ2UodGhpcy5wcm9kdWN0SWQsICRmb3JtLnNlcmlhbGl6ZSgpLCAncHJvZHVjdHMvYWRkLXRvLWNhcnQtZm9ybScsIChlcnIsIHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgIGNvbnN0IHByb2R1Y3RBdHRyaWJ1dGVzRGF0YSA9IHJlc3BvbnNlLmRhdGEgfHwge307XHJcbiAgICAgIGNvbnN0IHByb2R1Y3RBdHRyaWJ1dGVzQ29udGVudCA9IHJlc3BvbnNlLmNvbnRlbnQgfHwge307XHJcblxyXG4gICAgICAvLyBJZiBvdXIgZm9ybSBkYXRhIGRvZXNuJ3QgaW5jbHVkZSB0aGUgcHJvZHVjdC1vcHRpb25zLWNvdW50IHdpdGggYSBwb3NpdGl2ZSB2YWx1ZSwgcmV0dXJuXHJcbiAgICAgIGlmICh0aGlzLiRlbC5maW5kKCdbZGF0YS1wcm9kdWN0LW9wdGlvbnMtY291bnRdJykudmFsIDwgMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5hdHRyaWJ1dGVzSGVscGVyLnVwZGF0ZUF0dHJpYnV0ZXMocHJvZHVjdEF0dHJpYnV0ZXNEYXRhKTtcclxuICAgICAgdGhpcy5fdXBkYXRlVmlldyhwcm9kdWN0QXR0cmlidXRlc0RhdGEpO1xyXG4gICAgICB0aGlzLnNldFByb2R1Y3RWYXJpYW50KCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVWaWV3KGRhdGEpIHtcclxuICAgIGNvbnN0IHZpZXdNb2RlbCA9IHRoaXMuX2dldFZpZXdNb2RlbCh0aGlzLiRlbCk7XHJcblxyXG4gICAgLy8gdXBkYXRpbmcgcHJpY2VcclxuICAgIGlmICh2aWV3TW9kZWwuJHByaWNlLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBwcmljZVN0cmluZ3MgPSB7XHJcbiAgICAgICAgcHJpY2U6IGRhdGEucHJpY2UsXHJcbiAgICAgICAgZXhjbHVkaW5nVGF4OiB0aGlzLmNvbnRleHQucHJvZHVjdEV4Y2x1ZGluZ1RheCxcclxuICAgICAgICBzYWxlUHJpY2VMYWJlbDogdGhpcy5jb250ZXh0LnNhbGVQcmljZUxhYmVsLFxyXG4gICAgICAgIG5vblNhbGVQcmljZUxhYmVsOiB0aGlzLmNvbnRleHQubm9uU2FsZVByaWNlTGFiZWwsXHJcbiAgICAgICAgcmV0YWlsUHJpY2VMYWJlbDogdGhpcy5jb250ZXh0LnJldGFpbFByaWNlTGFiZWwsXHJcbiAgICAgICAgcHJpY2VMYWJlbDogdGhpcy5jb250ZXh0LnByaWNlTGFiZWwsXHJcbiAgICAgIH07XHJcbiAgICAgIHZpZXdNb2RlbC4kcHJpY2UuaHRtbCh0aGlzLm9wdGlvbnMucHJpY2VXaXRob3V0VGF4VGVtcGxhdGUocHJpY2VTdHJpbmdzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZpZXdNb2RlbC4kcHJpY2VXaXRoVGF4Lmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBwcmljZVN0cmluZ3MgPSB7XHJcbiAgICAgICAgcHJpY2U6IGRhdGEucHJpY2UsXHJcbiAgICAgICAgaW5jbHVkaW5nVGF4OiB0aGlzLmNvbnRleHQucHJvZHVjdEluY2x1ZGluZ1RheCxcclxuICAgICAgICBzYWxlUHJpY2VMYWJlbDogdGhpcy5jb250ZXh0LnNhbGVQcmljZUxhYmVsLFxyXG4gICAgICAgIG5vblNhbGVQcmljZUxhYmVsOiB0aGlzLmNvbnRleHQubm9uU2FsZVByaWNlTGFiZWwsXHJcbiAgICAgICAgcmV0YWlsUHJpY2VMYWJlbDogdGhpcy5jb250ZXh0LnJldGFpbFByaWNlTGFiZWwsXHJcbiAgICAgICAgcHJpY2VMYWJlbDogdGhpcy5jb250ZXh0LnByaWNlTGFiZWwsXHJcbiAgICAgIH07XHJcbiAgICAgIHZpZXdNb2RlbC4kcHJpY2VXaXRoVGF4Lmh0bWwodGhpcy5vcHRpb25zLnByaWNlV2l0aFRheFRlbXBsYXRlKHByaWNlU3RyaW5ncykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2aWV3TW9kZWwuJHNhdmVkLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBwcmljZVN0cmluZ3MgPSB7XHJcbiAgICAgICAgcHJpY2U6IGRhdGEucHJpY2UsXHJcbiAgICAgICAgc2F2ZWRTdHJpbmc6IHRoaXMuY29udGV4dC5wcm9kdWN0WW91U2F2ZSxcclxuICAgICAgfTtcclxuICAgICAgdmlld01vZGVsLiRzYXZlZC5odG1sKHRoaXMub3B0aW9ucy5wcmljZVNhdmVkVGVtcGxhdGUocHJpY2VTdHJpbmdzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgc3RvY2sgdmlldyBpcyBvbiAoQ1Agc2V0dGluZ3MpXHJcbiAgICBpZiAodmlld01vZGVsLnN0b2NrLiRzZWxlY3Rvci5sZW5ndGggJiYgZGF0YS5zdG9jayAhPT0gbnVsbCkge1xyXG4gICAgICB2aWV3TW9kZWwuc3RvY2suJHNlbGVjdG9yLnJlbW92ZUNsYXNzKCdwcm9kdWN0LWRldGFpbHMtaGlkZGVuJyk7XHJcbiAgICAgIHZpZXdNb2RlbC5zdG9jay4kbGV2ZWwudGV4dChkYXRhLnN0b2NrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZpZXdNb2RlbC5zdG9jay4kc2VsZWN0b3IuYWRkQ2xhc3MoJ3Byb2R1Y3QtZGV0YWlscy1oaWRkZW4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgc2t1IGlmIGV4aXN0c1xyXG4gICAgaWYgKHZpZXdNb2RlbC4kc2t1Lmxlbmd0aCkge1xyXG4gICAgICB2aWV3TW9kZWwuJHNrdS5odG1sKGRhdGEuc2t1KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgd2VpZ2h0IGlmIGV4aXN0c1xyXG4gICAgaWYgKGRhdGEud2VpZ2h0ICYmIHZpZXdNb2RlbC4kd2VpZ2h0Lmxlbmd0aCkge1xyXG4gICAgICB2aWV3TW9kZWwuJHdlaWdodC5odG1sKGRhdGEud2VpZ2h0LmZvcm1hdHRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGFuZGxlIHByb2R1Y3QgdmFyaWFudCBpbWFnZSBpZiBleGlzdHNcclxuICAgIGlmIChkYXRhLmltYWdlKSB7XHJcbiAgICAgIGNvbnN0IHByb2R1Y3RJbWFnZVVybCA9IHV0aWxzLnRvb2xzLmltYWdlLmdldFNyYyhcclxuICAgICAgICBkYXRhLmltYWdlLmRhdGEsXHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnRoZW1lSW1hZ2VTaXplcy56b29tXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHpvb21JbWFnZVVybCA9IHV0aWxzLnRvb2xzLmltYWdlLmdldFNyYyhcclxuICAgICAgICBkYXRhLmltYWdlLmRhdGEsXHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnRoZW1lSW1hZ2VTaXplcy5wcm9kdWN0XHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyB0byBtYWludGFpbiBhIHJlZmVyZW5jZSBiZXR3ZWVuIG9wdGlvbiBpbWFnZXMsIHB1bGwgb3V0IHRoZVxyXG4gICAgICAvLyBmaWxlbmFtZSBmcm9tIHRoZSBpbWFnZSBVUkwgYW5kIHVzZSBpdCBhcyBhbiBJRFxyXG4gICAgICBjb25zdCBpbWFnZUlkID0gZGF0YS5pbWFnZS5kYXRhLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcclxuXHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLnN3aXRjaEltYWdlKHByb2R1Y3RJbWFnZVVybCwgem9vbUltYWdlVXJsLCBkYXRhLmltYWdlLmFsdCwgaW1hZ2VJZCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuJGVsLmZpbmQoJ1tkYXRhLXByb2R1Y3QtaW1hZ2UtdmFyaWFudF0nKS5sZW5ndGgpIHtcclxuICAgICAgcmVzZXRQcm9kdWN0SW1hZ2VzKHRoaXMuJGVsLmZpbmQoJy5wcm9kdWN0LXNsaWRlcy13cmFwJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZSBzdWJtaXQgYnV0dG9uIHN0YXRlXHJcbiAgICBpZiAoIWRhdGEucHVyY2hhc2FibGUgfHwgIWRhdGEuaW5zdG9jaykge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgb3V0X29mX3N0b2NrX21lc3NhZ2UsXHJcbiAgICAgICAgc3RvY2tfbWVzc2FnZSxcclxuICAgICAgICBwdXJjaGFzaW5nX21lc3NhZ2UsXHJcbiAgICAgIH0gPSBkYXRhO1xyXG5cclxuICAgICAgaWYgKCQoJy5tb2RhbC1xdWljay1zaG9wJykubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9kdWN0QWxlcnRzLmVycm9yKG91dF9vZl9zdG9ja19tZXNzYWdlIHx8IHN0b2NrX21lc3NhZ2UgfHwgcHVyY2hhc2luZ19tZXNzYWdlLCB0cnVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHRoaXMucGFnZUFsZXJ0cy5lcnJvcihvdXRfb2Zfc3RvY2tfbWVzc2FnZSB8fCBzdG9ja19tZXNzYWdlIHx8IHB1cmNoYXNpbmdfbWVzc2FnZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSwgNTApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2aWV3TW9kZWwuJGFkZFRvQ2FydFxyXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLmJ1dHRvbkRpc2FibGVkQ2xhc3MpXHJcbiAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSlcclxuICAgICAgICAuY2hpbGRyZW4oJy5idXR0b24tdGV4dCcpXHJcbiAgICAgICAgLnRleHQodGhpcy5jb250ZXh0LnNvbGRPdXRCdXR0b25MYWJlbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2aWV3TW9kZWwuJGFkZFRvQ2FydFxyXG4gICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmJ1dHRvbkRpc2FibGVkQ2xhc3MpXHJcbiAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpXHJcbiAgICAgICAgLmNoaWxkcmVuKCcuYnV0dG9uLXRleHQnKVxyXG4gICAgICAgIC50ZXh0KHRoaXMuY29udGV4dC5hZGRUb0NhcnRCdXR0b25MYWJlbCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlUXVhbnRpdHkoZXZlbnQpIHtcclxuICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgY29uc3QgJHF1YW50aXR5ID0gJHRhcmdldC5jbG9zZXN0KCcucHJvZHVjdC1xdWFudGl0eS1jb250YWluZXInKS5maW5kKCcucHJvZHVjdC1xdWFudGl0eScpO1xyXG4gICAgY29uc3QgbWluID0gcGFyc2VJbnQoJHF1YW50aXR5LnByb3AoJ21pbicpLCAxMCk7XHJcbiAgICBjb25zdCBtYXggPSBwYXJzZUludCgkcXVhbnRpdHkucHJvcCgnbWF4JyksIDEwKTtcclxuICAgIGxldCBuZXdRdWFudGl0eSA9IHBhcnNlSW50KCRxdWFudGl0eS52YWwoKSwgMTApO1xyXG5cclxuICAgIGlmIChpc05hTihuZXdRdWFudGl0eSkpIHtcclxuICAgICAgbmV3UXVhbnRpdHkgPSBtaW47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoJ3Byb2R1Y3QtcXVhbnRpdHktaW5jcmVtZW50JykgJiYgKCFtYXggfHwgbmV3UXVhbnRpdHkgPCBtYXgpKSB7XHJcbiAgICAgIG5ld1F1YW50aXR5ID0gbmV3UXVhbnRpdHkgKyAxO1xyXG4gICAgfSBlbHNlIGlmICgkdGFyZ2V0Lmhhc0NsYXNzKCdwcm9kdWN0LXF1YW50aXR5LWRlY3JlbWVudCcpICYmIG5ld1F1YW50aXR5ID4gbWluKSB7XHJcbiAgICAgIG5ld1F1YW50aXR5ID0gbmV3UXVhbnRpdHkgLSAxO1xyXG4gICAgfVxyXG5cclxuICAgICRxdWFudGl0eS52YWwobmV3UXVhbnRpdHkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIHRvIGNhcnRcclxuICAgKi9cclxuICBfYmluZEFkZFRvQ2FydChldmVudCwgZm9ybSkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAvLyBTa2lwIHRoaXMgY2FsbGJhY2sgaWYgdGhlIHByb2R1Y3QgaXNuJ3QgdGhlIG9uZSB0aGlzIGluc3RhbmNlIGlzIHRyYWNraW5nXHJcbiAgICBjb25zdCBmb3JtUHJvZHVjdElkID0gZXZlbnQudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPXByb2R1Y3RfaWRdJykudmFsdWU7XHJcbiAgICBpZiAoZm9ybVByb2R1Y3RJZCAhPT0gdGhpcy5wcm9kdWN0SWQpIHJldHVybjtcclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBGb3JtRGF0YVxyXG4gICAgaWYgKHdpbmRvdy5Gb3JtRGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBxdWFudGl0eSA9IHRoaXMuJGVsLmZpbmQoJ2lucHV0LnByb2R1Y3QtcXVhbnRpdHknKS52YWwoKTtcclxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgYnV0dG9uIHN0YXRlXHJcbiAgICB0aGlzLnByb2dyZXNzQnV0dG9uLnByb2dyZXNzKHRoaXMuJGFkZFRvQ2FydCk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIG9sZCBhbGVydHNcclxuICAgIHRoaXMucGFnZUFsZXJ0cy5jbGVhcigpO1xyXG4gICAgdGhpcy5wcm9kdWN0QWxlcnRzLmNsZWFyKCk7XHJcblxyXG4gICAgLy8gQWpheCBhZGQgaXRlbSB0byBjYXJ0XHJcbiAgICB1dGlscy5hcGkuY2FydC5pdGVtQWRkKHRoaXMuZmlsdGVyRW1wdHlGaWxlc0Zyb21Gb3JtKGZvcm1EYXRhKSwgKGVyciwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgLy8gUGFyc2UgdGhlIGFqYXggcmVzcG9uc2Ugc28gd2UgY2FuIHBhc3MgaXQgdG8gdGhlIG1lc3NhZ2UuXHJcbiAgICAgIHJlc3BvbnNlID0gdGhpcy5fcGFyc2VSZXNwb25zZShlcnIsIHJlc3BvbnNlLCB0aGlzLnByb2R1Y3RUaXRsZSwgcXVhbnRpdHkpO1xyXG5cclxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBhZ2VBbGVydHMubWVzc2FnZShyZXNwb25zZS5tZXNzYWdlLCByZXNwb25zZS5zdGF0dXMsIHRydWUpO1xyXG4gICAgICAgIH0sIDUwKTtcclxuXHJcbiAgICAgICAgLy8gQ3VzdG9tIHN1Y2Nlc3MgZXZlbnQgdG8gY2xvc2UgdGhlIHF1aWNrIHNob3AgYW5kIG9wZW4gdGhlIG1pbmkgY2FydFxyXG4gICAgICAgICQuZXZlbnQudHJpZ2dlcignY2FydC1pdGVtLWFkZC1zdWNjZXNzJyk7XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5wYWdlQWxlcnRzLmNsZWFyKCk7XHJcbiAgICAgICAgfSwgNTAwMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5wcm9kdWN0QWxlcnRzLm1lc3NhZ2UocmVzcG9uc2UubWVzc2FnZSwgcmVzcG9uc2Uuc3RhdHVzLCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVzZXQgdGhlIGJ1dHRvbiBzdGF0ZVxyXG4gICAgICB0aGlzLnByb2dyZXNzQnV0dG9uLmNvbXBsZXRlKHRoaXMuJGFkZFRvQ2FydCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkIG91ciBlcnJvci9zdWNjZXNzIG1lc3NhZ2VzIGJhc2VkIG9uIHJlc3BvbnNlLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlcnIgLSB0aGUgKHBvdGVudGlhbCkgcmV0dXJuZWQgZXJyb3Igb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAtIHRoZSBhamF4IHJlc3BvbnNlIGZyb20gdGhlIGFkZC10by1jYXJ0IGFjdGlvbi5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgLSBUaGUgbmFtZSBvZiB0aGUgYWRkZWQgcHJvZHVjdC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbnRpdHkgLSBUaGUgYWRkZWQgcXVhbnRpdHkuXHJcbiAgICovXHJcbiAgX3BhcnNlUmVzcG9uc2UoZXJyLCByZXNwb25zZSwgdGl0bGUsIHF1YW50aXR5KSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xyXG4gICAgbGV0IHN0YXR1cyA9ICcnO1xyXG5cclxuICAgIGlmIChlcnIgfHwgcmVzcG9uc2UuZGF0YS5lcnJvcikge1xyXG4gICAgICBzdGF0dXMgPSAnZXJyb3InO1xyXG5cclxuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuZXJyb3IpIHtcclxuICAgICAgICBtZXNzYWdlID0gcmVzcG9uc2UuZGF0YS5lcnJvcjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtZXNzYWdlID0gdGhpcy5jb250ZXh0Lm1lc3NhZ2VzUHJvZHVjdEdlbmVyYWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGF0dXMgPSAnc3VjY2Vzcyc7XHJcbiAgICAgIGlmICh0aGlzLiRwcm9kdWN0Q29udGFpbmVyLmhhc0NsYXNzKCdiYWctaWNvbicpKSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMuY29udGV4dC5tZXNzYWdlc1Byb2R1Y3RBZGRTdWNjZXNzQmFnO1xyXG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnKnByb2R1Y3QqJywgYFwiJHt0aXRsZX1cImApXHJcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnKmJhZ19saW5rKicsIGA8YSBocmVmPSR7dGhpcy5jb250ZXh0LnVybHNDYXJ0fT4ke3RoaXMuY29udGV4dC5iYWdMaW5rfTwvYT5gKVxyXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJypjaGVja291dF9saW5rKicsIGA8YSBocmVmPSR7dGhpcy5jb250ZXh0LnVybHNDaGVja291dH0+JHt0aGlzLmNvbnRleHQuY2hlY2tvdXRMaW5rfTwvYT5gKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtZXNzYWdlID0gdGhpcy5jb250ZXh0Lm1lc3NhZ2VzUHJvZHVjdEFkZFN1Y2Nlc3NDYXJ0O1xyXG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnKnByb2R1Y3QqJywgYFwiJHt0aXRsZX1cImApXHJcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnKmNhcnRfbGluayonLCBgPGEgaHJlZj0ke3RoaXMuY29udGV4dC51cmxzQ2FydH0+JHt0aGlzLmNvbnRleHQuY2FydExpbmt9PC9hPmApXHJcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnKmNoZWNrb3V0X2xpbmsqJywgYDxhIGhyZWY9JHt0aGlzLmNvbnRleHQudXJsc0NoZWNrb3V0fT4ke3RoaXMuY29udGV4dC5jaGVja291dExpbmt9PC9hPmApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhdHVzOiBzdGF0dXMsXHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jaGVja1F1YW50aXR5KGVsKSB7XHJcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcclxuICAgIGNvbnN0IHF1YW50aXR5ID0gcGFyc2VJbnQoJGVsLnZhbCgpLCAxMCk7XHJcbiAgICBjb25zdCBtaW4gPSBwYXJzZUludCgkZWwucHJvcCgnbWluJykpXHJcblxyXG4gICAgaWYgKGlzTmFOKHF1YW50aXR5KSB8fCBxdWFudGl0eSA8IG1pbikge1xyXG4gICAgICAkZWwudmFsKG1pbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBamF4IGFkZCB0byB3aXNobGlzdFxyXG4gICAqXHJcbiAgICovXHJcbiAgX2JpbmRBZGRXaXNobGlzdCgpIHtcclxuICAgICQoJ1tkYXRhLXdpc2hsaXN0XScpLm9uKCdjbGljaycsIChldmVudCkgPT4ge1xyXG4gICAgICBjb25zdCAkYnV0dG9uID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgY29uc3QgYWRkVXJsID0gJGJ1dHRvbi5hdHRyKCdocmVmJyk7XHJcbiAgICAgIGNvbnN0IHZpZXdVcmwgPSAkYnV0dG9uLmRhdGEoJ3dpc2hsaXN0Jyk7XHJcblxyXG4gICAgICBpZiAoJCgnW2RhdGEtaXMtY3VzdG9tZXJdJykubGVuZ3RoKSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0J1dHRvbi5wcm9ncmVzcygkYnV0dG9uKTtcclxuXHJcbiAgICAgICAgJC5hamF4KHtcclxuICAgICAgICAgIHR5cGU6ICdQT1NUJyxcclxuICAgICAgICAgIHVybDogYWRkVXJsLFxyXG4gICAgICAgICAgc3VjY2VzczogKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2R1Y3RBbGVydHMuc3VjY2Vzcyh0aGlzLmNvbnRleHQubWVzc2FnZXNXaXNobGlzdEFkZFN1Y2Nlc3MucmVwbGFjZSgnKnByb2R1Y3QqJywgdGhpcy5wcm9kdWN0VGl0bGUpLnJlcGxhY2UoJyp1cmwqJywgdmlld1VybCksIHRydWUpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVycm9yOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZHVjdEFsZXJ0cy5lcnJvcih0aGlzLmNvbnRleHQubWVzc2FnZXNXaXNobGlzdEFkZEVycm9yLnJlcGxhY2UoJypwcm9kdWN0KicsIHRoaXMucHJvZHVjdFRpdGxlKSwgdHJ1ZSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0J1dHRvbi5jb21wbGV0ZSgkYnV0dG9uKTtcclxuXHJcbiAgICAgICAgICAgICRidXR0b25cclxuICAgICAgICAgICAgICAuY2xvc2VzdCgnW2RhdGEtd2lzaGxpc3QtZHJvcGRvd25dJylcclxuICAgICAgICAgICAgICAuZmluZCgnW2RhdGEtd2lzaGxpc3QtdG9nZ2xlXScpXHJcbiAgICAgICAgICAgICAgLnRyaWdnZXIoJ2NsaWNrJyk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHNldFByb2R1Y3RWYXJpYW50KCkge1xyXG4gICAgY29uc3QgdW5zYXRpc2ZpZWRSZXF1aXJlZEZpZWxkcyA9IFtdO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IFtdO1xyXG5cclxuICAgICQuZWFjaCgkKCdbZGF0YS1wcm9kdWN0LWF0dHJpYnV0ZV0nKSwgKGluZGV4LCB2YWx1ZSkgPT4ge1xyXG4gICAgICBjb25zdCBvcHRpb25MYWJlbCA9IHZhbHVlLmNoaWxkcmVuWzBdLmlubmVyVGV4dDtcclxuICAgICAgY29uc3Qgb3B0aW9uVGl0bGUgPSBvcHRpb25MYWJlbC5zcGxpdCgnOicpWzBdLnRyaW0oKTtcclxuICAgICAgY29uc3QgcmVxdWlyZWQgPSBvcHRpb25MYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyZXF1aXJlZCcpO1xyXG4gICAgICBjb25zdCB0eXBlID0gdmFsdWUuZ2V0QXR0cmlidXRlKCdkYXRhLXByb2R1Y3QtYXR0cmlidXRlJyk7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKHR5cGUgPT09ICdpbnB1dC1maWxlJyB8fCB0eXBlID09PSAnaW5wdXQtdGV4dCcgfHwgdHlwZSA9PT0gJ2lucHV0LW51bWJlcicpXHJcbiAgICAgICAgJiYgdmFsdWUucXVlcnlTZWxlY3RvcignaW5wdXQnKS52YWx1ZSA9PT0gJycgJiYgcmVxdWlyZWRcclxuICAgICAgKSB7XHJcbiAgICAgICAgdW5zYXRpc2ZpZWRSZXF1aXJlZEZpZWxkcy5wdXNoKHZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0YXJlYScgJiYgdmFsdWUucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKS52YWx1ZSA9PT0gJycgJiYgcmVxdWlyZWQpIHtcclxuICAgICAgICB1bnNhdGlzZmllZFJlcXVpcmVkRmllbGRzLnB1c2godmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gJ2RhdGUnKSB7XHJcbiAgICAgICAgY29uc3QgaXNTYXRpc2ZpZWQgPSBBcnJheS5mcm9tKHZhbHVlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpKS5ldmVyeSgoc2VsZWN0KSA9PiBzZWxlY3Quc2VsZWN0ZWRJbmRleCAhPT0gMCk7XHJcblxyXG4gICAgICAgIGlmIChpc1NhdGlzZmllZCkge1xyXG4gICAgICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IEFycmF5LmZyb20odmFsdWUucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JykpLm1hcCgoeCkgPT4geC52YWx1ZSkuam9pbignLScpO1xyXG4gICAgICAgICAgb3B0aW9ucy5wdXNoKGAke29wdGlvblRpdGxlfToke2RhdGVTdHJpbmd9YCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgdW5zYXRpc2ZpZWRSZXF1aXJlZEZpZWxkcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlID09PSAnc2V0LXNlbGVjdCcpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3QgPSB2YWx1ZS5xdWVyeVNlbGVjdG9yKCdzZWxlY3QnKTtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gc2VsZWN0LnNlbGVjdGVkSW5kZXg7XHJcblxyXG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgICBvcHRpb25zLnB1c2goYCR7b3B0aW9uVGl0bGV9OiR7c2VsZWN0Lm9wdGlvbnNbc2VsZWN0ZWRJbmRleF0uaW5uZXJUZXh0fWApO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlcXVpcmVkKSB7XHJcbiAgICAgICAgICB1bnNhdGlzZmllZFJlcXVpcmVkRmllbGRzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR5cGUgPT09ICdzZXQtcmVjdGFuZ2xlJ1xyXG4gICAgICAgIHx8IHR5cGUgPT09ICdzZXQtcmFkaW8nXHJcbiAgICAgICAgfHwgdHlwZSA9PT0gJ3N3YXRjaCdcclxuICAgICAgICB8fCB0eXBlID09PSAnaW5wdXQtY2hlY2tib3gnXHJcbiAgICAgICAgfHwgdHlwZSA9PT0gJ3Byb2R1Y3QtbGlzdCdcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHZhbHVlLnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XHJcbiAgICAgICAgaWYgKGNoZWNrZWQpIHtcclxuICAgICAgICAgIGlmICh0eXBlID09PSAnc2V0LXJlY3RhbmdsZScgfHwgdHlwZSA9PT0gJ3NldC1yYWRpbycgfHwgdHlwZSA9PT0gJ3Byb2R1Y3QtbGlzdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBjaGVja2VkLmxhYmVsc1swXS5pbm5lclRleHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgICBvcHRpb25zLnB1c2goYCR7b3B0aW9uVGl0bGV9OiR7bGFiZWx9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N3YXRjaCcpIHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBjaGVja2VkLmxhYmVsc1swXS5jaGlsZHJlblswXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICAgIG9wdGlvbnMucHVzaChgJHtvcHRpb25UaXRsZX06JHtsYWJlbC50aXRsZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICh0eXBlID09PSAnaW5wdXQtY2hlY2tib3gnKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChgJHtvcHRpb25UaXRsZX06WWVzYCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdpbnB1dC1jaGVja2JveCcpIHtcclxuICAgICAgICAgIG9wdGlvbnMucHVzaChgJHtvcHRpb25UaXRsZX06Tm9gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXF1aXJlZCkge1xyXG4gICAgICAgICAgICB1bnNhdGlzZmllZFJlcXVpcmVkRmllbGRzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IHByb2R1Y3RWYXJpYW50ID0gdW5zYXRpc2ZpZWRSZXF1aXJlZEZpZWxkcy5sZW5ndGggPT09IDAgPyBvcHRpb25zLnNvcnQoKS5qb2luKCcsICcpIDogJ3Vuc2F0aXNmaWVkJztcclxuICAgIGNvbnN0IHZpZXcgPSAkKCcucHJvZHVjdC1kZXRhaWxzJyk7XHJcblxyXG4gICAgaWYgKHByb2R1Y3RWYXJpYW50KSB7XHJcbiAgICAgIHByb2R1Y3RWYXJpYW50ID0gcHJvZHVjdFZhcmlhbnQgPT09ICd1bnNhdGlzZmllZCcgPyAnJyA6IHByb2R1Y3RWYXJpYW50O1xyXG5cclxuICAgICAgaWYgKHZpZXcuYXR0cignZGF0YS1ldmVudC10eXBlJykpIHtcclxuICAgICAgICB2aWV3LmF0dHIoJ2RhdGEtcHJvZHVjdC12YXJpYW50JywgcHJvZHVjdFZhcmlhbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHByb2R1Y3ROYW1lID0gdmlldy5maW5kKCcucHJvZHVjdC10aXRsZScpWzBdLmlubmVyVGV4dDtcclxuICAgICAgICBjb25zdCBjYXJkID0gJChgW2RhdGEtbmFtZT1cIiR7cHJvZHVjdE5hbWV9XCJdYCk7XHJcbiAgICAgICAgY2FyZC5hdHRyKCdkYXRhLXByb2R1Y3QtdmFyaWFudCcsIHByb2R1Y3RWYXJpYW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgaW1hZ2VzTG9hZGVkIGZyb20gJ2ltYWdlc2xvYWRlZCc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xuaW1wb3J0IFByb2R1Y3RVdGlscyBmcm9tICcuL1Byb2R1Y3RVdGlscyc7XG5pbXBvcnQgUHJvZHVjdEltYWdlcyBmcm9tICcuL1Byb2R1Y3RJbWFnZXMnO1xuaW1wb3J0IHByb2R1Y3RWaWV3VGVtcGxhdGVzIGZyb20gJy4vcHJvZHVjdFZpZXdUZW1wbGF0ZXMnO1xuaW1wb3J0IHZhcmlhdGlvbkltZ1ByZXZpZXcgZnJvbSAnLi92YXJpYXRpb25JbWdQcmV2aWV3JztcbmltcG9ydCBDb2xvclN3YXRjaCBmcm9tICcuLi9wcm9kdWN0L0NvbG9yU3dhdGNoJztcbmltcG9ydCBNb2RhbCBmcm9tICdiYy1tb2RhbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1aWNrU2hvcCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMucHJvZHVjdDtcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIFNldCB1cCB0aGUgbW9kYWwgb3B0aW9uc1xuICAgIHRoaXMuUXVpY2tTaG9wTW9kYWwgPSBuZXcgTW9kYWwoe1xuICAgICAgbW9kYWxDbGFzczogJ21vZGFsLXF1aWNrLXNob3AnLFxuICAgICAgY2VudGVyVmVydGljYWxseTogZmFsc2UsXG4gICAgICBhZnRlclNob3c6ICgkbW9kYWwpID0+IHtcbiAgICAgICAgdXRpbHMuaG9va3Mub2ZmKCdwcm9kdWN0LW9wdGlvbi1jaGFuZ2UnKTtcbiAgICAgICAgdGhpcy5fZmV0Y2hQcm9kdWN0KCRtb2RhbCwgdGhpcy5pZCk7XG4gICAgICB9LFxuICAgICAgYWZ0ZXJIaWRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuUHJvZHVjdFV0aWxzID0gbmV3IFByb2R1Y3RVdGlscygnW2RhdGEtcHJvZHVjdC1jb250YWluZXJdJywge1xuICAgICAgICAgIHByaWNlV2l0aG91dFRheFRlbXBsYXRlOiBwcm9kdWN0Vmlld1RlbXBsYXRlcy5wcmljZVdpdGhvdXRUYXgsXG4gICAgICAgICAgcHJpY2VXaXRoVGF4VGVtcGxhdGU6IHByb2R1Y3RWaWV3VGVtcGxhdGVzLnByaWNlV2l0aFRheCxcbiAgICAgICAgICBwcmljZVNhdmVkVGVtcGxhdGU6IHByb2R1Y3RWaWV3VGVtcGxhdGVzLnByaWNlU2F2ZWQsXG4gICAgICAgICAgdmFyaWF0aW9uUHJldmlld0ltYWdlVGVtcGxhdGU6IHByb2R1Y3RWaWV3VGVtcGxhdGVzLnZhcmlhdGlvblByZXZpZXdJbWFnZSxcbiAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgIHN3aXRjaEltYWdlOiB2YXJpYXRpb25JbWdQcmV2aWV3XG4gICAgICAgICAgfVxuICAgICAgICB9KS5pbml0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIHRoaXMucHJvZHVjdC5kZXN0cm95KCk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIExhdW5jaCBxdWlja3Nob3AgbW9kYWwgb24gY2xpY2sgYW5kIHNldCB1cCBpZCB2YXJpYWJsZVxuICAgKi9cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgJCgnYm9keScpLm9uKCdjbGljaycsICdbZGF0YS1xdWljay1zaG9wXScsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5pZCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YSgncHJvZHVjdC1pZCcpO1xuXG4gICAgICBpZiAoIXRoaXMuaWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHRoaXMuUXVpY2tTaG9wTW9kYWwub3BlbigpO1xuXG4gICAgICAkKCcubW9kYWwtY29udGVudCcpLnByZXBlbmQoJzxzdmcgY2xhc3M9XCJpY29uIGljb24tc3Bpbm5lclwiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uLXNwaW5uZXJcIiAvPjwvc3ZnPicpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBhamF4IGZldGNoIG9mIHByb2R1Y3QgYW5kIGFkZCB0byBtb2RhbC4gQmluZCBwcm9kdWN0IGZ1bmN0aW9uYWxpdHkgYW5kIHNob3cgdGhlIG1vZGFsXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkbW9kYWwgLSB0aGUgcm9vdCAoYXBwZW5kZWQpIG1vZGFsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gaWQgLSBwcm9kdWN0IGlkXG4gICAqL1xuICBfZmV0Y2hQcm9kdWN0KCRtb2RhbCwgaWQpIHtcbiAgICB1dGlscy5hcGkucHJvZHVjdC5nZXRCeUlkKGlkLCB7IHRlbXBsYXRlOiAncXVpY2stc2hvcC9xdWljay1zaG9wLW1vZGFsJyB9LCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgJG1vZGFsLmZpbmQoJy5tb2RhbC1jb250ZW50JykuYXBwZW5kKHJlc3BvbnNlKTtcblxuICAgICAgLy8gSW5pdCBGQiBsaWtlIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKCRtb2RhbC5maW5kKCcuZmFjZWJvb2stbGlrZScpLmxlbmd0aCkge1xuICAgICAgICAoZnVuY3Rpb24oZCwgcywgaWQpIHtcbiAgICAgICAgICB2YXIganMsIGZqcyA9IGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUocylbMF07XG4gICAgICAgICAgaWYgKGQuZ2V0RWxlbWVudEJ5SWQoaWQpKSByZXR1cm47XG4gICAgICAgICAganMgPSBkLmNyZWF0ZUVsZW1lbnQocyk7IGpzLmlkID0gaWQ7XG4gICAgICAgICAganMuc3JjID0gXCIvL2Nvbm5lY3QuZmFjZWJvb2submV0L2VuX1VTL3Nkay5qcyN4ZmJtbD0xJnZlcnNpb249djIuNVwiO1xuICAgICAgICAgIGZqcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShqcywgZmpzKTtcbiAgICAgICAgfShkb2N1bWVudCwgJ3NjcmlwdCcsICdmYWNlYm9vay1qc3NkaycpKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHVwIHByb2R1Y3QgdXRpbHMgKGFkZGluZyB0byBjYXJ0LCBvcHRpb25zKVxuICAgICAgY29uc3QgJGVsID0gJG1vZGFsLmZpbmQoJ1tkYXRhLXByb2R1Y3QtcXVpY2tzaG9wLWNvbnRhaW5lcl0nKTtcblxuICAgICAgdGhpcy5wcm9kdWN0ID0gbmV3IFByb2R1Y3RVdGlscygkZWwsIHtcbiAgICAgICAgcHJpY2VXaXRob3V0VGF4VGVtcGxhdGU6IHByb2R1Y3RWaWV3VGVtcGxhdGVzLnByaWNlV2l0aG91dFRheCxcbiAgICAgICAgcHJpY2VXaXRoVGF4VGVtcGxhdGU6IHByb2R1Y3RWaWV3VGVtcGxhdGVzLnByaWNlV2l0aFRheCxcbiAgICAgICAgcHJpY2VTYXZlZFRlbXBsYXRlOiBwcm9kdWN0Vmlld1RlbXBsYXRlcy5wcmljZVNhdmVkLFxuICAgICAgICB2YXJpYXRpb25QcmV2aWV3SW1hZ2VUZW1wbGF0ZTogcHJvZHVjdFZpZXdUZW1wbGF0ZXMudmFyaWF0aW9uUHJldmlld0ltYWdlLFxuICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICBzd2l0Y2hJbWFnZTogdmFyaWF0aW9uSW1nUHJldmlld1xuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLnByb2R1Y3QuaW5pdCh0aGlzLmNvbnRleHQpO1xuXG4gICAgICAvLyBzZXQgdXAgc2ltcGxlIGltYWdlIHNsaWRlc2hvd1xuICAgICAgbmV3IFByb2R1Y3RJbWFnZXMoJy5tb2RhbC1xdWljay1zaG9wIC5wcm9kdWN0LXNsaWRlcy13cmFwJyk7XG5cbiAgICAgIHRoaXMuc3dhdGNoZXMgPSBuZXcgQ29sb3JTd2F0Y2goKTsgLy8gSW5pdCBvdXIgY29sb3Igc3dhdGNoZXNcblxuICAgICAgLy8gcmVwb3NpdGlvbiBtb2RhbCB3aXRoIGNvbnRlbnRcbiAgICAgIHRoaXMuUXVpY2tTaG9wTW9kYWwucG9zaXRpb24oKTtcblxuICAgICAgJG1vZGFsLmFkZENsYXNzKCdsb2FkZWQnKTtcblxuICAgICAgJCgnLm1vZGFsLWNvbnRlbnQnKS5jaGlsZHJlbignLmljb24tc3Bpbm5lcicpLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByaWNlV2l0aG91dFRheDogXy50ZW1wbGF0ZShgXG4gICAgPCUgaWYgKHByaWNlLnJycF93aXRob3V0X3RheCkgeyAlPlxuICAgICAgPGRpdiBjbGFzcz1cInByaWNlLXJycC13cmFwcGVyXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cInByaWNlLXJycC1sYWJlbFwiPjwlPSByZXRhaWxQcmljZUxhYmVsICU+PC9sYWJlbD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJwcmljZS1ycnBcIj48JT0gcHJpY2UucnJwX3dpdGhvdXRfdGF4LmZvcm1hdHRlZCAlPjwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwlIH0gJT5cbiAgICA8JSBpZiAocHJpY2Uubm9uX3NhbGVfcHJpY2Vfd2l0aG91dF90YXgpIHsgJT5cbiAgICAgIDxkaXYgY2xhc3M9XCJwcmljZS1ucy13cmFwcGVyXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cInByaWNlLW5zLWxhYmVsXCI+PCU9IG5vblNhbGVQcmljZUxhYmVsICU+PC9sYWJlbD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJwcmljZS1uc1wiPlxuICAgICAgICAgIDwlPSBwcmljZS5ub25fc2FsZV9wcmljZV93aXRob3V0X3RheC5mb3JtYXR0ZWQgJT5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgPCUgfSAlPlxuICAgIDxkaXYgY2xhc3M9XCJwcmljZS12YWx1ZS13cmFwcGVyXCI+XG4gICAgICA8IS0tIElmIHRoZXJlJ3MgYW5vdGhlciBwcmljZSBzaG93IFwibm93XCIgbGFiZWwgLS0+XG4gICAgICA8JSBpZiAocHJpY2Uubm9uX3NhbGVfcHJpY2Vfd2l0aG91dF90YXgpIHsgJT5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwicHJpY2UtdmFsdWUtbGFiZWxcIj48JT0gc2FsZVByaWNlTGFiZWwgJT48L2xhYmVsPlxuICAgICAgPCUgfSBlbHNlIHsgJT5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwicHJpY2UtbGFiZWxcIj48JT0gcHJpY2VMYWJlbCAlPjwvbGFiZWw+XG4gICAgICA8JSB9ICU+XG4gICAgICA8c3BhbiBjbGFzcz1cInByaWNlLXZhbHVlXCIgZGF0YS1wcm9kdWN0LXByaWNlPlxuICAgICAgICA8JT0gcHJpY2Uud2l0aG91dF90YXguZm9ybWF0dGVkICU+XG4gICAgICA8L3NwYW4+XG4gICAgICA8JSBpZiAocHJpY2Uud2l0aF90YXggJiYgcHJpY2Uud2l0aG91dF90YXgpIHsgJT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJwcmljZS10YXgtbGFiZWxcIj48JT0gZXhjbHVkaW5nVGF4ICU+PC9zcGFuPlxuICAgICAgPCUgfSAlPlxuICAgIDwvZGl2PlxuICBgKSxcblxuICBwcmljZVdpdGhUYXg6IF8udGVtcGxhdGUoYFxuICAgIDwlIGlmIChwcmljZS5ycnBfd2l0aF90YXgpIHsgJT5cbiAgICAgIDxkaXYgY2xhc3M9XCJwcmljZS1ycnAtd3JhcHBlclwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJwcmljZS1ycnAtbGFiZWxcIj48JT0gcmV0YWlsUHJpY2VMYWJlbCAlPjwvbGFiZWw+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwicHJpY2UtcnJwXCI+PCU9IHByaWNlLnJycF93aXRoX3RheC5mb3JtYXR0ZWQgJT48L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICA8JSB9ICU+XG4gICAgPCUgaWYgKHByaWNlLm5vbl9zYWxlX3ByaWNlX3dpdGhvdXRfdGF4KSB7ICU+XG4gICAgICA8ZGl2IGNsYXNzPVwicHJpY2UtbnMtd3JhcHBlclwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJwcmljZS1ucy1sYWJlbFwiPjwlPSBub25TYWxlUHJpY2VMYWJlbCAlPjwvbGFiZWw+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwicHJpY2UtbnNcIj5cbiAgICAgICAgICA8JT0gcHJpY2Uubm9uX3NhbGVfcHJpY2Vfd2l0aF90YXguZm9ybWF0dGVkICU+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwlIH0gJT5cbiAgICA8ZGl2IGNsYXNzPVwicHJpY2UtdmFsdWUtd3JhcHBlclwiPlxuICAgICAgPCEtLSBJZiB0aGVyZSdzIGFub3RoZXIgcHJpY2Ugc2hvdyBcIm5vd1wiIGxhYmVsIC0tPlxuICAgICAgPCUgaWYgKHByaWNlLm5vbl9zYWxlX3ByaWNlX3dpdGhfdGF4KSB7ICU+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cInByaWNlLXZhbHVlLWxhYmVsXCI+PCU9IHNhbGVQcmljZUxhYmVsICU+PC9sYWJlbD5cbiAgICAgIDwlIH0gZWxzZSB7ICU+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cInByaWNlLWxhYmVsXCI+PCU9IHByaWNlTGFiZWwgJT48L2xhYmVsPlxuICAgICAgPCUgfSAlPlxuICAgICAgPHNwYW4gY2xhc3M9XCJwcmljZS12YWx1ZVwiIGRhdGEtcHJvZHVjdC1wcmljZT5cbiAgICAgICAgPCU9IHByaWNlLndpdGhfdGF4LmZvcm1hdHRlZCAlPlxuICAgICAgPC9zcGFuPlxuICAgICAgPCUgaWYgKHByaWNlLndpdGhfdGF4ICYmIHByaWNlLndpdGhvdXRfdGF4KSB7ICU+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwicHJpY2UtdGF4LWxhYmVsXCI+PCU9IGluY2x1ZGluZ1RheCAlPjwvc3Bhbj5cbiAgICAgIDwlIH0gJT5cbiAgICA8L2Rpdj5cbiAgYCksXG5cbiAgcHJpY2VTYXZlZDogXy50ZW1wbGF0ZShgXG4gICAgPCUgaWYgKHByaWNlLnNhdmVkKSB7ICU+XG4gICAgICA8JT0gc2F2ZWRTdHJpbmcgJT4gPCU9IHByaWNlLnNhdmVkLmZvcm1hdHRlZCAlPlxuICAgIDwlIH0gJT5cbiAgYCksXG5cbiAgdmFyaWF0aW9uSW1hZ2U6IF8udGVtcGxhdGUoYFxuICAgIDxhIGNsYXNzPVwicHJvZHVjdC1pbWFnZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTp1cmwoPCU9IHpvb21JbWFnZVNyYyAlPik7XCIgaHJlZj1cIjwlPSB6b29tSW1hZ2VTcmMgJT5cIiBkYXRhLXByb2R1Y3QtaW1hZ2UgZGF0YS1wcm9kdWN0LWltYWdlLXZhcmlhbnQ+XG4gICAgICA8aW1nIHNyYz1cIjwlPSBwcm9kdWN0SW1hZ2VTcmMgJT5cIj5cbiAgICA8L2E+XG4gIGApLFxuXG4gIHZhcmlhdGlvbkltYWdlTmF2OiBfLnRlbXBsYXRlKGBcbiAgICA8ZGl2IGNsYXNzPVwicGFnaW5hdGlvbi1pdGVtXCIgZGF0YS12YXJpYW50LWlkPVwiPCU9IGlkICU+XCI+XG4gICAgICA8aW1nIHNyYz1cIjwlPSBwcm9kdWN0SW1hZ2VTcmMgJT5cIj5cbiAgICA8L2Rpdj5cbiAgYCksXG59O1xuIiwiaW1wb3J0IHNjcm9sbFRvVG9wIGZyb20gJy4uL3V0aWxzL3Njcm9sbFRvVG9wJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzZXRQcm9kdWN0SW1hZ2VzKCRlbCkge1xuICBjb25zdCBudW1TbGlkZXMgPSAkZWwuZmluZCgnW2RhdGEtcHJvZHVjdC1pbWFnZV0nKS5sZW5ndGggLSAxO1xuICBjb25zdCBtYWluU2xpZGUgPSAkZWwuZmluZCgnW2RhdGEtcHJvZHVjdC1pbWFnZV0nKS5pbmRleCgnW2RhdGEtcHJvZHVjdC1tYWluLWltYWdlXScpO1xuXG4gICRlbC5zbGljaygnc2xpY2tHb1RvJywgbWFpblNsaWRlKTtcbiAgJGVsLnNsaWNrKCdzbGlja1JlbW92ZScsIG51bVNsaWRlcyk7XG4gIHNjcm9sbFRvVG9wKCk7XG59XG4iLCJpbXBvcnQgc2xpY2sgZnJvbSAnc2xpY2stY2Fyb3VzZWwnO1xuaW1wb3J0IHByb2R1Y3RWaWV3VGVtcGxhdGVzIGZyb20gJy4vcHJvZHVjdFZpZXdUZW1wbGF0ZXMnO1xuaW1wb3J0IFByb2R1Y3RJbWFnZXMgZnJvbSAnLi9Qcm9kdWN0SW1hZ2VzJztcbmltcG9ydCBiYWd1ZXR0ZUJveCBmcm9tICdiYWd1ZXR0ZWJveC5qcyc7XG5pbXBvcnQgSW1hZ2Vab29tIGZyb20gJy4vSW1hZ2Vab29tJztcbmltcG9ydCBpbWFnZXNMb2FkZWQgZnJvbSAnaW1hZ2VzbG9hZGVkJztcbmltcG9ydCBzY3JvbGxUb1RvcCBmcm9tICcuLi91dGlscy9zY3JvbGxUb1RvcCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhcmlhdGlvbkltZ1ByZXZpZXcocHJvZHVjdEltYWdlVXJsLCB6b29tSW1hZ2VVcmwsIGFsdCwgaW1hZ2VJZCkge1xuICBjb25zdCBwcm9kdWN0SW1ncyA9ICcucHJvZHVjdC1zbGlkZXMtd3JhcCc7XG5cbiAgLy8gT25seSBhcHBlbmQgaWYgaW1hZ2UgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAvLyBPdGhlcndpc2UsIHNjcm9sbCB0byBpdC5cbiAgaWYgKCEkKGBpbWdbc3JjPVwiJHtwcm9kdWN0SW1hZ2VVcmx9XCJdYCkubGVuZ3RoKSB7XG4gICAgY29uc3QgbnVtU2xpZGVzID0gJCgnW2RhdGEtcHJvZHVjdC1pbWFnZV0nKS5sZW5ndGg7XG5cbiAgICBpZiAoJCgnW2RhdGEtcHJvZHVjdC1pbWFnZS12YXJpYW50XScpLmxlbmd0aCkge1xuICAgICAgJChwcm9kdWN0SW1ncykuc2xpY2soJ3NsaWNrUmVtb3ZlJywgbnVtU2xpZGVzIC0gMSk7XG4gICAgfVxuXG4gICAgYmFndWV0dGVCb3guZGVzdHJveSgpO1xuXG4gICAgLy8gQWRkIGNhcm91c2VsIGltYWdlXG4gICAgJChwcm9kdWN0SW1ncykuc2xpY2soJ3NsaWNrQWRkJywgcHJvZHVjdFZpZXdUZW1wbGF0ZXMudmFyaWF0aW9uSW1hZ2Uoe1xuICAgICAgcHJvZHVjdEltYWdlU3JjOiBwcm9kdWN0SW1hZ2VVcmwsXG4gICAgICB6b29tSW1hZ2VTcmM6IHpvb21JbWFnZVVybCxcbiAgICAgIGFsdDogYWx0XG4gICAgfSkpO1xuXG4gICAgaW1hZ2VzTG9hZGVkKHByb2R1Y3RJbWdzLCB7IGJhY2tncm91bmQ6IHRydWUgfSwgKCkgPT4ge1xuICAgICAgYmFndWV0dGVCb3gucnVuKCcucHJvZHVjdC1zbGlkZXMtd3JhcCcsIHt9KTtcblxuICAgICAgJChwcm9kdWN0SW1ncykuc2xpY2soJ3NsaWNrR29UbycsIG51bVNsaWRlcyArIDEpO1xuXG4gICAgICAvLyBJbWFnZSB6b29tIGZvciBuZXdseSBhZGRlZCBpbWFnZVxuICAgICAgJChwcm9kdWN0SW1ncykuZmluZCgnW2RhdGEtcHJvZHVjdC1pbWFnZV0nKS5lYWNoKChpLCBlbCkgPT4ge1xuICAgICAgICBuZXcgSW1hZ2Vab29tKGVsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3Mgd2lzaGxpc3REcm9wZG93biB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZHJvcGRvd24gPSAnW2RhdGEtd2lzaGxpc3QtZHJvcGRvd25dJztcbiAgICB0aGlzLnRvZ2dsZSA9ICdbZGF0YS13aXNobGlzdC10b2dnbGVdJztcbiAgICB0aGlzLnBhbmVsID0gJ1tkYXRhLXdpc2hsaXN0LXBhbmVsXSc7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgdGhpcy50b2dnbGUsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlRHJvcGRvd24oZXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgX3RvZ2dsZURyb3Bkb3duKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICQoZXZlbnQuY3VycmVudFRhcmdldClcbiAgICAgIC5jbG9zZXN0KHRoaXMuZHJvcGRvd24pXG4gICAgICAuZmluZCh0aGlzLnBhbmVsKVxuICAgICAgLnJldmVhbGVyKCd0b2dnbGUnKTtcblxuICAgICQodGhpcy50b2dnbGUpXG4gICAgICAuZmlsdGVyKCQodGhpcy50b2dnbGUpLm5vdCgkKGV2ZW50LmN1cnJlbnRUYXJnZXQpKSlcbiAgICAgIC5jbG9zZXN0KHRoaXMuZHJvcGRvd24pXG4gICAgICAuZmluZCh0aGlzLnBhbmVsKVxuICAgICAgLnJldmVhbGVyKCdoaWRlJyk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcm1WYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmZvcm1TZWxlY3RvciA9ICdbZGF0YS12YWxpZGF0ZWQtZm9ybV0nO1xuXG4gICAgdGhpcy52YWxpZGF0aW9uT3B0aW9ucyA9IHt9O1xuXG4gICAgdGhpcy52YWxpZGF0aW9uTWVzc2FnZXMgPSB7XG4gICAgICByZXF1aXJlZCAgICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBlbWFpbCAgICAgICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uRW1haWwsXG4gICAgICBudW1iZXIgICAgICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uTnVtYmVyLFxuICAgICAgbnVtTWF4ICAgICAgOiB0aGlzLmNvbnRleHQudmFsaWRhdGlvbk51bWJlck1heCxcbiAgICAgIG51bU1pbiAgICAgIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25OdW1iZXJNaW4sXG4gICAgICBudW1SYW5nZSAgICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uTnVtYmVyUmFuZ2UsXG4gICAgICBtYXhMZW5ndGggICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uTWF4TGVuZ3RoLFxuICAgICAgbWluTGVuZ3RoICAgOiB0aGlzLmNvbnRleHQudmFsaWRhdGlvbk1pbkxlbmd0aCxcbiAgICAgIG1heENoZWNrZWQgIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25NYXhDaGVja2VkLFxuICAgICAgbWluQ2hlY2tlZCAgOiB0aGlzLmNvbnRleHQudmFsaWRhdGlvbk1pbkNoZWNrZWQsXG4gICAgICBtYXhTZWxlY3RlZCA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uTWF4U2VsZWN0ZWQsXG4gICAgICBtaW5TZWxlY3RlZCA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uTWluU2VsZWN0ZWQsXG4gICAgICBub3RFcXVhbCAgICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uTm90RXF1YWwsXG4gICAgICBkaWZmZXJlbnQgICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uRGlmZmVyZW50LFxuICAgIH07XG4gIH1cblxuICAvKlxuICAgKiBJbml0aWFsaXplIHZhbGlkYXRpb24gb24gYWxsIG1hdGNoaW5nIGZvcm1zIG9uIHBhZ2UgbG9hZFxuICAgKi9cbiAgaW5pdEdsb2JhbCgpIHtcbiAgICAkKHRoaXMuZm9ybVNlbGVjdG9yKS52YWxpZGV0dGEodGhpcy5vcHRpb25zLCB0aGlzLnZhbGlkYXRpb25NZXNzYWdlcyk7XG4gIH1cblxuICAvKlxuICAgKiBNYW51YWxseSBpbml0aWFsaXplIHZhbGlkYXRpb24gb24gdGFyZ2V0IGZvcm1cbiAgICpcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRmb3JtIC0gdGFyZ2V0IGZvcm0gdG8gdmFsaWRhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGxvY2FsT3B0aW9ucyAtIGEgc2V0IG9mIG9wdGlvbnMgc2VwYXJhdGUgZnJvbSB0aGUgb25lcyBkZWZpbmVkIGhlcmUgKG9wdGlvbmFsKVxuICAgKi9cbiAgaW5pdFNpbmdsZSgkZm9ybSwgbG9jYWxPcHRpb25zKSB7XG4gICAgY29uc3QgY3VzdG9tT3B0aW9ucyA9IGxvY2FsT3B0aW9ucyA/IGxvY2FsT3B0aW9ucyA6IHRoaXMudmFsaWRhdGlvbk9wdGlvbnM7XG4gICAgJCgkZm9ybSkudmFsaWRldHRhKGN1c3RvbU9wdGlvbnMsIHRoaXMudmFsaWRhdGlvbk1lc3NhZ2VzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi4vZ2xvYmFsL3N2Z0ljb24nO1xuXG4vKipcbiAqIFRvZ2dsZSBhIHByb2dyZXNzIGJ1dHRvbiBzdGF0ZSB3aXRoIGFsdGVybmF0ZSB0ZXh0XG4gKiB0aGUgYnV0dG9uIG5lZWRzIGEgY2xhc3Mgb2YgYnV0dG9uLXByb2dyZXNzXG4gKiB0aGUgYnV0dG9uIHRleHQgbmVlZHMgdG8gYmUgd3JhcHBlZCBpbiBhbiBleHRyYSAuYnV0dG9uLXRleHQgZWxlbWVudCB3aXRoaW4gdGhlIGJ1dHRvbiBlbGVtZW50IGl0c2VsZlxuICogdGhlIGJ1dHRvbiBzaG91bGQgcHJvYmFibHkgaGF2ZSBhIGRhdGEtcHJvZ3Jlc3MtdGV4dCBhdHRyaWJ1dGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmVzc0J1dHRvbiB7XG4gIHByb2dyZXNzKCRidXR0b24pIHtcbiAgICAvLyBjYWNoZSB0aGUgY3VycmVudCBidXR0b24gdGV4dFxuICAgICRidXR0b24uZGF0YSgnZGVmYXVsdFRleHQnLCAkYnV0dG9uLnRleHQoKSk7XG5cbiAgICBjb25zdCBwcm9ncmVzc1RleHQgPSAkYnV0dG9uLmF0dHIoJ2RhdGEtcHJvZ3Jlc3MtdGV4dCcpIHx8ICRidXR0b24udGV4dCgpO1xuICAgIGNvbnN0IHNwaW5uZXIgPSAkYnV0dG9uLmhhc0NsYXNzKCdzcGlubmVyJykgPyBzdmdJY29uKCdzcGlubmVyJykgOiAnJztcblxuICAgICRidXR0b25cbiAgICAgIC5hZGRDbGFzcygncHJvZ3Jlc3MnKVxuICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJylcbiAgICAgIC5hcHBlbmQoc3Bpbm5lcilcbiAgICAgIC5maW5kKCcuYnV0dG9uLXRleHQnKVxuICAgICAgLmh0bWwocHJvZ3Jlc3NUZXh0KTtcbiAgfVxuXG4gIGNvbXBsZXRlKCRidXR0b24pIHtcbiAgICBjb25zdCBkZWZhdWx0VGV4dCA9ICRidXR0b24uZGF0YSgnZGVmYXVsdFRleHQnKTtcblxuICAgICRidXR0b25cbiAgICAgIC5yZW1vdmVDbGFzcygncHJvZ3Jlc3MnKVxuICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgZmFsc2UpXG4gICAgICAuZmluZCgnLmJ1dHRvbi10ZXh0JylcbiAgICAgIC5odG1sKGRlZmF1bHRUZXh0KVxuICAgICAgLm5leHQoJy5pY29uLXNwaW5uZXInKVxuICAgICAgLnJlbW92ZSgpO1xuICB9XG59XG4iLCJjb25zdCBjaGFuZ2VXaXNobGlzdFBhZ2luYXRpb25MaW5rcyA9ICh3aXNobGlzdFVybCwgLi4ucGFnaW5hdGlvbkl0ZW1zKSA9PiAkLmVhY2gocGFnaW5hdGlvbkl0ZW1zLCAoXywgJGl0ZW0pID0+IHtcbiAgICBpZiAoJGl0ZW0ubGVuZ3RoICYmICEkaXRlbS5hdHRyKCdocmVmJykuaW5jbHVkZXMoJ3BhZ2U9JykpIHtcbiAgICAgICAgY29uc3QgcGFnZU51bWJlciA9ICRpdGVtLmF0dHIoJ2hyZWYnKTtcbiAgICAgICAgJGl0ZW0uYXR0cignaHJlZicsIGAke3dpc2hsaXN0VXJsfXBhZ2U9JHtwYWdlTnVtYmVyfWApO1xuICAgIH1cbn0pO1xuXG4vKipcbiogaGVscHMgdG8gd2l0aGRyYXcgZGlmZmVyZW5jZXMgaW4gc3RydWN0dXJlcyBhcm91bmQgdGhlIHN0ZW5jaWwgcmVzb3VyY2UgcGFnaW5hdGlvblxuKi9cblxuZXhwb3J0IGNvbnN0IHdpc2hsaXN0UGFnaW5hdGlvbkhlbHBlciA9ICgpID0+IHtcbiAgICBjb25zdCAkcGFnaW5hdGlvbiA9ICQoJy5wYWdpbmF0aW9uJyk7XG5cbiAgICBpZiAoISRwYWdpbmF0aW9uLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgY29uc3QgJG5leHRJdGVtID0gJCgnLm5leHQnLCAkcGFnaW5hdGlvbik7XG4gICAgY29uc3QgJHByZXZJdGVtID0gJCgnLnByZXZpb3VzJywgJHBhZ2luYXRpb24pO1xuICAgIGNvbnN0IGN1cnJlbnRIcmVmID0gJCgnW2RhdGEtcGFnaW5hdGlvbi1jdXJyZW50LXBhZ2UtbGlua10nKS5hdHRyKCdocmVmJyk7XG4gICAgY29uc3QgcGFydGlhbFBhZ2luYXRpb25VcmwgPSBjdXJyZW50SHJlZi5zcGxpdCgncGFnZT0nKS5zaGlmdCgpO1xuXG4gICAgY2hhbmdlV2lzaGxpc3RQYWdpbmF0aW9uTGlua3MocGFydGlhbFBhZ2luYXRpb25VcmwsICRwcmV2SXRlbSwgJG5leHRJdGVtKTtcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzY3JvbGxUb1RvcCgpIHtcbiAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xuICAgIHNjcm9sbFRvcDogJCgnLnNpdGUtY2FudmFzJykub2Zmc2V0KCkudG9wXG4gIH0pO1xufVxuIiwiaW1wb3J0IHJlcXVlc3QgZnJvbSAnLi4vbGliL3JlcXVlc3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICB0aGlzLnJlbW90ZVZlcnNpb24gPSB2ZXJzaW9uIHx8ICd2MSc7XG4gICAgICAgIHRoaXMucmVtb3RlQmFzZUVuZHBvaW50ID0gJy9yZW1vdGUvJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIFsnR0VUJywgJ1BPU1QnLCAnUFVUJywgJ0RFTEVURSddXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW90ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgbWFrZVJlcXVlc3QodXJsLCBtZXRob2QsIG9wdGlvbnMsIHJlbW90ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmVxdWVzdCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zOiBvcHRpb25zLFxuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIFsnR0VUJywgJ1BPU1QnLCAnUFVUJywgJ0RFTEVURSddXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlbW90ZVJlcXVlc3QoZW5kcG9pbnQsIG1ldGhvZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcmVtb3RlVXJsID0gdGhpcy5yZW1vdGVCYXNlRW5kcG9pbnQgKyB0aGlzLnJlbW90ZVZlcnNpb24gKyBlbmRwb2ludDtcblxuICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KHJlbW90ZVVybCwgbWV0aG9kLCBvcHRpb25zLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEJvZGxFdmVudHNDYXJ0IGZyb20gJy4uL2JvZGwvZW1pdHRlcnMvY2FydCc7XG5pbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IEhvb2tzIGZyb20gJy4uL2hvb2tzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIHN1cGVyKHZlcnNpb24pO1xuICAgICAgICB0aGlzLmJvZGxFdmVudHNDYXJ0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRCb2RsRXZlbnRzQ2FydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJvZGxFdmVudHNDYXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmJvZGxFdmVudHNDYXJ0ID0gbmV3IEJvZGxFdmVudHNDYXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYm9kbEV2ZW50c0NhcnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY29sbGVjdGlvbiBvZiBDYXJ0cy4gRm9yIG5vdywgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIGFuIGFycmF5IG9mIGEgc2luZ2xlIGNhcnQgYXMgbXVsdGlwbGUgY2FydHMgcGVyIHNlc3Npb25cbiAgICAgKiBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgZ2V0Q2FydHMob3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgdXJsID0gJy9hcGkvc3RvcmVmcm9udC9jYXJ0cyc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHVybCA9IHRoaXMuaW5jbHVkZU9wdGlvbnModXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3QodXJsLCAnR0VUJywgb3B0aW9ucywgdHJ1ZSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgQ2FydCdzIGRldGFpbHMsIGVpdGhlciB3aXRoIG9yIHdpdGhvdXQgUHJvZHVjdCBPcHRpb24gc2VsZWN0aW9ucy5cbiAgICAgKiBDYW4gYWxzbyBiZSB1c2VkIHRvIGdldCBhIHBhcnRpY3VsYXIgY2FydCBwcm92aWRlZCBhIGNhcnRJZCBpbiB0aGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXRDYXJ0KG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICAgICAgLyogSWYgbm8gY2FydCBJRCBpcyBwcm92aWRlZCwgZ2V0IHRoZSBjb2xsZWN0aW9uIG9mIGNhcnRzIGFuZCByZXR1cm4gdGhlIGZpcnN0IG9uZSAqL1xuICAgICAgICBpZiAoIW9wdGlvbnMuY2FydElkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXJ0cyhvcHRpb25zLCAoZXJyLCByZXNwb25zZSkgPT4gY2FsbGJhY2soZXJyLCByZXNwb25zZVswXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHVybCA9IGAvYXBpL3N0b3JlZnJvbnQvY2FydHMvJHtvcHRpb25zLmNhcnRJZH1gO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgICAgICB1cmwgPSB0aGlzLmluY2x1ZGVPcHRpb25zKHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KHVybCwgJ0dFVCcsIG9wdGlvbnMsIHRydWUsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdW1tYXJ5IGZvciB0aGUgY3VycmVudCBwcmltYXJ5IGNhcnQuIFRoaXMgc3VtbWFyeSBkb2VzIG5vdCBpbmNsdWRlIHRoZSBmdWxsIGRldGFpbHMgb2YgdGhlIGNhcnQsIGJ1dFxuICAgICAqIHRoZSByZXNwb25zZSB0aW1lIGlzIG11Y2ggZmFzdGVyIGFuZCBpdCdzIGFwcHJvcHJpYXRlIGZvciBzdW1tYXJ5IHVzZSBjYXNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXRDYXJ0U3VtbWFyeShvcHRpb25zID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHVybCA9ICcvYXBpL3N0b3JlZnJvbnQvY2FydC1zdW1tYXJ5JztcblxuICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KHVybCwgJ0dFVCcsIG9wdGlvbnMsIHRydWUsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBwYXJhbWV0ZXJzIHRvIGEgVVJMIG5lZWRlZCB0byBnZXQgcHJvZHVjdCBvcHRpb24gZGV0YWlscyBvbiBjYXJ0IGxpbmUgaXRlbXNcbiAgICAgKiBAcGFyYW0gdXJsXG4gICAgICovXG4gICAgaW5jbHVkZU9wdGlvbnModXJsKSB7XG4gICAgICAgIHJldHVybiBgJHt1cmx9P2luY2x1ZGU9bGluZUl0ZW1zLnBoeXNpY2FsSXRlbXMub3B0aW9ucyxsaW5lSXRlbXMuZGlnaXRhbEl0ZW1zLm9wdGlvbnNgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHN1bSBvZiB0aGUgY2FydCBsaW5lIGl0ZW0gcXVhbnRpdGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGdldENhcnRRdWFudGl0eShvcHRpb25zID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FydFN1bW1hcnkob3B0aW9ucywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBxdWFudGl0eSA9IDA7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VcbiAgICAgICAgICAgICAgICAmJiByZXNwb25zZS5zdGF0dXMgIT09IDIwNFxuICAgICAgICAgICAgICAgICYmIHJlc3BvbnNlLnRvdGFsX3F1YW50aXR5KSB7XG4gICAgICAgICAgICAgICAgcXVhbnRpdHkgPSByZXNwb25zZS50b3RhbF9xdWFudGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHF1YW50aXR5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5oYW5jZSB3aXRoIEJpZyBPcGVuIERhdGEgTGF5ZXIgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zvcm1EYXRhfSBmb3JtRGF0YVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgaXRlbUFkZChmb3JtRGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5oYW5kbGVJdGVtQWRkKGZvcm1EYXRhLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEJvZGxFdmVudHNDYXJ0KCkuZW1pdEFkZEl0ZW0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBpdGVtIHRvIGNhcnQgd2l0aCBvcHRpb25zICh2YXJpYW50cylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Rm9ybURhdGF9IGZvcm1EYXRhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBoYW5kbGVJdGVtQWRkKGZvcm1EYXRhLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnJlbW90ZVJlcXVlc3QoJy9jYXJ0L2FkZCcsICdQT1NUJywgeyBmb3JtRGF0YSB9LCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW1pdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgSG9va3MuZW1pdCgnY2FydC1pdGVtLWFkZC1yZW1vdGUnLCBlbWl0RGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNhcnQgaXRlbSBxdWFudGl0eVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBpdGVtSWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxGdW5jdGlvbn0gcXR5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBjYWxsYmFja1xuICAgICAqL1xuICAgIGl0ZW1VcGRhdGUoaXRlbUlkLCBxdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBjYWxsYmFja0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBsZXQgaXRlbXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbUlkKSAmJiB0eXBlb2YgcXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IHF0eTtcbiAgICAgICAgICAgIGl0ZW1zID0gaXRlbUlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbXMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogaXRlbUlkLFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcXR5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGUoaXRlbXMsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbWl0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAocXR5ID09PSAwICYmICFlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEJvZGxFdmVudHNDYXJ0KCkuZW1pdFJlbW92ZUl0ZW0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBIb29rcy5lbWl0KCdjYXJ0LWl0ZW0tdXBkYXRlLXJlbW90ZScsIGVtaXREYXRhKTtcbiAgICAgICAgICAgIGNhbGxiYWNrQXJnKGVyciwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlIHdpdGggQmlnIE9wZW4gRGF0YSBMYXllciBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGl0ZW1SZW1vdmUoaXRlbUlkLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmhhbmRsZUl0ZW1SZW1vdmUoaXRlbUlkLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEJvZGxFdmVudHNDYXJ0KCkuZW1pdFJlbW92ZUl0ZW0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjYXJ0IGl0ZW1zXG4gICAgICpcbiAgICAgKiBDYWxscyB0aGUgaW50ZXJuYWwgdXBkYXRlIGZ1bmN0aW9uIHdpdGggcXVhbnRpdHk6IDBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGhhbmRsZUl0ZW1SZW1vdmUoaXRlbUlkLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbUlkLFxuICAgICAgICAgICAgICAgIHF1YW50aXR5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLnVwZGF0ZShpdGVtcywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVtaXREYXRhID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEhvb2tzLmVtaXQoJ2NhcnQtaXRlbS1yZW1vdmUtcmVtb3RlJywgZW1pdERhdGEpO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBnaWZ0d3JhcHBpbmcgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbH0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXRJdGVtR2lmdFdyYXBwaW5nT3B0aW9ucyhpdGVtSWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbGV0IGNhbGxiYWNrQXJnID0gY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbW90ZVJlcXVlc3QoYC9naWZ0LXdyYXBwaW5nLyR7aXRlbUlkfWAsICdHRVQnLCBvcHRzLCBjYWxsYmFja0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3VibWl0IGdpZnR3cmFwcGluZyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbUlkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBzdWJtaXRJdGVtR2lmdFdyYXBwaW5nT3B0aW9uKGl0ZW1JZCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnJlbW90ZVJlcXVlc3QoYC9naWZ0LXdyYXBwaW5nLyR7aXRlbUlkfWAsICdQT1NUJywgeyBwYXJhbXMgfSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjYXJ0IGl0ZW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgdXBkYXRlKGl0ZW1zLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZW1vdGVSZXF1ZXN0KCcvY2FydC91cGRhdGUnLCAnUE9TVCcsIHsgcGFyYW1zOiBwYXlsb2FkIH0sIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FydCBjb250ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgZ2V0Q29udGVudChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGxldCBjYWxsYmFja0FyZyA9IGNhbGxiYWNrO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2tBcmcgPSBvcHRzO1xuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWtlUmVxdWVzdCgnL2NhcnQucGhwJywgJ0dFVCcsIG9wdHMsIGZhbHNlLCBjYWxsYmFja0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNhcnQgc2hpcHBpbmcgcXVvdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxPYmplY3R9IHJlbmRlcldpdGhcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGdldFNoaXBwaW5nUXVvdGVzKHBhcmFtcywgcmVuZGVyV2l0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxiYWNrQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGxldCByZW5kZXJXaXRoQXJnID0gcmVuZGVyV2l0aDtcblxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrQXJnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IHJlbmRlcldpdGhBcmc7XG4gICAgICAgICAgICByZW5kZXJXaXRoQXJnID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJXaXRoQXJnKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRlbXBsYXRlID0gcmVuZGVyV2l0aEFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtb3RlUmVxdWVzdCgnL3NoaXBwaW5nLXF1b3RlJywgJ0dFVCcsIG9wdGlvbnMsIGNhbGxiYWNrQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJtaXQgc2hpcHBpbmcgcXVvdGUgYmFzZWQgb24gcXVvdGVJZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHF1b3RlSWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHN1Ym1pdFNoaXBwaW5nUXVvdGUocXVvdGVJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHNoaXBwaW5nX21ldGhvZDogcXVvdGVJZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZW1vdGVSZXF1ZXN0KCcvc2hpcHBpbmctcXVvdGUnLCAnUE9TVCcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIGNvdXBvbiBjb2RlIG9yIGdpZnQgY2VydGlmaWNhdGUgdG8gdGhlIGNhcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhcHBseUNvZGUoY29kZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVtb3RlUmVxdWVzdCgnL2FwcGx5LWNvZGUnLCAnUE9TVCcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIGNvdXBvbiBjb2RlIG9yIGdpZnQgY2VydGlmaWNhdGUgdG8gdGhlIGNhcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhcHBseUdpZnRDZXJ0aWZpY2F0ZShjb2RlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZW1vdGVSZXF1ZXN0KCcvZ2lmdC1jZXJ0aWZpY2F0ZXMnLCAnUE9TVCcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBDb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcbiAgICAgICAgLy8gY2FsbCBwYXJlbnRcbiAgICAgICAgc3VwZXIodmVyc2lvbik7XG5cbiAgICAgICAgLy8gc2V0IHVwIGNsYXNzIHZhcmlhYmxlc1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gJy9jb3VudHJ5LXN0YXRlcy8nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogR2V0IGNvdW50cnkgZGF0YSBieSBpZCB3cmFwcGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGdldEJ5SWQoaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZW5kcG9pbnQgKyBpZDtcblxuICAgICAgICB0aGlzLnJlbW90ZVJlcXVlc3QodXJsLCAnR0VUJywge30sIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY291bnRyeSBkYXRhIGJ5IGNvdW50cnkgbmFtZVxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgZ2V0QnlOYW1lKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZW5kcG9pbnQgKyBuYW1lO1xuXG4gICAgICAgIHRoaXMucmVtb3RlUmVxdWVzdCh1cmwsICdHRVQnLCB7fSwgY2FsbGJhY2spO1xuICAgIH1cbn1cbiIsImltcG9ydCByZXF1ZXN0IGZyb20gJy4uL2xpYi9yZXF1ZXN0JztcblxuaW1wb3J0IENvdW50cnlBcGkgZnJvbSAnLi9jb3VudHJpZXMnO1xuaW1wb3J0IFByb2R1Y3RBcGkgZnJvbSAnLi9wcm9kdWN0JztcbmltcG9ydCBQcm9kdWN0QXR0cmlidXRlc0FwaSBmcm9tICcuL3Byb2R1Y3QtYXR0cmlidXRlcyc7XG5pbXBvcnQgU2VhcmNoQXBpIGZyb20gJy4vc2VhcmNoJztcbmltcG9ydCBDYXJ0QXBpIGZyb20gJy4vY2FydCc7XG5pbXBvcnQgV2lzaGxpc3QgZnJvbSAnLi93aXNobGlzdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJlcXVlc3QgYSBwYWdlIHZpYSBhamF4XG4gKlxuICogQHBhcmFtIHVybFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjYWxsYmFja1xuICovXG5pbnRlcm5hbHMuZ2V0UGFnZSA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgcmVxdWVzdCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcmVxdWVzdE9wdGlvbnM6IG9wdGlvbnMsXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuaW50ZXJuYWxzLmdldFBhZ2VCeUdRTCA9IGZ1bmN0aW9uIChwYWdlLCBjYWxsYmFjaykge1xuICAgIHJlcXVlc3QoJy9ncmFwaHFsLXJlbmRlcicsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcmVxdWVzdE9wdGlvbnM6IHtcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlX25hbWU6IHBhZ2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjb3VudHJ5OiBuZXcgQ291bnRyeUFwaSgpLFxuICAgIHByb2R1Y3RBdHRyaWJ1dGVzOiBuZXcgUHJvZHVjdEF0dHJpYnV0ZXNBcGkoKSxcbiAgICBwcm9kdWN0OiBuZXcgUHJvZHVjdEFwaSgpLFxuICAgIHNlYXJjaDogbmV3IFNlYXJjaEFwaSgpLFxuICAgIGNhcnQ6IG5ldyBDYXJ0QXBpKCksXG4gICAgd2lzaGxpc3Q6IG5ldyBXaXNobGlzdCgpLFxuICAgIGdldFBhZ2U6IGludGVybmFscy5nZXRQYWdlLFxuICAgIGdldFBhZ2VCeUdRTDogaW50ZXJuYWxzLmdldFBhZ2VCeUdRTCxcbn07XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IEhvb2tzIGZyb20gJy4uL2hvb2tzJztcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnLi4vbGliL3F1ZXJ5LXN0cmluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICAvLyBjYWxsIHBhcmVudFxuICAgICAgICBzdXBlcih2ZXJzaW9uKTtcblxuICAgICAgICAvLyBzZXQgdXAgY2xhc3MgdmFyaWFibGVzXG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSAnL3Byb2R1Y3QtYXR0cmlidXRlcy8nO1xuICAgICAgICB0aGlzLmluQ2FydEVuZHBvaW50ID0gJy9jb25maWd1cmUtb3B0aW9ucy8nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9kdWN0SWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgb3B0aW9uQ2hhbmdlKHByb2R1Y3RJZCwgcGFyYW1zLCB0ZW1wbGF0ZSA9IG51bGwsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUFyZyA9IHRlbXBsYXRlO1xuICAgICAgICBsZXQgY2FsbGJhY2tBcmcgPSBjYWxsYmFjaztcblxuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlQXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IHRlbXBsYXRlQXJnO1xuICAgICAgICAgICAgdGVtcGxhdGVBcmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW1vdGVSZXF1ZXN0KHRoaXMuZW5kcG9pbnQgKyBwcm9kdWN0SWQsICdQT1NUJywgeyBwYXJhbXM6IHBhcnNlKHBhcmFtcyksIHRlbXBsYXRlOiB0ZW1wbGF0ZUFyZyB9LCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW1pdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgSG9va3MuZW1pdCgncHJvZHVjdC1vcHRpb25zLWNoYW5nZS1yZW1vdGUnLCBlbWl0RGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFja0FyZyhlcnIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW1JZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBjb25maWd1cmVJbkNhcnQoaXRlbUlkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmVtb3RlUmVxdWVzdCh0aGlzLmluQ2FydEVuZHBvaW50ICsgaXRlbUlkLCAnR0VUJywgcGFyYW1zLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICAvLyBjYWxsIHBhcmVudFxuICAgICAgICBzdXBlcih2ZXJzaW9uKTtcblxuICAgICAgICAvLyBzZXQgdXAgY2xhc3MgdmFyaWFibGVzXG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSAnL3Byb2R1Y3RzLnBocD9wcm9kdWN0SWQ9JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9kdWN0SWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXRCeUlkKHByb2R1Y3RJZCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmVuZHBvaW50ICsgcHJvZHVjdElkO1xuICAgICAgICBsZXQgcGFyYW1zQXJnID0gcGFyYW1zO1xuICAgICAgICBsZXQgY2FsbGJhY2tBcmcgPSBjYWxsYmFjaztcblxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc0FyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2tBcmcgPSBwYXJhbXNBcmc7XG4gICAgICAgICAgICBwYXJhbXNBcmcgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3QodXJsLCAnR0VUJywgcGFyYW1zQXJnLCBmYWxzZSwgY2FsbGJhY2tBcmcpO1xuICAgIH1cbn1cbiIsImltcG9ydCBIb29rcyBmcm9tICcuLi9ob29rcyc7XG5pbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBDb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcbiAgICAgICAgLy8gY2FsbCBwYXJlbnRcbiAgICAgICAgc3VwZXIodmVyc2lvbik7XG5cbiAgICAgICAgLy8gc2V0IHVwIGNsYXNzIHZhcmlhYmxlc1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gJy9zZWFyY2gucGhwP3NlYXJjaF9xdWVyeT0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzZWFyY2ggcmVzdWx0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHNlYXJjaChxdWVyeSwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmVuZHBvaW50ICsgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KTtcbiAgICAgICAgbGV0IHBhcmFtc0FyZyA9IHBhcmFtcztcbiAgICAgICAgbGV0IGNhbGxiYWNrQXJnID0gY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gcGFyYW1zQXJnO1xuICAgICAgICAgICAgcGFyYW1zQXJnID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBIb29rcy5lbWl0KCdzZWFyY2gtcXVpY2stcmVtb3RlJywgcXVlcnkpO1xuICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KHVybCwgJ0dFVCcsIHBhcmFtc0FyZywgZmFsc2UsIGNhbGxiYWNrQXJnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2Uge1xuICAgIGl0ZW1BZGQod2lzaGxpc3RJZCwgcHJvZHVjdElkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB1cmwgPSBgL3dpc2hsaXN0LnBocD9hY3Rpb249YWRkJndpc2hsaXN0aWQ9JHt3aXNobGlzdElkfSZwcm9kdWN0X2lkPSR7cHJvZHVjdElkfWA7XG4gICAgICAgIGxldCBvcHRzID0gb3B0aW9ucztcbiAgICAgICAgbGV0IGNhbGxiYWNrRm4gPSBjYWxsYmFjaztcblxuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrRm4gPSBvcHRzO1xuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWtlUmVxdWVzdCh1cmwsICdQT1NUJywgb3B0cywgZmFsc2UsIGNhbGxiYWNrRm4pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGdldEJPRExFdmVudHMgfSBmcm9tICcuLi9oZWxwZXJzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJvZGxFdmVudHMgPSBnZXRCT0RMRXZlbnRzKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0RXZlbnRJZCwgaXNCT0RMRW5hYmxlZCB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IEJhc2UgZnJvbSAnLi9iYXNlJztcblxuY2xhc3MgQ2FydCBleHRlbmRzIEJhc2Uge1xuICAgIGVtaXRBZGRJdGVtKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmJvZGxFdmVudHMuQWRkQ2FydEl0ZW1FdmVudC5DUkVBVEUsIHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBlbWl0UmVtb3ZlSXRlbShyZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRFbWl0UmVtb3ZlSXRlbShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmJvZGxFdmVudHMuUmVtb3ZlQ2FydEl0ZW1FdmVudC5DUkVBVEUsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3VsZEVtaXRSZW1vdmVJdGVtKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmxpbmVfaXRlbXM/Lmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgZW1pdChldmVudE5hbWUsIHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLnByZXBhcmVQYXlsb2FkKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5ib2RsRXZlbnRzLmNhcnQuZW1pdChldmVudE5hbWUsIHBheWxvYWQpO1xuICAgIH1cblxuICAgIHByZXBhcmVQYXlsb2FkKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChpc0JPRExFbmFibGVkKCkgJiYgIXJlc3BvbnNlLmRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXZlbnRfaWQ6IGdldEV2ZW50SWQoKSxcbiAgICAgICAgICAgICAgICBjaGFubmVsX2lkOiByZXNwb25zZS5kYXRhLmNoYW5uZWxfaWQsXG4gICAgICAgICAgICAgICAgY3VycmVuY3k6IHJlc3BvbnNlLmRhdGEuY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgcHJvZHVjdF92YWx1ZTogcmVzcG9uc2UuZGF0YS5wcm9kdWN0X3ZhbHVlLFxuICAgICAgICAgICAgICAgIGxpbmVfaXRlbXM6IHJlc3BvbnNlLmRhdGEubGluZV9pdGVtcy5tYXAoKGl0ZW0pID0+ICh7IC4uLml0ZW0sIHByb2R1Y3RfaWQ6IFN0cmluZyhpdGVtLnByb2R1Y3RfaWQpIH0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXJ0O1xuIiwiaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5cbmV4cG9ydCBjb25zdCBpc0JPRExFbmFibGVkID0gKCkgPT4gdHlwZW9mIHdpbmRvdy5ib2RsRXZlbnRzICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGNvbnN0IEZha2VCT0RMRXZlbnRzID0ge1xuICAgIGNhcnQ6IHtcbiAgICAgICAgYWRkSXRlbTogKCkgPT4ge30sXG4gICAgICAgIHJlbW92ZUl0ZW06ICgpID0+IHt9LFxuICAgICAgICBlbWl0OiAoKSA9PiB7fSxcbiAgICB9LFxuICAgIEFkZENhcnRJdGVtRXZlbnQ6IHtcbiAgICAgICAgQ1JFQVRFOiAnY3JlYXRlX2FkZF9jYXJ0X2l0ZW0nLFxuICAgIH0sXG4gICAgUmVtb3ZlQ2FydEl0ZW1FdmVudDoge1xuICAgICAgICBDUkVBVEU6ICdjcmVhdGVfcmVtb3ZlX2NhcnRfaXRlbScsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFdmVudElkID0gKCkgPT4gdXVpZHY0KCk7XG5cbmV4cG9ydCBjb25zdCBnZXRCT0RMRXZlbnRzID0gKCkgPT4ge1xuICAgIGlmIChpc0JPRExFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5ib2RsRXZlbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBGYWtlQk9ETEV2ZW50cztcbn07XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgc3Vic2NyaWJlKGV2ZW50TmFtZSwgZWxlbWVudFNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgeyB0YXJnZXQgfSA9IGU7IHRhcmdldCAmJiB0YXJnZXQgIT09IHRoaXM7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5tYXRjaGVzKGVsZW1lbnRTZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRhcmdldCwgZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2VIb29rcyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2VIb29rcyB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGNhbGwgcGFyZW50XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5pdGVtQWRkKCk7XG4gICAgfVxuXG4gICAgaXRlbUFkZCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ3N1Ym1pdCcsICdbZGF0YS1jYXJ0LWl0ZW0tYWRkXScsIChldmVudCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NhcnQtaXRlbS1hZGQnLCBldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2VIb29rcyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2VIb29rcyB7fVxuIiwiaW1wb3J0IEJhc2VIb29rcyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2VIb29rcyB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGNhbGwgcGFyZW50XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW5jeVNlbGVjdG9yKCk7XG4gICAgfVxuXG4gICAgY3VycmVuY3lTZWxlY3RvcigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2lucHV0JywgJ1tkYXRhLWN1cnJlbmN5LXNlbGVjdG9yLXRvZ2dsZV0nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY3VycmVuY3lTZWxlY3Rvci10b2dnbGUnLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlSG9va3MgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBCYXNlSG9va3Mge1xuICAgIC8qKlxuICAgICAqIEBDb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBjYWxsIHBhcmVudFxuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuc2VhcmNoRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgc2VhcmNoRXZlbnRzKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgnY2xpY2snLCAnW2RhdGEtZmFjZXRlZC1zZWFyY2gtZmFjZXRdJywgKGV2ZW50LCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZmFjZXRlZFNlYXJjaC1mYWNldC1jbGlja2VkJywgZXZlbnQsIHRhcmdldCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKCdzdWJtaXQnLCAnW2RhdGEtZmFjZXRlZC1zZWFyY2gtcmFuZ2VdJywgKGV2ZW50LCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZmFjZXRlZFNlYXJjaC1yYW5nZS1zdWJtaXR0ZWQnLCBldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENhcnRIb29rcyBmcm9tICcuL2NhcnQnO1xuaW1wb3J0IENvb2tpZUhvb2tzIGZyb20gJy4vY29va2llJztcbmltcG9ydCBDdXJyZW5jeVNlbGVjdG9ySG9va3MgZnJvbSAnLi9jdXJyZW5jeS1zZWxlY3Rvcic7XG5pbXBvcnQgUHJvZHVjdEhvb2tzIGZyb20gJy4vcHJvZHVjdCc7XG5pbXBvcnQgU2VhcmNoSG9va3MgZnJvbSAnLi9zZWFyY2gnO1xuaW1wb3J0IEZhY2V0ZWRTZWFyY2hIb29rcyBmcm9tICcuL2ZhY2V0ZWQtc2VhcmNoJztcbmltcG9ydCBTb3J0QnlIb29rcyBmcm9tICcuL3NvcnQtYnknO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuaW50ZXJuYWxzLmNsYXNzZXMgPSB7XG4gICAgY2FydDogbmV3IENhcnRIb29rcygpLFxuICAgIGNvb2tpZTogbmV3IENvb2tpZUhvb2tzKCksXG4gICAgY3VycmVuY3lTZWxlY3RvcjogbmV3IEN1cnJlbmN5U2VsZWN0b3JIb29rcygpLFxuICAgIHByb2R1Y3Q6IG5ldyBQcm9kdWN0SG9va3MoKSxcbiAgICBzZWFyY2g6IG5ldyBTZWFyY2hIb29rcygpLFxuICAgIGZhY2V0ZWRTZWFyY2g6IG5ldyBGYWNldGVkU2VhcmNoSG9va3MoKSxcbiAgICBzb3J0Qnk6IG5ldyBTb3J0QnlIb29rcygpLFxufTtcblxuaW50ZXJuYWxzLnBhcnNlSG9va3MgPSBmdW5jdGlvbiAoaG9va05hbWUpIHtcbiAgICBjb25zdCBob29rVHlwZSA9IGhvb2tOYW1lLnNwbGl0KCctJylbMF07XG5cbiAgICBpZiAoaW50ZXJuYWxzLmNsYXNzZXNbaG9va1R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2hvb2tUeXBlfSBpcyBub3QgYSB2YWxpZCBob29rVHlwZWApO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMuY2xhc3Nlc1tob29rVHlwZV07XG59O1xuXG5jbGFzcyBIb29rcyB7XG4gICAgb24oaG9va05hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGhvb2sgPSBpbnRlcm5hbHMucGFyc2VIb29rcyhob29rTmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIGhvb2sub24oaG9va05hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBvZmYoaG9va05hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGhvb2sgPSBpbnRlcm5hbHMucGFyc2VIb29rcyhob29rTmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIGhvb2sub2ZmKGhvb2tOYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZW1pdChob29rTmFtZSkge1xuICAgICAgICBjb25zdCBob29rID0gaW50ZXJuYWxzLnBhcnNlSG9va3MoaG9va05hbWUpO1xuXG4gICAgICAgIHJldHVybiBob29rLmVtaXQoLi4uYXJndW1lbnRzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBIb29rcygpO1xuIiwiaW1wb3J0IEJhc2VIb29rcyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2VIb29rcyB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGNhbGwgcGFyZW50XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgb3B0aW9uc0NoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2NoYW5nZScsICdbZGF0YS1wcm9kdWN0LW9wdGlvbi1jaGFuZ2VdJywgKGV2ZW50LCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJvZHVjdC1vcHRpb24tY2hhbmdlJywgZXZlbnQsIHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlSG9va3MgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBCYXNlSG9va3Mge1xuICAgIC8qKlxuICAgICAqIEBDb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBjYWxsIHBhcmVudFxuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMucXVpY2tTZWFyY2goKTtcbiAgICB9XG5cbiAgICBxdWlja1NlYXJjaCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2lucHV0JywgJ1tkYXRhLXNlYXJjaC1xdWlja10nLCAoZXZlbnQsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzZWFyY2gtcXVpY2snLCBldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2VIb29rcyBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vbGliL2Nsb3Nlc3QnO1xuXG4vLyBpZSAxMSBkb2VzIG5vdCBzdXBwb3J0IG5hdGl2ZSBjbG9zZXN0XG5pZiAoIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xufVxuXG5pZiAoIUVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QpIHtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gY2xvc2VzdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBCYXNlSG9va3Mge1xuICAgIC8qKlxuICAgICAqIEBDb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBjYWxsIHBhcmVudFxuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuc29ydEJ5RXZlbnRzKCk7XG4gICAgfVxuXG4gICAgc29ydEJ5RXZlbnRzKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgnc3VibWl0JywgJ1tkYXRhLXNvcnQtYnldJywgKGV2ZW50LCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc29ydEJ5LXN1Ym1pdHRlZCcsIGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN1YnNjcmliZSgnY2hhbmdlJywgJ1tkYXRhLXNvcnQtYnldIHNlbGVjdCcsIChldmVudCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3NvcnRCeS1zZWxlY3QtY2hhbmdlZCcsIGV2ZW50LCB0YXJnZXQpO1xuXG4gICAgICAgICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3NvcnRCeS1zdWJtaXR0ZWQnLCBldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBpZSAxMSBkb2VzIG5vdCBzdXBwb3J0IG5hdGl2ZSBjbG9zZXN0IHNvIHVzZSB0aGlzIHBvbHlmaWxsIGZ1bmN0aW9uIGluc3RlYWQgdG8gZmluZCBjbG9zZXN0IG1hdGNoaW5nIHNlbGVjdG9yIHN0YXJ0aW5nIGZyb20gZWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zXG4gKiBAcmV0dXJucyB7YW55fSBtYXRjaGluZyBzZWxlY3RvciBvciBudWxsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsb3Nlc3Qocykge1xuICAgIGxldCBlbCA9IHRoaXM7XG5cbiAgICBkbyB7XG4gICAgICAgIGlmIChlbC5tYXRjaGVzKHMpKSByZXR1cm4gZWw7XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcblxuICAgIHJldHVybiBudWxsO1xufVxuIiwiLyoqXG4gKiBFbmNvZGVzIHN0cmluZyBieSBzdHJpY3RlciBydWxlc1xuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rZXZ2YS9zdHJpY3QtdXJpLWVuY29kZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqL1xuY29uc3QgZW5jb2RlID0gKHN0cmluZykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykucmVwbGFjZSgvWyEnKCkqXS9nLCAoeCkgPT4gYCUke3guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX1gKTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5LCB3aGVyZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBzbGljZSB0aWxsIHNlcGFyYXRvciBhbmQgdGhlIHNlY29uZCBpcyB0aGUgcmVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VwYXJhdG9yXG4gKi9cbmNvbnN0IHNwbGl0T25GaXJzdCA9IChzdHJpbmcsIHNlcGFyYXRvcikgPT4ge1xuICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gc3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICBpZiAoc2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbc3RyaW5nXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RyaW5nLnNsaWNlKDAsIHNlcGFyYXRvckluZGV4KSxcbiAgICAgICAgc3RyaW5nLnNsaWNlKHNlcGFyYXRvckluZGV4ICsgc2VwYXJhdG9yLmxlbmd0aCksXG4gICAgXTtcbn07XG5cbi8qKlxuICogU29ydHMgYXJyYXkgb3Igb2JqZWN0IGJ5IGtleXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaW5wdXRcbiAqL1xuY29uc3Qgc29ydEJ5S2V5cyA9IChpbnB1dCkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQuc29ydCgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzb3J0QnlLZXlzKE9iamVjdC5rZXlzKGlucHV0KSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBOdW1iZXIoYSkgLSBOdW1iZXIoYikpXG4gICAgICAgICAgICAubWFwKChrZXkpID0+IGlucHV0W2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiBpbnB1dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBpZiB0aGUga2V5IGV4aXN0cyBpbiB0aGUgb2JqZWN0IG9yIHRoZSB2YWx1ZSBpZiBkb2VuJ3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvclxuICovXG5jb25zdCBnZXRQYXJzZWRWYWx1ZSA9IChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikgPT4ge1xuICAgIGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBbXS5jb25jYXQoYWNjdW11bGF0b3Jba2V5XSwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBSZWR1Y2VyIHRoYXQgZm9ybWF0cyBhbmQgY29tYmluZXMga2V5LXZhbHVlIHBhaXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uc1xuICovXG5jb25zdCByZWR1Y2VCeUtleSA9IChvcHRpb25zKSA9PiAoa2V5KSA9PiAocmVzdWx0LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbLi4ucmVzdWx0LCBlbmNvZGUoa2V5KV07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZUFycmF5SW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVzdWx0Lmxlbmd0aCAvIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChrZXlPZlZhbHVlKSA9PiAoW1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGUoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgJ1snLCBlbmNvZGUoaW5kZXgpLCAnXScsXG4gICAgICAgICAgICAgICAgICAgICdbJywgZW5jb2RlKGtleU9mVmFsdWUpLCAnXT0nLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGUodmFsdWVba2V5T2ZWYWx1ZV0pLFxuICAgICAgICAgICAgICAgIF0uam9pbignJykpKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBbZW5jb2RlKGtleSksICdbJywgZW5jb2RlKGluZGV4KSwgJ109JywgZW5jb2RlKHZhbHVlKV0uam9pbignJyksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFsuLi5yZXN1bHQsIFtlbmNvZGUoa2V5KSwgJz0nLCBlbmNvZGUodmFsdWUpXS5qb2luKCcnKV07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHF1ZXJ5IHN0cmluZyBpbnRvIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dFBhcnNlZCA9IGlucHV0LnRyaW0oKS5yZXBsYWNlKC9eWz8jJl0vLCAnJyk7XG5cbiAgICBpZiAoIWlucHV0UGFyc2VkKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaW5wdXRQYXJzZWQuc3BsaXQoJyYnKS5mb3JFYWNoKChwYXJhbSkgPT4ge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IHNwbGl0T25GaXJzdChwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKSwgJz0nKTtcblxuICAgICAgICBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgIHJldFtrZXldID0gZ2V0UGFyc2VkVmFsdWUoa2V5LCB2YWx1ZSwgcmV0KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXQpLnNvcnQoKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmV0W2tleV07XG4gICAgICAgIGlmIChCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc29ydEJ5S2V5cyh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IHRvIHF1ZXJ5IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbHRlclZhbHVlc10gLSBmaWx0ZXJzIGVtcHR5IHN0cmluZyBvciB1bmRlZmluZWRzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVBcnJheUluZGV4XSAtIGluY2x1ZGVzIGFycmF5IGluZGV4IGluIHRoZSBxdWVyeSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShvYmplY3QsIG9wdGlvbnMgPSB7XG4gICAgZmlsdGVyVmFsdWVzOiBmYWxzZSxcbiAgICBhcnJheUluZGV4OiBmYWxzZSxcbn0pIHtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqZWN0Q29weSA9IHt9O1xuICAgIGNvbnN0IHNob3VsZEZpbHRlciA9IChrZXkpID0+IChcbiAgICAgICAgb3B0aW9ucy5maWx0ZXJWYWx1ZXNcbiAgICAgICAgJiYgKG9iamVjdFtrZXldID09PSAnJyB8fCBvYmplY3Rba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICk7XG5cbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEZpbHRlcihrZXkpKSB7XG4gICAgICAgICAgICBvYmplY3RDb3B5W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdENvcHkpO1xuICAgIGtleXMuc29ydCgpO1xuXG4gICAgcmV0dXJuIGtleXMubWFwKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UocmVkdWNlQnlLZXkob3B0aW9ucykoa2V5KSwgW10pXG4gICAgICAgICAgICAgICAgLmpvaW4oJyYnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgJHtlbmNvZGUoa2V5KX09JHtlbmNvZGUodmFsdWUpfWA7XG4gICAgfSkuZmlsdGVyKCh4KSA9PiB4Lmxlbmd0aCA+IDApLmpvaW4oJyYnKTtcbn1cbiIsImltcG9ydCAnd2hhdHdnLWZldGNoJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vcXVlcnktc3RyaW5nJztcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IG1ldGhvZCBwYXNzZWQgaW4gaXMgdmFsaWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuY29uc3QgaXNWYWxpZEhUVFBNZXRob2QgPSAobWV0aG9kKSA9PiBbJ0dFVCcsICdQT1NUJywgJ1BVVCcsICdERUxFVEUnXS5pbmRleE9mKG1ldGhvZCkgIT09IC0xO1xuXG4vKipcbiAqIENoZWNrcyBpZiByZXF1ZXN0ZWQgdGVtcGxhdGUgaXMgdXNpbmcgc2VjdGlvbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd9IHJlcXVlc3RlZFRlbXBsYXRlXG4gKi9cbmNvbnN0IGlzVXNpbmdTZWN0aW9ucyA9IChyZXF1ZXN0ZWRUZW1wbGF0ZSkgPT4gcmVxdWVzdGVkVGVtcGxhdGUgIT09IG51bGwgJiYgdHlwZW9mIChyZXF1ZXN0ZWRUZW1wbGF0ZSkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcXVlc3RlZFRlbXBsYXRlKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRlbXBsYXRlcyBhcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ30gcmVxdWVzdGVkVGVtcGxhdGVcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuY29uc3QgZ2V0VGVtcGxhdGVzID0gKHJlcXVlc3RlZFRlbXBsYXRlKSA9PiB7XG4gICAgbGV0IHRlbXBsYXRlcyA9IFtdO1xuICAgIGlmIChpc1VzaW5nU2VjdGlvbnMocmVxdWVzdGVkVGVtcGxhdGUpKSB7XG4gICAgICAgIHRlbXBsYXRlcyA9IE9iamVjdC52YWx1ZXMocmVxdWVzdGVkVGVtcGxhdGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIChyZXF1ZXN0ZWRUZW1wbGF0ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRlbXBsYXRlcyA9IFtyZXF1ZXN0ZWRUZW1wbGF0ZV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3RlZFRlbXBsYXRlKSAmJiByZXF1ZXN0ZWRUZW1wbGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRlbXBsYXRlcyA9IHJlcXVlc3RlZFRlbXBsYXRlO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGVzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHJlbGF0aXZlVXJsLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZW1vdGU6IGZhbHNlLFxuICAgICAgICByZXF1ZXN0T3B0aW9uczoge1xuICAgICAgICAgICAgYmFzZVVybDogbnVsbCxcbiAgICAgICAgICAgIGZvcm1EYXRhOiBudWxsLFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogW10sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCBvcHRpb25zID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9O1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zLnJlcXVlc3RPcHRpb25zLmZvcm1EYXRhID8gb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5mb3JtRGF0YSA6IG9wdGlvbnMucmVxdWVzdE9wdGlvbnMucGFyYW1zO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICdzdGVuY2lsLWNvbmZpZyc6IG9wdGlvbnMucmVxdWVzdE9wdGlvbnMuY29uZmlnID8gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5jb25maWcpIDogJ3t9JyxcbiAgICAgICAgJ3N0ZW5jaWwtb3B0aW9ucyc6ICd7fScsXG4gICAgICAgICd4LXhzcmYtdG9rZW4nOiB3aW5kb3cuQkNEYXRhICYmIHdpbmRvdy5CQ0RhdGEuY3NyZl90b2tlbiA/IHdpbmRvdy5CQ0RhdGEuY3NyZl90b2tlbiA6ICcnLFxuICAgICAgICAneC1yZXF1ZXN0ZWQtd2l0aCc6ICdzdGVuY2lsLXV0aWxzJyxcbiAgICB9O1xuXG4gICAgaWYgKCFpc1ZhbGlkSFRUUE1ldGhvZChvcHRpb25zLm1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignTm90IGEgdmFsaWQgSFRUUCBtZXRob2QnKSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGVtcGxhdGVzID0gZ2V0VGVtcGxhdGVzKG9wdGlvbnMucmVxdWVzdE9wdGlvbnMudGVtcGxhdGUpO1xuICAgIGNvbnN0IHVzaW5nU2VjdGlvbnMgPSBpc1VzaW5nU2VjdGlvbnMob3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy50ZW1wbGF0ZSk7XG4gICAgY29uc3QgdXNpbmdUZW1wbGF0ZXMgPSB0ZW1wbGF0ZXMubGVuZ3RoID4gMDtcblxuICAgIGlmICghb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5mb3JtRGF0YSkge1xuICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnO1xuICAgIH1cblxuICAgIGlmICh1c2luZ1RlbXBsYXRlcykge1xuICAgICAgICBoZWFkZXJzWydzdGVuY2lsLW9wdGlvbnMnXSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHJlbmRlcl93aXRoOiB0ZW1wbGF0ZXMuam9pbignLCcpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgfTtcblxuICAgIGxldCB1cmwgPSBvcHRpb25zLnJlcXVlc3RPcHRpb25zLmJhc2VVcmwgPyBgJHtvcHRpb25zLnJlcXVlc3RPcHRpb25zLmJhc2VVcmx9JHtyZWxhdGl2ZVVybH1gIDogcmVsYXRpdmVVcmw7XG4gICAgaWYgKFsnR0VUJywgJ0hFQUQnXS5pbmRleE9mKGNvbmZpZy5tZXRob2QpID09PSAtMSkge1xuICAgICAgICBjb25maWcuYm9keSA9ICFvcHRpb25zLnJlcXVlc3RPcHRpb25zLmZvcm1EYXRhID8gc3RyaW5naWZ5KGRhdGEsIHsgaW5jbHVkZUFycmF5SW5kZXg6IHRydWUgfSkgOiBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICBjb25zdCBkZWxpbWl0ZXIgPSAhdXJsLmluY2x1ZGVzKCc/JykgPyAnPycgOiAnJic7XG4gICAgICAgIHVybCArPSBgJHtkZWxpbWl0ZXJ9JHtzdHJpbmdpZnkoZGF0YSl9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2godXJsLCBjb25maWcpXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IG9wdGlvbnMucmVtb3RlID8gcmVzcG9uc2UuY29udGVudCA6IHJlc3BvbnNlO1xuICAgICAgICAgICAgbGV0IHJldCA9IHJlc3BvbnNlO1xuXG4gICAgICAgICAgICBpZiAodXNpbmdUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGBjb21wb25lbnRzYCBwcmVmaXggZnJvbSB0aGUgcmVzcG9uc2UgaWYgaXQncyBhbiBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChjb250ZW50KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udGVudCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGVhbktleSA9IGtleS5yZXBsYWNlKC9eY29tcG9uZW50c1xcLy8sICcnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFtjbGVhbktleV0gPSBjb250ZW50W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgKGNvbnRlbnRba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHVzaW5nIFwic2VjdGlvbnNcIiwgbW9ycGggdGhlIGNvbnRlbnQgaW50byB0aGUgYXJiaXRyYXJ5IGtleXMgPT4gY29udGVudCBvYmplY3QuXG4gICAgICAgICAgICAgICAgaWYgKHVzaW5nU2VjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVGVtcGxhdGUgPSBvcHRpb25zLnJlcXVlc3RPcHRpb25zLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZXF1ZXN0ZWRUZW1wbGF0ZSkuZm9yRWFjaCgodGVtcGxhdGVWYXJpYWJsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFt0ZW1wbGF0ZVZhcmlhYmxlXSA9IGNvbnRlbnRbcmVxdWVzdGVkVGVtcGxhdGVbdGVtcGxhdGVWYXJpYWJsZV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbnRlbnRbcmVxdWVzdGVkVGVtcGxhdGVbdGVtcGxhdGVWYXJpYWJsZV1dO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmV0KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVycikpO1xufVxuIiwiaW1wb3J0IGhvb2tzIGZyb20gJy4vaG9va3MnO1xuaW1wb3J0IGFwaSBmcm9tICcuL2FwaSc7XG5pbXBvcnQgdG9vbHMgZnJvbSAnLi90b29scyc7XG5cbmNvbnN0IFN0ZW5jaWxVdGlscyA9IHtcbiAgICBob29rcyxcbiAgICBhcGksXG4gICAgdG9vbHMsXG59O1xuZXhwb3J0IHsgaG9va3MsIGFwaSwgdG9vbHMgfTtcbmV4cG9ydCBkZWZhdWx0IFN0ZW5jaWxVdGlscztcblxuLyogZ2xvYmFsIGRlZmluZSAqL1xuKGZ1bmN0aW9uIChyb290KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAmJiByb290KSB7XG4gICAgICAgIC8vIElnbm9yZXMgYmVsb3cgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy81MTUwXG4gICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWFycm93LWNhbGxiYWNrXG4gICAgICAgICAgICByb290LnN0ZW5jaWxVdGlscyA9IFN0ZW5jaWxVdGlsczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gU3RlbmNpbFV0aWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5zdGVuY2lsVXRpbHMgPSBTdGVuY2lsVXRpbHM7XG4gICAgfVxufSh0aGlzKSk7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gICAgZ2V0U3JjKHBhdGgsIGRpbWVuc2lvbnMpIHtcbiAgICAgICAgLy8gUmVnZXggdG8gdGVzdCBzaXplIHN0cmluZyBpcyBvZiB0aGUgZm9ybSAxMjN4MTIzIG9yIDEwMHdcbiAgICAgICAgY29uc3Qgc2l6ZVJlZ2V4ID0gLyheXFxkK3ckKXwoXihcXGQrPyl4KFxcZCs/KSQpL2c7XG4gICAgICAgIGxldCBzaXplO1xuXG4gICAgICAgIGlmICh0eXBlb2YgKGRpbWVuc2lvbnMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoIHx8IDEwMDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0IHx8IDEwMDtcblxuICAgICAgICAgICAgc2l6ZSA9IGAke3dpZHRofXgke2hlaWdodH1gO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAoZGltZW5zaW9ucykgPT09ICdzdHJpbmcnICYmIHNpemVSZWdleC50ZXN0KGRpbWVuc2lvbnMpKSB7XG4gICAgICAgICAgICAvLyBJZiBkaW1lbnNpb25zIGlzIGEgc3RyaW5nIGFuZCBtYXRjaCB0aGUgTk5OeE5OTiBvciBOTk53IGZvcm1hdFxuICAgICAgICAgICAgc2l6ZSA9IGRpbWVuc2lvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGltYWdlIHNpemVcbiAgICAgICAgICAgIHNpemUgPSAnb3JpZ2luYWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgnezpzaXplfScsIHNpemUpO1xuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgICBnZXRTcmNzZXQodXJsLCBzaXplcykge1xuICAgICAgICAvLyBSZWdleCB0byB0ZXN0IHNpemUgc3RyaW5nIGlzIG9mIHRoZSBmb3JtIDEyM3gxMjMgb3IgMTAwd1xuICAgICAgICBjb25zdCBzaXplUmVnZXggPSAvKF5cXGQrdyQpfCheKFxcZCs/KXgoXFxkKz8pJCkvO1xuICAgICAgICAvLyBSZWdleCB0byB0ZXN0IHRvIHRoYXQgc3Jjc2V0IGRlc2NyaXB0b3IgaXMgb2YgdGhlIGZvcm0gMXggMS41eCAyeCBPUiAxMjN3XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3JSZWdleCA9IC8oXlxcZCt3JCl8KF4oWzAtOV0oXFwuWzAtOV0rKT8peCkkLztcblxuICAgICAgICBsZXQgc3Jjc2V0cyA9IHt9O1xuXG4gICAgICAgIGlmICghc2l6ZXMpIHtcbiAgICAgICAgICAgIC8vIFVzZSBkZWZhdWx0IHNyY3NldHMgaWYgbm9uZSBhcmUgcHJvdmlkZWRcbiAgICAgICAgICAgIHNyY3NldHMgPSB7XG4gICAgICAgICAgICAgICAgJzgwdyc6ICc4MHcnLFxuICAgICAgICAgICAgICAgICcxNjB3JzogJzE2MHcnLFxuICAgICAgICAgICAgICAgICczMjB3JzogJzMyMHcnLFxuICAgICAgICAgICAgICAgICc2NDB3JzogJzY0MHcnLFxuICAgICAgICAgICAgICAgICc5NjB3JzogJzk2MHcnLFxuICAgICAgICAgICAgICAgICcxMjgwdyc6ICcxMjgwdycsXG4gICAgICAgICAgICAgICAgJzE5MjB3JzogJzE5MjB3JyxcbiAgICAgICAgICAgICAgICAnMjU2MHcnOiAnMjU2MHcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICgoc2l6ZXMgPT09IE9iamVjdChzaXplcykpICYmICFPYmplY3Qua2V5cyhzaXplcykuc29tZSgoZGVzY3JpcHRvcikgPT4gIShkZXNjcmlwdG9yUmVnZXgudGVzdChkZXNjcmlwdG9yKSAmJiBzaXplUmVnZXgudGVzdChzaXplc1tkZXNjcmlwdG9yXSkpKSkge1xuICAgICAgICAgICAgLy8gSWYgb2JqZWN0IGNvbnNpc3RzIG9mIHZhbGlkIHNyY3NldHMsIHVzZSBpdCBpbnN0ZWFkXG4gICAgICAgICAgICBzcmNzZXRzID0gc2l6ZXM7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIGFyZ3VtZW50LCByZXR1cm4gYSBgc3JjYCBvbmx5IChhbHNvIHdvcmtzIGZvciBgc3Jjc2V0YClcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzcmNzZXRzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHVybC5yZXBsYWNlKCd7OnNpemV9Jywgc3Jjc2V0c1tPYmplY3Qua2V5cyhzcmNzZXRzKVswXV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzcmNzZXQgZGVzY3JpcHRvciBvciBzaXplJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3Jjc2V0cykubWFwKChkZXNjcmlwdG9yKSA9PiBbdXJsLnJlcGxhY2UoJ3s6c2l6ZX0nLCBzcmNzZXRzW2Rlc2NyaXB0b3JdKSwgZGVzY3JpcHRvcl0uam9pbignICcpKS5qb2luKCcsICcpO1xuICAgIH1cbn1cbiIsImltcG9ydCBJbWFnZVRvb2wgZnJvbSAnLi9pbWFnZSc7XG5pbXBvcnQgSW1hZ2VTcmNzZXRUb29sIGZyb20gJy4vaW1hZ2VTcmNzZXQnO1xuaW1wb3J0IFN0b3JhZ2VUb29scyBmcm9tICcuL3N0b3JhZ2UnO1xuXG5jb25zdCB0b29scyA9IHtcbiAgICBpbWFnZTogbmV3IEltYWdlVG9vbCgpLFxuICAgIGltYWdlU3Jjc2V0OiBuZXcgSW1hZ2VTcmNzZXRUb29sKCksXG4gICAgc3RvcmFnZTogbmV3IFN0b3JhZ2VUb29scygpLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgdG9vbHM7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBzdG9yYWdlIHR5cGUgKGxpa2UgbG9jYWxTdG9yYWdlIG9yIHNlc3Npb25TdG9yYWdlKSBpcyBhdmFpbGFibGUgZm9yIHVzZVxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkvVXNpbmdfdGhlX1dlYl9TdG9yYWdlX0FQSSNUZXN0aW5nX2Zvcl9hdmFpbGFiaWxpdHlcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdG9yYWdlQXZhaWxhYmxlKHR5cGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHdpbmRvd1t0eXBlXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHggPSAnX19zdG9yYWdlX3Rlc3RfXyc7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oeCwgeCk7XG4gICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oeCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgKFxuICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBleGNlcHQgRmlyZWZveFxuICAgICAgICAgICAgICAgIGUuY29kZSA9PT0gMjJcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICAgICAgfHwgZS5jb2RlID09PSAxMDE0XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBuYW1lIGZpZWxkIHRvbywgYmVjYXVzZSBjb2RlIG1pZ2h0IG5vdCBiZSBwcmVzZW50XG4gICAgICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBleGNlcHQgRmlyZWZveFxuICAgICAgICAgICAgICAgIHx8IGUubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcidcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICAgICAgfHwgZS5uYW1lID09PSAnTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRUQnKVxuICAgICAgICAgICAgICAgIC8vIGFja25vd2xlZGdlIFF1b3RhRXhjZWVkZWRFcnJvciBvbmx5IGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGFscmVhZHkgc3RvcmVkXG4gICAgICAgICAgICAgICAgJiYgc3RvcmFnZS5sZW5ndGggIT09IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VBdmFpbGFibGUoJ2xvY2FsU3RvcmFnZScpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogYmFndWV0dGVCb3guanNcbiAqIEBhdXRob3IgIGZlaW1vc2lcbiAqIEB2ZXJzaW9uIDEuMTIuMFxuICogQHVybCBodHRwczovL2dpdGh1Yi5jb20vZmVpbW9zaS9iYWd1ZXR0ZUJveC5qc1xuICovXG4hZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP21vZHVsZS5leHBvcnRzPXQoKTplLmJhZ3VldHRlQm94PXQoKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBzLGwsdSxjLGQsZj0nPHN2ZyB3aWR0aD1cIjQ0XCIgaGVpZ2h0PVwiNjBcIj48cG9seWxpbmUgcG9pbnRzPVwiMzAgMTAgMTAgMzAgMzAgNTBcIiBzdHJva2U9XCJyZ2JhKDI1NSwyNTUsMjU1LDAuNSlcIiBzdHJva2Utd2lkdGg9XCI0XCJzdHJva2UtbGluZWNhcD1cImJ1dHRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPjwvc3ZnPicsZz0nPHN2ZyB3aWR0aD1cIjQ0XCIgaGVpZ2h0PVwiNjBcIj48cG9seWxpbmUgcG9pbnRzPVwiMTQgMTAgMzQgMzAgMTQgNTBcIiBzdHJva2U9XCJyZ2JhKDI1NSwyNTUsMjU1LDAuNSlcIiBzdHJva2Utd2lkdGg9XCI0XCJzdHJva2UtbGluZWNhcD1cImJ1dHRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPjwvc3ZnPicscD0nPHN2ZyB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIj48ZyBzdHJva2U9XCJyZ2IoMTYwLDE2MCwxNjApXCIgc3Ryb2tlLXdpZHRoPVwiNFwiPjxsaW5lIHgxPVwiNVwiIHkxPVwiNVwiIHgyPVwiMjVcIiB5Mj1cIjI1XCIvPjxsaW5lIHgxPVwiNVwiIHkxPVwiMjVcIiB4Mj1cIjI1XCIgeTI9XCI1XCIvPjwvZz48L3N2Zz4nLGI9e30sdj17Y2FwdGlvbnM6ITAsYnV0dG9uczpcImF1dG9cIixmdWxsU2NyZWVuOiExLG5vU2Nyb2xsYmFyczohMSxib2R5Q2xhc3M6XCJiYWd1ZXR0ZUJveC1vcGVuXCIsdGl0bGVUYWc6ITEsYXN5bmM6ITEscHJlbG9hZDoyLGFuaW1hdGlvbjpcInNsaWRlSW5cIixhZnRlclNob3c6bnVsbCxhZnRlckhpZGU6bnVsbCxvbkNoYW5nZTpudWxsLG92ZXJsYXlCYWNrZ3JvdW5kQ29sb3I6XCJyZ2JhKDAsMCwwLC44KVwiLGNsb3NlWDpwLGxlZnRBcnJvdzpmLHJpZ2h0QXJyb3c6Z30sbT17fSxoPVtdLG89MCxuPSExLGk9e30sYT0hMSx5PS8uK1xcLihnaWZ8anBlP2d8cG5nfHdlYnApL2ksdz17fSxrPVtdLHI9bnVsbCx4PWZ1bmN0aW9uKGUpey0xIT09ZS50YXJnZXQuaWQuaW5kZXhPZihcImJhZ3VldHRlLWltZ1wiKSYmWCgpfSxFPWZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uP2Uuc3RvcFByb3BhZ2F0aW9uKCk6ZS5jYW5jZWxCdWJibGU9ITAscSgpfSxDPWZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uP2Uuc3RvcFByb3BhZ2F0aW9uKCk6ZS5jYW5jZWxCdWJibGU9ITAsaigpfSxCPWZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uP2Uuc3RvcFByb3BhZ2F0aW9uKCk6ZS5jYW5jZWxCdWJibGU9ITAsWCgpfSxUPWZ1bmN0aW9uKGUpe2kuY291bnQrKywxPGkuY291bnQmJihpLm11bHRpdG91Y2g9ITApLGkuc3RhcnRYPWUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVgsaS5zdGFydFk9ZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWX0sQT1mdW5jdGlvbihlKXtpZighYSYmIWkubXVsdGl0b3VjaCl7ZS5wcmV2ZW50RGVmYXVsdD9lLnByZXZlbnREZWZhdWx0KCk6ZS5yZXR1cm5WYWx1ZT0hMTt2YXIgdD1lLnRvdWNoZXNbMF18fGUuY2hhbmdlZFRvdWNoZXNbMF07NDA8dC5wYWdlWC1pLnN0YXJ0WD8oYT0hMCxxKCkpOnQucGFnZVgtaS5zdGFydFg8LTQwPyhhPSEwLGooKSk6MTAwPGkuc3RhcnRZLXQucGFnZVkmJlgoKX19LEw9ZnVuY3Rpb24oKXtpLmNvdW50LS0saS5jb3VudDw9MCYmKGkubXVsdGl0b3VjaD0hMSksYT0hMX0sTj1mdW5jdGlvbigpe0woKX0sSD1mdW5jdGlvbihlKXtcImJsb2NrXCI9PT1zLnN0eWxlLmRpc3BsYXkmJnMuY29udGFpbnMmJiFzLmNvbnRhaW5zKGUudGFyZ2V0KSYmKGUuc3RvcFByb3BhZ2F0aW9uKCksTSgpKX07ZnVuY3Rpb24gUChlKXtpZih3Lmhhc093blByb3BlcnR5KGUpKXt2YXIgdD13W2VdLmdhbGxlcmllcztbXS5mb3JFYWNoLmNhbGwodCxmdW5jdGlvbihlKXtbXS5mb3JFYWNoLmNhbGwoZSxmdW5jdGlvbihlKXtXKGUuaW1hZ2VFbGVtZW50LFwiY2xpY2tcIixlLmV2ZW50SGFuZGxlcil9KSxoPT09ZSYmKGg9W10pfSksZGVsZXRlIHdbZV19fWZ1bmN0aW9uIFMoZSl7c3dpdGNoKGUua2V5Q29kZSl7Y2FzZSAzNzpxKCk7YnJlYWs7Y2FzZSAzOTpqKCk7YnJlYWs7Y2FzZSAyNzpYKCk7YnJlYWs7Y2FzZSAzNjohZnVuY3Rpb24gdChlKXtlJiZlLnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIEQoMCl9KGUpO2JyZWFrO2Nhc2UgMzU6IWZ1bmN0aW9uIG4oZSl7ZSYmZS5wcmV2ZW50RGVmYXVsdCgpO3JldHVybiBEKGgubGVuZ3RoLTEpfShlKX19ZnVuY3Rpb24gRihlLHQpe2lmKGghPT1lKXtmb3IoaD1lLGZ1bmN0aW9uIHIoZSl7ZT1lfHx7fTtmb3IodmFyIHQgaW4gdiliW3RdPXZbdF0sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGVbdF0mJihiW3RdPWVbdF0pO2wuc3R5bGUudHJhbnNpdGlvbj1sLnN0eWxlLndlYmtpdFRyYW5zaXRpb249XCJmYWRlSW5cIj09PWIuYW5pbWF0aW9uP1wib3BhY2l0eSAuNHMgZWFzZVwiOlwic2xpZGVJblwiPT09Yi5hbmltYXRpb24/XCJcIjpcIm5vbmVcIixcImF1dG9cIj09PWIuYnV0dG9ucyYmKFwib250b3VjaHN0YXJ0XCJpbiB3aW5kb3d8fDE9PT1oLmxlbmd0aCkmJihiLmJ1dHRvbnM9ITEpO3Uuc3R5bGUuZGlzcGxheT1jLnN0eWxlLmRpc3BsYXk9Yi5idXR0b25zP1wiXCI6XCJub25lXCIsZC5pbm5lckhUTUw9Yi5jbG9zZVgsYi5idXR0b25zJiYodS5pbm5lckhUTUw9Yi5sZWZ0QXJyb3csYy5pbm5lckhUTUw9Yi5yaWdodEFycm93KTt0cnl7cy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9Yi5vdmVybGF5QmFja2dyb3VuZENvbG9yfWNhdGNoKG4pe319KHQpO2wuZmlyc3RDaGlsZDspbC5yZW1vdmVDaGlsZChsLmZpcnN0Q2hpbGQpO2Zvcih2YXIgbixvPVtdLGk9W10sYT1rLmxlbmd0aD0wO2E8ZS5sZW5ndGg7YSsrKShuPUooXCJkaXZcIikpLmNsYXNzTmFtZT1cImZ1bGwtaW1hZ2VcIixuLmlkPVwiYmFndWV0dGUtaW1nLVwiK2Esay5wdXNoKG4pLG8ucHVzaChcImJhZ3VldHRlQm94LWZpZ3VyZS1cIithKSxpLnB1c2goXCJiYWd1ZXR0ZUJveC1maWdjYXB0aW9uLVwiK2EpLGwuYXBwZW5kQ2hpbGQoa1thXSk7cy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIixvLmpvaW4oXCIgXCIpKSxzLnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIixpLmpvaW4oXCIgXCIpKX19ZnVuY3Rpb24gSShlKXtiLm5vU2Nyb2xsYmFycyYmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvd1k9XCJoaWRkZW5cIixkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93WT1cInNjcm9sbFwiKSxcImJsb2NrXCIhPT1zLnN0eWxlLmRpc3BsYXkmJihVKGRvY3VtZW50LFwia2V5ZG93blwiLFMpLGk9e2NvdW50OjAsc3RhcnRYOm51bGwsc3RhcnRZOm51bGx9LFkobz1lLGZ1bmN0aW9uKCl7eihvKSxWKG8pfSksUigpLHMuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsYi5mdWxsU2NyZWVuJiZmdW5jdGlvbiB0KCl7cy5yZXF1ZXN0RnVsbHNjcmVlbj9zLnJlcXVlc3RGdWxsc2NyZWVuKCk6cy53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbj9zLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk6cy5tb3pSZXF1ZXN0RnVsbFNjcmVlbiYmcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpfSgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzLmNsYXNzTmFtZT1cInZpc2libGVcIixiLmJvZHlDbGFzcyYmZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QmJmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChiLmJvZHlDbGFzcyksYi5hZnRlclNob3cmJmIuYWZ0ZXJTaG93KCl9LDUwKSxiLm9uQ2hhbmdlJiZiLm9uQ2hhbmdlKG8say5sZW5ndGgpLHI9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxNKCksbj0hMCl9ZnVuY3Rpb24gTSgpe2IuYnV0dG9ucz91LmZvY3VzKCk6ZC5mb2N1cygpfWZ1bmN0aW9uIFgoKXtiLm5vU2Nyb2xsYmFycyYmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvd1k9XCJhdXRvXCIsZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvd1k9XCJhdXRvXCIpLFwibm9uZVwiIT09cy5zdHlsZS5kaXNwbGF5JiYoVyhkb2N1bWVudCxcImtleWRvd25cIixTKSxzLmNsYXNzTmFtZT1cIlwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsZG9jdW1lbnQuZnVsbHNjcmVlbiYmZnVuY3Rpb24gZSgpe2RvY3VtZW50LmV4aXRGdWxsc2NyZWVuP2RvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk6ZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbj9kb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk6ZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4mJmRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCl9KCksYi5ib2R5Q2xhc3MmJmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0JiZkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoYi5ib2R5Q2xhc3MpLGIuYWZ0ZXJIaWRlJiZiLmFmdGVySGlkZSgpLHImJnIuZm9jdXMoKSxuPSExfSw1MDApKX1mdW5jdGlvbiBZKHQsbil7dmFyIGU9a1t0XSxvPWhbdF07aWYodm9pZCAwIT09ZSYmdm9pZCAwIT09bylpZihlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW1nXCIpWzBdKW4mJm4oKTtlbHNle3ZhciBpPW8uaW1hZ2VFbGVtZW50LGE9aS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImltZ1wiKVswXSxyPVwiZnVuY3Rpb25cIj09dHlwZW9mIGIuY2FwdGlvbnM/Yi5jYXB0aW9ucy5jYWxsKGgsaSk6aS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNhcHRpb25cIil8fGkudGl0bGUscz1mdW5jdGlvbiBkKGUpe3ZhciB0PWUuaHJlZjtpZihlLmRhdGFzZXQpe3ZhciBuPVtdO2Zvcih2YXIgbyBpbiBlLmRhdGFzZXQpXCJhdC1cIiE9PW8uc3Vic3RyaW5nKDAsMyl8fGlzTmFOKG8uc3Vic3RyaW5nKDMpKXx8KG5bby5yZXBsYWNlKFwiYXQtXCIsXCJcIildPWUuZGF0YXNldFtvXSk7Zm9yKHZhciBpPU9iamVjdC5rZXlzKG4pLnNvcnQoZnVuY3Rpb24oZSx0KXtyZXR1cm4gcGFyc2VJbnQoZSwxMCk8cGFyc2VJbnQodCwxMCk/LTE6MX0pLGE9d2luZG93LmlubmVyV2lkdGgqd2luZG93LmRldmljZVBpeGVsUmF0aW8scj0wO3I8aS5sZW5ndGgtMSYmaVtyXTxhOylyKys7dD1uW2lbcl1dfHx0fXJldHVybiB0fShpKSxsPUooXCJmaWd1cmVcIik7aWYobC5pZD1cImJhZ3VldHRlQm94LWZpZ3VyZS1cIit0LGwuaW5uZXJIVE1MPSc8ZGl2IGNsYXNzPVwiYmFndWV0dGVCb3gtc3Bpbm5lclwiPjxkaXYgY2xhc3M9XCJiYWd1ZXR0ZUJveC1kb3VibGUtYm91bmNlMVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJiYWd1ZXR0ZUJveC1kb3VibGUtYm91bmNlMlwiPjwvZGl2PjwvZGl2PicsYi5jYXB0aW9ucyYmcil7dmFyIHU9SihcImZpZ2NhcHRpb25cIik7dS5pZD1cImJhZ3VldHRlQm94LWZpZ2NhcHRpb24tXCIrdCx1LmlubmVySFRNTD1yLGwuYXBwZW5kQ2hpbGQodSl9ZS5hcHBlbmRDaGlsZChsKTt2YXIgYz1KKFwiaW1nXCIpO2Mub25sb2FkPWZ1bmN0aW9uKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNiYWd1ZXR0ZS1pbWctXCIrdCtcIiAuYmFndWV0dGVCb3gtc3Bpbm5lclwiKTtsLnJlbW92ZUNoaWxkKGUpLCFiLmFzeW5jJiZuJiZuKCl9LGMuc2V0QXR0cmlidXRlKFwic3JjXCIscyksYy5hbHQ9YSYmYS5hbHR8fFwiXCIsYi50aXRsZVRhZyYmciYmKGMudGl0bGU9ciksbC5hcHBlbmRDaGlsZChjKSxiLmFzeW5jJiZuJiZuKCl9fWZ1bmN0aW9uIGooKXtyZXR1cm4gRChvKzEpfWZ1bmN0aW9uIHEoKXtyZXR1cm4gRChvLTEpfWZ1bmN0aW9uIEQoZSx0KXtyZXR1cm4hbiYmMDw9ZSYmZTx0Lmxlbmd0aD8oRih0LGIpLEkoZSksITApOmU8MD8oYi5hbmltYXRpb24mJk8oXCJsZWZ0XCIpLCExKTplPj1rLmxlbmd0aD8oYi5hbmltYXRpb24mJk8oXCJyaWdodFwiKSwhMSk6KFkobz1lLGZ1bmN0aW9uKCl7eihvKSxWKG8pfSksUigpLGIub25DaGFuZ2UmJmIub25DaGFuZ2UobyxrLmxlbmd0aCksITApfWZ1bmN0aW9uIE8oZSl7bC5jbGFzc05hbWU9XCJib3VuY2UtZnJvbS1cIitlLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtsLmNsYXNzTmFtZT1cIlwifSw0MDApfWZ1bmN0aW9uIFIoKXt2YXIgZT0xMDAqLW8rXCIlXCI7XCJmYWRlSW5cIj09PWIuYW5pbWF0aW9uPyhsLnN0eWxlLm9wYWNpdHk9MCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bS50cmFuc2Zvcm1zP2wuc3R5bGUudHJhbnNmb3JtPWwuc3R5bGUud2Via2l0VHJhbnNmb3JtPVwidHJhbnNsYXRlM2QoXCIrZStcIiwwLDApXCI6bC5zdHlsZS5sZWZ0PWUsbC5zdHlsZS5vcGFjaXR5PTF9LDQwMCkpOm0udHJhbnNmb3Jtcz9sLnN0eWxlLnRyYW5zZm9ybT1sLnN0eWxlLndlYmtpdFRyYW5zZm9ybT1cInRyYW5zbGF0ZTNkKFwiK2UrXCIsMCwwKVwiOmwuc3R5bGUubGVmdD1lfWZ1bmN0aW9uIHooZSl7ZS1vPj1iLnByZWxvYWR8fFkoZSsxLGZ1bmN0aW9uKCl7eihlKzEpfSl9ZnVuY3Rpb24gVihlKXtvLWU+PWIucHJlbG9hZHx8WShlLTEsZnVuY3Rpb24oKXtWKGUtMSl9KX1mdW5jdGlvbiBVKGUsdCxuLG8pe2UuYWRkRXZlbnRMaXN0ZW5lcj9lLmFkZEV2ZW50TGlzdGVuZXIodCxuLG8pOmUuYXR0YWNoRXZlbnQoXCJvblwiK3QsZnVuY3Rpb24oZSl7KGU9ZXx8d2luZG93LmV2ZW50KS50YXJnZXQ9ZS50YXJnZXR8fGUuc3JjRWxlbWVudCxuKGUpfSl9ZnVuY3Rpb24gVyhlLHQsbixvKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXI/ZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsbixvKTplLmRldGFjaEV2ZW50KFwib25cIit0LG4pfWZ1bmN0aW9uIEcoZSl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpfWZ1bmN0aW9uIEooZSl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSl9cmV0dXJuW10uZm9yRWFjaHx8KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTA7bjx0aGlzLmxlbmd0aDtuKyspZS5jYWxsKHQsdGhpc1tuXSxuLHRoaXMpfSksW10uZmlsdGVyfHwoQXJyYXkucHJvdG90eXBlLmZpbHRlcj1mdW5jdGlvbihlLHQsbixvLGkpe2ZvcihuPXRoaXMsbz1bXSxpPTA7aTxuLmxlbmd0aDtpKyspZS5jYWxsKHQsbltpXSxpLG4pJiZvLnB1c2gobltpXSk7cmV0dXJuIG99KSx7cnVuOmZ1bmN0aW9uIEsoZSx0KXtyZXR1cm4gbS50cmFuc2Zvcm1zPWZ1bmN0aW9uIG4oKXt2YXIgZT1KKFwiZGl2XCIpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLnN0eWxlLnBlcnNwZWN0aXZlfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgZS5zdHlsZS53ZWJraXRQZXJzcGVjdGl2ZX0oKSxtLnN2Zz1mdW5jdGlvbiBvKCl7dmFyIGU9SihcImRpdlwiKTtyZXR1cm4gZS5pbm5lckhUTUw9XCI8c3ZnLz5cIixcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI9PT0oZS5maXJzdENoaWxkJiZlLmZpcnN0Q2hpbGQubmFtZXNwYWNlVVJJKX0oKSxtLnBhc3NpdmVFdmVudHM9ZnVuY3Rpb24gaSgpe3ZhciBlPSExO3RyeXt2YXIgdD1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe2U9ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsbnVsbCx0KX1jYXRjaChuKXt9cmV0dXJuIGV9KCksZnVuY3Rpb24gYSgpe2lmKHM9RyhcImJhZ3VldHRlQm94LW92ZXJsYXlcIikpcmV0dXJuIGw9RyhcImJhZ3VldHRlQm94LXNsaWRlclwiKSx1PUcoXCJwcmV2aW91cy1idXR0b25cIiksYz1HKFwibmV4dC1idXR0b25cIiksdm9pZChkPUcoXCJjbG9zZS1idXR0b25cIikpOyhzPUooXCJkaXZcIikpLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImRpYWxvZ1wiKSxzLmlkPVwiYmFndWV0dGVCb3gtb3ZlcmxheVwiLGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXS5hcHBlbmRDaGlsZChzKSwobD1KKFwiZGl2XCIpKS5pZD1cImJhZ3VldHRlQm94LXNsaWRlclwiLHMuYXBwZW5kQ2hpbGQobCksKHU9SihcImJ1dHRvblwiKSkuc2V0QXR0cmlidXRlKFwidHlwZVwiLFwiYnV0dG9uXCIpLHUuaWQ9XCJwcmV2aW91cy1idXR0b25cIix1LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixcIlByZXZpb3VzXCIpLHUuaW5uZXJIVE1MPW0uc3ZnP2Y6XCImbHQ7XCIscy5hcHBlbmRDaGlsZCh1KSwoYz1KKFwiYnV0dG9uXCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJidXR0b25cIiksYy5pZD1cIm5leHQtYnV0dG9uXCIsYy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsXCJOZXh0XCIpLGMuaW5uZXJIVE1MPW0uc3ZnP2c6XCImZ3Q7XCIscy5hcHBlbmRDaGlsZChjKSwoZD1KKFwiYnV0dG9uXCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJidXR0b25cIiksZC5pZD1cImNsb3NlLWJ1dHRvblwiLGQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLFwiQ2xvc2VcIiksZC5pbm5lckhUTUw9bS5zdmc/cDpcIiZ0aW1lcztcIixzLmFwcGVuZENoaWxkKGQpLHUuY2xhc3NOYW1lPWMuY2xhc3NOYW1lPWQuY2xhc3NOYW1lPVwiYmFndWV0dGVCb3gtYnV0dG9uXCIsZnVuY3Rpb24gbigpe3ZhciBlPW0ucGFzc2l2ZUV2ZW50cz97cGFzc2l2ZTohMX06bnVsbCx0PW0ucGFzc2l2ZUV2ZW50cz97cGFzc2l2ZTohMH06bnVsbDtVKHMsXCJjbGlja1wiLHgpLFUodSxcImNsaWNrXCIsRSksVShjLFwiY2xpY2tcIixDKSxVKGQsXCJjbGlja1wiLEIpLFUobCxcImNvbnRleHRtZW51XCIsTiksVShzLFwidG91Y2hzdGFydFwiLFQsdCksVShzLFwidG91Y2htb3ZlXCIsQSxlKSxVKHMsXCJ0b3VjaGVuZFwiLEwpLFUoZG9jdW1lbnQsXCJmb2N1c1wiLEgsITApfSgpfSgpLFAoZSksZnVuY3Rpb24gcihlLGEpe3ZhciB0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZSksbj17Z2FsbGVyaWVzOltdLG5vZGVMaXN0OnR9O3JldHVybiB3W2VdPW4sW10uZm9yRWFjaC5jYWxsKHQsZnVuY3Rpb24oZSl7YSYmYS5maWx0ZXImJih5PWEuZmlsdGVyKTt2YXIgdD1bXTtpZih0PVwiQVwiPT09ZS50YWdOYW1lP1tlXTplLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYVwiKSwwIT09KHQ9W10uZmlsdGVyLmNhbGwodCxmdW5jdGlvbihlKXtpZigtMT09PWUuY2xhc3NOYW1lLmluZGV4T2YoYSYmYS5pZ25vcmVDbGFzcykpcmV0dXJuIHkudGVzdChlLmhyZWYpfSkpLmxlbmd0aCl7dmFyIGk9W107W10uZm9yRWFjaC5jYWxsKHQsZnVuY3Rpb24oZSx0KXt2YXIgbj1mdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0P2UucHJldmVudERlZmF1bHQoKTplLnJldHVyblZhbHVlPSExLEYoaSxhKSxJKHQpfSxvPXtldmVudEhhbmRsZXI6bixpbWFnZUVsZW1lbnQ6ZX07VShlLFwiY2xpY2tcIixuKSxpLnB1c2gobyl9KSxuLmdhbGxlcmllcy5wdXNoKGkpfX0pLG4uZ2FsbGVyaWVzfShlLHQpfSxzaG93OkQsc2hvd05leHQ6aixzaG93UHJldmlvdXM6cSxoaWRlOlgsZGVzdHJveTpmdW5jdGlvbiBlKCl7IWZ1bmN0aW9uIG4oKXt2YXIgZT1tLnBhc3NpdmVFdmVudHM/e3Bhc3NpdmU6ITF9Om51bGwsdD1tLnBhc3NpdmVFdmVudHM/e3Bhc3NpdmU6ITB9Om51bGw7VyhzLFwiY2xpY2tcIix4KSxXKHUsXCJjbGlja1wiLEUpLFcoYyxcImNsaWNrXCIsQyksVyhkLFwiY2xpY2tcIixCKSxXKGwsXCJjb250ZXh0bWVudVwiLE4pLFcocyxcInRvdWNoc3RhcnRcIixULHQpLFcocyxcInRvdWNobW92ZVwiLEEsZSksVyhzLFwidG91Y2hlbmRcIixMKSxXKGRvY3VtZW50LFwiZm9jdXNcIixILCEwKX0oKSxmdW5jdGlvbiB0KCl7Zm9yKHZhciBlIGluIHcpdy5oYXNPd25Qcm9wZXJ0eShlKSYmUChlKX0oKSxXKGRvY3VtZW50LFwia2V5ZG93blwiLFMpLGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXS5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJhZ3VldHRlQm94LW92ZXJsYXlcIikpLHc9e30saD1bXSxvPTB9fX0pOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2pxdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgX2pxdWVyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qcXVlcnkpO1xuXG52YXIgX2xvZGFzaCA9IHJlcXVpcmUoJ2xvZGFzaC50ZW1wbGF0ZScpO1xuXG52YXIgX2xvZGFzaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2gpO1xuXG52YXIgX2pxdWVyeVRyZW5kID0gcmVxdWlyZSgnanF1ZXJ5LXRyZW5kJyk7XG5cbnZhciBfanF1ZXJ5VHJlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanF1ZXJ5VHJlbmQpO1xuXG52YXIgX2pxdWVyeVJldmVhbGVyID0gcmVxdWlyZSgnanF1ZXJ5LXJldmVhbGVyJyk7XG5cbnZhciBfanF1ZXJ5UmV2ZWFsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanF1ZXJ5UmV2ZWFsZXIpO1xuXG52YXIgX2V2ZW50ZW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjInKTtcblxudmFyIF9ldmVudGVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRlbWl0dGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9kdWN0IENvbXBhcmlzb24gV2lkZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIFByb2R1Y3RDb21wYXJlID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFByb2R1Y3RDb21wYXJlLCBfRXZlbnRFbWl0dGVyKTtcblxuICBmdW5jdGlvbiBQcm9kdWN0Q29tcGFyZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvZHVjdENvbXBhcmUpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFByb2R1Y3RDb21wYXJlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUHJvZHVjdENvbXBhcmUpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLm9wdGlvbnMgPSBfanF1ZXJ5Mi5kZWZhdWx0LmV4dGVuZCh7XG4gICAgICBzY29wZTogJ1tkYXRhLXByb2R1Y3QtY29tcGFyZV0nLFxuICAgICAgbWF4SXRlbXM6IDQsXG4gICAgICBpdGVtVGVtcGxhdGU6ICgwLCBfbG9kYXNoMi5kZWZhdWx0KSgnXFxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29tcGFyZS1pdGVtXCIgZGF0YS1jb21wYXJlLWl0ZW0+XFxuICAgICAgICAgIDxhIGhyZWY9XCI8JT0gdXJsICU+XCI+XFxuICAgICAgICAgICAgPGltZyBjbGFzcz1cImNvbXBhcmUtaXRlbS10aHVtYm5haWxcIiBzcmM9XCI8JT0gdGh1bWJuYWlsICU+XCIvPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb21wYXJlLWl0ZW0tcHJpY2VcIj48JT0gcHJpY2UgJT48L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29tcGFyZS1pdGVtLXRpdGxlXCI+PCU9IHRpdGxlICU+PC9kaXY+XFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImNvbXBhcmUtaXRlbS1yZW1vdmVcIiBkYXRhLWNvbXBhcmUtaXRlbS1yZW1vdmU9XCI8JT0gaWQgJT5cIj4mdGltZXM7PC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAnKVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgX3RoaXMuJHNjb3BlID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKF90aGlzLm9wdGlvbnMuc2NvcGUpO1xuICAgIF90aGlzLiRjb21wYXJlSXRlbXMgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoJ1tkYXRhLWNvbXBhcmUtaXRlbXNdJyk7XG4gICAgX3RoaXMuJGNvbXBhcmVMaW5rID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKCdbZGF0YS1jb21wYXJlLWxpbmtdJyk7XG5cbiAgICBfdGhpcy5jaGVja2JveCA9ICdbZGF0YS1jb21wYXJlLWNoZWNrYm94XSc7XG4gICAgX3RoaXMuY29tcGFyZUl0ZW0gPSAnW2RhdGEtY29tcGFyZS1pdGVtXSc7XG4gICAgX3RoaXMuY29tcGFyZVJlbW92ZSA9ICdkYXRhLWNvbXBhcmUtaXRlbS1yZW1vdmUnO1xuXG4gICAgX3RoaXMuX2luaXQoKTtcbiAgICBfdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBTZXQgdXAgdGhlIGNvbXBhcmUgbGlzdCBNYXBcbiAgICpcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFByb2R1Y3RDb21wYXJlLCBbe1xuICAgIGtleTogJ19pbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBpZiAoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnY29tcGFyZScpKSB7XG4gICAgICAgIHRoaXMuY29tcGFyZUxpc3QgPSBuZXcgTWFwKEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnY29tcGFyZScpKSk7XG4gICAgICAgIHRoaXMuX2luaXRXaWRnZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGFyZUxpc3QgPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBCaW5kIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY29tcGFyZSB3aWRnZXRcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYmluZEV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJHNjb3BlLm9uKCdjaGFuZ2UnLCB0aGlzLmNoZWNrYm94LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl90b2dnbGVJdGVtKGV2ZW50LnRhcmdldCk7XG4gICAgICB9KTtcblxuICAgICAgKDAsIF9qcXVlcnkyLmRlZmF1bHQpKCdib2R5Jykub24oJ2NsaWNrJywgJ1snICsgdGhpcy5jb21wYXJlUmVtb3ZlICsgJ10nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGlkID0gcGFyc2VJbnQoKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGV2ZW50LnRhcmdldCkuYXR0cihfdGhpczIuY29tcGFyZVJlbW92ZSksIDEwKTtcbiAgICAgICAgX3RoaXMyLl9yZW1vdmVJdGVtKGlkKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNldHMgdGhlIGluaXRhbCBzdGF0ZSBvZiB3aWRnZXQgaWYgbG9hZGluZyBmcm9tIHNlc3Npb25TdG9yYWdlXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2luaXRXaWRnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdFdpZGdldCgpIHtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLmNvbXBhcmVMaXN0LmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgaWQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHRoaXMuX2NoZWNrQ2hlY2tib3goaWQpO1xuXG4gICAgICAgICAgdGhpcy5fcG9wdWxhdGVXaWRnZXQoaWQpO1xuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlV2lkZ2V0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGVzIGEgY2hlY2tib3ggc3RhdGUgdG8gXCJjaGVja2VkXCJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aWR9IG51bWJlciBUaGUgSUQgb2YgdGhlIGl0ZW0gLyBjaGVja2JveCB0byB0YXJnZXRcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2hlY2tDaGVja2JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0NoZWNrYm94KGlkKSB7XG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoJ1tkYXRhLWNvbXBhcmUtaWQ9XCInICsgaWQgKyAnXCJdJykucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWRkcyBhbiBpdGVtIHRvIHRoZSB3aWRnZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aWR9IG51bWJlciBUaGUgSUQgb2YgdGhlIGl0ZW0gaXQgYWRkXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BvcHVsYXRlV2lkZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvcHVsYXRlV2lkZ2V0KGlkKSB7XG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcy5vcHRpb25zLml0ZW1UZW1wbGF0ZSh0aGlzLmNvbXBhcmVMaXN0LmdldChpZCkpKS5hcHBlbmRUbyh0aGlzLiRjb21wYXJlSXRlbXMpLnJldmVhbGVyKCdzaG93Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDb250cm9scyB3aGV0aGVyIHRvIGFkZCBvciByZW1vdmUgYSBwcm9kdWN0IGZyb20gdGhlIGNvbXBhcmUgbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoZWNrYm94IFRoZSBjaGVja2JveCAoZG9tIGVsZW1lbnQpXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3RvZ2dsZUl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlSXRlbShjaGVja2JveCkge1xuICAgICAgdmFyICRjaGVja2JveCA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShjaGVja2JveCk7XG4gICAgICB2YXIgaWQgPSBwYXJzZUludCgkY2hlY2tib3guZGF0YSgnY29tcGFyZS1pZCcpLCAxMCk7XG4gICAgICB2YXIgcHJvZHVjdERhdGEgPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdGl0bGU6ICRjaGVja2JveC5kYXRhKCdjb21wYXJlLXRpdGxlJyksXG4gICAgICAgIHVybDogJGNoZWNrYm94LmRhdGEoJ2NvbXBhcmUtdXJsJyksXG4gICAgICAgIHByaWNlOiAkY2hlY2tib3guZGF0YSgnY29tcGFyZS1wcmljZScpLFxuICAgICAgICB0aHVtYm5haWw6ICRjaGVja2JveC5kYXRhKCdjb21wYXJlLXRodW1ibmFpbCcpXG4gICAgICB9O1xuXG4gICAgICAvLyBBZGQgLyByZW1vdmUgaXRlbSBmcm9tIGNvbXBhcmUgbGlzdFxuICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgdGhpcy5fYWRkSXRlbShpZCwgcHJvZHVjdERhdGEpO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGFuIGFycmF5IG9mIHRoZSBjb21wYXJlIElEcyBzbyB3ZSBjYW4gdGFyZ2V0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAgIHZhciBjb21wYXJlSWRzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmNvbXBhcmVMaXN0LmtleXMoKSkpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgaXRlbSBmcm9tIHRoZSBsaXN0IGlmID4gbWF4SXRlbXNcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZUxpc3Quc2l6ZSA+IHRoaXMub3B0aW9ucy5tYXhJdGVtcykge1xuICAgICAgICAgIHZhciBmaXJzdEl0ZW0gPSBjb21wYXJlSWRzWzBdO1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUl0ZW0oZmlyc3RJdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlSXRlbShpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGNvbXBhcmUgbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbSB0byBhZGRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvZHVjdERhdGEgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgb2YgYSBjb21wYXJlIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYWRkSXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRJdGVtKGlkLCBwcm9kdWN0RGF0YSkge1xuICAgICAgdGhpcy5lbWl0KCdiZWZvcmVhZGQnLCBpZCk7XG5cbiAgICAgIHRoaXMuY29tcGFyZUxpc3Quc2V0KGlkLCBwcm9kdWN0RGF0YSk7XG5cbiAgICAgIHRoaXMuX3BvcHVsYXRlV2lkZ2V0KGlkKTtcblxuICAgICAgdGhpcy5fdXBkYXRlV2lkZ2V0U3RhdGUoKTtcblxuICAgICAgdGhpcy5lbWl0KCdhZnRlcmFkZCcsIGlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBjb21wYXJlIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlbW92ZUl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlSXRlbShpZCkge1xuICAgICAgdGhpcy5lbWl0KCdiZWZvcmVyZW1vdmUnLCBpZCk7XG5cbiAgICAgIHRoaXMuY29tcGFyZUxpc3QuZGVsZXRlKGlkKTtcblxuICAgICAgdGhpcy4kY29tcGFyZUl0ZW1zLmZpbmQoJ1snICsgdGhpcy5jb21wYXJlUmVtb3ZlICsgJz0nICsgaWQgKyAnXScpLmNsb3Nlc3QodGhpcy5jb21wYXJlSXRlbSkucmV2ZWFsZXIoJ2hpZGUnKTtcblxuICAgICAgKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHRoaXMuY29tcGFyZUl0ZW0pLm9uKCdyZXZlYWxlci1oaWRlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShldmVudC5jdXJyZW50VGFyZ2V0KS5yZW1vdmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBVbmNoZWNrIHRoZSBjaGVja2JveCBpZiByZW1vdmVkIHZpYSBidXR0b25cbiAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSgnW2RhdGEtY29tcGFyZS1pZD1cIicgKyBpZCArICdcIl0nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xuXG4gICAgICB0aGlzLl91cGRhdGVXaWRnZXRTdGF0ZSgpO1xuXG4gICAgICB0aGlzLmVtaXQoJ2FmdGVycmVtb3ZlJywgaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHVibGljIG1ldGhvZCB0byBjbGVhciB0aGUgbGlzdCBhbmQgd2lkZ2V0IGl0ZW1zXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlQWxsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLmNvbXBhcmVMaXN0LmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBpZCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHRoaXMuX3JlbW92ZUl0ZW0oaWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZXRzIGVhY2ggY2hlY2tib3ggaW4gdGhlIGNvbXBhcmUgbGlzdCB0byBcImNoZWNrZWRcIi5cbiAgICAgKiBVc2VmdWwgaWYgcHJvZHVjdHMgYXJlIGxvYWRlZCBkeW5hbWljYWxseSBhbmQgdGhlIHdpZGdldCBpcyBhbHJlYWR5IGluaXRpYWxpemVkLlxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUNoZWNrYm94ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDaGVja2JveGVzKCkge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSB0aGlzLmNvbXBhcmVMaXN0LmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBpZCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIHRoaXMuX2NoZWNrQ2hlY2tib3goaWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wYXJlIHdpZGdldCBzdGF0ZVxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVXaWRnZXRTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVXaWRnZXRTdGF0ZSgpIHtcbiAgICAgIHZhciBjb21wYXJlTGVuZ3RoID0gdGhpcy5jb21wYXJlTGlzdC5zaXplO1xuXG4gICAgICAvLyBUb2dnbGUgd2lkZ2V0IHN0YXRlIGNsYXNzXG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoJ1tkYXRhLWNvbXBhcmUtd2lkZ2V0XScpLnRvZ2dsZUNsYXNzKCdpcy1lbmFibGVkJywgISFjb21wYXJlTGVuZ3RoKTtcblxuICAgICAgLy8gVG9nZ2xlIGNvbXBhcmUgbGluayBjbGFzc1xuICAgICAgdGhpcy4kY29tcGFyZUxpbmsudG9nZ2xlQ2xhc3MoJ2lzLWRpc2FibGVkJywgY29tcGFyZUxlbmd0aCA8PSAxKTtcblxuICAgICAgLy8gU2V0IGNvbXBhcmUgbGluayBocmVmXG4gICAgICB0aGlzLiRjb21wYXJlTGluay5hdHRyKCdocmVmJywgdGhpcy4kY29tcGFyZUxpbmsuZGF0YSgnY29tcGFyZS1saW5rJykgKyAnLycgKyBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuY29tcGFyZUxpc3Qua2V5cygpKSkuam9pbignLycpKTtcblxuICAgICAgLy8gU2F2ZSB0aGUgY29tcGFyZSBkYXRhIGZvciBsYXRlclxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnY29tcGFyZScsIEpTT04uc3RyaW5naWZ5KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5jb21wYXJlTGlzdCkpKSk7XG5cbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT3Zlci1yaWRlIEV2ZW50RW1pdHRlcidzIFwib25cIiBtZXRob2Qgc28gdGhhdCBldmVudHMgY2FuIGJlIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZXkncmUgYm91bmRcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgdmFyIGZpcmVPbkJpbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICBfZ2V0KFByb2R1Y3RDb21wYXJlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFByb2R1Y3RDb21wYXJlLnByb3RvdHlwZSksICdvbicsIHRoaXMpLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIGlmIChmaXJlT25CaW5kKSB7XG4gICAgICAgIHRoaXMuZW1pdChldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQcm9kdWN0Q29tcGFyZTtcbn0oX2V2ZW50ZW1pdHRlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFByb2R1Y3RDb21wYXJlOyIsIi8qIVxuICogUmV2ZWFsZXIgMy4wLjBcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMSwgUGl4ZWwgVW5pb24gLSBodHRwOi8vcGl4ZWx1bmlvbi5uZXRcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24oJCl7XG4gIC8vIGNoZWNrIGZvciB0cmVuZCBldmVudCAobWFrZSBzdXJlIGpxdWVyeS50cmVuZCBpcyBpbmNsdWRlZClcbiAgaWYgKHR5cGVvZiAkLmV2ZW50LnNwZWNpYWwudHJlbmQgIT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQbGVhc2UgbWFrZSBzdXJlIGpxdWVyeS50cmVuZCBpcyBpbmNsdWRlZCEgT3RoZXJ3aXNlIHJldmVhbGVyIHdvbid0IHdvcmsuXCIpO1xuICB9XG5cbiAgLy8gU2ltcGxlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbFxuICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZnVuY3Rpb24oZm4pIHsgd2luZG93LnNldFRpbWVvdXQoZm4sIDEwMDAvNjApOyB9XG5cblxuICAvLyBQdWJsaWMgQVBJXG4gIHZhciBtZXRob2RzID0ge1xuICAgIGlzVmlzaWJsZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiAhIWVsLmRhdGEoXCJyZXZlYWxlci12aXNpYmxlXCIpO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbihlbCwgZm9yY2UpIHtcbiAgICAgIC8vIENoZWNrIHN0YXRlXG4gICAgICBpZiAobWV0aG9kcy5pc1Zpc2libGUoZWwpKSB7XG4gICAgICAgIGVsLnJlbW92ZUNsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1pblwiKTtcbiAgICAgICAgZWwub2ZmKFwicmV2ZWFsZXItYW5pbWF0aW5nIHJldmVhbGVyLXNob3dcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgZWwuZGF0YShcInJldmVhbGVyLXZpc2libGVcIiwgdHJ1ZSk7XG4gICAgICBlbC5vZmYoXCJ0cmVuZFwiKTtcblxuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgIGVsLmFkZENsYXNzKFwidmlzaWJsZVwiKTtcbiAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWFuaW1hdGluZ1wiKTtcbiAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItc2hvd1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFN0YXJ0IGFuaW1hdGlvbiBzdGF0ZSB0cmFuc2l0aW9uXG4gICAgICAgIGVsLmFkZENsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1pblwiKTtcbiAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWFuaW1hdGluZ1wiKTtcblxuICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbC5hZGRDbGFzcyhcInZpc2libGVcIik7XG5cbiAgICAgICAgICBlbC5vbmUoXCJ0cmVuZFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLWluXCIpO1xuICAgICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLXNob3dcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKGVsLCBmb3JjZSkge1xuICAgICAgLy8gQ2hlY2sgc3RhdGVcbiAgICAgIGlmICghbWV0aG9kcy5pc1Zpc2libGUoZWwpKSB7XG4gICAgICAgIGVsLnJlbW92ZUNsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1vdXQgdmlzaWJsZVwiKTtcbiAgICAgICAgZWwub2ZmKFwicmV2ZWFsZXItYW5pbWF0aW5nIHJldmVhbGVyLWhpZGVcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgZWwuZGF0YShcInJldmVhbGVyLXZpc2libGVcIiwgZmFsc2UpO1xuICAgICAgZWwub2ZmKFwidHJlbmRcIik7XG5cbiAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICBlbC5yZW1vdmVDbGFzcyhcInZpc2libGVcIik7XG4gICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1hbmltYXRpbmdcIik7XG4gICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWhpZGVcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICBlbC5hZGRDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctb3V0XCIpO1xuICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItYW5pbWF0aW5nXCIpO1xuXG4gICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKFwidmlzaWJsZVwiKTtcblxuICAgICAgICAgIGVsLm9uZShcInRyZW5kXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBlbC5yZW1vdmVDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctaW4gYW5pbWF0aW5nLW91dFwiKTtcbiAgICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1oaWRlXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0b2dnbGU6IGZ1bmN0aW9uKGVsLCBmb3JjZSkge1xuICAgICAgaWYgKG1ldGhvZHMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICBtZXRob2RzLmhpZGUoZWwsIGZvcmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGhvZHMuc2hvdyhlbCwgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBqUXVlcnkgcGx1Z2luXG4gICQuZm4ucmV2ZWFsZXIgPSBmdW5jdGlvbihtZXRob2QsIGZvcmNlKSB7XG4gICAgLy8gR2V0IGFjdGlvblxuICAgIHZhciBhY3Rpb24gPSBtZXRob2RzW21ldGhvZCB8fCBcInRvZ2dsZVwiXTtcbiAgICBpZiAoIWFjdGlvbikgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBSdW4gYWN0aW9uXG4gICAgaWYgKG1ldGhvZCA9PT0gXCJpc1Zpc2libGVcIikge1xuICAgICAgcmV0dXJuIGFjdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICBhY3Rpb24oJCh0aGlzKSwgZm9yY2UpO1xuICAgIH0pO1xuICB9O1xufSkoalF1ZXJ5KTtcbiIsIi8qIVxuICogVHJlbmQgMC4xLjBcbiAqXG4gKiBGYWlsLXNhZmUgVHJhbnNpdGlvbkVuZCBldmVudCBmb3IgalF1ZXJ5LlxuICpcbiAqIEFkZHMgYSBuZXcgXCJ0cmVuZFwiIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgaW4gYnJvd3NlcnMgdGhhdCBkb24ndFxuICogc3VwcG9ydCBcInRyYW5zaXRpb25lbmRcIi5cbiAqXG4gKiBOT1RFOiBPbmx5IHN1cHBvcnRzIGJlaW5nIGJvdW5kIHdpdGggXCJqUXVlcnkub25lXCIuXG4gKlxuICogQ29weXJpZ2h0IDIwMTQsIFBpeGVsIFVuaW9uIC0gaHR0cDovL3BpeGVsdW5pb24ubmV0XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbigkKXtcblxuICAvLyBQcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWVzXG4gIHZhciB0cmFuc2l0aW9uRW5kRXZlbnRzID1cbiAgICBcIndlYmtpdFRyYW5zaXRpb25FbmQgXCIgK1xuICAgIFwib3RyYW5zaXRpb25lbmQgXCIgK1xuICAgIFwib1RyYW5zaXRpb25FbmQgXCIgK1xuICAgIFwibXNUcmFuc2l0aW9uRW5kIFwiICtcbiAgICBcInRyYW5zaXRpb25lbmRcIjtcblxuICAvLyBQcmVmaXhlZCB0cmFuc2l0aW9uIGR1cmF0aW9uIHByb3BlcnR5IG5hbWVzXG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25Qcm9wZXJ0aWVzID0gW1xuICAgIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLW1vei10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1tcy10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItby10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCIta2h0bWwtdHJhbnNpdGlvbi1kdXJhdGlvblwiXG4gIF07XG5cbiAgLy8gUGFyc2VzIGEgQ1NTIGR1cmF0aW9uIHZhbHVlIGludG8gbWlsbGlzZWNvbmRzLlxuICB2YXIgcGFyc2VEdXJhdGlvbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICBzID0gcy5yZXBsYWNlKC9cXHMvLCBcIlwiKTtcbiAgICB2YXIgdiA9IHdpbmRvdy5wYXJzZUZsb2F0KHMpO1xuXG4gICAgcmV0dXJuIHMubWF0Y2goL1tebV1zJC9pKVxuICAgICAgPyB2ICogMTAwMFxuICAgICAgOiB2O1xuICB9O1xuXG4gIC8vIEdldCB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBmb3IgYW4gZWxlbWVudCwgYXMgc3BlY2lmaWVkIGJ5IENTUy5cbiAgLy8gUmV0dXJucyBhIHZhbHVlIGluIG1pbGxpc2Vjb25kcy5cbiAgdmFyIGdldFRyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNpdGlvbkR1cmF0aW9uUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHJhdyBDU1MgdmFsdWVcbiAgICAgIHZhciB2YWx1ZSA9IGVsLmNzcyh0cmFuc2l0aW9uRHVyYXRpb25Qcm9wZXJ0aWVzW2ldKTtcbiAgICAgIGlmICghdmFsdWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBNdWx0aXBsZSB0cmFuc2l0aW9ucy0tcGljayB0aGUgbG9uZ2VzdFxuICAgICAgaWYgKHZhbHVlLmluZGV4T2YoXCIsXCIpICE9PSAtMSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICB2YXIgZHVyYXRpb25zID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gcGFyc2VEdXJhdGlvbih2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGR1cmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heC5hcHBseShNYXRoLCBkdXJhdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5nbGUgdHJhbnNpdGlvblxuICAgICAgZWxzZSB7XG4gICAgICAgIGR1cmF0aW9uID0gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFjY2VwdCBmaXJzdCB2YXVlXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH07XG5cbiAgJC5ldmVudC5zcGVjaWFsLnRyZW5kID0ge1xuICAgIC8vIFRyaWdnZXJzIGFuIGV2ZW50IGhhbmRsZXIgd2hlbiBhbiBlbGVtZW50IGlzIGRvbmUgdHJhbnNpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIEhhbmRsZXMgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRyYW5zaXRpb25lbmQgYnkgYWRkaW5nIGFcbiAgICAvLyB0aW1lb3V0IHdpdGggdGhlIHRyYW5zaXRpb24gZHVyYXRpb24uXG4gICAgYWRkOiBmdW5jdGlvbihoYW5kbGVPYmopIHtcbiAgICAgIHZhciBlbCA9ICQodGhpcyk7XG4gICAgICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICAgICAgLy8gTWFyayBlbGVtZW50IGFzIGJlaW5nIGluIHRyYW5zaXRpb25cbiAgICAgIGVsLmRhdGEoXCJ0cmVuZFwiLCB0cnVlKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGEgZmFsbGJhY2sgZHVyYXRpb24uICsgMjAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGZpcmVcbiAgICAgIC8vIHRpbWVvdXRzIGZhc3RlciB0aGFuIHRyYW5zaXRpb25lbmQuXG4gICAgICB2YXIgZHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb24oZWwpICsgMjA7XG5cbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gdHJhbnNpdGlvbmVuZCBldmVudHMgY2FuIGJlIHNlbnQgZm9yIGVhY2ggcHJvcGVydHkuIExldCdzIGp1c3RcbiAgICAgICAgLy8gc2tpcCBhbGwgYnV0IHRoZSBmaXJzdC4gQWxzbyBoYW5kbGVzIHRoZSB0aW1lb3V0IGNhbGxiYWNrLlxuICAgICAgICBpZiAoZmlyZWQpIHJldHVybjtcblxuICAgICAgICAvLyBDaGlsZCBlbGVtZW50cyB0aGF0IGFsc28gaGF2ZSB0cmFuc2l0aW9ucyBjYW4gYmUgZmlyZWQgYmVmb3JlIHdlXG4gICAgICAgIC8vIGNvbXBsZXRlLiBUaGlzIHdpbGwgY2F0Y2ggYW5kIGlnbm9yZSB0aG9zZS4gVW5mb3J0dW5hdGVseSwgd2UnbGxcbiAgICAgICAgLy8gaGF2ZSB0byByZWx5IG9uIHRoZSB0aW1lb3V0IGluIHRoZXNlIGNhc2VzLlxuICAgICAgICBpZiAoZSAmJiBlLnNyY0VsZW1lbnQgIT09IGVsWzBdKSByZXR1cm47XG5cbiAgICAgICAgLy8gTWFyayBlbGVtZW50IGhhcyBub3QgYmVpbmcgaW4gdHJhbnNpdGlvblxuICAgICAgICBlbC5kYXRhKFwidHJlbmRcIiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIENhbGxiYWNrXG4gICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhbmRsZU9iai5oYW5kbGVyKSBoYW5kbGVPYmouaGFuZGxlcigpO1xuICAgICAgfTtcblxuICAgICAgZWwub25lKHRyYW5zaXRpb25FbmRFdmVudHMsIGNiKTtcbiAgICAgIGVsLmRhdGEoXCJ0cmVuZC10aW1lb3V0XCIsIHdpbmRvdy5zZXRUaW1lb3V0KGNiLCBkdXJhdGlvbikpO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKGhhbmRsZU9iaikge1xuICAgICAgdmFyIGVsID0gJCh0aGlzKTtcbiAgICAgIGVsLm9mZih0cmFuc2l0aW9uRW5kRXZlbnRzKTtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZWwuZGF0YShcInRyZW5kLXRpbWVvdXRcIikpO1xuICAgIH1cbiAgfTtcblxufSkoalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9qcXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIF9qcXVlcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanF1ZXJ5KTtcblxudmFyIF9qcXVlcnlUcmVuZCA9IHJlcXVpcmUoJ2pxdWVyeS10cmVuZCcpO1xuXG52YXIgX2pxdWVyeVRyZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pxdWVyeVRyZW5kKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIExvYWRpbmdVdGlscyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9hZGluZ1V0aWxzKG9wdGlvbnMsIHNjcm9sbExvY2ssIGVsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRpbmdVdGlscyk7XG5cbiAgICB0aGlzLnNjcm9sbExvY2sgPSBzY3JvbGxMb2NrO1xuICAgIHRoaXMuJGJvZHkgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoZG9jdW1lbnQuYm9keSk7XG4gICAgdGhpcy4kZWwgPSBlbCA/ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShlbCkgOiB0aGlzLiRib2R5O1xuXG4gICAgdGhpcy5vcHRpb25zID0gX2pxdWVyeTIuZGVmYXVsdC5leHRlbmQoe1xuICAgICAgbG9hZGluZ01hcmt1cDogJzxkaXYgY2xhc3M9XCJsb2FkaW5nXCI+PHNwYW4gY2xhc3M9XCJsb2FkaW5nLXNwaW5uZXJcIj48L3NwYW4+PC9kaXY+JyxcbiAgICAgIHZpc2libGVDbGFzczogJ3Zpc2libGUnLFxuICAgICAgc2Nyb2xsTG9ja0NsYXNzOiAnc2Nyb2xsLWxvY2tlZCdcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuJGxvYWRpbmcgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcy5vcHRpb25zLmxvYWRpbmdNYXJrdXApO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExvYWRpbmdVdGlscywgW3tcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnNjcm9sbExvY2spIHtcbiAgICAgICAgdGhpcy4kYm9keS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc2Nyb2xsTG9ja0NsYXNzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRQb3NpdGlvbmluZyA9IHRoaXMuJGVsLmNzcygncG9zaXRpb24nKTtcblxuICAgICAgaWYgKGVsZW1lbnRQb3NpdGlvbmluZyA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgdGhpcy4kZWwuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbC5wcmVwZW5kKHRoaXMuJGxvYWRpbmcpO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuJGxvYWRpbmcuYWRkQ2xhc3MoX3RoaXMub3B0aW9ucy52aXNpYmxlQ2xhc3MpO1xuICAgICAgfSwgMTApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hpZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnNjcm9sbExvY2spIHtcbiAgICAgICAgdGhpcy4kYm9keS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc2Nyb2xsTG9ja0NsYXNzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kbG9hZGluZy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudmlzaWJsZUNsYXNzKS5vbmUoJ3RyZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuJGxvYWRpbmcucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTG9hZGluZ1V0aWxzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMb2FkaW5nVXRpbHM7IiwiLyohXG4gKiBUcmVuZCAwLjEuMFxuICpcbiAqIEZhaWwtc2FmZSBUcmFuc2l0aW9uRW5kIGV2ZW50IGZvciBqUXVlcnkuXG4gKlxuICogQWRkcyBhIG5ldyBcInRyZW5kXCIgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCBpbiBicm93c2VycyB0aGF0IGRvbid0XG4gKiBzdXBwb3J0IFwidHJhbnNpdGlvbmVuZFwiLlxuICpcbiAqIE5PVEU6IE9ubHkgc3VwcG9ydHMgYmVpbmcgYm91bmQgd2l0aCBcImpRdWVyeS5vbmVcIi5cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCwgUGl4ZWwgVW5pb24gLSBodHRwOi8vcGl4ZWx1bmlvbi5uZXRcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG47KGZ1bmN0aW9uKCQpe1xuXG4gIC8vIFByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZXNcbiAgdmFyIHRyYW5zaXRpb25FbmRFdmVudHMgPVxuICAgIFwid2Via2l0VHJhbnNpdGlvbkVuZCBcIiArXG4gICAgXCJvdHJhbnNpdGlvbmVuZCBcIiArXG4gICAgXCJvVHJhbnNpdGlvbkVuZCBcIiArXG4gICAgXCJtc1RyYW5zaXRpb25FbmQgXCIgK1xuICAgIFwidHJhbnNpdGlvbmVuZFwiO1xuXG4gIC8vIFByZWZpeGVkIHRyYW5zaXRpb24gZHVyYXRpb24gcHJvcGVydHkgbmFtZXNcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvblByb3BlcnRpZXMgPSBbXG4gICAgXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItbW96LXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi13ZWJraXQtdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLW1zLXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1vLXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1raHRtbC10cmFuc2l0aW9uLWR1cmF0aW9uXCJcbiAgXTtcblxuICAvLyBQYXJzZXMgYSBDU1MgZHVyYXRpb24gdmFsdWUgaW50byBtaWxsaXNlY29uZHMuXG4gIHZhciBwYXJzZUR1cmF0aW9uID0gZnVuY3Rpb24ocykge1xuICAgIHMgPSBzLnJlcGxhY2UoL1xccy8sIFwiXCIpO1xuICAgIHZhciB2ID0gd2luZG93LnBhcnNlRmxvYXQocyk7XG5cbiAgICByZXR1cm4gcy5tYXRjaCgvW15tXXMkL2kpXG4gICAgICA/IHYgKiAxMDAwXG4gICAgICA6IHY7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGZvciBhbiBlbGVtZW50LCBhcyBzcGVjaWZpZWQgYnkgQ1NTLlxuICAvLyBSZXR1cm5zIGEgdmFsdWUgaW4gbWlsbGlzZWNvbmRzLlxuICB2YXIgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgZHVyYXRpb24gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2l0aW9uRHVyYXRpb25Qcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBHZXQgcmF3IENTUyB2YWx1ZVxuICAgICAgdmFyIHZhbHVlID0gZWwuY3NzKHRyYW5zaXRpb25EdXJhdGlvblByb3BlcnRpZXNbaV0pO1xuICAgICAgaWYgKCF2YWx1ZSkgY29udGludWU7XG5cbiAgICAgIC8vIE11bHRpcGxlIHRyYW5zaXRpb25zLS1waWNrIHRoZSBsb25nZXN0XG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihcIixcIikgIT09IC0xKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgIHZhciBkdXJhdGlvbnMgPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBwYXJzZUR1cmF0aW9uKHZhbHVlc1tpXSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZHVyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGR1cmF0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbmdsZSB0cmFuc2l0aW9uXG4gICAgICBlbHNlIHtcbiAgICAgICAgZHVyYXRpb24gPSBwYXJzZUR1cmF0aW9uKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWNjZXB0IGZpcnN0IHZhdWVcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfTtcblxuICAkLmV2ZW50LnNwZWNpYWwudHJlbmQgPSB7XG4gICAgLy8gVHJpZ2dlcnMgYW4gZXZlbnQgaGFuZGxlciB3aGVuIGFuIGVsZW1lbnQgaXMgZG9uZSB0cmFuc2l0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gSGFuZGxlcyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdHJhbnNpdGlvbmVuZCBieSBhZGRpbmcgYVxuICAgIC8vIHRpbWVvdXQgd2l0aCB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbi5cbiAgICBhZGQ6IGZ1bmN0aW9uKGhhbmRsZU9iaikge1xuICAgICAgdmFyIGVsID0gJCh0aGlzKTtcbiAgICAgIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBNYXJrIGVsZW1lbnQgYXMgYmVpbmcgaW4gdHJhbnNpdGlvblxuICAgICAgZWwuZGF0YShcInRyZW5kXCIsIHRydWUpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYSBmYWxsYmFjayBkdXJhdGlvbi4gKyAyMCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgZmlyZVxuICAgICAgLy8gdGltZW91dHMgZmFzdGVyIHRoYW4gdHJhbnNpdGlvbmVuZC5cbiAgICAgIHZhciBkdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbihlbCkgKyAyMDtcblxuICAgICAgdmFyIGNiID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyB0cmFuc2l0aW9uZW5kIGV2ZW50cyBjYW4gYmUgc2VudCBmb3IgZWFjaCBwcm9wZXJ0eS4gTGV0J3MganVzdFxuICAgICAgICAvLyBza2lwIGFsbCBidXQgdGhlIGZpcnN0LiBBbHNvIGhhbmRsZXMgdGhlIHRpbWVvdXQgY2FsbGJhY2suXG4gICAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIENoaWxkIGVsZW1lbnRzIHRoYXQgYWxzbyBoYXZlIHRyYW5zaXRpb25zIGNhbiBiZSBmaXJlZCBiZWZvcmUgd2VcbiAgICAgICAgLy8gY29tcGxldGUuIFRoaXMgd2lsbCBjYXRjaCBhbmQgaWdub3JlIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCB3ZSdsbFxuICAgICAgICAvLyBoYXZlIHRvIHJlbHkgb24gdGhlIHRpbWVvdXQgaW4gdGhlc2UgY2FzZXMuXG4gICAgICAgIGlmIChlICYmIGUuc3JjRWxlbWVudCAhPT0gZWxbMF0pIHJldHVybjtcblxuICAgICAgICAvLyBNYXJrIGVsZW1lbnQgaGFzIG5vdCBiZWluZyBpbiB0cmFuc2l0aW9uXG4gICAgICAgIGVsLmRhdGEoXCJ0cmVuZFwiLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gQ2FsbGJhY2tcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaGFuZGxlT2JqLmhhbmRsZXIpIGhhbmRsZU9iai5oYW5kbGVyKCk7XG4gICAgICB9O1xuXG4gICAgICBlbC5vbmUodHJhbnNpdGlvbkVuZEV2ZW50cywgY2IpO1xuICAgICAgZWwuZGF0YShcInRyZW5kLXRpbWVvdXRcIiwgd2luZG93LnNldFRpbWVvdXQoY2IsIGR1cmF0aW9uKSk7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oaGFuZGxlT2JqKSB7XG4gICAgICB2YXIgZWwgPSAkKHRoaXMpO1xuICAgICAgZWwub2ZmKHRyYW5zaXRpb25FbmRFdmVudHMpO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChlbC5kYXRhKFwidHJlbmQtdGltZW91dFwiKSk7XG4gICAgfVxuICB9O1xuXG59KShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2pxdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgX2pxdWVyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qcXVlcnkpO1xuXG52YXIgX2pxdWVyeVRyZW5kID0gcmVxdWlyZSgnanF1ZXJ5LXRyZW5kJyk7XG5cbnZhciBfanF1ZXJ5VHJlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanF1ZXJ5VHJlbmQpO1xuXG52YXIgX2pxdWVyeVJldmVhbGVyID0gcmVxdWlyZSgnanF1ZXJ5LXJldmVhbGVyJyk7XG5cbnZhciBfanF1ZXJ5UmV2ZWFsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanF1ZXJ5UmV2ZWFsZXIpO1xuXG52YXIgX2p1c3REZWJvdW5jZSA9IHJlcXVpcmUoJ2p1c3QtZGVib3VuY2UnKTtcblxudmFyIF9qdXN0RGVib3VuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanVzdERlYm91bmNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE1vZGFsID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb2RhbChvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsKTtcblxuICAgIHRoaXMuJG1vZGFsO1xuICAgIHRoaXMuJG1vZGFsQ29udGVudDtcbiAgICB0aGlzLiRkaWFsb2c7XG4gICAgdGhpcy4kYm9keSA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSgnYm9keScpO1xuICAgIHRoaXMuJGVsID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKG9wdGlvbnMuZWwpO1xuICAgIHRoaXMuJGJhY2tkcm9wID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKCc8ZGl2IGNsYXNzPVwibW9kYWwtb3ZlcmxheVwiPicpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gX2pxdWVyeTIuZGVmYXVsdC5leHRlbmQoe1xuICAgICAgbW9kYWxJZDogJ21vZGFsJyxcbiAgICAgIG1vZGFsQ2xhc3M6ICcnLFxuICAgICAgYm9keU92ZXJmbG93Q2xhc3M6ICdzY3JvbGwtbG9ja2VkJyxcbiAgICAgIGNlbnRlclZlcnRpY2FsbHk6IHRydWUsXG4gICAgICBjbG9zZVNlbGVjdG9yOiAnLm1vZGFsLWNsb3NlJyxcbiAgICAgIGFmdGVyU2hvdzogZnVuY3Rpb24gYWZ0ZXJTaG93KCkge30sXG4gICAgICBhZnRlckhpZGU6IGZ1bmN0aW9uIGFmdGVySGlkZSgpIHt9XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLndyYXBwZXJIdG1sID0gJzxkaXYgaWQ9XCInICsgdGhpcy5vcHRpb25zLm1vZGFsSWQgKyAnXCIgY2xhc3M9XCJtb2RhbC13cmFwcGVyXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJkaWFsb2dcIj48ZGl2IGNsYXNzPVwiJyArIHRoaXMub3B0aW9ucy5tb2RhbENsYXNzICsgJyBtb2RhbFwiIHJvbGU9XCJkb2N1bWVudFwiPjxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+JztcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgdXAgb3VyIGZyZXNoIG1vZGFsIGVsZW1lbnRcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTW9kYWwsIFt7XG4gICAga2V5OiAnX2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIC8vIGdldCB0aGUgY29udGVudHNcbiAgICAgIHRoaXMuJG1vZGFsQ29udGVudCA9IHRoaXMuJGVsLmNoaWxkcmVuKCkuZGV0YWNoKCk7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgd3JhcHBpbmcgZWxlbWVudFxuICAgICAgdGhpcy4kbW9kYWwgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcy53cmFwcGVySHRtbCk7XG4gICAgICAvLyBwb3Agb3VyIGNvbnRlbnQgaW4gdGhlcmVcbiAgICAgIHRoaXMuJG1vZGFsLmZpbmQoJy5tb2RhbC1jb250ZW50JykuYXBwZW5kKHRoaXMuJG1vZGFsQ29udGVudCk7XG4gICAgICAvLyBhZGQgYmFja2Ryb3BcbiAgICAgIHRoaXMuJGJhY2tkcm9wLmFwcGVuZFRvKHRoaXMuJGJvZHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1dCBldmVyeXRoaW5nIGJhY2sgd2hlcmUgdGhleSB1c2VkIHRvIGJlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldCgpIHtcbiAgICAgIHRoaXMuJG1vZGFsLmRldGFjaCgpO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kKHRoaXMuJG1vZGFsQ29udGVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyBib3RoIHRoZSBtb2RhbCBhbmQgYmFja2Ryb3BcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX29wZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgIHRoaXMuX2JpbmRPdmVybGF5Q2xpY2soKTtcbiAgICAgIHRoaXMuX2JpbmRDbG9zZUNsaWNrKCk7XG4gICAgICB0aGlzLl9iaW5kQ2xvc2VFc2MoKTtcblxuICAgICAgdGhpcy4kYm9keS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYm9keU92ZXJmbG93Q2xhc3MpLmFwcGVuZCh0aGlzLiRtb2RhbCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2VudGVyVmVydGljYWxseSkge1xuICAgICAgICB0aGlzLiRkaWFsb2cgPSB0aGlzLiRtb2RhbC5maW5kKCcubW9kYWwnKTtcbiAgICAgICAgdGhpcy5fYmluZFJlc2l6ZSgpO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIG1vZGFsIGZvciB0aGUgZmlyc3QgdGltZSBqdXN0IGFmdGVyIGl0J3MgYmVlbiB1bmhpZGRlblxuICAgICAgICB0aGlzLiRtb2RhbC5vbmUoJ3JldmVhbGVyLWFuaW1hdGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5fcmVwb3NpdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gYmluZCBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgdGhpcy4kbW9kYWwub25lKCdyZXZlYWxlci1zaG93JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzLm9wdGlvbnMuYWZ0ZXJTaG93KCgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShldmVudC5jdXJyZW50VGFyZ2V0KSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gc2hvdyBib3RoIG1vZGFsICYgYmFja2Ryb3BcbiAgICAgIHRoaXMuJG1vZGFsLmFkZCh0aGlzLiRiYWNrZHJvcCkucmV2ZWFsZXIoJ3Nob3cnKTtcblxuICAgICAgLy8gc2V0IHVwIGJhY2tkcm9wIHJlbW92YWwgb24gaGlkZVxuICAgICAgdGhpcy4kYmFja2Ryb3Aub24oJ3JldmVhbGVyLWhpZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLiRiYWNrZHJvcC5yZW1vdmUoKTtcbiAgICAgICAgX3RoaXMub3B0aW9ucy5hZnRlckhpZGUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGUgIGJvdGggdGhlIG1vZGFsIGFuZCBiYWNrZHJvcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2xvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xvc2UoKSB7XG4gICAgICB0aGlzLiRtb2RhbC5hZGQodGhpcy4kYmFja2Ryb3ApLnJldmVhbGVyKCdoaWRlJyk7XG5cbiAgICAgIHRoaXMuJGJvZHkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmJvZHlPdmVyZmxvd0NsYXNzKTtcblxuICAgICAgdGhpcy5fdW5iaW5kUmVzaXplKCk7XG4gICAgICB0aGlzLl9yZXNldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNsb3NlIG1vZGFsIGlmIHdlIGNsaWNrIG9ubHkgb24gYmFja2Ryb3BcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2JpbmRPdmVybGF5Q2xpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZE92ZXJsYXlDbGljaygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRtb2RhbC5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIF90aGlzMi5fY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xvc2UgbW9kYWwgaWYgd2UgY2xpY2sgb24gYSBjbG9zZSBidXR0b25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2JpbmRDbG9zZUNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRDbG9zZUNsaWNrKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG1vZGFsLm9uKCdjbGljaycsIHRoaXMub3B0aW9ucy5jbG9zZVNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMzLl9jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xvc2UgbW9kYWwgaWYgd2UgcHJlc3MgdGhlIGVzY2FwZSBidXR0b24gd2hlbiBpdCdzIHZpc2libGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2JpbmRDbG9zZUVzYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kQ2xvc2VFc2MoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGRvY3VtZW50KS5vbigna2V5dXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3ICYmIF90aGlzNC4kbW9kYWwucmV2ZWFsZXIoJ2lzVmlzaWJsZScpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBfdGhpczQuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBvc2l0aW9uaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgbWFyZ2luLXRvcCBmb3IgZWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVwb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXBvc2l0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLiRkaWFsb2cgfHwgIXRoaXMub3B0aW9ucy5jZW50ZXJWZXJ0aWNhbGx5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsSGVpZ2h0ID0gdGhpcy4kZGlhbG9nLm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgd2luZG93SGVpZ2h0ID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHdpbmRvdykuaGVpZ2h0KCk7XG4gICAgICB2YXIgZGlmZiA9ICh3aW5kb3dIZWlnaHQgLSBlbEhlaWdodCkgLyAyO1xuXG4gICAgICBkaWZmID0gZGlmZiA8IDAgPyAwIDogZGlmZjtcblxuICAgICAgdGhpcy4kZGlhbG9nLmNzcygnbWFyZ2luLXRvcCcsIGRpZmYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19iaW5kUmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRSZXNpemUoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHdpbmRvdykub24oJ3Jlc2l6ZS5tb2RhbCcsICgwLCBfanVzdERlYm91bmNlMi5kZWZhdWx0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNS5fcmVwb3NpdGlvbi5iaW5kKF90aGlzNSk7XG4gICAgICB9LCAxMDApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfdW5iaW5kUmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuYmluZFJlc2l6ZSgpIHtcbiAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh3aW5kb3cpLm9mZigncmVzaXplLm1vZGFsJyk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRXhwb3NlIFB1YmxpYyBNZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgfSwge1xuICAgIGtleTogJ29wZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgdGhpcy5fb3BlbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Nsb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB0aGlzLl9jbG9zZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Bvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICB0aGlzLl9yZXBvc2l0aW9uKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1vZGFsO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNb2RhbDsiLCIvKiFcbiAqIFJldmVhbGVyIDMuMC4wXG4gKlxuICogQ29weXJpZ2h0IDIwMjEsIFBpeGVsIFVuaW9uIC0gaHR0cDovL3BpeGVsdW5pb24ubmV0XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uKCQpe1xuICAvLyBjaGVjayBmb3IgdHJlbmQgZXZlbnQgKG1ha2Ugc3VyZSBqcXVlcnkudHJlbmQgaXMgaW5jbHVkZWQpXG4gIGlmICh0eXBlb2YgJC5ldmVudC5zcGVjaWFsLnRyZW5kICE9PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIG1ha2Ugc3VyZSBqcXVlcnkudHJlbmQgaXMgaW5jbHVkZWQhIE90aGVyd2lzZSByZXZlYWxlciB3b24ndCB3b3JrLlwiKTtcbiAgfVxuXG4gIC8vIFNpbXBsZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGxcbiAgdmFyIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIGZ1bmN0aW9uKGZuKSB7IHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAxMDAwLzYwKTsgfVxuXG5cbiAgLy8gUHVibGljIEFQSVxuICB2YXIgbWV0aG9kcyA9IHtcbiAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gISFlbC5kYXRhKFwicmV2ZWFsZXItdmlzaWJsZVwiKTtcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24oZWwsIGZvcmNlKSB7XG4gICAgICAvLyBDaGVjayBzdGF0ZVxuICAgICAgaWYgKG1ldGhvZHMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICBlbC5yZW1vdmVDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctaW5cIik7XG4gICAgICAgIGVsLm9mZihcInJldmVhbGVyLWFuaW1hdGluZyByZXZlYWxlci1zaG93XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBldmVudCBsaXN0ZW5lcnNcbiAgICAgIGVsLmRhdGEoXCJyZXZlYWxlci12aXNpYmxlXCIsIHRydWUpO1xuICAgICAgZWwub2ZmKFwidHJlbmRcIik7XG5cbiAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICBlbC5hZGRDbGFzcyhcInZpc2libGVcIik7XG4gICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1hbmltYXRpbmdcIik7XG4gICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLXNob3dcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAvLyBTdGFydCBhbmltYXRpb24gc3RhdGUgdHJhbnNpdGlvblxuICAgICAgICBlbC5hZGRDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctaW5cIik7XG4gICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1hbmltYXRpbmdcIik7XG5cbiAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZWwuYWRkQ2xhc3MoXCJ2aXNpYmxlXCIpO1xuXG4gICAgICAgICAgZWwub25lKFwidHJlbmRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1pblwiKTtcbiAgICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1zaG93XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbihlbCwgZm9yY2UpIHtcbiAgICAgIC8vIENoZWNrIHN0YXRlXG4gICAgICBpZiAoIW1ldGhvZHMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICBlbC5yZW1vdmVDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctb3V0IHZpc2libGVcIik7XG4gICAgICAgIGVsLm9mZihcInJldmVhbGVyLWFuaW1hdGluZyByZXZlYWxlci1oaWRlXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBldmVudCBsaXN0ZW5lcnNcbiAgICAgIGVsLmRhdGEoXCJyZXZlYWxlci12aXNpYmxlXCIsIGZhbHNlKTtcbiAgICAgIGVsLm9mZihcInRyZW5kXCIpO1xuXG4gICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJ2aXNpYmxlXCIpO1xuICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItYW5pbWF0aW5nXCIpO1xuICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1oaWRlXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgZWwuYWRkQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLW91dFwiKTtcbiAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWFuaW1hdGluZ1wiKTtcblxuICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbC5yZW1vdmVDbGFzcyhcInZpc2libGVcIik7XG5cbiAgICAgICAgICBlbC5vbmUoXCJ0cmVuZFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLWluIGFuaW1hdGluZy1vdXRcIik7XG4gICAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItaGlkZVwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlOiBmdW5jdGlvbihlbCwgZm9yY2UpIHtcbiAgICAgIGlmIChtZXRob2RzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgbWV0aG9kcy5oaWRlKGVsLCBmb3JjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRob2RzLnNob3coZWwsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8galF1ZXJ5IHBsdWdpblxuICAkLmZuLnJldmVhbGVyID0gZnVuY3Rpb24obWV0aG9kLCBmb3JjZSkge1xuICAgIC8vIEdldCBhY3Rpb25cbiAgICB2YXIgYWN0aW9uID0gbWV0aG9kc1ttZXRob2QgfHwgXCJ0b2dnbGVcIl07XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiB0aGlzO1xuXG4gICAgLy8gUnVuIGFjdGlvblxuICAgIGlmIChtZXRob2QgPT09IFwiaXNWaXNpYmxlXCIpIHtcbiAgICAgIHJldHVybiBhY3Rpb24odGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgYWN0aW9uKCQodGhpcyksIGZvcmNlKTtcbiAgICB9KTtcbiAgfTtcbn0pKGpRdWVyeSk7XG4iLCIvKiFcbiAqIFRyZW5kIDAuMS4wXG4gKlxuICogRmFpbC1zYWZlIFRyYW5zaXRpb25FbmQgZXZlbnQgZm9yIGpRdWVyeS5cbiAqXG4gKiBBZGRzIGEgbmV3IFwidHJlbmRcIiBldmVudCB0aGF0IGNhbiBiZSB1c2VkIGluIGJyb3dzZXJzIHRoYXQgZG9uJ3RcbiAqIHN1cHBvcnQgXCJ0cmFuc2l0aW9uZW5kXCIuXG4gKlxuICogTk9URTogT25seSBzdXBwb3J0cyBiZWluZyBib3VuZCB3aXRoIFwialF1ZXJ5Lm9uZVwiLlxuICpcbiAqIENvcHlyaWdodCAyMDE0LCBQaXhlbCBVbmlvbiAtIGh0dHA6Ly9waXhlbHVuaW9uLm5ldFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24oJCl7XG5cbiAgLy8gUHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lc1xuICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50cyA9XG4gICAgXCJ3ZWJraXRUcmFuc2l0aW9uRW5kIFwiICtcbiAgICBcIm90cmFuc2l0aW9uZW5kIFwiICtcbiAgICBcIm9UcmFuc2l0aW9uRW5kIFwiICtcbiAgICBcIm1zVHJhbnNpdGlvbkVuZCBcIiArXG4gICAgXCJ0cmFuc2l0aW9uZW5kXCI7XG5cbiAgLy8gUHJlZml4ZWQgdHJhbnNpdGlvbiBkdXJhdGlvbiBwcm9wZXJ0eSBuYW1lc1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uUHJvcGVydGllcyA9IFtcbiAgICBcInRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1tb3otdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLXdlYmtpdC10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItbXMtdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLW8tdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLWtodG1sLXRyYW5zaXRpb24tZHVyYXRpb25cIlxuICBdO1xuXG4gIC8vIFBhcnNlcyBhIENTUyBkdXJhdGlvbiB2YWx1ZSBpbnRvIG1pbGxpc2Vjb25kcy5cbiAgdmFyIHBhcnNlRHVyYXRpb24gPSBmdW5jdGlvbihzKSB7XG4gICAgcyA9IHMucmVwbGFjZSgvXFxzLywgXCJcIik7XG4gICAgdmFyIHYgPSB3aW5kb3cucGFyc2VGbG9hdChzKTtcblxuICAgIHJldHVybiBzLm1hdGNoKC9bXm1dcyQvaSlcbiAgICAgID8gdiAqIDEwMDBcbiAgICAgIDogdjtcbiAgfTtcblxuICAvLyBHZXQgdGhlIHRyYW5zaXRpb24gZHVyYXRpb24gZm9yIGFuIGVsZW1lbnQsIGFzIHNwZWNpZmllZCBieSBDU1MuXG4gIC8vIFJldHVybnMgYSB2YWx1ZSBpbiBtaWxsaXNlY29uZHMuXG4gIHZhciBnZXRUcmFuc2l0aW9uRHVyYXRpb24gPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBkdXJhdGlvbiA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zaXRpb25EdXJhdGlvblByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEdldCByYXcgQ1NTIHZhbHVlXG4gICAgICB2YXIgdmFsdWUgPSBlbC5jc3ModHJhbnNpdGlvbkR1cmF0aW9uUHJvcGVydGllc1tpXSk7XG4gICAgICBpZiAoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgLy8gTXVsdGlwbGUgdHJhbnNpdGlvbnMtLXBpY2sgdGhlIGxvbmdlc3RcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiLFwiKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgdmFyIGR1cmF0aW9ucyA9IChmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHBhcnNlRHVyYXRpb24odmFsdWVzW2ldKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChkdXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZHVyYXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2luZ2xlIHRyYW5zaXRpb25cbiAgICAgIGVsc2Uge1xuICAgICAgICBkdXJhdGlvbiA9IHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBY2NlcHQgZmlyc3QgdmF1ZVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9O1xuXG4gICQuZXZlbnQuc3BlY2lhbC50cmVuZCA9IHtcbiAgICAvLyBUcmlnZ2VycyBhbiBldmVudCBoYW5kbGVyIHdoZW4gYW4gZWxlbWVudCBpcyBkb25lIHRyYW5zaXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBIYW5kbGVzIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0cmFuc2l0aW9uZW5kIGJ5IGFkZGluZyBhXG4gICAgLy8gdGltZW91dCB3aXRoIHRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uLlxuICAgIGFkZDogZnVuY3Rpb24oaGFuZGxlT2JqKSB7XG4gICAgICB2YXIgZWwgPSAkKHRoaXMpO1xuICAgICAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgICAgIC8vIE1hcmsgZWxlbWVudCBhcyBiZWluZyBpbiB0cmFuc2l0aW9uXG4gICAgICBlbC5kYXRhKFwidHJlbmRcIiwgdHJ1ZSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBhIGZhbGxiYWNrIGR1cmF0aW9uLiArIDIwIGJlY2F1c2Ugc29tZSBicm93c2VycyBmaXJlXG4gICAgICAvLyB0aW1lb3V0cyBmYXN0ZXIgdGhhbiB0cmFuc2l0aW9uZW5kLlxuICAgICAgdmFyIGR1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uKGVsKSArIDIwO1xuXG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIHRyYW5zaXRpb25lbmQgZXZlbnRzIGNhbiBiZSBzZW50IGZvciBlYWNoIHByb3BlcnR5LiBMZXQncyBqdXN0XG4gICAgICAgIC8vIHNraXAgYWxsIGJ1dCB0aGUgZmlyc3QuIEFsc28gaGFuZGxlcyB0aGUgdGltZW91dCBjYWxsYmFjay5cbiAgICAgICAgaWYgKGZpcmVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gQ2hpbGQgZWxlbWVudHMgdGhhdCBhbHNvIGhhdmUgdHJhbnNpdGlvbnMgY2FuIGJlIGZpcmVkIGJlZm9yZSB3ZVxuICAgICAgICAvLyBjb21wbGV0ZS4gVGhpcyB3aWxsIGNhdGNoIGFuZCBpZ25vcmUgdGhvc2UuIFVuZm9ydHVuYXRlbHksIHdlJ2xsXG4gICAgICAgIC8vIGhhdmUgdG8gcmVseSBvbiB0aGUgdGltZW91dCBpbiB0aGVzZSBjYXNlcy5cbiAgICAgICAgaWYgKGUgJiYgZS5zcmNFbGVtZW50ICE9PSBlbFswXSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIE1hcmsgZWxlbWVudCBoYXMgbm90IGJlaW5nIGluIHRyYW5zaXRpb25cbiAgICAgICAgZWwuZGF0YShcInRyZW5kXCIsIGZhbHNlKTtcblxuICAgICAgICAvLyBDYWxsYmFja1xuICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgIGlmIChoYW5kbGVPYmouaGFuZGxlcikgaGFuZGxlT2JqLmhhbmRsZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIGVsLm9uZSh0cmFuc2l0aW9uRW5kRXZlbnRzLCBjYik7XG4gICAgICBlbC5kYXRhKFwidHJlbmQtdGltZW91dFwiLCB3aW5kb3cuc2V0VGltZW91dChjYiwgZHVyYXRpb24pKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihoYW5kbGVPYmopIHtcbiAgICAgIHZhciBlbCA9ICQodGhpcyk7XG4gICAgICBlbC5vZmYodHJhbnNpdGlvbkVuZEV2ZW50cyk7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGVsLmRhdGEoXCJ0cmVuZC10aW1lb3V0XCIpKTtcbiAgICB9XG4gIH07XG5cbn0pKGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfanF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbnZhciBfanF1ZXJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pxdWVyeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTY3JvbGxMaW5rID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY3JvbGxMaW5rKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Nyb2xsTGluayk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBfanF1ZXJ5Mi5kZWZhdWx0LmV4dGVuZCh7XG4gICAgICBzZWxlY3RvcjogJ1tkYXRhLXNjcm9sbF0nLFxuICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICBlYXNpbmc6ICdzd2luZycsXG4gICAgICBkZWxheTogMCxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIHVwZGF0ZUhhc2g6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY3JvbGxMaW5rLCBbe1xuICAgIGtleTogJ19iaW5kRXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRFdmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcy5vcHRpb25zLnNlbGVjdG9yKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl9zY3JvbGxUb0NvbnRlbnQoKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGUuY3VycmVudFRhcmdldCkpO1xuICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmRlbGF5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19zY3JvbGxUb0NvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2Nyb2xsVG9Db250ZW50KHRhcmdldCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5vcHRpb25zLmR1cmF0aW9uO1xuICAgICAgdmFyIGVhc2luZyA9IHRoaXMub3B0aW9ucy5lYXNpbmc7XG4gICAgICB2YXIgc2Nyb2xsVGFyZ2V0ID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHRhcmdldCkuZGF0YSgnc2Nyb2xsJykgfHwgdGFyZ2V0O1xuXG4gICAgICBpZiAoc2Nyb2xsVGFyZ2V0ID09PSAnIycpIHtcbiAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gJ2JvZHknO1xuICAgICAgfVxuXG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgc2Nyb2xsVG9wOiAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoc2Nyb2xsVGFyZ2V0KS5vZmZzZXQoKS50b3AgKyB0aGlzLm9wdGlvbnMub2Zmc2V0XG4gICAgICB9LCBkdXJhdGlvbiwgZWFzaW5nKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVIYXNoKSB7XG4gICAgICAgIGlmIChoaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBzY3JvbGxUYXJnZXQsIHNjcm9sbFRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzY3JvbGxUb0NvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxUb0NvbnRlbnQodGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5fc2Nyb2xsVG9Db250ZW50KHRhcmdldCk7XG4gICAgICB9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY3JvbGxMaW5rO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGxMaW5rOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9qcXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIF9qcXVlcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanF1ZXJ5KTtcblxudmFyIF9qdXN0RGVib3VuY2UgPSByZXF1aXJlKCdqdXN0LWRlYm91bmNlJyk7XG5cbnZhciBfanVzdERlYm91bmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2p1c3REZWJvdW5jZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBUYWJzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUYWJzKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFicyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBfanF1ZXJ5Mi5kZWZhdWx0LmV4dGVuZCh7XG5cbiAgICAgIC8vIFNjb3BpbmcgdGhlIHRhYnMgKGV2ZW50IGJpbmRpbmcpLCBsaW5rIGNsYXNzLCBhbmQgY29udGVudFxuICAgICAgdGFiU2NvcGU6ICdbZGF0YS10YWJzXScsXG4gICAgICB0YWJUb2dnbGU6ICdbZGF0YS10YWItbGlua10nLFxuICAgICAgdGFiQ29udGVudDogJ1tkYXRhLXRhYi1jb250ZW50XScsXG4gICAgICB0b2dnbGVUYWI6IHRoaXMuX2RlZmF1bHRUb2dnbGVUYWIsXG4gICAgICBrZWVwVGFic09wZW46IHRoaXMua2VlcFRhYnNPcGVuLFxuICAgICAgYWN0aXZlQ2xhc3M6ICdhY3RpdmUnLFxuICAgICAgZGVmYXVsdFRhYjogJycsXG4gICAgICBhZnRlclNldHVwOiBmdW5jdGlvbiBhZnRlclNldHVwKCkge30sXG4gICAgICBhZnRlckNoYW5nZTogZnVuY3Rpb24gYWZ0ZXJDaGFuZ2UoJGVsZW1lbnQpIHt9LFxuICAgICAgdGFiSGlzdG9yeTogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuJHNjb3BlID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHRoaXMub3B0aW9ucy50YWJTY29wZSk7XG4gICAgdGhpcy4kdGFiVG9nZ2xlcyA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh0aGlzLm9wdGlvbnMudGFiVG9nZ2xlKTtcbiAgICB0aGlzLiR0YWJDb250ZW50cyA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh0aGlzLm9wdGlvbnMudGFiQ29udGVudCk7XG5cbiAgICB0aGlzLmRlZmF1bHRUYWIgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdFRhYiB8fCB0aGlzLiR0YWJDb250ZW50cy5nZXQoMCk7XG5cbiAgICB0aGlzLmN1cnJlbnRUYWIgPSB0aGlzLl9kZWZhdWx0VGFiKCk7XG4gICAgdGhpcy5wcmV2aW91c1N0eWxlID0gdGhpcy5fZ2V0VGFiU3R5bGUoKTtcblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICB0aGlzLl9pbml0KCk7XG4gICAgdGhpcy5vcHRpb25zLmFmdGVyU2V0dXAoKTtcbiAgfVxuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC9cbiAgIERlZmF1bHQgZnVuY3Rpb25zOiBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nIGNhbGxiYWNrcyBpbnRvIGNvbnN0cnVjdG9yXG4gICAqL1xuXG4gIC8vIEZpbmQgb3V0IHRoZSBkZWZhdWx0IHRhYiAoaWYgbm9uZSBzZWxlY3RlZCBpbiBvcHRpb25zKVxuXG5cbiAgX2NyZWF0ZUNsYXNzKFRhYnMsIFt7XG4gICAga2V5OiAnX2RlZmF1bHRUYWInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVmYXVsdFRhYigpIHtcbiAgICAgIHJldHVybiB0aGlzLiR0YWJDb250ZW50cy5maXJzdCgpLmF0dHIoJ2lkJyk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBmdW5jdGlvbiB0byB0b2dnbGUgYSB0YWIgYmV0d2VlbiBhY3RpdmUgLyBpbmFjdGl2ZVxuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGVmYXVsdFRvZ2dsZVRhYicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWZhdWx0VG9nZ2xlVGFiKGVsZW1lbnQsIGFjdGl2ZSkge1xuICAgICAgdmFyICRlbGVtZW50ID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGVsZW1lbnQpO1xuXG4gICAgICAkZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmFjdGl2ZUNsYXNzLCBhY3RpdmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19nZXRUYWJTdHlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUYWJTdHlsZSgpIHtcbiAgICAgIHZhciBwc2V1ZG9FbGVtID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kc2NvcGUuZ2V0KDApLCAnOmJlZm9yZScpLmNvbnRlbnQucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgcmV0dXJuIHBzZXVkb0VsZW07XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBmdW5jdGlvbiB0byB0b2dnbGUgc29tZSBjb250ZW50IG9uIG9yIG9mZlxuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGVmYXVsdFRvZ2dsZUNvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVmYXVsdFRvZ2dsZUNvbnRlbnQoZWxlbWVudCwgYWN0aXZlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgJGVsZW1lbnQgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoZWxlbWVudCk7XG5cbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0YWIgdG8gYWN0aXZlXG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzU3R5bGUgPT09ICdzbGlkZScpIHtcbiAgICAgICAgICAvLyBzaG93IHdpdGggYSBzbGlkZXRvZ2dsZVxuICAgICAgICAgICRlbGVtZW50LnNsaWRlRG93bignZmFzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuYWZ0ZXJDaGFuZ2UoJGVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNob3cgc2ltcGx5IHZpYSBkaXNwbGF5XG4gICAgICAgICAgJGVsZW1lbnQuc2hvdygpO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZnRlckNoYW5nZSgkZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldCB0aGUgdGFiIHRvIGluYWN0aXZlXG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzU3R5bGUgPT09ICdzbGlkZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdmlhIGEgc2xpZGVUb2dnbGVcbiAgICAgICAgICAkZWxlbWVudC5zbGlkZVVwKCdmYXN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5hZnRlckNoYW5nZSgkZWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHZpYSBhIHNpbXBsZSBoaWRlXG4gICAgICAgICAgJGVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZnRlckNoYW5nZSgkZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHRhcmdldCBhbGwgdGFicyBvciBpbmRpdmlkdWFsIHRhYnNcbiAgICAvLyAoU3dhcCBiZXR3ZWVuIHRhYiBhbmQgYWNjb3JkaW9uIGZ1bmN0aW9uYWxpdHkuKVxuXG4gIH0sIHtcbiAgICBrZXk6ICdrZWVwVGFic09wZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZWVwVGFic09wZW4oKSB7XG4gICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggPCA4MDA7XG4gICAgfVxuXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gL1xuICAgICBBY3RpdmF0aW9uIGZ1bmN0aW9uczogVHJpZ2dlciB0aGUgY2FsbGJhY2tzIGZvciBzaG93aW5nIC8gaGlkaW5nIHRhYlxuICAgICBjb21wb25lbnRzIGFuZCBsaW5rc1xuICAgICAqL1xuXG4gICAgLy8gU2V0IGEgcGFydGljdWxhciB0YWIgYXMgYWN0aXZlIChhbmQgb3B0aW9uYWxseSBkaXNhYmxlIG90aGVycylcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGEgd3JhcHBlciBmb3IgYWN0aXZhdGluZyBib3RoIHRoZSB0YWItbGluayBhbmRcbiAgICAvLyB0YWItY29udGVudCBhdCB0aGUgc2FtZSB0aW1lLlxuXG4gIH0sIHtcbiAgICBrZXk6ICdhY3RpdmF0ZVRhYicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2YXRlVGFiKGhhc2gsIGNsb3NlT3RoZXJzKSB7XG5cbiAgICAgIC8vIG5lY2Vzc2FyeSB0byBjaGVjayBmb3IgbGlua3MgdGhhdCBsaW5rIHRvIHRhYnMgdGhhdCBhcmVuJ3QgYXZhaWxhYmxlOlxuICAgICAgaWYgKCEoMCwgX2pxdWVyeTIuZGVmYXVsdCkoaGFzaCkubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0YWIgZG9lc25cXCd0IGV4aXN0IScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1N0aWNreSA9IGNsb3NlT3RoZXJzIHx8IHRoaXMub3B0aW9ucy5rZWVwVGFic09wZW4oKTtcbiAgICAgIHRoaXMuYWN0aXZhdGVUYWJUb2dnbGUoaGFzaCwgaXNTdGlja3kpO1xuICAgICAgdGhpcy5hY3RpdmF0ZVRhYkNvbnRlbnQoaGFzaCwgaXNTdGlja3kpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBiYy10YWJzIGlmIGNvbnRlbnQgd2l0aCB0YWJzIGlzIHVwZGF0ZWQsIHJlZnJlc2hlZCBvciByZXBsYWNlZFxuXG4gIH0sIHtcbiAgICBrZXk6ICd1bmxvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmxvYWQoKSB7XG4gICAgICB0aGlzLiRzY29wZS5vZmYoJy5iYy10YWJzJyk7XG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkod2luZG93KS5vZmYoJy5iYy10YWJzJyk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGEgcGFydGljdWxhciBbZGF0YS10YWItdG9nZ2xlXSBsaW5rIGFzIGFjdGl2ZSxcbiAgICAvLyBhbmQgKG9wdGlvbmFsbHkpIGRlYWN0aXZhdGUgb3RoZXJzXG5cbiAgfSwge1xuICAgIGtleTogJ2FjdGl2YXRlVGFiVG9nZ2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWN0aXZhdGVUYWJUb2dnbGUoaGFzaCkge1xuICAgICAgdmFyIGlzU3RpY2t5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuXG4gICAgICB2YXIgJHRoaXNUYWIgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoaGFzaCk7XG5cbiAgICAgIC8vIEZpbmQgdGFibGlua3MgdGhhdCBwb2ludCB0byB0aGlzIGhhc2hcbiAgICAgIHZhciAkdGFiTGlua3MgPSB0aGlzLiR0YWJUb2dnbGVzLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcykuYXR0cignaHJlZicpID09PSBoYXNoO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghaXNTdGlja3kpIHtcbiAgICAgICAgLy8gVGFiIHN0aWNreW5lc3Mgbm90IGFjdGl2ZSwgdGFyZ2V0IGFsbCBvdGhlciB0YWJzIGluIGdyb3VwXG5cbiAgICAgICAgaWYgKCR0aGlzVGFiLmlzKCc6dmlzaWJsZScpKSByZXR1cm47XG4gICAgICAgIC8vIEdyYWIgYWxsIHRoZSBncm91cHMgdGhlc2UgbGlua3MgYmVsb25nIHRvXG4gICAgICAgIHZhciB0YWJzR3JvdXBzID0gW107XG4gICAgICAgICR0YWJMaW5rcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGhpc1RhYkdyb3VwID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHRoaXMpLmRhdGEoJ3RhYnMtZ3JvdXAnKTtcbiAgICAgICAgICBpZiAodGFic0dyb3Vwcy5pbmRleE9mKHRoaXNUYWJHcm91cCkgPT09IC0xKSB7XG4gICAgICAgICAgICB0YWJzR3JvdXBzLnB1c2godGhpc1RhYkdyb3VwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpbHRlciBhbGwgdGhlIHRhYnMgdG8gb25seSB0aG9zZSBiZWxvbmdpbmcgdG8gdGhlc2UgZ3JvdXBzXG4gICAgICAgIHZhciAkdGFic0dyb3VwID0gdGhpcy4kdGFiVG9nZ2xlcy5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0YWJzR3JvdXBzLmluZGV4T2YoKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHRoaXMpLmRhdGEoJ3RhYnMtZ3JvdXAnKSkgPiAtMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGlzYWJsZSBhbGwgdGhlIHRhYiBsaW5rc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR0YWJzR3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMudG9nZ2xlVGFiKCR0YWJzR3JvdXBbaV0sIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuYWJsZSBqdXN0IHRoZSB0YWIgbGlua3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaGFzaFxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgJHRhYkxpbmtzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy50b2dnbGVUYWIoJHRhYkxpbmtzW19pXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRhYnMgYXJlIHN0aWNreSwgc28gd2Ugc2hvdWxkIG9ubHkgdG9nZ2xlIGl0ZW1zIG1hdGNoaW5nIHRoaXMgaGFzaFxuICAgICAgICBpZiAoJHRoaXNUYWIuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAvLyBFbmFibGUganVzdCB0aGUgdGFiIGxpbmtzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGhhc2hcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCAkdGFiTGlua3MubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRvZ2dsZVRhYigkdGFiTGlua3NbX2kyXSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCAkdGFiTGlua3MubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRvZ2dsZVRhYigkdGFiTGlua3NbX2kzXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWN0aXZhdGUgYSBjb250ZW50LWVsZW1lbnQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBoYXNoLCBhbmRcbiAgICAvLyAob3B0aW9uYWxseSkgaGlkZSBvdGhlcnMgaW4gZ3JvdXBcblxuICB9LCB7XG4gICAga2V5OiAnYWN0aXZhdGVUYWJDb250ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWN0aXZhdGVUYWJDb250ZW50KGhhc2gpIHtcbiAgICAgIHZhciBpc1N0aWNreSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIHZhciAkdGhpc1RhYiA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShoYXNoKTtcblxuICAgICAgaWYgKCFpc1N0aWNreSkge1xuXG4gICAgICAgIGlmICgkdGhpc1RhYi5pcygnOnZpc2libGUnKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIExvY2F0ZSBvdGhlciB0YWJzIHRoYXQgc2hhcmUgdGhlIHNhbWUgJ3RhYnMtZ3JvdXAnXG4gICAgICAgIHZhciB0YWJzR3JvdXAgPSAkdGhpc1RhYi5kYXRhKCd0YWJzLWdyb3VwJyk7XG4gICAgICAgIHZhciAkdGFic0dyb3VwID0gdGhpcy4kdGFiQ29udGVudHMuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHRoaXMpLmRhdGEoJ3RhYnMtZ3JvdXAnKSA9PT0gdGFic0dyb3VwO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEaXNhYmxlIG90aGVyIHRhYnMgaW4gdGhpcyBncm91cFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR0YWJzR3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9kZWZhdWx0VG9nZ2xlQ29udGVudCgkdGFic0dyb3VwW2ldLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5hYmxlIHRoaXMgdGFiIGNvbnRlbnRcbiAgICAgICAgdGhpcy5fZGVmYXVsdFRvZ2dsZUNvbnRlbnQoJHRoaXNUYWIsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGFicyBhcmUgc3RpY2t5LCBzbyB3ZSBvbmx5IHRvZ2dsZSB0aGUgaW5kaXZpZHVhbCBpdGVtXG4gICAgICAgIGlmICgkdGhpc1RhYi5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgIHRoaXMuX2RlZmF1bHRUb2dnbGVDb250ZW50KCR0aGlzVGFiLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZGVmYXVsdFRvZ2dsZUNvbnRlbnQoJHRoaXNUYWIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gL1xuICAgICBNaXNjZWxsYW5lb3VzOiBkZWFsIHdpdGggaW5pdGluZyB0aGUgYmFzZSB0YWIgc3RhdGUgKHNheSBhZnRlciByZXNpemluZ1xuICAgICB0aGUgdmlld3BvcnQgb3Igb24gcGFnZSBsb2FkKSBhbmQgZXZlbnQgYmluZGluZy5cbiAgICAgKi9cblxuICAgIC8vIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRhYnMgYXJlIGZpcnN0IGluaXQgKHNldHMgb25lIGFjdGl2ZSBvdmVyIG90aGVycylcblxuICB9LCB7XG4gICAga2V5OiAnX2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdChjaGVja1N0eWxlTWF0Y2gpIHtcbiAgICAgIGlmIChjaGVja1N0eWxlTWF0Y2gpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdHlsZSA9IHRoaXMuX2dldFRhYlN0eWxlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXNTdHlsZSA9PSBjdXJyZW50U3R5bGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZpb3VzU3R5bGUgPSBjdXJyZW50U3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2ggfHwgJyMnICsgdGhpcy5kZWZhdWx0VGFiLmlkO1xuICAgICAgdmFyIGN1cnJlbnRUYWIgPSBoYXNoID8gJ2FbaHJlZj1cIicgKyBoYXNoICsgJ1wiXScgOiAnW2RhdGEtdGFiLWxpbmtdOmZpcnN0JztcblxuICAgICAgLy8gRGlzYWJsZSBhbGwgdGhlIHRhYnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kdGFiVG9nZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLm9wdGlvbnMudG9nZ2xlVGFiKHRoaXMuJHRhYlRvZ2dsZXMuZ2V0KGkpLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHRoaXMuJHRhYkNvbnRlbnRzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFRvZ2dsZUNvbnRlbnQodGhpcy4kdGFiQ29udGVudHMuZ2V0KF9pNCksIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGVmYXVsdFRvZ2dsZUNvbnRlbnQoaGFzaCwgdHJ1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnMudG9nZ2xlVGFiKGN1cnJlbnRUYWIsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIEJpbmQgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIHNjb3BlIHRhcmdldC5cblxuICB9LCB7XG4gICAga2V5OiAnX2JpbmRFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRzY29wZS5vbignY2xpY2suYmMtdGFicycsIHRoaXMub3B0aW9ucy50YWJUb2dnbGUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgaGFzaCA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShldmVudC50YXJnZXQpLmF0dHIoJ2hyZWYnKTtcblxuICAgICAgICBfdGhpczIuYWN0aXZhdGVUYWIoaGFzaCk7XG5cbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnRhYkhpc3RvcnkpIHtcbiAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgaGFzaCwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGhhc2gsIGhhc2gpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UuYmMtdGFicycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmFjdGl2YXRlVGFiKHdpbmRvdy5sb2NhdGlvbi5oYXNoKTtcbiAgICAgIH0pO1xuXG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkod2luZG93KS5vbigncmVzaXplLmJjLXRhYnMnLCAoMCwgX2p1c3REZWJvdW5jZTIuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuX2luaXQodHJ1ZSk7XG4gICAgICB9LCAzMDApKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGFicztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGFicztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnLi8nKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJpbmQoR2V0SW50cmluc2ljKCdTdHJpbmcucHJvdG90eXBlLmluZGV4T2YnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xuXHRcdHJldHVybiBjYWxsQmluZChpbnRyaW5zaWMpO1xuXHR9XG5cdHJldHVybiBpbnRyaW5zaWM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG52YXIgc2V0RnVuY3Rpb25MZW5ndGggPSByZXF1aXJlKCdzZXQtZnVuY3Rpb24tbGVuZ3RoJyk7XG5cbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XG52YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCUnKTtcbnZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdlcy1kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHRpZiAodHlwZW9mIG9yaWdpbmFsRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuXHR9XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0cmV0dXJuIHNldEZ1bmN0aW9uTGVuZ3RoKFxuXHRcdGZ1bmMsXG5cdFx0MSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSxcblx0XHR0cnVlXG5cdCk7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3R5cGVzJylcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhcmRUeXBlXG5cbmZ1bmN0aW9uIENhcmRUeXBlIChkYXRhKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDYXJkVHlwZSkpIHJldHVybiBuZXcgQ2FyZFR5cGUoZGF0YSlcbiAgT2JqZWN0LmFzc2lnbih0aGlzLCBkYXRhKVxufVxuXG5DYXJkVHlwZS5wcm90b3R5cGUuZGlnaXRzID0gMTZcbkNhcmRUeXBlLnByb3RvdHlwZS5jdmNMZW5ndGggPSAzXG5DYXJkVHlwZS5wcm90b3R5cGUubHVobiA9IHRydWVcbkNhcmRUeXBlLnByb3RvdHlwZS5ncm91cFBhdHRlcm4gPSAvKFxcZHsxLDR9KShcXGR7MSw0fSk/KFxcZHsxLDR9KT8oXFxkezEsNH0pPy9cblxuQ2FyZFR5cGUucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gKG51bWJlci5tYXRjaCh0aGlzLmdyb3VwUGF0dGVybikgfHwgW10pXG4gICAgLnNsaWNlKDEpXG4gICAgLmZpbHRlcihCb29sZWFuKVxufVxuXG5DYXJkVHlwZS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIChudW1iZXIsIGVhZ2VyKSB7XG4gIHJldHVybiB0aGlzW2VhZ2VyID8gJ2VhZ2VyUGF0dGVybicgOiAncGF0dGVybiddLnRlc3QobnVtYmVyKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlKHtcbiAgbmFtZTogJ0FtZXJpY2FuIEV4cHJlc3MnLFxuICBkaWdpdHM6IDE1LFxuICBwYXR0ZXJuOiAvXjNbNDddXFxkezEzfSQvLFxuICBlYWdlclBhdHRlcm46IC9eM1s0N10vLFxuICBncm91cFBhdHRlcm46IC8oXFxkezEsNH0pKFxcZHsxLDZ9KT8oXFxkezEsNX0pPy8sXG4gIGN2Y0xlbmd0aDogNFxufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdEYW5rb3J0JyxcbiAgcGF0dGVybjogL141MDE5XFxkezEyfSQvLFxuICBlYWdlclBhdHRlcm46IC9eNTAxOS9cbn0pXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGUoe1xuICBuYW1lOiAnRGluZXJzIENsdWInLFxuICBkaWdpdHM6IFsxNCwgMTldLFxuICBwYXR0ZXJuOiAvXjMoMFswLTVdfFs2OF1cXGQpXFxkezExLDE2fSQvLFxuICBlYWdlclBhdHRlcm46IC9eMygwfFs2OF0pLyxcbiAgZ3JvdXBQYXR0ZXJuOiAvKFxcZHsxLDR9KT8oXFxkezEsNn0pPyhcXGR7MSw5fSk/L1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdEaXNjb3ZlcicsXG4gIHBhdHRlcm46IC9eNigwMTEoMFswLTldfFsyLTRdXFxkfDc0fDdbNy05XXw4WzYtOV18OVswLTldKXw0WzQtOV1cXGR7M318NVxcZHs0fSlcXGR7MTB9JC8sXG4gIGVhZ2VyUGF0dGVybjogL142KDAxMSgwWzAtOV18WzItNF18NzR8N1s3LTldfDhbNi05XXw5WzAtOV0pfDRbNC05XXw1KS9cbn0pXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGUoe1xuICBuYW1lOiAnRWxvJyxcbiAgcGF0dGVybjogL14oNFswMzVdfDVbMF18NlsyMzVdKSg2WzcyNjNdfDlbOTBdfDFbMjQxNl18N1s3MzZdfDhbOV18MFswNDU3OV18NVswXSkoWzAtOV0pKFswLTldKVxcZHsxMH0kLyxcbiAgZWFnZXJQYXR0ZXJuOiAvXig0WzAzNV18NVswXXw2WzIzNV0pKDZbNzI2M118OVs5MF18MVsyNDE2XXw3WzczNl18OFs5XXwwWzA0NTc5XXw1WzBdKShbMC05XSkoWzAtOV0pLyxcbiAgZ3JvdXBQYXR0ZXJuOiAvKFxcZHsxLDR9KShcXGR7MSw0fSk/KFxcZHsxLDR9KT8oXFxkezEsNH0pPyhcXGR7MSwzfSk/L1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdGb3JicnVnc2ZvcmVuaW5nZW4nLFxuICBwYXR0ZXJuOiAvXjYwMDcyMlxcZHsxMH0kLyxcbiAgZWFnZXJQYXR0ZXJuOiAvXjYwMC9cbn0pXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIHJlcXVpcmUoJy4vdmlzYScpLFxuICByZXF1aXJlKCcuL21hZXN0cm8nKSxcbiAgcmVxdWlyZSgnLi9mb3JicnVnc2ZvcmVuaW5nZW4nKSxcbiAgcmVxdWlyZSgnLi9kYW5rb3J0JyksXG4gIHJlcXVpcmUoJy4vbWFzdGVyY2FyZCcpLFxuICByZXF1aXJlKCcuL2FtZXJpY2FuLWV4cHJlc3MnKSxcbiAgcmVxdWlyZSgnLi9kaW5lcnMtY2x1YicpLFxuICByZXF1aXJlKCcuL2Rpc2NvdmVyJyksXG4gIHJlcXVpcmUoJy4vamNiJyksXG4gIHJlcXVpcmUoJy4vdW5pb25wYXknKSxcbiAgcmVxdWlyZSgnLi90cm95JyksXG4gIHJlcXVpcmUoJy4vZWxvJyksXG4gIHJlcXVpcmUoJy4vdWF0cCcpXG5dXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGUoe1xuICBuYW1lOiAnSkNCJyxcbiAgcGF0dGVybjogL14zNVxcZHsxNH0kLyxcbiAgZWFnZXJQYXR0ZXJuOiAvXjM1L1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdNYWVzdHJvJyxcbiAgZGlnaXRzOiBbMTIsIDE5XSxcbiAgcGF0dGVybjogL14oPzo1WzA2Nzg5XVxcZFxcZHwoPyE2MDExWzAyMzRdKSg/ITYwMTE3WzQ3ODldKSg/ITYwMTE4WzY3ODldKSg/ITYwMTE5KSg/ITY0WzQ1Njc4OV0pKD8hNjUpNlxcZHszfSlcXGR7OCwxNX0kLyxcbiAgZWFnZXJQYXR0ZXJuOiAvXig1KDAxOHwwWzIzXXxbNjhdKXw2WzM3XXw2MDExMXw2MDExNXw2MDExNyhbNTZdfDdbNTZdKXw2MDExOFswLTVdfDY0WzAtM118NjYpLyxcbiAgZ3JvdXBQYXR0ZXJuOiAvKFxcZHsxLDR9KShcXGR7MSw0fSk/KFxcZHsxLDR9KT8oXFxkezEsNH0pPyhcXGR7MSwzfSk/L1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdNYXN0ZXJjYXJkJyxcbiAgcGF0dGVybjogL14oNVsxLTVdWzAtOV17Mn18MjIyWzEtOV18MjJbMy05XVswLTldfDJbMy02XVswLTldezJ9fDI3WzAxXVswLTldfDI3MjApXFxkezEyfSQvLFxuICBlYWdlclBhdHRlcm46IC9eKDJbMy03XXwyMlsyLTldfDVbMS01XSkvXG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlKHtcbiAgbmFtZTogJ1Ryb3knLFxuICBwYXR0ZXJuOiAvXjk3OTJcXGR7MTJ9JC8sXG4gIGVhZ2VyUGF0dGVybjogL145NzkyL1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdVQVRQJyxcbiAgZGlnaXRzOiAxNSxcbiAgcGF0dGVybjogL14xXFxkezE0fSQvLFxuICBlYWdlclBhdHRlcm46IC9eMS8sXG4gIGdyb3VwUGF0dGVybjogLyhcXGR7MSw0fSkoXFxkezEsNX0pPyhcXGR7MSw2fSk/L1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdVbmlvblBheScsXG4gIHBhdHRlcm46IC9eNjJbMC01XVxcZHsxMywxNn0kLyxcbiAgZWFnZXJQYXR0ZXJuOiAvXjYyLyxcbiAgZ3JvdXBQYXR0ZXJuOiAvKFxcZHsxLDR9KShcXGR7MSw0fSk/KFxcZHsxLDR9KT8oXFxkezEsNH0pPyhcXGR7MSwzfSk/LyxcbiAgbHVobjogZmFsc2Vcbn0pXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGUoe1xuICBuYW1lOiAnVmlzYScsXG4gIGRpZ2l0czogWzEzLCAxOV0sXG4gIHBhdHRlcm46IC9eNFxcZHsxMn0oXFxkezN9fFxcZHs2fSk/JC8sXG4gIGVhZ2VyUGF0dGVybjogL140LyxcbiAgZ3JvdXBQYXR0ZXJuOiAvKFxcZHsxLDR9KShcXGR7MSw0fSk/KFxcZHsxLDR9KT8oXFxkezEsNH0pPyhcXGR7MSwzfSk/L1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBsdWhuID0gcmVxdWlyZSgnZmFzdC1sdWhuJylcbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpXG5cbm1vZHVsZS5leHBvcnRzID0gQ2FyZFxuXG5mdW5jdGlvbiBDYXJkIChkYXRhKSB7XG4gIGNvbnN0IHR5cGVzID0gVHlwZXMoZGF0YSlcblxuICByZXR1cm4ge1xuICAgIHR5cGVzOiBkYXRhLFxuICAgIHBhcnNlOiBwYXJzZUNhcmQsXG4gICAgZm9ybWF0OiBmb3JtYXRDYXJkLFxuICAgIHR5cGU6IGNhcmRUeXBlLFxuICAgIGx1aG46IGx1aG4sXG4gICAgaXNWYWxpZDogaXNDYXJkVmFsaWRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQ2FyZCAobnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICdzdHJpbmcnKSByZXR1cm4gJydcbiAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL1teXFxkXS9nLCAnJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdENhcmQgKG51bWJlciwgc2VwYXJhdG9yKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUobnVtYmVyLCB0cnVlKVxuICAgIGlmICghdHlwZSkgcmV0dXJuIG51bWJlclxuICAgIHJldHVybiB0eXBlLmdyb3VwKG51bWJlcikuam9pbihzZXBhcmF0b3IgfHwgJyAnKVxuICB9XG5cbiAgZnVuY3Rpb24gY2FyZFR5cGUgKG51bWJlciwgZWFnZXIpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZShudW1iZXIsIGVhZ2VyKVxuICAgIHJldHVybiB0eXBlID8gdHlwZS5uYW1lIDogdW5kZWZpbmVkXG4gIH1cblxuICBmdW5jdGlvbiBpc0NhcmRWYWxpZCAobnVtYmVyLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHR5cGUgPSB0eXBlcy5nZXQodHlwZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IGdldFR5cGUobnVtYmVyKVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiAoIXR5cGUubHVobiB8fCBsdWhuKG51bWJlcikpICYmIHR5cGUudGVzdChudW1iZXIpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUeXBlIChudW1iZXIsIGVhZ2VyKSB7XG4gICAgcmV0dXJuIHR5cGVzLmZpbmQoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlLnRlc3QobnVtYmVyLCBlYWdlcilcbiAgICB9KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJylcbmNvbnN0IGN2Y1JlZ2V4ID0gL15cXGR7Myw0fSQvXG5cbm1vZHVsZS5leHBvcnRzID0gQ3ZjXG5cbmZ1bmN0aW9uIEN2YyAoZGF0YSkge1xuICBjb25zdCB0eXBlcyA9IFR5cGVzKGRhdGEpXG5cbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBjdmNJc1ZhbGlkXG4gIH1cblxuICBmdW5jdGlvbiBjdmNJc1ZhbGlkIChjdmMsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIGN2YyAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZVxuICAgIGlmICghY3ZjUmVnZXgudGVzdChjdmMpKSByZXR1cm4gZmFsc2VcblxuICAgIGlmICghdHlwZSkge1xuICAgICAgcmV0dXJuIHR5cGVzLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3ZjTGVuZ3RoID09PSBjdmMubGVuZ3RoXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlcy5nZXQodHlwZSkuY3ZjTGVuZ3RoID09PSBjdmMubGVuZ3RoXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBpc1ZhbGlkTW9udGggPSByZXF1aXJlKCdpcy12YWxpZC1tb250aCcpXG5jb25zdCBwYXJzZUludFN0cmljdCA9IHJlcXVpcmUoJ3BhcnNlLWludCcpXG5jb25zdCBwYXJzZVllYXIgPSByZXF1aXJlKCdwYXJzZS15ZWFyJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzUGFzdDogaXNQYXN0LFxuICBtb250aDoge1xuICAgIHBhcnNlOiBwYXJzZU1vbnRoLFxuICAgIGlzVmFsaWQ6IGlzVmFsaWRNb250aFxuICB9LFxuICB5ZWFyOiB7XG4gICAgcGFyc2U6IHBhcnNlWWVhcixcbiAgICBmb3JtYXQ6IGZvcm1hdEV4cFllYXIsXG4gICAgaXNWYWxpZDogaXNFeHBZZWFyVmFsaWQsXG4gICAgaXNQYXN0OiBpc0V4cFllYXJQYXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQYXN0IChtb250aCwgeWVhcikge1xuICByZXR1cm4gRGF0ZS5ub3coKSA+PSBuZXcgRGF0ZSh5ZWFyLCBtb250aClcbn1cblxuZnVuY3Rpb24gcGFyc2VNb250aCAobW9udGgpIHtcbiAgcmV0dXJuIHBhcnNlSW50U3RyaWN0KG1vbnRoKVxufVxuXG5mdW5jdGlvbiBmb3JtYXRFeHBZZWFyICh5ZWFyLCBzdHJpcCkge1xuICB5ZWFyID0geWVhci50b1N0cmluZygpXG4gIHJldHVybiBzdHJpcCA/IHllYXIuc3Vic3RyKDIsIDQpIDogeWVhclxufVxuXG5mdW5jdGlvbiBpc0V4cFllYXJWYWxpZCAoeWVhcikge1xuICBpZiAodHlwZW9mIHllYXIgIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2VcbiAgeWVhciA9IHBhcnNlSW50U3RyaWN0KHllYXIpXG4gIHJldHVybiB5ZWFyID4gMFxufVxuXG5mdW5jdGlvbiBpc0V4cFllYXJQYXN0ICh5ZWFyKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgPiB5ZWFyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdHlwZXMgPSByZXF1aXJlKCdjcmVkaXRjYXJkcy10eXBlcycpXG5jb25zdCBDYXJkID0gcmVxdWlyZSgnLi9jYXJkJylcbmNvbnN0IEN2YyA9IHJlcXVpcmUoJy4vY3ZjJylcbmNvbnN0IGV4cGlyYXRpb24gPSByZXF1aXJlKCcuL2V4cGlyYXRpb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhUeXBlcyh0eXBlcylcbm1vZHVsZS5leHBvcnRzLndpdGhUeXBlcyA9IHdpdGhUeXBlc1xuXG5mdW5jdGlvbiB3aXRoVHlwZXMgKHR5cGVzKSB7XG4gIHJldHVybiB7XG4gICAgY2FyZDogQ2FyZCh0eXBlcyksXG4gICAgY3ZjOiBDdmModHlwZXMpLFxuICAgIGV4cGlyYXRpb246IGV4cGlyYXRpb25cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlZmF1bHRzID0gcmVxdWlyZSgnY3JlZGl0Y2FyZHMtdHlwZXMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhcmRUeXBlc1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0c1xuXG5mdW5jdGlvbiBDYXJkVHlwZXMgKHR5cGVzKSB7XG4gIGNvbnN0IG1hcCA9IHR5cGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0eXBlKSB7XG4gICAgYWNjW3R5cGUubmFtZV0gPSB0eXBlXG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSlcblxuICByZXR1cm4ge1xuICAgIGZpbmQ6IHR5cGVzLmZpbmQuYmluZCh0eXBlcyksXG4gICAgc29tZTogdHlwZXMuc29tZS5iaW5kKHR5cGVzKSxcbiAgICBnZXQ6IGdldFxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0IChuYW1lKSB7XG4gICAgY29uc3QgdHlwZSA9IG1hcFtuYW1lXVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHR5cGUgZm91bmQgZm9yIG5hbWU6ICcgKyBuYW1lKVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ2VzLWRlZmluZS1wcm9wZXJ0eScpO1xuXG52YXIgJFN5bnRheEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3N5bnRheCcpO1xudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xuXG52YXIgZ29wZCA9IHJlcXVpcmUoJ2dvcGQnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lRGF0YVByb3BlcnR5KFxuXHRvYmosXG5cdHByb3BlcnR5LFxuXHR2YWx1ZVxuKSB7XG5cdGlmICghb2JqIHx8ICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgb2JqYCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uYCcpO1xuXHR9XG5cdGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N5bWJvbCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYHByb3BlcnR5YCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgc3ltYm9sYCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzNdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25FbnVtZXJhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgdHlwZW9mIGFyZ3VtZW50c1s0XSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1s0XSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uV3JpdGFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNSAmJiB0eXBlb2YgYXJndW1lbnRzWzVdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzVdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Db25maWd1cmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNiAmJiB0eXBlb2YgYXJndW1lbnRzWzZdICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGxvb3NlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgbm9uRW51bWVyYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblx0dmFyIG5vbldyaXRhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuXHR2YXIgbm9uQ29uZmlndXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiBudWxsO1xuXHR2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gNiA/IGFyZ3VtZW50c1s2XSA6IGZhbHNlO1xuXG5cdC8qIEB0eXBlIHtmYWxzZSB8IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPHVua25vd24+fSAqL1xuXHR2YXIgZGVzYyA9ICEhZ29wZCAmJiBnb3BkKG9iaiwgcHJvcGVydHkpO1xuXG5cdGlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0XHQkZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBub25Db25maWd1cmFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2MuY29uZmlndXJhYmxlIDogIW5vbkNvbmZpZ3VyYWJsZSxcblx0XHRcdGVudW1lcmFibGU6IG5vbkVudW1lcmFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2MuZW51bWVyYWJsZSA6ICFub25FbnVtZXJhYmxlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IG5vbldyaXRhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLndyaXRhYmxlIDogIW5vbldyaXRhYmxlXG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAobG9vc2UgfHwgKCFub25FbnVtZXJhYmxlICYmICFub25Xcml0YWJsZSAmJiAhbm9uQ29uZmlndXJhYmxlKSkge1xuXHRcdC8vIG11c3QgZmFsbCBiYWNrIHRvIFtbU2V0XV0sIGFuZCB3YXMgbm90IGV4cGxpY2l0bHkgYXNrZWQgdG8gbWFrZSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlLCBvciBub24tY29uZmlndXJhYmxlXG5cdFx0b2JqW3Byb3BlcnR5XSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGRlZmluaW5nIGEgcHJvcGVydHkgYXMgbm9uLWNvbmZpZ3VyYWJsZSwgbm9uLXdyaXRhYmxlLCBvciBub24tZW51bWVyYWJsZS4nKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9ldmFsJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEV2YWxFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JhbmdlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JlZicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWZlcmVuY2VFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vc3ludGF4Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRheEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdXJpJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFVSSUVycm9yO1xuIiwiLyoqXG4gKiBFdkVtaXR0ZXIgdjIuMS4xXG4gKiBMaWwnIGV2ZW50IGVtaXR0ZXJcbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTIC0gQnJvd3NlcmlmeSwgV2VicGFja1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGdsb2JhbC5FdkVtaXR0ZXIgPSBmYWN0b3J5KCk7XG4gIH1cblxufSggdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCkge1xuXG5mdW5jdGlvbiBFdkVtaXR0ZXIoKSB7fVxuXG5sZXQgcHJvdG8gPSBFdkVtaXR0ZXIucHJvdG90eXBlO1xuXG5wcm90by5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gc2V0IGV2ZW50cyBoYXNoXG4gIGxldCBldmVudHMgPSB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIC8vIHNldCBsaXN0ZW5lcnMgYXJyYXlcbiAgbGV0IGxpc3RlbmVycyA9IGV2ZW50c1sgZXZlbnROYW1lIF0gPSBldmVudHNbIGV2ZW50TmFtZSBdIHx8IFtdO1xuICAvLyBvbmx5IGFkZCBvbmNlXG4gIGlmICggIWxpc3RlbmVycy5pbmNsdWRlcyggbGlzdGVuZXIgKSApIHtcbiAgICBsaXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub25jZSA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gYWRkIGV2ZW50XG4gIHRoaXMub24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgLy8gc2V0IG9uY2UgZmxhZ1xuICAvLyBzZXQgb25jZUV2ZW50cyBoYXNoXG4gIGxldCBvbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyA9IHRoaXMuX29uY2VFdmVudHMgfHwge307XG4gIC8vIHNldCBvbmNlTGlzdGVuZXJzIG9iamVjdFxuICBsZXQgb25jZUxpc3RlbmVycyA9IG9uY2VFdmVudHNbIGV2ZW50TmFtZSBdID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gfHwge307XG4gIC8vIHNldCBmbGFnXG4gIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF0gPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub2ZmID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKSB7XG4gIGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkgcmV0dXJuIHRoaXM7XG5cbiAgbGV0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoIGxpc3RlbmVyICk7XG4gIGlmICggaW5kZXggIT0gLTEgKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uZW1pdEV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgYXJncyApIHtcbiAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbIGV2ZW50TmFtZSBdO1xuICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSByZXR1cm4gdGhpcztcblxuICAvLyBjb3B5IG92ZXIgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIGlmIC5vZmYoKSBpbiBsaXN0ZW5lclxuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoIDAgKTtcbiAgYXJncyA9IGFyZ3MgfHwgW107XG4gIC8vIG9uY2Ugc3R1ZmZcbiAgbGV0IG9uY2VMaXN0ZW5lcnMgPSB0aGlzLl9vbmNlRXZlbnRzICYmIHRoaXMuX29uY2VFdmVudHNbIGV2ZW50TmFtZSBdO1xuXG4gIGZvciAoIGxldCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMgKSB7XG4gICAgbGV0IGlzT25jZSA9IG9uY2VMaXN0ZW5lcnMgJiYgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXTtcbiAgICBpZiAoIGlzT25jZSApIHtcbiAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgLy8gcmVtb3ZlIGJlZm9yZSB0cmlnZ2VyIHRvIHByZXZlbnQgcmVjdXJzaW9uXG4gICAgICB0aGlzLm9mZiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAgICAgLy8gdW5zZXQgb25jZSBmbGFnXG4gICAgICBkZWxldGUgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXTtcbiAgICB9XG4gICAgLy8gdHJpZ2dlciBsaXN0ZW5lclxuICAgIGxpc3RlbmVyLmFwcGx5KCB0aGlzLCBhcmdzICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmFsbE9mZiA9IGZ1bmN0aW9uKCkge1xuICBkZWxldGUgdGhpcy5fZXZlbnRzO1xuICBkZWxldGUgdGhpcy5fb25jZUV2ZW50cztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5yZXR1cm4gRXZFbWl0dGVyO1xuXG59ICkgKTtcbiIsIi8qIVxuICogRXZlbnRFbWl0dGVyMlxuICogaHR0cHM6Ly9naXRodWIuY29tL2hpajFueC9FdmVudEVtaXR0ZXIyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIGhpajFueFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG47IWZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICB2YXIgaGFzT3duUHJvcGVydHk9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheSA6IGZ1bmN0aW9uIF9pc0FycmF5KG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICB9O1xuICB2YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuICB2YXIgbmV4dFRpY2tTdXBwb3J0ZWQ9IHR5cGVvZiBwcm9jZXNzPT0nb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljaz09J2Z1bmN0aW9uJztcbiAgdmFyIHN5bWJvbHNTdXBwb3J0ZWQ9IHR5cGVvZiBTeW1ib2w9PT0nZnVuY3Rpb24nO1xuICB2YXIgcmVmbGVjdFN1cHBvcnRlZD0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnO1xuICB2YXIgc2V0SW1tZWRpYXRlU3VwcG9ydGVkPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nO1xuICB2YXIgX3NldEltbWVkaWF0ZT0gc2V0SW1tZWRpYXRlU3VwcG9ydGVkID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dDtcbiAgdmFyIG93bktleXM9IHN5bWJvbHNTdXBwb3J0ZWQ/IChyZWZsZWN0U3VwcG9ydGVkICYmIHR5cGVvZiBSZWZsZWN0Lm93bktleXM9PT0nZnVuY3Rpb24nPyBSZWZsZWN0Lm93bktleXMgOiBmdW5jdGlvbihvYmope1xuICAgIHZhciBhcnI9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gICAgYXJyLnB1c2guYXBwbHkoYXJyLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpO1xuICAgIHJldHVybiBhcnI7XG4gIH0pIDogT2JqZWN0LmtleXM7XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBpZiAodGhpcy5fY29uZikge1xuICAgICAgY29uZmlndXJlLmNhbGwodGhpcywgdGhpcy5fY29uZik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlKGNvbmYpIHtcbiAgICBpZiAoY29uZikge1xuICAgICAgdGhpcy5fY29uZiA9IGNvbmY7XG5cbiAgICAgIGNvbmYuZGVsaW1pdGVyICYmICh0aGlzLmRlbGltaXRlciA9IGNvbmYuZGVsaW1pdGVyKTtcblxuICAgICAgaWYoY29uZi5tYXhMaXN0ZW5lcnMhPT11bmRlZmluZWQpe1xuICAgICAgICAgIHRoaXMuX21heExpc3RlbmVycz0gY29uZi5tYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGNvbmYud2lsZGNhcmQgJiYgKHRoaXMud2lsZGNhcmQgPSBjb25mLndpbGRjYXJkKTtcbiAgICAgIGNvbmYubmV3TGlzdGVuZXIgJiYgKHRoaXMuX25ld0xpc3RlbmVyID0gY29uZi5uZXdMaXN0ZW5lcik7XG4gICAgICBjb25mLnJlbW92ZUxpc3RlbmVyICYmICh0aGlzLl9yZW1vdmVMaXN0ZW5lciA9IGNvbmYucmVtb3ZlTGlzdGVuZXIpO1xuICAgICAgY29uZi52ZXJib3NlTWVtb3J5TGVhayAmJiAodGhpcy52ZXJib3NlTWVtb3J5TGVhayA9IGNvbmYudmVyYm9zZU1lbW9yeUxlYWspO1xuICAgICAgY29uZi5pZ25vcmVFcnJvcnMgJiYgKHRoaXMuaWdub3JlRXJyb3JzID0gY29uZi5pZ25vcmVFcnJvcnMpO1xuXG4gICAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyVHJlZSA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ1Bvc3NpYmxlTWVtb3J5TGVhayhjb3VudCwgZXZlbnROYW1lKSB7XG4gICAgdmFyIGVycm9yTXNnID0gJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAnbGVhayBkZXRlY3RlZC4gJyArIGNvdW50ICsgJyBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJztcblxuICAgIGlmKHRoaXMudmVyYm9zZU1lbW9yeUxlYWspe1xuICAgICAgZXJyb3JNc2cgKz0gJyBFdmVudCBuYW1lOiAnICsgZXZlbnROYW1lICsgJy4nO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVtaXRXYXJuaW5nKXtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgIGUubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgZS5lbWl0dGVyID0gdGhpcztcbiAgICAgIGUuY291bnQgPSBjb3VudDtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JNc2cpO1xuXG4gICAgICBpZiAoY29uc29sZS50cmFjZSl7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW107XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBbYV07XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBbYSwgYl07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KG4pO1xuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgYXJyW25dID0gYXJndW1lbnRzW25dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHRvT2JqZWN0KGtleXMsIHZhbHVlcykge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIga2V5O1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzQ291bnQgPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgb2JqW2tleV0gPSBpIDwgdmFsdWVzQ291bnQgPyB2YWx1ZXNbaV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBUYXJnZXRPYnNlcnZlcihlbWl0dGVyLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9lbWl0dGVyID0gZW1pdHRlcjtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fbGlzdGVuZXJzQ291bnQgPSAwO1xuXG4gICAgdmFyIG9uLCBvZmY7XG5cbiAgICBpZiAob3B0aW9ucy5vbiB8fCBvcHRpb25zLm9mZikge1xuICAgICAgb24gPSBvcHRpb25zLm9uO1xuICAgICAgb2ZmID0gb3B0aW9ucy5vZmY7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBvbiA9IHRhcmdldC5hZGRFdmVudExpc3RlbmVyO1xuICAgICAgb2ZmID0gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYWRkTGlzdGVuZXIpIHtcbiAgICAgIG9uID0gdGFyZ2V0LmFkZExpc3RlbmVyO1xuICAgICAgb2ZmID0gdGFyZ2V0LnJlbW92ZUxpc3RlbmVyO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lm9uKSB7XG4gICAgICBvbiA9IHRhcmdldC5vbjtcbiAgICAgIG9mZiA9IHRhcmdldC5vZmY7XG4gICAgfVxuXG4gICAgaWYgKCFvbiAmJiAhb2ZmKSB7XG4gICAgICB0aHJvdyBFcnJvcigndGFyZ2V0IGRvZXMgbm90IGltcGxlbWVudCBhbnkga25vd24gZXZlbnQgQVBJJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdvbiBtZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignb2ZmIG1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vbiA9IG9uO1xuICAgIHRoaXMuX29mZiA9IG9mZjtcblxuICAgIHZhciBfb2JzZXJ2ZXJzPSBlbWl0dGVyLl9vYnNlcnZlcnM7XG4gICAgaWYoX29ic2VydmVycyl7XG4gICAgICBfb2JzZXJ2ZXJzLnB1c2godGhpcyk7XG4gICAgfWVsc2V7XG4gICAgICBlbWl0dGVyLl9vYnNlcnZlcnM9IFt0aGlzXTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuYXNzaWduKFRhcmdldE9ic2VydmVyLnByb3RvdHlwZSwge1xuICAgIHN1YnNjcmliZTogZnVuY3Rpb24oZXZlbnQsIGxvY2FsRXZlbnQsIHJlZHVjZXIpe1xuICAgICAgdmFyIG9ic2VydmVyPSB0aGlzO1xuICAgICAgdmFyIHRhcmdldD0gdGhpcy5fdGFyZ2V0O1xuICAgICAgdmFyIGVtaXR0ZXI9IHRoaXMuX2VtaXR0ZXI7XG4gICAgICB2YXIgbGlzdGVuZXJzPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICB2YXIgaGFuZGxlcj0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGFyZ3M9IHRvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGV2ZW50T2JqPSB7XG4gICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICBuYW1lOiBsb2NhbEV2ZW50LFxuICAgICAgICAgIG9yaWdpbmFsOiBldmVudFxuICAgICAgICB9O1xuICAgICAgICBpZihyZWR1Y2VyKXtcbiAgICAgICAgICB2YXIgcmVzdWx0PSByZWR1Y2VyLmNhbGwodGFyZ2V0LCBldmVudE9iaik7XG4gICAgICAgICAgaWYocmVzdWx0IT09ZmFsc2Upe1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0LmFwcGx5KGVtaXR0ZXIsIFtldmVudE9iai5uYW1lXS5jb25jYXQoYXJncykpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbWl0dGVyLmVtaXQuYXBwbHkoZW1pdHRlciwgW2xvY2FsRXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9O1xuXG5cbiAgICAgIGlmKGxpc3RlbmVyc1tldmVudF0pe1xuICAgICAgICB0aHJvdyBFcnJvcignRXZlbnQgXFwnJyArIGV2ZW50ICsgJ1xcJyBpcyBhbHJlYWR5IGxpc3RlbmluZycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNDb3VudCsrO1xuXG4gICAgICBpZihlbWl0dGVyLl9uZXdMaXN0ZW5lciAmJiBlbWl0dGVyLl9yZW1vdmVMaXN0ZW5lciAmJiAhb2JzZXJ2ZXIuX29uTmV3TGlzdGVuZXIpe1xuXG4gICAgICAgIHRoaXMuX29uTmV3TGlzdGVuZXIgPSBmdW5jdGlvbiAoX2V2ZW50KSB7XG4gICAgICAgICAgaWYgKF9ldmVudCA9PT0gbG9jYWxFdmVudCAmJiBsaXN0ZW5lcnNbZXZlbnRdID09PSBudWxsKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gaGFuZGxlcjtcbiAgICAgICAgICAgIG9ic2VydmVyLl9vbi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBlbWl0dGVyLm9uKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpO1xuXG4gICAgICAgIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXI9IGZ1bmN0aW9uKF9ldmVudCl7XG4gICAgICAgICAgaWYoX2V2ZW50ID09PSBsb2NhbEV2ZW50ICYmICFlbWl0dGVyLmhhc0xpc3RlbmVycyhfZXZlbnQpICYmIGxpc3RlbmVyc1tldmVudF0pe1xuICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XT0gbnVsbDtcbiAgICAgICAgICAgIG9ic2VydmVyLl9vZmYuY2FsbCh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XT0gbnVsbDtcblxuICAgICAgICBlbWl0dGVyLm9uKCdyZW1vdmVMaXN0ZW5lcicsIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGxpc3RlbmVyc1tldmVudF09IGhhbmRsZXI7XG4gICAgICAgIG9ic2VydmVyLl9vbi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgdmFyIG9ic2VydmVyPSB0aGlzO1xuICAgICAgdmFyIGxpc3RlbmVycz0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgdmFyIGVtaXR0ZXI9IHRoaXMuX2VtaXR0ZXI7XG4gICAgICB2YXIgaGFuZGxlcjtcbiAgICAgIHZhciBldmVudHM7XG4gICAgICB2YXIgb2ZmPSB0aGlzLl9vZmY7XG4gICAgICB2YXIgdGFyZ2V0PSB0aGlzLl90YXJnZXQ7XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYoZXZlbnQgJiYgdHlwZW9mIGV2ZW50IT09J3N0cmluZycpe1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2V2ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYXJSZWZzKCl7XG4gICAgICAgIGlmKG9ic2VydmVyLl9vbk5ld0xpc3RlbmVyKXtcbiAgICAgICAgICBlbWl0dGVyLm9mZignbmV3TGlzdGVuZXInLCBvYnNlcnZlci5fb25OZXdMaXN0ZW5lcik7XG4gICAgICAgICAgZW1pdHRlci5vZmYoJ3JlbW92ZUxpc3RlbmVyJywgb2JzZXJ2ZXIuX29uUmVtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgIG9ic2VydmVyLl9vbk5ld0xpc3RlbmVyPSBudWxsO1xuICAgICAgICAgIG9ic2VydmVyLl9vblJlbW92ZUxpc3RlbmVyPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleD0gZmluZFRhcmdldEluZGV4LmNhbGwoZW1pdHRlciwgb2JzZXJ2ZXIpO1xuICAgICAgICBlbWl0dGVyLl9vYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYoZXZlbnQpe1xuICAgICAgICBoYW5kbGVyPSBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICBpZighaGFuZGxlcikgcmV0dXJuO1xuICAgICAgICBvZmYuY2FsbCh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIGlmKCEtLXRoaXMuX2xpc3RlbmVyc0NvdW50KXtcbiAgICAgICAgICBjbGVhclJlZnMoKTtcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIGV2ZW50cz0gb3duS2V5cyhsaXN0ZW5lcnMpO1xuICAgICAgICBpPSBldmVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZShpLS0+MCl7XG4gICAgICAgICAgZXZlbnQ9IGV2ZW50c1tpXTtcbiAgICAgICAgICBvZmYuY2FsbCh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcnNbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saXN0ZW5lcnM9IHt9O1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNDb3VudD0gMDtcbiAgICAgICAgY2xlYXJSZWZzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIHJlZHVjZXJzLCBhbGxvd1Vua25vd24pIHtcbiAgICB2YXIgY29tcHV0ZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgc2NoZW1hKTtcblxuICAgIGlmICghb3B0aW9ucykgcmV0dXJuIGNvbXB1dGVkT3B0aW9ucztcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIG9wdGlvbiwgdmFsdWU7XG4gICAgdmFyIHJlZHVjZXI7XG5cbiAgICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBcIicgKyBvcHRpb24gKyAnXCIgb3B0aW9uIHZhbHVlJyArIChyZWFzb24gPyAnLiBSZWFzb246ICcgKyByZWFzb24gOiAnJykpXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgb3B0aW9uID0ga2V5c1tpXTtcbiAgICAgIGlmICghYWxsb3dVbmtub3duICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwgb3B0aW9uKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biBcIicgKyBvcHRpb24gKyAnXCIgb3B0aW9uJyk7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZHVjZXIgPSByZWR1Y2Vyc1tvcHRpb25dO1xuICAgICAgICBjb21wdXRlZE9wdGlvbnNbb3B0aW9uXSA9IHJlZHVjZXIgPyByZWR1Y2VyKHZhbHVlLCByZWplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wdXRlZE9wdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RvclJlZHVjZXIodmFsdWUsIHJlamVjdCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgIXZhbHVlLmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKSkge1xuICAgICAgcmVqZWN0KCd2YWx1ZSBtdXN0IGJlIGEgY29uc3RydWN0b3InKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVR5cGVSZWR1Y2VyKHR5cGVzKSB7XG4gICAgdmFyIG1lc3NhZ2U9ICd2YWx1ZSBtdXN0IGJlIHR5cGUgb2YgJyArIHR5cGVzLmpvaW4oJ3wnKTtcbiAgICB2YXIgbGVuPSB0eXBlcy5sZW5ndGg7XG4gICAgdmFyIGZpcnN0VHlwZT0gdHlwZXNbMF07XG4gICAgdmFyIHNlY29uZFR5cGU9IHR5cGVzWzFdO1xuXG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2LCByZWplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBmaXJzdFR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2LCByZWplY3QpIHtcbiAgICAgICAgdmFyIGtpbmQ9IHR5cGVvZiB2O1xuICAgICAgICBpZiAoa2luZCA9PT0gZmlyc3RUeXBlIHx8IGtpbmQgPT09IHNlY29uZFR5cGUpIHJldHVybiB2O1xuICAgICAgICByZWplY3QobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2LCByZWplY3QpIHtcbiAgICAgIHZhciBraW5kID0gdHlwZW9mIHY7XG4gICAgICB2YXIgaSA9IGxlbjtcbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIGlmIChraW5kID09PSB0eXBlc1tpXSkgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgICByZWplY3QobWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZ1bmN0aW9uUmVkdWNlcj0gbWFrZVR5cGVSZWR1Y2VyKFsnZnVuY3Rpb24nXSk7XG5cbiAgdmFyIG9iamVjdEZ1bmN0aW9uUmVkdWNlcj0gbWFrZVR5cGVSZWR1Y2VyKFsnb2JqZWN0JywgJ2Z1bmN0aW9uJ10pO1xuXG4gIGZ1bmN0aW9uIG1ha2VDYW5jZWxhYmxlUHJvbWlzZShQcm9taXNlLCBleGVjdXRvciwgb3B0aW9ucykge1xuICAgIHZhciBpc0NhbmNlbGFibGU7XG4gICAgdmFyIGNhbGxiYWNrcztcbiAgICB2YXIgdGltZXI9IDA7XG4gICAgdmFyIHN1YnNjcmlwdGlvbkNsb3NlZDtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpIHtcbiAgICAgIG9wdGlvbnM9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgdGltZW91dDogMCxcbiAgICAgICAgb3ZlcmxvYWQ6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKHZhbHVlLCByZWplY3Qpe1xuICAgICAgICAgIHZhbHVlKj0gMTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlamVjdCgndGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlzQ2FuY2VsYWJsZSA9ICFvcHRpb25zLm92ZXJsb2FkICYmIHR5cGVvZiBQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9uQ2FuY2VsID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHRpbWVyID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX3Jlc29sdmU9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfcmVqZWN0PSBmdW5jdGlvbihlcnIpe1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcblxuICAgICAgaWYgKGlzQ2FuY2VsYWJsZSkge1xuICAgICAgICBleGVjdXRvcihfcmVzb2x2ZSwgX3JlamVjdCwgb25DYW5jZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2tzID0gW2Z1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgICAgX3JlamVjdChyZWFzb24gfHwgRXJyb3IoJ2NhbmNlbGVkJykpO1xuICAgICAgICB9XTtcbiAgICAgICAgZXhlY3V0b3IoX3Jlc29sdmUsIF9yZWplY3QsIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25DbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdVbmFibGUgdG8gc3Vic2NyaWJlIG9uIGNhbmNlbCBldmVudCBhc3luY2hyb25vdXNseScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignb25DYW5jZWwgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbkNsb3NlZD0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICAgICAgdGltZXI9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgcmVhc29uPSBFcnJvcigndGltZW91dCcpO1xuICAgICAgICAgIHJlYXNvbi5jb2RlID0gJ0VUSU1FRE9VVCdcbiAgICAgICAgICB0aW1lcj0gMDtcbiAgICAgICAgICBwcm9taXNlLmNhbmNlbChyZWFzb24pO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFpc0NhbmNlbGFibGUpIHtcbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNhbGxiYWNrc1tpXShyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVybmFsIGNhbGxiYWNrIHRvIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgICAgICBjYWxsYmFja3NbMF0ocmVhc29uKTtcbiAgICAgICAgY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kVGFyZ2V0SW5kZXgob2JzZXJ2ZXIpIHtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzO1xuICAgIGlmKCFvYnNlcnZlcnMpe1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAob2JzZXJ2ZXJzW2ldLl90YXJnZXQgPT09IG9ic2VydmVyKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gQXR0ZW50aW9uLCBmdW5jdGlvbiByZXR1cm4gdHlwZSBub3cgaXMgYXJyYXksIGFsd2F5cyAhXG4gIC8vIEl0IGhhcyB6ZXJvIGVsZW1lbnRzIGlmIG5vIGFueSBtYXRjaGVzIGZvdW5kIGFuZCBvbmUgb3IgbW9yZVxuICAvLyBlbGVtZW50cyAobGVhZnMpIGlmIHRoZXJlIGFyZSBtYXRjaGVzXG4gIC8vXG4gIGZ1bmN0aW9uIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZSwgaSwgdHlwZUxlbmd0aCkge1xuICAgIGlmICghdHJlZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHZhciBraW5kID0gdHlwZW9mIHR5cGU7XG4gICAgICBpZiAoa2luZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG5zLCBuLCBsID0gMCwgaiA9IDAsIGRlbGltaXRlciA9IHRoaXMuZGVsaW1pdGVyLCBkbCA9IGRlbGltaXRlci5sZW5ndGg7XG4gICAgICAgIGlmICgobiA9IHR5cGUuaW5kZXhPZihkZWxpbWl0ZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgICBucyA9IG5ldyBBcnJheSg1KTtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBuc1tsKytdID0gdHlwZS5zbGljZShqLCBuKTtcbiAgICAgICAgICAgIGogPSBuICsgZGw7XG4gICAgICAgICAgfSB3aGlsZSAoKG4gPSB0eXBlLmluZGV4T2YoZGVsaW1pdGVyLCBqKSkgIT09IC0xKTtcblxuICAgICAgICAgIG5zW2wrK10gPSB0eXBlLnNsaWNlKGopO1xuICAgICAgICAgIHR5cGUgPSBucztcbiAgICAgICAgICB0eXBlTGVuZ3RoID0gbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gW3R5cGVdO1xuICAgICAgICAgIHR5cGVMZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHR5cGVMZW5ndGggPSB0eXBlLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICAgIHR5cGVMZW5ndGggPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnM9IG51bGwsIGJyYW5jaCwgeFRyZWUsIHh4VHJlZSwgaXNvbGF0ZWRCcmFuY2gsIGVuZFJlYWNoZWQsIGN1cnJlbnRUeXBlID0gdHlwZVtpXSxcbiAgICAgICAgbmV4dFR5cGUgPSB0eXBlW2kgKyAxXSwgYnJhbmNoZXMsIF9saXN0ZW5lcnM7XG5cbiAgICBpZiAoaSA9PT0gdHlwZUxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIElmIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50KHMpIGxpc3QgYW5kIHRoZSB0cmVlIGhhcyBsaXN0ZW5lcnNcbiAgICAgIC8vIGludm9rZSB0aG9zZSBsaXN0ZW5lcnMuXG4gICAgICAvL1xuXG4gICAgICBpZih0cmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmVlLl9saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBoYW5kbGVycyAmJiBoYW5kbGVycy5wdXNoKHRyZWUuX2xpc3RlbmVycyk7XG4gICAgICAgICAgbGlzdGVuZXJzID0gW3RyZWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzICYmIGhhbmRsZXJzLnB1c2guYXBwbHkoaGFuZGxlcnMsIHRyZWUuX2xpc3RlbmVycyk7XG4gICAgICAgICAgbGlzdGVuZXJzID0gW3RyZWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKGN1cnJlbnRUeXBlID09PSAnKicpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIGV2ZW50IGVtaXR0ZWQgaXMgJyonIGF0IHRoaXMgcGFydFxuICAgICAgICAvLyBvciB0aGVyZSBpcyBhIGNvbmNyZXRlIG1hdGNoIGF0IHRoaXMgcGF0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgYnJhbmNoZXMgPSBvd25LZXlzKHRyZWUpO1xuICAgICAgICBuID0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaGVzW25dO1xuICAgICAgICAgIGlmIChicmFuY2ggIT09ICdfbGlzdGVuZXJzJykge1xuICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpICsgMSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBfbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBfbGlzdGVuZXJzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUeXBlID09PSAnKionKSB7XG4gICAgICAgIGVuZFJlYWNoZWQgPSAoaSArIDEgPT09IHR5cGVMZW5ndGggfHwgKGkgKyAyID09PSB0eXBlTGVuZ3RoICYmIG5leHRUeXBlID09PSAnKicpKTtcbiAgICAgICAgaWYgKGVuZFJlYWNoZWQgJiYgdHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgLy8gVGhlIG5leHQgZWxlbWVudCBoYXMgYSBfbGlzdGVuZXJzLCBhZGQgaXQgdG8gdGhlIGhhbmRsZXJzLlxuICAgICAgICAgIGxpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmFuY2hlcyA9IG93bktleXModHJlZSk7XG4gICAgICAgIG4gPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgYnJhbmNoID0gYnJhbmNoZXNbbl07XG4gICAgICAgICAgaWYgKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnKSB7XG4gICAgICAgICAgICBpZiAoYnJhbmNoID09PSAnKicgfHwgYnJhbmNoID09PSAnKionKSB7XG4gICAgICAgICAgICAgIGlmICh0cmVlW2JyYW5jaF0uX2xpc3RlbmVycyAmJiAhZW5kUmVhY2hlZCkge1xuICAgICAgICAgICAgICAgIF9saXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKF9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBfbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IF9saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9saXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJyYW5jaCA9PT0gbmV4dFR5cGUpIHtcbiAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpICsgMiwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBObyBtYXRjaCBvbiB0aGlzIG9uZSwgc2hpZnQgaW50byB0aGUgdHJlZSBidXQgbm90IGluIHRoZSB0eXBlIGFycmF5LlxuICAgICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGksIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoLmFwcGx5KGxpc3RlbmVycywgX2xpc3RlbmVycyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gX2xpc3RlbmVycztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIGlmICh0cmVlW2N1cnJlbnRUeXBlXSkge1xuICAgICAgICBsaXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbY3VycmVudFR5cGVdLCBpICsgMSwgdHlwZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgICB4VHJlZSA9IHRyZWVbJyonXTtcbiAgICBpZiAoeFRyZWUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgbGlzdGVuZXIgdHJlZSB3aWxsIGFsbG93IGFueSBtYXRjaCBmb3IgdGhpcyBwYXJ0LFxuICAgICAgLy8gdGhlbiByZWN1cnNpdmVseSBleHBsb3JlIGFsbCBicmFuY2hlcyBvZiB0aGUgdHJlZVxuICAgICAgLy9cbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeFRyZWUsIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICB4eFRyZWUgPSB0cmVlWycqKiddO1xuICAgIGlmICh4eFRyZWUpIHtcbiAgICAgIGlmIChpIDwgdHlwZUxlbmd0aCkge1xuICAgICAgICBpZiAoeHhUcmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbGlzdGVuZXIgb24gYSAnKionLCBpdCB3aWxsIGNhdGNoIGFsbCwgc28gYWRkIGl0cyBoYW5kbGVyLlxuICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1aWxkIGFycmF5cyBvZiBtYXRjaGluZyBuZXh0IGJyYW5jaGVzIGFuZCBvdGhlcnMuXG4gICAgICAgIGJyYW5jaGVzPSBvd25LZXlzKHh4VHJlZSk7XG4gICAgICAgIG49IGJyYW5jaGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUobi0tPjApe1xuICAgICAgICAgIGJyYW5jaD0gYnJhbmNoZXNbbl07XG4gICAgICAgICAgaWYgKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnKSB7XG4gICAgICAgICAgICBpZiAoYnJhbmNoID09PSBuZXh0VHlwZSkge1xuICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBuZXh0IGVsZW1lbnQgd2lsbCBtYXRjaCwgc28ganVtcCB0d2ljZS5cbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbYnJhbmNoXSwgaSArIDIsIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChicmFuY2ggPT09IGN1cnJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgIC8vIEN1cnJlbnQgbm9kZSBtYXRjaGVzLCBtb3ZlIGludG8gdGhlIHRyZWUuXG4gICAgICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlW2JyYW5jaF0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzb2xhdGVkQnJhbmNoID0ge307XG4gICAgICAgICAgICAgIGlzb2xhdGVkQnJhbmNoW2JyYW5jaF0gPSB4eFRyZWVbYnJhbmNoXTtcbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB7JyoqJzogaXNvbGF0ZWRCcmFuY2h9LCBpICsgMSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHh4VHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIGFuZCBzdGlsbCBvbiBhICcqKidcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWUsIHR5cGVMZW5ndGgsIHR5cGVMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh4eFRyZWVbJyonXSAmJiB4eFRyZWVbJyonXS5fbGlzdGVuZXJzKSB7XG4gICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlWycqJ10sIHR5cGVMZW5ndGgsIHR5cGVMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gIH1cblxuICBmdW5jdGlvbiBncm93TGlzdGVuZXJUcmVlKHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gICAgdmFyIGxlbiA9IDAsIGogPSAwLCBpLCBkZWxpbWl0ZXIgPSB0aGlzLmRlbGltaXRlciwgZGw9IGRlbGltaXRlci5sZW5ndGgsIG5zO1xuXG4gICAgaWYodHlwZW9mIHR5cGU9PT0nc3RyaW5nJykge1xuICAgICAgaWYgKChpID0gdHlwZS5pbmRleE9mKGRlbGltaXRlcikpICE9PSAtMSkge1xuICAgICAgICBucyA9IG5ldyBBcnJheSg1KTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5zW2xlbisrXSA9IHR5cGUuc2xpY2UoaiwgaSk7XG4gICAgICAgICAgaiA9IGkgKyBkbDtcbiAgICAgICAgfSB3aGlsZSAoKGkgPSB0eXBlLmluZGV4T2YoZGVsaW1pdGVyLCBqKSkgIT09IC0xKTtcblxuICAgICAgICBuc1tsZW4rK10gPSB0eXBlLnNsaWNlKGopO1xuICAgICAgfWVsc2V7XG4gICAgICAgIG5zPSBbdHlwZV07XG4gICAgICAgIGxlbj0gMTtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIG5zPSB0eXBlO1xuICAgICAgbGVuPSB0eXBlLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIExvb2tzIGZvciB0d28gY29uc2VjdXRpdmUgJyoqJywgaWYgc28sIGRvbid0IGFkZCB0aGUgZXZlbnQgYXQgYWxsLlxuICAgIC8vXG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgKyAxIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG5zW2ldID09PSAnKionICYmIG5zW2kgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuXG5cbiAgICB2YXIgdHJlZSA9IHRoaXMubGlzdGVuZXJUcmVlLCBuYW1lO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBuYW1lID0gbnNbaV07XG5cbiAgICAgIHRyZWUgPSB0cmVlW25hbWVdIHx8ICh0cmVlW25hbWVdID0ge30pO1xuXG4gICAgICBpZiAoaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICBpZiAoIXRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICAgIHRyZWUuX2xpc3RlbmVycyA9IGxpc3RlbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHJlZS5fbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMgPSBbdHJlZS5fbGlzdGVuZXJzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhdHJlZS5fbGlzdGVuZXJzLndhcm5lZCAmJlxuICAgICAgICAgICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPiAwICYmXG4gICAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy5sZW5ndGggPiB0aGlzLl9tYXhMaXN0ZW5lcnNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy53YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgbG9nUG9zc2libGVNZW1vcnlMZWFrLmNhbGwodGhpcywgdHJlZS5fbGlzdGVuZXJzLmxlbmd0aCwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdFRyZWVFdmVudHModHJlZSwgZXZlbnRzLCByb290LCBhc0FycmF5KXtcbiAgICAgdmFyIGJyYW5jaGVzPSBvd25LZXlzKHRyZWUpO1xuICAgICB2YXIgaT0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICB2YXIgYnJhbmNoLCBicmFuY2hOYW1lLCBwYXRoO1xuICAgICB2YXIgaGFzTGlzdGVuZXJzPSB0cmVlWydfbGlzdGVuZXJzJ107XG4gICAgIHZhciBpc0FycmF5UGF0aDtcblxuICAgICB3aGlsZShpLS0+MCl7XG4gICAgICAgICBicmFuY2hOYW1lPSBicmFuY2hlc1tpXTtcblxuICAgICAgICAgYnJhbmNoPSB0cmVlW2JyYW5jaE5hbWVdO1xuXG4gICAgICAgICBpZihicmFuY2hOYW1lPT09J19saXN0ZW5lcnMnKXtcbiAgICAgICAgICAgICBwYXRoPSByb290O1xuICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgIHBhdGggPSByb290ID8gcm9vdC5jb25jYXQoYnJhbmNoTmFtZSkgOiBbYnJhbmNoTmFtZV07XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlzQXJyYXlQYXRoPSBhc0FycmF5IHx8IHR5cGVvZiBicmFuY2hOYW1lPT09J3N5bWJvbCc7XG5cbiAgICAgICAgIGhhc0xpc3RlbmVycyAmJiBldmVudHMucHVzaChpc0FycmF5UGF0aD8gcGF0aCA6IHBhdGguam9pbih0aGlzLmRlbGltaXRlcikpO1xuXG4gICAgICAgICBpZih0eXBlb2YgYnJhbmNoPT09J29iamVjdCcpe1xuICAgICAgICAgICAgIGNvbGxlY3RUcmVlRXZlbnRzLmNhbGwodGhpcywgYnJhbmNoLCBldmVudHMsIHBhdGgsIGlzQXJyYXlQYXRoKTtcbiAgICAgICAgIH1cbiAgICAgfVxuXG4gICAgIHJldHVybiBldmVudHM7XG4gIH1cblxuICBmdW5jdGlvbiByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHJvb3QpIHtcbiAgICB2YXIga2V5cyA9IG93bktleXMocm9vdCk7XG4gICAgdmFyIGk9IGtleXMubGVuZ3RoO1xuICAgIHZhciBvYmosIGtleSwgZmxhZztcbiAgICB3aGlsZShpLS0+MCl7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgb2JqID0gcm9vdFtrZXldO1xuXG4gICAgICBpZihvYmope1xuICAgICAgICAgIGZsYWc9IHRydWU7XG4gICAgICAgICAgaWYoa2V5ICE9PSAnX2xpc3RlbmVycycgJiYgIXJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3Qob2JqKSl7XG4gICAgICAgICAgICAgZGVsZXRlIHJvb3Rba2V5XTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsYWc7XG4gIH1cblxuICBmdW5jdGlvbiBMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIpe1xuICAgIHRoaXMuZW1pdHRlcj0gZW1pdHRlcjtcbiAgICB0aGlzLmV2ZW50PSBldmVudDtcbiAgICB0aGlzLmxpc3RlbmVyPSBsaXN0ZW5lcjtcbiAgfVxuXG4gIExpc3RlbmVyLnByb3RvdHlwZS5vZmY9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lbWl0dGVyLm9mZih0aGlzLmV2ZW50LCB0aGlzLmxpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiBzZXR1cExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgb3B0aW9ucyl7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9taXNpZnkgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBhc3luYyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdvcHRpb25zIHNob3VsZCBiZSBhbiBvYmplY3Qgb3IgdHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3luYyA9IG9wdGlvbnMuYXN5bmM7XG4gICAgICAgIHZhciBwcm9taXNpZnkgPSBvcHRpb25zLnByb21pc2lmeTtcbiAgICAgICAgdmFyIG5leHRUaWNrID0gb3B0aW9ucy5uZXh0VGljaztcbiAgICAgICAgdmFyIG9iamVjdGlmeSA9IG9wdGlvbnMub2JqZWN0aWZ5O1xuICAgICAgfVxuXG4gICAgICBpZiAoYXN5bmMgfHwgbmV4dFRpY2sgfHwgcHJvbWlzaWZ5KSB7XG4gICAgICAgIHZhciBfbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdmFyIF9vcmlnaW4gPSBsaXN0ZW5lci5fb3JpZ2luIHx8IGxpc3RlbmVyO1xuXG4gICAgICAgIGlmIChuZXh0VGljayAmJiAhbmV4dFRpY2tTdXBwb3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigncHJvY2Vzcy5uZXh0VGljayBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvbWlzaWZ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9taXNpZnkgPSBsaXN0ZW5lci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXN5bmNGdW5jdGlvbic7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5ldmVudDtcblxuICAgICAgICAgIHJldHVybiBwcm9taXNpZnkgPyAobmV4dFRpY2sgPyBQcm9taXNlLnJlc29sdmUoKSA6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBfc2V0SW1tZWRpYXRlKHJlc29sdmUpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGV4dC5ldmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9saXN0ZW5lci5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgICAgIH0pKSA6IChuZXh0VGljayA/IHByb2Nlc3MubmV4dFRpY2sgOiBfc2V0SW1tZWRpYXRlKShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBfbGlzdGVuZXIuYXBwbHkoY29udGV4dCwgYXJncylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBsaXN0ZW5lci5fYXN5bmMgPSB0cnVlO1xuICAgICAgICBsaXN0ZW5lci5fb3JpZ2luID0gX29yaWdpbjtcbiAgICAgIH1cblxuICAgIHJldHVybiBbbGlzdGVuZXIsIG9iamVjdGlmeT8gbmV3IExpc3RlbmVyKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcik6IHRoaXNdO1xuICB9XG5cbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGNvbmYpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB0aGlzLl9uZXdMaXN0ZW5lciA9IGZhbHNlO1xuICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyID0gZmFsc2U7XG4gICAgdGhpcy52ZXJib3NlTWVtb3J5TGVhayA9IGZhbHNlO1xuICAgIGNvbmZpZ3VyZS5jYWxsKHRoaXMsIGNvbmYpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBleHBvcnRpbmcgRXZlbnRFbWl0dGVyIHByb3BlcnR5XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5Ubz0gZnVuY3Rpb24odGFyZ2V0LCBldmVudHMsIG9wdGlvbnMpe1xuICAgIGlmKHR5cGVvZiB0YXJnZXQhPT0nb2JqZWN0Jyl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0cyBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG5cbiAgICB2YXIgZW1pdHRlcj0gdGhpcztcblxuICAgIG9wdGlvbnMgPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBvbjogdW5kZWZpbmVkLFxuICAgICAgb2ZmOiB1bmRlZmluZWQsXG4gICAgICByZWR1Y2VyczogdW5kZWZpbmVkXG4gICAgfSwge1xuICAgICAgb246IGZ1bmN0aW9uUmVkdWNlcixcbiAgICAgIG9mZjogZnVuY3Rpb25SZWR1Y2VyLFxuICAgICAgcmVkdWNlcnM6IG9iamVjdEZ1bmN0aW9uUmVkdWNlclxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbGlzdGVuKGV2ZW50cyl7XG4gICAgICBpZih0eXBlb2YgZXZlbnRzIT09J29iamVjdCcpe1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2V2ZW50cyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVkdWNlcnM9IG9wdGlvbnMucmVkdWNlcnM7XG4gICAgICB2YXIgaW5kZXg9IGZpbmRUYXJnZXRJbmRleC5jYWxsKGVtaXR0ZXIsIHRhcmdldCk7XG4gICAgICB2YXIgb2JzZXJ2ZXI7XG5cbiAgICAgIGlmKGluZGV4PT09LTEpe1xuICAgICAgICBvYnNlcnZlcj0gbmV3IFRhcmdldE9ic2VydmVyKGVtaXR0ZXIsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgb2JzZXJ2ZXI9IGVtaXR0ZXIuX29ic2VydmVyc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzPSBvd25LZXlzKGV2ZW50cyk7XG4gICAgICB2YXIgbGVuPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciBldmVudDtcbiAgICAgIHZhciBpc1NpbmdsZVJlZHVjZXI9IHR5cGVvZiByZWR1Y2Vycz09PSdmdW5jdGlvbic7XG5cbiAgICAgIGZvcih2YXIgaT0wOyBpPGxlbjsgaSsrKXtcbiAgICAgICAgZXZlbnQ9IGtleXNbaV07XG4gICAgICAgIG9ic2VydmVyLnN1YnNjcmliZShcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgZXZlbnRzW2V2ZW50XSB8fCBldmVudCxcbiAgICAgICAgICAgIGlzU2luZ2xlUmVkdWNlciA/IHJlZHVjZXJzIDogcmVkdWNlcnMgJiYgcmVkdWNlcnNbZXZlbnRdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNBcnJheShldmVudHMpP1xuICAgICAgICBsaXN0ZW4odG9PYmplY3QoZXZlbnRzKSkgOlxuICAgICAgICAodHlwZW9mIGV2ZW50cz09PSdzdHJpbmcnPyBsaXN0ZW4odG9PYmplY3QoZXZlbnRzLnNwbGl0KC9cXHMrLykpKTogbGlzdGVuKGV2ZW50cykpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zdG9wTGlzdGVuaW5nVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudCkge1xuICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnM7XG5cbiAgICBpZighb2JzZXJ2ZXJzKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgdmFyIG9ic2VydmVyO1xuICAgIHZhciBtYXRjaGVkPSBmYWxzZTtcblxuICAgIGlmKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0IT09J29iamVjdCcpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCd0YXJnZXQgc2hvdWxkIGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBvYnNlcnZlciA9IG9ic2VydmVyc1tpXTtcbiAgICAgIGlmICghdGFyZ2V0IHx8IG9ic2VydmVyLl90YXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICBvYnNlcnZlci51bnN1YnNjcmliZShldmVudCk7XG4gICAgICAgIG1hdGNoZWQ9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhblxuICAvLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbiAgLy8gaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4gIC8vXG4gIC8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuICAvLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmRlbGltaXRlciA9ICcuJztcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICAgICAgaWYgKCF0aGlzLl9jb25mKSB0aGlzLl9jb25mID0ge307XG4gICAgICB0aGlzLl9jb25mLm1heExpc3RlbmVycyA9IG47XG4gICAgfVxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heExpc3RlbmVycztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50ID0gJyc7XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uY2UoZXZlbnQsIGZuLCBmYWxzZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uY2UoZXZlbnQsIGZuLCB0cnVlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuLCBwcmVwZW5kLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hbnkoZXZlbnQsIDEsIGZuLCBwcmVwZW5kLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm1hbnkgPSBmdW5jdGlvbihldmVudCwgdHRsLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9tYW55KGV2ZW50LCB0dGwsIGZuLCBmYWxzZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hbnkoZXZlbnQsIHR0bCwgZm4sIHRydWUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21hbnkgPSBmdW5jdGlvbihldmVudCwgdHRsLCBmbiwgcHJlcGVuZCwgb3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFueSBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoLS10dGwgPT09IDApIHtcbiAgICAgICAgc2VsZi5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGxpc3RlbmVyLl9vcmlnaW4gPSBmbjtcblxuICAgIHJldHVybiB0aGlzLl9vbihldmVudCwgbGlzdGVuZXIsIHByZXBlbmQsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzICYmICF0aGlzLl9hbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF0sIG5zLCB3aWxkY2FyZD0gdGhpcy53aWxkY2FyZDtcbiAgICB2YXIgYXJncyxsLGksaiwgY29udGFpbnNTeW1ib2w7XG5cbiAgICBpZiAodHlwZSA9PT0gJ25ld0xpc3RlbmVyJyAmJiAhdGhpcy5fbmV3TGlzdGVuZXIpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgIG5zPSB0eXBlO1xuICAgICAgaWYodHlwZSE9PSduZXdMaXN0ZW5lcicgJiYgdHlwZSE9PSdyZW1vdmVMaXN0ZW5lcicpe1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbCA9IHR5cGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChzeW1ib2xzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVtpXSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBjb250YWluc1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb250YWluc1N5bWJvbCkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuam9pbih0aGlzLmRlbGltaXRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaGFuZGxlcjtcblxuICAgIGlmICh0aGlzLl9hbGwgJiYgdGhpcy5fYWxsLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IHRoaXMuX2FsbC5zbGljZSgpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBoYW5kbGVyW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgIGhhbmRsZXIgPSBbXTtcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXIsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCwgbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XG4gICAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgLy8gbmVlZCB0byBtYWtlIGNvcHkgb2YgaGFuZGxlcnMgYmVjYXVzZSBsaXN0IGNhbiBjaGFuZ2UgaW4gdGhlIG1pZGRsZVxuICAgICAgICAvLyBvZiBlbWl0IGNhbGxcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlciAmJiBoYW5kbGVyLmxlbmd0aCkge1xuICAgICAgaWYgKGFsID4gMykge1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaWdub3JlRXJyb3JzICYmICF0aGlzLl9hbGwgJiYgdHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gISF0aGlzLl9hbGw7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0QXN5bmMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cyAmJiAhdGhpcy5fYWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcblxuICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLCB3aWxkY2FyZD0gdGhpcy53aWxkY2FyZCwgbnMsIGNvbnRhaW5zU3ltYm9sO1xuICAgIHZhciBhcmdzLGwsaSxqO1xuXG4gICAgaWYgKHR5cGUgPT09ICduZXdMaXN0ZW5lcicgJiYgIXRoaXMuX25ld0xpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoW2ZhbHNlXSk7IH1cbiAgICB9XG5cbiAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgIG5zPSB0eXBlO1xuICAgICAgaWYodHlwZSE9PSduZXdMaXN0ZW5lcicgJiYgdHlwZSE9PSdyZW1vdmVMaXN0ZW5lcicpe1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbCA9IHR5cGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChzeW1ib2xzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVtpXSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBjb250YWluc1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb250YWluc1N5bWJvbCkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuam9pbih0aGlzLmRlbGltaXRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2VzPSBbXTtcblxuICAgIHZhciBhbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGhhbmRsZXI7XG5cbiAgICBpZiAodGhpcy5fYWxsKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5fYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uY2FsbCh0aGlzLCB0eXBlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbGRjYXJkKSB7XG4gICAgICBoYW5kbGVyID0gW107XG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVyLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5jYWxsKHRoaXMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgICBpZiAoYWwgPiAzKSB7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uY2FsbCh0aGlzKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaWdub3JlRXJyb3JzICYmICF0aGlzLl9hbGwgJiYgdHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhcmd1bWVudHNbMV0pOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGxpc3RlbmVyLCBmYWxzZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9vbih0eXBlLCBsaXN0ZW5lciwgdHJ1ZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbkFueSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uQW55KGZuLCBmYWxzZSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kQW55ID0gZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb25BbnkoZm4sIHRydWUpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX29uQW55ID0gZnVuY3Rpb24oZm4sIHByZXBlbmQpe1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25Bbnkgb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fYWxsKSB7XG4gICAgICB0aGlzLl9hbGwgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZ1bmN0aW9uIHRvIHRoZSBldmVudCBsaXN0ZW5lciBjb2xsZWN0aW9uLlxuICAgIGlmKHByZXBlbmQpe1xuICAgICAgdGhpcy5fYWxsLnVuc2hpZnQoZm4pO1xuICAgIH1lbHNle1xuICAgICAgdGhpcy5fYWxsLnB1c2goZm4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX29uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHByZXBlbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX29uQW55KHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb24gb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHJldHVyblZhbHVlPSB0aGlzLCB0ZW1wO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGVtcCA9IHNldHVwTGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICBsaXN0ZW5lciA9IHRlbXBbMF07XG4gICAgICByZXR1cm5WYWx1ZSA9IHRlbXBbMV07XG4gICAgfVxuXG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICAgIGlmICh0aGlzLl9uZXdMaXN0ZW5lcikge1xuICAgICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgZ3Jvd0xpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKTtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9ldmVudHNbdHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQ2hhbmdlIHRvIGFycmF5LlxuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYWRkXG4gICAgICBpZihwcmVwZW5kKXtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICAgIGlmIChcbiAgICAgICAgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgJiZcbiAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzID4gMCAmJlxuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gdGhpcy5fbWF4TGlzdGVuZXJzXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICAgIGxvZ1Bvc3NpYmxlTWVtb3J5TGVhay5jYWxsKHRoaXMsIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyxsZWFmcz1bXTtcblxuICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgbGVhZnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBudWxsLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuICAgICAgaWYoIWxlYWZzKSByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gICAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XG4gICAgICBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgIGxlYWZzLnB1c2goe19saXN0ZW5lcnM6aGFuZGxlcnN9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpTGVhZj0wOyBpTGVhZjxsZWFmcy5sZW5ndGg7IGlMZWFmKyspIHtcbiAgICAgIHZhciBsZWFmID0gbGVhZnNbaUxlYWZdO1xuICAgICAgaGFuZGxlcnMgPSBsZWFmLl9saXN0ZW5lcnM7XG4gICAgICBpZiAoaXNBcnJheShoYW5kbGVycykpIHtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcnNbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgICAoaGFuZGxlcnNbaV0ubGlzdGVuZXIgJiYgaGFuZGxlcnNbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB8fFxuICAgICAgICAgICAgKGhhbmRsZXJzW2ldLl9vcmlnaW4gJiYgaGFuZGxlcnNbaV0uX29yaWdpbiA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgICAgbGVhZi5fbGlzdGVuZXJzLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgICAgICAgZGVsZXRlIGxlYWYuX2xpc3RlbmVycztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgdHlwZSwgbGlzdGVuZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaGFuZGxlcnMgPT09IGxpc3RlbmVyIHx8XG4gICAgICAgIChoYW5kbGVycy5saXN0ZW5lciAmJiBoYW5kbGVycy5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHx8XG4gICAgICAgIChoYW5kbGVycy5fb3JpZ2luICYmIGhhbmRsZXJzLl9vcmlnaW4gPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgICAgZGVsZXRlIGxlYWYuX2xpc3RlbmVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lclRyZWUgJiYgcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdCh0aGlzLmxpc3RlbmVyVHJlZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZkFueSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIGkgPSAwLCBsID0gMCwgZm5zO1xuICAgIGlmIChmbiAmJiB0aGlzLl9hbGwgJiYgdGhpcy5fYWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIGZucyA9IHRoaXMuX2FsbDtcbiAgICAgIGZvcihpID0gMCwgbCA9IGZucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYoZm4gPT09IGZuc1tpXSkge1xuICAgICAgICAgIGZucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJBbnlcIiwgZm4pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZucyA9IHRoaXMuX2FsbDtcbiAgICAgIGlmICh0aGlzLl9yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBmb3IoaSA9IDAsIGwgPSBmbnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyQW55XCIsIGZuc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbGwgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAhdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICB2YXIgbGVhZnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBudWxsLCB0eXBlLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCksIGxlYWYsIGk7XG4gICAgICBpZiAoIWxlYWZzKSByZXR1cm4gdGhpcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZWFmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZWFmID0gbGVhZnNbaV07XG4gICAgICAgIGxlYWYuX2xpc3RlbmVycyA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmxpc3RlbmVyVHJlZSAmJiByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHRoaXMubGlzdGVuZXJUcmVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBfZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIHZhciBrZXlzLCBsaXN0ZW5lcnMsIGFsbExpc3RlbmVycztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGlzdGVuZXJUcmVlO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2V2ZW50IG5hbWUgcmVxdWlyZWQgZm9yIHdpbGRjYXJkIGVtaXR0ZXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAga2V5cyA9IG93bktleXMoX2V2ZW50cyk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICBhbGxMaXN0ZW5lcnMgPSBbXTtcbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IF9ldmVudHNba2V5c1tpXV07XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYWxsTGlzdGVuZXJzLnB1c2gobGlzdGVuZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGxMaXN0ZW5lcnMucHVzaC5hcHBseShhbGxMaXN0ZW5lcnMsIGxpc3RlbmVycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgIGxpc3RlbmVyVHJlZT0gdGhpcy5saXN0ZW5lclRyZWU7XG4gICAgICAgIGlmKCFsaXN0ZW5lclRyZWUpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVycywgbnMsIGxpc3RlbmVyVHJlZSwgMCk7XG4gICAgICAgIHJldHVybiBoYW5kbGVycztcbiAgICAgIH1cblxuICAgICAgaWYgKCFfZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gX2V2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgPyBbbGlzdGVuZXJzXSA6IGxpc3RlbmVycztcbiAgICB9XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24obnNBc0FycmF5KXtcbiAgICB2YXIgX2V2ZW50cz0gdGhpcy5fZXZlbnRzO1xuICAgIHJldHVybiB0aGlzLndpbGRjYXJkPyBjb2xsZWN0VHJlZUV2ZW50cy5jYWxsKHRoaXMsIHRoaXMubGlzdGVuZXJUcmVlLCBbXSwgbnVsbCwgbnNBc0FycmF5KSA6IChfZXZlbnRzPyBvd25LZXlzKF9ldmVudHMpIDogW10pO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXJzLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuICAgICAgcmV0dXJuIGhhbmRsZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgdmFyIF9ldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgdmFyIF9hbGwgPSB0aGlzLl9hbGw7XG5cbiAgICByZXR1cm4gISEoX2FsbCAmJiBfYWxsLmxlbmd0aCB8fCBfZXZlbnRzICYmICh0eXBlID09PSB1bmRlZmluZWQgPyBvd25LZXlzKF9ldmVudHMpLmxlbmd0aCA6IF9ldmVudHNbdHlwZV0pKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyc0FueSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYodGhpcy5fYWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiAoZXZlbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb3B0aW9ucztcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIG9wdGlvbnMgPSB7dGltZW91dDogb3B0aW9uc307XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zID0ge2ZpbHRlcjogb3B0aW9uc307XG4gICAgfVxuXG4gICAgb3B0aW9ucz0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgdGltZW91dDogMCxcbiAgICAgIGZpbHRlcjogdW5kZWZpbmVkLFxuICAgICAgaGFuZGxlRXJyb3I6IGZhbHNlLFxuICAgICAgUHJvbWlzZTogUHJvbWlzZSxcbiAgICAgIG92ZXJsb2FkOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIGZpbHRlcjogZnVuY3Rpb25SZWR1Y2VyLFxuICAgICAgUHJvbWlzZTogY29uc3RydWN0b3JSZWR1Y2VyXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWFrZUNhbmNlbGFibGVQcm9taXNlKG9wdGlvbnMuUHJvbWlzZSwgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpIHtcbiAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgICB2YXIgZmlsdGVyPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlRXJyb3IpIHtcbiAgICAgICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSh0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuc2xpY2UoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUodG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbkNhbmNlbChmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuX29uKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0sIHtcbiAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCxcbiAgICAgIG92ZXJsb2FkOiBvcHRpb25zLm92ZXJsb2FkXG4gICAgfSlcbiAgfTtcblxuICBmdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBQcm9taXNlOiBQcm9taXNlLFxuICAgICAgdGltZW91dDogMCxcbiAgICAgIG92ZXJsb2FkOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIFByb21pc2U6IGNvbnN0cnVjdG9yUmVkdWNlclxuICAgIH0pO1xuXG4gICAgdmFyIF9Qcm9taXNlPSBvcHRpb25zLlByb21pc2U7XG5cbiAgICByZXR1cm4gbWFrZUNhbmNlbGFibGVQcm9taXNlKF9Qcm9taXNlLCBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKXtcbiAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlcj0gIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlKHRvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb25DYW5jZWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAge29uY2U6IHRydWV9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICBlcnJvckxpc3RlbmVyICYmIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIHJlc29sdmUodG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBlcnJvckxpc3RlbmVyO1xuXG4gICAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgICBlcnJvckxpc3RlbmVyID0gZnVuY3Rpb24gKGVycil7XG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBlbWl0dGVyLm9uY2UoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIG9uQ2FuY2VsKGZ1bmN0aW9uKCl7XG4gICAgICAgIGVycm9yTGlzdGVuZXIgJiYgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICAgIH0pO1xuXG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSwge1xuICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgb3ZlcmxvYWQ6IG9wdGlvbnMub3ZlcmxvYWRcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGU9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnRFbWl0dGVyLCB7XG4gICAgZGVmYXVsdE1heExpc3RlbmVyczoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm90b3R5cGUuX21heExpc3RlbmVycztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVyLmlzTmFOKG4pKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcbiAgICAgICAgfVxuICAgICAgICBwcm90b3R5cGUuX21heExpc3RlbmVycyA9IG47XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgb25jZToge1xuICAgICAgdmFsdWU6IG9uY2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvdG90eXBlLCB7XG4gICAgICBfbWF4TGlzdGVuZXJzOiB7XG4gICAgICAgICAgdmFsdWU6IGRlZmF1bHRNYXhMaXN0ZW5lcnMsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgX29ic2VydmVyczoge3ZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfVxuICB9KTtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2xvYmFsIGZvciBhbnkga2luZCBvZiBlbnZpcm9ubWVudC5cbiAgICB2YXIgX2dsb2JhbD0gbmV3IEZ1bmN0aW9uKCcnLCdyZXR1cm4gdGhpcycpKCk7XG4gICAgX2dsb2JhbC5FdmVudEVtaXR0ZXIyID0gRXZlbnRFbWl0dGVyO1xuICB9XG59KCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHplcm9GaWxsID0gcmVxdWlyZSgnemVyby1maWxsJylcbnZhciBwYXJzZUludFN0cmljdCA9IHJlcXVpcmUoJ3BhcnNlLWludCcpXG5cbnZhciBwYWQgPSB6ZXJvRmlsbCgyKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cGFuZFllYXIgKHllYXIsIG5vdykge1xuICBub3cgPSBub3cgfHwgbmV3IERhdGUoKVxuICB2YXIgYmFzZSA9IG5vdy5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyKDAsIDIpXG4gIHllYXIgPSBwYXJzZUludFN0cmljdCh5ZWFyKVxuICByZXR1cm4gcGFyc2VJbnRTdHJpY3QoYmFzZSArIHBhZCh5ZWFyKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBsb29rdXAgPSBbMCwgMiwgNCwgNiwgOCwgMSwgMywgNSwgNywgOV1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsdWhuIChudW1iZXIpIHtcbiAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBzdHJpbmcgaW5wdXQnKVxuICBpZiAoIW51bWJlcikgcmV0dXJuIGZhbHNlXG5cbiAgbGV0IGluZGV4ID0gbnVtYmVyLmxlbmd0aFxuICBsZXQgeDIgPSB0cnVlXG4gIGxldCBzdW0gPSAwXG5cbiAgd2hpbGUgKGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBudW1iZXIuY2hhckNvZGVBdCgtLWluZGV4KSAtIDQ4XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDkpIHJldHVybiBmYWxzZVxuXG4gICAgeDIgPSAheDJcbiAgICBzdW0gKz0geDIgPyBsb29rdXBbdmFsdWVdIDogdmFsdWVcbiAgfVxuXG4gIHJldHVybiBzdW0gJSAxMCA9PT0gMFxufVxuIiwidmFyIHNlbGVjdG9ycyA9IFtcbiAgJ2lmcmFtZVtzcmMqPVwicGxheWVyLnZpbWVvLmNvbVwiXScsXG4gICdpZnJhbWVbc3JjKj1cInlvdXR1YmUuY29tXCJdJyxcbiAgJ2lmcmFtZVtzcmMqPVwieW91dHViZS1ub2Nvb2tpZS5jb21cIl0nLFxuICAnaWZyYW1lW3NyYyo9XCJraWNrc3RhcnRlci5jb21cIl1bc3JjKj1cInZpZGVvLmh0bWxcIl0nLFxuICBcIm9iamVjdFwiXG5dO1xuXG52YXIgY3NzID1cbiAgXCIuZmx1aWQtd2lkdGgtdmlkZW8td3JhcHBlcnt3aWR0aDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6MDt9LmZsdWlkLXdpZHRoLXZpZGVvLXdyYXBwZXIgaWZyYW1lLC5mbHVpZC13aWR0aC12aWRlby13cmFwcGVyIG9iamVjdCwuZmx1aWQtd2lkdGgtdmlkZW8td3JhcHBlciBlbWJlZCB7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7fVwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhcmVudFNlbGVjdG9yLCBvcHRzKSB7XG4gIHBhcmVudFNlbGVjdG9yID0gcGFyZW50U2VsZWN0b3IgfHwgXCJib2R5XCI7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmIChpc09iamVjdChwYXJlbnRTZWxlY3RvcikpIHtcbiAgICBvcHRzID0gcGFyZW50U2VsZWN0b3I7XG4gICAgcGFyZW50U2VsZWN0b3IgPSBcImJvZHlcIjtcbiAgfVxuXG4gIG9wdHMuaWdub3JlID0gb3B0cy5pZ25vcmUgfHwgXCJcIjtcbiAgb3B0cy5wbGF5ZXJzID0gb3B0cy5wbGF5ZXJzIHx8IFwiXCI7XG5cbiAgdmFyIGNvbnRhaW5lcnMgPSBxdWVyeUFsbChwYXJlbnRTZWxlY3Rvcik7XG4gIGlmICghaGFzTGVuZ3RoKGNvbnRhaW5lcnMpKSByZXR1cm47XG5cbiAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpdC12aWRzLXN0eWxlXCIpKSB7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlcygpKTtcbiAgfVxuXG4gIHZhciBjdXN0b20gPSB0b1NlbGVjdG9yQXJyYXkob3B0cy5wbGF5ZXJzKTtcbiAgdmFyIGlnbm9yZWQgPSB0b1NlbGVjdG9yQXJyYXkob3B0cy5pZ25vcmUpO1xuICB2YXIgaWdub3JlZFNlbGVjdG9yID0gaWdub3JlZC5sZW5ndGggPiAwID8gaWdub3JlZC5qb2luKCkgOiBudWxsO1xuICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnMuY29uY2F0KGN1c3RvbSkuam9pbigpO1xuXG4gIGlmICghaGFzTGVuZ3RoKHNlbGVjdG9yKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICB2YXIgdmlkZW9zID0gcXVlcnlBbGwoY29udGFpbmVyLCBzZWxlY3Rvcik7XG5cbiAgICB2aWRlb3MuZm9yRWFjaChmdW5jdGlvbih2aWRlbykge1xuICAgICAgaWYgKGlnbm9yZWRTZWxlY3RvciAmJiB2aWRlby5tYXRjaGVzKGlnbm9yZWRTZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd3JhcCh2aWRlbyk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBxdWVyeUFsbChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHNlbGVjdG9yID0gZWw7XG4gICAgZWwgPSBkb2N1bWVudDtcbiAgfVxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuXG5mdW5jdGlvbiB0b1NlbGVjdG9yQXJyYXkoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBpbnB1dFxuICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgLm1hcCh0cmltKVxuICAgICAgLmZpbHRlcihoYXNMZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oaW5wdXQubWFwKHRvU2VsZWN0b3JBcnJheSkuZmlsdGVyKGhhc0xlbmd0aCkpO1xuICB9XG4gIHJldHVybiBpbnB1dCB8fCBbXTtcbn1cblxuZnVuY3Rpb24gd3JhcChlbCkge1xuICBpZiAoL2ZsdWlkLXdpZHRoLXZpZGVvLXdyYXBwZXIvLnRlc3QoZWwucGFyZW50Tm9kZS5jbGFzc05hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHdpZHRoQXR0ciA9IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpLCAxMCk7XG4gIHZhciBoZWlnaHRBdHRyID0gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpLCAxMCk7XG5cbiAgdmFyIHdpZHRoID0gIWlzTmFOKHdpZHRoQXR0cikgPyB3aWR0aEF0dHIgOiBlbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9ICFpc05hTihoZWlnaHRBdHRyKSA/IGhlaWdodEF0dHIgOiBlbC5jbGllbnRIZWlnaHQ7XG4gIHZhciBhc3BlY3QgPSBoZWlnaHQgLyB3aWR0aDtcblxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJ3aWR0aFwiKTtcbiAgZWwucmVtb3ZlQXR0cmlidXRlKFwiaGVpZ2h0XCIpO1xuXG4gIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlciwgZWwpO1xuICB3cmFwcGVyLmNsYXNzTmFtZSA9IFwiZmx1aWQtd2lkdGgtdmlkZW8td3JhcHBlclwiO1xuICB3cmFwcGVyLnN0eWxlLnBhZGRpbmdUb3AgPSBhc3BlY3QgKiAxMDAgKyBcIiVcIjtcbiAgd3JhcHBlci5hcHBlbmRDaGlsZChlbCk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGRpdi5pbm5lckhUTUwgPSAnPHA+eDwvcD48c3R5bGUgaWQ9XCJmaXQtdmlkcy1zdHlsZVwiPicgKyBjc3MgKyBcIjwvc3R5bGU+XCI7XG4gIHJldHVybiBkaXYuY2hpbGROb2Rlc1sxXTtcbn1cblxuZnVuY3Rpb24gaGFzTGVuZ3RoKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuKGlucHV0KSB7XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGlucHV0KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxudmFyIGNvbmNhdHR5ID0gZnVuY3Rpb24gY29uY2F0dHkoYSwgYikge1xuICAgIHZhciBhcnIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJbaV0gPSBhW2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgYXJyW2ogKyBhLmxlbmd0aF0gPSBiW2pdO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgc2xpY3kgPSBmdW5jdGlvbiBzbGljeShhcnJMaWtlLCBvZmZzZXQpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldCB8fCAwLCBqID0gMDsgaSA8IGFyckxpa2UubGVuZ3RoOyBpICs9IDEsIGogKz0gMSkge1xuICAgICAgICBhcnJbal0gPSBhcnJMaWtlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIGpvaW55ID0gZnVuY3Rpb24gKGFyciwgam9pbmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBhcnJbaV07XG4gICAgICAgIGlmIChpICsgMSA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0ciArPSBqb2luZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuYXBwbHkodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljeShhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBjb25jYXR0eShhcmdzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICBjb25jYXR0eShhcmdzLCBhcmd1bWVudHMpXG4gICAgICAgICk7XG5cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gbWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3NbaV0gPSAnJCcgKyBpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBqb2lueShib3VuZEFyZ3MsICcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzJyk7XG52YXIgJEV2YWxFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9ldmFsJyk7XG52YXIgJFJhbmdlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvcmFuZ2UnKTtcbnZhciAkUmVmZXJlbmNlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvcmVmJyk7XG52YXIgJFN5bnRheEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3N5bnRheCcpO1xudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRVUklFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy91cmknKTtcblxudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGhhc1Byb3RvID0gcmVxdWlyZSgnaGFzLXByb3RvJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IChcblx0aGFzUHJvdG9cblx0XHQ/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cdFx0OiBudWxsXG4pO1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJpZ0ludDY0QXJyYXklJzogdHlwZW9mIEJpZ0ludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50NjRBcnJheSxcblx0JyVCaWdVaW50NjRBcnJheSUnOiB0eXBlb2YgQmlnVWludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnVWludDY0QXJyYXksXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiAkRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogJEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiAkUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiAkUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6ICRVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxuaWYgKGdldFByb3RvKSB7XG5cdHRyeSB7XG5cdFx0bnVsbC5lcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNoYWRvd3JlYWxtL3B1bGwvMzg0I2lzc3VlY29tbWVudC0xMzY0MjY0MjI5XG5cdFx0dmFyIGVycm9yUHJvdG8gPSBnZXRQcm90byhnZXRQcm90byhlKSk7XG5cdFx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG5cdH1cbn1cblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbiAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzb3duJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xudmFyICRleGVjID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC8sIG5hbWUpID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZScpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuXG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnZXMtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0cmV0dXJuICEhJGRlZmluZVByb3BlcnR5O1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCEkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRlc3QgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Zm9vOiB7fVxufTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1Byb3RvKCkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yOiBUUyBlcnJvcnMgb24gYW4gaW5oZXJpdGVkIHByb3BlcnR5IGZvciBzb21lIHJlYXNvblxuXHRyZXR1cm4geyBfX3Byb3RvX186IHRlc3QgfS5mb28gPT09IHRlc3QuZm9vXG5cdFx0JiYgISh0ZXN0IGluc3RhbmNlb2YgJE9iamVjdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG52YXIgJGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKGNhbGwsICRoYXNPd24pO1xuIiwiLypcbiAgICBqc29uMi5qc1xuICAgIDIwMTItMTAtMDhcblxuICAgIFB1YmxpYyBEb21haW4uXG5cbiAgICBOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC4gVVNFIEFUIFlPVVIgT1dOIFJJU0suXG5cbiAgICBTZWUgaHR0cDovL3d3dy5KU09OLm9yZy9qcy5odG1sXG5cblxuICAgIFRoaXMgY29kZSBzaG91bGQgYmUgbWluaWZpZWQgYmVmb3JlIGRlcGxveW1lbnQuXG4gICAgU2VlIGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vanNtaW4uaHRtbFxuXG4gICAgVVNFIFlPVVIgT1dOIENPUFkuIElUIElTIEVYVFJFTUVMWSBVTldJU0UgVE8gTE9BRCBDT0RFIEZST00gU0VSVkVSUyBZT1UgRE9cbiAgICBOT1QgQ09OVFJPTC5cblxuXG4gICAgVGhpcyBmaWxlIGNyZWF0ZXMgYSBnbG9iYWwgSlNPTiBvYmplY3QgY29udGFpbmluZyB0d28gbWV0aG9kczogc3RyaW5naWZ5XG4gICAgYW5kIHBhcnNlLlxuXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG4gICAgICAgICAgICB2YWx1ZSAgICAgICBhbnkgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXkuXG5cbiAgICAgICAgICAgIHJlcGxhY2VyICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGRldGVybWluZXMgaG93IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIGFyZSBzdHJpbmdpZmllZCBmb3Igb2JqZWN0cy4gSXQgY2FuIGJlIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG5cbiAgICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzICdcXHQnIG9yICcmbmJzcDsnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0IGNvbnRhaW5zIHRoZSBjaGFyYWN0ZXJzIHVzZWQgdG8gaW5kZW50IGF0IGVhY2ggbGV2ZWwuXG5cbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIHByb2R1Y2VzIGEgSlNPTiB0ZXh0IGZyb20gYSBKYXZhU2NyaXB0IHZhbHVlLlxuXG4gICAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuICAgICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4gICAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbiAgICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuICAgICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4gICAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWVcblxuICAgICAgICAgICAgRm9yIGV4YW1wbGUsIHRoaXMgd291bGQgc2VyaWFsaXplIERhdGVzIGFzIElTTyBzdHJpbmdzLlxuXG4gICAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENGdWxsWWVhcigpICAgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyAnVCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyAnWic7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsIHJlcGxhY2VyIG1ldGhvZC4gSXQgd2lsbCBiZSBwYXNzZWQgdGhlXG4gICAgICAgICAgICBrZXkgYW5kIHZhbHVlIG9mIGVhY2ggbWVtYmVyLCB3aXRoIHRoaXMgYm91bmQgdG8gdGhlIGNvbnRhaW5pbmdcbiAgICAgICAgICAgIG9iamVjdC4gVGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB5b3VyIG1ldGhvZCB3aWxsIGJlXG4gICAgICAgICAgICBzZXJpYWxpemVkLiBJZiB5b3VyIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiB0aGUgbWVtYmVyIHdpbGxcbiAgICAgICAgICAgIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHNlcmlhbGl6YXRpb24uXG5cbiAgICAgICAgICAgIElmIHRoZSByZXBsYWNlciBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgdGhlbiBpdCB3aWxsIGJlXG4gICAgICAgICAgICB1c2VkIHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzZXJpYWxpemVkLiBJdCBmaWx0ZXJzIHRoZSByZXN1bHRzXG4gICAgICAgICAgICBzdWNoIHRoYXQgb25seSBtZW1iZXJzIHdpdGgga2V5cyBsaXN0ZWQgaW4gdGhlIHJlcGxhY2VyIGFycmF5IGFyZVxuICAgICAgICAgICAgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIFZhbHVlcyB0aGF0IGRvIG5vdCBoYXZlIEpTT04gcmVwcmVzZW50YXRpb25zLCBzdWNoIGFzIHVuZGVmaW5lZCBvclxuICAgICAgICAgICAgZnVuY3Rpb25zLCB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLiBTdWNoIHZhbHVlcyBpbiBvYmplY3RzIHdpbGwgYmVcbiAgICAgICAgICAgIGRyb3BwZWQ7IGluIGFycmF5cyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBudWxsLiBZb3UgY2FuIHVzZVxuICAgICAgICAgICAgYSByZXBsYWNlciBmdW5jdGlvbiB0byByZXBsYWNlIHRob3NlIHdpdGggSlNPTiB2YWx1ZXMuXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4gICAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuICAgICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbiAgICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbiAgICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4gICAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoWydlJywge3BsdXJpYnVzOiAndW51bSd9XSk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJlXCIse1wicGx1cmlidXNcIjpcInVudW1cIn1dJ1xuXG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbJ2UnLCB7cGx1cmlidXM6ICd1bnVtJ31dLCBudWxsLCAnXFx0Jyk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXFxuXFx0XCJlXCIsXFxuXFx0e1xcblxcdFxcdFwicGx1cmlidXNcIjogXCJ1bnVtXCJcXG5cXHR9XFxuXSdcblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtuZXcgRGF0ZSgpXSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldIGluc3RhbmNlb2YgRGF0ZSA/XG4gICAgICAgICAgICAgICAgICAgICdEYXRlKCcgKyB0aGlzW2tleV0gKyAnKScgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG5cbiAgICAgICAgSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKVxuICAgICAgICAgICAgVGhpcyBtZXRob2QgcGFyc2VzIGEgSlNPTiB0ZXh0IHRvIHByb2R1Y2UgYW4gb2JqZWN0IG9yIGFycmF5LlxuICAgICAgICAgICAgSXQgY2FuIHRocm93IGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uLlxuXG4gICAgICAgICAgICBUaGUgb3B0aW9uYWwgcmV2aXZlciBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBmaWx0ZXIgYW5kXG4gICAgICAgICAgICB0cmFuc2Zvcm0gdGhlIHJlc3VsdHMuIEl0IHJlY2VpdmVzIGVhY2ggb2YgdGhlIGtleXMgYW5kIHZhbHVlcyxcbiAgICAgICAgICAgIGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICAgICAgICBJZiBpdCByZXR1cm5zIHdoYXQgaXQgcmVjZWl2ZWQsIHRoZW4gdGhlIHN0cnVjdHVyZSBpcyBub3QgbW9kaWZpZWQuXG4gICAgICAgICAgICBJZiBpdCByZXR1cm5zIHVuZGVmaW5lZCB0aGVuIHRoZSBtZW1iZXIgaXMgZGVsZXRlZC5cblxuICAgICAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIHRleHQuIFZhbHVlcyB0aGF0IGxvb2sgbGlrZSBJU08gZGF0ZSBzdHJpbmdzIHdpbGxcbiAgICAgICAgICAgIC8vIGJlIGNvbnZlcnRlZCB0byBEYXRlIG9iamVjdHMuXG5cbiAgICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UodGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhID1cbi9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSg/OlxcLlxcZCopPylaJC8uZXhlYyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK2FbMV0sICthWzJdIC0gMSwgK2FbM10sICthWzRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICthWzVdLCArYVs2XSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKCdbXCJEYXRlKDA5LzA5LzIwMDEpXCJdJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoMCwgNSkgPT09ICdEYXRlKCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBuZXcgRGF0ZSh2YWx1ZS5zbGljZSg1LCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG4gICAgcmVkaXN0cmlidXRlLlxuKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSwgcmVnZXhwOiB0cnVlICovXG5cbi8qbWVtYmVycyBcIlwiLCBcIlxcYlwiLCBcIlxcdFwiLCBcIlxcblwiLCBcIlxcZlwiLCBcIlxcclwiLCBcIlxcXCJcIiwgSlNPTiwgXCJcXFxcXCIsIGFwcGx5LFxuICAgIGNhbGwsIGNoYXJDb2RlQXQsIGdldFVUQ0RhdGUsIGdldFVUQ0Z1bGxZZWFyLCBnZXRVVENIb3VycyxcbiAgICBnZXRVVENNaW51dGVzLCBnZXRVVENNb250aCwgZ2V0VVRDU2Vjb25kcywgaGFzT3duUHJvcGVydHksIGpvaW4sXG4gICAgbGFzdEluZGV4LCBsZW5ndGgsIHBhcnNlLCBwcm90b3R5cGUsIHB1c2gsIHJlcGxhY2UsIHNsaWNlLCBzdHJpbmdpZnksXG4gICAgdGVzdCwgdG9KU09OLCB0b1N0cmluZywgdmFsdWVPZlxuKi9cblxuXG4vLyBDcmVhdGUgYSBKU09OIG9iamVjdCBvbmx5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LiBXZSBjcmVhdGUgdGhlXG4vLyBtZXRob2RzIGluIGEgY2xvc3VyZSB0byBhdm9pZCBjcmVhdGluZyBnbG9iYWwgdmFyaWFibGVzLlxuXG5pZiAodHlwZW9mIEpTT04gIT09ICdvYmplY3QnKSB7XG4gICAgSlNPTiA9IHt9O1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIGYobikge1xuICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSlcbiAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICAgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArICdUJyArXG4gICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSAgICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArICdaJ1xuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBTdHJpbmcucHJvdG90eXBlLnRvSlNPTiAgICAgID1cbiAgICAgICAgICAgIE51bWJlci5wcm90b3R5cGUudG9KU09OICA9XG4gICAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgZ2FwLFxuICAgICAgICBpbmRlbnQsXG4gICAgICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgIH0sXG4gICAgICAgIHJlcDtcblxuXG4gICAgZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG5cbi8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbi8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4vLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbi8vIHNlcXVlbmNlcy5cblxuICAgICAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgPyAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gY1xuICAgICAgICAgICAgICAgIDogJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG5cbi8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cblxuICAgICAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgICAgICBwYXJ0aWFsLFxuICAgICAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICB9XG5cbi8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4vLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcblxuLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbi8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4vLyBJZiB0aGUgdHlwZSBpcyAnb2JqZWN0Jywgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuLy8gbnVsbC5cblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4vLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblxuLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbi8vIGJyYWNrZXRzLlxuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICAgID8gJ1tdJ1xuICAgICAgICAgICAgICAgICAgICA6IGdhcFxuICAgICAgICAgICAgICAgICAgICA/ICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nXG4gICAgICAgICAgICAgICAgICAgIDogJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgID8gJ3t9J1xuICAgICAgICAgICAgICAgIDogZ2FwXG4gICAgICAgICAgICAgICAgPyAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICd9J1xuICAgICAgICAgICAgICAgIDogJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHN0cmluZ2lmeSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gICAgaWYgKHR5cGVvZiBKU09OLnN0cmluZ2lmeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBKU09OLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG5cbi8vIFRoZSBzdHJpbmdpZnkgbWV0aG9kIHRha2VzIGEgdmFsdWUgYW5kIGFuIG9wdGlvbmFsIHJlcGxhY2VyLCBhbmQgYW4gb3B0aW9uYWxcbi8vIHNwYWNlIHBhcmFtZXRlciwgYW5kIHJldHVybnMgYSBKU09OIHRleHQuIFRoZSByZXBsYWNlciBjYW4gYmUgYSBmdW5jdGlvblxuLy8gdGhhdCBjYW4gcmVwbGFjZSB2YWx1ZXMsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCB3aWxsIHNlbGVjdCB0aGUga2V5cy5cbi8vIEEgZGVmYXVsdCByZXBsYWNlciBtZXRob2QgY2FuIGJlIHByb3ZpZGVkLiBVc2Ugb2YgdGhlIHNwYWNlIHBhcmFtZXRlciBjYW5cbi8vIHByb2R1Y2UgdGV4dCB0aGF0IGlzIG1vcmUgZWFzaWx5IHJlYWRhYmxlLlxuXG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGdhcCA9ICcnO1xuICAgICAgICAgICAgaW5kZW50ID0gJyc7XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbi8vIG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4vLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICAgICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeScpO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cblxuICAgICAgICAgICAgcmV0dXJuIHN0cignJywgeycnOiB2YWx1ZX0pO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4vLyBJZiB0aGUgSlNPTiBvYmplY3QgZG9lcyBub3QgeWV0IGhhdmUgYSBwYXJzZSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gICAgaWYgKHR5cGVvZiBKU09OLnBhcnNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEpTT04ucGFyc2UgPSBmdW5jdGlvbiAodGV4dCwgcmV2aXZlcikge1xuXG4vLyBUaGUgcGFyc2UgbWV0aG9kIHRha2VzIGEgdGV4dCBhbmQgYW4gb3B0aW9uYWwgcmV2aXZlciBmdW5jdGlvbiwgYW5kIHJldHVybnNcbi8vIGEgSmF2YVNjcmlwdCB2YWx1ZSBpZiB0aGUgdGV4dCBpcyBhIHZhbGlkIEpTT04gdGV4dC5cblxuICAgICAgICAgICAgdmFyIGo7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcblxuLy8gVGhlIHdhbGsgbWV0aG9kIGlzIHVzZWQgdG8gcmVjdXJzaXZlbHkgd2FsayB0aGUgcmVzdWx0aW5nIHN0cnVjdHVyZSBzb1xuLy8gdGhhdCBtb2RpZmljYXRpb25zIGNhbiBiZSBtYWRlLlxuXG4gICAgICAgICAgICAgICAgdmFyIGssIHYsIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuXG4vLyBQYXJzaW5nIGhhcHBlbnMgaW4gZm91ciBzdGFnZXMuIEluIHRoZSBmaXJzdCBzdGFnZSwgd2UgcmVwbGFjZSBjZXJ0YWluXG4vLyBVbmljb2RlIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLiBKYXZhU2NyaXB0IGhhbmRsZXMgbWFueSBjaGFyYWN0ZXJzXG4vLyBpbmNvcnJlY3RseSwgZWl0aGVyIHNpbGVudGx5IGRlbGV0aW5nIHRoZW0sIG9yIHRyZWF0aW5nIHRoZW0gYXMgbGluZSBlbmRpbmdzLlxuXG4gICAgICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgY3gubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChjeC50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShjeCwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuLy8gSW4gdGhlIHNlY29uZCBzdGFnZSwgd2UgcnVuIHRoZSB0ZXh0IGFnYWluc3QgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGxvb2tcbi8vIGZvciBub24tSlNPTiBwYXR0ZXJucy4gV2UgYXJlIGVzcGVjaWFsbHkgY29uY2VybmVkIHdpdGggJygpJyBhbmQgJ25ldydcbi8vIGJlY2F1c2UgdGhleSBjYW4gY2F1c2UgaW52b2NhdGlvbiwgYW5kICc9JyBiZWNhdXNlIGl0IGNhbiBjYXVzZSBtdXRhdGlvbi5cbi8vIEJ1dCBqdXN0IHRvIGJlIHNhZmUsIHdlIHdhbnQgdG8gcmVqZWN0IGFsbCB1bmV4cGVjdGVkIGZvcm1zLlxuXG4vLyBXZSBzcGxpdCB0aGUgc2Vjb25kIHN0YWdlIGludG8gNCByZWdleHAgb3BlcmF0aW9ucyBpbiBvcmRlciB0byB3b3JrIGFyb3VuZFxuLy8gY3JpcHBsaW5nIGluZWZmaWNpZW5jaWVzIGluIElFJ3MgYW5kIFNhZmFyaSdzIHJlZ2V4cCBlbmdpbmVzLiBGaXJzdCB3ZVxuLy8gcmVwbGFjZSB0aGUgSlNPTiBiYWNrc2xhc2ggcGFpcnMgd2l0aCAnQCcgKGEgbm9uLUpTT04gY2hhcmFjdGVyKS4gU2Vjb25kLCB3ZVxuLy8gcmVwbGFjZSBhbGwgc2ltcGxlIHZhbHVlIHRva2VucyB3aXRoICddJyBjaGFyYWN0ZXJzLiBUaGlyZCwgd2UgZGVsZXRlIGFsbFxuLy8gb3BlbiBicmFja2V0cyB0aGF0IGZvbGxvdyBhIGNvbG9uIG9yIGNvbW1hIG9yIHRoYXQgYmVnaW4gdGhlIHRleHQuIEZpbmFsbHksXG4vLyB3ZSBsb29rIHRvIHNlZSB0aGF0IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhcmUgb25seSB3aGl0ZXNwYWNlIG9yICddJyBvclxuLy8gJywnIG9yICc6JyBvciAneycgb3IgJ30nLiBJZiB0aGF0IGlzIHNvLCB0aGVuIHRoZSB0ZXh0IGlzIHNhZmUgZm9yIGV2YWwuXG5cbiAgICAgICAgICAgIGlmICgvXltcXF0sOnt9XFxzXSokL1xuICAgICAgICAgICAgICAgICAgICAudGVzdCh0ZXh0LnJlcGxhY2UoL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZywgJ0AnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLCAnXScpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKD86Xnw6fCwpKD86XFxzKlxcWykrL2csICcnKSkpIHtcblxuLy8gSW4gdGhlIHRoaXJkIHN0YWdlIHdlIHVzZSB0aGUgZXZhbCBmdW5jdGlvbiB0byBjb21waWxlIHRoZSB0ZXh0IGludG8gYVxuLy8gSmF2YVNjcmlwdCBzdHJ1Y3R1cmUuIFRoZSAneycgb3BlcmF0b3IgaXMgc3ViamVjdCB0byBhIHN5bnRhY3RpYyBhbWJpZ3VpdHlcbi8vIGluIEphdmFTY3JpcHQ6IGl0IGNhbiBiZWdpbiBhIGJsb2NrIG9yIGFuIG9iamVjdCBsaXRlcmFsLiBXZSB3cmFwIHRoZSB0ZXh0XG4vLyBpbiBwYXJlbnMgdG8gZWxpbWluYXRlIHRoZSBhbWJpZ3VpdHkuXG5cbiAgICAgICAgICAgICAgICBqID0gZXZhbCgnKCcgKyB0ZXh0ICsgJyknKTtcblxuLy8gSW4gdGhlIG9wdGlvbmFsIGZvdXJ0aCBzdGFnZSwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSwgcGFzc2luZ1xuLy8gZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gYSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZSB0cmFuc2Zvcm1hdGlvbi5cblxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IHdhbGsoeycnOiBqfSwgJycpXG4gICAgICAgICAgICAgICAgICAgIDogajtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHRleHQgaXMgbm90IEpTT04gcGFyc2VhYmxlLCB0aGVuIGEgU3ludGF4RXJyb3IgaXMgdGhyb3duLlxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0pTT04ucGFyc2UnKTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpOy8qKlxuICogSGlzdG9yeS5qcyBqUXVlcnkgQWRhcHRlclxuICogQGF1dGhvciBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cbiAqIEBjb3B5cmlnaHQgMjAxMC0yMDExIEJlbmphbWluIEFydGh1ciBMdXB0b24gPGNvbnRhY3RAYmFsdXB0b24uY29tPlxuICogQGxpY2Vuc2UgTmV3IEJTRCBMaWNlbnNlIDxodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9CU0QvPlxuICovXG5cbi8vIENsb3N1cmVcbihmdW5jdGlvbih3aW5kb3csdW5kZWZpbmVkKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gTG9jYWxpc2UgR2xvYmFsc1xuXHR2YXJcblx0XHRIaXN0b3J5ID0gd2luZG93Lkhpc3RvcnkgPSB3aW5kb3cuSGlzdG9yeXx8e30sXG5cdFx0alF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcblxuXHQvLyBDaGVjayBFeGlzdGVuY2Vcblx0aWYgKCB0eXBlb2YgSGlzdG9yeS5BZGFwdGVyICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgQWRhcHRlciBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZC4uLicpO1xuXHR9XG5cblx0Ly8gQWRkIHRoZSBBZGFwdGVyXG5cdEhpc3RvcnkuQWRhcHRlciA9IHtcblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LkFkYXB0ZXIuYmluZChlbCxldmVudCxjYWxsYmFjaylcblx0XHQgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGN1c3RvbSBhbmQgc3RhbmRhcmQgZXZlbnRzXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcblx0XHQgKiBAcmV0dXJuIHt2b2lkfVxuXHRcdCAqL1xuXHRcdGJpbmQ6IGZ1bmN0aW9uKGVsLGV2ZW50LGNhbGxiYWNrKXtcblx0XHRcdGpRdWVyeShlbCkuYmluZChldmVudCxjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKGVsLGV2ZW50KVxuXHRcdCAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IGVsXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gY3VzdG9tIGFuZCBzdGFuZGFyZCBldmVudHNcblx0XHQgKiBAcGFyYW0ge09iamVjdD19IGV4dHJhIC0gYSBvYmplY3Qgb2YgZXh0cmEgZXZlbnQgZGF0YSAob3B0aW9uYWwpXG5cdFx0ICogQHJldHVybiB7dm9pZH1cblx0XHQgKi9cblx0XHR0cmlnZ2VyOiBmdW5jdGlvbihlbCxldmVudCxleHRyYSl7XG5cdFx0XHRqUXVlcnkoZWwpLnRyaWdnZXIoZXZlbnQsZXh0cmEpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LkFkYXB0ZXIuZXh0cmFjdEV2ZW50RGF0YShrZXksZXZlbnQsZXh0cmEpXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGtleSBmb3IgdGhlIGV2ZW50IGRhdGEgdG8gZXh0cmFjdFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGN1c3RvbSBhbmQgc3RhbmRhcmQgZXZlbnRzXG5cdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBleHRyYSAtIGEgb2JqZWN0IG9mIGV4dHJhIGV2ZW50IGRhdGEgKG9wdGlvbmFsKVxuXHRcdCAqIEByZXR1cm4ge21peGVkfVxuXHRcdCAqL1xuXHRcdGV4dHJhY3RFdmVudERhdGE6IGZ1bmN0aW9uKGtleSxldmVudCxleHRyYSl7XG5cdFx0XHQvLyBqUXVlcnkgTmF0aXZlIHRoZW4galF1ZXJ5IEN1c3RvbVxuXHRcdFx0dmFyIHJlc3VsdCA9IChldmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnRba2V5XSkgfHwgKGV4dHJhICYmIGV4dHJhW2tleV0pIHx8IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LkFkYXB0ZXIub25Eb21Mb2FkKGNhbGxiYWNrKVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG5cdFx0ICogQHJldHVybiB7dm9pZH1cblx0XHQgKi9cblx0XHRvbkRvbUxvYWQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRqUXVlcnkoY2FsbGJhY2spO1xuXHRcdH1cblx0fTtcblxuXHQvLyBUcnkgYW5kIEluaXRpYWxpc2UgSGlzdG9yeVxuXHRpZiAoIHR5cGVvZiBIaXN0b3J5LmluaXQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdEhpc3RvcnkuaW5pdCgpO1xuXHR9XG5cbn0pKHdpbmRvdyk7XG5cbi8qKlxuICogSGlzdG9yeS5qcyBIVE1MNCBTdXBwb3J0XG4gKiBEZXBlbmRzIG9uIHRoZSBIVE1MNSBTdXBwb3J0XG4gKiBAYXV0aG9yIEJlbmphbWluIEFydGh1ciBMdXB0b24gPGNvbnRhY3RAYmFsdXB0b24uY29tPlxuICogQGNvcHlyaWdodCAyMDEwLTIwMTEgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG4gKiBAbGljZW5zZSBOZXcgQlNEIExpY2Vuc2UgPGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL0JTRC8+XG4gKi9cblxuKGZ1bmN0aW9uKHdpbmRvdyx1bmRlZmluZWQpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0Ly8gSW5pdGlhbGlzZVxuXG5cdC8vIExvY2FsaXNlIEdsb2JhbHNcblx0dmFyXG5cdFx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgdXNpbmcgdGhlIGNvcnJlY3QgZG9jdW1lbnRcblx0XHRzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXR8fHNldFRpbWVvdXQsXG5cdFx0Y2xlYXJUaW1lb3V0ID0gd2luZG93LmNsZWFyVGltZW91dHx8Y2xlYXJUaW1lb3V0LFxuXHRcdHNldEludGVydmFsID0gd2luZG93LnNldEludGVydmFsfHxzZXRJbnRlcnZhbCxcblx0XHRIaXN0b3J5ID0gd2luZG93Lkhpc3RvcnkgPSB3aW5kb3cuSGlzdG9yeXx8e307IC8vIFB1YmxpYyBIaXN0b3J5IE9iamVjdFxuXG5cdC8vIENoZWNrIEV4aXN0ZW5jZVxuXHRpZiAoIHR5cGVvZiBIaXN0b3J5LmluaXRIdG1sNCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmpzIEhUTUw0IFN1cHBvcnQgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQuLi4nKTtcblx0fVxuXG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdC8vIEluaXRpYWxpc2UgSFRNTDQgU3VwcG9ydFxuXG5cdC8vIEluaXRpYWxpc2UgSFRNTDQgU3VwcG9ydFxuXHRIaXN0b3J5LmluaXRIdG1sNCA9IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gSW5pdGlhbGlzZVxuXHRcdGlmICggdHlwZW9mIEhpc3RvcnkuaW5pdEh0bWw0LmluaXRpYWxpemVkICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdC8vIEFscmVhZHkgTG9hZGVkXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0SGlzdG9yeS5pbml0SHRtbDQuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdH1cblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBQcm9wZXJ0aWVzXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmVuYWJsZWRcblx0XHQgKiBJcyBIaXN0b3J5IGVuYWJsZWQ/XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5lbmFibGVkID0gdHJ1ZTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBIYXNoIFN0b3JhZ2VcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc2F2ZWRIYXNoZXNcblx0XHQgKiBTdG9yZSB0aGUgaGFzaGVzIGluIGFuIGFycmF5XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlZEhhc2hlcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5pc0xhc3RIYXNoKG5ld0hhc2gpXG5cdFx0ICogQ2hlY2tzIGlmIHRoZSBoYXNoIGlzIHRoZSBsYXN0IGhhc2hcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmV3SGFzaFxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmlzTGFzdEhhc2ggPSBmdW5jdGlvbihuZXdIYXNoKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBvbGRIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlJbmRleCgpLFxuXHRcdFx0XHRpc0xhc3Q7XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRpc0xhc3QgPSBuZXdIYXNoID09PSBvbGRIYXNoO1xuXG5cdFx0XHQvLyBSZXR1cm4gaXNMYXN0XG5cdFx0XHRyZXR1cm4gaXNMYXN0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmlzSGFzaEVxdWFsKG5ld0hhc2gsIG9sZEhhc2gpXG5cdFx0ICogQ2hlY2tzIHRvIHNlZSBpZiB0d28gaGFzaGVzIGFyZSBmdW5jdGlvbmFsbHkgZXF1YWxcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmV3SGFzaFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBvbGRIYXNoXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaXNIYXNoRXF1YWwgPSBmdW5jdGlvbihuZXdIYXNoLCBvbGRIYXNoKXtcblx0XHRcdG5ld0hhc2ggPSBlbmNvZGVVUklDb21wb25lbnQobmV3SGFzaCkucmVwbGFjZSgvJTI1L2csIFwiJVwiKTtcblx0XHRcdG9sZEhhc2ggPSBlbmNvZGVVUklDb21wb25lbnQob2xkSGFzaCkucmVwbGFjZSgvJTI1L2csIFwiJVwiKTtcblx0XHRcdHJldHVybiBuZXdIYXNoID09PSBvbGRIYXNoO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNhdmVIYXNoKG5ld0hhc2gpXG5cdFx0ICogUHVzaCBhIEhhc2hcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmV3SGFzaFxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWVcblx0XHQgKi9cblx0XHRIaXN0b3J5LnNhdmVIYXNoID0gZnVuY3Rpb24obmV3SGFzaCl7XG5cdFx0XHQvLyBDaGVjayBIYXNoXG5cdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0SGFzaChuZXdIYXNoKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXNoIHRoZSBIYXNoXG5cdFx0XHRIaXN0b3J5LnNhdmVkSGFzaGVzLnB1c2gobmV3SGFzaCk7XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRIYXNoQnlJbmRleCgpXG5cdFx0ICogR2V0cyBhIGhhc2ggYnkgdGhlIGluZGV4XG5cdFx0ICogQHBhcmFtIHtpbnRlZ2VyfSBpbmRleFxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ31cblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldEhhc2hCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGhhc2ggPSBudWxsO1xuXG5cdFx0XHQvLyBIYW5kbGVcblx0XHRcdGlmICggdHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBsYXN0IGluc2VydGVkXG5cdFx0XHRcdGhhc2ggPSBIaXN0b3J5LnNhdmVkSGFzaGVzW0hpc3Rvcnkuc2F2ZWRIYXNoZXMubGVuZ3RoLTFdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0Ly8gR2V0IGZyb20gdGhlIGVuZFxuXHRcdFx0XHRoYXNoID0gSGlzdG9yeS5zYXZlZEhhc2hlc1tIaXN0b3J5LnNhdmVkSGFzaGVzLmxlbmd0aCtpbmRleF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gR2V0IGZyb20gdGhlIGJlZ2lubmluZ1xuXHRcdFx0XHRoYXNoID0gSGlzdG9yeS5zYXZlZEhhc2hlc1tpbmRleF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBoYXNoXG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIERpc2NhcmRlZCBTdGF0ZXNcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZGlzY2FyZGVkSGFzaGVzXG5cdFx0ICogQSBoYXNoZWQgYXJyYXkgb2YgZGlzY2FyZGVkIGhhc2hlc1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZGlzY2FyZGVkSGFzaGVzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRpc2NhcmRlZFN0YXRlc1xuXHRcdCAqIEEgaGFzaGVkIGFycmF5IG9mIGRpc2NhcmRlZCBzdGF0ZXNcblx0XHQgKi9cblx0XHRIaXN0b3J5LmRpc2NhcmRlZFN0YXRlcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kaXNjYXJkU3RhdGUoU3RhdGUpXG5cdFx0ICogRGlzY2FyZHMgdGhlIHN0YXRlIGJ5IGlnbm9yaW5nIGl0IHRocm91Z2ggSGlzdG9yeVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge3RydWV9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kaXNjYXJkU3RhdGUgPSBmdW5jdGlvbihkaXNjYXJkZWRTdGF0ZSxmb3J3YXJkU3RhdGUsYmFja1N0YXRlKXtcblx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5kaXNjYXJkU3RhdGUnLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGRpc2NhcmRlZFN0YXRlSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5U3RhdGUoZGlzY2FyZGVkU3RhdGUpLFxuXHRcdFx0XHRkaXNjYXJkT2JqZWN0O1xuXG5cdFx0XHQvLyBDcmVhdGUgRGlzY2FyZCBPYmplY3Rcblx0XHRcdGRpc2NhcmRPYmplY3QgPSB7XG5cdFx0XHRcdCdkaXNjYXJkZWRTdGF0ZSc6IGRpc2NhcmRlZFN0YXRlLFxuXHRcdFx0XHQnYmFja1N0YXRlJzogYmFja1N0YXRlLFxuXHRcdFx0XHQnZm9yd2FyZFN0YXRlJzogZm9yd2FyZFN0YXRlXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBBZGQgdG8gRGlzY2FyZGVkU3RhdGVzXG5cdFx0XHRIaXN0b3J5LmRpc2NhcmRlZFN0YXRlc1tkaXNjYXJkZWRTdGF0ZUhhc2hdID0gZGlzY2FyZE9iamVjdDtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRpc2NhcmRIYXNoKGhhc2gpXG5cdFx0ICogRGlzY2FyZHMgdGhlIGhhc2ggYnkgaWdub3JpbmcgaXQgdGhyb3VnaCBIaXN0b3J5XG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcblx0XHQgKiBAcmV0dXJuIHt0cnVlfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZGlzY2FyZEhhc2ggPSBmdW5jdGlvbihkaXNjYXJkZWRIYXNoLGZvcndhcmRTdGF0ZSxiYWNrU3RhdGUpe1xuXHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmRpc2NhcmRTdGF0ZScsIGFyZ3VtZW50cyk7XG5cdFx0XHQvLyBDcmVhdGUgRGlzY2FyZCBPYmplY3Rcblx0XHRcdHZhciBkaXNjYXJkT2JqZWN0ID0ge1xuXHRcdFx0XHQnZGlzY2FyZGVkSGFzaCc6IGRpc2NhcmRlZEhhc2gsXG5cdFx0XHRcdCdiYWNrU3RhdGUnOiBiYWNrU3RhdGUsXG5cdFx0XHRcdCdmb3J3YXJkU3RhdGUnOiBmb3J3YXJkU3RhdGVcblx0XHRcdH07XG5cblx0XHRcdC8vIEFkZCB0byBkaXNjYXJkZWRIYXNoXG5cdFx0XHRIaXN0b3J5LmRpc2NhcmRlZEhhc2hlc1tkaXNjYXJkZWRIYXNoXSA9IGRpc2NhcmRPYmplY3Q7XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kaXNjYXJkZWRTdGF0ZShTdGF0ZSlcblx0XHQgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBzdGF0ZSBpcyBkaXNjYXJkZWRcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gU3RhdGVcblx0XHQgKiBAcmV0dXJuIHtib29sfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZGlzY2FyZGVkU3RhdGUgPSBmdW5jdGlvbihTdGF0ZSl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgU3RhdGVIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShTdGF0ZSksXG5cdFx0XHRcdGRpc2NhcmRlZDtcblxuXHRcdFx0Ly8gQ2hlY2tcblx0XHRcdGRpc2NhcmRlZCA9IEhpc3RvcnkuZGlzY2FyZGVkU3RhdGVzW1N0YXRlSGFzaF18fGZhbHNlO1xuXG5cdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0cmV0dXJuIGRpc2NhcmRlZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kaXNjYXJkZWRIYXNoKGhhc2gpXG5cdFx0ICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgc3RhdGUgaXMgZGlzY2FyZGVkXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFN0YXRlXG5cdFx0ICogQHJldHVybiB7Ym9vbH1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRpc2NhcmRlZEhhc2ggPSBmdW5jdGlvbihoYXNoKXtcblx0XHRcdC8vIENoZWNrXG5cdFx0XHR2YXIgZGlzY2FyZGVkID0gSGlzdG9yeS5kaXNjYXJkZWRIYXNoZXNbaGFzaF18fGZhbHNlO1xuXG5cdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0cmV0dXJuIGRpc2NhcmRlZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5yZWN5Y2xlU3RhdGUoU3RhdGUpXG5cdFx0ICogQWxsb3dzIGEgZGlzY2FyZGVkIHN0YXRlIHRvIGJlIHVzZWQgYWdhaW5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcmV0dXJuIHt0cnVlfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkucmVjeWNsZVN0YXRlID0gZnVuY3Rpb24oU3RhdGUpe1xuXHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnJlY3ljbGVTdGF0ZScsIGFyZ3VtZW50cyk7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgU3RhdGVIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShTdGF0ZSk7XG5cblx0XHRcdC8vIFJlbW92ZSBmcm9tIERpc2NhcmRlZFN0YXRlc1xuXHRcdFx0aWYgKCBIaXN0b3J5LmRpc2NhcmRlZFN0YXRlKFN0YXRlKSApIHtcblx0XHRcdFx0ZGVsZXRlIEhpc3RvcnkuZGlzY2FyZGVkU3RhdGVzW1N0YXRlSGFzaF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEhUTUw0IEhhc2hDaGFuZ2UgU3VwcG9ydFxuXG5cdFx0aWYgKCBIaXN0b3J5LmVtdWxhdGVkLmhhc2hDaGFuZ2UgKSB7XG5cdFx0XHQvKlxuXHRcdFx0ICogV2UgbXVzdCBlbXVsYXRlIHRoZSBIVE1MNCBIYXNoQ2hhbmdlIFN1cHBvcnQgYnkgbWFudWFsbHkgY2hlY2tpbmcgZm9yIGhhc2ggY2hhbmdlc1xuXHRcdFx0ICovXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSGlzdG9yeS5oYXNoQ2hhbmdlSW5pdCgpXG5cdFx0XHQgKiBJbml0IHRoZSBIYXNoQ2hhbmdlIEVtdWxhdGlvblxuXHRcdFx0ICovXG5cdFx0XHRIaXN0b3J5Lmhhc2hDaGFuZ2VJbml0ID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0Ly8gRGVmaW5lIG91ciBDaGVja2VyIEZ1bmN0aW9uXG5cdFx0XHRcdEhpc3RvcnkuY2hlY2tlckZ1bmN0aW9uID0gbnVsbDtcblxuXHRcdFx0XHQvLyBEZWZpbmUgc29tZSB2YXJpYWJsZXMgdGhhdCB3aWxsIGhlbHAgaW4gb3VyIGNoZWNrZXIgZnVuY3Rpb25cblx0XHRcdFx0dmFyIGxhc3REb2N1bWVudEhhc2ggPSAnJyxcblx0XHRcdFx0XHRpZnJhbWVJZCwgaWZyYW1lLFxuXHRcdFx0XHRcdGxhc3RJZnJhbWVIYXNoLCBjaGVja2VyUnVubmluZyxcblx0XHRcdFx0XHRzdGFydGVkV2l0aEhhc2ggPSBCb29sZWFuKEhpc3RvcnkuZ2V0SGFzaCgpKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXG5cdFx0XHRcdGlmICggSGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIoKSApIHtcblx0XHRcdFx0XHQvLyBJRTYgYW5kIElFN1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gdXNlIGFuIGlmcmFtZSB0byBlbXVsYXRlIHRoZSBiYWNrIGFuZCBmb3J3YXJkIGJ1dHRvbnNcblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBpRnJhbWVcblx0XHRcdFx0XHRpZnJhbWVJZCA9ICdoaXN0b3J5anMtaWZyYW1lJztcblx0XHRcdFx0XHRpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblxuXHRcdFx0XHRcdC8vIEFkanVzdCBpRmFybWVcblx0XHRcdFx0XHQvLyBJRSA2IHJlcXVpcmVzIGlmcmFtZSB0byBoYXZlIGEgc3JjIG9uIEhUVFBTIHBhZ2VzLCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhXG5cdFx0XHRcdFx0Ly8gXCJUaGlzIHBhZ2UgY29udGFpbnMgYm90aCBzZWN1cmUgYW5kIG5vbnNlY3VyZSBpdGVtc1wiIHdhcm5pbmcuXG5cdFx0XHRcdFx0aWZyYW1lLnNldEF0dHJpYnV0ZSgnaWQnLCBpZnJhbWVJZCk7XG5cdFx0XHRcdFx0aWZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgJyMnKTtcblx0XHRcdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuXHRcdFx0XHRcdC8vIEFwcGVuZCBpRnJhbWVcblx0XHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgaW5pdGlhbCBoaXN0b3J5IGVudHJ5XG5cdFx0XHRcdFx0aWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQub3BlbigpO1xuXHRcdFx0XHRcdGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XG5cblx0XHRcdFx0XHQvLyBEZWZpbmUgc29tZSB2YXJpYWJsZXMgdGhhdCB3aWxsIGhlbHAgaW4gb3VyIGNoZWNrZXIgZnVuY3Rpb25cblx0XHRcdFx0XHRsYXN0SWZyYW1lSGFzaCA9ICcnO1xuXHRcdFx0XHRcdGNoZWNrZXJSdW5uaW5nID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBEZWZpbmUgdGhlIGNoZWNrZXIgZnVuY3Rpb25cblx0XHRcdFx0XHRIaXN0b3J5LmNoZWNrZXJGdW5jdGlvbiA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBSdW5uaW5nXG5cdFx0XHRcdFx0XHRpZiAoIGNoZWNrZXJSdW5uaW5nICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFVwZGF0ZSBSdW5uaW5nXG5cdFx0XHRcdFx0XHRjaGVja2VyUnVubmluZyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdC8vIEZldGNoXG5cdFx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRIYXNoID0gSGlzdG9yeS5nZXRIYXNoKCksXG5cdFx0XHRcdFx0XHRcdGlmcmFtZUhhc2ggPSBIaXN0b3J5LmdldEhhc2goaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpO1xuXG5cdFx0XHRcdFx0XHQvLyBUaGUgRG9jdW1lbnQgSGFzaCBoYXMgY2hhbmdlZCAoYXBwbGljYXRpb24gY2F1c2VkKVxuXHRcdFx0XHRcdFx0aWYgKCBkb2N1bWVudEhhc2ggIT09IGxhc3REb2N1bWVudEhhc2ggKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEVxdWFsaXNlXG5cdFx0XHRcdFx0XHRcdGxhc3REb2N1bWVudEhhc2ggPSBkb2N1bWVudEhhc2g7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgaGlzdG9yeSBlbnRyeSBpbiB0aGUgaWZyYW1lXG5cdFx0XHRcdFx0XHRcdGlmICggaWZyYW1lSGFzaCAhPT0gZG9jdW1lbnRIYXNoICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnaGFzaGNoYW5nZS5jaGVja2VyOiBpZnJhbWUgaGFzaCBjaGFuZ2UnLCAnZG9jdW1lbnRIYXNoIChuZXcpOicsIGRvY3VtZW50SGFzaCwgJ2lmcmFtZUhhc2ggKG9sZCk6JywgaWZyYW1lSGFzaCk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBFcXVhbGlzZVxuXHRcdFx0XHRcdFx0XHRcdGxhc3RJZnJhbWVIYXNoID0gaWZyYW1lSGFzaCA9IGRvY3VtZW50SGFzaDtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENyZWF0ZSBIaXN0b3J5IEVudHJ5XG5cdFx0XHRcdFx0XHRcdFx0aWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQub3BlbigpO1xuXHRcdFx0XHRcdFx0XHRcdGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBVcGRhdGUgdGhlIGlmcmFtZSdzIGhhc2hcblx0XHRcdFx0XHRcdFx0XHRpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5sb2NhdGlvbi5oYXNoID0gSGlzdG9yeS5lc2NhcGVIYXNoKGRvY3VtZW50SGFzaCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBUcmlnZ2VyIEhhc2hjaGFuZ2UgRXZlbnRcblx0XHRcdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdoYXNoY2hhbmdlJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFRoZSBpRnJhbWUgSGFzaCBoYXMgY2hhbmdlZCAoYmFjayBidXR0b24gY2F1c2VkKVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoIGlmcmFtZUhhc2ggIT09IGxhc3RJZnJhbWVIYXNoICkge1xuXHRcdFx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ2hhc2hjaGFuZ2UuY2hlY2tlcjogaWZyYW1lIGhhc2ggb3V0IG9mIHN5bmMnLCAnaWZyYW1lSGFzaCAobmV3KTonLCBpZnJhbWVIYXNoLCAnZG9jdW1lbnRIYXNoIChvbGQpOicsIGRvY3VtZW50SGFzaCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXF1YWxpc2Vcblx0XHRcdFx0XHRcdFx0bGFzdElmcmFtZUhhc2ggPSBpZnJhbWVIYXNoO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgbm8gaWZyYW1lIGhhc2ggdGhhdCBtZWFucyB3ZSdyZSBhdCB0aGUgb3JpZ2luYWxcblx0XHRcdFx0XHRcdFx0Ly8gaWZyYW1lIHN0YXRlLlxuXHRcdFx0XHRcdFx0XHQvLyBBbmQgaWYgdGhlcmUgd2FzIGEgaGFzaCBvbiB0aGUgb3JpZ2luYWwgcmVxdWVzdCwgdGhlIG9yaWdpbmFsXG5cdFx0XHRcdFx0XHRcdC8vIGlmcmFtZSBzdGF0ZSB3YXMgcmVwbGFjZWQgaW5zdGFudGx5LCBzbyBza2lwIHRoaXMgc3RhdGUgYW5kIHRha2Vcblx0XHRcdFx0XHRcdFx0Ly8gdGhlIHVzZXIgYmFjayB0byB3aGVyZSB0aGV5IGNhbWUgZnJvbS5cblx0XHRcdFx0XHRcdFx0aWYgKHN0YXJ0ZWRXaXRoSGFzaCAmJiBpZnJhbWVIYXNoID09PSAnJykge1xuXHRcdFx0XHRcdFx0XHRcdEhpc3RvcnkuYmFjaygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVwZGF0ZSB0aGUgSGFzaFxuXHRcdFx0XHRcdFx0XHRcdEhpc3Rvcnkuc2V0SGFzaChpZnJhbWVIYXNoLGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBSZXNldCBSdW5uaW5nXG5cdFx0XHRcdFx0XHRjaGVja2VyUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBXZSBhcmUgbm90IElFXG5cdFx0XHRcdFx0Ly8gRmlyZWZveCAxIG9yIDIsIE9wZXJhXG5cblx0XHRcdFx0XHQvLyBEZWZpbmUgdGhlIGNoZWNrZXIgZnVuY3Rpb25cblx0XHRcdFx0XHRIaXN0b3J5LmNoZWNrZXJGdW5jdGlvbiA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRcdFx0XHR2YXIgZG9jdW1lbnRIYXNoID0gSGlzdG9yeS5nZXRIYXNoKCl8fCcnO1xuXG5cdFx0XHRcdFx0XHQvLyBUaGUgRG9jdW1lbnQgSGFzaCBoYXMgY2hhbmdlZCAoYXBwbGljYXRpb24gY2F1c2VkKVxuXHRcdFx0XHRcdFx0aWYgKCBkb2N1bWVudEhhc2ggIT09IGxhc3REb2N1bWVudEhhc2ggKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEVxdWFsaXNlXG5cdFx0XHRcdFx0XHRcdGxhc3REb2N1bWVudEhhc2ggPSBkb2N1bWVudEhhc2g7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVHJpZ2dlciBIYXNoY2hhbmdlIEV2ZW50XG5cdFx0XHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnaGFzaGNoYW5nZScpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IHRoZSBjaGVja2VyIGZ1bmN0aW9uXG5cdFx0XHRcdEhpc3RvcnkuaW50ZXJ2YWxMaXN0LnB1c2goc2V0SW50ZXJ2YWwoSGlzdG9yeS5jaGVja2VyRnVuY3Rpb24sIEhpc3Rvcnkub3B0aW9ucy5oYXNoQ2hhbmdlSW50ZXJ2YWwpKTtcblxuXHRcdFx0XHQvLyBEb25lXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTsgLy8gSGlzdG9yeS5oYXNoQ2hhbmdlSW5pdFxuXG5cdFx0XHQvLyBCaW5kIGhhc2hDaGFuZ2VJbml0XG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIub25Eb21Mb2FkKEhpc3RvcnkuaGFzaENoYW5nZUluaXQpO1xuXG5cdFx0fSAvLyBIaXN0b3J5LmVtdWxhdGVkLmhhc2hDaGFuZ2VcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBIVE1MNSBTdGF0ZSBTdXBwb3J0XG5cblx0XHQvLyBOb24tTmF0aXZlIHB1c2hTdGF0ZSBJbXBsZW1lbnRhdGlvblxuXHRcdGlmICggSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgKSB7XG5cdFx0XHQvKlxuXHRcdFx0ICogV2UgbXVzdCBlbXVsYXRlIHRoZSBIVE1MNSBTdGF0ZSBNYW5hZ2VtZW50IGJ5IHVzaW5nIEhUTUw0IEhhc2hDaGFuZ2Vcblx0XHRcdCAqL1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3Rvcnkub25IYXNoQ2hhbmdlKGV2ZW50KVxuXHRcdFx0ICogVHJpZ2dlciBIVE1MNSdzIHdpbmRvdy5vbnBvcHN0YXRlIHZpYSBIVE1MNCBIYXNoQ2hhbmdlIFN1cHBvcnRcblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5vbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbihldmVudCl7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5vbkhhc2hDaGFuZ2UnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRcdC8vIFByZXBhcmVcblx0XHRcdFx0dmFyIGN1cnJlbnRVcmwgPSAoKGV2ZW50ICYmIGV2ZW50Lm5ld1VSTCkgfHwgSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSksXG5cdFx0XHRcdFx0Y3VycmVudEhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVVybChjdXJyZW50VXJsKSxcblx0XHRcdFx0XHRjdXJyZW50U3RhdGUgPSBudWxsLFxuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZUhhc2ggPSBudWxsLFxuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZUhhc2hFeGl0cyA9IG51bGwsXG5cdFx0XHRcdFx0ZGlzY2FyZE9iamVjdDtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgdGhlIHNhbWUgc3RhdGVcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmlzTGFzdEhhc2goY3VycmVudEhhc2gpICkge1xuXHRcdFx0XHRcdC8vIFRoZXJlIGhhcyBiZWVuIG5vIGNoYW5nZSAoanVzdCB0aGUgcGFnZSdzIGhhc2ggaGFzIGZpbmFsbHkgcHJvcGFnYXRlZClcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25IYXNoQ2hhbmdlOiBubyBjaGFuZ2UnKTtcblx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc2V0IHRoZSBkb3VibGUgY2hlY2tcblx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja0NvbXBsZXRlKCk7XG5cblx0XHRcdFx0Ly8gU3RvcmUgb3VyIGxvY2F0aW9uIGZvciB1c2UgaW4gZGV0ZWN0aW5nIGJhY2svZm9yd2FyZCBkaXJlY3Rpb25cblx0XHRcdFx0SGlzdG9yeS5zYXZlSGFzaChjdXJyZW50SGFzaCk7XG5cblx0XHRcdFx0Ly8gRXhwYW5kIEhhc2hcblx0XHRcdFx0aWYgKCBjdXJyZW50SGFzaCAmJiBIaXN0b3J5LmlzVHJhZGl0aW9uYWxBbmNob3IoY3VycmVudEhhc2gpICkge1xuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5vbkhhc2hDaGFuZ2U6IHRyYWRpdGlvbmFsIGFuY2hvcicsIGN1cnJlbnRIYXNoKTtcblx0XHRcdFx0XHQvLyBUcmFkaXRpb25hbCBBbmNob3IgSGFzaFxuXHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnYW5jaG9yY2hhbmdlJyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgU3RhdGVcblx0XHRcdFx0Y3VycmVudFN0YXRlID0gSGlzdG9yeS5leHRyYWN0U3RhdGUoSGlzdG9yeS5nZXRGdWxsVXJsKGN1cnJlbnRIYXNofHxIaXN0b3J5LmdldExvY2F0aW9uSHJlZigpKSx0cnVlKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgdGhlIHNhbWUgc3RhdGVcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmlzTGFzdFNhdmVkU3RhdGUoY3VycmVudFN0YXRlKSApIHtcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25IYXNoQ2hhbmdlOiBubyBjaGFuZ2UnKTtcblx0XHRcdFx0XHQvLyBUaGVyZSBoYXMgYmVlbiBubyBjaGFuZ2UgKGp1c3QgdGhlIHBhZ2UncyBoYXNoIGhhcyBmaW5hbGx5IHByb3BhZ2F0ZWQpXG5cdFx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIHN0YXRlIEhhc2hcblx0XHRcdFx0Y3VycmVudFN0YXRlSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5U3RhdGUoY3VycmVudFN0YXRlKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgRGlzY2FyZGVkU3RhdGVcblx0XHRcdFx0ZGlzY2FyZE9iamVjdCA9IEhpc3RvcnkuZGlzY2FyZGVkU3RhdGUoY3VycmVudFN0YXRlKTtcblx0XHRcdFx0aWYgKCBkaXNjYXJkT2JqZWN0ICkge1xuXHRcdFx0XHRcdC8vIElnbm9yZSB0aGlzIHN0YXRlIGFzIGl0IGhhcyBiZWVuIGRpc2NhcmRlZCBhbmQgZ28gYmFjayB0byB0aGUgc3RhdGUgYmVmb3JlIGl0XG5cdFx0XHRcdFx0aWYgKCBIaXN0b3J5LmdldEhhc2hCeUluZGV4KC0yKSA9PT0gSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShkaXNjYXJkT2JqZWN0LmZvcndhcmRTdGF0ZSkgKSB7XG5cdFx0XHRcdFx0XHQvLyBXZSBhcmUgZ29pbmcgYmFja3dhcmRzXG5cdFx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25IYXNoQ2hhbmdlOiBnbyBiYWNrd2FyZHMnKTtcblx0XHRcdFx0XHRcdEhpc3RvcnkuYmFjayhmYWxzZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFdlIGFyZSBnb2luZyBmb3J3YXJkc1xuXHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uSGFzaENoYW5nZTogZ28gZm9yd2FyZHMnKTtcblx0XHRcdFx0XHRcdEhpc3RvcnkuZm9yd2FyZChmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFB1c2ggdGhlIG5ldyBIVE1MNSBTdGF0ZVxuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25IYXNoQ2hhbmdlOiBzdWNjZXNzIGhhc2hjaGFuZ2UnKTtcblx0XHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUoY3VycmVudFN0YXRlLmRhdGEsY3VycmVudFN0YXRlLnRpdGxlLGVuY29kZVVSSShjdXJyZW50U3RhdGUudXJsKSxmYWxzZSk7XG5cblx0XHRcdFx0Ly8gRW5kIG9uSGFzaENoYW5nZSBjbG9zdXJlXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTtcblx0XHRcdEhpc3RvcnkuQWRhcHRlci5iaW5kKHdpbmRvdywnaGFzaGNoYW5nZScsSGlzdG9yeS5vbkhhc2hDaGFuZ2UpO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3RvcnkucHVzaFN0YXRlKGRhdGEsdGl0bGUsdXJsKVxuXHRcdFx0ICogQWRkIGEgbmV3IFN0YXRlIHRvIHRoZSBoaXN0b3J5IG9iamVjdCwgYmVjb21lIGl0LCBhbmQgdHJpZ2dlciBvbnBvcHN0YXRlXG5cdFx0XHQgKiBXZSBoYXZlIHRvIHRyaWdnZXIgZm9yIEhUTUw0IGNvbXBhdGliaWxpdHlcblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHRcdCAqIEByZXR1cm4ge3RydWV9XG5cdFx0XHQgKi9cblx0XHRcdEhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24oZGF0YSx0aXRsZSx1cmwscXVldWUpe1xuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBVUkwgcGFzc2VkIGluIGlzIFVSSS1lbmNvZGVkLCBidXQgdGhpcyBtYWtlc1xuXHRcdFx0XHQvLyBzdXJlIHRoYXQgaXQncyBmdWxseSBVUkkgZW5jb2RlZDsgYW55ICclJ3MgdGhhdCBhcmUgZW5jb2RlZCBhcmVcblx0XHRcdFx0Ly8gY29udmVydGVkIGJhY2sgaW50byAnJSdzXG5cdFx0XHRcdHVybCA9IGVuY29kZVVSSSh1cmwpLnJlcGxhY2UoLyUyNS9nLCBcIiVcIik7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgdGhlIFN0YXRlXG5cdFx0XHRcdGlmICggSGlzdG9yeS5nZXRIYXNoQnlVcmwodXJsKSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgZG9lcyBub3Qgc3VwcG9ydCBzdGF0ZXMgd2l0aCBmcmFnbWVudC1pZGVudGlmaWVycyAoaGFzaGVzL2FuY2hvcnMpLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIFF1ZXVlaW5nXG5cdFx0XHRcdGlmICggcXVldWUgIT09IGZhbHNlICYmIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHRcdC8vIFdhaXQgKyBQdXNoIHRvIFF1ZXVlXG5cdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnB1c2hTdGF0ZTogd2UgbXVzdCB3YWl0JywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRIaXN0b3J5LnB1c2hRdWV1ZSh7XG5cdFx0XHRcdFx0XHRzY29wZTogSGlzdG9yeSxcblx0XHRcdFx0XHRcdGNhbGxiYWNrOiBIaXN0b3J5LnB1c2hTdGF0ZSxcblx0XHRcdFx0XHRcdGFyZ3M6IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdHF1ZXVlOiBxdWV1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1ha2UgQnVzeVxuXHRcdFx0XHRIaXN0b3J5LmJ1c3kodHJ1ZSk7XG5cblx0XHRcdFx0Ly8gRmV0Y2ggdGhlIFN0YXRlIE9iamVjdFxuXHRcdFx0XHR2YXIgbmV3U3RhdGUgPSBIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0KGRhdGEsdGl0bGUsdXJsKSxcblx0XHRcdFx0XHRuZXdTdGF0ZUhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKG5ld1N0YXRlKSxcblx0XHRcdFx0XHRvbGRTdGF0ZSA9IEhpc3RvcnkuZ2V0U3RhdGUoZmFsc2UpLFxuXHRcdFx0XHRcdG9sZFN0YXRlSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5U3RhdGUob2xkU3RhdGUpLFxuXHRcdFx0XHRcdGh0bWw0SGFzaCA9IEhpc3RvcnkuZ2V0SGFzaCgpLFxuXHRcdFx0XHRcdHdhc0V4cGVjdGVkID0gSGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPT0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlIG5ld1N0YXRlXG5cdFx0XHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0XHRcdEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkID0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdFx0Ly8gUmVjeWNsZSB0aGUgU3RhdGVcblx0XHRcdFx0SGlzdG9yeS5yZWN5Y2xlU3RhdGUobmV3U3RhdGUpO1xuXG5cdFx0XHRcdC8vIEZvcmNlIHVwZGF0ZSBvZiB0aGUgdGl0bGVcblx0XHRcdFx0SGlzdG9yeS5zZXRUaXRsZShuZXdTdGF0ZSk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIHRoZSBzYW1lIFN0YXRlXG5cdFx0XHRcdGlmICggbmV3U3RhdGVIYXNoID09PSBvbGRTdGF0ZUhhc2ggKSB7XG5cdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnB1c2hTdGF0ZTogbm8gY2hhbmdlJywgbmV3U3RhdGVIYXNoKTtcblx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVwZGF0ZSBIVE1MNSBTdGF0ZVxuXHRcdFx0XHRIaXN0b3J5LnNhdmVTdGF0ZShuZXdTdGF0ZSk7XG5cblx0XHRcdFx0Ly8gRmlyZSBIVE1MNSBFdmVudFxuXHRcdFx0XHRpZighd2FzRXhwZWN0ZWQpXG5cdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdzdGF0ZWNoYW5nZScpO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBIVE1MNCBIYXNoXG5cdFx0XHRcdGlmICggIUhpc3RvcnkuaXNIYXNoRXF1YWwobmV3U3RhdGVIYXNoLCBodG1sNEhhc2gpICYmICFIaXN0b3J5LmlzSGFzaEVxdWFsKG5ld1N0YXRlSGFzaCwgSGlzdG9yeS5nZXRTaG9ydFVybChIaXN0b3J5LmdldExvY2F0aW9uSHJlZigpKSkgKSB7XG5cdFx0XHRcdFx0SGlzdG9yeS5zZXRIYXNoKG5ld1N0YXRlSGFzaCxmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cblx0XHRcdFx0Ly8gRW5kIHB1c2hTdGF0ZSBjbG9zdXJlXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIaXN0b3J5LnJlcGxhY2VTdGF0ZShkYXRhLHRpdGxlLHVybClcblx0XHRcdCAqIFJlcGxhY2UgdGhlIFN0YXRlIGFuZCB0cmlnZ2VyIG9ucG9wc3RhdGVcblx0XHRcdCAqIFdlIGhhdmUgdG8gdHJpZ2dlciBmb3IgSFRNTDQgY29tcGF0aWJpbGl0eVxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdFx0ICogQHJldHVybiB7dHJ1ZX1cblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbihkYXRhLHRpdGxlLHVybCxxdWV1ZSl7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5yZXBsYWNlU3RhdGU6IGNhbGxlZCcsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0Ly8gV2UgYXNzdW1lIHRoYXQgdGhlIFVSTCBwYXNzZWQgaW4gaXMgVVJJLWVuY29kZWQsIGJ1dCB0aGlzIG1ha2VzXG5cdFx0XHRcdC8vIHN1cmUgdGhhdCBpdCdzIGZ1bGx5IFVSSSBlbmNvZGVkOyBhbnkgJyUncyB0aGF0IGFyZSBlbmNvZGVkIGFyZVxuXHRcdFx0XHQvLyBjb252ZXJ0ZWQgYmFjayBpbnRvICclJ3Ncblx0XHRcdFx0dXJsID0gZW5jb2RlVVJJKHVybCkucmVwbGFjZSgvJTI1L2csIFwiJVwiKTtcblxuXHRcdFx0XHQvLyBDaGVjayB0aGUgU3RhdGVcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmdldEhhc2hCeVVybCh1cmwpICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSGlzdG9yeS5qcyBkb2VzIG5vdCBzdXBwb3J0IHN0YXRlcyB3aXRoIGZyYWdtZW50LWlkZW50aWZpZXJzIChoYXNoZXMvYW5jaG9ycykuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdFx0aWYgKCBxdWV1ZSAhPT0gZmFsc2UgJiYgSGlzdG9yeS5idXN5KCkgKSB7XG5cdFx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucmVwbGFjZVN0YXRlOiB3ZSBtdXN0IHdhaXQnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2s6IEhpc3RvcnkucmVwbGFjZVN0YXRlLFxuXHRcdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0cXVldWU6IHF1ZXVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFrZSBCdXN5XG5cdFx0XHRcdEhpc3RvcnkuYnVzeSh0cnVlKTtcblxuXHRcdFx0XHQvLyBGZXRjaCB0aGUgU3RhdGUgT2JqZWN0c1xuXHRcdFx0XHR2YXIgbmV3U3RhdGUgICAgICAgID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChkYXRhLHRpdGxlLHVybCksXG5cdFx0XHRcdFx0bmV3U3RhdGVIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShuZXdTdGF0ZSksXG5cdFx0XHRcdFx0b2xkU3RhdGUgICAgICAgID0gSGlzdG9yeS5nZXRTdGF0ZShmYWxzZSksXG5cdFx0XHRcdFx0b2xkU3RhdGVIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShvbGRTdGF0ZSksXG5cdFx0XHRcdFx0cHJldmlvdXNTdGF0ZSAgID0gSGlzdG9yeS5nZXRTdGF0ZUJ5SW5kZXgoLTIpO1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgT2xkIFN0YXRlXG5cdFx0XHRcdEhpc3RvcnkuZGlzY2FyZFN0YXRlKG9sZFN0YXRlLG5ld1N0YXRlLHByZXZpb3VzU3RhdGUpO1xuXG5cdFx0XHRcdC8vIElmIHRoZSB1cmwgaGFzbid0IGNoYW5nZWQsIGp1c3Qgc3RvcmUgYW5kIHNhdmUgdGhlIHN0YXRlXG5cdFx0XHRcdC8vIGFuZCBmaXJlIGEgc3RhdGVjaGFuZ2UgZXZlbnQgdG8gYmUgY29uc2lzdGVudCB3aXRoIHRoZVxuXHRcdFx0XHQvLyBodG1sIDUgYXBpXG5cdFx0XHRcdGlmICggbmV3U3RhdGVIYXNoID09PSBvbGRTdGF0ZUhhc2ggKSB7XG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIG5ld1N0YXRlXG5cdFx0XHRcdFx0SGlzdG9yeS5zdG9yZVN0YXRlKG5ld1N0YXRlKTtcblx0XHRcdFx0XHRIaXN0b3J5LmV4cGVjdGVkU3RhdGVJZCA9IG5ld1N0YXRlLmlkO1xuXHRcblx0XHRcdFx0XHQvLyBSZWN5Y2xlIHRoZSBTdGF0ZVxuXHRcdFx0XHRcdEhpc3RvcnkucmVjeWNsZVN0YXRlKG5ld1N0YXRlKTtcblx0XG5cdFx0XHRcdFx0Ly8gRm9yY2UgdXBkYXRlIG9mIHRoZSB0aXRsZVxuXHRcdFx0XHRcdEhpc3Rvcnkuc2V0VGl0bGUobmV3U3RhdGUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFVwZGF0ZSBIVE1MNSBTdGF0ZVxuXHRcdFx0XHRcdEhpc3Rvcnkuc2F2ZVN0YXRlKG5ld1N0YXRlKTtcblxuXHRcdFx0XHRcdC8vIEZpcmUgSFRNTDUgRXZlbnRcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiB0cmlnZ2VyIHBvcHN0YXRlJyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdzdGF0ZWNoYW5nZScpO1xuXHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQWxpYXMgdG8gUHVzaFN0YXRlXG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUobmV3U3RhdGUuZGF0YSxuZXdTdGF0ZS50aXRsZSxuZXdTdGF0ZS51cmwsZmFsc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRW5kIHJlcGxhY2VTdGF0ZSBjbG9zdXJlXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTtcblxuXHRcdH0gLy8gSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGVcblxuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEluaXRpYWxpc2VcblxuXHRcdC8vIE5vbi1OYXRpdmUgcHVzaFN0YXRlIEltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogRW5zdXJlIGluaXRpYWwgc3RhdGUgaXMgaGFuZGxlZCBjb3JyZWN0bHlcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBIaXN0b3J5LmdldEhhc2goKSAmJiAhSGlzdG9yeS5lbXVsYXRlZC5oYXNoQ2hhbmdlICkge1xuXHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIub25Eb21Mb2FkKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdoYXNoY2hhbmdlJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0fSAvLyBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZVxuXG5cdH07IC8vIEhpc3RvcnkuaW5pdEh0bWw0XG5cblx0Ly8gVHJ5IHRvIEluaXRpYWxpc2UgSGlzdG9yeVxuXHRpZiAoIHR5cGVvZiBIaXN0b3J5LmluaXQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdEhpc3RvcnkuaW5pdCgpO1xuXHR9XG5cbn0pKHdpbmRvdyk7XG4vKipcbiAqIEhpc3RvcnkuanMgQ29yZVxuICogQGF1dGhvciBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cbiAqIEBjb3B5cmlnaHQgMjAxMC0yMDExIEJlbmphbWluIEFydGh1ciBMdXB0b24gPGNvbnRhY3RAYmFsdXB0b24uY29tPlxuICogQGxpY2Vuc2UgTmV3IEJTRCBMaWNlbnNlIDxodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9CU0QvPlxuICovXG5cbihmdW5jdGlvbih3aW5kb3csdW5kZWZpbmVkKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdC8vIEluaXRpYWxpc2VcblxuXHQvLyBMb2NhbGlzZSBHbG9iYWxzXG5cdHZhclxuXHRcdGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZXx8dW5kZWZpbmVkLCAvLyBQcmV2ZW50IGEgSlNMaW50IGNvbXBsYWluXG5cdFx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgdXNpbmcgdGhlIGNvcnJlY3QgZG9jdW1lbnRcblx0XHRuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLCAvLyBNYWtlIHN1cmUgd2UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IG5hdmlnYXRvclxuXHRcdHNlc3Npb25TdG9yYWdlID0gZmFsc2UsIC8vIHNlc3Npb25TdG9yYWdlXG5cdFx0c2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0LFxuXHRcdGNsZWFyVGltZW91dCA9IHdpbmRvdy5jbGVhclRpbWVvdXQsXG5cdFx0c2V0SW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwsXG5cdFx0Y2xlYXJJbnRlcnZhbCA9IHdpbmRvdy5jbGVhckludGVydmFsLFxuXHRcdEpTT04gPSB3aW5kb3cuSlNPTixcblx0XHRhbGVydCA9IHdpbmRvdy5hbGVydCxcblx0XHRIaXN0b3J5ID0gd2luZG93Lkhpc3RvcnkgPSB3aW5kb3cuSGlzdG9yeXx8e30sIC8vIFB1YmxpYyBIaXN0b3J5IE9iamVjdFxuXHRcdGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTsgLy8gT2xkIEhpc3RvcnkgT2JqZWN0XG5cblx0dHJ5IHtcblx0XHRzZXNzaW9uU3RvcmFnZSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZTsgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpbiBzb21lIGJyb3dzZXJzIHdoZW4gY29va2llcy9sb2NhbFN0b3JhZ2UgYXJlIGV4cGxpY2l0bHkgZGlzYWJsZWQgKGkuZS4gQ2hyb21lKVxuXHRcdHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ1RFU1QnLCAnMScpO1xuXHRcdHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ1RFU1QnKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0c2Vzc2lvblN0b3JhZ2UgPSBmYWxzZTtcblx0fVxuXG5cdC8vIE1vb1Rvb2xzIENvbXBhdGliaWxpdHlcblx0SlNPTi5zdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeXx8SlNPTi5lbmNvZGU7XG5cdEpTT04ucGFyc2UgPSBKU09OLnBhcnNlfHxKU09OLmRlY29kZTtcblxuXHQvLyBDaGVjayBFeGlzdGVuY2Vcblx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgQ29yZSBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZC4uLicpO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGlzZSBIaXN0b3J5XG5cdEhpc3RvcnkuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHRcdC8vIENoZWNrIExvYWQgU3RhdHVzIG9mIEFkYXB0ZXJcblx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LkFkYXB0ZXIgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIExvYWQgU3RhdHVzIG9mIENvcmVcblx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LmluaXRDb3JlICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdEhpc3RvcnkuaW5pdENvcmUoKTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBMb2FkIFN0YXR1cyBvZiBIVE1MNCBTdXBwb3J0XG5cdFx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0SHRtbDQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0SGlzdG9yeS5pbml0SHRtbDQoKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdC8vIEluaXRpYWxpc2UgQ29yZVxuXG5cdC8vIEluaXRpYWxpc2UgQ29yZVxuXHRIaXN0b3J5LmluaXRDb3JlID0gZnVuY3Rpb24ob3B0aW9ucyl7XG5cdFx0Ly8gSW5pdGlhbGlzZVxuXHRcdGlmICggdHlwZW9mIEhpc3RvcnkuaW5pdENvcmUuaW5pdGlhbGl6ZWQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0Ly8gQWxyZWFkeSBMb2FkZWRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRIaXN0b3J5LmluaXRDb3JlLmluaXRpYWxpemVkID0gdHJ1ZTtcblx0XHR9XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gT3B0aW9uc1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zXG5cdFx0ICogQ29uZmlndXJhYmxlIG9wdGlvbnNcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMgPSBIaXN0b3J5Lm9wdGlvbnN8fHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmhhc2hDaGFuZ2VJbnRlcnZhbFxuXHRcdCAqIEhvdyBsb25nIHNob3VsZCB0aGUgaW50ZXJ2YWwgYmUgYmVmb3JlIGhhc2hjaGFuZ2UgY2hlY2tzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmhhc2hDaGFuZ2VJbnRlcnZhbCA9IEhpc3Rvcnkub3B0aW9ucy5oYXNoQ2hhbmdlSW50ZXJ2YWwgfHwgMTAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLnNhZmFyaVBvbGxJbnRlcnZhbFxuXHRcdCAqIEhvdyBsb25nIHNob3VsZCB0aGUgaW50ZXJ2YWwgYmUgYmVmb3JlIHNhZmFyaSBwb2xsIGNoZWNrc1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5zYWZhcmlQb2xsSW50ZXJ2YWwgPSBIaXN0b3J5Lm9wdGlvbnMuc2FmYXJpUG9sbEludGVydmFsIHx8IDUwMDtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5kb3VibGVDaGVja0ludGVydmFsXG5cdFx0ICogSG93IGxvbmcgc2hvdWxkIHRoZSBpbnRlcnZhbCBiZSBiZWZvcmUgd2UgcGVyZm9ybSBhIGRvdWJsZSBjaGVja1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5kb3VibGVDaGVja0ludGVydmFsID0gSGlzdG9yeS5vcHRpb25zLmRvdWJsZUNoZWNrSW50ZXJ2YWwgfHwgNTAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmRpc2FibGVTdWlkXG5cdFx0ICogRm9yY2UgSGlzdG9yeSBub3QgdG8gYXBwZW5kIHN1aWRcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuZGlzYWJsZVN1aWQgPSBIaXN0b3J5Lm9wdGlvbnMuZGlzYWJsZVN1aWQgfHwgZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuc3RvcmVJbnRlcnZhbFxuXHRcdCAqIEhvdyBsb25nIHNob3VsZCB3ZSB3YWl0IGJldHdlZW4gc3RvcmUgY2FsbHNcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuc3RvcmVJbnRlcnZhbCA9IEhpc3Rvcnkub3B0aW9ucy5zdG9yZUludGVydmFsIHx8IDEwMDA7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuYnVzeURlbGF5XG5cdFx0ICogSG93IGxvbmcgc2hvdWxkIHdlIHdhaXQgYmV0d2VlbiBidXN5IGV2ZW50c1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXkgPSBIaXN0b3J5Lm9wdGlvbnMuYnVzeURlbGF5IHx8IDI1MDtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5kZWJ1Z1xuXHRcdCAqIElmIHRydWUgd2lsbCBlbmFibGUgZGVidWcgbWVzc2FnZXMgdG8gYmUgbG9nZ2VkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmRlYnVnID0gSGlzdG9yeS5vcHRpb25zLmRlYnVnIHx8IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmluaXRpYWxUaXRsZVxuXHRcdCAqIFdoYXQgaXMgdGhlIHRpdGxlIG9mIHRoZSBpbml0aWFsIHN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmluaXRpYWxUaXRsZSA9IEhpc3Rvcnkub3B0aW9ucy5pbml0aWFsVGl0bGUgfHwgZG9jdW1lbnQudGl0bGU7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuaHRtbDRNb2RlXG5cdFx0ICogSWYgdHJ1ZSwgd2lsbCBmb3JjZSBIVE1sNCBtb2RlIChoYXNodGFncylcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuaHRtbDRNb2RlID0gSGlzdG9yeS5vcHRpb25zLmh0bWw0TW9kZSB8fCBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5kZWxheUluaXRcblx0XHQgKiBXYW50IHRvIG92ZXJyaWRlIGRlZmF1bHQgb3B0aW9ucyBhbmQgY2FsbCBpbml0IG1hbnVhbGx5LlxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5kZWxheUluaXQgPSBIaXN0b3J5Lm9wdGlvbnMuZGVsYXlJbml0IHx8IGZhbHNlO1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEludGVydmFsIHJlY29yZFxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5pbnRlcnZhbExpc3Rcblx0XHQgKiBMaXN0IG9mIGludGVydmFscyBzZXQsIHRvIGJlIGNsZWFyZWQgd2hlbiBkb2N1bWVudCBpcyB1bmxvYWRlZC5cblx0XHQgKi9cblx0XHRIaXN0b3J5LmludGVydmFsTGlzdCA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5jbGVhckFsbEludGVydmFsc1xuXHRcdCAqIENsZWFycyBhbGwgc2V0SW50ZXJ2YWwgaW5zdGFuY2VzLlxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuY2xlYXJBbGxJbnRlcnZhbHMgPSBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGksIGlsID0gSGlzdG9yeS5pbnRlcnZhbExpc3Q7XG5cdFx0XHRpZiAodHlwZW9mIGlsICE9PSBcInVuZGVmaW5lZFwiICYmIGlsICE9PSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBpbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwoaWxbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdEhpc3RvcnkuaW50ZXJ2YWxMaXN0ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIERlYnVnXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRlYnVnKG1lc3NhZ2UsLi4uKVxuXHRcdCAqIExvZ3MgdGhlIHBhc3NlZCBhcmd1bWVudHMgaWYgZGVidWcgZW5hYmxlZFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZGVidWcgPSBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCAoSGlzdG9yeS5vcHRpb25zLmRlYnVnfHxmYWxzZSkgKSB7XG5cdFx0XHRcdEhpc3RvcnkubG9nLmFwcGx5KEhpc3RvcnksYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5sb2cobWVzc2FnZSwuLi4pXG5cdFx0ICogTG9ncyB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkubG9nID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhclxuXHRcdFx0XHRjb25zb2xlRXhpc3RzID0gISh0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGNvbnNvbGUubG9nID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgY29uc29sZS5sb2cuYXBwbHkgPT09ICd1bmRlZmluZWQnKSxcblx0XHRcdFx0dGV4dGFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nJyksXG5cdFx0XHRcdG1lc3NhZ2UsXG5cdFx0XHRcdGksbixcblx0XHRcdFx0YXJncyxhcmdcblx0XHRcdFx0O1xuXG5cdFx0XHQvLyBXcml0ZSB0byBDb25zb2xlXG5cdFx0XHRpZiAoIGNvbnNvbGVFeGlzdHMgKSB7XG5cdFx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHRtZXNzYWdlID0gYXJncy5zaGlmdCgpO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBjb25zb2xlLmRlYnVnICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnLmFwcGx5KGNvbnNvbGUsW21lc3NhZ2UsYXJnc10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsW21lc3NhZ2UsYXJnc10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bWVzc2FnZSA9IChcIlxcblwiK2FyZ3VtZW50c1swXStcIlxcblwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV3JpdGUgdG8gbG9nXG5cdFx0XHRmb3IgKCBpPTEsbj1hcmd1bWVudHMubGVuZ3RoOyBpPG47ICsraSApIHtcblx0XHRcdFx0YXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0YXJnID0gSlNPTi5zdHJpbmdpZnkoYXJnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKCBFeGNlcHRpb24gKSB7XG5cdFx0XHRcdFx0XHQvLyBSZWN1cnNpdmUgT2JqZWN0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG1lc3NhZ2UgKz0gXCJcXG5cIithcmcrXCJcXG5cIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGV4dGFyZWFcblx0XHRcdGlmICggdGV4dGFyZWEgKSB7XG5cdFx0XHRcdHRleHRhcmVhLnZhbHVlICs9IG1lc3NhZ2UrXCJcXG4tLS0tLVxcblwiO1xuXHRcdFx0XHR0ZXh0YXJlYS5zY3JvbGxUb3AgPSB0ZXh0YXJlYS5zY3JvbGxIZWlnaHQgLSB0ZXh0YXJlYS5jbGllbnRIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBObyBUZXh0YXJlYSwgTm8gQ29uc29sZVxuXHRcdFx0ZWxzZSBpZiAoICFjb25zb2xlRXhpc3RzICkge1xuXHRcdFx0XHRhbGVydChtZXNzYWdlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gRW11bGF0ZWQgU3RhdHVzXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24oKVxuXHRcdCAqIEdldCdzIHRoZSBtYWpvciB2ZXJzaW9uIG9mIEludGVybmV0IEV4cGxvcmVyXG5cdFx0ICogQHJldHVybiB7aW50ZWdlcn1cblx0XHQgKiBAbGljZW5zZSBQdWJsaWMgRG9tYWluXG5cdFx0ICogQGF1dGhvciBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cblx0XHQgKiBAYXV0aG9yIEphbWVzIFBhZG9sc2V5IDxodHRwczovL2dpc3QuZ2l0aHViLmNvbS81Mjc2ODM+XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciByZXN1bHQgPSBIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24uY2FjaGVkID1cblx0XHRcdFx0XHQodHlwZW9mIEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbi5jYWNoZWQgIT09ICd1bmRlZmluZWQnKVxuXHRcdFx0XHQ/XHRIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24uY2FjaGVkXG5cdFx0XHRcdDpcdChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0dmFyIHYgPSAzLFxuXHRcdFx0XHRcdFx0XHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdFx0XHRcdFx0XHRcdGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCAoZGl2LmlubmVySFRNTCA9ICc8IS0tW2lmIGd0IElFICcgKyAoKyt2KSArICddPjxpPjwvaT48IVtlbmRpZl0tLT4nKSAmJiBhbGxbMF0gKSB7fVxuXHRcdFx0XHRcdFx0cmV0dXJuICh2ID4gNCkgPyB2IDogZmFsc2U7XG5cdFx0XHRcdFx0fSkoKVxuXHRcdFx0XHQ7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3JlcigpXG5cdFx0ICogQXJlIHdlIHVzaW5nIEludGVybmV0IEV4cGxvcmVyP1xuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0ICogQGxpY2Vuc2UgUHVibGljIERvbWFpblxuXHRcdCAqIEBhdXRob3IgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHJlc3VsdCA9XG5cdFx0XHRcdEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyLmNhY2hlZCA9XG5cdFx0XHRcdCh0eXBlb2YgSGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIuY2FjaGVkICE9PSAndW5kZWZpbmVkJylcblx0XHRcdFx0XHQ/XHRIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3Jlci5jYWNoZWRcblx0XHRcdFx0XHQ6XHRCb29sZWFuKEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbigpKVxuXHRcdFx0XHQ7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmVtdWxhdGVkXG5cdFx0ICogV2hpY2ggZmVhdHVyZXMgcmVxdWlyZSBlbXVsYXRpbmc/XG5cdFx0ICovXG5cblx0XHRpZiAoSGlzdG9yeS5vcHRpb25zLmh0bWw0TW9kZSkge1xuXHRcdFx0SGlzdG9yeS5lbXVsYXRlZCA9IHtcblx0XHRcdFx0cHVzaFN0YXRlIDogdHJ1ZSxcblx0XHRcdFx0aGFzaENoYW5nZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRlbHNlIHtcblxuXHRcdFx0SGlzdG9yeS5lbXVsYXRlZCA9IHtcblx0XHRcdFx0cHVzaFN0YXRlOiAhQm9vbGVhbihcblx0XHRcdFx0XHR3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgJiYgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlXG5cdFx0XHRcdFx0JiYgIShcblx0XHRcdFx0XHRcdCgvIE1vYmlsZVxcLyhbMS03XVthLXpdfCg4KFthYmNkZV18ZigxWzAtOF0pKSkpL2kpLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgLyogZGlzYWJsZSBmb3IgdmVyc2lvbnMgb2YgaU9TIGJlZm9yZSB2ZXJzaW9uIDQuMyAoOEYxOTApICovXG5cdFx0XHRcdFx0XHR8fCAoL0FwcGxlV2ViS2l0XFwvNShbMC0yXXwzWzAtMl0pL2kpLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgLyogZGlzYWJsZSBmb3IgdGhlIG1lcmN1cnkgaU9TIGJyb3dzZXIsIG9yIGF0IGxlYXN0IG9sZGVyIHZlcnNpb25zIG9mIHRoZSB3ZWJraXQgZW5naW5lICovXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpLFxuXHRcdFx0XHRoYXNoQ2hhbmdlOiBCb29sZWFuKFxuXHRcdFx0XHRcdCEoKCdvbmhhc2hjaGFuZ2UnIGluIHdpbmRvdykgfHwgKCdvbmhhc2hjaGFuZ2UnIGluIGRvY3VtZW50KSlcblx0XHRcdFx0XHR8fFxuXHRcdFx0XHRcdChIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3JlcigpICYmIEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbigpIDwgOClcblx0XHRcdFx0KVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmVuYWJsZWRcblx0XHQgKiBJcyBIaXN0b3J5IGVuYWJsZWQ/XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5lbmFibGVkID0gIUhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5idWdzXG5cdFx0ICogV2hpY2ggYnVncyBhcmUgcHJlc2VudFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuYnVncyA9IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogU2FmYXJpIDUgYW5kIFNhZmFyaSBpT1MgNCBmYWlsIHRvIHJldHVybiB0byB0aGUgY29ycmVjdCBzdGF0ZSBvbmNlIGEgaGFzaCBpcyByZXBsYWNlZCBieSBhIGByZXBsYWNlU3RhdGVgIGNhbGxcblx0XHRcdCAqIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD01NjI0OVxuXHRcdFx0ICovXG5cdFx0XHRzZXRIYXNoOiBCb29sZWFuKCFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSAmJiBuYXZpZ2F0b3IudmVuZG9yID09PSAnQXBwbGUgQ29tcHV0ZXIsIEluYy4nICYmIC9BcHBsZVdlYktpdFxcLzUoWzAtMl18M1swLTNdKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSksXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2FmYXJpIDUgYW5kIFNhZmFyaSBpT1MgNCBzb21ldGltZXMgZmFpbCB0byBhcHBseSB0aGUgc3RhdGUgY2hhbmdlIHVuZGVyIGJ1c3kgY29uZGl0aW9uc1xuXHRcdFx0ICogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQyOTQwXG5cdFx0XHQgKi9cblx0XHRcdHNhZmFyaVBvbGw6IEJvb2xlYW4oIUhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICYmIG5hdmlnYXRvci52ZW5kb3IgPT09ICdBcHBsZSBDb21wdXRlciwgSW5jLicgJiYgL0FwcGxlV2ViS2l0XFwvNShbMC0yXXwzWzAtM10pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNU0lFIDYgYW5kIDcgc29tZXRpbWVzIGRvIG5vdCBhcHBseSBhIGhhc2ggZXZlbiBpdCB3YXMgdG9sZCB0byAocmVxdWlyaW5nIGEgc2Vjb25kIGNhbGwgdG8gdGhlIGFwcGx5IGZ1bmN0aW9uKVxuXHRcdFx0ICovXG5cdFx0XHRpZURvdWJsZUNoZWNrOiBCb29sZWFuKEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyKCkgJiYgSGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uKCkgPCA4KSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNU0lFIDYgcmVxdWlyZXMgdGhlIGVudGlyZSBoYXNoIHRvIGJlIGVuY29kZWQgZm9yIHRoZSBoYXNoZXMgdG8gdHJpZ2dlciB0aGUgb25IYXNoQ2hhbmdlIGV2ZW50XG5cdFx0XHQgKi9cblx0XHRcdGhhc2hFc2NhcGU6IEJvb2xlYW4oSGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIoKSAmJiBIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24oKSA8IDcpXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNFbXB0eU9iamVjdChvYmopXG5cdFx0ICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgT2JqZWN0IGlzIEVtcHR5XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggb2JqLmhhc093blByb3BlcnR5KG5hbWUpICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuY2xvbmVPYmplY3Qob2JqKVxuXHRcdCAqIENsb25lcyBhIG9iamVjdCBhbmQgZWxpbWluYXRlIGFsbCByZWZlcmVuY2VzIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0c1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5jbG9uZU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0dmFyIGhhc2gsbmV3T2JqO1xuXHRcdFx0aWYgKCBvYmogKSB7XG5cdFx0XHRcdGhhc2ggPSBKU09OLnN0cmluZ2lmeShvYmopO1xuXHRcdFx0XHRuZXdPYmogPSBKU09OLnBhcnNlKGhhc2gpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG5ld09iaiA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ld09iajtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFVSTCBIZWxwZXJzXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFJvb3RVcmwoKVxuXHRcdCAqIFR1cm5zIFwiaHR0cDovL215c2l0ZS5jb20vZGlyL3BhZ2UuaHRtbD9hc2RcIiBpbnRvIFwiaHR0cDovL215c2l0ZS5jb21cIlxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gcm9vdFVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0Um9vdFVybCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdHZhciByb290VXJsID0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wrJy8vJysoZG9jdW1lbnQubG9jYXRpb24uaG9zdG5hbWV8fGRvY3VtZW50LmxvY2F0aW9uLmhvc3QpO1xuXHRcdFx0aWYgKCBkb2N1bWVudC5sb2NhdGlvbi5wb3J0fHxmYWxzZSApIHtcblx0XHRcdFx0cm9vdFVybCArPSAnOicrZG9jdW1lbnQubG9jYXRpb24ucG9ydDtcblx0XHRcdH1cblx0XHRcdHJvb3RVcmwgKz0gJy8nO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiByb290VXJsO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEJhc2VIcmVmKClcblx0XHQgKiBGZXRjaGVzIHRoZSBgaHJlZmAgYXR0cmlidXRlIG9mIHRoZSBgPGJhc2UgaHJlZj1cIi4uLlwiPmAgZWxlbWVudCBpZiBpdCBleGlzdHNcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2VIcmVmXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRCYXNlSHJlZiA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdHZhclxuXHRcdFx0XHRiYXNlRWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpLFxuXHRcdFx0XHRiYXNlRWxlbWVudCA9IG51bGwsXG5cdFx0XHRcdGJhc2VIcmVmID0gJyc7XG5cblx0XHRcdC8vIFRlc3QgZm9yIEJhc2UgRWxlbWVudFxuXHRcdFx0aWYgKCBiYXNlRWxlbWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHQvLyBQcmVwYXJlIGZvciBCYXNlIEVsZW1lbnRcblx0XHRcdFx0YmFzZUVsZW1lbnQgPSBiYXNlRWxlbWVudHNbMF07XG5cdFx0XHRcdGJhc2VIcmVmID0gYmFzZUVsZW1lbnQuaHJlZi5yZXBsYWNlKC9bXlxcL10rJC8sJycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGp1c3QgdHJhaWxpbmcgc2xhc2hcblx0XHRcdGJhc2VIcmVmID0gYmFzZUhyZWYucmVwbGFjZSgvXFwvKyQvLCcnKTtcblx0XHRcdGlmICggYmFzZUhyZWYgKSBiYXNlSHJlZiArPSAnLyc7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGJhc2VIcmVmO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEJhc2VVcmwoKVxuXHRcdCAqIEZldGNoZXMgdGhlIGJhc2VIcmVmIG9yIGJhc2VQYWdlVXJsIG9yIHJvb3RVcmwgKHdoaWNoZXZlciBvbmUgZXhpc3RzIGZpcnN0KVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gYmFzZVVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0QmFzZVVybCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdHZhciBiYXNlVXJsID0gSGlzdG9yeS5nZXRCYXNlSHJlZigpfHxIaXN0b3J5LmdldEJhc2VQYWdlVXJsKCl8fEhpc3RvcnkuZ2V0Um9vdFVybCgpO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBiYXNlVXJsO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFBhZ2VVcmwoKVxuXHRcdCAqIEZldGNoZXMgdGhlIFVSTCBvZiB0aGUgY3VycmVudCBwYWdlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBwYWdlVXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRQYWdlVXJsID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIEZldGNoXG5cdFx0XHR2YXJcblx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlKGZhbHNlLGZhbHNlKSxcblx0XHRcdFx0c3RhdGVVcmwgPSAoU3RhdGV8fHt9KS51cmx8fEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCksXG5cdFx0XHRcdHBhZ2VVcmw7XG5cblx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0cGFnZVVybCA9IHN0YXRlVXJsLnJlcGxhY2UoL1xcLyskLywnJykucmVwbGFjZSgvW15cXC9dKyQvLGZ1bmN0aW9uKHBhcnQsaW5kZXgsc3RyaW5nKXtcblx0XHRcdFx0cmV0dXJuICgvXFwuLykudGVzdChwYXJ0KSA/IHBhcnQgOiBwYXJ0KycvJztcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBwYWdlVXJsO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEJhc2VQYWdlVXJsKClcblx0XHQgKiBGZXRjaGVzIHRoZSBVcmwgb2YgdGhlIGRpcmVjdG9yeSBvZiB0aGUgY3VycmVudCBwYWdlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBiYXNlUGFnZVVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0QmFzZVBhZ2VVcmwgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ3JlYXRlXG5cdFx0XHR2YXIgYmFzZVBhZ2VVcmwgPSAoSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSkucmVwbGFjZSgvWyNcXD9dLiovLCcnKS5yZXBsYWNlKC9bXlxcL10rJC8sZnVuY3Rpb24ocGFydCxpbmRleCxzdHJpbmcpe1xuXHRcdFx0XHRyZXR1cm4gKC9bXlxcL10kLykudGVzdChwYXJ0KSA/ICcnIDogcGFydDtcblx0XHRcdH0pLnJlcGxhY2UoL1xcLyskLywnJykrJy8nO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBiYXNlUGFnZVVybDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRGdWxsVXJsKHVybClcblx0XHQgKiBFbnN1cmVzIHRoYXQgd2UgaGF2ZSBhbiBhYnNvbHV0ZSBVUkwgYW5kIG5vdCBhIHJlbGF0aXZlIFVSTFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93QmFzZUhyZWZcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IGZ1bGxVcmxcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldEZ1bGxVcmwgPSBmdW5jdGlvbih1cmwsYWxsb3dCYXNlSHJlZil7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgZnVsbFVybCA9IHVybCwgZmlyc3RDaGFyID0gdXJsLnN1YnN0cmluZygwLDEpO1xuXHRcdFx0YWxsb3dCYXNlSHJlZiA9ICh0eXBlb2YgYWxsb3dCYXNlSHJlZiA9PT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IGFsbG93QmFzZUhyZWY7XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRpZiAoIC9bYS16XStcXDpcXC9cXC8vLnRlc3QodXJsKSApIHtcblx0XHRcdFx0Ly8gRnVsbCBVUkxcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBmaXJzdENoYXIgPT09ICcvJyApIHtcblx0XHRcdFx0Ly8gUm9vdCBVUkxcblx0XHRcdFx0ZnVsbFVybCA9IEhpc3RvcnkuZ2V0Um9vdFVybCgpK3VybC5yZXBsYWNlKC9eXFwvKy8sJycpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGZpcnN0Q2hhciA9PT0gJyMnICkge1xuXHRcdFx0XHQvLyBBbmNob3IgVVJMXG5cdFx0XHRcdGZ1bGxVcmwgPSBIaXN0b3J5LmdldFBhZ2VVcmwoKS5yZXBsYWNlKC8jLiovLCcnKSt1cmw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggZmlyc3RDaGFyID09PSAnPycgKSB7XG5cdFx0XHRcdC8vIFF1ZXJ5IFVSTFxuXHRcdFx0XHRmdWxsVXJsID0gSGlzdG9yeS5nZXRQYWdlVXJsKCkucmVwbGFjZSgvW1xcPyNdLiovLCcnKSt1cmw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gUmVsYXRpdmUgVVJMXG5cdFx0XHRcdGlmICggYWxsb3dCYXNlSHJlZiApIHtcblx0XHRcdFx0XHRmdWxsVXJsID0gSGlzdG9yeS5nZXRCYXNlVXJsKCkrdXJsLnJlcGxhY2UoL14oXFwuXFwvKSsvLCcnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmdWxsVXJsID0gSGlzdG9yeS5nZXRCYXNlUGFnZVVybCgpK3VybC5yZXBsYWNlKC9eKFxcLlxcLykrLywnJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gV2UgaGF2ZSBhbiBpZiBjb25kaXRpb24gYWJvdmUgYXMgd2UgZG8gbm90IHdhbnQgaGFzaGVzXG5cdFx0XHRcdC8vIHdoaWNoIGFyZSByZWxhdGl2ZSB0byB0aGUgYmFzZUhyZWYgaW4gb3VyIFVSTHNcblx0XHRcdFx0Ly8gYXMgaWYgdGhlIGJhc2VIcmVmIGNoYW5nZXMsIHRoZW4gYWxsIG91ciBib29rbWFya3Ncblx0XHRcdFx0Ly8gd291bGQgbm93IHBvaW50IHRvIGRpZmZlcmVudCBsb2NhdGlvbnNcblx0XHRcdFx0Ly8gd2hlcmVhcyB0aGUgYmFzZVBhZ2VVcmwgd2lsbCBhbHdheXMgc3RheSB0aGUgc2FtZVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBmdWxsVXJsLnJlcGxhY2UoL1xcIyQvLCcnKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRTaG9ydFVybCh1cmwpXG5cdFx0ICogRW5zdXJlcyB0aGF0IHdlIGhhdmUgYSByZWxhdGl2ZSBVUkwgYW5kIG5vdCBhIGFic29sdXRlIFVSTFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0U2hvcnRVcmwgPSBmdW5jdGlvbih1cmwpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIHNob3J0VXJsID0gdXJsLCBiYXNlVXJsID0gSGlzdG9yeS5nZXRCYXNlVXJsKCksIHJvb3RVcmwgPSBIaXN0b3J5LmdldFJvb3RVcmwoKTtcblxuXHRcdFx0Ly8gVHJpbSBiYXNlVXJsXG5cdFx0XHRpZiAoIEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICkge1xuXHRcdFx0XHQvLyBXZSBhcmUgaW4gYSBpZiBzdGF0ZW1lbnQgYXMgd2hlbiBwdXNoU3RhdGUgaXMgbm90IGVtdWxhdGVkXG5cdFx0XHRcdC8vIFRoZSBhY3R1YWwgdXJsIHRoZXNlIHNob3J0IHVybHMgYXJlIHJlbGF0aXZlIHRvIGNhbiBjaGFuZ2Vcblx0XHRcdFx0Ly8gU28gd2l0aGluIHRoZSBzYW1lIHNlc3Npb24sIHdlIHRoZSB1cmwgbWF5IGVuZCB1cCBzb21ld2hlcmUgZGlmZmVyZW50XG5cdFx0XHRcdHNob3J0VXJsID0gc2hvcnRVcmwucmVwbGFjZShiYXNlVXJsLCcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJpbSByb290VXJsXG5cdFx0XHRzaG9ydFVybCA9IHNob3J0VXJsLnJlcGxhY2Uocm9vdFVybCwnLycpO1xuXG5cdFx0XHQvLyBFbnN1cmUgd2UgY2FuIHN0aWxsIGRldGVjdCBpdCBhcyBhIHN0YXRlXG5cdFx0XHRpZiAoIEhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvcihzaG9ydFVybCkgKSB7XG5cdFx0XHRcdHNob3J0VXJsID0gJy4vJytzaG9ydFVybDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYW4gSXRcblx0XHRcdHNob3J0VXJsID0gc2hvcnRVcmwucmVwbGFjZSgvXihcXC5cXC8pKy9nLCcuLycpLnJlcGxhY2UoL1xcIyQvLCcnKTtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gc2hvcnRVcmw7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKGRvY3VtZW50KVxuXHRcdCAqIFJldHVybnMgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgZG9jdW1lbnQubG9jYXRpb24uaHJlZlxuXHRcdCAqIGFjY291bnRpbmcgZm9yIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzLCBldGMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIFVSTCB3aWxsIGJlIFVSSS1lbmNvZGVkIGFuZCB3aWxsIGluY2x1ZGUgdGhlIGhhc2hcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkb2N1bWVudFxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gdXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYgPSBmdW5jdGlvbihkb2MpIHtcblx0XHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdFx0Ly8gbW9zdCBvZiB0aGUgdGltZSwgdGhpcyB3aWxsIGJlIHRydWVcblx0XHRcdGlmIChkb2MuVVJMID09PSBkb2MubG9jYXRpb24uaHJlZilcblx0XHRcdFx0cmV0dXJuIGRvYy5sb2NhdGlvbi5ocmVmO1xuXG5cdFx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHdlYmtpdCBVUkktZGVjb2RlIGRvY3VtZW50LmxvY2F0aW9uLmhyZWZcblx0XHRcdC8vIGJ1dCB0aGV5IGxlYXZlIGRvY3VtZW50LlVSTCBpbiBhbiBlbmNvZGVkIHN0YXRlXG5cdFx0XHRpZiAoZG9jLmxvY2F0aW9uLmhyZWYgPT09IGRlY29kZVVSSUNvbXBvbmVudChkb2MuVVJMKSlcblx0XHRcdFx0cmV0dXJuIGRvYy5VUkw7XG5cblx0XHRcdC8vIEZGIDMuNiBvbmx5IHVwZGF0ZXMgZG9jdW1lbnQuVVJMIHdoZW4gYSBwYWdlIGlzIHJlbG9hZGVkXG5cdFx0XHQvLyBkb2N1bWVudC5sb2NhdGlvbi5ocmVmIGlzIHVwZGF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoZG9jLmxvY2F0aW9uLmhhc2ggJiYgZGVjb2RlVVJJQ29tcG9uZW50KGRvYy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoL15bXiNdKy8sIFwiXCIpKSA9PT0gZG9jLmxvY2F0aW9uLmhhc2gpXG5cdFx0XHRcdHJldHVybiBkb2MubG9jYXRpb24uaHJlZjtcblxuXHRcdFx0aWYgKGRvYy5VUkwuaW5kZXhPZignIycpID09IC0xICYmIGRvYy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKSAhPSAtMSlcblx0XHRcdFx0cmV0dXJuIGRvYy5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZG9jLlVSTCB8fCBkb2MubG9jYXRpb24uaHJlZjtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFN0YXRlIFN0b3JhZ2VcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc3RvcmVcblx0XHQgKiBUaGUgc3RvcmUgZm9yIGFsbCBzZXNzaW9uIHNwZWNpZmljIGRhdGFcblx0XHQgKi9cblx0XHRIaXN0b3J5LnN0b3JlID0ge307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmlkVG9TdGF0ZVxuXHRcdCAqIDEtMTogU3RhdGUgSUQgdG8gU3RhdGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pZFRvU3RhdGUgPSBIaXN0b3J5LmlkVG9TdGF0ZXx8e307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnN0YXRlVG9JZFxuXHRcdCAqIDEtMTogU3RhdGUgU3RyaW5nIHRvIFN0YXRlIElEXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zdGF0ZVRvSWQgPSBIaXN0b3J5LnN0YXRlVG9JZHx8e307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnVybFRvSWRcblx0XHQgKiAxLTE6IFN0YXRlIFVSTCB0byBTdGF0ZSBJRFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkudXJsVG9JZCA9IEhpc3RvcnkudXJsVG9JZHx8e307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnN0b3JlZFN0YXRlc1xuXHRcdCAqIFN0b3JlIHRoZSBzdGF0ZXMgaW4gYW4gYXJyYXlcblx0XHQgKi9cblx0XHRIaXN0b3J5LnN0b3JlZFN0YXRlcyA9IEhpc3Rvcnkuc3RvcmVkU3RhdGVzfHxbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc2F2ZWRTdGF0ZXNcblx0XHQgKiBTYXZlZCB0aGUgc3RhdGVzIGluIGFuIGFycmF5XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlZFN0YXRlcyA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXN8fFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5ub3JhbWxpemVTdG9yZSgpXG5cdFx0ICogTm9yYW1saXplIHRoZSBzdG9yZSBieSBhZGRpbmcgbmVjZXNzYXJ5IHZhbHVlc1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUgPSBmdW5jdGlvbigpe1xuXHRcdFx0SGlzdG9yeS5zdG9yZS5pZFRvU3RhdGUgPSBIaXN0b3J5LnN0b3JlLmlkVG9TdGF0ZXx8e307XG5cdFx0XHRIaXN0b3J5LnN0b3JlLnVybFRvSWQgPSBIaXN0b3J5LnN0b3JlLnVybFRvSWR8fHt9O1xuXHRcdFx0SGlzdG9yeS5zdG9yZS5zdGF0ZVRvSWQgPSBIaXN0b3J5LnN0b3JlLnN0YXRlVG9JZHx8e307XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0U3RhdGUoKVxuXHRcdCAqIEdldCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSwgdGl0bGUgYW5kIHVybCBvZiB0aGUgY3VycmVudCBzdGF0ZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZnJpZW5kbHlcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNyZWF0ZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gU3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldFN0YXRlID0gZnVuY3Rpb24oZnJpZW5kbHksY3JlYXRlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdGlmICggdHlwZW9mIGZyaWVuZGx5ID09PSAndW5kZWZpbmVkJyApIHsgZnJpZW5kbHkgPSB0cnVlOyB9XG5cdFx0XHRpZiAoIHR5cGVvZiBjcmVhdGUgPT09ICd1bmRlZmluZWQnICkgeyBjcmVhdGUgPSB0cnVlOyB9XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHR2YXIgU3RhdGUgPSBIaXN0b3J5LmdldExhc3RTYXZlZFN0YXRlKCk7XG5cblx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0aWYgKCAhU3RhdGUgJiYgY3JlYXRlICkge1xuXHRcdFx0XHRTdGF0ZSA9IEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRqdXN0XG5cdFx0XHRpZiAoIGZyaWVuZGx5ICkge1xuXHRcdFx0XHRTdGF0ZSA9IEhpc3RvcnkuY2xvbmVPYmplY3QoU3RhdGUpO1xuXHRcdFx0XHRTdGF0ZS51cmwgPSBTdGF0ZS5jbGVhblVybHx8U3RhdGUudXJsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBTdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRJZEJ5U3RhdGUoU3RhdGUpXG5cdFx0ICogR2V0cyBhIElEIGZvciBhIFN0YXRlXG5cdFx0ICogQHBhcmFtIHtTdGF0ZX0gbmV3U3RhdGVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRJZEJ5U3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cblx0XHRcdC8vIEZldGNoIElEXG5cdFx0XHR2YXIgaWQgPSBIaXN0b3J5LmV4dHJhY3RJZChuZXdTdGF0ZS51cmwpLFxuXHRcdFx0XHRzdHI7XG5cblx0XHRcdGlmICggIWlkICkge1xuXHRcdFx0XHQvLyBGaW5kIElEIHZpYSBTdGF0ZSBTdHJpbmdcblx0XHRcdFx0c3RyID0gSGlzdG9yeS5nZXRTdGF0ZVN0cmluZyhuZXdTdGF0ZSk7XG5cdFx0XHRcdGlmICggdHlwZW9mIEhpc3Rvcnkuc3RhdGVUb0lkW3N0cl0gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdGlkID0gSGlzdG9yeS5zdGF0ZVRvSWRbc3RyXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIEhpc3Rvcnkuc3RvcmUuc3RhdGVUb0lkW3N0cl0gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdGlkID0gSGlzdG9yeS5zdG9yZS5zdGF0ZVRvSWRbc3RyXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBHZW5lcmF0ZSBhIG5ldyBJRFxuXHRcdFx0XHRcdHdoaWxlICggdHJ1ZSApIHtcblx0XHRcdFx0XHRcdGlkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZywnJyk7XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LmlkVG9TdGF0ZVtpZF0gPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBIaXN0b3J5LnN0b3JlLmlkVG9TdGF0ZVtpZF0gPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBcHBseSB0aGUgbmV3IFN0YXRlIHRvIHRoZSBJRFxuXHRcdFx0XHRcdEhpc3Rvcnkuc3RhdGVUb0lkW3N0cl0gPSBpZDtcblx0XHRcdFx0XHRIaXN0b3J5LmlkVG9TdGF0ZVtpZF0gPSBuZXdTdGF0ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gSURcblx0XHRcdHJldHVybiBpZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5ub3JtYWxpemVTdGF0ZShTdGF0ZSlcblx0XHQgKiBFeHBhbmRzIGEgU3RhdGUgT2JqZWN0XG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFN0YXRlXG5cdFx0ICogQHJldHVybiB7b2JqZWN0fVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkubm9ybWFsaXplU3RhdGUgPSBmdW5jdGlvbihvbGRTdGF0ZSl7XG5cdFx0XHQvLyBWYXJpYWJsZXNcblx0XHRcdHZhciBuZXdTdGF0ZSwgZGF0YU5vdEVtcHR5O1xuXG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRpZiAoICFvbGRTdGF0ZSB8fCAodHlwZW9mIG9sZFN0YXRlICE9PSAnb2JqZWN0JykgKSB7XG5cdFx0XHRcdG9sZFN0YXRlID0ge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRpZiAoIHR5cGVvZiBvbGRTdGF0ZS5ub3JtYWxpemVkICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0cmV0dXJuIG9sZFN0YXRlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGp1c3Rcblx0XHRcdGlmICggIW9sZFN0YXRlLmRhdGEgfHwgKHR5cGVvZiBvbGRTdGF0ZS5kYXRhICE9PSAnb2JqZWN0JykgKSB7XG5cdFx0XHRcdG9sZFN0YXRlLmRhdGEgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdG5ld1N0YXRlID0ge307XG5cdFx0XHRuZXdTdGF0ZS5ub3JtYWxpemVkID0gdHJ1ZTtcblx0XHRcdG5ld1N0YXRlLnRpdGxlID0gb2xkU3RhdGUudGl0bGV8fCcnO1xuXHRcdFx0bmV3U3RhdGUudXJsID0gSGlzdG9yeS5nZXRGdWxsVXJsKG9sZFN0YXRlLnVybD9vbGRTdGF0ZS51cmw6KEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpKTtcblx0XHRcdG5ld1N0YXRlLmhhc2ggPSBIaXN0b3J5LmdldFNob3J0VXJsKG5ld1N0YXRlLnVybCk7XG5cdFx0XHRuZXdTdGF0ZS5kYXRhID0gSGlzdG9yeS5jbG9uZU9iamVjdChvbGRTdGF0ZS5kYXRhKTtcblxuXHRcdFx0Ly8gRmV0Y2ggSURcblx0XHRcdG5ld1N0YXRlLmlkID0gSGlzdG9yeS5nZXRJZEJ5U3RhdGUobmV3U3RhdGUpO1xuXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRcdC8vIENsZWFuIHRoZSBVUkxcblx0XHRcdG5ld1N0YXRlLmNsZWFuVXJsID0gbmV3U3RhdGUudXJsLnJlcGxhY2UoL1xcPz9cXCZfc3VpZC4qLywnJyk7XG5cdFx0XHRuZXdTdGF0ZS51cmwgPSBuZXdTdGF0ZS5jbGVhblVybDtcblxuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgbW9yZSB0aGFuIGp1c3QgYSB1cmxcblx0XHRcdGRhdGFOb3RFbXB0eSA9ICFIaXN0b3J5LmlzRW1wdHlPYmplY3QobmV3U3RhdGUuZGF0YSk7XG5cblx0XHRcdC8vIEFwcGx5XG5cdFx0XHRpZiAoIChuZXdTdGF0ZS50aXRsZSB8fCBkYXRhTm90RW1wdHkpICYmIEhpc3Rvcnkub3B0aW9ucy5kaXNhYmxlU3VpZCAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0Ly8gQWRkIElEIHRvIEhhc2hcblx0XHRcdFx0bmV3U3RhdGUuaGFzaCA9IEhpc3RvcnkuZ2V0U2hvcnRVcmwobmV3U3RhdGUudXJsKS5yZXBsYWNlKC9cXD8/XFwmX3N1aWQuKi8sJycpO1xuXHRcdFx0XHRpZiAoICEvXFw/Ly50ZXN0KG5ld1N0YXRlLmhhc2gpICkge1xuXHRcdFx0XHRcdG5ld1N0YXRlLmhhc2ggKz0gJz8nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld1N0YXRlLmhhc2ggKz0gJyZfc3VpZD0nK25ld1N0YXRlLmlkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIEhhc2hlZCBVUkxcblx0XHRcdG5ld1N0YXRlLmhhc2hlZFVybCA9IEhpc3RvcnkuZ2V0RnVsbFVybChuZXdTdGF0ZS5oYXNoKTtcblxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIFVSTCBpZiB3ZSBoYXZlIGEgZHVwbGljYXRlXG5cdFx0XHRpZiAoIChIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSB8fCBIaXN0b3J5LmJ1Z3Muc2FmYXJpUG9sbCkgJiYgSGlzdG9yeS5oYXNVcmxEdXBsaWNhdGUobmV3U3RhdGUpICkge1xuXHRcdFx0XHRuZXdTdGF0ZS51cmwgPSBuZXdTdGF0ZS5oYXNoZWRVcmw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gbmV3U3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QoZGF0YSx0aXRsZSx1cmwpXG5cdFx0ICogQ3JlYXRlcyBhIG9iamVjdCBiYXNlZCBvbiB0aGUgZGF0YSwgdGl0bGUgYW5kIHVybCBzdGF0ZSBwYXJhbXNcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdCA9IGZ1bmN0aW9uKGRhdGEsdGl0bGUsdXJsKXtcblx0XHRcdC8vIEhhc2hpZnlcblx0XHRcdHZhciBTdGF0ZSA9IHtcblx0XHRcdFx0J2RhdGEnOiBkYXRhLFxuXHRcdFx0XHQndGl0bGUnOiB0aXRsZSxcblx0XHRcdFx0J3VybCc6IHVybFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRXhwYW5kIHRoZSBTdGF0ZVxuXHRcdFx0U3RhdGUgPSBIaXN0b3J5Lm5vcm1hbGl6ZVN0YXRlKFN0YXRlKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG9iamVjdFxuXHRcdFx0cmV0dXJuIFN0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFN0YXRlQnlJZChpZClcblx0XHQgKiBHZXQgYSBzdGF0ZSBieSBpdCdzIFVJRFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0U3RhdGVCeUlkID0gZnVuY3Rpb24oaWQpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0aWQgPSBTdHJpbmcoaWQpO1xuXG5cdFx0XHQvLyBSZXRyaWV2ZVxuXHRcdFx0dmFyIFN0YXRlID0gSGlzdG9yeS5pZFRvU3RhdGVbaWRdIHx8IEhpc3Rvcnkuc3RvcmUuaWRUb1N0YXRlW2lkXSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIFJldHVybiBTdGF0ZVxuXHRcdFx0cmV0dXJuIFN0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBTdGF0ZSdzIFN0cmluZ1xuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IHBhc3NlZFN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTdGF0ZVN0cmluZyA9IGZ1bmN0aW9uKHBhc3NlZFN0YXRlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZSwgY2xlYW5lZFN0YXRlLCBzdHI7XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRTdGF0ZSA9IEhpc3Rvcnkubm9ybWFsaXplU3RhdGUocGFzc2VkU3RhdGUpO1xuXG5cdFx0XHQvLyBDbGVhblxuXHRcdFx0Y2xlYW5lZFN0YXRlID0ge1xuXHRcdFx0XHRkYXRhOiBTdGF0ZS5kYXRhLFxuXHRcdFx0XHR0aXRsZTogcGFzc2VkU3RhdGUudGl0bGUsXG5cdFx0XHRcdHVybDogcGFzc2VkU3RhdGUudXJsXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0c3RyID0gSlNPTi5zdHJpbmdpZnkoY2xlYW5lZFN0YXRlKTtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBTdGF0ZSdzIElEXG5cdFx0ICogQHBhcmFtIHtTdGF0ZX0gcGFzc2VkU3RhdGVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTdGF0ZUlkID0gZnVuY3Rpb24ocGFzc2VkU3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlLCBpZDtcblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdFN0YXRlID0gSGlzdG9yeS5ub3JtYWxpemVTdGF0ZShwYXNzZWRTdGF0ZSk7XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRpZCA9IFN0YXRlLmlkO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBpZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShTdGF0ZSlcblx0XHQgKiBDcmVhdGVzIGEgSGFzaCBmb3IgdGhlIFN0YXRlIE9iamVjdFxuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IHBhc3NlZFN0YXRlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBoYXNoXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRIYXNoQnlTdGF0ZSA9IGZ1bmN0aW9uKHBhc3NlZFN0YXRlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZSwgaGFzaDtcblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdFN0YXRlID0gSGlzdG9yeS5ub3JtYWxpemVTdGF0ZShwYXNzZWRTdGF0ZSk7XG5cblx0XHRcdC8vIEhhc2hcblx0XHRcdGhhc2ggPSBTdGF0ZS5oYXNoO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmV4dHJhY3RJZCh1cmxfb3JfaGFzaClcblx0XHQgKiBHZXQgYSBTdGF0ZSBJRCBieSBpdCdzIFVSTCBvciBIYXNoXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybF9vcl9oYXNoXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSBpZFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZXh0cmFjdElkID0gZnVuY3Rpb24gKCB1cmxfb3JfaGFzaCApIHtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBpZCxwYXJ0cyx1cmwsIHRtcDtcblxuXHRcdFx0Ly8gRXh0cmFjdFxuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgVVJMIGhhcyBhICMsIHVzZSB0aGUgaWQgZnJvbSBiZWZvcmUgdGhlICNcblx0XHRcdGlmICh1cmxfb3JfaGFzaC5pbmRleE9mKCcjJykgIT0gLTEpXG5cdFx0XHR7XG5cdFx0XHRcdHRtcCA9IHVybF9vcl9oYXNoLnNwbGl0KFwiI1wiKVswXTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dG1wID0gdXJsX29yX2hhc2g7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHBhcnRzID0gLyguKilcXCZfc3VpZD0oWzAtOV0rKSQvLmV4ZWModG1wKTtcblx0XHRcdHVybCA9IHBhcnRzID8gKHBhcnRzWzFdfHx1cmxfb3JfaGFzaCkgOiB1cmxfb3JfaGFzaDtcblx0XHRcdGlkID0gcGFydHMgPyBTdHJpbmcocGFydHNbMl18fCcnKSA6ICcnO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBpZHx8ZmFsc2U7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvclxuXHRcdCAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHVybCBpcyBhIHRyYWRpdGlvbmFsIGFuY2hvciBvciBub3Rcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsX29yX2hhc2hcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvciA9IGZ1bmN0aW9uKHVybF9vcl9oYXNoKXtcblx0XHRcdC8vIENoZWNrXG5cdFx0XHR2YXIgaXNUcmFkaXRpb25hbCA9ICEoL1tcXC9cXD9cXC5dLy50ZXN0KHVybF9vcl9oYXNoKSk7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGlzVHJhZGl0aW9uYWw7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZXh0cmFjdFN0YXRlXG5cdFx0ICogR2V0IGEgU3RhdGUgYnkgaXQncyBVUkwgb3IgSGFzaFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxfb3JfaGFzaFxuXHRcdCAqIEByZXR1cm4ge1N0YXRlfG51bGx9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5leHRyYWN0U3RhdGUgPSBmdW5jdGlvbih1cmxfb3JfaGFzaCxjcmVhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlID0gbnVsbCwgaWQsIHVybDtcblx0XHRcdGNyZWF0ZSA9IGNyZWF0ZXx8ZmFsc2U7XG5cblx0XHRcdC8vIEZldGNoIFNVSURcblx0XHRcdGlkID0gSGlzdG9yeS5leHRyYWN0SWQodXJsX29yX2hhc2gpO1xuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChpZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZldGNoIFNVSUQgcmV0dXJuZWQgbm8gU3RhdGVcblx0XHRcdGlmICggIVN0YXRlICkge1xuXHRcdFx0XHQvLyBGZXRjaCBVUkxcblx0XHRcdFx0dXJsID0gSGlzdG9yeS5nZXRGdWxsVXJsKHVybF9vcl9oYXNoKTtcblxuXHRcdFx0XHQvLyBDaGVjayBVUkxcblx0XHRcdFx0aWQgPSBIaXN0b3J5LmdldElkQnlVcmwodXJsKXx8ZmFsc2U7XG5cdFx0XHRcdGlmICggaWQgKSB7XG5cdFx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChpZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgU3RhdGVcblx0XHRcdFx0aWYgKCAhU3RhdGUgJiYgY3JlYXRlICYmICFIaXN0b3J5LmlzVHJhZGl0aW9uYWxBbmNob3IodXJsX29yX2hhc2gpICkge1xuXHRcdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChudWxsLG51bGwsdXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBTdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRJZEJ5VXJsKClcblx0XHQgKiBHZXQgYSBTdGF0ZSBJRCBieSBhIFN0YXRlIFVSTFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SWRCeVVybCA9IGZ1bmN0aW9uKHVybCl7XG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0dmFyIGlkID0gSGlzdG9yeS51cmxUb0lkW3VybF0gfHwgSGlzdG9yeS5zdG9yZS51cmxUb0lkW3VybF0gfHwgdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBpZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRMYXN0U2F2ZWRTdGF0ZSgpXG5cdFx0ICogR2V0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhLCB0aXRsZSBhbmQgdXJsIG9mIHRoZSBjdXJyZW50IHN0YXRlXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBTdGF0ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0TGFzdFNhdmVkU3RhdGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIEhpc3Rvcnkuc2F2ZWRTdGF0ZXNbSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGgtMV18fHVuZGVmaW5lZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRMYXN0U3RvcmVkU3RhdGUoKVxuXHRcdCAqIEdldCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSwgdGl0bGUgYW5kIHVybCBvZiB0aGUgY3VycmVudCBzdGF0ZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gU3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldExhc3RTdG9yZWRTdGF0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gSGlzdG9yeS5zdG9yZWRTdGF0ZXNbSGlzdG9yeS5zdG9yZWRTdGF0ZXMubGVuZ3RoLTFdfHx1bmRlZmluZWQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaGFzVXJsRHVwbGljYXRlXG5cdFx0ICogQ2hlY2tzIGlmIGEgVXJsIHdpbGwgaGF2ZSBhIHVybCBjb25mbGljdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IGhhc0R1cGxpY2F0ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaGFzVXJsRHVwbGljYXRlID0gZnVuY3Rpb24obmV3U3RhdGUpIHtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBoYXNEdXBsaWNhdGUgPSBmYWxzZSxcblx0XHRcdFx0b2xkU3RhdGU7XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRvbGRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKG5ld1N0YXRlLnVybCk7XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRoYXNEdXBsaWNhdGUgPSBvbGRTdGF0ZSAmJiBvbGRTdGF0ZS5pZCAhPT0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGhhc0R1cGxpY2F0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zdG9yZVN0YXRlXG5cdFx0ICogU3RvcmUgYSBTdGF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gbmV3U3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LnN0b3JlU3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cdFx0XHQvLyBTdG9yZSB0aGUgU3RhdGVcblx0XHRcdEhpc3RvcnkudXJsVG9JZFtuZXdTdGF0ZS51cmxdID0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdC8vIFB1c2ggdGhlIFN0YXRlXG5cdFx0XHRIaXN0b3J5LnN0b3JlZFN0YXRlcy5wdXNoKEhpc3RvcnkuY2xvbmVPYmplY3QobmV3U3RhdGUpKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5ld1N0YXRlXG5cdFx0XHRyZXR1cm4gbmV3U3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSlcblx0XHQgKiBUZXN0cyB0byBzZWUgaWYgdGhlIHN0YXRlIGlzIHRoZSBsYXN0IHN0YXRlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG5ld1N0YXRlXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gaXNMYXN0XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGlzTGFzdCA9IGZhbHNlLFxuXHRcdFx0XHRuZXdJZCwgb2xkU3RhdGUsIG9sZElkO1xuXG5cdFx0XHQvLyBDaGVja1xuXHRcdFx0aWYgKCBIaXN0b3J5LnNhdmVkU3RhdGVzLmxlbmd0aCApIHtcblx0XHRcdFx0bmV3SWQgPSBuZXdTdGF0ZS5pZDtcblx0XHRcdFx0b2xkU3RhdGUgPSBIaXN0b3J5LmdldExhc3RTYXZlZFN0YXRlKCk7XG5cdFx0XHRcdG9sZElkID0gb2xkU3RhdGUuaWQ7XG5cblx0XHRcdFx0Ly8gQ2hlY2tcblx0XHRcdFx0aXNMYXN0ID0gKG5ld0lkID09PSBvbGRJZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGlzTGFzdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zYXZlU3RhdGVcblx0XHQgKiBQdXNoIGEgU3RhdGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbmV3U3RhdGVcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufSBjaGFuZ2VkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlU3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cdFx0XHQvLyBDaGVjayBIYXNoXG5cdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHVzaCB0aGUgU3RhdGVcblx0XHRcdEhpc3Rvcnkuc2F2ZWRTdGF0ZXMucHVzaChIaXN0b3J5LmNsb25lT2JqZWN0KG5ld1N0YXRlKSk7XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRTdGF0ZUJ5SW5kZXgoKVxuXHRcdCAqIEdldHMgYSBzdGF0ZSBieSB0aGUgaW5kZXhcblx0XHQgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4XG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0U3RhdGVCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlID0gbnVsbDtcblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdC8vIEdldCB0aGUgbGFzdCBpbnNlcnRlZFxuXHRcdFx0XHRTdGF0ZSA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXNbSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGgtMV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHQvLyBHZXQgZnJvbSB0aGUgZW5kXG5cdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5zYXZlZFN0YXRlc1tIaXN0b3J5LnNhdmVkU3RhdGVzLmxlbmd0aCtpbmRleF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gR2V0IGZyb20gdGhlIGJlZ2lubmluZ1xuXHRcdFx0XHRTdGF0ZSA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXNbaW5kZXhdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gU3RhdGVcblx0XHRcdHJldHVybiBTdGF0ZTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0Q3VycmVudEluZGV4KClcblx0XHQgKiBHZXRzIHRoZSBjdXJyZW50IGluZGV4XG5cdFx0ICogQHJldHVybiAoaW50ZWdlcilcblx0XHQqL1xuXHRcdEhpc3RvcnkuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBpbmRleCA9IG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIE5vIHN0YXRlcyBzYXZlZFxuXHRcdFx0aWYoSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGggPCAxKSB7XG5cdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpbmRleCA9IEhpc3Rvcnkuc2F2ZWRTdGF0ZXMubGVuZ3RoLTE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0fTtcblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSGFzaCBIZWxwZXJzXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEhhc2goKVxuXHRcdCAqIEBwYXJhbSB7TG9jYXRpb249fSBsb2NhdGlvblxuXHRcdCAqIEdldHMgdGhlIGN1cnJlbnQgZG9jdW1lbnQgaGFzaFxuXHRcdCAqIE5vdGU6IHVubGlrZSBsb2NhdGlvbi5oYXNoLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIHRoZSBlc2NhcGVkIGhhc2ggaW4gYWxsIGJyb3dzZXJzXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SGFzaCA9IGZ1bmN0aW9uKGRvYyl7XG5cdFx0XHR2YXIgdXJsID0gSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoZG9jKSxcblx0XHRcdFx0aGFzaDtcblx0XHRcdGhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVVybCh1cmwpO1xuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkudW5lc2NhcGVIYXNoKClcblx0XHQgKiBub3JtYWxpemUgYW5kIFVuZXNjYXBlIGEgSGFzaFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkudW5lc2NhcGVIYXNoID0gZnVuY3Rpb24oaGFzaCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgcmVzdWx0ID0gSGlzdG9yeS5ub3JtYWxpemVIYXNoKGhhc2gpO1xuXG5cdFx0XHQvLyBVbmVzY2FwZSBoYXNoXG5cdFx0XHRyZXN1bHQgPSBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcblxuXHRcdFx0Ly8gUmV0dXJuIHJlc3VsdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5ub3JtYWxpemVIYXNoKClcblx0XHQgKiBub3JtYWxpemUgYSBoYXNoIGFjcm9zcyBicm93c2Vyc1xuXHRcdCAqIEByZXR1cm4ge3N0cmluZ31cblx0XHQgKi9cblx0XHRIaXN0b3J5Lm5vcm1hbGl6ZUhhc2ggPSBmdW5jdGlvbihoYXNoKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciByZXN1bHQgPSBoYXNoLnJlcGxhY2UoL1teI10qIy8sJycpLnJlcGxhY2UoLyMuKi8sICcnKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHJlc3VsdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zZXRIYXNoKGhhc2gpXG5cdFx0ICogU2V0cyB0aGUgZG9jdW1lbnQgaGFzaFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LnNldEhhc2ggPSBmdW5jdGlvbihoYXNoLHF1ZXVlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZSwgcGFnZVVybDtcblxuXHRcdFx0Ly8gSGFuZGxlIFF1ZXVlaW5nXG5cdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnNldEhhc2g6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRzY29wZTogSGlzdG9yeSxcblx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5zZXRIYXNoLFxuXHRcdFx0XHRcdGFyZ3M6IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9nXG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkuc2V0SGFzaDogY2FsbGVkJyxoYXNoKTtcblxuXHRcdFx0Ly8gTWFrZSBCdXN5ICsgQ29udGludWVcblx0XHRcdEhpc3RvcnkuYnVzeSh0cnVlKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaGFzaCBpcyBhIHN0YXRlXG5cdFx0XHRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKGhhc2gsdHJ1ZSk7XG5cdFx0XHRpZiAoIFN0YXRlICYmICFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdFx0Ly8gSGFzaCBpcyBhIHN0YXRlIHNvIHNraXAgdGhlIHNldEhhc2hcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnNldEhhc2g6IEhhc2ggaXMgYSBzdGF0ZSBzbyBza2lwcGluZyB0aGUgaGFzaCBzZXQgd2l0aCBhIGRpcmVjdCBwdXNoU3RhdGUgY2FsbCcsYXJndW1lbnRzKTtcblxuXHRcdFx0XHQvLyBQdXNoU3RhdGVcblx0XHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUoU3RhdGUuZGF0YSxTdGF0ZS50aXRsZSxTdGF0ZS51cmwsZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIEhpc3RvcnkuZ2V0SGFzaCgpICE9PSBoYXNoICkge1xuXHRcdFx0XHQvLyBIYXNoIGlzIGEgcHJvcGVyIGhhc2gsIHNvIGFwcGx5IGl0XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGJyb3dzZXIgYnVnc1xuXHRcdFx0XHRpZiAoIEhpc3RvcnkuYnVncy5zZXRIYXNoICkge1xuXHRcdFx0XHRcdC8vIEZpeCBTYWZhcmkgQnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD01NjI0OVxuXG5cdFx0XHRcdFx0Ly8gRmV0Y2ggdGhlIGJhc2UgcGFnZVxuXHRcdFx0XHRcdHBhZ2VVcmwgPSBIaXN0b3J5LmdldFBhZ2VVcmwoKTtcblxuXHRcdFx0XHRcdC8vIFNhZmFyaSBoYXNoIGFwcGx5XG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLHBhZ2VVcmwrJyMnK2hhc2gsZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIE5vcm1hbCBoYXNoIGFwcGx5XG5cdFx0XHRcdFx0ZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IGhhc2g7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmVzY2FwZSgpXG5cdFx0ICogbm9ybWFsaXplIGFuZCBFc2NhcGUgYSBIYXNoXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZXNjYXBlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIHJlc3VsdCA9IEhpc3Rvcnkubm9ybWFsaXplSGFzaChoYXNoKTtcblxuXHRcdFx0Ly8gRXNjYXBlIGhhc2hcblx0XHRcdHJlc3VsdCA9IHdpbmRvdy5lbmNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcblxuXHRcdFx0Ly8gSUU2IEVzY2FwZSBCdWdcblx0XHRcdGlmICggIUhpc3RvcnkuYnVncy5oYXNoRXNjYXBlICkge1xuXHRcdFx0XHQvLyBSZXN0b3JlIGNvbW1vbiBwYXJ0c1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHRcblx0XHRcdFx0XHQucmVwbGFjZSgvXFwlMjEvZywnIScpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcJTI2L2csJyYnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXCUzRC9nLCc9Jylcblx0XHRcdFx0XHQucmVwbGFjZSgvXFwlM0YvZywnPycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gcmVzdWx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEhhc2hCeVVybCh1cmwpXG5cdFx0ICogRXh0cmFjdHMgdGhlIEhhc2ggZnJvbSBhIFVSTFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SGFzaEJ5VXJsID0gZnVuY3Rpb24odXJsKXtcblx0XHRcdC8vIEV4dHJhY3QgdGhlIGhhc2hcblx0XHRcdHZhciBoYXNoID0gU3RyaW5nKHVybClcblx0XHRcdFx0LnJlcGxhY2UoLyhbXiNdKikjPyhbXiNdKikjPyguKikvLCAnJDInKVxuXHRcdFx0XHQ7XG5cblx0XHRcdC8vIFVuZXNjYXBlIGhhc2hcblx0XHRcdGhhc2ggPSBIaXN0b3J5LnVuZXNjYXBlSGFzaChoYXNoKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGhhc2hcblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNldFRpdGxlKHRpdGxlKVxuXHRcdCAqIEFwcGxpZXMgdGhlIHRpdGxlIHRvIHRoZSBkb2N1bWVudFxuXHRcdCAqIEBwYXJhbSB7U3RhdGV9IG5ld1N0YXRlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRIaXN0b3J5LnNldFRpdGxlID0gZnVuY3Rpb24obmV3U3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIHRpdGxlID0gbmV3U3RhdGUudGl0bGUsXG5cdFx0XHRcdGZpcnN0U3RhdGU7XG5cblx0XHRcdC8vIEluaXRpYWxcblx0XHRcdGlmICggIXRpdGxlICkge1xuXHRcdFx0XHRmaXJzdFN0YXRlID0gSGlzdG9yeS5nZXRTdGF0ZUJ5SW5kZXgoMCk7XG5cdFx0XHRcdGlmICggZmlyc3RTdGF0ZSAmJiBmaXJzdFN0YXRlLnVybCA9PT0gbmV3U3RhdGUudXJsICkge1xuXHRcdFx0XHRcdHRpdGxlID0gZmlyc3RTdGF0ZS50aXRsZXx8SGlzdG9yeS5vcHRpb25zLmluaXRpYWxUaXRsZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RpdGxlJylbMF0uaW5uZXJIVE1MID0gdGl0bGUucmVwbGFjZSgnPCcsJyZsdDsnKS5yZXBsYWNlKCc+JywnJmd0OycpLnJlcGxhY2UoJyAmICcsJyAmYW1wOyAnKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoICggRXhjZXB0aW9uICkgeyB9XG5cdFx0XHRkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuXG5cdFx0XHQvLyBDaGFpblxuXHRcdFx0cmV0dXJuIEhpc3Rvcnk7XG5cdFx0fTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBRdWV1ZWluZ1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5xdWV1ZXNcblx0XHQgKiBUaGUgbGlzdCBvZiBxdWV1ZXMgdG8gdXNlXG5cdFx0ICogRmlyc3QgSW4sIEZpcnN0IE91dFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkucXVldWVzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmJ1c3kodmFsdWUpXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBbb3B0aW9uYWxdXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gYnVzeVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuYnVzeSA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdC8vIEFwcGx5XG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5idXN5OiBjaGFuZ2luZyBbJysoSGlzdG9yeS5idXN5LmZsYWd8fGZhbHNlKSsnXSB0byBbJysodmFsdWV8fGZhbHNlKSsnXScsIEhpc3RvcnkucXVldWVzLmxlbmd0aCk7XG5cdFx0XHRcdEhpc3RvcnkuYnVzeS5mbGFnID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBEZWZhdWx0XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIEhpc3RvcnkuYnVzeS5mbGFnID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0SGlzdG9yeS5idXN5LmZsYWcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUXVldWVcblx0XHRcdGlmICggIUhpc3RvcnkuYnVzeS5mbGFnICkge1xuXHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIHF1ZXVlXG5cdFx0XHRcdGNsZWFyVGltZW91dChIaXN0b3J5LmJ1c3kudGltZW91dCk7XG5cdFx0XHRcdHZhciBmaXJlTmV4dCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dmFyIGksIHF1ZXVlLCBpdGVtO1xuXHRcdFx0XHRcdGlmICggSGlzdG9yeS5idXN5LmZsYWcgKSByZXR1cm47XG5cdFx0XHRcdFx0Zm9yICggaT1IaXN0b3J5LnF1ZXVlcy5sZW5ndGgtMTsgaSA+PSAwOyAtLWkgKSB7XG5cdFx0XHRcdFx0XHRxdWV1ZSA9IEhpc3RvcnkucXVldWVzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCBxdWV1ZS5sZW5ndGggPT09IDAgKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdGl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5maXJlUXVldWVJdGVtKGl0ZW0pO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5idXN5LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZpcmVOZXh0LEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0SGlzdG9yeS5idXN5LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZpcmVOZXh0LEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBIaXN0b3J5LmJ1c3kuZmxhZztcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5idXN5LmZsYWdcblx0XHQgKi9cblx0XHRIaXN0b3J5LmJ1c3kuZmxhZyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5maXJlUXVldWVJdGVtKGl0ZW0pXG5cdFx0ICogRmlyZSBhIFF1ZXVlIEl0ZW1cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHRcdCAqIEByZXR1cm4ge01peGVkfSByZXN1bHRcblx0XHQgKi9cblx0XHRIaXN0b3J5LmZpcmVRdWV1ZUl0ZW0gPSBmdW5jdGlvbihpdGVtKXtcblx0XHRcdHJldHVybiBpdGVtLmNhbGxiYWNrLmFwcGx5KGl0ZW0uc2NvcGV8fEhpc3RvcnksaXRlbS5hcmdzfHxbXSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkucHVzaFF1ZXVlKGNhbGxiYWNrLGFyZ3MpXG5cdFx0ICogQWRkIGFuIGl0ZW0gdG8gdGhlIHF1ZXVlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gW3Njb3BlLGNhbGxiYWNrLGFyZ3MscXVldWVdXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5wdXNoUXVldWUgPSBmdW5jdGlvbihpdGVtKXtcblx0XHRcdC8vIFByZXBhcmUgdGhlIHF1ZXVlXG5cdFx0XHRIaXN0b3J5LnF1ZXVlc1tpdGVtLnF1ZXVlfHwwXSA9IEhpc3RvcnkucXVldWVzW2l0ZW0ucXVldWV8fDBdfHxbXTtcblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBxdWV1ZVxuXHRcdFx0SGlzdG9yeS5xdWV1ZXNbaXRlbS5xdWV1ZXx8MF0ucHVzaChpdGVtKTtcblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnF1ZXVlIChpdGVtLHF1ZXVlKSwgKGZ1bmMscXVldWUpLCAoZnVuYyksIChpdGVtKVxuXHRcdCAqIEVpdGhlciBmaXJzIHRoZSBpdGVtIG5vdyBpZiBub3QgYnVzeSwgb3IgYWRkcyBpdCB0byB0aGUgcXVldWVcblx0XHQgKi9cblx0XHRIaXN0b3J5LnF1ZXVlID0gZnVuY3Rpb24oaXRlbSxxdWV1ZSl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRpdGVtID0ge1xuXHRcdFx0XHRcdGNhbGxiYWNrOiBpdGVtXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBxdWV1ZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdGl0ZW0ucXVldWUgPSBxdWV1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHRIaXN0b3J5LnB1c2hRdWV1ZShpdGVtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdEhpc3RvcnkuZmlyZVF1ZXVlSXRlbShpdGVtKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmNsZWFyUXVldWUoKVxuXHRcdCAqIENsZWFycyB0aGUgUXVldWVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmNsZWFyUXVldWUgPSBmdW5jdGlvbigpe1xuXHRcdFx0SGlzdG9yeS5idXN5LmZsYWcgPSBmYWxzZTtcblx0XHRcdEhpc3RvcnkucXVldWVzID0gW107XG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIElFIEJ1ZyBGaXhcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc3RhdGVDaGFuZ2VkXG5cdFx0ICogU3RhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBzdGF0ZSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBkb3VibGUgY2hlY2sgd2FzIGluaXRpYWxpc2VkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zdGF0ZUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZG91YmxlQ2hlY2tlclxuXHRcdCAqIENvbnRhaW5zIHRoZSB0aW1lb3V0IHVzZWQgZm9yIHRoZSBkb3VibGUgY2hlY2tzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kb3VibGVDaGVja2VyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUoKVxuXHRcdCAqIENvbXBsZXRlIGEgZG91YmxlIGNoZWNrXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gVXBkYXRlXG5cdFx0XHRIaXN0b3J5LnN0YXRlQ2hhbmdlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyXG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKTtcblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKVxuXHRcdCAqIENsZWFyIGEgZG91YmxlIGNoZWNrXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ2xlYXJcblx0XHRcdGlmICggSGlzdG9yeS5kb3VibGVDaGVja2VyICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoSGlzdG9yeS5kb3VibGVDaGVja2VyKTtcblx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja2VyID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kb3VibGVDaGVjaygpXG5cdFx0ICogQ3JlYXRlIGEgZG91YmxlIGNoZWNrXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrID0gZnVuY3Rpb24odHJ5QWdhaW4pe1xuXHRcdFx0Ly8gUmVzZXRcblx0XHRcdEhpc3Rvcnkuc3RhdGVDaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKTtcblxuXHRcdFx0Ly8gRml4IElFNixJRTcgYnVnIHdoZXJlIGNhbGxpbmcgaGlzdG9yeS5iYWNrIG9yIGhpc3RvcnkuZm9yd2FyZCBkb2VzIG5vdCBhY3R1YWxseSBjaGFuZ2UgdGhlIGhhc2ggKHdoZXJlYXMgZG9pbmcgaXQgbWFudWFsbHkgZG9lcylcblx0XHRcdC8vIEZpeCBTYWZhcmkgNSBidWcgd2hlcmUgc29tZXRpbWVzIHRoZSBzdGF0ZSBkb2VzIG5vdCBjaGFuZ2U6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD00Mjk0MFxuXHRcdFx0aWYgKCBIaXN0b3J5LmJ1Z3MuaWVEb3VibGVDaGVjayApIHtcblx0XHRcdFx0Ly8gQXBwbHkgQ2hlY2tcblx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja2VyID0gc2V0VGltZW91dChcblx0XHRcdFx0XHRmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5kb3VibGVDaGVja0NsZWFyKCk7XG5cdFx0XHRcdFx0XHRpZiAoICFIaXN0b3J5LnN0YXRlQ2hhbmdlZCApIHtcblx0XHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmRvdWJsZUNoZWNrOiBTdGF0ZSBoYXMgbm90IHlldCBjaGFuZ2VkLCB0cnlpbmcgYWdhaW4nLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1BdHRlbXB0XG5cdFx0XHRcdFx0XHRcdHRyeUFnYWluKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEhpc3Rvcnkub3B0aW9ucy5kb3VibGVDaGVja0ludGVydmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFNhZmFyaSBCdWcgRml4XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNhZmFyaVN0YXRlUG9sbCgpXG5cdFx0ICogUG9sbCB0aGUgY3VycmVudCBzdGF0ZVxuXHRcdCAqIEByZXR1cm4ge0hpc3Rvcnl9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYWZhcmlTdGF0ZVBvbGwgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gUG9sbCB0aGUgVVJMXG5cblx0XHRcdC8vIEdldCB0aGUgTGFzdCBTdGF0ZSB3aGljaCBoYXMgdGhlIG5ldyBVUkxcblx0XHRcdHZhclxuXHRcdFx0XHR1cmxTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpLFxuXHRcdFx0XHRuZXdTdGF0ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGEgZGlmZmVyZW5jZVxuXHRcdFx0aWYgKCAhSGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlKHVybFN0YXRlKSApIHtcblx0XHRcdFx0bmV3U3RhdGUgPSB1cmxTdGF0ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIHdlIGhhdmUgYSBzdGF0ZSB3aXRoIHRoYXQgdXJsXG5cdFx0XHQvLyBJZiBub3QgY3JlYXRlIGl0XG5cdFx0XHRpZiAoICFuZXdTdGF0ZSApIHtcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnNhZmFyaVN0YXRlUG9sbDogbmV3Jyk7XG5cdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSB0aGUgTmV3IFN0YXRlXG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkuc2FmYXJpU3RhdGVQb2xsOiB0cmlnZ2VyJyk7XG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3BvcHN0YXRlJyk7XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFN0YXRlIEFsaWFzZXNcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuYmFjayhxdWV1ZSlcblx0XHQgKiBTZW5kIHRoZSBicm93c2VyIGhpc3RvcnkgYmFjayBvbmUgaXRlbVxuXHRcdCAqIEBwYXJhbSB7SW50ZWdlcn0gcXVldWUgW29wdGlvbmFsXVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuYmFjayA9IGZ1bmN0aW9uKHF1ZXVlKXtcblx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5iYWNrOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdGlmICggcXVldWUgIT09IGZhbHNlICYmIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuYmFjazogd2UgbXVzdCB3YWl0JywgYXJndW1lbnRzKTtcblx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdGNhbGxiYWNrOiBIaXN0b3J5LmJhY2ssXG5cdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdHF1ZXVlOiBxdWV1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIEJ1c3kgKyBDb250aW51ZVxuXHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHQvLyBGaXggY2VydGFpbiBicm93c2VyIGJ1Z3MgdGhhdCBwcmV2ZW50IHRoZSBzdGF0ZSBmcm9tIGNoYW5naW5nXG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdEhpc3RvcnkuYmFjayhmYWxzZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gR28gYmFja1xuXHRcdFx0aGlzdG9yeS5nbygtMSk7XG5cblx0XHRcdC8vIEVuZCBiYWNrIGNsb3N1cmVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmZvcndhcmQocXVldWUpXG5cdFx0ICogU2VuZCB0aGUgYnJvd3NlciBoaXN0b3J5IGZvcndhcmQgb25lIGl0ZW1cblx0XHQgKiBAcGFyYW0ge0ludGVnZXJ9IHF1ZXVlIFtvcHRpb25hbF1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmZvcndhcmQgPSBmdW5jdGlvbihxdWV1ZSl7XG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuZm9yd2FyZDogY2FsbGVkJywgYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gSGFuZGxlIFF1ZXVlaW5nXG5cdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmZvcndhcmQ6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRzY29wZTogSGlzdG9yeSxcblx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5mb3J3YXJkLFxuXHRcdFx0XHRcdGFyZ3M6IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBCdXN5ICsgQ29udGludWVcblx0XHRcdEhpc3RvcnkuYnVzeSh0cnVlKTtcblxuXHRcdFx0Ly8gRml4IGNlcnRhaW4gYnJvd3NlciBidWdzIHRoYXQgcHJldmVudCB0aGUgc3RhdGUgZnJvbSBjaGFuZ2luZ1xuXHRcdFx0SGlzdG9yeS5kb3VibGVDaGVjayhmdW5jdGlvbigpe1xuXHRcdFx0XHRIaXN0b3J5LmZvcndhcmQoZmFsc2UpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEdvIGZvcndhcmRcblx0XHRcdGhpc3RvcnkuZ28oMSk7XG5cblx0XHRcdC8vIEVuZCBmb3J3YXJkIGNsb3N1cmVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdvKGluZGV4LHF1ZXVlKVxuXHRcdCAqIFNlbmQgdGhlIGJyb3dzZXIgaGlzdG9yeSBiYWNrIG9yIGZvcndhcmQgaW5kZXggdGltZXNcblx0XHQgKiBAcGFyYW0ge0ludGVnZXJ9IHF1ZXVlIFtvcHRpb25hbF1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmdvID0gZnVuY3Rpb24oaW5kZXgscXVldWUpe1xuXHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmdvOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0Ly8gSGFuZGxlXG5cdFx0XHRpZiAoIGluZGV4ID4gMCApIHtcblx0XHRcdFx0Ly8gRm9yd2FyZFxuXHRcdFx0XHRmb3IgKCBpPTE7IGk8PWluZGV4OyArK2kgKSB7XG5cdFx0XHRcdFx0SGlzdG9yeS5mb3J3YXJkKHF1ZXVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0Ly8gQmFja3dhcmRcblx0XHRcdFx0Zm9yICggaT0tMTsgaT49aW5kZXg7IC0taSApIHtcblx0XHRcdFx0XHRIaXN0b3J5LmJhY2socXVldWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmdvOiBIaXN0b3J5LmdvIHJlcXVpcmVzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBwYXNzZWQuJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEhUTUw1IFN0YXRlIFN1cHBvcnRcblxuXHRcdC8vIE5vbi1OYXRpdmUgcHVzaFN0YXRlIEltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdC8qXG5cdFx0XHQgKiBQcm92aWRlIFNrZWxldG9uIGZvciBIVE1MNCBCcm93c2Vyc1xuXHRcdFx0ICovXG5cblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24oKXt9O1xuXHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUgPSBIaXN0b3J5LnB1c2hTdGF0ZXx8ZW1wdHlGdW5jdGlvbjtcblx0XHRcdEhpc3RvcnkucmVwbGFjZVN0YXRlID0gSGlzdG9yeS5yZXBsYWNlU3RhdGV8fGVtcHR5RnVuY3Rpb247XG5cdFx0fSAvLyBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZVxuXG5cdFx0Ly8gTmF0aXZlIHB1c2hTdGF0ZSBJbXBsZW1lbnRhdGlvblxuXHRcdGVsc2Uge1xuXHRcdFx0Lypcblx0XHRcdCAqIFVzZSBuYXRpdmUgSFRNTDUgSGlzdG9yeSBBUEkgSW1wbGVtZW50YXRpb25cblx0XHRcdCAqL1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3Rvcnkub25Qb3BTdGF0ZShldmVudCxleHRyYSlcblx0XHRcdCAqIFJlZnJlc2ggdGhlIEN1cnJlbnQgU3RhdGVcblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5vblBvcFN0YXRlID0gZnVuY3Rpb24oZXZlbnQsZXh0cmEpe1xuXHRcdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRcdHZhciBzdGF0ZUlkID0gZmFsc2UsIG5ld1N0YXRlID0gZmFsc2UsIGN1cnJlbnRIYXNoLCBjdXJyZW50U3RhdGU7XG5cblx0XHRcdFx0Ly8gUmVzZXQgdGhlIGRvdWJsZSBjaGVja1xuXHRcdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUoKTtcblxuXHRcdFx0XHQvLyBDaGVjayBmb3IgYSBIYXNoLCBhbmQgaGFuZGxlIGFwcG9yaWF0bHlcblx0XHRcdFx0Y3VycmVudEhhc2ggPSBIaXN0b3J5LmdldEhhc2goKTtcblx0XHRcdFx0aWYgKCBjdXJyZW50SGFzaCApIHtcblx0XHRcdFx0XHQvLyBFeHBhbmQgSGFzaFxuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZSA9IEhpc3RvcnkuZXh0cmFjdFN0YXRlKGN1cnJlbnRIYXNofHxIaXN0b3J5LmdldExvY2F0aW9uSHJlZigpLHRydWUpO1xuXHRcdFx0XHRcdGlmICggY3VycmVudFN0YXRlICkge1xuXHRcdFx0XHRcdFx0Ly8gV2Ugd2VyZSBhYmxlIHRvIHBhcnNlIGl0LCBpdCBtdXN0IGJlIGEgU3RhdGUhXG5cdFx0XHRcdFx0XHQvLyBMZXQncyBmb3J3YXJkIHRvIHJlcGxhY2VTdGF0ZVxuXHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uUG9wU3RhdGU6IHN0YXRlIGFuY2hvcicsIGN1cnJlbnRIYXNoLCBjdXJyZW50U3RhdGUpO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLmRhdGEsIGN1cnJlbnRTdGF0ZS50aXRsZSwgY3VycmVudFN0YXRlLnVybCwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFRyYWRpdGlvbmFsIEFuY2hvclxuXHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uUG9wU3RhdGU6IHRyYWRpdGlvbmFsIGFuY2hvcicsIGN1cnJlbnRIYXNoKTtcblx0XHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnYW5jaG9yY2hhbmdlJyk7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFdlIGRvbid0IGNhcmUgZm9yIGhhc2hlc1xuXHRcdFx0XHRcdEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkID0gZmFsc2U7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRW5zdXJlXG5cdFx0XHRcdHN0YXRlSWQgPSBIaXN0b3J5LkFkYXB0ZXIuZXh0cmFjdEV2ZW50RGF0YSgnc3RhdGUnLGV2ZW50LGV4dHJhKSB8fCBmYWxzZTtcblxuXHRcdFx0XHQvLyBGZXRjaCBTdGF0ZVxuXHRcdFx0XHRpZiAoIHN0YXRlSWQgKSB7XG5cdFx0XHRcdFx0Ly8gVmFuaWxsYTogQmFjay9mb3J3YXJkIGJ1dHRvbiB3YXMgdXNlZFxuXHRcdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5nZXRTdGF0ZUJ5SWQoc3RhdGVJZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkICkge1xuXHRcdFx0XHRcdC8vIFZhbmlsbGE6IEEgbmV3IHN0YXRlIHdhcyBwdXNoZWQsIGFuZCBwb3BzdGF0ZSB3YXMgY2FsbGVkIG1hbnVhbGx5XG5cdFx0XHRcdFx0bmV3U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChIaXN0b3J5LmV4cGVjdGVkU3RhdGVJZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSW5pdGlhbCBTdGF0ZVxuXHRcdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5leHRyYWN0U3RhdGUoSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgU3RhdGUgZGlkIG5vdCBleGlzdCBpbiBvdXIgc3RvcmVcblx0XHRcdFx0aWYgKCAhbmV3U3RhdGUgKSB7XG5cdFx0XHRcdFx0Ly8gUmVnZW5lcmF0ZSB0aGUgU3RhdGVcblx0XHRcdFx0XHRuZXdTdGF0ZSA9IEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QobnVsbCxudWxsLEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2xlYW5cblx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgdGhlIHNhbWUgc3RhdGVcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmlzTGFzdFNhdmVkU3RhdGUobmV3U3RhdGUpICkge1xuXHRcdFx0XHRcdC8vIFRoZXJlIGhhcyBiZWVuIG5vIGNoYW5nZSAoanVzdCB0aGUgcGFnZSdzIGhhc2ggaGFzIGZpbmFsbHkgcHJvcGFnYXRlZClcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25Qb3BTdGF0ZTogbm8gY2hhbmdlJywgbmV3U3RhdGUsIEhpc3Rvcnkuc2F2ZWRTdGF0ZXMpO1xuXHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlIFN0YXRlXG5cdFx0XHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0XHRcdEhpc3Rvcnkuc2F2ZVN0YXRlKG5ld1N0YXRlKTtcblxuXHRcdFx0XHQvLyBGb3JjZSB1cGRhdGUgb2YgdGhlIHRpdGxlXG5cdFx0XHRcdEhpc3Rvcnkuc2V0VGl0bGUobmV3U3RhdGUpO1xuXG5cdFx0XHRcdC8vIEZpcmUgT3VyIEV2ZW50XG5cdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnc3RhdGVjaGFuZ2UnKTtcblx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblxuXHRcdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIuYmluZCh3aW5kb3csJ3BvcHN0YXRlJyxIaXN0b3J5Lm9uUG9wU3RhdGUpO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3RvcnkucHVzaFN0YXRlKGRhdGEsdGl0bGUsdXJsKVxuXHRcdFx0ICogQWRkIGEgbmV3IFN0YXRlIHRvIHRoZSBoaXN0b3J5IG9iamVjdCwgYmVjb21lIGl0LCBhbmQgdHJpZ2dlciBvbnBvcHN0YXRlXG5cdFx0XHQgKiBXZSBoYXZlIHRvIHRyaWdnZXIgZm9yIEhUTUw0IGNvbXBhdGliaWxpdHlcblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0XHRcdCAqIEByZXR1cm4ge3RydWV9XG5cdFx0XHQgKi9cblx0XHRcdEhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24oZGF0YSx0aXRsZSx1cmwscXVldWUpe1xuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRcdC8vIENoZWNrIHRoZSBTdGF0ZVxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuZ2V0SGFzaEJ5VXJsKHVybCkgJiYgSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmpzIGRvZXMgbm90IHN1cHBvcnQgc3RhdGVzIHdpdGggZnJhZ2VtZW50LWlkZW50aWZpZXJzIChoYXNoZXMvYW5jaG9ycykuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdFx0aWYgKCBxdWV1ZSAhPT0gZmFsc2UgJiYgSGlzdG9yeS5idXN5KCkgKSB7XG5cdFx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiB3ZSBtdXN0IHdhaXQnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2s6IEhpc3RvcnkucHVzaFN0YXRlLFxuXHRcdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0cXVldWU6IHF1ZXVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFrZSBCdXN5ICsgQ29udGludWVcblx0XHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgbmV3U3RhdGVcblx0XHRcdFx0dmFyIG5ld1N0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChkYXRhLHRpdGxlLHVybCk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaXRcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmlzTGFzdFNhdmVkU3RhdGUobmV3U3RhdGUpICkge1xuXHRcdFx0XHRcdC8vIFdvbid0IGJlIGEgY2hhbmdlXG5cdFx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgbmV3U3RhdGVcblx0XHRcdFx0XHRIaXN0b3J5LnN0b3JlU3RhdGUobmV3U3RhdGUpO1xuXHRcdFx0XHRcdEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkID0gbmV3U3RhdGUuaWQ7XG5cblx0XHRcdFx0XHQvLyBQdXNoIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHRcdGhpc3RvcnkucHVzaFN0YXRlKG5ld1N0YXRlLmlkLG5ld1N0YXRlLnRpdGxlLG5ld1N0YXRlLnVybCk7XG5cblx0XHRcdFx0XHQvLyBGaXJlIEhUTUw1IEV2ZW50XG5cdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdwb3BzdGF0ZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRW5kIHB1c2hTdGF0ZSBjbG9zdXJlXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIaXN0b3J5LnJlcGxhY2VTdGF0ZShkYXRhLHRpdGxlLHVybClcblx0XHRcdCAqIFJlcGxhY2UgdGhlIFN0YXRlIGFuZCB0cmlnZ2VyIG9ucG9wc3RhdGVcblx0XHRcdCAqIFdlIGhhdmUgdG8gdHJpZ2dlciBmb3IgSFRNTDQgY29tcGF0aWJpbGl0eVxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdFx0ICogQHJldHVybiB7dHJ1ZX1cblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbihkYXRhLHRpdGxlLHVybCxxdWV1ZSl7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5yZXBsYWNlU3RhdGU6IGNhbGxlZCcsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgdGhlIFN0YXRlXG5cdFx0XHRcdGlmICggSGlzdG9yeS5nZXRIYXNoQnlVcmwodXJsKSAmJiBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgZG9lcyBub3Qgc3VwcG9ydCBzdGF0ZXMgd2l0aCBmcmFnZW1lbnQtaWRlbnRpZmllcnMgKGhhc2hlcy9hbmNob3JzKS4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBRdWV1ZWluZ1xuXHRcdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5yZXBsYWNlU3RhdGU6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdFx0c2NvcGU6IEhpc3RvcnksXG5cdFx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5yZXBsYWNlU3RhdGUsXG5cdFx0XHRcdFx0XHRhcmdzOiBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIEJ1c3kgKyBDb250aW51ZVxuXHRcdFx0XHRIaXN0b3J5LmJ1c3kodHJ1ZSk7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHR2YXIgbmV3U3RhdGUgPSBIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0KGRhdGEsdGl0bGUsdXJsKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpdFxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSkgKSB7XG5cdFx0XHRcdFx0Ly8gV29uJ3QgYmUgYSBjaGFuZ2Vcblx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBuZXdTdGF0ZS5pZDtcblxuXHRcdFx0XHRcdC8vIFB1c2ggdGhlIG5ld1N0YXRlXG5cdFx0XHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUobmV3U3RhdGUuaWQsbmV3U3RhdGUudGl0bGUsbmV3U3RhdGUudXJsKTtcblxuXHRcdFx0XHRcdC8vIEZpcmUgSFRNTDUgRXZlbnRcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3BvcHN0YXRlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFbmQgcmVwbGFjZVN0YXRlIGNsb3N1cmVcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXG5cdFx0fSAvLyAhSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGVcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBJbml0aWFsaXNlXG5cblx0XHQvKipcblx0XHQgKiBMb2FkIHRoZSBTdG9yZVxuXHRcdCAqL1xuXHRcdGlmICggc2Vzc2lvblN0b3JhZ2UgKSB7XG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0SGlzdG9yeS5zdG9yZSA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnSGlzdG9yeS5zdG9yZScpKXx8e307XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0SGlzdG9yeS5zdG9yZSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb3JtYWxpemVcblx0XHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBEZWZhdWx0IExvYWRcblx0XHRcdEhpc3Rvcnkuc3RvcmUgPSB7fTtcblx0XHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUoKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDbGVhciBJbnRlcnZhbHMgb24gZXhpdCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkuQWRhcHRlci5iaW5kKHdpbmRvdyxcInVubG9hZFwiLEhpc3RvcnkuY2xlYXJBbGxJbnRlcnZhbHMpO1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHRoZSBpbml0aWFsIFN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5zYXZlU3RhdGUoSGlzdG9yeS5zdG9yZVN0YXRlKEhpc3RvcnkuZXh0cmFjdFN0YXRlKEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCksdHJ1ZSkpKTtcblxuXHRcdC8qKlxuXHRcdCAqIEJpbmQgZm9yIFNhdmluZyBTdG9yZVxuXHRcdCAqL1xuXHRcdGlmICggc2Vzc2lvblN0b3JhZ2UgKSB7XG5cdFx0XHQvLyBXaGVuIHRoZSBwYWdlIGlzIGNsb3NlZFxuXHRcdFx0SGlzdG9yeS5vblVubG9hZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIFByZXBhcmVcblx0XHRcdFx0dmFyXHRjdXJyZW50U3RvcmUsIGl0ZW0sIGN1cnJlbnRTdG9yZVN0cmluZztcblxuXHRcdFx0XHQvLyBGZXRjaFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGN1cnJlbnRTdG9yZSA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnSGlzdG9yeS5zdG9yZScpKXx8e307XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0Y3VycmVudFN0b3JlID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFbnN1cmVcblx0XHRcdFx0Y3VycmVudFN0b3JlLmlkVG9TdGF0ZSA9IGN1cnJlbnRTdG9yZS5pZFRvU3RhdGUgfHwge307XG5cdFx0XHRcdGN1cnJlbnRTdG9yZS51cmxUb0lkID0gY3VycmVudFN0b3JlLnVybFRvSWQgfHwge307XG5cdFx0XHRcdGN1cnJlbnRTdG9yZS5zdGF0ZVRvSWQgPSBjdXJyZW50U3RvcmUuc3RhdGVUb0lkIHx8IHt9O1xuXG5cdFx0XHRcdC8vIFN5bmNcblx0XHRcdFx0Zm9yICggaXRlbSBpbiBIaXN0b3J5LmlkVG9TdGF0ZSApIHtcblx0XHRcdFx0XHRpZiAoICFIaXN0b3J5LmlkVG9TdGF0ZS5oYXNPd25Qcm9wZXJ0eShpdGVtKSApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50U3RvcmUuaWRUb1N0YXRlW2l0ZW1dID0gSGlzdG9yeS5pZFRvU3RhdGVbaXRlbV07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggaXRlbSBpbiBIaXN0b3J5LnVybFRvSWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhSGlzdG9yeS51cmxUb0lkLmhhc093blByb3BlcnR5KGl0ZW0pICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1cnJlbnRTdG9yZS51cmxUb0lkW2l0ZW1dID0gSGlzdG9yeS51cmxUb0lkW2l0ZW1dO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGl0ZW0gaW4gSGlzdG9yeS5zdGF0ZVRvSWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhSGlzdG9yeS5zdGF0ZVRvSWQuaGFzT3duUHJvcGVydHkoaXRlbSkgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VycmVudFN0b3JlLnN0YXRlVG9JZFtpdGVtXSA9IEhpc3Rvcnkuc3RhdGVUb0lkW2l0ZW1dO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlXG5cdFx0XHRcdEhpc3Rvcnkuc3RvcmUgPSBjdXJyZW50U3RvcmU7XG5cdFx0XHRcdEhpc3Rvcnkubm9ybWFsaXplU3RvcmUoKTtcblxuXHRcdFx0XHQvLyBJbiBTYWZhcmksIGdvaW5nIGludG8gUHJpdmF0ZSBCcm93c2luZyBtb2RlIGNhdXNlcyB0aGVcblx0XHRcdFx0Ly8gU2Vzc2lvbiBTdG9yYWdlIG9iamVjdCB0byBzdGlsbCBleGlzdCBidXQgaWYgeW91IHRyeSBhbmQgdXNlXG5cdFx0XHRcdC8vIG9yIHNldCBhbnkgcHJvcGVydHkvZnVuY3Rpb24gb2YgaXQgaXQgdGhyb3dzIHRoZSBleGNlcHRpb25cblx0XHRcdFx0Ly8gXCJRVU9UQV9FWENFRURFRF9FUlI6IERPTSBFeGNlcHRpb24gMjI6IEFuIGF0dGVtcHQgd2FzIG1hZGUgdG9cblx0XHRcdFx0Ly8gYWRkIHNvbWV0aGluZyB0byBzdG9yYWdlIHRoYXQgZXhjZWVkZWQgdGhlIHF1b3RhLlwiIGluZmluaXRlbHlcblx0XHRcdFx0Ly8gZXZlcnkgc2Vjb25kLlxuXHRcdFx0XHRjdXJyZW50U3RvcmVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShjdXJyZW50U3RvcmUpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFN0b3JlXG5cdFx0XHRcdFx0c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnSGlzdG9yeS5zdG9yZScsIGN1cnJlbnRTdG9yZVN0cmluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRpZiAoZS5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2Vzc2lvblN0b3JhZ2UubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdvcmthcm91bmQgZm9yIGEgYnVnIHNlZW4gb24gaVBhZHMuIFNvbWV0aW1lcyB0aGUgcXVvdGEgZXhjZWVkZWQgZXJyb3IgY29tZXMgdXAgYW5kIHNpbXBseVxuXHRcdFx0XHRcdFx0XHQvLyByZW1vdmluZy9yZXNldHRpbmcgdGhlIHN0b3JhZ2UgY2FuIHdvcmsuXG5cdFx0XHRcdFx0XHRcdHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ0hpc3Rvcnkuc3RvcmUnKTtcblx0XHRcdFx0XHRcdFx0c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnSGlzdG9yeS5zdG9yZScsIGN1cnJlbnRTdG9yZVN0cmluZyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIHdlJ3JlIHByb2JhYmx5IHByaXZhdGUgYnJvd3NpbmcgaW4gU2FmYXJpLCBzbyB3ZSdsbCBpZ25vcmUgdGhlIGV4Y2VwdGlvbi5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIEZvciBJbnRlcm5ldCBFeHBsb3JlclxuXHRcdFx0SGlzdG9yeS5pbnRlcnZhbExpc3QucHVzaChzZXRJbnRlcnZhbChIaXN0b3J5Lm9uVW5sb2FkLEhpc3Rvcnkub3B0aW9ucy5zdG9yZUludGVydmFsKSk7XG5cblx0XHRcdC8vIEZvciBPdGhlciBCcm93c2Vyc1xuXHRcdFx0SGlzdG9yeS5BZGFwdGVyLmJpbmQod2luZG93LCdiZWZvcmV1bmxvYWQnLEhpc3Rvcnkub25VbmxvYWQpO1xuXHRcdFx0SGlzdG9yeS5BZGFwdGVyLmJpbmQod2luZG93LCd1bmxvYWQnLEhpc3Rvcnkub25VbmxvYWQpO1xuXG5cdFx0XHQvLyBCb3RoIGFyZSBlbmFibGVkIGZvciBjb25zaXN0ZW5jeVxuXHRcdH1cblxuXHRcdC8vIE5vbi1OYXRpdmUgcHVzaFN0YXRlIEltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCAhSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgKSB7XG5cdFx0XHQvLyBCZSBhd2FyZSwgdGhlIGZvbGxvd2luZyBpcyBvbmx5IGZvciBuYXRpdmUgcHVzaFN0YXRlIGltcGxlbWVudGF0aW9uc1xuXHRcdFx0Ly8gSWYgeW91IGFyZSB3YW50aW5nIHRvIGluY2x1ZGUgc29tZXRoaW5nIGZvciBhbGwgYnJvd3NlcnNcblx0XHRcdC8vIFRoZW4gaW5jbHVkZSBpdCBhYm92ZSB0aGlzIGlmIGJsb2NrXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0dXAgU2FmYXJpIEZpeFxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIEhpc3RvcnkuYnVncy5zYWZhcmlQb2xsICkge1xuXHRcdFx0XHRIaXN0b3J5LmludGVydmFsTGlzdC5wdXNoKHNldEludGVydmFsKEhpc3Rvcnkuc2FmYXJpU3RhdGVQb2xsLCBIaXN0b3J5Lm9wdGlvbnMuc2FmYXJpUG9sbEludGVydmFsKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRW5zdXJlIENyb3NzIEJyb3dzZXIgQ29tcGF0aWJpbGl0eVxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIG5hdmlnYXRvci52ZW5kb3IgPT09ICdBcHBsZSBDb21wdXRlciwgSW5jLicgfHwgKG5hdmlnYXRvci5hcHBDb2RlTmFtZXx8JycpID09PSAnTW96aWxsYScgKSB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBGaXggU2FmYXJpIEhhc2hDaGFuZ2UgSXNzdWVcblx0XHRcdFx0ICovXG5cblx0XHRcdFx0Ly8gU2V0dXAgQWxpYXNcblx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLmJpbmQod2luZG93LCdoYXNoY2hhbmdlJyxmdW5jdGlvbigpe1xuXHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywncG9wc3RhdGUnKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gSW5pdGlhbGlzZSBBbGlhc1xuXHRcdFx0XHRpZiAoIEhpc3RvcnkuZ2V0SGFzaCgpICkge1xuXHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci5vbkRvbUxvYWQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywnaGFzaGNoYW5nZScpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IC8vICFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZVxuXG5cblx0fTsgLy8gSGlzdG9yeS5pbml0Q29yZVxuXG5cdC8vIFRyeSB0byBJbml0aWFsaXNlIEhpc3Rvcnlcblx0aWYgKCFIaXN0b3J5Lm9wdGlvbnMgfHwgIUhpc3Rvcnkub3B0aW9ucy5kZWxheUluaXQpIHtcblx0XHRIaXN0b3J5LmluaXQoKTtcblx0fVxuXG59KSh3aW5kb3cpO1xuIiwiLyohXG4gKiBpbWFnZXNMb2FkZWQgdjUuMC4wXG4gKiBKYXZhU2NyaXB0IGlzIGFsbCBsaWtlIFwiWW91IGltYWdlcyBhcmUgZG9uZSB5ZXQgb3Igd2hhdD9cIlxuICogTUlUIExpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHdpbmRvdywgcmVxdWlyZSgnZXYtZW1pdHRlcicpICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuaW1hZ2VzTG9hZGVkID0gZmFjdG9yeSggd2luZG93LCB3aW5kb3cuRXZFbWl0dGVyICk7XG4gIH1cblxufSApKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsXG4gICAgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIgKSB7XG5cbmxldCAkID0gd2luZG93LmpRdWVyeTtcbmxldCBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gdHVybiBlbGVtZW50IG9yIG5vZGVMaXN0IGludG8gYW4gYXJyYXlcbmZ1bmN0aW9uIG1ha2VBcnJheSggb2JqICkge1xuICAvLyB1c2Ugb2JqZWN0IGlmIGFscmVhZHkgYW4gYXJyYXlcbiAgaWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHJldHVybiBvYmo7XG5cbiAgbGV0IGlzQXJyYXlMaWtlID0gdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLmxlbmd0aCA9PSAnbnVtYmVyJztcbiAgLy8gY29udmVydCBub2RlTGlzdCB0byBhcnJheVxuICBpZiAoIGlzQXJyYXlMaWtlICkgcmV0dXJuIFsgLi4ub2JqIF07XG5cbiAgLy8gYXJyYXkgb2Ygc2luZ2xlIGluZGV4XG4gIHJldHVybiBbIG9iaiBdO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBpbWFnZXNMb2FkZWQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBAcGFyYW0ge1tBcnJheSwgRWxlbWVudCwgTm9kZUxpc3QsIFN0cmluZ119IGVsZW1cbiAqIEBwYXJhbSB7W09iamVjdCwgRnVuY3Rpb25dfSBvcHRpb25zIC0gaWYgZnVuY3Rpb24sIHVzZSBhcyBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb25BbHdheXMgLSBjYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0ltYWdlc0xvYWRlZH1cbiAqL1xuZnVuY3Rpb24gSW1hZ2VzTG9hZGVkKCBlbGVtLCBvcHRpb25zLCBvbkFsd2F5cyApIHtcbiAgLy8gY29lcmNlIEltYWdlc0xvYWRlZCgpIHdpdGhvdXQgbmV3LCB0byBiZSBuZXcgSW1hZ2VzTG9hZGVkKClcbiAgaWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgSW1hZ2VzTG9hZGVkICkgKSB7XG4gICAgcmV0dXJuIG5ldyBJbWFnZXNMb2FkZWQoIGVsZW0sIG9wdGlvbnMsIG9uQWx3YXlzICk7XG4gIH1cbiAgLy8gdXNlIGVsZW0gYXMgc2VsZWN0b3Igc3RyaW5nXG4gIGxldCBxdWVyeUVsZW0gPSBlbGVtO1xuICBpZiAoIHR5cGVvZiBlbGVtID09ICdzdHJpbmcnICkge1xuICAgIHF1ZXJ5RWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIGVsZW0gKTtcbiAgfVxuICAvLyBiYWlsIGlmIGJhZCBlbGVtZW50XG4gIGlmICggIXF1ZXJ5RWxlbSApIHtcbiAgICBjb25zb2xlLmVycm9yKGBCYWQgZWxlbWVudCBmb3IgaW1hZ2VzTG9hZGVkICR7cXVlcnlFbGVtIHx8IGVsZW19YCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lbGVtZW50cyA9IG1ha2VBcnJheSggcXVlcnlFbGVtICk7XG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICAvLyBzaGlmdCBhcmd1bWVudHMgaWYgbm8gb3B0aW9ucyBzZXRcbiAgaWYgKCB0eXBlb2Ygb3B0aW9ucyA9PSAnZnVuY3Rpb24nICkge1xuICAgIG9uQWx3YXlzID0gb3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMgKTtcbiAgfVxuXG4gIGlmICggb25BbHdheXMgKSB0aGlzLm9uKCAnYWx3YXlzJywgb25BbHdheXMgKTtcblxuICB0aGlzLmdldEltYWdlcygpO1xuICAvLyBhZGQgalF1ZXJ5IERlZmVycmVkIG9iamVjdFxuICBpZiAoICQgKSB0aGlzLmpxRGVmZXJyZWQgPSBuZXcgJC5EZWZlcnJlZCgpO1xuXG4gIC8vIEhBQ0sgY2hlY2sgYXN5bmMgdG8gYWxsb3cgdGltZSB0byBiaW5kIGxpc3RlbmVyc1xuICBzZXRUaW1lb3V0KCB0aGlzLmNoZWNrLmJpbmQoIHRoaXMgKSApO1xufVxuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmdldEltYWdlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmltYWdlcyA9IFtdO1xuXG4gIC8vIGZpbHRlciAmIGZpbmQgaXRlbXMgaWYgd2UgaGF2ZSBhbiBpdGVtIHNlbGVjdG9yXG4gIHRoaXMuZWxlbWVudHMuZm9yRWFjaCggdGhpcy5hZGRFbGVtZW50SW1hZ2VzLCB0aGlzICk7XG59O1xuXG5jb25zdCBlbGVtZW50Tm9kZVR5cGVzID0gWyAxLCA5LCAxMSBdO1xuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gZWxlbVxuICovXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmFkZEVsZW1lbnRJbWFnZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgLy8gZmlsdGVyIHNpYmxpbmdzXG4gIGlmICggZWxlbS5ub2RlTmFtZSA9PT0gJ0lNRycgKSB7XG4gICAgdGhpcy5hZGRJbWFnZSggZWxlbSApO1xuICB9XG4gIC8vIGdldCBiYWNrZ3JvdW5kIGltYWdlIG9uIGVsZW1lbnRcbiAgaWYgKCB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZCA9PT0gdHJ1ZSApIHtcbiAgICB0aGlzLmFkZEVsZW1lbnRCYWNrZ3JvdW5kSW1hZ2VzKCBlbGVtICk7XG4gIH1cblxuICAvLyBmaW5kIGNoaWxkcmVuXG4gIC8vIG5vIG5vbi1lbGVtZW50IG5vZGVzLCAjMTQzXG4gIGxldCB7IG5vZGVUeXBlIH0gPSBlbGVtO1xuICBpZiAoICFub2RlVHlwZSB8fCAhZWxlbWVudE5vZGVUeXBlcy5pbmNsdWRlcyggbm9kZVR5cGUgKSApIHJldHVybjtcblxuICBsZXQgY2hpbGRJbWdzID0gZWxlbS5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKTtcbiAgLy8gY29uY2F0IGNoaWxkRWxlbXMgdG8gZmlsdGVyRm91bmQgYXJyYXlcbiAgZm9yICggbGV0IGltZyBvZiBjaGlsZEltZ3MgKSB7XG4gICAgdGhpcy5hZGRJbWFnZSggaW1nICk7XG4gIH1cblxuICAvLyBnZXQgY2hpbGQgYmFja2dyb3VuZCBpbWFnZXNcbiAgaWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLmJhY2tncm91bmQgPT0gJ3N0cmluZycgKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbS5xdWVyeVNlbGVjdG9yQWxsKCB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZCApO1xuICAgIGZvciAoIGxldCBjaGlsZCBvZiBjaGlsZHJlbiApIHtcbiAgICAgIHRoaXMuYWRkRWxlbWVudEJhY2tncm91bmRJbWFnZXMoIGNoaWxkICk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCByZVVSTCA9IC91cmxcXCgoWydcIl0pPyguKj8pXFwxXFwpL2dpO1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmFkZEVsZW1lbnRCYWNrZ3JvdW5kSW1hZ2VzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIGxldCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcbiAgLy8gRmlyZWZveCByZXR1cm5zIG51bGwgaWYgaW4gYSBoaWRkZW4gaWZyYW1lIGh0dHBzOi8vYnVnemlsLmxhLzU0ODM5N1xuICBpZiAoICFzdHlsZSApIHJldHVybjtcblxuICAvLyBnZXQgdXJsIGluc2lkZSB1cmwoXCIuLi5cIilcbiAgbGV0IG1hdGNoZXMgPSByZVVSTC5leGVjKCBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgKTtcbiAgd2hpbGUgKCBtYXRjaGVzICE9PSBudWxsICkge1xuICAgIGxldCB1cmwgPSBtYXRjaGVzICYmIG1hdGNoZXNbMl07XG4gICAgaWYgKCB1cmwgKSB7XG4gICAgICB0aGlzLmFkZEJhY2tncm91bmQoIHVybCwgZWxlbSApO1xuICAgIH1cbiAgICBtYXRjaGVzID0gcmVVUkwuZXhlYyggc3R5bGUuYmFja2dyb3VuZEltYWdlICk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtJbWFnZX0gaW1nXG4gKi9cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiggaW1nICkge1xuICBsZXQgbG9hZGluZ0ltYWdlID0gbmV3IExvYWRpbmdJbWFnZSggaW1nICk7XG4gIHRoaXMuaW1hZ2VzLnB1c2goIGxvYWRpbmdJbWFnZSApO1xufTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5hZGRCYWNrZ3JvdW5kID0gZnVuY3Rpb24oIHVybCwgZWxlbSApIHtcbiAgbGV0IGJhY2tncm91bmQgPSBuZXcgQmFja2dyb3VuZCggdXJsLCBlbGVtICk7XG4gIHRoaXMuaW1hZ2VzLnB1c2goIGJhY2tncm91bmQgKTtcbn07XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcm9ncmVzc2VkQ291bnQgPSAwO1xuICB0aGlzLmhhc0FueUJyb2tlbiA9IGZhbHNlO1xuICAvLyBjb21wbGV0ZSBpZiBubyBpbWFnZXNcbiAgaWYgKCAhdGhpcy5pbWFnZXMubGVuZ3RoICkge1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1zdHlsZSAqL1xuICBsZXQgb25Qcm9ncmVzcyA9ICggaW1hZ2UsIGVsZW0sIG1lc3NhZ2UgKSA9PiB7XG4gICAgLy8gSEFDSyAtIENocm9tZSB0cmlnZ2VycyBldmVudCBiZWZvcmUgb2JqZWN0IHByb3BlcnRpZXMgaGF2ZSBjaGFuZ2VkLiAjODNcbiAgICBzZXRUaW1lb3V0KCAoKSA9PiB7XG4gICAgICB0aGlzLnByb2dyZXNzKCBpbWFnZSwgZWxlbSwgbWVzc2FnZSApO1xuICAgIH0gKTtcbiAgfTtcblxuICB0aGlzLmltYWdlcy5mb3JFYWNoKCBmdW5jdGlvbiggbG9hZGluZ0ltYWdlICkge1xuICAgIGxvYWRpbmdJbWFnZS5vbmNlKCAncHJvZ3Jlc3MnLCBvblByb2dyZXNzICk7XG4gICAgbG9hZGluZ0ltYWdlLmNoZWNrKCk7XG4gIH0gKTtcbn07XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiggaW1hZ2UsIGVsZW0sIG1lc3NhZ2UgKSB7XG4gIHRoaXMucHJvZ3Jlc3NlZENvdW50Kys7XG4gIHRoaXMuaGFzQW55QnJva2VuID0gdGhpcy5oYXNBbnlCcm9rZW4gfHwgIWltYWdlLmlzTG9hZGVkO1xuICAvLyBwcm9ncmVzcyBldmVudFxuICB0aGlzLmVtaXRFdmVudCggJ3Byb2dyZXNzJywgWyB0aGlzLCBpbWFnZSwgZWxlbSBdICk7XG4gIGlmICggdGhpcy5qcURlZmVycmVkICYmIHRoaXMuanFEZWZlcnJlZC5ub3RpZnkgKSB7XG4gICAgdGhpcy5qcURlZmVycmVkLm5vdGlmeSggdGhpcywgaW1hZ2UgKTtcbiAgfVxuICAvLyBjaGVjayBpZiBjb21wbGV0ZWRcbiAgaWYgKCB0aGlzLnByb2dyZXNzZWRDb3VudCA9PT0gdGhpcy5pbWFnZXMubGVuZ3RoICkge1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgfVxuXG4gIGlmICggdGhpcy5vcHRpb25zLmRlYnVnICYmIGNvbnNvbGUgKSB7XG4gICAgY29uc29sZS5sb2coIGBwcm9ncmVzczogJHttZXNzYWdlfWAsIGltYWdlLCBlbGVtICk7XG4gIH1cbn07XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgbGV0IGV2ZW50TmFtZSA9IHRoaXMuaGFzQW55QnJva2VuID8gJ2ZhaWwnIDogJ2RvbmUnO1xuICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICB0aGlzLmVtaXRFdmVudCggZXZlbnROYW1lLCBbIHRoaXMgXSApO1xuICB0aGlzLmVtaXRFdmVudCggJ2Fsd2F5cycsIFsgdGhpcyBdICk7XG4gIGlmICggdGhpcy5qcURlZmVycmVkICkge1xuICAgIGxldCBqcU1ldGhvZCA9IHRoaXMuaGFzQW55QnJva2VuID8gJ3JlamVjdCcgOiAncmVzb2x2ZSc7XG4gICAgdGhpcy5qcURlZmVycmVkWyBqcU1ldGhvZCBdKCB0aGlzICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBMb2FkaW5nSW1hZ2UoIGltZyApIHtcbiAgdGhpcy5pbWcgPSBpbWc7XG59XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgLy8gSWYgY29tcGxldGUgaXMgdHJ1ZSBhbmQgYnJvd3NlciBzdXBwb3J0cyBuYXR1cmFsIHNpemVzLFxuICAvLyB0cnkgdG8gY2hlY2sgZm9yIGltYWdlIHN0YXR1cyBtYW51YWxseS5cbiAgbGV0IGlzQ29tcGxldGUgPSB0aGlzLmdldElzSW1hZ2VDb21wbGV0ZSgpO1xuICBpZiAoIGlzQ29tcGxldGUgKSB7XG4gICAgLy8gcmVwb3J0IGJhc2VkIG9uIG5hdHVyYWxXaWR0aFxuICAgIHRoaXMuY29uZmlybSggdGhpcy5pbWcubmF0dXJhbFdpZHRoICE9PSAwLCAnbmF0dXJhbFdpZHRoJyApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIG5vbmUgb2YgdGhlIGNoZWNrcyBhYm92ZSBtYXRjaGVkLCBzaW11bGF0ZSBsb2FkaW5nIG9uIGRldGFjaGVkIGVsZW1lbnQuXG4gIHRoaXMucHJveHlJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAvLyBhZGQgY3Jvc3NPcmlnaW4gYXR0cmlidXRlLiAjMjA0XG4gIGlmICggdGhpcy5pbWcuY3Jvc3NPcmlnaW4gKSB7XG4gICAgdGhpcy5wcm94eUltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5pbWcuY3Jvc3NPcmlnaW47XG4gIH1cbiAgdGhpcy5wcm94eUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLnByb3h5SW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICAvLyBiaW5kIHRvIGltYWdlIGFzIHdlbGwgZm9yIEZpcmVmb3guICMxOTFcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMuaW1nLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbiAgdGhpcy5wcm94eUltYWdlLnNyYyA9IHRoaXMuaW1nLmN1cnJlbnRTcmMgfHwgdGhpcy5pbWcuc3JjO1xufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5nZXRJc0ltYWdlQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gY2hlY2sgZm9yIG5vbi16ZXJvLCBub24tdW5kZWZpbmVkIG5hdHVyYWxXaWR0aFxuICAvLyBmaXhlcyBTYWZhcmkrSW5maW5pdGVTY3JvbGwrTWFzb25yeSBidWcgaW5maW5pdGUtc2Nyb2xsIzY3MVxuICByZXR1cm4gdGhpcy5pbWcuY29tcGxldGUgJiYgdGhpcy5pbWcubmF0dXJhbFdpZHRoO1xufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24oIGlzTG9hZGVkLCBtZXNzYWdlICkge1xuICB0aGlzLmlzTG9hZGVkID0gaXNMb2FkZWQ7XG4gIGxldCB7IHBhcmVudE5vZGUgfSA9IHRoaXMuaW1nO1xuICAvLyBlbWl0IHByb2dyZXNzIHdpdGggcGFyZW50IDxwaWN0dXJlPiBvciBzZWxmIDxpbWc+XG4gIGxldCBlbGVtID0gcGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ1BJQ1RVUkUnID8gcGFyZW50Tm9kZSA6IHRoaXMuaW1nO1xuICB0aGlzLmVtaXRFdmVudCggJ3Byb2dyZXNzJywgWyB0aGlzLCBlbGVtLCBtZXNzYWdlIF0gKTtcbn07XG5cbi8vIC0tLS0tIGV2ZW50cyAtLS0tLSAvL1xuXG4vLyB0cmlnZ2VyIHNwZWNpZmllZCBoYW5kbGVyIGZvciBldmVudCB0eXBlXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBsZXQgbWV0aG9kID0gJ29uJyArIGV2ZW50LnR5cGU7XG4gIGlmICggdGhpc1sgbWV0aG9kIF0gKSB7XG4gICAgdGhpc1sgbWV0aG9kIF0oIGV2ZW50ICk7XG4gIH1cbn07XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29uZmlybSggdHJ1ZSwgJ29ubG9hZCcgKTtcbiAgdGhpcy51bmJpbmRFdmVudHMoKTtcbn07XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbmZpcm0oIGZhbHNlLCAnb25lcnJvcicgKTtcbiAgdGhpcy51bmJpbmRFdmVudHMoKTtcbn07XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUudW5iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucHJveHlJbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5wcm94eUltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbiAgdGhpcy5pbWcucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEJhY2tncm91bmQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gQmFja2dyb3VuZCggdXJsLCBlbGVtZW50ICkge1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5pbWcgPSBuZXcgSW1hZ2UoKTtcbn1cblxuLy8gaW5oZXJpdCBMb2FkaW5nSW1hZ2UgcHJvdG90eXBlXG5CYWNrZ3JvdW5kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExvYWRpbmdJbWFnZS5wcm90b3R5cGUgKTtcblxuQmFja2dyb3VuZC5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMuaW1nLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbiAgdGhpcy5pbWcuc3JjID0gdGhpcy51cmw7XG4gIC8vIGNoZWNrIGlmIGltYWdlIGlzIGFscmVhZHkgY29tcGxldGVcbiAgbGV0IGlzQ29tcGxldGUgPSB0aGlzLmdldElzSW1hZ2VDb21wbGV0ZSgpO1xuICBpZiAoIGlzQ29tcGxldGUgKSB7XG4gICAgdGhpcy5jb25maXJtKCB0aGlzLmltZy5uYXR1cmFsV2lkdGggIT09IDAsICduYXR1cmFsV2lkdGgnICk7XG4gICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgfVxufTtcblxuQmFja2dyb3VuZC5wcm90b3R5cGUudW5iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLmltZy5yZW1vdmVFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG59O1xuXG5CYWNrZ3JvdW5kLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24oIGlzTG9hZGVkLCBtZXNzYWdlICkge1xuICB0aGlzLmlzTG9hZGVkID0gaXNMb2FkZWQ7XG4gIHRoaXMuZW1pdEV2ZW50KCAncHJvZ3Jlc3MnLCBbIHRoaXMsIHRoaXMuZWxlbWVudCwgbWVzc2FnZSBdICk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBqUXVlcnkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuSW1hZ2VzTG9hZGVkLm1ha2VKUXVlcnlQbHVnaW4gPSBmdW5jdGlvbiggalF1ZXJ5ICkge1xuICBqUXVlcnkgPSBqUXVlcnkgfHwgd2luZG93LmpRdWVyeTtcbiAgaWYgKCAhalF1ZXJ5ICkgcmV0dXJuO1xuXG4gIC8vIHNldCBsb2NhbCB2YXJpYWJsZVxuICAkID0galF1ZXJ5O1xuICAvLyAkKCkuaW1hZ2VzTG9hZGVkKClcbiAgJC5mbi5pbWFnZXNMb2FkZWQgPSBmdW5jdGlvbiggb3B0aW9ucywgb25BbHdheXMgKSB7XG4gICAgbGV0IGluc3RhbmNlID0gbmV3IEltYWdlc0xvYWRlZCggdGhpcywgb3B0aW9ucywgb25BbHdheXMgKTtcbiAgICByZXR1cm4gaW5zdGFuY2UuanFEZWZlcnJlZC5wcm9taXNlKCAkKCB0aGlzICkgKTtcbiAgfTtcbn07XG4vLyB0cnkgbWFraW5nIHBsdWdpblxuSW1hZ2VzTG9hZGVkLm1ha2VKUXVlcnlQbHVnaW4oKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnJldHVybiBJbWFnZXNMb2FkZWQ7XG5cbn0gKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiAhKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgIT09IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSB8fCB2YWx1ZSA9PT0gLUluZmluaXR5KTtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2VzNi1zaGltXG4vLyBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIuaXNpbnRlZ2VyXG52YXIgaXNGaW5pdGUgPSByZXF1aXJlKFwiaXMtZmluaXRlXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJlxuICAgIGlzRmluaXRlKHZhbCkgJiZcbiAgICBNYXRoLmZsb29yKHZhbCkgPT09IHZhbDtcbn07XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJ2lzLWludGVnZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVmFsaWRNb250aCAobW9udGgpIHtcbiAgaWYgKHR5cGVvZiBtb250aCAhPT0gJ251bWJlcicgfHwgIWlzSW50ZWdlcihtb250aCkpIHJldHVybiBmYWxzZVxuICByZXR1cm4gbW9udGggPj0gMSAmJiBtb250aCA8PSAxMlxufVxuIiwiLyohXG4gKiBSZXZlYWxlciAzLjAuMFxuICpcbiAqIENvcHlyaWdodCAyMDIxLCBQaXhlbCBVbmlvbiAtIGh0dHA6Ly9waXhlbHVuaW9uLm5ldFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbihmdW5jdGlvbigkKXtcbiAgLy8gY2hlY2sgZm9yIHRyZW5kIGV2ZW50IChtYWtlIHN1cmUganF1ZXJ5LnRyZW5kIGlzIGluY2x1ZGVkKVxuICBpZiAodHlwZW9mICQuZXZlbnQuc3BlY2lhbC50cmVuZCAhPT0gXCJvYmplY3RcIikge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBtYWtlIHN1cmUganF1ZXJ5LnRyZW5kIGlzIGluY2x1ZGVkISBPdGhlcndpc2UgcmV2ZWFsZXIgd29uJ3Qgd29yay5cIik7XG4gIH1cblxuICAvLyBTaW1wbGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsXG4gIHZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBmdW5jdGlvbihmbikgeyB3aW5kb3cuc2V0VGltZW91dChmbiwgMTAwMC82MCk7IH1cblxuXG4gIC8vIFB1YmxpYyBBUElcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuICEhZWwuZGF0YShcInJldmVhbGVyLXZpc2libGVcIik7XG4gICAgfSxcblxuICAgIHNob3c6IGZ1bmN0aW9uKGVsLCBmb3JjZSkge1xuICAgICAgLy8gQ2hlY2sgc3RhdGVcbiAgICAgIGlmIChtZXRob2RzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLWluXCIpO1xuICAgICAgICBlbC5vZmYoXCJyZXZlYWxlci1hbmltYXRpbmcgcmV2ZWFsZXItc2hvd1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgcHJldmlvdXMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBlbC5kYXRhKFwicmV2ZWFsZXItdmlzaWJsZVwiLCB0cnVlKTtcbiAgICAgIGVsLm9mZihcInRyZW5kXCIpO1xuXG4gICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgZWwuYWRkQ2xhc3MoXCJ2aXNpYmxlXCIpO1xuICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItYW5pbWF0aW5nXCIpO1xuICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1zaG93XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gU3RhcnQgYW5pbWF0aW9uIHN0YXRlIHRyYW5zaXRpb25cbiAgICAgICAgZWwuYWRkQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLWluXCIpO1xuICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItYW5pbWF0aW5nXCIpO1xuXG4gICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgIGVsLmFkZENsYXNzKFwidmlzaWJsZVwiKTtcblxuICAgICAgICAgIGVsLm9uZShcInRyZW5kXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBlbC5yZW1vdmVDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctaW5cIik7XG4gICAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItc2hvd1wiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oZWwsIGZvcmNlKSB7XG4gICAgICAvLyBDaGVjayBzdGF0ZVxuICAgICAgaWYgKCFtZXRob2RzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLW91dCB2aXNpYmxlXCIpO1xuICAgICAgICBlbC5vZmYoXCJyZXZlYWxlci1hbmltYXRpbmcgcmV2ZWFsZXItaGlkZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgcHJldmlvdXMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBlbC5kYXRhKFwicmV2ZWFsZXItdmlzaWJsZVwiLCBmYWxzZSk7XG4gICAgICBlbC5vZmYoXCJ0cmVuZFwiKTtcblxuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgIGVsLnJlbW92ZUNsYXNzKFwidmlzaWJsZVwiKTtcbiAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWFuaW1hdGluZ1wiKTtcbiAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItaGlkZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgIGVsLmFkZENsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1vdXRcIik7XG4gICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1hbmltYXRpbmdcIik7XG5cbiAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJ2aXNpYmxlXCIpO1xuXG4gICAgICAgICAgZWwub25lKFwidHJlbmRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1pbiBhbmltYXRpbmctb3V0XCIpO1xuICAgICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWhpZGVcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRvZ2dsZTogZnVuY3Rpb24oZWwsIGZvcmNlKSB7XG4gICAgICBpZiAobWV0aG9kcy5pc1Zpc2libGUoZWwpKSB7XG4gICAgICAgIG1ldGhvZHMuaGlkZShlbCwgZm9yY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0aG9kcy5zaG93KGVsLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGpRdWVyeSBwbHVnaW5cbiAgJC5mbi5yZXZlYWxlciA9IGZ1bmN0aW9uKG1ldGhvZCwgZm9yY2UpIHtcbiAgICAvLyBHZXQgYWN0aW9uXG4gICAgdmFyIGFjdGlvbiA9IG1ldGhvZHNbbWV0aG9kIHx8IFwidG9nZ2xlXCJdO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gdGhpcztcblxuICAgIC8vIFJ1biBhY3Rpb25cbiAgICBpZiAobWV0aG9kID09PSBcImlzVmlzaWJsZVwiKSB7XG4gICAgICByZXR1cm4gYWN0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIGFjdGlvbigkKHRoaXMpLCBmb3JjZSk7XG4gICAgfSk7XG4gIH07XG59KShqUXVlcnkpO1xuIiwiLyohXG4gKiBUcmVuZCAxLjAuMFxuICpcbiAqIEZhaWwtc2FmZSBUcmFuc2l0aW9uRW5kIGV2ZW50IGZvciBqUXVlcnkuXG4gKlxuICogQWRkcyBhIG5ldyBcInRyZW5kXCIgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCBpbiBicm93c2VycyB0aGF0IGRvbid0XG4gKiBzdXBwb3J0IFwidHJhbnNpdGlvbmVuZFwiLlxuICpcbiAqIE5PVEU6IE9ubHkgc3VwcG9ydHMgYmVpbmcgYm91bmQgd2l0aCBcImpRdWVyeS5vbmVcIi5cbiAqXG4gKiBDb3B5cmlnaHQgMjAyMSwgUGl4ZWwgVW5pb24gLSBodHRwOi8vcGl4ZWx1bmlvbi5uZXRcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG47KGZ1bmN0aW9uKCQpe1xuXG4gIC8vIFByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZXNcbiAgdmFyIHRyYW5zaXRpb25FbmRFdmVudHMgPVxuICAgIFwid2Via2l0VHJhbnNpdGlvbkVuZCBcIiArXG4gICAgXCJvdHJhbnNpdGlvbmVuZCBcIiArXG4gICAgXCJvVHJhbnNpdGlvbkVuZCBcIiArXG4gICAgXCJtc1RyYW5zaXRpb25FbmQgXCIgK1xuICAgIFwidHJhbnNpdGlvbmVuZFwiO1xuXG4gIC8vIFByZWZpeGVkIHRyYW5zaXRpb24gZHVyYXRpb24gcHJvcGVydHkgbmFtZXNcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvblByb3BlcnRpZXMgPSBbXG4gICAgXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItbW96LXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi13ZWJraXQtdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLW1zLXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1vLXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1raHRtbC10cmFuc2l0aW9uLWR1cmF0aW9uXCJcbiAgXTtcblxuICAvLyBQcmVmaXhlZCB0cmFuc2l0aW9uIGRlbGF5IHByb3BlcnR5IG5hbWVzXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlQcm9wZXJ0aWVzID0gW1xuICAgIFwidHJhbnNpdGlvbi1kZWxheVwiLFxuICAgIFwiLW1vei10cmFuc2l0aW9uLWRlbGF5XCIsXG4gICAgXCItd2Via2l0LXRyYW5zaXRpb24tZGVsYXlcIixcbiAgICBcIi1tcy10cmFuc2l0aW9uLWRlbGF5XCIsXG4gICAgXCItby10cmFuc2l0aW9uLWRlbGF5XCIsXG4gICAgXCIta2h0bWwtdHJhbnNpdGlvbi1kZWxheVwiXG4gIF07XG5cbiAgLy8gUGFyc2VzIGEgQ1NTIHRpbWUgdmFsdWUgaW50byBtaWxsaXNlY29uZHMuXG4gIHZhciBwYXJzZVRpbWUgPSBmdW5jdGlvbihzKSB7XG4gICAgcyA9IHMucmVwbGFjZSgvXFxzLywgXCJcIik7XG4gICAgdmFyIHYgPSB3aW5kb3cucGFyc2VGbG9hdChzKTtcblxuICAgIHJldHVybiBzLm1hdGNoKC9bXm1dcyQvaSlcbiAgICAgID8gdiAqIDEwMDBcbiAgICAgIDogdjtcbiAgfTtcblxuICAvLyBQYXJzZXMgdGhlIGxvbmdlc3QgdGltZSB1bml0IGZvdW5kIGluIGEgc2VyaWVzIG9mIENTUyBwcm9wZXJ0aWVzLlxuICAvLyBSZXR1cm5zIGEgdmFsdWUgaW4gbWlsbGlzZWNvbmRzLlxuICB2YXIgcGFyc2VQcm9wZXJ0aWVzID0gZnVuY3Rpb24oZWwsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgZHVyYXRpb24gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBHZXQgcmF3IENTUyB2YWx1ZVxuICAgICAgdmFyIHZhbHVlID0gZWwuY3NzKHByb3BlcnRpZXNbaV0pO1xuICAgICAgaWYgKCF2YWx1ZSkgY29udGludWU7XG5cbiAgICAgIC8vIE11bHRpcGxlIHRyYW5zaXRpb25zLS1waWNrIHRoZSBsb25nZXN0XG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihcIixcIikgIT09IC0xKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgIHZhciBkdXJhdGlvbnMgPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBwYXJzZVRpbWUodmFsdWVzW2ldKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChkdXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZHVyYXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2luZ2xlIHRyYW5zaXRpb25cbiAgICAgIGVsc2Uge1xuICAgICAgICBkdXJhdGlvbiA9IHBhcnNlVGltZSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFjY2VwdCBmaXJzdCB2YXVlXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH07XG5cbiAgJC5ldmVudC5zcGVjaWFsLnRyZW5kID0ge1xuICAgIC8vIFRyaWdnZXJzIGFuIGV2ZW50IGhhbmRsZXIgd2hlbiBhbiBlbGVtZW50IGlzIGRvbmUgdHJhbnNpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIEhhbmRsZXMgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRyYW5zaXRpb25lbmQgYnkgYWRkaW5nIGFcbiAgICAvLyB0aW1lb3V0IHdpdGggdGhlIHRyYW5zaXRpb24gZHVyYXRpb24uXG4gICAgYWRkOiBmdW5jdGlvbihoYW5kbGVPYmopIHtcbiAgICAgIHZhciBlbCA9ICQodGhpcyk7XG4gICAgICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICAgICAgLy8gTWFyayBlbGVtZW50IGFzIGJlaW5nIGluIHRyYW5zaXRpb25cbiAgICAgIGVsLmRhdGEoXCJ0cmVuZFwiLCB0cnVlKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGEgZmFsbGJhY2sgZHVyYXRpb24uICsgMjAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGZpcmVcbiAgICAgIC8vIHRpbWVvdXRzIGZhc3RlciB0aGFuIHRyYW5zaXRpb25lbmQuXG4gICAgICB2YXIgdGltZSA9XG4gICAgICAgIHBhcnNlUHJvcGVydGllcyhlbCwgdHJhbnNpdGlvbkR1cmF0aW9uUHJvcGVydGllcykgK1xuICAgICAgICBwYXJzZVByb3BlcnRpZXMoZWwsIHRyYW5zaXRpb25EZWxheVByb3BlcnRpZXMpICtcbiAgICAgICAgMjA7XG5cbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gdHJhbnNpdGlvbmVuZCBldmVudHMgY2FuIGJlIHNlbnQgZm9yIGVhY2ggcHJvcGVydHkuIExldCdzIGp1c3RcbiAgICAgICAgLy8gc2tpcCBhbGwgYnV0IHRoZSBmaXJzdC4gQWxzbyBoYW5kbGVzIHRoZSB0aW1lb3V0IGNhbGxiYWNrLlxuICAgICAgICBpZiAoZmlyZWQpIHJldHVybjtcblxuICAgICAgICAvLyBDaGlsZCBlbGVtZW50cyB0aGF0IGFsc28gaGF2ZSB0cmFuc2l0aW9ucyBjYW4gYmUgZmlyZWQgYmVmb3JlIHdlXG4gICAgICAgIC8vIGNvbXBsZXRlLiBUaGlzIHdpbGwgY2F0Y2ggYW5kIGlnbm9yZSB0aG9zZS4gVW5mb3J0dW5hdGVseSwgd2UnbGxcbiAgICAgICAgLy8gaGF2ZSB0byByZWx5IG9uIHRoZSB0aW1lb3V0IGluIHRoZXNlIGNhc2VzLlxuICAgICAgICBpZiAoZSAmJiBlLnNyY0VsZW1lbnQgIT09IGVsWzBdKSByZXR1cm47XG5cbiAgICAgICAgLy8gTWFyayBlbGVtZW50IGhhcyBub3QgYmVpbmcgaW4gdHJhbnNpdGlvblxuICAgICAgICBlbC5kYXRhKFwidHJlbmRcIiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIENhbGxiYWNrXG4gICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhbmRsZU9iai5oYW5kbGVyKSBoYW5kbGVPYmouaGFuZGxlcigpO1xuICAgICAgfTtcblxuICAgICAgZWwub25lKHRyYW5zaXRpb25FbmRFdmVudHMsIGNiKTtcbiAgICAgIGVsLmRhdGEoXCJ0cmVuZC10aW1lb3V0XCIsIHdpbmRvdy5zZXRUaW1lb3V0KGNiLCB0aW1lKSk7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oaGFuZGxlT2JqKSB7XG4gICAgICB2YXIgZWwgPSAkKHRoaXMpO1xuICAgICAgZWwub2ZmKHRyYW5zaXRpb25FbmRFdmVudHMpO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChlbC5kYXRhKFwidHJlbmQtdGltZW91dFwiKSk7XG4gICAgfVxuICB9O1xuXG59KShqUXVlcnkpO1xuIiwiLyohIGpRdWVyeSB2My43LjEgfCAoYykgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IGpxdWVyeS5vcmcvbGljZW5zZSAqL1xuIWZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7XCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWUuZG9jdW1lbnQ/dChlLCEwKTpmdW5jdGlvbihlKXtpZighZS5kb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO3JldHVybiB0KGUpfTp0KGUpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp0aGlzLGZ1bmN0aW9uKGllLGUpe1widXNlIHN0cmljdFwiO3ZhciBvZT1bXSxyPU9iamVjdC5nZXRQcm90b3R5cGVPZixhZT1vZS5zbGljZSxnPW9lLmZsYXQ/ZnVuY3Rpb24oZSl7cmV0dXJuIG9lLmZsYXQuY2FsbChlKX06ZnVuY3Rpb24oZSl7cmV0dXJuIG9lLmNvbmNhdC5hcHBseShbXSxlKX0scz1vZS5wdXNoLHNlPW9lLmluZGV4T2Ysbj17fSxpPW4udG9TdHJpbmcsdWU9bi5oYXNPd25Qcm9wZXJ0eSxvPXVlLnRvU3RyaW5nLGE9by5jYWxsKE9iamVjdCksbGU9e30sdj1mdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZcIm51bWJlclwiIT10eXBlb2YgZS5ub2RlVHlwZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZS5pdGVtfSx5PWZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lJiZlPT09ZS53aW5kb3d9LEM9aWUuZG9jdW1lbnQsdT17dHlwZTohMCxzcmM6ITAsbm9uY2U6ITAsbm9Nb2R1bGU6ITB9O2Z1bmN0aW9uIG0oZSx0LG4pe3ZhciByLGksbz0obj1ufHxDKS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2lmKG8udGV4dD1lLHQpZm9yKHIgaW4gdSkoaT10W3JdfHx0LmdldEF0dHJpYnV0ZSYmdC5nZXRBdHRyaWJ1dGUocikpJiZvLnNldEF0dHJpYnV0ZShyLGkpO24uaGVhZC5hcHBlbmRDaGlsZChvKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pfWZ1bmN0aW9uIHgoZSl7cmV0dXJuIG51bGw9PWU/ZStcIlwiOlwib2JqZWN0XCI9PXR5cGVvZiBlfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP25baS5jYWxsKGUpXXx8XCJvYmplY3RcIjp0eXBlb2YgZX12YXIgdD1cIjMuNy4xXCIsbD0vSFRNTCQvaSxjZT1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgY2UuZm4uaW5pdChlLHQpfTtmdW5jdGlvbiBjKGUpe3ZhciB0PSEhZSYmXCJsZW5ndGhcImluIGUmJmUubGVuZ3RoLG49eChlKTtyZXR1cm4hdihlKSYmIXkoZSkmJihcImFycmF5XCI9PT1ufHwwPT09dHx8XCJudW1iZXJcIj09dHlwZW9mIHQmJjA8dCYmdC0xIGluIGUpfWZ1bmN0aW9uIGZlKGUsdCl7cmV0dXJuIGUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PXQudG9Mb3dlckNhc2UoKX1jZS5mbj1jZS5wcm90b3R5cGU9e2pxdWVyeTp0LGNvbnN0cnVjdG9yOmNlLGxlbmd0aDowLHRvQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gYWUuY2FsbCh0aGlzKX0sZ2V0OmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP2FlLmNhbGwodGhpcyk6ZTwwP3RoaXNbZSt0aGlzLmxlbmd0aF06dGhpc1tlXX0scHVzaFN0YWNrOmZ1bmN0aW9uKGUpe3ZhciB0PWNlLm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSxlKTtyZXR1cm4gdC5wcmV2T2JqZWN0PXRoaXMsdH0sZWFjaDpmdW5jdGlvbihlKXtyZXR1cm4gY2UuZWFjaCh0aGlzLGUpfSxtYXA6ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGNlLm1hcCh0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIG4uY2FsbChlLHQsZSl9KSl9LHNsaWNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGFlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9LGZpcnN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoMCl9LGxhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcSgtMSl9LGV2ZW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soY2UuZ3JlcCh0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuKHQrMSklMn0pKX0sb2RkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGNlLmdyZXAodGhpcyxmdW5jdGlvbihlLHQpe3JldHVybiB0JTJ9KSl9LGVxOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMubGVuZ3RoLG49K2UrKGU8MD90OjApO3JldHVybiB0aGlzLnB1c2hTdGFjaygwPD1uJiZuPHQ/W3RoaXNbbl1dOltdKX0sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJldk9iamVjdHx8dGhpcy5jb25zdHJ1Y3RvcigpfSxwdXNoOnMsc29ydDpvZS5zb3J0LHNwbGljZTpvZS5zcGxpY2V9LGNlLmV4dGVuZD1jZS5mbi5leHRlbmQ9ZnVuY3Rpb24oKXt2YXIgZSx0LG4scixpLG8sYT1hcmd1bWVudHNbMF18fHt9LHM9MSx1PWFyZ3VtZW50cy5sZW5ndGgsbD0hMTtmb3IoXCJib29sZWFuXCI9PXR5cGVvZiBhJiYobD1hLGE9YXJndW1lbnRzW3NdfHx7fSxzKyspLFwib2JqZWN0XCI9PXR5cGVvZiBhfHx2KGEpfHwoYT17fSkscz09PXUmJihhPXRoaXMscy0tKTtzPHU7cysrKWlmKG51bGwhPShlPWFyZ3VtZW50c1tzXSkpZm9yKHQgaW4gZSlyPWVbdF0sXCJfX3Byb3RvX19cIiE9PXQmJmEhPT1yJiYobCYmciYmKGNlLmlzUGxhaW5PYmplY3Qocil8fChpPUFycmF5LmlzQXJyYXkocikpKT8obj1hW3RdLG89aSYmIUFycmF5LmlzQXJyYXkobik/W106aXx8Y2UuaXNQbGFpbk9iamVjdChuKT9uOnt9LGk9ITEsYVt0XT1jZS5leHRlbmQobCxvLHIpKTp2b2lkIDAhPT1yJiYoYVt0XT1yKSk7cmV0dXJuIGF9LGNlLmV4dGVuZCh7ZXhwYW5kbzpcImpRdWVyeVwiKyh0K01hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLFwiXCIpLGlzUmVhZHk6ITAsZXJyb3I6ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKGUpfSxub29wOmZ1bmN0aW9uKCl7fSxpc1BsYWluT2JqZWN0OmZ1bmN0aW9uKGUpe3ZhciB0LG47cmV0dXJuISghZXx8XCJbb2JqZWN0IE9iamVjdF1cIiE9PWkuY2FsbChlKSkmJighKHQ9cihlKSl8fFwiZnVuY3Rpb25cIj09dHlwZW9mKG49dWUuY2FsbCh0LFwiY29uc3RydWN0b3JcIikmJnQuY29uc3RydWN0b3IpJiZvLmNhbGwobik9PT1hKX0saXNFbXB0eU9iamVjdDpmdW5jdGlvbihlKXt2YXIgdDtmb3IodCBpbiBlKXJldHVybiExO3JldHVybiEwfSxnbG9iYWxFdmFsOmZ1bmN0aW9uKGUsdCxuKXttKGUse25vbmNlOnQmJnQubm9uY2V9LG4pfSxlYWNoOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj0wO2lmKGMoZSkpe2ZvcihuPWUubGVuZ3RoO3I8bjtyKyspaWYoITE9PT10LmNhbGwoZVtyXSxyLGVbcl0pKWJyZWFrfWVsc2UgZm9yKHIgaW4gZSlpZighMT09PXQuY2FsbChlW3JdLHIsZVtyXSkpYnJlYWs7cmV0dXJuIGV9LHRleHQ6ZnVuY3Rpb24oZSl7dmFyIHQsbj1cIlwiLHI9MCxpPWUubm9kZVR5cGU7aWYoIWkpd2hpbGUodD1lW3IrK10pbis9Y2UudGV4dCh0KTtyZXR1cm4gMT09PWl8fDExPT09aT9lLnRleHRDb250ZW50Ojk9PT1pP2UuZG9jdW1lbnRFbGVtZW50LnRleHRDb250ZW50OjM9PT1pfHw0PT09aT9lLm5vZGVWYWx1ZTpufSxtYWtlQXJyYXk6ZnVuY3Rpb24oZSx0KXt2YXIgbj10fHxbXTtyZXR1cm4gbnVsbCE9ZSYmKGMoT2JqZWN0KGUpKT9jZS5tZXJnZShuLFwic3RyaW5nXCI9PXR5cGVvZiBlP1tlXTplKTpzLmNhbGwobixlKSksbn0saW5BcnJheTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIG51bGw9PXQ/LTE6c2UuY2FsbCh0LGUsbil9LGlzWE1MRG9jOmZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUubmFtZXNwYWNlVVJJLG49ZSYmKGUub3duZXJEb2N1bWVudHx8ZSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiFsLnRlc3QodHx8biYmbi5ub2RlTmFtZXx8XCJIVE1MXCIpfSxtZXJnZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0rdC5sZW5ndGgscj0wLGk9ZS5sZW5ndGg7cjxuO3IrKyllW2krK109dFtyXTtyZXR1cm4gZS5sZW5ndGg9aSxlfSxncmVwOmZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHI9W10saT0wLG89ZS5sZW5ndGgsYT0hbjtpPG87aSsrKSF0KGVbaV0saSkhPT1hJiZyLnB1c2goZVtpXSk7cmV0dXJuIHJ9LG1hcDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPTAsYT1bXTtpZihjKGUpKWZvcihyPWUubGVuZ3RoO288cjtvKyspbnVsbCE9KGk9dChlW29dLG8sbikpJiZhLnB1c2goaSk7ZWxzZSBmb3IobyBpbiBlKW51bGwhPShpPXQoZVtvXSxvLG4pKSYmYS5wdXNoKGkpO3JldHVybiBnKGEpfSxndWlkOjEsc3VwcG9ydDpsZX0pLFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKGNlLmZuW1N5bWJvbC5pdGVyYXRvcl09b2VbU3ltYm9sLml0ZXJhdG9yXSksY2UuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGUsdCl7bltcIltvYmplY3QgXCIrdCtcIl1cIl09dC50b0xvd2VyQ2FzZSgpfSk7dmFyIHBlPW9lLnBvcCxkZT1vZS5zb3J0LGhlPW9lLnNwbGljZSxnZT1cIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsdmU9bmV3IFJlZ0V4cChcIl5cIitnZStcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIrZ2UrXCIrJFwiLFwiZ1wiKTtjZS5jb250YWlucz1mdW5jdGlvbihlLHQpe3ZhciBuPXQmJnQucGFyZW50Tm9kZTtyZXR1cm4gZT09PW58fCEoIW58fDEhPT1uLm5vZGVUeXBlfHwhKGUuY29udGFpbnM/ZS5jb250YWlucyhuKTplLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uJiYxNiZlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG4pKSl9O3ZhciBmPS8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxceDgwLVxcdUZGRkZcXHctXS9nO2Z1bmN0aW9uIHAoZSx0KXtyZXR1cm4gdD9cIlxcMFwiPT09ZT9cIlxcdWZmZmRcIjplLnNsaWNlKDAsLTEpK1wiXFxcXFwiK2UuY2hhckNvZGVBdChlLmxlbmd0aC0xKS50b1N0cmluZygxNikrXCIgXCI6XCJcXFxcXCIrZX1jZS5lc2NhcGVTZWxlY3Rvcj1mdW5jdGlvbihlKXtyZXR1cm4oZStcIlwiKS5yZXBsYWNlKGYscCl9O3ZhciB5ZT1DLG1lPXM7IWZ1bmN0aW9uKCl7dmFyIGUsYix3LG8sYSxULHIsQyxkLGksaz1tZSxTPWNlLmV4cGFuZG8sRT0wLG49MCxzPVcoKSxjPVcoKSx1PVcoKSxoPVcoKSxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9PT10JiYoYT0hMCksMH0sZj1cImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsdD1cIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIrZ2UrXCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixwPVwiXFxcXFtcIitnZStcIiooXCIrdCtcIikoPzpcIitnZStcIiooWypeJHwhfl0/PSlcIitnZStcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiK3QrXCIpKXwpXCIrZ2UrXCIqXFxcXF1cIixnPVwiOihcIit0K1wiKSg/OlxcXFwoKCgnKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIitwK1wiKSopfC4qKVxcXFwpfClcIix2PW5ldyBSZWdFeHAoZ2UrXCIrXCIsXCJnXCIpLHk9bmV3IFJlZ0V4cChcIl5cIitnZStcIiosXCIrZ2UrXCIqXCIpLG09bmV3IFJlZ0V4cChcIl5cIitnZStcIiooWz4rfl18XCIrZ2UrXCIpXCIrZ2UrXCIqXCIpLHg9bmV3IFJlZ0V4cChnZStcInw+XCIpLGo9bmV3IFJlZ0V4cChnKSxBPW5ldyBSZWdFeHAoXCJeXCIrdCtcIiRcIiksRD17SUQ6bmV3IFJlZ0V4cChcIl4jKFwiK3QrXCIpXCIpLENMQVNTOm5ldyBSZWdFeHAoXCJeXFxcXC4oXCIrdCtcIilcIiksVEFHOm5ldyBSZWdFeHAoXCJeKFwiK3QrXCJ8WypdKVwiKSxBVFRSOm5ldyBSZWdFeHAoXCJeXCIrcCksUFNFVURPOm5ldyBSZWdFeHAoXCJeXCIrZyksQ0hJTEQ6bmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIrZ2UrXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIitnZStcIiooPzooWystXXwpXCIrZ2UrXCIqKFxcXFxkKyl8KSlcIitnZStcIipcXFxcKXwpXCIsXCJpXCIpLGJvb2w6bmV3IFJlZ0V4cChcIl4oPzpcIitmK1wiKSRcIixcImlcIiksbmVlZHNDb250ZXh0Om5ldyBSZWdFeHAoXCJeXCIrZ2UrXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiK2dlK1wiKigoPzotXFxcXGQpP1xcXFxkKilcIitnZStcIipcXFxcKXwpKD89W14tXXwkKVwiLFwiaVwiKX0sTj0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLHE9L15oXFxkJC9pLEw9L14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sSD0vWyt+XS8sTz1uZXcgUmVnRXhwKFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIitnZStcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLFwiZ1wiKSxQPWZ1bmN0aW9uKGUsdCl7dmFyIG49XCIweFwiK2Uuc2xpY2UoMSktNjU1MzY7cmV0dXJuIHR8fChuPDA/U3RyaW5nLmZyb21DaGFyQ29kZShuKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKG4+PjEwfDU1Mjk2LDEwMjMmbnw1NjMyMCkpfSxNPWZ1bmN0aW9uKCl7VigpfSxSPUooZnVuY3Rpb24oZSl7cmV0dXJuITA9PT1lLmRpc2FibGVkJiZmZShlLFwiZmllbGRzZXRcIil9LHtkaXI6XCJwYXJlbnROb2RlXCIsbmV4dDpcImxlZ2VuZFwifSk7dHJ5e2suYXBwbHkob2U9YWUuY2FsbCh5ZS5jaGlsZE5vZGVzKSx5ZS5jaGlsZE5vZGVzKSxvZVt5ZS5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGV9Y2F0Y2goZSl7az17YXBwbHk6ZnVuY3Rpb24oZSx0KXttZS5hcHBseShlLGFlLmNhbGwodCkpfSxjYWxsOmZ1bmN0aW9uKGUpe21lLmFwcGx5KGUsYWUuY2FsbChhcmd1bWVudHMsMSkpfX19ZnVuY3Rpb24gSSh0LGUsbixyKXt2YXIgaSxvLGEscyx1LGwsYyxmPWUmJmUub3duZXJEb2N1bWVudCxwPWU/ZS5ub2RlVHlwZTo5O2lmKG49bnx8W10sXCJzdHJpbmdcIiE9dHlwZW9mIHR8fCF0fHwxIT09cCYmOSE9PXAmJjExIT09cClyZXR1cm4gbjtpZighciYmKFYoZSksZT1lfHxULEMpKXtpZigxMSE9PXAmJih1PUwuZXhlYyh0KSkpaWYoaT11WzFdKXtpZig5PT09cCl7aWYoIShhPWUuZ2V0RWxlbWVudEJ5SWQoaSkpKXJldHVybiBuO2lmKGEuaWQ9PT1pKXJldHVybiBrLmNhbGwobixhKSxufWVsc2UgaWYoZiYmKGE9Zi5nZXRFbGVtZW50QnlJZChpKSkmJkkuY29udGFpbnMoZSxhKSYmYS5pZD09PWkpcmV0dXJuIGsuY2FsbChuLGEpLG59ZWxzZXtpZih1WzJdKXJldHVybiBrLmFwcGx5KG4sZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0KSksbjtpZigoaT11WzNdKSYmZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKXJldHVybiBrLmFwcGx5KG4sZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGkpKSxufWlmKCEoaFt0K1wiIFwiXXx8ZCYmZC50ZXN0KHQpKSl7aWYoYz10LGY9ZSwxPT09cCYmKHgudGVzdCh0KXx8bS50ZXN0KHQpKSl7KGY9SC50ZXN0KHQpJiZVKGUucGFyZW50Tm9kZSl8fGUpPT1lJiZsZS5zY29wZXx8KChzPWUuZ2V0QXR0cmlidXRlKFwiaWRcIikpP3M9Y2UuZXNjYXBlU2VsZWN0b3Iocyk6ZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLHM9UykpLG89KGw9WSh0KSkubGVuZ3RoO3doaWxlKG8tLSlsW29dPShzP1wiI1wiK3M6XCI6c2NvcGVcIikrXCIgXCIrUShsW29dKTtjPWwuam9pbihcIixcIil9dHJ5e3JldHVybiBrLmFwcGx5KG4sZi5xdWVyeVNlbGVjdG9yQWxsKGMpKSxufWNhdGNoKGUpe2godCwhMCl9ZmluYWxseXtzPT09UyYmZS5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKX19fXJldHVybiByZSh0LnJlcGxhY2UodmUsXCIkMVwiKSxlLG4scil9ZnVuY3Rpb24gVygpe3ZhciByPVtdO3JldHVybiBmdW5jdGlvbiBlKHQsbil7cmV0dXJuIHIucHVzaCh0K1wiIFwiKT5iLmNhY2hlTGVuZ3RoJiZkZWxldGUgZVtyLnNoaWZ0KCldLGVbdCtcIiBcIl09bn19ZnVuY3Rpb24gRihlKXtyZXR1cm4gZVtTXT0hMCxlfWZ1bmN0aW9uICQoZSl7dmFyIHQ9VC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7dHJ5e3JldHVybiEhZSh0KX1jYXRjaChlKXtyZXR1cm4hMX1maW5hbGx5e3QucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLHQ9bnVsbH19ZnVuY3Rpb24gQih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGZlKGUsXCJpbnB1dFwiKSYmZS50eXBlPT09dH19ZnVuY3Rpb24gXyh0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuKGZlKGUsXCJpbnB1dFwiKXx8ZmUoZSxcImJ1dHRvblwiKSkmJmUudHlwZT09PXR9fWZ1bmN0aW9uIHoodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVyblwiZm9ybVwiaW4gZT9lLnBhcmVudE5vZGUmJiExPT09ZS5kaXNhYmxlZD9cImxhYmVsXCJpbiBlP1wibGFiZWxcImluIGUucGFyZW50Tm9kZT9lLnBhcmVudE5vZGUuZGlzYWJsZWQ9PT10OmUuZGlzYWJsZWQ9PT10OmUuaXNEaXNhYmxlZD09PXR8fGUuaXNEaXNhYmxlZCE9PSF0JiZSKGUpPT09dDplLmRpc2FibGVkPT09dDpcImxhYmVsXCJpbiBlJiZlLmRpc2FibGVkPT09dH19ZnVuY3Rpb24gWChhKXtyZXR1cm4gRihmdW5jdGlvbihvKXtyZXR1cm4gbz0rbyxGKGZ1bmN0aW9uKGUsdCl7dmFyIG4scj1hKFtdLGUubGVuZ3RoLG8pLGk9ci5sZW5ndGg7d2hpbGUoaS0tKWVbbj1yW2ldXSYmKGVbbl09ISh0W25dPWVbbl0pKX0pfSl9ZnVuY3Rpb24gVShlKXtyZXR1cm4gZSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUmJmV9ZnVuY3Rpb24gVihlKXt2YXIgdCxuPWU/ZS5vd25lckRvY3VtZW50fHxlOnllO3JldHVybiBuIT1UJiY5PT09bi5ub2RlVHlwZSYmbi5kb2N1bWVudEVsZW1lbnQmJihyPShUPW4pLmRvY3VtZW50RWxlbWVudCxDPSFjZS5pc1hNTERvYyhUKSxpPXIubWF0Y2hlc3x8ci53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fHIubXNNYXRjaGVzU2VsZWN0b3Isci5tc01hdGNoZXNTZWxlY3RvciYmeWUhPVQmJih0PVQuZGVmYXVsdFZpZXcpJiZ0LnRvcCE9PXQmJnQuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLE0pLGxlLmdldEJ5SWQ9JChmdW5jdGlvbihlKXtyZXR1cm4gci5hcHBlbmRDaGlsZChlKS5pZD1jZS5leHBhbmRvLCFULmdldEVsZW1lbnRzQnlOYW1lfHwhVC5nZXRFbGVtZW50c0J5TmFtZShjZS5leHBhbmRvKS5sZW5ndGh9KSxsZS5kaXNjb25uZWN0ZWRNYXRjaD0kKGZ1bmN0aW9uKGUpe3JldHVybiBpLmNhbGwoZSxcIipcIil9KSxsZS5zY29wZT0kKGZ1bmN0aW9uKCl7cmV0dXJuIFQucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZVwiKX0pLGxlLmNzc0hhcz0kKGZ1bmN0aW9uKCl7dHJ5e3JldHVybiBULnF1ZXJ5U2VsZWN0b3IoXCI6aGFzKCosOmpxZmFrZSlcIiksITF9Y2F0Y2goZSl7cmV0dXJuITB9fSksbGUuZ2V0QnlJZD8oYi5maWx0ZXIuSUQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5yZXBsYWNlKE8sUCk7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZShcImlkXCIpPT09dH19LGIuZmluZC5JRD1mdW5jdGlvbihlLHQpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0LmdldEVsZW1lbnRCeUlkJiZDKXt2YXIgbj10LmdldEVsZW1lbnRCeUlkKGUpO3JldHVybiBuP1tuXTpbXX19KTooYi5maWx0ZXIuSUQ9ZnVuY3Rpb24oZSl7dmFyIG49ZS5yZXBsYWNlKE8sUCk7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLmdldEF0dHJpYnV0ZU5vZGUmJmUuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO3JldHVybiB0JiZ0LnZhbHVlPT09bn19LGIuZmluZC5JRD1mdW5jdGlvbihlLHQpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0LmdldEVsZW1lbnRCeUlkJiZDKXt2YXIgbixyLGksbz10LmdldEVsZW1lbnRCeUlkKGUpO2lmKG8pe2lmKChuPW8uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpKSYmbi52YWx1ZT09PWUpcmV0dXJuW29dO2k9dC5nZXRFbGVtZW50c0J5TmFtZShlKSxyPTA7d2hpbGUobz1pW3IrK10paWYoKG49by5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikpJiZuLnZhbHVlPT09ZSlyZXR1cm5bb119cmV0dXJuW119fSksYi5maW5kLlRBRz1mdW5jdGlvbihlLHQpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB0LmdldEVsZW1lbnRzQnlUYWdOYW1lP3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk6dC5xdWVyeVNlbGVjdG9yQWxsKGUpfSxiLmZpbmQuQ0xBU1M9ZnVuY3Rpb24oZSx0KXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZDKXJldHVybiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZSl9LGQ9W10sJChmdW5jdGlvbihlKXt2YXIgdDtyLmFwcGVuZENoaWxkKGUpLmlubmVySFRNTD1cIjxhIGlkPSdcIitTK1wiJyBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPjxzZWxlY3QgaWQ9J1wiK1MrXCItXFxyXFxcXCcgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiLGUucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RofHxkLnB1c2goXCJcXFxcW1wiK2dlK1wiKig/OnZhbHVlfFwiK2YrXCIpXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIltpZH49XCIrUytcIi1dXCIpLmxlbmd0aHx8ZC5wdXNoKFwifj1cIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiYSNcIitTK1wiKypcIikubGVuZ3RofHxkLnB1c2goXCIuIy4rWyt+XVwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGh8fGQucHVzaChcIjpjaGVja2VkXCIpLCh0PVQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJoaWRkZW5cIiksZS5hcHBlbmRDaGlsZCh0KS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJEXCIpLHIuYXBwZW5kQ2hpbGQoZSkuZGlzYWJsZWQ9ITAsMiE9PWUucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGgmJmQucHVzaChcIjplbmFibGVkXCIsXCI6ZGlzYWJsZWRcIiksKHQ9VC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnNldEF0dHJpYnV0ZShcIm5hbWVcIixcIlwiKSxlLmFwcGVuZENoaWxkKHQpLGUucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPScnXVwiKS5sZW5ndGh8fGQucHVzaChcIlxcXFxbXCIrZ2UrXCIqbmFtZVwiK2dlK1wiKj1cIitnZStcIiooPzonJ3xcXFwiXFxcIilcIil9KSxsZS5jc3NIYXN8fGQucHVzaChcIjpoYXNcIiksZD1kLmxlbmd0aCYmbmV3IFJlZ0V4cChkLmpvaW4oXCJ8XCIpKSxsPWZ1bmN0aW9uKGUsdCl7aWYoZT09PXQpcmV0dXJuIGE9ITAsMDt2YXIgbj0hZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbi0hdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtyZXR1cm4gbnx8KDEmKG49KGUub3duZXJEb2N1bWVudHx8ZSk9PSh0Lm93bmVyRG9jdW1lbnR8fHQpP2UuY29tcGFyZURvY3VtZW50UG9zaXRpb24odCk6MSl8fCFsZS5zb3J0RGV0YWNoZWQmJnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZSk9PT1uP2U9PT1UfHxlLm93bmVyRG9jdW1lbnQ9PXllJiZJLmNvbnRhaW5zKHllLGUpPy0xOnQ9PT1UfHx0Lm93bmVyRG9jdW1lbnQ9PXllJiZJLmNvbnRhaW5zKHllLHQpPzE6bz9zZS5jYWxsKG8sZSktc2UuY2FsbChvLHQpOjA6NCZuPy0xOjEpfSksVH1mb3IoZSBpbiBJLm1hdGNoZXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSShlLG51bGwsbnVsbCx0KX0sSS5tYXRjaGVzU2VsZWN0b3I9ZnVuY3Rpb24oZSx0KXtpZihWKGUpLEMmJiFoW3QrXCIgXCJdJiYoIWR8fCFkLnRlc3QodCkpKXRyeXt2YXIgbj1pLmNhbGwoZSx0KTtpZihufHxsZS5kaXNjb25uZWN0ZWRNYXRjaHx8ZS5kb2N1bWVudCYmMTEhPT1lLmRvY3VtZW50Lm5vZGVUeXBlKXJldHVybiBufWNhdGNoKGUpe2godCwhMCl9cmV0dXJuIDA8SSh0LFQsbnVsbCxbZV0pLmxlbmd0aH0sSS5jb250YWlucz1mdW5jdGlvbihlLHQpe3JldHVybihlLm93bmVyRG9jdW1lbnR8fGUpIT1UJiZWKGUpLGNlLmNvbnRhaW5zKGUsdCl9LEkuYXR0cj1mdW5jdGlvbihlLHQpeyhlLm93bmVyRG9jdW1lbnR8fGUpIT1UJiZWKGUpO3ZhciBuPWIuYXR0ckhhbmRsZVt0LnRvTG93ZXJDYXNlKCldLHI9biYmdWUuY2FsbChiLmF0dHJIYW5kbGUsdC50b0xvd2VyQ2FzZSgpKT9uKGUsdCwhQyk6dm9pZCAwO3JldHVybiB2b2lkIDAhPT1yP3I6ZS5nZXRBdHRyaWJ1dGUodCl9LEkuZXJyb3I9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIrZSl9LGNlLnVuaXF1ZVNvcnQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj1bXSxyPTAsaT0wO2lmKGE9IWxlLnNvcnRTdGFibGUsbz0hbGUuc29ydFN0YWJsZSYmYWUuY2FsbChlLDApLGRlLmNhbGwoZSxsKSxhKXt3aGlsZSh0PWVbaSsrXSl0PT09ZVtpXSYmKHI9bi5wdXNoKGkpKTt3aGlsZShyLS0paGUuY2FsbChlLG5bcl0sMSl9cmV0dXJuIG89bnVsbCxlfSxjZS5mbi51bmlxdWVTb3J0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGNlLnVuaXF1ZVNvcnQoYWUuYXBwbHkodGhpcykpKX0sKGI9Y2UuZXhwcj17Y2FjaGVMZW5ndGg6NTAsY3JlYXRlUHNldWRvOkYsbWF0Y2g6RCxhdHRySGFuZGxlOnt9LGZpbmQ6e30scmVsYXRpdmU6e1wiPlwiOntkaXI6XCJwYXJlbnROb2RlXCIsZmlyc3Q6ITB9LFwiIFwiOntkaXI6XCJwYXJlbnROb2RlXCJ9LFwiK1wiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIixmaXJzdDohMH0sXCJ+XCI6e2RpcjpcInByZXZpb3VzU2libGluZ1wifX0scHJlRmlsdGVyOntBVFRSOmZ1bmN0aW9uKGUpe3JldHVybiBlWzFdPWVbMV0ucmVwbGFjZShPLFApLGVbM109KGVbM118fGVbNF18fGVbNV18fFwiXCIpLnJlcGxhY2UoTyxQKSxcIn49XCI9PT1lWzJdJiYoZVszXT1cIiBcIitlWzNdK1wiIFwiKSxlLnNsaWNlKDAsNCl9LENISUxEOmZ1bmN0aW9uKGUpe3JldHVybiBlWzFdPWVbMV0udG9Mb3dlckNhc2UoKSxcIm50aFwiPT09ZVsxXS5zbGljZSgwLDMpPyhlWzNdfHxJLmVycm9yKGVbMF0pLGVbNF09KyhlWzRdP2VbNV0rKGVbNl18fDEpOjIqKFwiZXZlblwiPT09ZVszXXx8XCJvZGRcIj09PWVbM10pKSxlWzVdPSsoZVs3XStlWzhdfHxcIm9kZFwiPT09ZVszXSkpOmVbM10mJkkuZXJyb3IoZVswXSksZX0sUFNFVURPOmZ1bmN0aW9uKGUpe3ZhciB0LG49IWVbNl0mJmVbMl07cmV0dXJuIEQuQ0hJTEQudGVzdChlWzBdKT9udWxsOihlWzNdP2VbMl09ZVs0XXx8ZVs1XXx8XCJcIjpuJiZqLnRlc3QobikmJih0PVkobiwhMCkpJiYodD1uLmluZGV4T2YoXCIpXCIsbi5sZW5ndGgtdCktbi5sZW5ndGgpJiYoZVswXT1lWzBdLnNsaWNlKDAsdCksZVsyXT1uLnNsaWNlKDAsdCkpLGUuc2xpY2UoMCwzKSl9fSxmaWx0ZXI6e1RBRzpmdW5jdGlvbihlKXt2YXIgdD1lLnJlcGxhY2UoTyxQKS50b0xvd2VyQ2FzZSgpO3JldHVyblwiKlwiPT09ZT9mdW5jdGlvbigpe3JldHVybiEwfTpmdW5jdGlvbihlKXtyZXR1cm4gZmUoZSx0KX19LENMQVNTOmZ1bmN0aW9uKGUpe3ZhciB0PXNbZStcIiBcIl07cmV0dXJuIHR8fCh0PW5ldyBSZWdFeHAoXCIoXnxcIitnZStcIilcIitlK1wiKFwiK2dlK1wifCQpXCIpKSYmcyhlLGZ1bmN0aW9uKGUpe3JldHVybiB0LnRlc3QoXCJzdHJpbmdcIj09dHlwZW9mIGUuY2xhc3NOYW1lJiZlLmNsYXNzTmFtZXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiKX0pfSxBVFRSOmZ1bmN0aW9uKG4scixpKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9SS5hdHRyKGUsbik7cmV0dXJuIG51bGw9PXQ/XCIhPVwiPT09cjohcnx8KHQrPVwiXCIsXCI9XCI9PT1yP3Q9PT1pOlwiIT1cIj09PXI/dCE9PWk6XCJePVwiPT09cj9pJiYwPT09dC5pbmRleE9mKGkpOlwiKj1cIj09PXI/aSYmLTE8dC5pbmRleE9mKGkpOlwiJD1cIj09PXI/aSYmdC5zbGljZSgtaS5sZW5ndGgpPT09aTpcIn49XCI9PT1yPy0xPChcIiBcIit0LnJlcGxhY2UodixcIiBcIikrXCIgXCIpLmluZGV4T2YoaSk6XCJ8PVwiPT09ciYmKHQ9PT1pfHx0LnNsaWNlKDAsaS5sZW5ndGgrMSk9PT1pK1wiLVwiKSl9fSxDSElMRDpmdW5jdGlvbihkLGUsdCxoLGcpe3ZhciB2PVwibnRoXCIhPT1kLnNsaWNlKDAsMykseT1cImxhc3RcIiE9PWQuc2xpY2UoLTQpLG09XCJvZi10eXBlXCI9PT1lO3JldHVybiAxPT09aCYmMD09PWc/ZnVuY3Rpb24oZSl7cmV0dXJuISFlLnBhcmVudE5vZGV9OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzLHU9diE9PXk/XCJuZXh0U2libGluZ1wiOlwicHJldmlvdXNTaWJsaW5nXCIsbD1lLnBhcmVudE5vZGUsYz1tJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksZj0hbiYmIW0scD0hMTtpZihsKXtpZih2KXt3aGlsZSh1KXtvPWU7d2hpbGUobz1vW3VdKWlmKG0/ZmUobyxjKToxPT09by5ub2RlVHlwZSlyZXR1cm4hMTtzPXU9XCJvbmx5XCI9PT1kJiYhcyYmXCJuZXh0U2libGluZ1wifXJldHVybiEwfWlmKHM9W3k/bC5maXJzdENoaWxkOmwubGFzdENoaWxkXSx5JiZmKXtwPShhPShyPShpPWxbU118fChsW1NdPXt9KSlbZF18fFtdKVswXT09PUUmJnJbMV0pJiZyWzJdLG89YSYmbC5jaGlsZE5vZGVzW2FdO3doaWxlKG89KythJiZvJiZvW3VdfHwocD1hPTApfHxzLnBvcCgpKWlmKDE9PT1vLm5vZGVUeXBlJiYrK3AmJm89PT1lKXtpW2RdPVtFLGEscF07YnJlYWt9fWVsc2UgaWYoZiYmKHA9YT0ocj0oaT1lW1NdfHwoZVtTXT17fSkpW2RdfHxbXSlbMF09PT1FJiZyWzFdKSwhMT09PXApd2hpbGUobz0rK2EmJm8mJm9bdV18fChwPWE9MCl8fHMucG9wKCkpaWYoKG0/ZmUobyxjKToxPT09by5ub2RlVHlwZSkmJisrcCYmKGYmJigoaT1vW1NdfHwob1tTXT17fSkpW2RdPVtFLHBdKSxvPT09ZSkpYnJlYWs7cmV0dXJuKHAtPWcpPT09aHx8cCVoPT0wJiYwPD1wL2h9fX0sUFNFVURPOmZ1bmN0aW9uKGUsbyl7dmFyIHQsYT1iLnBzZXVkb3NbZV18fGIuc2V0RmlsdGVyc1tlLnRvTG93ZXJDYXNlKCldfHxJLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIitlKTtyZXR1cm4gYVtTXT9hKG8pOjE8YS5sZW5ndGg/KHQ9W2UsZSxcIlwiLG9dLGIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShlLnRvTG93ZXJDYXNlKCkpP0YoZnVuY3Rpb24oZSx0KXt2YXIgbixyPWEoZSxvKSxpPXIubGVuZ3RoO3doaWxlKGktLSllW249c2UuY2FsbChlLHJbaV0pXT0hKHRbbl09cltpXSl9KTpmdW5jdGlvbihlKXtyZXR1cm4gYShlLDAsdCl9KTphfX0scHNldWRvczp7bm90OkYoZnVuY3Rpb24oZSl7dmFyIHI9W10saT1bXSxzPW5lKGUucmVwbGFjZSh2ZSxcIiQxXCIpKTtyZXR1cm4gc1tTXT9GKGZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG89cyhlLG51bGwscixbXSksYT1lLmxlbmd0aDt3aGlsZShhLS0pKGk9b1thXSkmJihlW2FdPSEodFthXT1pKSl9KTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHJbMF09ZSxzKHIsbnVsbCxuLGkpLHJbMF09bnVsbCwhaS5wb3AoKX19KSxoYXM6RihmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIDA8SSh0LGUpLmxlbmd0aH19KSxjb250YWluczpGKGZ1bmN0aW9uKHQpe3JldHVybiB0PXQucmVwbGFjZShPLFApLGZ1bmN0aW9uKGUpe3JldHVybi0xPChlLnRleHRDb250ZW50fHxjZS50ZXh0KGUpKS5pbmRleE9mKHQpfX0pLGxhbmc6RihmdW5jdGlvbihuKXtyZXR1cm4gQS50ZXN0KG58fFwiXCIpfHxJLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIrbiksbj1uLnJlcGxhY2UoTyxQKS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKGUpe3ZhciB0O2Rve2lmKHQ9Qz9lLmxhbmc6ZS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKXx8ZS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKXJldHVybih0PXQudG9Mb3dlckNhc2UoKSk9PT1ufHwwPT09dC5pbmRleE9mKG4rXCItXCIpfXdoaWxlKChlPWUucGFyZW50Tm9kZSkmJjE9PT1lLm5vZGVUeXBlKTtyZXR1cm4hMX19KSx0YXJnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9aWUubG9jYXRpb24mJmllLmxvY2F0aW9uLmhhc2g7cmV0dXJuIHQmJnQuc2xpY2UoMSk9PT1lLmlkfSxyb290OmZ1bmN0aW9uKGUpe3JldHVybiBlPT09cn0sZm9jdXM6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1mdW5jdGlvbigpe3RyeXtyZXR1cm4gVC5hY3RpdmVFbGVtZW50fWNhdGNoKGUpe319KCkmJlQuaGFzRm9jdXMoKSYmISEoZS50eXBlfHxlLmhyZWZ8fH5lLnRhYkluZGV4KX0sZW5hYmxlZDp6KCExKSxkaXNhYmxlZDp6KCEwKSxjaGVja2VkOmZ1bmN0aW9uKGUpe3JldHVybiBmZShlLFwiaW5wdXRcIikmJiEhZS5jaGVja2VkfHxmZShlLFwib3B0aW9uXCIpJiYhIWUuc2VsZWN0ZWR9LHNlbGVjdGVkOmZ1bmN0aW9uKGUpe3JldHVybiBlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCEwPT09ZS5zZWxlY3RlZH0sZW1wdHk6ZnVuY3Rpb24oZSl7Zm9yKGU9ZS5maXJzdENoaWxkO2U7ZT1lLm5leHRTaWJsaW5nKWlmKGUubm9kZVR5cGU8NilyZXR1cm4hMTtyZXR1cm4hMH0scGFyZW50OmZ1bmN0aW9uKGUpe3JldHVybiFiLnBzZXVkb3MuZW1wdHkoZSl9LGhlYWRlcjpmdW5jdGlvbihlKXtyZXR1cm4gcS50ZXN0KGUubm9kZU5hbWUpfSxpbnB1dDpmdW5jdGlvbihlKXtyZXR1cm4gTi50ZXN0KGUubm9kZU5hbWUpfSxidXR0b246ZnVuY3Rpb24oZSl7cmV0dXJuIGZlKGUsXCJpbnB1dFwiKSYmXCJidXR0b25cIj09PWUudHlwZXx8ZmUoZSxcImJ1dHRvblwiKX0sdGV4dDpmdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gZmUoZSxcImlucHV0XCIpJiZcInRleHRcIj09PWUudHlwZSYmKG51bGw9PSh0PWUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSl8fFwidGV4dFwiPT09dC50b0xvd2VyQ2FzZSgpKX0sZmlyc3Q6WChmdW5jdGlvbigpe3JldHVyblswXX0pLGxhc3Q6WChmdW5jdGlvbihlLHQpe3JldHVyblt0LTFdfSksZXE6WChmdW5jdGlvbihlLHQsbil7cmV0dXJuW248MD9uK3Q6bl19KSxldmVuOlgoZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MDtuPHQ7bis9MillLnB1c2gobik7cmV0dXJuIGV9KSxvZGQ6WChmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0xO248dDtuKz0yKWUucHVzaChuKTtyZXR1cm4gZX0pLGx0OlgoZnVuY3Rpb24oZSx0LG4pe3ZhciByO2ZvcihyPW48MD9uK3Q6dDxuP3Q6bjswPD0tLXI7KWUucHVzaChyKTtyZXR1cm4gZX0pLGd0OlgoZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj1uPDA/bit0Om47KytyPHQ7KWUucHVzaChyKTtyZXR1cm4gZX0pfX0pLnBzZXVkb3MubnRoPWIucHNldWRvcy5lcSx7cmFkaW86ITAsY2hlY2tib3g6ITAsZmlsZTohMCxwYXNzd29yZDohMCxpbWFnZTohMH0pYi5wc2V1ZG9zW2VdPUIoZSk7Zm9yKGUgaW57c3VibWl0OiEwLHJlc2V0OiEwfSliLnBzZXVkb3NbZV09XyhlKTtmdW5jdGlvbiBHKCl7fWZ1bmN0aW9uIFkoZSx0KXt2YXIgbixyLGksbyxhLHMsdSxsPWNbZStcIiBcIl07aWYobClyZXR1cm4gdD8wOmwuc2xpY2UoMCk7YT1lLHM9W10sdT1iLnByZUZpbHRlcjt3aGlsZShhKXtmb3IobyBpbiBuJiYhKHI9eS5leGVjKGEpKXx8KHImJihhPWEuc2xpY2UoclswXS5sZW5ndGgpfHxhKSxzLnB1c2goaT1bXSkpLG49ITEsKHI9bS5leGVjKGEpKSYmKG49ci5zaGlmdCgpLGkucHVzaCh7dmFsdWU6bix0eXBlOnJbMF0ucmVwbGFjZSh2ZSxcIiBcIil9KSxhPWEuc2xpY2Uobi5sZW5ndGgpKSxiLmZpbHRlcikhKHI9RFtvXS5leGVjKGEpKXx8dVtvXSYmIShyPXVbb10ocikpfHwobj1yLnNoaWZ0KCksaS5wdXNoKHt2YWx1ZTpuLHR5cGU6byxtYXRjaGVzOnJ9KSxhPWEuc2xpY2Uobi5sZW5ndGgpKTtpZighbilicmVha31yZXR1cm4gdD9hLmxlbmd0aDphP0kuZXJyb3IoZSk6YyhlLHMpLnNsaWNlKDApfWZ1bmN0aW9uIFEoZSl7Zm9yKHZhciB0PTAsbj1lLmxlbmd0aCxyPVwiXCI7dDxuO3QrKylyKz1lW3RdLnZhbHVlO3JldHVybiByfWZ1bmN0aW9uIEooYSxlLHQpe3ZhciBzPWUuZGlyLHU9ZS5uZXh0LGw9dXx8cyxjPXQmJlwicGFyZW50Tm9kZVwiPT09bCxmPW4rKztyZXR1cm4gZS5maXJzdD9mdW5jdGlvbihlLHQsbil7d2hpbGUoZT1lW3NdKWlmKDE9PT1lLm5vZGVUeXBlfHxjKXJldHVybiBhKGUsdCxuKTtyZXR1cm4hMX06ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbz1bRSxmXTtpZihuKXt3aGlsZShlPWVbc10paWYoKDE9PT1lLm5vZGVUeXBlfHxjKSYmYShlLHQsbikpcmV0dXJuITB9ZWxzZSB3aGlsZShlPWVbc10paWYoMT09PWUubm9kZVR5cGV8fGMpaWYoaT1lW1NdfHwoZVtTXT17fSksdSYmZmUoZSx1KSllPWVbc118fGU7ZWxzZXtpZigocj1pW2xdKSYmclswXT09PUUmJnJbMV09PT1mKXJldHVybiBvWzJdPXJbMl07aWYoKGlbbF09bylbMl09YShlLHQsbikpcmV0dXJuITB9cmV0dXJuITF9fWZ1bmN0aW9uIEsoaSl7cmV0dXJuIDE8aS5sZW5ndGg/ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWkubGVuZ3RoO3doaWxlKHItLSlpZighaVtyXShlLHQsbikpcmV0dXJuITE7cmV0dXJuITB9OmlbMF19ZnVuY3Rpb24gWihlLHQsbixyLGkpe2Zvcih2YXIgbyxhPVtdLHM9MCx1PWUubGVuZ3RoLGw9bnVsbCE9dDtzPHU7cysrKShvPWVbc10pJiYobiYmIW4obyxyLGkpfHwoYS5wdXNoKG8pLGwmJnQucHVzaChzKSkpO3JldHVybiBhfWZ1bmN0aW9uIGVlKGQsaCxnLHYseSxlKXtyZXR1cm4gdiYmIXZbU10mJih2PWVlKHYpKSx5JiYheVtTXSYmKHk9ZWUoeSxlKSksRihmdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvLGEscyx1PVtdLGw9W10sYz10Lmxlbmd0aCxmPWV8fGZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHI9MCxpPXQubGVuZ3RoO3I8aTtyKyspSShlLHRbcl0sbik7cmV0dXJuIG59KGh8fFwiKlwiLG4ubm9kZVR5cGU/W25dOm4sW10pLHA9IWR8fCFlJiZoP2Y6WihmLHUsZCxuLHIpO2lmKGc/ZyhwLHM9eXx8KGU/ZDpjfHx2KT9bXTp0LG4scik6cz1wLHYpe2k9WihzLGwpLHYoaSxbXSxuLHIpLG89aS5sZW5ndGg7d2hpbGUoby0tKShhPWlbb10pJiYoc1tsW29dXT0hKHBbbFtvXV09YSkpfWlmKGUpe2lmKHl8fGQpe2lmKHkpe2k9W10sbz1zLmxlbmd0aDt3aGlsZShvLS0pKGE9c1tvXSkmJmkucHVzaChwW29dPWEpO3kobnVsbCxzPVtdLGkscil9bz1zLmxlbmd0aDt3aGlsZShvLS0pKGE9c1tvXSkmJi0xPChpPXk/c2UuY2FsbChlLGEpOnVbb10pJiYoZVtpXT0hKHRbaV09YSkpfX1lbHNlIHM9WihzPT09dD9zLnNwbGljZShjLHMubGVuZ3RoKTpzKSx5P3kobnVsbCx0LHMscik6ay5hcHBseSh0LHMpfSl9ZnVuY3Rpb24gdGUoZSl7Zm9yKHZhciBpLHQsbixyPWUubGVuZ3RoLG89Yi5yZWxhdGl2ZVtlWzBdLnR5cGVdLGE9b3x8Yi5yZWxhdGl2ZVtcIiBcIl0scz1vPzE6MCx1PUooZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1pfSxhLCEwKSxsPUooZnVuY3Rpb24oZSl7cmV0dXJuLTE8c2UuY2FsbChpLGUpfSxhLCEwKSxjPVtmdW5jdGlvbihlLHQsbil7dmFyIHI9IW8mJihufHx0IT13KXx8KChpPXQpLm5vZGVUeXBlP3UoZSx0LG4pOmwoZSx0LG4pKTtyZXR1cm4gaT1udWxsLHJ9XTtzPHI7cysrKWlmKHQ9Yi5yZWxhdGl2ZVtlW3NdLnR5cGVdKWM9W0ooSyhjKSx0KV07ZWxzZXtpZigodD1iLmZpbHRlcltlW3NdLnR5cGVdLmFwcGx5KG51bGwsZVtzXS5tYXRjaGVzKSlbU10pe2ZvcihuPSsrcztuPHI7bisrKWlmKGIucmVsYXRpdmVbZVtuXS50eXBlXSlicmVhaztyZXR1cm4gZWUoMTxzJiZLKGMpLDE8cyYmUShlLnNsaWNlKDAscy0xKS5jb25jYXQoe3ZhbHVlOlwiIFwiPT09ZVtzLTJdLnR5cGU/XCIqXCI6XCJcIn0pKS5yZXBsYWNlKHZlLFwiJDFcIiksdCxzPG4mJnRlKGUuc2xpY2UocyxuKSksbjxyJiZ0ZShlPWUuc2xpY2UobikpLG48ciYmUShlKSl9Yy5wdXNoKHQpfXJldHVybiBLKGMpfWZ1bmN0aW9uIG5lKGUsdCl7dmFyIG4sdix5LG0seCxyLGk9W10sbz1bXSxhPXVbZStcIiBcIl07aWYoIWEpe3R8fCh0PVkoZSkpLG49dC5sZW5ndGg7d2hpbGUobi0tKShhPXRlKHRbbl0pKVtTXT9pLnB1c2goYSk6by5wdXNoKGEpOyhhPXUoZSwodj1vLG09MDwoeT1pKS5sZW5ndGgseD0wPHYubGVuZ3RoLHI9ZnVuY3Rpb24oZSx0LG4scixpKXt2YXIgbyxhLHMsdT0wLGw9XCIwXCIsYz1lJiZbXSxmPVtdLHA9dyxkPWV8fHgmJmIuZmluZC5UQUcoXCIqXCIsaSksaD1FKz1udWxsPT1wPzE6TWF0aC5yYW5kb20oKXx8LjEsZz1kLmxlbmd0aDtmb3IoaSYmKHc9dD09VHx8dHx8aSk7bCE9PWcmJm51bGwhPShvPWRbbF0pO2wrKyl7aWYoeCYmbyl7YT0wLHR8fG8ub3duZXJEb2N1bWVudD09VHx8KFYobyksbj0hQyk7d2hpbGUocz12W2ErK10paWYocyhvLHR8fFQsbikpe2suY2FsbChyLG8pO2JyZWFrfWkmJihFPWgpfW0mJigobz0hcyYmbykmJnUtLSxlJiZjLnB1c2gobykpfWlmKHUrPWwsbSYmbCE9PXUpe2E9MDt3aGlsZShzPXlbYSsrXSlzKGMsZix0LG4pO2lmKGUpe2lmKDA8dSl3aGlsZShsLS0pY1tsXXx8ZltsXXx8KGZbbF09cGUuY2FsbChyKSk7Zj1aKGYpfWsuYXBwbHkocixmKSxpJiYhZSYmMDxmLmxlbmd0aCYmMTx1K3kubGVuZ3RoJiZjZS51bmlxdWVTb3J0KHIpfXJldHVybiBpJiYoRT1oLHc9cCksY30sbT9GKHIpOnIpKSkuc2VsZWN0b3I9ZX1yZXR1cm4gYX1mdW5jdGlvbiByZShlLHQsbixyKXt2YXIgaSxvLGEscyx1LGw9XCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZSxjPSFyJiZZKGU9bC5zZWxlY3Rvcnx8ZSk7aWYobj1ufHxbXSwxPT09Yy5sZW5ndGgpe2lmKDI8KG89Y1swXT1jWzBdLnNsaWNlKDApKS5sZW5ndGgmJlwiSURcIj09PShhPW9bMF0pLnR5cGUmJjk9PT10Lm5vZGVUeXBlJiZDJiZiLnJlbGF0aXZlW29bMV0udHlwZV0pe2lmKCEodD0oYi5maW5kLklEKGEubWF0Y2hlc1swXS5yZXBsYWNlKE8sUCksdCl8fFtdKVswXSkpcmV0dXJuIG47bCYmKHQ9dC5wYXJlbnROb2RlKSxlPWUuc2xpY2Uoby5zaGlmdCgpLnZhbHVlLmxlbmd0aCl9aT1ELm5lZWRzQ29udGV4dC50ZXN0KGUpPzA6by5sZW5ndGg7d2hpbGUoaS0tKXtpZihhPW9baV0sYi5yZWxhdGl2ZVtzPWEudHlwZV0pYnJlYWs7aWYoKHU9Yi5maW5kW3NdKSYmKHI9dShhLm1hdGNoZXNbMF0ucmVwbGFjZShPLFApLEgudGVzdChvWzBdLnR5cGUpJiZVKHQucGFyZW50Tm9kZSl8fHQpKSl7aWYoby5zcGxpY2UoaSwxKSwhKGU9ci5sZW5ndGgmJlEobykpKXJldHVybiBrLmFwcGx5KG4sciksbjticmVha319fXJldHVybihsfHxuZShlLGMpKShyLHQsIUMsbiwhdHx8SC50ZXN0KGUpJiZVKHQucGFyZW50Tm9kZSl8fHQpLG59Ry5wcm90b3R5cGU9Yi5maWx0ZXJzPWIucHNldWRvcyxiLnNldEZpbHRlcnM9bmV3IEcsbGUuc29ydFN0YWJsZT1TLnNwbGl0KFwiXCIpLnNvcnQobCkuam9pbihcIlwiKT09PVMsVigpLGxlLnNvcnREZXRhY2hlZD0kKGZ1bmN0aW9uKGUpe3JldHVybiAxJmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oVC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikpfSksY2UuZmluZD1JLGNlLmV4cHJbXCI6XCJdPWNlLmV4cHIucHNldWRvcyxjZS51bmlxdWU9Y2UudW5pcXVlU29ydCxJLmNvbXBpbGU9bmUsSS5zZWxlY3Q9cmUsSS5zZXREb2N1bWVudD1WLEkudG9rZW5pemU9WSxJLmVzY2FwZT1jZS5lc2NhcGVTZWxlY3RvcixJLmdldFRleHQ9Y2UudGV4dCxJLmlzWE1MPWNlLmlzWE1MRG9jLEkuc2VsZWN0b3JzPWNlLmV4cHIsSS5zdXBwb3J0PWNlLnN1cHBvcnQsSS51bmlxdWVTb3J0PWNlLnVuaXF1ZVNvcnR9KCk7dmFyIGQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPVtdLGk9dm9pZCAwIT09bjt3aGlsZSgoZT1lW3RdKSYmOSE9PWUubm9kZVR5cGUpaWYoMT09PWUubm9kZVR5cGUpe2lmKGkmJmNlKGUpLmlzKG4pKWJyZWFrO3IucHVzaChlKX1yZXR1cm4gcn0saD1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj1bXTtlO2U9ZS5uZXh0U2libGluZykxPT09ZS5ub2RlVHlwZSYmZSE9PXQmJm4ucHVzaChlKTtyZXR1cm4gbn0sYj1jZS5leHByLm1hdGNoLm5lZWRzQ29udGV4dCx3PS9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pO2Z1bmN0aW9uIFQoZSxuLHIpe3JldHVybiB2KG4pP2NlLmdyZXAoZSxmdW5jdGlvbihlLHQpe3JldHVybiEhbi5jYWxsKGUsdCxlKSE9PXJ9KTpuLm5vZGVUeXBlP2NlLmdyZXAoZSxmdW5jdGlvbihlKXtyZXR1cm4gZT09PW4hPT1yfSk6XCJzdHJpbmdcIiE9dHlwZW9mIG4/Y2UuZ3JlcChlLGZ1bmN0aW9uKGUpe3JldHVybi0xPHNlLmNhbGwobixlKSE9PXJ9KTpjZS5maWx0ZXIobixlLHIpfWNlLmZpbHRlcj1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXTtyZXR1cm4gbiYmKGU9XCI6bm90KFwiK2UrXCIpXCIpLDE9PT10Lmxlbmd0aCYmMT09PXIubm9kZVR5cGU/Y2UuZmluZC5tYXRjaGVzU2VsZWN0b3IocixlKT9bcl06W106Y2UuZmluZC5tYXRjaGVzKGUsY2UuZ3JlcCh0LGZ1bmN0aW9uKGUpe3JldHVybiAxPT09ZS5ub2RlVHlwZX0pKX0sY2UuZm4uZXh0ZW5kKHtmaW5kOmZ1bmN0aW9uKGUpe3ZhciB0LG4scj10aGlzLmxlbmd0aCxpPXRoaXM7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuIHRoaXMucHVzaFN0YWNrKGNlKGUpLmZpbHRlcihmdW5jdGlvbigpe2Zvcih0PTA7dDxyO3QrKylpZihjZS5jb250YWlucyhpW3RdLHRoaXMpKXJldHVybiEwfSkpO2ZvcihuPXRoaXMucHVzaFN0YWNrKFtdKSx0PTA7dDxyO3QrKyljZS5maW5kKGUsaVt0XSxuKTtyZXR1cm4gMTxyP2NlLnVuaXF1ZVNvcnQobik6bn0sZmlsdGVyOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1c2hTdGFjayhUKHRoaXMsZXx8W10sITEpKX0sbm90OmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1c2hTdGFjayhUKHRoaXMsZXx8W10sITApKX0saXM6ZnVuY3Rpb24oZSl7cmV0dXJuISFUKHRoaXMsXCJzdHJpbmdcIj09dHlwZW9mIGUmJmIudGVzdChlKT9jZShlKTplfHxbXSwhMSkubGVuZ3RofX0pO3ZhciBrLFM9L14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC87KGNlLmZuLmluaXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk7aWYoIWUpcmV0dXJuIHRoaXM7aWYobj1ufHxrLFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZighKHI9XCI8XCI9PT1lWzBdJiZcIj5cIj09PWVbZS5sZW5ndGgtMV0mJjM8PWUubGVuZ3RoP1tudWxsLGUsbnVsbF06Uy5leGVjKGUpKXx8IXJbMV0mJnQpcmV0dXJuIXR8fHQuanF1ZXJ5Pyh0fHxuKS5maW5kKGUpOnRoaXMuY29uc3RydWN0b3IodCkuZmluZChlKTtpZihyWzFdKXtpZih0PXQgaW5zdGFuY2VvZiBjZT90WzBdOnQsY2UubWVyZ2UodGhpcyxjZS5wYXJzZUhUTUwoclsxXSx0JiZ0Lm5vZGVUeXBlP3Qub3duZXJEb2N1bWVudHx8dDpDLCEwKSksdy50ZXN0KHJbMV0pJiZjZS5pc1BsYWluT2JqZWN0KHQpKWZvcihyIGluIHQpdih0aGlzW3JdKT90aGlzW3JdKHRbcl0pOnRoaXMuYXR0cihyLHRbcl0pO3JldHVybiB0aGlzfXJldHVybihpPUMuZ2V0RWxlbWVudEJ5SWQoclsyXSkpJiYodGhpc1swXT1pLHRoaXMubGVuZ3RoPTEpLHRoaXN9cmV0dXJuIGUubm9kZVR5cGU/KHRoaXNbMF09ZSx0aGlzLmxlbmd0aD0xLHRoaXMpOnYoZSk/dm9pZCAwIT09bi5yZWFkeT9uLnJlYWR5KGUpOmUoY2UpOmNlLm1ha2VBcnJheShlLHRoaXMpfSkucHJvdG90eXBlPWNlLmZuLGs9Y2UoQyk7dmFyIEU9L14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8saj17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTtmdW5jdGlvbiBBKGUsdCl7d2hpbGUoKGU9ZVt0XSkmJjEhPT1lLm5vZGVUeXBlKTtyZXR1cm4gZX1jZS5mbi5leHRlbmQoe2hhczpmdW5jdGlvbihlKXt2YXIgdD1jZShlLHRoaXMpLG49dC5sZW5ndGg7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTxuO2UrKylpZihjZS5jb250YWlucyh0aGlzLHRbZV0pKXJldHVybiEwfSl9LGNsb3Nlc3Q6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTAsaT10aGlzLmxlbmd0aCxvPVtdLGE9XCJzdHJpbmdcIiE9dHlwZW9mIGUmJmNlKGUpO2lmKCFiLnRlc3QoZSkpZm9yKDtyPGk7cisrKWZvcihuPXRoaXNbcl07biYmbiE9PXQ7bj1uLnBhcmVudE5vZGUpaWYobi5ub2RlVHlwZTwxMSYmKGE/LTE8YS5pbmRleChuKToxPT09bi5ub2RlVHlwZSYmY2UuZmluZC5tYXRjaGVzU2VsZWN0b3IobixlKSkpe28ucHVzaChuKTticmVha31yZXR1cm4gdGhpcy5wdXNoU3RhY2soMTxvLmxlbmd0aD9jZS51bmlxdWVTb3J0KG8pOm8pfSxpbmRleDpmdW5jdGlvbihlKXtyZXR1cm4gZT9cInN0cmluZ1wiPT10eXBlb2YgZT9zZS5jYWxsKGNlKGUpLHRoaXNbMF0pOnNlLmNhbGwodGhpcyxlLmpxdWVyeT9lWzBdOmUpOnRoaXNbMF0mJnRoaXNbMF0ucGFyZW50Tm9kZT90aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aDotMX0sYWRkOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGNlLnVuaXF1ZVNvcnQoY2UubWVyZ2UodGhpcy5nZXQoKSxjZShlLHQpKSkpfSxhZGRCYWNrOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmFkZChudWxsPT1lP3RoaXMucHJldk9iamVjdDp0aGlzLnByZXZPYmplY3QuZmlsdGVyKGUpKX19KSxjZS5lYWNoKHtwYXJlbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wYXJlbnROb2RlO3JldHVybiB0JiYxMSE9PXQubm9kZVR5cGU/dDpudWxsfSxwYXJlbnRzOmZ1bmN0aW9uKGUpe3JldHVybiBkKGUsXCJwYXJlbnROb2RlXCIpfSxwYXJlbnRzVW50aWw6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBkKGUsXCJwYXJlbnROb2RlXCIsbil9LG5leHQ6ZnVuY3Rpb24oZSl7cmV0dXJuIEEoZSxcIm5leHRTaWJsaW5nXCIpfSxwcmV2OmZ1bmN0aW9uKGUpe3JldHVybiBBKGUsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRBbGw6ZnVuY3Rpb24oZSl7cmV0dXJuIGQoZSxcIm5leHRTaWJsaW5nXCIpfSxwcmV2QWxsOmZ1bmN0aW9uKGUpe3JldHVybiBkKGUsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGQoZSxcIm5leHRTaWJsaW5nXCIsbil9LHByZXZVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGQoZSxcInByZXZpb3VzU2libGluZ1wiLG4pfSxzaWJsaW5nczpmdW5jdGlvbihlKXtyZXR1cm4gaCgoZS5wYXJlbnROb2RlfHx7fSkuZmlyc3RDaGlsZCxlKX0sY2hpbGRyZW46ZnVuY3Rpb24oZSl7cmV0dXJuIGgoZS5maXJzdENoaWxkKX0sY29udGVudHM6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWUuY29udGVudERvY3VtZW50JiZyKGUuY29udGVudERvY3VtZW50KT9lLmNvbnRlbnREb2N1bWVudDooZmUoZSxcInRlbXBsYXRlXCIpJiYoZT1lLmNvbnRlbnR8fGUpLGNlLm1lcmdlKFtdLGUuY2hpbGROb2RlcykpfX0sZnVuY3Rpb24ocixpKXtjZS5mbltyXT1mdW5jdGlvbihlLHQpe3ZhciBuPWNlLm1hcCh0aGlzLGksZSk7cmV0dXJuXCJVbnRpbFwiIT09ci5zbGljZSgtNSkmJih0PWUpLHQmJlwic3RyaW5nXCI9PXR5cGVvZiB0JiYobj1jZS5maWx0ZXIodCxuKSksMTx0aGlzLmxlbmd0aCYmKGpbcl18fGNlLnVuaXF1ZVNvcnQobiksRS50ZXN0KHIpJiZuLnJldmVyc2UoKSksdGhpcy5wdXNoU3RhY2sobil9fSk7dmFyIEQ9L1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nO2Z1bmN0aW9uIE4oZSl7cmV0dXJuIGV9ZnVuY3Rpb24gcShlKXt0aHJvdyBlfWZ1bmN0aW9uIEwoZSx0LG4scil7dmFyIGk7dHJ5e2UmJnYoaT1lLnByb21pc2UpP2kuY2FsbChlKS5kb25lKHQpLmZhaWwobik6ZSYmdihpPWUudGhlbik/aS5jYWxsKGUsdCxuKTp0LmFwcGx5KHZvaWQgMCxbZV0uc2xpY2UocikpfWNhdGNoKGUpe24uYXBwbHkodm9pZCAwLFtlXSl9fWNlLkNhbGxiYWNrcz1mdW5jdGlvbihyKXt2YXIgZSxuO3I9XCJzdHJpbmdcIj09dHlwZW9mIHI/KGU9cixuPXt9LGNlLmVhY2goZS5tYXRjaChEKXx8W10sZnVuY3Rpb24oZSx0KXtuW3RdPSEwfSksbik6Y2UuZXh0ZW5kKHt9LHIpO3ZhciBpLHQsbyxhLHM9W10sdT1bXSxsPS0xLGM9ZnVuY3Rpb24oKXtmb3IoYT1hfHxyLm9uY2Usbz1pPSEwO3UubGVuZ3RoO2w9LTEpe3Q9dS5zaGlmdCgpO3doaWxlKCsrbDxzLmxlbmd0aCkhMT09PXNbbF0uYXBwbHkodFswXSx0WzFdKSYmci5zdG9wT25GYWxzZSYmKGw9cy5sZW5ndGgsdD0hMSl9ci5tZW1vcnl8fCh0PSExKSxpPSExLGEmJihzPXQ/W106XCJcIil9LGY9e2FkZDpmdW5jdGlvbigpe3JldHVybiBzJiYodCYmIWkmJihsPXMubGVuZ3RoLTEsdS5wdXNoKHQpKSxmdW5jdGlvbiBuKGUpe2NlLmVhY2goZSxmdW5jdGlvbihlLHQpe3YodCk/ci51bmlxdWUmJmYuaGFzKHQpfHxzLnB1c2godCk6dCYmdC5sZW5ndGgmJlwic3RyaW5nXCIhPT14KHQpJiZuKHQpfSl9KGFyZ3VtZW50cyksdCYmIWkmJmMoKSksdGhpc30scmVtb3ZlOmZ1bmN0aW9uKCl7cmV0dXJuIGNlLmVhY2goYXJndW1lbnRzLGZ1bmN0aW9uKGUsdCl7dmFyIG47d2hpbGUoLTE8KG49Y2UuaW5BcnJheSh0LHMsbikpKXMuc3BsaWNlKG4sMSksbjw9bCYmbC0tfSksdGhpc30saGFzOmZ1bmN0aW9uKGUpe3JldHVybiBlPy0xPGNlLmluQXJyYXkoZSxzKTowPHMubGVuZ3RofSxlbXB0eTpmdW5jdGlvbigpe3JldHVybiBzJiYocz1bXSksdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiBhPXU9W10scz10PVwiXCIsdGhpc30sZGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hc30sbG9jazpmdW5jdGlvbigpe3JldHVybiBhPXU9W10sdHx8aXx8KHM9dD1cIlwiKSx0aGlzfSxsb2NrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIWF9LGZpcmVXaXRoOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGF8fCh0PVtlLCh0PXR8fFtdKS5zbGljZT90LnNsaWNlKCk6dF0sdS5wdXNoKHQpLGl8fGMoKSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBmLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhb319O3JldHVybiBmfSxjZS5leHRlbmQoe0RlZmVycmVkOmZ1bmN0aW9uKGUpe3ZhciBvPVtbXCJub3RpZnlcIixcInByb2dyZXNzXCIsY2UuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLGNlLkNhbGxiYWNrcyhcIm1lbW9yeVwiKSwyXSxbXCJyZXNvbHZlXCIsXCJkb25lXCIsY2UuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksY2UuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksMCxcInJlc29sdmVkXCJdLFtcInJlamVjdFwiLFwiZmFpbFwiLGNlLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLGNlLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLDEsXCJyZWplY3RlZFwiXV0saT1cInBlbmRpbmdcIixhPXtzdGF0ZTpmdW5jdGlvbigpe3JldHVybiBpfSxhbHdheXM6ZnVuY3Rpb24oKXtyZXR1cm4gcy5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpLHRoaXN9LFwiY2F0Y2hcIjpmdW5jdGlvbihlKXtyZXR1cm4gYS50aGVuKG51bGwsZSl9LHBpcGU6ZnVuY3Rpb24oKXt2YXIgaT1hcmd1bWVudHM7cmV0dXJuIGNlLkRlZmVycmVkKGZ1bmN0aW9uKHIpe2NlLmVhY2gobyxmdW5jdGlvbihlLHQpe3ZhciBuPXYoaVt0WzRdXSkmJmlbdFs0XV07c1t0WzFdXShmdW5jdGlvbigpe3ZhciBlPW4mJm4uYXBwbHkodGhpcyxhcmd1bWVudHMpO2UmJnYoZS5wcm9taXNlKT9lLnByb21pc2UoKS5wcm9ncmVzcyhyLm5vdGlmeSkuZG9uZShyLnJlc29sdmUpLmZhaWwoci5yZWplY3QpOnJbdFswXStcIldpdGhcIl0odGhpcyxuP1tlXTphcmd1bWVudHMpfSl9KSxpPW51bGx9KS5wcm9taXNlKCl9LHRoZW46ZnVuY3Rpb24odCxuLHIpe3ZhciB1PTA7ZnVuY3Rpb24gbChpLG8sYSxzKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj10aGlzLHI9YXJndW1lbnRzLGU9ZnVuY3Rpb24oKXt2YXIgZSx0O2lmKCEoaTx1KSl7aWYoKGU9YS5hcHBseShuLHIpKT09PW8ucHJvbWlzZSgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIik7dD1lJiYoXCJvYmplY3RcIj09dHlwZW9mIGV8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpJiZlLnRoZW4sdih0KT9zP3QuY2FsbChlLGwodSxvLE4scyksbCh1LG8scSxzKSk6KHUrKyx0LmNhbGwoZSxsKHUsbyxOLHMpLGwodSxvLHEscyksbCh1LG8sTixvLm5vdGlmeVdpdGgpKSk6KGEhPT1OJiYobj12b2lkIDAscj1bZV0pLChzfHxvLnJlc29sdmVXaXRoKShuLHIpKX19LHQ9cz9lOmZ1bmN0aW9uKCl7dHJ5e2UoKX1jYXRjaChlKXtjZS5EZWZlcnJlZC5leGNlcHRpb25Ib29rJiZjZS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKGUsdC5lcnJvciksdTw9aSsxJiYoYSE9PXEmJihuPXZvaWQgMCxyPVtlXSksby5yZWplY3RXaXRoKG4scikpfX07aT90KCk6KGNlLkRlZmVycmVkLmdldEVycm9ySG9vaz90LmVycm9yPWNlLkRlZmVycmVkLmdldEVycm9ySG9vaygpOmNlLkRlZmVycmVkLmdldFN0YWNrSG9vayYmKHQuZXJyb3I9Y2UuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCkpLGllLnNldFRpbWVvdXQodCkpfX1yZXR1cm4gY2UuRGVmZXJyZWQoZnVuY3Rpb24oZSl7b1swXVszXS5hZGQobCgwLGUsdihyKT9yOk4sZS5ub3RpZnlXaXRoKSksb1sxXVszXS5hZGQobCgwLGUsdih0KT90Ok4pKSxvWzJdWzNdLmFkZChsKDAsZSx2KG4pP246cSkpfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lP2NlLmV4dGVuZChlLGEpOmF9fSxzPXt9O3JldHVybiBjZS5lYWNoKG8sZnVuY3Rpb24oZSx0KXt2YXIgbj10WzJdLHI9dFs1XTthW3RbMV1dPW4uYWRkLHImJm4uYWRkKGZ1bmN0aW9uKCl7aT1yfSxvWzMtZV1bMl0uZGlzYWJsZSxvWzMtZV1bM10uZGlzYWJsZSxvWzBdWzJdLmxvY2ssb1swXVszXS5sb2NrKSxuLmFkZCh0WzNdLmZpcmUpLHNbdFswXV09ZnVuY3Rpb24oKXtyZXR1cm4gc1t0WzBdK1wiV2l0aFwiXSh0aGlzPT09cz92b2lkIDA6dGhpcyxhcmd1bWVudHMpLHRoaXN9LHNbdFswXStcIldpdGhcIl09bi5maXJlV2l0aH0pLGEucHJvbWlzZShzKSxlJiZlLmNhbGwocyxzKSxzfSx3aGVuOmZ1bmN0aW9uKGUpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgsdD1uLHI9QXJyYXkodCksaT1hZS5jYWxsKGFyZ3VtZW50cyksbz1jZS5EZWZlcnJlZCgpLGE9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JbdF09dGhpcyxpW3RdPTE8YXJndW1lbnRzLmxlbmd0aD9hZS5jYWxsKGFyZ3VtZW50cyk6ZSwtLW58fG8ucmVzb2x2ZVdpdGgocixpKX19O2lmKG48PTEmJihMKGUsby5kb25lKGEodCkpLnJlc29sdmUsby5yZWplY3QsIW4pLFwicGVuZGluZ1wiPT09by5zdGF0ZSgpfHx2KGlbdF0mJmlbdF0udGhlbikpKXJldHVybiBvLnRoZW4oKTt3aGlsZSh0LS0pTChpW3RdLGEodCksby5yZWplY3QpO3JldHVybiBvLnByb21pc2UoKX19KTt2YXIgSD0vXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztjZS5EZWZlcnJlZC5leGNlcHRpb25Ib29rPWZ1bmN0aW9uKGUsdCl7aWUuY29uc29sZSYmaWUuY29uc29sZS53YXJuJiZlJiZILnRlc3QoZS5uYW1lKSYmaWUuY29uc29sZS53YXJuKFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIrZS5tZXNzYWdlLGUuc3RhY2ssdCl9LGNlLnJlYWR5RXhjZXB0aW9uPWZ1bmN0aW9uKGUpe2llLnNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlfSl9O3ZhciBPPWNlLkRlZmVycmVkKCk7ZnVuY3Rpb24gUCgpe0MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixQKSxpZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLFApLGNlLnJlYWR5KCl9Y2UuZm4ucmVhZHk9ZnVuY3Rpb24oZSl7cmV0dXJuIE8udGhlbihlKVtcImNhdGNoXCJdKGZ1bmN0aW9uKGUpe2NlLnJlYWR5RXhjZXB0aW9uKGUpfSksdGhpc30sY2UuZXh0ZW5kKHtpc1JlYWR5OiExLHJlYWR5V2FpdDoxLHJlYWR5OmZ1bmN0aW9uKGUpeyghMD09PWU/LS1jZS5yZWFkeVdhaXQ6Y2UuaXNSZWFkeSl8fChjZS5pc1JlYWR5PSEwKSE9PWUmJjA8LS1jZS5yZWFkeVdhaXR8fE8ucmVzb2x2ZVdpdGgoQyxbY2VdKX19KSxjZS5yZWFkeS50aGVuPU8udGhlbixcImNvbXBsZXRlXCI9PT1DLnJlYWR5U3RhdGV8fFwibG9hZGluZ1wiIT09Qy5yZWFkeVN0YXRlJiYhQy5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGw/aWUuc2V0VGltZW91dChjZS5yZWFkeSk6KEMuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixQKSxpZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLFApKTt2YXIgTT1mdW5jdGlvbihlLHQsbixyLGksbyxhKXt2YXIgcz0wLHU9ZS5sZW5ndGgsbD1udWxsPT1uO2lmKFwib2JqZWN0XCI9PT14KG4pKWZvcihzIGluIGk9ITAsbilNKGUsdCxzLG5bc10sITAsbyxhKTtlbHNlIGlmKHZvaWQgMCE9PXImJihpPSEwLHYocil8fChhPSEwKSxsJiYoYT8odC5jYWxsKGUsciksdD1udWxsKToobD10LHQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBsLmNhbGwoY2UoZSksbil9KSksdCkpZm9yKDtzPHU7cysrKXQoZVtzXSxuLGE/cjpyLmNhbGwoZVtzXSxzLHQoZVtzXSxuKSkpO3JldHVybiBpP2U6bD90LmNhbGwoZSk6dT90KGVbMF0sbik6b30sUj0vXi1tcy0vLEk9Ly0oW2Etel0pL2c7ZnVuY3Rpb24gVyhlLHQpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9ZnVuY3Rpb24gRihlKXtyZXR1cm4gZS5yZXBsYWNlKFIsXCJtcy1cIikucmVwbGFjZShJLFcpfXZhciAkPWZ1bmN0aW9uKGUpe3JldHVybiAxPT09ZS5ub2RlVHlwZXx8OT09PWUubm9kZVR5cGV8fCErZS5ub2RlVHlwZX07ZnVuY3Rpb24gQigpe3RoaXMuZXhwYW5kbz1jZS5leHBhbmRvK0IudWlkKyt9Qi51aWQ9MSxCLnByb3RvdHlwZT17Y2FjaGU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZVt0aGlzLmV4cGFuZG9dO3JldHVybiB0fHwodD17fSwkKGUpJiYoZS5ub2RlVHlwZT9lW3RoaXMuZXhwYW5kb109dDpPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0aGlzLmV4cGFuZG8se3ZhbHVlOnQsY29uZmlndXJhYmxlOiEwfSkpKSx0fSxzZXQ6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk9dGhpcy5jYWNoZShlKTtpZihcInN0cmluZ1wiPT10eXBlb2YgdClpW0YodCldPW47ZWxzZSBmb3IociBpbiB0KWlbRihyKV09dFtyXTtyZXR1cm4gaX0sZ2V0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQ/dGhpcy5jYWNoZShlKTplW3RoaXMuZXhwYW5kb10mJmVbdGhpcy5leHBhbmRvXVtGKHQpXX0sYWNjZXNzOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdm9pZCAwPT09dHx8dCYmXCJzdHJpbmdcIj09dHlwZW9mIHQmJnZvaWQgMD09PW4/dGhpcy5nZXQoZSx0KToodGhpcy5zZXQoZSx0LG4pLHZvaWQgMCE9PW4/bjp0KX0scmVtb3ZlOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj1lW3RoaXMuZXhwYW5kb107aWYodm9pZCAwIT09cil7aWYodm9pZCAwIT09dCl7bj0odD1BcnJheS5pc0FycmF5KHQpP3QubWFwKEYpOih0PUYodCkpaW4gcj9bdF06dC5tYXRjaChEKXx8W10pLmxlbmd0aDt3aGlsZShuLS0pZGVsZXRlIHJbdFtuXV19KHZvaWQgMD09PXR8fGNlLmlzRW1wdHlPYmplY3QocikpJiYoZS5ub2RlVHlwZT9lW3RoaXMuZXhwYW5kb109dm9pZCAwOmRlbGV0ZSBlW3RoaXMuZXhwYW5kb10pfX0saGFzRGF0YTpmdW5jdGlvbihlKXt2YXIgdD1lW3RoaXMuZXhwYW5kb107cmV0dXJuIHZvaWQgMCE9PXQmJiFjZS5pc0VtcHR5T2JqZWN0KHQpfX07dmFyIF89bmV3IEIsej1uZXcgQixYPS9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxVPS9bQS1aXS9nO2Z1bmN0aW9uIFYoZSx0LG4pe3ZhciByLGk7aWYodm9pZCAwPT09biYmMT09PWUubm9kZVR5cGUpaWYocj1cImRhdGEtXCIrdC5yZXBsYWNlKFUsXCItJCZcIikudG9Mb3dlckNhc2UoKSxcInN0cmluZ1wiPT10eXBlb2Yobj1lLmdldEF0dHJpYnV0ZShyKSkpe3RyeXtuPVwidHJ1ZVwiPT09KGk9bil8fFwiZmFsc2VcIiE9PWkmJihcIm51bGxcIj09PWk/bnVsbDppPT09K2krXCJcIj8raTpYLnRlc3QoaSk/SlNPTi5wYXJzZShpKTppKX1jYXRjaChlKXt9ei5zZXQoZSx0LG4pfWVsc2Ugbj12b2lkIDA7cmV0dXJuIG59Y2UuZXh0ZW5kKHtoYXNEYXRhOmZ1bmN0aW9uKGUpe3JldHVybiB6Lmhhc0RhdGEoZSl8fF8uaGFzRGF0YShlKX0sZGF0YTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHouYWNjZXNzKGUsdCxuKX0scmVtb3ZlRGF0YTpmdW5jdGlvbihlLHQpe3oucmVtb3ZlKGUsdCl9LF9kYXRhOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gXy5hY2Nlc3MoZSx0LG4pfSxfcmVtb3ZlRGF0YTpmdW5jdGlvbihlLHQpe18ucmVtb3ZlKGUsdCl9fSksY2UuZm4uZXh0ZW5kKHtkYXRhOmZ1bmN0aW9uKG4sZSl7dmFyIHQscixpLG89dGhpc1swXSxhPW8mJm8uYXR0cmlidXRlcztpZih2b2lkIDA9PT1uKXtpZih0aGlzLmxlbmd0aCYmKGk9ei5nZXQobyksMT09PW8ubm9kZVR5cGUmJiFfLmdldChvLFwiaGFzRGF0YUF0dHJzXCIpKSl7dD1hLmxlbmd0aDt3aGlsZSh0LS0pYVt0XSYmMD09PShyPWFbdF0ubmFtZSkuaW5kZXhPZihcImRhdGEtXCIpJiYocj1GKHIuc2xpY2UoNSkpLFYobyxyLGlbcl0pKTtfLnNldChvLFwiaGFzRGF0YUF0dHJzXCIsITApfXJldHVybiBpfXJldHVyblwib2JqZWN0XCI9PXR5cGVvZiBuP3RoaXMuZWFjaChmdW5jdGlvbigpe3ouc2V0KHRoaXMsbil9KTpNKHRoaXMsZnVuY3Rpb24oZSl7dmFyIHQ7aWYobyYmdm9pZCAwPT09ZSlyZXR1cm4gdm9pZCAwIT09KHQ9ei5nZXQobyxuKSk/dDp2b2lkIDAhPT0odD1WKG8sbikpP3Q6dm9pZCAwO3RoaXMuZWFjaChmdW5jdGlvbigpe3ouc2V0KHRoaXMsbixlKX0pfSxudWxsLGUsMTxhcmd1bWVudHMubGVuZ3RoLG51bGwsITApfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt6LnJlbW92ZSh0aGlzLGUpfSl9fSksY2UuZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihlLHQsbil7dmFyIHI7aWYoZSlyZXR1cm4gdD0odHx8XCJmeFwiKStcInF1ZXVlXCIscj1fLmdldChlLHQpLG4mJighcnx8QXJyYXkuaXNBcnJheShuKT9yPV8uYWNjZXNzKGUsdCxjZS5tYWtlQXJyYXkobikpOnIucHVzaChuKSkscnx8W119LGRlcXVldWU6ZnVuY3Rpb24oZSx0KXt0PXR8fFwiZnhcIjt2YXIgbj1jZS5xdWV1ZShlLHQpLHI9bi5sZW5ndGgsaT1uLnNoaWZ0KCksbz1jZS5fcXVldWVIb29rcyhlLHQpO1wiaW5wcm9ncmVzc1wiPT09aSYmKGk9bi5zaGlmdCgpLHItLSksaSYmKFwiZnhcIj09PXQmJm4udW5zaGlmdChcImlucHJvZ3Jlc3NcIiksZGVsZXRlIG8uc3RvcCxpLmNhbGwoZSxmdW5jdGlvbigpe2NlLmRlcXVldWUoZSx0KX0sbykpLCFyJiZvJiZvLmVtcHR5LmZpcmUoKX0sX3F1ZXVlSG9va3M6ZnVuY3Rpb24oZSx0KXt2YXIgbj10K1wicXVldWVIb29rc1wiO3JldHVybiBfLmdldChlLG4pfHxfLmFjY2VzcyhlLG4se2VtcHR5OmNlLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpe18ucmVtb3ZlKGUsW3QrXCJxdWV1ZVwiLG5dKX0pfSl9fSksY2UuZm4uZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbih0LG4pe3ZhciBlPTI7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIHQmJihuPXQsdD1cImZ4XCIsZS0tKSxhcmd1bWVudHMubGVuZ3RoPGU/Y2UucXVldWUodGhpc1swXSx0KTp2b2lkIDA9PT1uP3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9Y2UucXVldWUodGhpcyx0LG4pO2NlLl9xdWV1ZUhvb2tzKHRoaXMsdCksXCJmeFwiPT09dCYmXCJpbnByb2dyZXNzXCIhPT1lWzBdJiZjZS5kZXF1ZXVlKHRoaXMsdCl9KX0sZGVxdWV1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Y2UuZGVxdWV1ZSh0aGlzLGUpfSl9LGNsZWFyUXVldWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucXVldWUoZXx8XCJmeFwiLFtdKX0scHJvbWlzZTpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MSxpPWNlLkRlZmVycmVkKCksbz10aGlzLGE9dGhpcy5sZW5ndGgscz1mdW5jdGlvbigpey0tcnx8aS5yZXNvbHZlV2l0aChvLFtvXSl9O1wic3RyaW5nXCIhPXR5cGVvZiBlJiYodD1lLGU9dm9pZCAwKSxlPWV8fFwiZnhcIjt3aGlsZShhLS0pKG49Xy5nZXQob1thXSxlK1wicXVldWVIb29rc1wiKSkmJm4uZW1wdHkmJihyKyssbi5lbXB0eS5hZGQocykpO3JldHVybiBzKCksaS5wcm9taXNlKHQpfX0pO3ZhciBHPS9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZSxZPW5ldyBSZWdFeHAoXCJeKD86KFsrLV0pPXwpKFwiK0crXCIpKFthLXolXSopJFwiLFwiaVwiKSxRPVtcIlRvcFwiLFwiUmlnaHRcIixcIkJvdHRvbVwiLFwiTGVmdFwiXSxKPUMuZG9jdW1lbnRFbGVtZW50LEs9ZnVuY3Rpb24oZSl7cmV0dXJuIGNlLmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCxlKX0sWj17Y29tcG9zZWQ6ITB9O0ouZ2V0Um9vdE5vZGUmJihLPWZ1bmN0aW9uKGUpe3JldHVybiBjZS5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsZSl8fGUuZ2V0Um9vdE5vZGUoWik9PT1lLm93bmVyRG9jdW1lbnR9KTt2YXIgZWU9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cIm5vbmVcIj09PShlPXR8fGUpLnN0eWxlLmRpc3BsYXl8fFwiXCI9PT1lLnN0eWxlLmRpc3BsYXkmJksoZSkmJlwibm9uZVwiPT09Y2UuY3NzKGUsXCJkaXNwbGF5XCIpfTtmdW5jdGlvbiB0ZShlLHQsbixyKXt2YXIgaSxvLGE9MjAscz1yP2Z1bmN0aW9uKCl7cmV0dXJuIHIuY3VyKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIGNlLmNzcyhlLHQsXCJcIil9LHU9cygpLGw9biYmblszXXx8KGNlLmNzc051bWJlclt0XT9cIlwiOlwicHhcIiksYz1lLm5vZGVUeXBlJiYoY2UuY3NzTnVtYmVyW3RdfHxcInB4XCIhPT1sJiYrdSkmJlkuZXhlYyhjZS5jc3MoZSx0KSk7aWYoYyYmY1szXSE9PWwpe3UvPTIsbD1sfHxjWzNdLGM9K3V8fDE7d2hpbGUoYS0tKWNlLnN0eWxlKGUsdCxjK2wpLCgxLW8pKigxLShvPXMoKS91fHwuNSkpPD0wJiYoYT0wKSxjLz1vO2MqPTIsY2Uuc3R5bGUoZSx0LGMrbCksbj1ufHxbXX1yZXR1cm4gbiYmKGM9K2N8fCt1fHwwLGk9blsxXT9jKyhuWzFdKzEpKm5bMl06K25bMl0sciYmKHIudW5pdD1sLHIuc3RhcnQ9YyxyLmVuZD1pKSksaX12YXIgbmU9e307ZnVuY3Rpb24gcmUoZSx0KXtmb3IodmFyIG4scixpLG8sYSxzLHUsbD1bXSxjPTAsZj1lLmxlbmd0aDtjPGY7YysrKShyPWVbY10pLnN0eWxlJiYobj1yLnN0eWxlLmRpc3BsYXksdD8oXCJub25lXCI9PT1uJiYobFtjXT1fLmdldChyLFwiZGlzcGxheVwiKXx8bnVsbCxsW2NdfHwoci5zdHlsZS5kaXNwbGF5PVwiXCIpKSxcIlwiPT09ci5zdHlsZS5kaXNwbGF5JiZlZShyKSYmKGxbY109KHU9YT1vPXZvaWQgMCxhPShpPXIpLm93bmVyRG9jdW1lbnQscz1pLm5vZGVOYW1lLCh1PW5lW3NdKXx8KG89YS5ib2R5LmFwcGVuZENoaWxkKGEuY3JlYXRlRWxlbWVudChzKSksdT1jZS5jc3MobyxcImRpc3BsYXlcIiksby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pLFwibm9uZVwiPT09dSYmKHU9XCJibG9ja1wiKSxuZVtzXT11KSkpKTpcIm5vbmVcIiE9PW4mJihsW2NdPVwibm9uZVwiLF8uc2V0KHIsXCJkaXNwbGF5XCIsbikpKTtmb3IoYz0wO2M8ZjtjKyspbnVsbCE9bFtjXSYmKGVbY10uc3R5bGUuZGlzcGxheT1sW2NdKTtyZXR1cm4gZX1jZS5mbi5leHRlbmQoe3Nob3c6ZnVuY3Rpb24oKXtyZXR1cm4gcmUodGhpcywhMCl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gcmUodGhpcyl9LHRvZ2dsZTpmdW5jdGlvbihlKXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGU/ZT90aGlzLnNob3coKTp0aGlzLmhpZGUoKTp0aGlzLmVhY2goZnVuY3Rpb24oKXtlZSh0aGlzKT9jZSh0aGlzKS5zaG93KCk6Y2UodGhpcykuaGlkZSgpfSl9fSk7dmFyIHhlLGJlLHdlPS9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLFRlPS88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSxDZT0vXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pO3hlPUMuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLmFwcGVuZENoaWxkKEMuY3JlYXRlRWxlbWVudChcImRpdlwiKSksKGJlPUMuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJyYWRpb1wiKSxiZS5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsXCJjaGVja2VkXCIpLGJlLnNldEF0dHJpYnV0ZShcIm5hbWVcIixcInRcIikseGUuYXBwZW5kQ2hpbGQoYmUpLGxlLmNoZWNrQ2xvbmU9eGUuY2xvbmVOb2RlKCEwKS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5jaGVja2VkLHhlLmlubmVySFRNTD1cIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIixsZS5ub0Nsb25lQ2hlY2tlZD0hIXhlLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZSx4ZS5pbm5lckhUTUw9XCI8b3B0aW9uPjwvb3B0aW9uPlwiLGxlLm9wdGlvbj0hIXhlLmxhc3RDaGlsZDt2YXIga2U9e3RoZWFkOlsxLFwiPHRhYmxlPlwiLFwiPC90YWJsZT5cIl0sY29sOlsyLFwiPHRhYmxlPjxjb2xncm91cD5cIixcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sdHI6WzIsXCI8dGFibGU+PHRib2R5PlwiLFwiPC90Ym9keT48L3RhYmxlPlwiXSx0ZDpbMyxcIjx0YWJsZT48dGJvZHk+PHRyPlwiLFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCJdLF9kZWZhdWx0OlswLFwiXCIsXCJcIl19O2Z1bmN0aW9uIFNlKGUsdCl7dmFyIG47cmV0dXJuIG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuZ2V0RWxlbWVudHNCeVRhZ05hbWU/ZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0fHxcIipcIik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUucXVlcnlTZWxlY3RvckFsbD9lLnF1ZXJ5U2VsZWN0b3JBbGwodHx8XCIqXCIpOltdLHZvaWQgMD09PXR8fHQmJmZlKGUsdCk/Y2UubWVyZ2UoW2VdLG4pOm59ZnVuY3Rpb24gRWUoZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjtuKyspXy5zZXQoZVtuXSxcImdsb2JhbEV2YWxcIiwhdHx8Xy5nZXQodFtuXSxcImdsb2JhbEV2YWxcIikpfWtlLnRib2R5PWtlLnRmb290PWtlLmNvbGdyb3VwPWtlLmNhcHRpb249a2UudGhlYWQsa2UudGg9a2UudGQsbGUub3B0aW9ufHwoa2Uub3B0Z3JvdXA9a2Uub3B0aW9uPVsxLFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLFwiPC9zZWxlY3Q+XCJdKTt2YXIgamU9Lzx8JiM/XFx3KzsvO2Z1bmN0aW9uIEFlKGUsdCxuLHIsaSl7Zm9yKHZhciBvLGEscyx1LGwsYyxmPXQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHA9W10sZD0wLGg9ZS5sZW5ndGg7ZDxoO2QrKylpZigobz1lW2RdKXx8MD09PW8paWYoXCJvYmplY3RcIj09PXgobykpY2UubWVyZ2UocCxvLm5vZGVUeXBlP1tvXTpvKTtlbHNlIGlmKGplLnRlc3Qobykpe2E9YXx8Zi5hcHBlbmRDaGlsZCh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLHM9KFRlLmV4ZWMobyl8fFtcIlwiLFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLHU9a2Vbc118fGtlLl9kZWZhdWx0LGEuaW5uZXJIVE1MPXVbMV0rY2UuaHRtbFByZWZpbHRlcihvKSt1WzJdLGM9dVswXTt3aGlsZShjLS0pYT1hLmxhc3RDaGlsZDtjZS5tZXJnZShwLGEuY2hpbGROb2RlcyksKGE9Zi5maXJzdENoaWxkKS50ZXh0Q29udGVudD1cIlwifWVsc2UgcC5wdXNoKHQuY3JlYXRlVGV4dE5vZGUobykpO2YudGV4dENvbnRlbnQ9XCJcIixkPTA7d2hpbGUobz1wW2QrK10paWYociYmLTE8Y2UuaW5BcnJheShvLHIpKWkmJmkucHVzaChvKTtlbHNlIGlmKGw9SyhvKSxhPVNlKGYuYXBwZW5kQ2hpbGQobyksXCJzY3JpcHRcIiksbCYmRWUoYSksbil7Yz0wO3doaWxlKG89YVtjKytdKUNlLnRlc3Qoby50eXBlfHxcIlwiKSYmbi5wdXNoKG8pfXJldHVybiBmfXZhciBEZT0vXihbXi5dKikoPzpcXC4oLispfCkvO2Z1bmN0aW9uIE5lKCl7cmV0dXJuITB9ZnVuY3Rpb24gcWUoKXtyZXR1cm4hMX1mdW5jdGlvbiBMZShlLHQsbixyLGksbyl7dmFyIGEscztpZihcIm9iamVjdFwiPT10eXBlb2YgdCl7Zm9yKHMgaW5cInN0cmluZ1wiIT10eXBlb2YgbiYmKHI9cnx8bixuPXZvaWQgMCksdClMZShlLHMsbixyLHRbc10sbyk7cmV0dXJuIGV9aWYobnVsbD09ciYmbnVsbD09aT8oaT1uLHI9bj12b2lkIDApOm51bGw9PWkmJihcInN0cmluZ1wiPT10eXBlb2Ygbj8oaT1yLHI9dm9pZCAwKTooaT1yLHI9bixuPXZvaWQgMCkpLCExPT09aSlpPXFlO2Vsc2UgaWYoIWkpcmV0dXJuIGU7cmV0dXJuIDE9PT1vJiYoYT1pLChpPWZ1bmN0aW9uKGUpe3JldHVybiBjZSgpLm9mZihlKSxhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pLmd1aWQ9YS5ndWlkfHwoYS5ndWlkPWNlLmd1aWQrKykpLGUuZWFjaChmdW5jdGlvbigpe2NlLmV2ZW50LmFkZCh0aGlzLHQsaSxyLG4pfSl9ZnVuY3Rpb24gSGUoZSxyLHQpe3Q/KF8uc2V0KGUsciwhMSksY2UuZXZlbnQuYWRkKGUscix7bmFtZXNwYWNlOiExLGhhbmRsZXI6ZnVuY3Rpb24oZSl7dmFyIHQsbj1fLmdldCh0aGlzLHIpO2lmKDEmZS5pc1RyaWdnZXImJnRoaXNbcl0pe2lmKG4pKGNlLmV2ZW50LnNwZWNpYWxbcl18fHt9KS5kZWxlZ2F0ZVR5cGUmJmUuc3RvcFByb3BhZ2F0aW9uKCk7ZWxzZSBpZihuPWFlLmNhbGwoYXJndW1lbnRzKSxfLnNldCh0aGlzLHIsbiksdGhpc1tyXSgpLHQ9Xy5nZXQodGhpcyxyKSxfLnNldCh0aGlzLHIsITEpLG4hPT10KXJldHVybiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGUucHJldmVudERlZmF1bHQoKSx0fWVsc2UgbiYmKF8uc2V0KHRoaXMscixjZS5ldmVudC50cmlnZ2VyKG5bMF0sbi5zbGljZSgxKSx0aGlzKSksZS5zdG9wUHJvcGFnYXRpb24oKSxlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPU5lKX19KSk6dm9pZCAwPT09Xy5nZXQoZSxyKSYmY2UuZXZlbnQuYWRkKGUscixOZSl9Y2UuZXZlbnQ9e2dsb2JhbDp7fSxhZGQ6ZnVuY3Rpb24odCxlLG4scixpKXt2YXIgbyxhLHMsdSxsLGMsZixwLGQsaCxnLHY9Xy5nZXQodCk7aWYoJCh0KSl7bi5oYW5kbGVyJiYobj0obz1uKS5oYW5kbGVyLGk9by5zZWxlY3RvciksaSYmY2UuZmluZC5tYXRjaGVzU2VsZWN0b3IoSixpKSxuLmd1aWR8fChuLmd1aWQ9Y2UuZ3VpZCsrKSwodT12LmV2ZW50cyl8fCh1PXYuZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCkpLChhPXYuaGFuZGxlKXx8KGE9di5oYW5kbGU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNlJiZjZS5ldmVudC50cmlnZ2VyZWQhPT1lLnR5cGU/Y2UuZXZlbnQuZGlzcGF0Y2guYXBwbHkodCxhcmd1bWVudHMpOnZvaWQgMH0pLGw9KGU9KGV8fFwiXCIpLm1hdGNoKEQpfHxbXCJcIl0pLmxlbmd0aDt3aGlsZShsLS0pZD1nPShzPURlLmV4ZWMoZVtsXSl8fFtdKVsxXSxoPShzWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLGQmJihmPWNlLmV2ZW50LnNwZWNpYWxbZF18fHt9LGQ9KGk/Zi5kZWxlZ2F0ZVR5cGU6Zi5iaW5kVHlwZSl8fGQsZj1jZS5ldmVudC5zcGVjaWFsW2RdfHx7fSxjPWNlLmV4dGVuZCh7dHlwZTpkLG9yaWdUeXBlOmcsZGF0YTpyLGhhbmRsZXI6bixndWlkOm4uZ3VpZCxzZWxlY3RvcjppLG5lZWRzQ29udGV4dDppJiZjZS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KGkpLG5hbWVzcGFjZTpoLmpvaW4oXCIuXCIpfSxvKSwocD11W2RdKXx8KChwPXVbZF09W10pLmRlbGVnYXRlQ291bnQ9MCxmLnNldHVwJiYhMSE9PWYuc2V0dXAuY2FsbCh0LHIsaCxhKXx8dC5hZGRFdmVudExpc3RlbmVyJiZ0LmFkZEV2ZW50TGlzdGVuZXIoZCxhKSksZi5hZGQmJihmLmFkZC5jYWxsKHQsYyksYy5oYW5kbGVyLmd1aWR8fChjLmhhbmRsZXIuZ3VpZD1uLmd1aWQpKSxpP3Auc3BsaWNlKHAuZGVsZWdhdGVDb3VudCsrLDAsYyk6cC5wdXNoKGMpLGNlLmV2ZW50Lmdsb2JhbFtkXT0hMCl9fSxyZW1vdmU6ZnVuY3Rpb24oZSx0LG4scixpKXt2YXIgbyxhLHMsdSxsLGMsZixwLGQsaCxnLHY9Xy5oYXNEYXRhKGUpJiZfLmdldChlKTtpZih2JiYodT12LmV2ZW50cykpe2w9KHQ9KHR8fFwiXCIpLm1hdGNoKEQpfHxbXCJcIl0pLmxlbmd0aDt3aGlsZShsLS0paWYoZD1nPShzPURlLmV4ZWModFtsXSl8fFtdKVsxXSxoPShzWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLGQpe2Y9Y2UuZXZlbnQuc3BlY2lhbFtkXXx8e30scD11W2Q9KHI/Zi5kZWxlZ2F0ZVR5cGU6Zi5iaW5kVHlwZSl8fGRdfHxbXSxzPXNbMl0mJm5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKSxhPW89cC5sZW5ndGg7d2hpbGUoby0tKWM9cFtvXSwhaSYmZyE9PWMub3JpZ1R5cGV8fG4mJm4uZ3VpZCE9PWMuZ3VpZHx8cyYmIXMudGVzdChjLm5hbWVzcGFjZSl8fHImJnIhPT1jLnNlbGVjdG9yJiYoXCIqKlwiIT09cnx8IWMuc2VsZWN0b3IpfHwocC5zcGxpY2UobywxKSxjLnNlbGVjdG9yJiZwLmRlbGVnYXRlQ291bnQtLSxmLnJlbW92ZSYmZi5yZW1vdmUuY2FsbChlLGMpKTthJiYhcC5sZW5ndGgmJihmLnRlYXJkb3duJiYhMSE9PWYudGVhcmRvd24uY2FsbChlLGgsdi5oYW5kbGUpfHxjZS5yZW1vdmVFdmVudChlLGQsdi5oYW5kbGUpLGRlbGV0ZSB1W2RdKX1lbHNlIGZvcihkIGluIHUpY2UuZXZlbnQucmVtb3ZlKGUsZCt0W2xdLG4sciwhMCk7Y2UuaXNFbXB0eU9iamVjdCh1KSYmXy5yZW1vdmUoZSxcImhhbmRsZSBldmVudHNcIil9fSxkaXNwYXRjaDpmdW5jdGlvbihlKXt2YXIgdCxuLHIsaSxvLGEscz1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksdT1jZS5ldmVudC5maXgoZSksbD0oXy5nZXQodGhpcyxcImV2ZW50c1wiKXx8T2JqZWN0LmNyZWF0ZShudWxsKSlbdS50eXBlXXx8W10sYz1jZS5ldmVudC5zcGVjaWFsW3UudHlwZV18fHt9O2ZvcihzWzBdPXUsdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspc1t0XT1hcmd1bWVudHNbdF07aWYodS5kZWxlZ2F0ZVRhcmdldD10aGlzLCFjLnByZURpc3BhdGNofHwhMSE9PWMucHJlRGlzcGF0Y2guY2FsbCh0aGlzLHUpKXthPWNlLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcyx1LGwpLHQ9MDt3aGlsZSgoaT1hW3QrK10pJiYhdS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXt1LmN1cnJlbnRUYXJnZXQ9aS5lbGVtLG49MDt3aGlsZSgobz1pLmhhbmRsZXJzW24rK10pJiYhdS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKXUucm5hbWVzcGFjZSYmITEhPT1vLm5hbWVzcGFjZSYmIXUucm5hbWVzcGFjZS50ZXN0KG8ubmFtZXNwYWNlKXx8KHUuaGFuZGxlT2JqPW8sdS5kYXRhPW8uZGF0YSx2b2lkIDAhPT0ocj0oKGNlLmV2ZW50LnNwZWNpYWxbby5vcmlnVHlwZV18fHt9KS5oYW5kbGV8fG8uaGFuZGxlcikuYXBwbHkoaS5lbGVtLHMpKSYmITE9PT0odS5yZXN1bHQ9cikmJih1LnByZXZlbnREZWZhdWx0KCksdS5zdG9wUHJvcGFnYXRpb24oKSkpfXJldHVybiBjLnBvc3REaXNwYXRjaCYmYy5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLHUpLHUucmVzdWx0fX0saGFuZGxlcnM6ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGksbyxhLHM9W10sdT10LmRlbGVnYXRlQ291bnQsbD1lLnRhcmdldDtpZih1JiZsLm5vZGVUeXBlJiYhKFwiY2xpY2tcIj09PWUudHlwZSYmMTw9ZS5idXR0b24pKWZvcig7bCE9PXRoaXM7bD1sLnBhcmVudE5vZGV8fHRoaXMpaWYoMT09PWwubm9kZVR5cGUmJihcImNsaWNrXCIhPT1lLnR5cGV8fCEwIT09bC5kaXNhYmxlZCkpe2ZvcihvPVtdLGE9e30sbj0wO248dTtuKyspdm9pZCAwPT09YVtpPShyPXRbbl0pLnNlbGVjdG9yK1wiIFwiXSYmKGFbaV09ci5uZWVkc0NvbnRleHQ/LTE8Y2UoaSx0aGlzKS5pbmRleChsKTpjZS5maW5kKGksdGhpcyxudWxsLFtsXSkubGVuZ3RoKSxhW2ldJiZvLnB1c2gocik7by5sZW5ndGgmJnMucHVzaCh7ZWxlbTpsLGhhbmRsZXJzOm99KX1yZXR1cm4gbD10aGlzLHU8dC5sZW5ndGgmJnMucHVzaCh7ZWxlbTpsLGhhbmRsZXJzOnQuc2xpY2UodSl9KSxzfSxhZGRQcm9wOmZ1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGNlLkV2ZW50LnByb3RvdHlwZSx0LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6dihlKT9mdW5jdGlvbigpe2lmKHRoaXMub3JpZ2luYWxFdmVudClyZXR1cm4gZSh0aGlzLm9yaWdpbmFsRXZlbnQpfTpmdW5jdGlvbigpe2lmKHRoaXMub3JpZ2luYWxFdmVudClyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50W3RdfSxzZXQ6ZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsdCx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZX0pfX0pfSxmaXg6ZnVuY3Rpb24oZSl7cmV0dXJuIGVbY2UuZXhwYW5kb10/ZTpuZXcgY2UuRXZlbnQoZSl9LHNwZWNpYWw6e2xvYWQ6e25vQnViYmxlOiEwfSxjbGljazp7c2V0dXA6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpc3x8ZTtyZXR1cm4gd2UudGVzdCh0LnR5cGUpJiZ0LmNsaWNrJiZmZSh0LFwiaW5wdXRcIikmJkhlKHQsXCJjbGlja1wiLCEwKSwhMX0sdHJpZ2dlcjpmdW5jdGlvbihlKXt2YXIgdD10aGlzfHxlO3JldHVybiB3ZS50ZXN0KHQudHlwZSkmJnQuY2xpY2smJmZlKHQsXCJpbnB1dFwiKSYmSGUodCxcImNsaWNrXCIpLCEwfSxfZGVmYXVsdDpmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldDtyZXR1cm4gd2UudGVzdCh0LnR5cGUpJiZ0LmNsaWNrJiZmZSh0LFwiaW5wdXRcIikmJl8uZ2V0KHQsXCJjbGlja1wiKXx8ZmUodCxcImFcIil9fSxiZWZvcmV1bmxvYWQ6e3Bvc3REaXNwYXRjaDpmdW5jdGlvbihlKXt2b2lkIDAhPT1lLnJlc3VsdCYmZS5vcmlnaW5hbEV2ZW50JiYoZS5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlPWUucmVzdWx0KX19fX0sY2UucmVtb3ZlRXZlbnQ9ZnVuY3Rpb24oZSx0LG4pe2UucmVtb3ZlRXZlbnRMaXN0ZW5lciYmZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsbil9LGNlLkV2ZW50PWZ1bmN0aW9uKGUsdCl7aWYoISh0aGlzIGluc3RhbmNlb2YgY2UuRXZlbnQpKXJldHVybiBuZXcgY2UuRXZlbnQoZSx0KTtlJiZlLnR5cGU/KHRoaXMub3JpZ2luYWxFdmVudD1lLHRoaXMudHlwZT1lLnR5cGUsdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9ZS5kZWZhdWx0UHJldmVudGVkfHx2b2lkIDA9PT1lLmRlZmF1bHRQcmV2ZW50ZWQmJiExPT09ZS5yZXR1cm5WYWx1ZT9OZTpxZSx0aGlzLnRhcmdldD1lLnRhcmdldCYmMz09PWUudGFyZ2V0Lm5vZGVUeXBlP2UudGFyZ2V0LnBhcmVudE5vZGU6ZS50YXJnZXQsdGhpcy5jdXJyZW50VGFyZ2V0PWUuY3VycmVudFRhcmdldCx0aGlzLnJlbGF0ZWRUYXJnZXQ9ZS5yZWxhdGVkVGFyZ2V0KTp0aGlzLnR5cGU9ZSx0JiZjZS5leHRlbmQodGhpcyx0KSx0aGlzLnRpbWVTdGFtcD1lJiZlLnRpbWVTdGFtcHx8RGF0ZS5ub3coKSx0aGlzW2NlLmV4cGFuZG9dPSEwfSxjZS5FdmVudC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmNlLkV2ZW50LGlzRGVmYXVsdFByZXZlbnRlZDpxZSxpc1Byb3BhZ2F0aW9uU3RvcHBlZDpxZSxpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDpxZSxpc1NpbXVsYXRlZDohMSxwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3ZhciBlPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1OZSxlJiYhdGhpcy5pc1NpbXVsYXRlZCYmZS5wcmV2ZW50RGVmYXVsdCgpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1OZSxlJiYhdGhpcy5pc1NpbXVsYXRlZCYmZS5zdG9wUHJvcGFnYXRpb24oKX0sc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9TmUsZSYmIXRoaXMuaXNTaW11bGF0ZWQmJmUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdGhpcy5zdG9wUHJvcGFnYXRpb24oKX19LGNlLmVhY2goe2FsdEtleTohMCxidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsY2hhbmdlZFRvdWNoZXM6ITAsY3RybEtleTohMCxkZXRhaWw6ITAsZXZlbnRQaGFzZTohMCxtZXRhS2V5OiEwLHBhZ2VYOiEwLHBhZ2VZOiEwLHNoaWZ0S2V5OiEwLHZpZXc6ITAsXCJjaGFyXCI6ITAsY29kZTohMCxjaGFyQ29kZTohMCxrZXk6ITAsa2V5Q29kZTohMCxidXR0b246ITAsYnV0dG9uczohMCxjbGllbnRYOiEwLGNsaWVudFk6ITAsb2Zmc2V0WDohMCxvZmZzZXRZOiEwLHBvaW50ZXJJZDohMCxwb2ludGVyVHlwZTohMCxzY3JlZW5YOiEwLHNjcmVlblk6ITAsdGFyZ2V0VG91Y2hlczohMCx0b0VsZW1lbnQ6ITAsdG91Y2hlczohMCx3aGljaDohMH0sY2UuZXZlbnQuYWRkUHJvcCksY2UuZWFjaCh7Zm9jdXM6XCJmb2N1c2luXCIsYmx1cjpcImZvY3Vzb3V0XCJ9LGZ1bmN0aW9uKHIsaSl7ZnVuY3Rpb24gbyhlKXtpZihDLmRvY3VtZW50TW9kZSl7dmFyIHQ9Xy5nZXQodGhpcyxcImhhbmRsZVwiKSxuPWNlLmV2ZW50LmZpeChlKTtuLnR5cGU9XCJmb2N1c2luXCI9PT1lLnR5cGU/XCJmb2N1c1wiOlwiYmx1clwiLG4uaXNTaW11bGF0ZWQ9ITAsdChlKSxuLnRhcmdldD09PW4uY3VycmVudFRhcmdldCYmdChuKX1lbHNlIGNlLmV2ZW50LnNpbXVsYXRlKGksZS50YXJnZXQsY2UuZXZlbnQuZml4KGUpKX1jZS5ldmVudC5zcGVjaWFsW3JdPXtzZXR1cDpmdW5jdGlvbigpe3ZhciBlO2lmKEhlKHRoaXMsciwhMCksIUMuZG9jdW1lbnRNb2RlKXJldHVybiExOyhlPV8uZ2V0KHRoaXMsaSkpfHx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaSxvKSxfLnNldCh0aGlzLGksKGV8fDApKzEpfSx0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuIEhlKHRoaXMsciksITB9LHRlYXJkb3duOmZ1bmN0aW9uKCl7dmFyIGU7aWYoIUMuZG9jdW1lbnRNb2RlKXJldHVybiExOyhlPV8uZ2V0KHRoaXMsaSktMSk/Xy5zZXQodGhpcyxpLGUpOih0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoaSxvKSxfLnJlbW92ZSh0aGlzLGkpKX0sX2RlZmF1bHQ6ZnVuY3Rpb24oZSl7cmV0dXJuIF8uZ2V0KGUudGFyZ2V0LHIpfSxkZWxlZ2F0ZVR5cGU6aX0sY2UuZXZlbnQuc3BlY2lhbFtpXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMuZG9jdW1lbnR8fHRoaXMsdD1DLmRvY3VtZW50TW9kZT90aGlzOmUsbj1fLmdldCh0LGkpO258fChDLmRvY3VtZW50TW9kZT90aGlzLmFkZEV2ZW50TGlzdGVuZXIoaSxvKTplLmFkZEV2ZW50TGlzdGVuZXIocixvLCEwKSksXy5zZXQodCxpLChufHwwKSsxKX0sdGVhcmRvd246ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMuZG9jdW1lbnR8fHRoaXMsdD1DLmRvY3VtZW50TW9kZT90aGlzOmUsbj1fLmdldCh0LGkpLTE7bj9fLnNldCh0LGksbik6KEMuZG9jdW1lbnRNb2RlP3RoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLG8pOmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihyLG8sITApLF8ucmVtb3ZlKHQsaSkpfX19KSxjZS5lYWNoKHttb3VzZWVudGVyOlwibW91c2VvdmVyXCIsbW91c2VsZWF2ZTpcIm1vdXNlb3V0XCIscG9pbnRlcmVudGVyOlwicG9pbnRlcm92ZXJcIixwb2ludGVybGVhdmU6XCJwb2ludGVyb3V0XCJ9LGZ1bmN0aW9uKGUsaSl7Y2UuZXZlbnQuc3BlY2lhbFtlXT17ZGVsZWdhdGVUeXBlOmksYmluZFR5cGU6aSxoYW5kbGU6ZnVuY3Rpb24oZSl7dmFyIHQsbj1lLnJlbGF0ZWRUYXJnZXQscj1lLmhhbmRsZU9iajtyZXR1cm4gbiYmKG49PT10aGlzfHxjZS5jb250YWlucyh0aGlzLG4pKXx8KGUudHlwZT1yLm9yaWdUeXBlLHQ9ci5oYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxlLnR5cGU9aSksdH19fSksY2UuZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gTGUodGhpcyxlLHQsbixyKX0sb25lOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBMZSh0aGlzLGUsdCxuLHIsMSl9LG9mZjpmdW5jdGlvbihlLHQsbil7dmFyIHIsaTtpZihlJiZlLnByZXZlbnREZWZhdWx0JiZlLmhhbmRsZU9iailyZXR1cm4gcj1lLmhhbmRsZU9iaixjZShlLmRlbGVnYXRlVGFyZ2V0KS5vZmYoci5uYW1lc3BhY2U/ci5vcmlnVHlwZStcIi5cIityLm5hbWVzcGFjZTpyLm9yaWdUeXBlLHIuc2VsZWN0b3Isci5oYW5kbGVyKSx0aGlzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBlKXtmb3IoaSBpbiBlKXRoaXMub2ZmKGksdCxlW2ldKTtyZXR1cm4gdGhpc31yZXR1cm4hMSE9PXQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHR8fChuPXQsdD12b2lkIDApLCExPT09biYmKG49cWUpLHRoaXMuZWFjaChmdW5jdGlvbigpe2NlLmV2ZW50LnJlbW92ZSh0aGlzLGUsbix0KX0pfX0pO3ZhciBPZT0vPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxQZT0vY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLE1lPS9eXFxzKjwhXFxbQ0RBVEFcXFt8XFxdXFxdPlxccyokL2c7ZnVuY3Rpb24gUmUoZSx0KXtyZXR1cm4gZmUoZSxcInRhYmxlXCIpJiZmZSgxMSE9PXQubm9kZVR5cGU/dDp0LmZpcnN0Q2hpbGQsXCJ0clwiKSYmY2UoZSkuY2hpbGRyZW4oXCJ0Ym9keVwiKVswXXx8ZX1mdW5jdGlvbiBJZShlKXtyZXR1cm4gZS50eXBlPShudWxsIT09ZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKStcIi9cIitlLnR5cGUsZX1mdW5jdGlvbiBXZShlKXtyZXR1cm5cInRydWUvXCI9PT0oZS50eXBlfHxcIlwiKS5zbGljZSgwLDUpP2UudHlwZT1lLnR5cGUuc2xpY2UoNSk6ZS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpLGV9ZnVuY3Rpb24gRmUoZSx0KXt2YXIgbixyLGksbyxhLHM7aWYoMT09PXQubm9kZVR5cGUpe2lmKF8uaGFzRGF0YShlKSYmKHM9Xy5nZXQoZSkuZXZlbnRzKSlmb3IoaSBpbiBfLnJlbW92ZSh0LFwiaGFuZGxlIGV2ZW50c1wiKSxzKWZvcihuPTAscj1zW2ldLmxlbmd0aDtuPHI7bisrKWNlLmV2ZW50LmFkZCh0LGksc1tpXVtuXSk7ei5oYXNEYXRhKGUpJiYobz16LmFjY2VzcyhlKSxhPWNlLmV4dGVuZCh7fSxvKSx6LnNldCh0LGEpKX19ZnVuY3Rpb24gJGUobixyLGksbyl7cj1nKHIpO3ZhciBlLHQsYSxzLHUsbCxjPTAsZj1uLmxlbmd0aCxwPWYtMSxkPXJbMF0saD12KGQpO2lmKGh8fDE8ZiYmXCJzdHJpbmdcIj09dHlwZW9mIGQmJiFsZS5jaGVja0Nsb25lJiZQZS50ZXN0KGQpKXJldHVybiBuLmVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9bi5lcShlKTtoJiYoclswXT1kLmNhbGwodGhpcyxlLHQuaHRtbCgpKSksJGUodCxyLGksbyl9KTtpZihmJiYodD0oZT1BZShyLG5bMF0ub3duZXJEb2N1bWVudCwhMSxuLG8pKS5maXJzdENoaWxkLDE9PT1lLmNoaWxkTm9kZXMubGVuZ3RoJiYoZT10KSx0fHxvKSl7Zm9yKHM9KGE9Y2UubWFwKFNlKGUsXCJzY3JpcHRcIiksSWUpKS5sZW5ndGg7YzxmO2MrKyl1PWUsYyE9PXAmJih1PWNlLmNsb25lKHUsITAsITApLHMmJmNlLm1lcmdlKGEsU2UodSxcInNjcmlwdFwiKSkpLGkuY2FsbChuW2NdLHUsYyk7aWYocylmb3IobD1hW2EubGVuZ3RoLTFdLm93bmVyRG9jdW1lbnQsY2UubWFwKGEsV2UpLGM9MDtjPHM7YysrKXU9YVtjXSxDZS50ZXN0KHUudHlwZXx8XCJcIikmJiFfLmFjY2Vzcyh1LFwiZ2xvYmFsRXZhbFwiKSYmY2UuY29udGFpbnMobCx1KSYmKHUuc3JjJiZcIm1vZHVsZVwiIT09KHUudHlwZXx8XCJcIikudG9Mb3dlckNhc2UoKT9jZS5fZXZhbFVybCYmIXUubm9Nb2R1bGUmJmNlLl9ldmFsVXJsKHUuc3JjLHtub25jZTp1Lm5vbmNlfHx1LmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpfSxsKTptKHUudGV4dENvbnRlbnQucmVwbGFjZShNZSxcIlwiKSx1LGwpKX1yZXR1cm4gbn1mdW5jdGlvbiBCZShlLHQsbil7Zm9yKHZhciByLGk9dD9jZS5maWx0ZXIodCxlKTplLG89MDtudWxsIT0ocj1pW29dKTtvKyspbnx8MSE9PXIubm9kZVR5cGV8fGNlLmNsZWFuRGF0YShTZShyKSksci5wYXJlbnROb2RlJiYobiYmSyhyKSYmRWUoU2UocixcInNjcmlwdFwiKSksci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHIpKTtyZXR1cm4gZX1jZS5leHRlbmQoe2h0bWxQcmVmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LGNsb25lOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzLHUsbCxjPWUuY2xvbmVOb2RlKCEwKSxmPUsoZSk7aWYoIShsZS5ub0Nsb25lQ2hlY2tlZHx8MSE9PWUubm9kZVR5cGUmJjExIT09ZS5ub2RlVHlwZXx8Y2UuaXNYTUxEb2MoZSkpKWZvcihhPVNlKGMpLHI9MCxpPShvPVNlKGUpKS5sZW5ndGg7cjxpO3IrKylzPW9bcl0sdT1hW3JdLHZvaWQgMCxcImlucHV0XCI9PT0obD11Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpJiZ3ZS50ZXN0KHMudHlwZSk/dS5jaGVja2VkPXMuY2hlY2tlZDpcImlucHV0XCIhPT1sJiZcInRleHRhcmVhXCIhPT1sfHwodS5kZWZhdWx0VmFsdWU9cy5kZWZhdWx0VmFsdWUpO2lmKHQpaWYobilmb3Iobz1vfHxTZShlKSxhPWF8fFNlKGMpLHI9MCxpPW8ubGVuZ3RoO3I8aTtyKyspRmUob1tyXSxhW3JdKTtlbHNlIEZlKGUsYyk7cmV0dXJuIDA8KGE9U2UoYyxcInNjcmlwdFwiKSkubGVuZ3RoJiZFZShhLCFmJiZTZShlLFwic2NyaXB0XCIpKSxjfSxjbGVhbkRhdGE6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LG4scixpPWNlLmV2ZW50LnNwZWNpYWwsbz0wO3ZvaWQgMCE9PShuPWVbb10pO28rKylpZigkKG4pKXtpZih0PW5bXy5leHBhbmRvXSl7aWYodC5ldmVudHMpZm9yKHIgaW4gdC5ldmVudHMpaVtyXT9jZS5ldmVudC5yZW1vdmUobixyKTpjZS5yZW1vdmVFdmVudChuLHIsdC5oYW5kbGUpO25bXy5leHBhbmRvXT12b2lkIDB9blt6LmV4cGFuZG9dJiYoblt6LmV4cGFuZG9dPXZvaWQgMCl9fX0pLGNlLmZuLmV4dGVuZCh7ZGV0YWNoOmZ1bmN0aW9uKGUpe3JldHVybiBCZSh0aGlzLGUsITApfSxyZW1vdmU6ZnVuY3Rpb24oZSl7cmV0dXJuIEJlKHRoaXMsZSl9LHRleHQ6ZnVuY3Rpb24oZSl7cmV0dXJuIE0odGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZT9jZS50ZXh0KHRoaXMpOnRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCl7MSE9PXRoaXMubm9kZVR5cGUmJjExIT09dGhpcy5ub2RlVHlwZSYmOSE9PXRoaXMubm9kZVR5cGV8fCh0aGlzLnRleHRDb250ZW50PWUpfSl9LG51bGwsZSxhcmd1bWVudHMubGVuZ3RoKX0sYXBwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuICRlKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpezEhPT10aGlzLm5vZGVUeXBlJiYxMSE9PXRoaXMubm9kZVR5cGUmJjkhPT10aGlzLm5vZGVUeXBlfHxSZSh0aGlzLGUpLmFwcGVuZENoaWxkKGUpfSl9LHByZXBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gJGUodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oZSl7aWYoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpe3ZhciB0PVJlKHRoaXMsZSk7dC5pbnNlcnRCZWZvcmUoZSx0LmZpcnN0Q2hpbGQpfX0pfSxiZWZvcmU6ZnVuY3Rpb24oKXtyZXR1cm4gJGUodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oZSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsdGhpcyl9KX0sYWZ0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gJGUodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oZSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsdGhpcy5uZXh0U2libGluZyl9KX0sZW1wdHk6ZnVuY3Rpb24oKXtmb3IodmFyIGUsdD0wO251bGwhPShlPXRoaXNbdF0pO3QrKykxPT09ZS5ub2RlVHlwZSYmKGNlLmNsZWFuRGF0YShTZShlLCExKSksZS50ZXh0Q29udGVudD1cIlwiKTtyZXR1cm4gdGhpc30sY2xvbmU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1udWxsIT1lJiZlLHQ9bnVsbD09dD9lOnQsdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gY2UuY2xvbmUodGhpcyxlLHQpfSl9LGh0bWw6ZnVuY3Rpb24oZSl7cmV0dXJuIE0odGhpcyxmdW5jdGlvbihlKXt2YXIgdD10aGlzWzBdfHx7fSxuPTAscj10aGlzLmxlbmd0aDtpZih2b2lkIDA9PT1lJiYxPT09dC5ub2RlVHlwZSlyZXR1cm4gdC5pbm5lckhUTUw7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJiFPZS50ZXN0KGUpJiYha2VbKFRlLmV4ZWMoZSl8fFtcIlwiLFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSl7ZT1jZS5odG1sUHJlZmlsdGVyKGUpO3RyeXtmb3IoO248cjtuKyspMT09PSh0PXRoaXNbbl18fHt9KS5ub2RlVHlwZSYmKGNlLmNsZWFuRGF0YShTZSh0LCExKSksdC5pbm5lckhUTUw9ZSk7dD0wfWNhdGNoKGUpe319dCYmdGhpcy5lbXB0eSgpLmFwcGVuZChlKX0sbnVsbCxlLGFyZ3VtZW50cy5sZW5ndGgpfSxyZXBsYWNlV2l0aDpmdW5jdGlvbigpe3ZhciBuPVtdO3JldHVybiAkZSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihlKXt2YXIgdD10aGlzLnBhcmVudE5vZGU7Y2UuaW5BcnJheSh0aGlzLG4pPDAmJihjZS5jbGVhbkRhdGEoU2UodGhpcykpLHQmJnQucmVwbGFjZUNoaWxkKGUsdGhpcykpfSxuKX19KSxjZS5lYWNoKHthcHBlbmRUbzpcImFwcGVuZFwiLHByZXBlbmRUbzpcInByZXBlbmRcIixpbnNlcnRCZWZvcmU6XCJiZWZvcmVcIixpbnNlcnRBZnRlcjpcImFmdGVyXCIscmVwbGFjZUFsbDpcInJlcGxhY2VXaXRoXCJ9LGZ1bmN0aW9uKGUsYSl7Y2UuZm5bZV09ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LG49W10scj1jZShlKSxpPXIubGVuZ3RoLTEsbz0wO288PWk7bysrKXQ9bz09PWk/dGhpczp0aGlzLmNsb25lKCEwKSxjZShyW29dKVthXSh0KSxzLmFwcGx5KG4sdC5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKG4pfX0pO3ZhciBfZT1uZXcgUmVnRXhwKFwiXihcIitHK1wiKSg/IXB4KVthLXolXSskXCIsXCJpXCIpLHplPS9eLS0vLFhlPWZ1bmN0aW9uKGUpe3ZhciB0PWUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztyZXR1cm4gdCYmdC5vcGVuZXJ8fCh0PWllKSx0LmdldENvbXB1dGVkU3R5bGUoZSl9LFVlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89e307Zm9yKGkgaW4gdClvW2ldPWUuc3R5bGVbaV0sZS5zdHlsZVtpXT10W2ldO2ZvcihpIGluIHI9bi5jYWxsKGUpLHQpZS5zdHlsZVtpXT1vW2ldO3JldHVybiByfSxWZT1uZXcgUmVnRXhwKFEuam9pbihcInxcIiksXCJpXCIpO2Z1bmN0aW9uIEdlKGUsdCxuKXt2YXIgcixpLG8sYSxzPXplLnRlc3QodCksdT1lLnN0eWxlO3JldHVybihuPW58fFhlKGUpKSYmKGE9bi5nZXRQcm9wZXJ0eVZhbHVlKHQpfHxuW3RdLHMmJmEmJihhPWEucmVwbGFjZSh2ZSxcIiQxXCIpfHx2b2lkIDApLFwiXCIhPT1hfHxLKGUpfHwoYT1jZS5zdHlsZShlLHQpKSwhbGUucGl4ZWxCb3hTdHlsZXMoKSYmX2UudGVzdChhKSYmVmUudGVzdCh0KSYmKHI9dS53aWR0aCxpPXUubWluV2lkdGgsbz11Lm1heFdpZHRoLHUubWluV2lkdGg9dS5tYXhXaWR0aD11LndpZHRoPWEsYT1uLndpZHRoLHUud2lkdGg9cix1Lm1pbldpZHRoPWksdS5tYXhXaWR0aD1vKSksdm9pZCAwIT09YT9hK1wiXCI6YX1mdW5jdGlvbiBZZShlLHQpe3JldHVybntnZXQ6ZnVuY3Rpb24oKXtpZighZSgpKXJldHVybih0aGlzLmdldD10KS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZGVsZXRlIHRoaXMuZ2V0fX19IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe2lmKGwpe3Uuc3R5bGUuY3NzVGV4dD1cInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDttYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIixsLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7bWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo2MCU7dG9wOjElXCIsSi5hcHBlbmRDaGlsZCh1KS5hcHBlbmRDaGlsZChsKTt2YXIgZT1pZS5nZXRDb21wdXRlZFN0eWxlKGwpO249XCIxJVwiIT09ZS50b3Ascz0xMj09PXQoZS5tYXJnaW5MZWZ0KSxsLnN0eWxlLnJpZ2h0PVwiNjAlXCIsbz0zNj09PXQoZS5yaWdodCkscj0zNj09PXQoZS53aWR0aCksbC5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsaT0xMj09PXQobC5vZmZzZXRXaWR0aC8zKSxKLnJlbW92ZUNoaWxkKHUpLGw9bnVsbH19ZnVuY3Rpb24gdChlKXtyZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KGUpKX12YXIgbixyLGksbyxhLHMsdT1DLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksbD1DLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7bC5zdHlsZSYmKGwuc3R5bGUuYmFja2dyb3VuZENsaXA9XCJjb250ZW50LWJveFwiLGwuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cIlwiLGxlLmNsZWFyQ2xvbmVTdHlsZT1cImNvbnRlbnQtYm94XCI9PT1sLnN0eWxlLmJhY2tncm91bmRDbGlwLGNlLmV4dGVuZChsZSx7Ym94U2l6aW5nUmVsaWFibGU6ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLHJ9LHBpeGVsQm94U3R5bGVzOmZ1bmN0aW9uKCl7cmV0dXJuIGUoKSxvfSxwaXhlbFBvc2l0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGUoKSxufSxyZWxpYWJsZU1hcmdpbkxlZnQ6ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLHN9LHNjcm9sbGJveFNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLGl9LHJlbGlhYmxlVHJEaW1lbnNpb25zOmZ1bmN0aW9uKCl7dmFyIGUsdCxuLHI7cmV0dXJuIG51bGw9PWEmJihlPUMuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpLHQ9Qy5jcmVhdGVFbGVtZW50KFwidHJcIiksbj1DLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZS5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGVcIix0LnN0eWxlLmNzc1RleHQ9XCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JvcmRlcjoxcHggc29saWRcIix0LnN0eWxlLmhlaWdodD1cIjFweFwiLG4uc3R5bGUuaGVpZ2h0PVwiOXB4XCIsbi5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixKLmFwcGVuZENoaWxkKGUpLmFwcGVuZENoaWxkKHQpLmFwcGVuZENoaWxkKG4pLHI9aWUuZ2V0Q29tcHV0ZWRTdHlsZSh0KSxhPXBhcnNlSW50KHIuaGVpZ2h0LDEwKStwYXJzZUludChyLmJvcmRlclRvcFdpZHRoLDEwKStwYXJzZUludChyLmJvcmRlckJvdHRvbVdpZHRoLDEwKT09PXQub2Zmc2V0SGVpZ2h0LEoucmVtb3ZlQ2hpbGQoZSkpLGF9fSkpfSgpO3ZhciBRZT1bXCJXZWJraXRcIixcIk1velwiLFwibXNcIl0sSmU9Qy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLEtlPXt9O2Z1bmN0aW9uIFplKGUpe3ZhciB0PWNlLmNzc1Byb3BzW2VdfHxLZVtlXTtyZXR1cm4gdHx8KGUgaW4gSmU/ZTpLZVtlXT1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxuPVFlLmxlbmd0aDt3aGlsZShuLS0paWYoKGU9UWVbbl0rdClpbiBKZSlyZXR1cm4gZX0oZSl8fGUpfXZhciBldD0vXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sdHQ9e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix2aXNpYmlsaXR5OlwiaGlkZGVuXCIsZGlzcGxheTpcImJsb2NrXCJ9LG50PXtsZXR0ZXJTcGFjaW5nOlwiMFwiLGZvbnRXZWlnaHQ6XCI0MDBcIn07ZnVuY3Rpb24gcnQoZSx0LG4pe3ZhciByPVkuZXhlYyh0KTtyZXR1cm4gcj9NYXRoLm1heCgwLHJbMl0tKG58fDApKSsoclszXXx8XCJweFwiKTp0fWZ1bmN0aW9uIGl0KGUsdCxuLHIsaSxvKXt2YXIgYT1cIndpZHRoXCI9PT10PzE6MCxzPTAsdT0wLGw9MDtpZihuPT09KHI/XCJib3JkZXJcIjpcImNvbnRlbnRcIikpcmV0dXJuIDA7Zm9yKDthPDQ7YSs9MilcIm1hcmdpblwiPT09biYmKGwrPWNlLmNzcyhlLG4rUVthXSwhMCxpKSkscj8oXCJjb250ZW50XCI9PT1uJiYodS09Y2UuY3NzKGUsXCJwYWRkaW5nXCIrUVthXSwhMCxpKSksXCJtYXJnaW5cIiE9PW4mJih1LT1jZS5jc3MoZSxcImJvcmRlclwiK1FbYV0rXCJXaWR0aFwiLCEwLGkpKSk6KHUrPWNlLmNzcyhlLFwicGFkZGluZ1wiK1FbYV0sITAsaSksXCJwYWRkaW5nXCIhPT1uP3UrPWNlLmNzcyhlLFwiYm9yZGVyXCIrUVthXStcIldpZHRoXCIsITAsaSk6cys9Y2UuY3NzKGUsXCJib3JkZXJcIitRW2FdK1wiV2lkdGhcIiwhMCxpKSk7cmV0dXJuIXImJjA8PW8mJih1Kz1NYXRoLm1heCgwLE1hdGguY2VpbChlW1wib2Zmc2V0XCIrdFswXS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSldLW8tdS1zLS41KSl8fDApLHUrbH1mdW5jdGlvbiBvdChlLHQsbil7dmFyIHI9WGUoZSksaT0oIWxlLmJveFNpemluZ1JlbGlhYmxlKCl8fG4pJiZcImJvcmRlci1ib3hcIj09PWNlLmNzcyhlLFwiYm94U2l6aW5nXCIsITEsciksbz1pLGE9R2UoZSx0LHIpLHM9XCJvZmZzZXRcIit0WzBdLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKTtpZihfZS50ZXN0KGEpKXtpZighbilyZXR1cm4gYTthPVwiYXV0b1wifXJldHVybighbGUuYm94U2l6aW5nUmVsaWFibGUoKSYmaXx8IWxlLnJlbGlhYmxlVHJEaW1lbnNpb25zKCkmJmZlKGUsXCJ0clwiKXx8XCJhdXRvXCI9PT1hfHwhcGFyc2VGbG9hdChhKSYmXCJpbmxpbmVcIj09PWNlLmNzcyhlLFwiZGlzcGxheVwiLCExLHIpKSYmZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCYmKGk9XCJib3JkZXItYm94XCI9PT1jZS5jc3MoZSxcImJveFNpemluZ1wiLCExLHIpLChvPXMgaW4gZSkmJihhPWVbc10pKSwoYT1wYXJzZUZsb2F0KGEpfHwwKStpdChlLHQsbnx8KGk/XCJib3JkZXJcIjpcImNvbnRlbnRcIiksbyxyLGEpK1wicHhcIn1mdW5jdGlvbiBhdChlLHQsbixyLGkpe3JldHVybiBuZXcgYXQucHJvdG90eXBlLmluaXQoZSx0LG4scixpKX1jZS5leHRlbmQoe2Nzc0hvb2tzOntvcGFjaXR5OntnZXQ6ZnVuY3Rpb24oZSx0KXtpZih0KXt2YXIgbj1HZShlLFwib3BhY2l0eVwiKTtyZXR1cm5cIlwiPT09bj9cIjFcIjpufX19fSxjc3NOdW1iZXI6e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGFzcGVjdFJhdGlvOiEwLGJvcmRlckltYWdlU2xpY2U6ITAsY29sdW1uQ291bnQ6ITAsZmxleEdyb3c6ITAsZmxleFNocmluazohMCxmb250V2VpZ2h0OiEwLGdyaWRBcmVhOiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTdGFydDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JkZXI6ITAsb3JwaGFuczohMCxzY2FsZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITAsZmlsbE9wYWNpdHk6ITAsZmxvb2RPcGFjaXR5OiEwLHN0b3BPcGFjaXR5OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMH0sY3NzUHJvcHM6e30sc3R5bGU6ZnVuY3Rpb24oZSx0LG4scil7aWYoZSYmMyE9PWUubm9kZVR5cGUmJjghPT1lLm5vZGVUeXBlJiZlLnN0eWxlKXt2YXIgaSxvLGEscz1GKHQpLHU9emUudGVzdCh0KSxsPWUuc3R5bGU7aWYodXx8KHQ9WmUocykpLGE9Y2UuY3NzSG9va3NbdF18fGNlLmNzc0hvb2tzW3NdLHZvaWQgMD09PW4pcmV0dXJuIGEmJlwiZ2V0XCJpbiBhJiZ2b2lkIDAhPT0oaT1hLmdldChlLCExLHIpKT9pOmxbdF07XCJzdHJpbmdcIj09PShvPXR5cGVvZiBuKSYmKGk9WS5leGVjKG4pKSYmaVsxXSYmKG49dGUoZSx0LGkpLG89XCJudW1iZXJcIiksbnVsbCE9biYmbj09biYmKFwibnVtYmVyXCIhPT1vfHx1fHwobis9aSYmaVszXXx8KGNlLmNzc051bWJlcltzXT9cIlwiOlwicHhcIikpLGxlLmNsZWFyQ2xvbmVTdHlsZXx8XCJcIiE9PW58fDAhPT10LmluZGV4T2YoXCJiYWNrZ3JvdW5kXCIpfHwobFt0XT1cImluaGVyaXRcIiksYSYmXCJzZXRcImluIGEmJnZvaWQgMD09PShuPWEuc2V0KGUsbixyKSl8fCh1P2wuc2V0UHJvcGVydHkodCxuKTpsW3RdPW4pKX19LGNzczpmdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvLGEscz1GKHQpO3JldHVybiB6ZS50ZXN0KHQpfHwodD1aZShzKSksKGE9Y2UuY3NzSG9va3NbdF18fGNlLmNzc0hvb2tzW3NdKSYmXCJnZXRcImluIGEmJihpPWEuZ2V0KGUsITAsbikpLHZvaWQgMD09PWkmJihpPUdlKGUsdCxyKSksXCJub3JtYWxcIj09PWkmJnQgaW4gbnQmJihpPW50W3RdKSxcIlwiPT09bnx8bj8obz1wYXJzZUZsb2F0KGkpLCEwPT09bnx8aXNGaW5pdGUobyk/b3x8MDppKTppfX0pLGNlLmVhY2goW1wiaGVpZ2h0XCIsXCJ3aWR0aFwiXSxmdW5jdGlvbihlLHUpe2NlLmNzc0hvb2tzW3VdPXtnZXQ6ZnVuY3Rpb24oZSx0LG4pe2lmKHQpcmV0dXJuIWV0LnRlc3QoY2UuY3NzKGUsXCJkaXNwbGF5XCIpKXx8ZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCYmZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aD9vdChlLHUsbik6VWUoZSx0dCxmdW5jdGlvbigpe3JldHVybiBvdChlLHUsbil9KX0sc2V0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpPVhlKGUpLG89IWxlLnNjcm9sbGJveFNpemUoKSYmXCJhYnNvbHV0ZVwiPT09aS5wb3NpdGlvbixhPShvfHxuKSYmXCJib3JkZXItYm94XCI9PT1jZS5jc3MoZSxcImJveFNpemluZ1wiLCExLGkpLHM9bj9pdChlLHUsbixhLGkpOjA7cmV0dXJuIGEmJm8mJihzLT1NYXRoLmNlaWwoZVtcIm9mZnNldFwiK3VbMF0udG9VcHBlckNhc2UoKSt1LnNsaWNlKDEpXS1wYXJzZUZsb2F0KGlbdV0pLWl0KGUsdSxcImJvcmRlclwiLCExLGkpLS41KSkscyYmKHI9WS5leGVjKHQpKSYmXCJweFwiIT09KHJbM118fFwicHhcIikmJihlLnN0eWxlW3VdPXQsdD1jZS5jc3MoZSx1KSkscnQoMCx0LHMpfX19KSxjZS5jc3NIb29rcy5tYXJnaW5MZWZ0PVllKGxlLnJlbGlhYmxlTWFyZ2luTGVmdCxmdW5jdGlvbihlLHQpe2lmKHQpcmV0dXJuKHBhcnNlRmxvYXQoR2UoZSxcIm1hcmdpbkxlZnRcIikpfHxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQtVWUoZSx7bWFyZ2luTGVmdDowfSxmdW5jdGlvbigpe3JldHVybiBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnR9KSkrXCJweFwifSksY2UuZWFjaCh7bWFyZ2luOlwiXCIscGFkZGluZzpcIlwiLGJvcmRlcjpcIldpZHRoXCJ9LGZ1bmN0aW9uKGksbyl7Y2UuY3NzSG9va3NbaStvXT17ZXhwYW5kOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49e30scj1cInN0cmluZ1wiPT10eXBlb2YgZT9lLnNwbGl0KFwiIFwiKTpbZV07dDw0O3QrKyluW2krUVt0XStvXT1yW3RdfHxyW3QtMl18fHJbMF07cmV0dXJuIG59fSxcIm1hcmdpblwiIT09aSYmKGNlLmNzc0hvb2tzW2krb10uc2V0PXJ0KX0pLGNlLmZuLmV4dGVuZCh7Y3NzOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIE0odGhpcyxmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPXt9LGE9MDtpZihBcnJheS5pc0FycmF5KHQpKXtmb3Iocj1YZShlKSxpPXQubGVuZ3RoO2E8aTthKyspb1t0W2FdXT1jZS5jc3MoZSx0W2FdLCExLHIpO3JldHVybiBvfXJldHVybiB2b2lkIDAhPT1uP2NlLnN0eWxlKGUsdCxuKTpjZS5jc3MoZSx0KX0sZSx0LDE8YXJndW1lbnRzLmxlbmd0aCl9fSksKChjZS5Ud2Vlbj1hdCkucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjphdCxpbml0OmZ1bmN0aW9uKGUsdCxuLHIsaSxvKXt0aGlzLmVsZW09ZSx0aGlzLnByb3A9bix0aGlzLmVhc2luZz1pfHxjZS5lYXNpbmcuX2RlZmF1bHQsdGhpcy5vcHRpb25zPXQsdGhpcy5zdGFydD10aGlzLm5vdz10aGlzLmN1cigpLHRoaXMuZW5kPXIsdGhpcy51bml0PW98fChjZS5jc3NOdW1iZXJbbl0/XCJcIjpcInB4XCIpfSxjdXI6ZnVuY3Rpb24oKXt2YXIgZT1hdC5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gZSYmZS5nZXQ/ZS5nZXQodGhpcyk6YXQucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKX0scnVuOmZ1bmN0aW9uKGUpe3ZhciB0LG49YXQucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbj90aGlzLnBvcz10PWNlLmVhc2luZ1t0aGlzLmVhc2luZ10oZSx0aGlzLm9wdGlvbnMuZHVyYXRpb24qZSwwLDEsdGhpcy5vcHRpb25zLmR1cmF0aW9uKTp0aGlzLnBvcz10PWUsdGhpcy5ub3c9KHRoaXMuZW5kLXRoaXMuc3RhcnQpKnQrdGhpcy5zdGFydCx0aGlzLm9wdGlvbnMuc3RlcCYmdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sdGhpcy5ub3csdGhpcyksbiYmbi5zZXQ/bi5zZXQodGhpcyk6YXQucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSx0aGlzfX0pLmluaXQucHJvdG90eXBlPWF0LnByb3RvdHlwZSwoYXQucHJvcEhvb2tzPXtfZGVmYXVsdDp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiAxIT09ZS5lbGVtLm5vZGVUeXBlfHxudWxsIT1lLmVsZW1bZS5wcm9wXSYmbnVsbD09ZS5lbGVtLnN0eWxlW2UucHJvcF0/ZS5lbGVtW2UucHJvcF06KHQ9Y2UuY3NzKGUuZWxlbSxlLnByb3AsXCJcIikpJiZcImF1dG9cIiE9PXQ/dDowfSxzZXQ6ZnVuY3Rpb24oZSl7Y2UuZnguc3RlcFtlLnByb3BdP2NlLmZ4LnN0ZXBbZS5wcm9wXShlKToxIT09ZS5lbGVtLm5vZGVUeXBlfHwhY2UuY3NzSG9va3NbZS5wcm9wXSYmbnVsbD09ZS5lbGVtLnN0eWxlW1plKGUucHJvcCldP2UuZWxlbVtlLnByb3BdPWUubm93OmNlLnN0eWxlKGUuZWxlbSxlLnByb3AsZS5ub3crZS51bml0KX19fSkuc2Nyb2xsVG9wPWF0LnByb3BIb29rcy5zY3JvbGxMZWZ0PXtzZXQ6ZnVuY3Rpb24oZSl7ZS5lbGVtLm5vZGVUeXBlJiZlLmVsZW0ucGFyZW50Tm9kZSYmKGUuZWxlbVtlLnByb3BdPWUubm93KX19LGNlLmVhc2luZz17bGluZWFyOmZ1bmN0aW9uKGUpe3JldHVybiBlfSxzd2luZzpmdW5jdGlvbihlKXtyZXR1cm4uNS1NYXRoLmNvcyhlKk1hdGguUEkpLzJ9LF9kZWZhdWx0Olwic3dpbmdcIn0sY2UuZng9YXQucHJvdG90eXBlLmluaXQsY2UuZnguc3RlcD17fTt2YXIgc3QsdXQsbHQsY3QsZnQ9L14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLHB0PS9xdWV1ZUhvb2tzJC87ZnVuY3Rpb24gZHQoKXt1dCYmKCExPT09Qy5oaWRkZW4mJmllLnJlcXVlc3RBbmltYXRpb25GcmFtZT9pZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHQpOmllLnNldFRpbWVvdXQoZHQsY2UuZnguaW50ZXJ2YWwpLGNlLmZ4LnRpY2soKSl9ZnVuY3Rpb24gaHQoKXtyZXR1cm4gaWUuc2V0VGltZW91dChmdW5jdGlvbigpe3N0PXZvaWQgMH0pLHN0PURhdGUubm93KCl9ZnVuY3Rpb24gZ3QoZSx0KXt2YXIgbixyPTAsaT17aGVpZ2h0OmV9O2Zvcih0PXQ/MTowO3I8NDtyKz0yLXQpaVtcIm1hcmdpblwiKyhuPVFbcl0pXT1pW1wicGFkZGluZ1wiK25dPWU7cmV0dXJuIHQmJihpLm9wYWNpdHk9aS53aWR0aD1lKSxpfWZ1bmN0aW9uIHZ0KGUsdCxuKXtmb3IodmFyIHIsaT0oeXQudHdlZW5lcnNbdF18fFtdKS5jb25jYXQoeXQudHdlZW5lcnNbXCIqXCJdKSxvPTAsYT1pLmxlbmd0aDtvPGE7bysrKWlmKHI9aVtvXS5jYWxsKG4sdCxlKSlyZXR1cm4gcn1mdW5jdGlvbiB5dChvLGUsdCl7dmFyIG4sYSxyPTAsaT15dC5wcmVmaWx0ZXJzLmxlbmd0aCxzPWNlLkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uKCl7ZGVsZXRlIHUuZWxlbX0pLHU9ZnVuY3Rpb24oKXtpZihhKXJldHVybiExO2Zvcih2YXIgZT1zdHx8aHQoKSx0PU1hdGgubWF4KDAsbC5zdGFydFRpbWUrbC5kdXJhdGlvbi1lKSxuPTEtKHQvbC5kdXJhdGlvbnx8MCkscj0wLGk9bC50d2VlbnMubGVuZ3RoO3I8aTtyKyspbC50d2VlbnNbcl0ucnVuKG4pO3JldHVybiBzLm5vdGlmeVdpdGgobyxbbCxuLHRdKSxuPDEmJmk/dDooaXx8cy5ub3RpZnlXaXRoKG8sW2wsMSwwXSkscy5yZXNvbHZlV2l0aChvLFtsXSksITEpfSxsPXMucHJvbWlzZSh7ZWxlbTpvLHByb3BzOmNlLmV4dGVuZCh7fSxlKSxvcHRzOmNlLmV4dGVuZCghMCx7c3BlY2lhbEVhc2luZzp7fSxlYXNpbmc6Y2UuZWFzaW5nLl9kZWZhdWx0fSx0KSxvcmlnaW5hbFByb3BlcnRpZXM6ZSxvcmlnaW5hbE9wdGlvbnM6dCxzdGFydFRpbWU6c3R8fGh0KCksZHVyYXRpb246dC5kdXJhdGlvbix0d2VlbnM6W10sY3JlYXRlVHdlZW46ZnVuY3Rpb24oZSx0KXt2YXIgbj1jZS5Ud2VlbihvLGwub3B0cyxlLHQsbC5vcHRzLnNwZWNpYWxFYXNpbmdbZV18fGwub3B0cy5lYXNpbmcpO3JldHVybiBsLnR3ZWVucy5wdXNoKG4pLG59LHN0b3A6ZnVuY3Rpb24oZSl7dmFyIHQ9MCxuPWU/bC50d2VlbnMubGVuZ3RoOjA7aWYoYSlyZXR1cm4gdGhpcztmb3IoYT0hMDt0PG47dCsrKWwudHdlZW5zW3RdLnJ1bigxKTtyZXR1cm4gZT8ocy5ub3RpZnlXaXRoKG8sW2wsMSwwXSkscy5yZXNvbHZlV2l0aChvLFtsLGVdKSk6cy5yZWplY3RXaXRoKG8sW2wsZV0pLHRoaXN9fSksYz1sLnByb3BzO2ZvcighZnVuY3Rpb24oZSx0KXt2YXIgbixyLGksbyxhO2ZvcihuIGluIGUpaWYoaT10W3I9RihuKV0sbz1lW25dLEFycmF5LmlzQXJyYXkobykmJihpPW9bMV0sbz1lW25dPW9bMF0pLG4hPT1yJiYoZVtyXT1vLGRlbGV0ZSBlW25dKSwoYT1jZS5jc3NIb29rc1tyXSkmJlwiZXhwYW5kXCJpbiBhKWZvcihuIGluIG89YS5leHBhbmQobyksZGVsZXRlIGVbcl0sbyluIGluIGV8fChlW25dPW9bbl0sdFtuXT1pKTtlbHNlIHRbcl09aX0oYyxsLm9wdHMuc3BlY2lhbEVhc2luZyk7cjxpO3IrKylpZihuPXl0LnByZWZpbHRlcnNbcl0uY2FsbChsLG8sYyxsLm9wdHMpKXJldHVybiB2KG4uc3RvcCkmJihjZS5fcXVldWVIb29rcyhsLmVsZW0sbC5vcHRzLnF1ZXVlKS5zdG9wPW4uc3RvcC5iaW5kKG4pKSxuO3JldHVybiBjZS5tYXAoYyx2dCxsKSx2KGwub3B0cy5zdGFydCkmJmwub3B0cy5zdGFydC5jYWxsKG8sbCksbC5wcm9ncmVzcyhsLm9wdHMucHJvZ3Jlc3MpLmRvbmUobC5vcHRzLmRvbmUsbC5vcHRzLmNvbXBsZXRlKS5mYWlsKGwub3B0cy5mYWlsKS5hbHdheXMobC5vcHRzLmFsd2F5cyksY2UuZngudGltZXIoY2UuZXh0ZW5kKHUse2VsZW06byxhbmltOmwscXVldWU6bC5vcHRzLnF1ZXVlfSkpLGx9Y2UuQW5pbWF0aW9uPWNlLmV4dGVuZCh5dCx7dHdlZW5lcnM6e1wiKlwiOltmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuY3JlYXRlVHdlZW4oZSx0KTtyZXR1cm4gdGUobi5lbGVtLGUsWS5leGVjKHQpLG4pLG59XX0sdHdlZW5lcjpmdW5jdGlvbihlLHQpe3YoZSk/KHQ9ZSxlPVtcIipcIl0pOmU9ZS5tYXRjaChEKTtmb3IodmFyIG4scj0wLGk9ZS5sZW5ndGg7cjxpO3IrKyluPWVbcl0seXQudHdlZW5lcnNbbl09eXQudHdlZW5lcnNbbl18fFtdLHl0LnR3ZWVuZXJzW25dLnVuc2hpZnQodCl9LHByZWZpbHRlcnM6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzLHUsbCxjLGY9XCJ3aWR0aFwiaW4gdHx8XCJoZWlnaHRcImluIHQscD10aGlzLGQ9e30saD1lLnN0eWxlLGc9ZS5ub2RlVHlwZSYmZWUoZSksdj1fLmdldChlLFwiZnhzaG93XCIpO2ZvcihyIGluIG4ucXVldWV8fChudWxsPT0oYT1jZS5fcXVldWVIb29rcyhlLFwiZnhcIikpLnVucXVldWVkJiYoYS51bnF1ZXVlZD0wLHM9YS5lbXB0eS5maXJlLGEuZW1wdHkuZmlyZT1mdW5jdGlvbigpe2EudW5xdWV1ZWR8fHMoKX0pLGEudW5xdWV1ZWQrKyxwLmFsd2F5cyhmdW5jdGlvbigpe3AuYWx3YXlzKGZ1bmN0aW9uKCl7YS51bnF1ZXVlZC0tLGNlLnF1ZXVlKGUsXCJmeFwiKS5sZW5ndGh8fGEuZW1wdHkuZmlyZSgpfSl9KSksdClpZihpPXRbcl0sZnQudGVzdChpKSl7aWYoZGVsZXRlIHRbcl0sbz1vfHxcInRvZ2dsZVwiPT09aSxpPT09KGc/XCJoaWRlXCI6XCJzaG93XCIpKXtpZihcInNob3dcIiE9PWl8fCF2fHx2b2lkIDA9PT12W3JdKWNvbnRpbnVlO2c9ITB9ZFtyXT12JiZ2W3JdfHxjZS5zdHlsZShlLHIpfWlmKCh1PSFjZS5pc0VtcHR5T2JqZWN0KHQpKXx8IWNlLmlzRW1wdHlPYmplY3QoZCkpZm9yKHIgaW4gZiYmMT09PWUubm9kZVR5cGUmJihuLm92ZXJmbG93PVtoLm92ZXJmbG93LGgub3ZlcmZsb3dYLGgub3ZlcmZsb3dZXSxudWxsPT0obD12JiZ2LmRpc3BsYXkpJiYobD1fLmdldChlLFwiZGlzcGxheVwiKSksXCJub25lXCI9PT0oYz1jZS5jc3MoZSxcImRpc3BsYXlcIikpJiYobD9jPWw6KHJlKFtlXSwhMCksbD1lLnN0eWxlLmRpc3BsYXl8fGwsYz1jZS5jc3MoZSxcImRpc3BsYXlcIikscmUoW2VdKSkpLChcImlubGluZVwiPT09Y3x8XCJpbmxpbmUtYmxvY2tcIj09PWMmJm51bGwhPWwpJiZcIm5vbmVcIj09PWNlLmNzcyhlLFwiZmxvYXRcIikmJih1fHwocC5kb25lKGZ1bmN0aW9uKCl7aC5kaXNwbGF5PWx9KSxudWxsPT1sJiYoYz1oLmRpc3BsYXksbD1cIm5vbmVcIj09PWM/XCJcIjpjKSksaC5kaXNwbGF5PVwiaW5saW5lLWJsb2NrXCIpKSxuLm92ZXJmbG93JiYoaC5vdmVyZmxvdz1cImhpZGRlblwiLHAuYWx3YXlzKGZ1bmN0aW9uKCl7aC5vdmVyZmxvdz1uLm92ZXJmbG93WzBdLGgub3ZlcmZsb3dYPW4ub3ZlcmZsb3dbMV0saC5vdmVyZmxvd1k9bi5vdmVyZmxvd1syXX0pKSx1PSExLGQpdXx8KHY/XCJoaWRkZW5cImluIHYmJihnPXYuaGlkZGVuKTp2PV8uYWNjZXNzKGUsXCJmeHNob3dcIix7ZGlzcGxheTpsfSksbyYmKHYuaGlkZGVuPSFnKSxnJiZyZShbZV0sITApLHAuZG9uZShmdW5jdGlvbigpe2ZvcihyIGluIGd8fHJlKFtlXSksXy5yZW1vdmUoZSxcImZ4c2hvd1wiKSxkKWNlLnN0eWxlKGUscixkW3JdKX0pKSx1PXZ0KGc/dltyXTowLHIscCksciBpbiB2fHwodltyXT11LnN0YXJ0LGcmJih1LmVuZD11LnN0YXJ0LHUuc3RhcnQ9MCkpfV0scHJlZmlsdGVyOmZ1bmN0aW9uKGUsdCl7dD95dC5wcmVmaWx0ZXJzLnVuc2hpZnQoZSk6eXQucHJlZmlsdGVycy5wdXNoKGUpfX0pLGNlLnNwZWVkPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1lJiZcIm9iamVjdFwiPT10eXBlb2YgZT9jZS5leHRlbmQoe30sZSk6e2NvbXBsZXRlOm58fCFuJiZ0fHx2KGUpJiZlLGR1cmF0aW9uOmUsZWFzaW5nOm4mJnR8fHQmJiF2KHQpJiZ0fTtyZXR1cm4gY2UuZngub2ZmP3IuZHVyYXRpb249MDpcIm51bWJlclwiIT10eXBlb2Ygci5kdXJhdGlvbiYmKHIuZHVyYXRpb24gaW4gY2UuZnguc3BlZWRzP3IuZHVyYXRpb249Y2UuZnguc3BlZWRzW3IuZHVyYXRpb25dOnIuZHVyYXRpb249Y2UuZnguc3BlZWRzLl9kZWZhdWx0KSxudWxsIT1yLnF1ZXVlJiYhMCE9PXIucXVldWV8fChyLnF1ZXVlPVwiZnhcIiksci5vbGQ9ci5jb21wbGV0ZSxyLmNvbXBsZXRlPWZ1bmN0aW9uKCl7dihyLm9sZCkmJnIub2xkLmNhbGwodGhpcyksci5xdWV1ZSYmY2UuZGVxdWV1ZSh0aGlzLHIucXVldWUpfSxyfSxjZS5mbi5leHRlbmQoe2ZhZGVUbzpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5maWx0ZXIoZWUpLmNzcyhcIm9wYWNpdHlcIiwwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7b3BhY2l0eTp0fSxlLG4scil9LGFuaW1hdGU6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9Y2UuaXNFbXB0eU9iamVjdCh0KSxvPWNlLnNwZWVkKGUsbixyKSxhPWZ1bmN0aW9uKCl7dmFyIGU9eXQodGhpcyxjZS5leHRlbmQoe30sdCksbyk7KGl8fF8uZ2V0KHRoaXMsXCJmaW5pc2hcIikpJiZlLnN0b3AoITApfTtyZXR1cm4gYS5maW5pc2g9YSxpfHwhMT09PW8ucXVldWU/dGhpcy5lYWNoKGEpOnRoaXMucXVldWUoby5xdWV1ZSxhKX0sc3RvcDpmdW5jdGlvbihpLGUsbyl7dmFyIGE9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdG9wO2RlbGV0ZSBlLnN0b3AsdChvKX07cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGkmJihvPWUsZT1pLGk9dm9pZCAwKSxlJiZ0aGlzLnF1ZXVlKGl8fFwiZnhcIixbXSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9ITAsdD1udWxsIT1pJiZpK1wicXVldWVIb29rc1wiLG49Y2UudGltZXJzLHI9Xy5nZXQodGhpcyk7aWYodClyW3RdJiZyW3RdLnN0b3AmJmEoclt0XSk7ZWxzZSBmb3IodCBpbiByKXJbdF0mJnJbdF0uc3RvcCYmcHQudGVzdCh0KSYmYShyW3RdKTtmb3IodD1uLmxlbmd0aDt0LS07KW5bdF0uZWxlbSE9PXRoaXN8fG51bGwhPWkmJm5bdF0ucXVldWUhPT1pfHwoblt0XS5hbmltLnN0b3AobyksZT0hMSxuLnNwbGljZSh0LDEpKTshZSYmb3x8Y2UuZGVxdWV1ZSh0aGlzLGkpfSl9LGZpbmlzaDpmdW5jdGlvbihhKXtyZXR1cm4hMSE9PWEmJihhPWF8fFwiZnhcIiksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGUsdD1fLmdldCh0aGlzKSxuPXRbYStcInF1ZXVlXCJdLHI9dFthK1wicXVldWVIb29rc1wiXSxpPWNlLnRpbWVycyxvPW4/bi5sZW5ndGg6MDtmb3IodC5maW5pc2g9ITAsY2UucXVldWUodGhpcyxhLFtdKSxyJiZyLnN0b3AmJnIuc3RvcC5jYWxsKHRoaXMsITApLGU9aS5sZW5ndGg7ZS0tOylpW2VdLmVsZW09PT10aGlzJiZpW2VdLnF1ZXVlPT09YSYmKGlbZV0uYW5pbS5zdG9wKCEwKSxpLnNwbGljZShlLDEpKTtmb3IoZT0wO2U8bztlKyspbltlXSYmbltlXS5maW5pc2gmJm5bZV0uZmluaXNoLmNhbGwodGhpcyk7ZGVsZXRlIHQuZmluaXNofSl9fSksY2UuZWFjaChbXCJ0b2dnbGVcIixcInNob3dcIixcImhpZGVcIl0sZnVuY3Rpb24oZSxyKXt2YXIgaT1jZS5mbltyXTtjZS5mbltyXT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIG51bGw9PWV8fFwiYm9vbGVhblwiPT10eXBlb2YgZT9pLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUoZ3QociwhMCksZSx0LG4pfX0pLGNlLmVhY2goe3NsaWRlRG93bjpndChcInNob3dcIiksc2xpZGVVcDpndChcImhpZGVcIiksc2xpZGVUb2dnbGU6Z3QoXCJ0b2dnbGVcIiksZmFkZUluOntvcGFjaXR5Olwic2hvd1wifSxmYWRlT3V0OntvcGFjaXR5OlwiaGlkZVwifSxmYWRlVG9nZ2xlOntvcGFjaXR5OlwidG9nZ2xlXCJ9fSxmdW5jdGlvbihlLHIpe2NlLmZuW2VdPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy5hbmltYXRlKHIsZSx0LG4pfX0pLGNlLnRpbWVycz1bXSxjZS5meC50aWNrPWZ1bmN0aW9uKCl7dmFyIGUsdD0wLG49Y2UudGltZXJzO2ZvcihzdD1EYXRlLm5vdygpO3Q8bi5sZW5ndGg7dCsrKShlPW5bdF0pKCl8fG5bdF0hPT1lfHxuLnNwbGljZSh0LS0sMSk7bi5sZW5ndGh8fGNlLmZ4LnN0b3AoKSxzdD12b2lkIDB9LGNlLmZ4LnRpbWVyPWZ1bmN0aW9uKGUpe2NlLnRpbWVycy5wdXNoKGUpLGNlLmZ4LnN0YXJ0KCl9LGNlLmZ4LmludGVydmFsPTEzLGNlLmZ4LnN0YXJ0PWZ1bmN0aW9uKCl7dXR8fCh1dD0hMCxkdCgpKX0sY2UuZnguc3RvcD1mdW5jdGlvbigpe3V0PW51bGx9LGNlLmZ4LnNwZWVkcz17c2xvdzo2MDAsZmFzdDoyMDAsX2RlZmF1bHQ6NDAwfSxjZS5mbi5kZWxheT1mdW5jdGlvbihyLGUpe3JldHVybiByPWNlLmZ4JiZjZS5meC5zcGVlZHNbcl18fHIsZT1lfHxcImZ4XCIsdGhpcy5xdWV1ZShlLGZ1bmN0aW9uKGUsdCl7dmFyIG49aWUuc2V0VGltZW91dChlLHIpO3Quc3RvcD1mdW5jdGlvbigpe2llLmNsZWFyVGltZW91dChuKX19KX0sbHQ9Qy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksY3Q9Qy5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLmFwcGVuZENoaWxkKEMuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSksbHQudHlwZT1cImNoZWNrYm94XCIsbGUuY2hlY2tPbj1cIlwiIT09bHQudmFsdWUsbGUub3B0U2VsZWN0ZWQ9Y3Quc2VsZWN0ZWQsKGx0PUMuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS52YWx1ZT1cInRcIixsdC50eXBlPVwicmFkaW9cIixsZS5yYWRpb1ZhbHVlPVwidFwiPT09bHQudmFsdWU7dmFyIG10LHh0PWNlLmV4cHIuYXR0ckhhbmRsZTtjZS5mbi5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gTSh0aGlzLGNlLmF0dHIsZSx0LDE8YXJndW1lbnRzLmxlbmd0aCl9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2NlLnJlbW92ZUF0dHIodGhpcyxlKX0pfX0pLGNlLmV4dGVuZCh7YXR0cjpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPWUubm9kZVR5cGU7aWYoMyE9PW8mJjghPT1vJiYyIT09bylyZXR1cm5cInVuZGVmaW5lZFwiPT10eXBlb2YgZS5nZXRBdHRyaWJ1dGU/Y2UucHJvcChlLHQsbik6KDE9PT1vJiZjZS5pc1hNTERvYyhlKXx8KGk9Y2UuYXR0ckhvb2tzW3QudG9Mb3dlckNhc2UoKV18fChjZS5leHByLm1hdGNoLmJvb2wudGVzdCh0KT9tdDp2b2lkIDApKSx2b2lkIDAhPT1uP251bGw9PT1uP3ZvaWQgY2UucmVtb3ZlQXR0cihlLHQpOmkmJlwic2V0XCJpbiBpJiZ2b2lkIDAhPT0ocj1pLnNldChlLG4sdCkpP3I6KGUuc2V0QXR0cmlidXRlKHQsbitcIlwiKSxuKTppJiZcImdldFwiaW4gaSYmbnVsbCE9PShyPWkuZ2V0KGUsdCkpP3I6bnVsbD09KHI9Y2UuZmluZC5hdHRyKGUsdCkpP3ZvaWQgMDpyKX0sYXR0ckhvb2tzOnt0eXBlOntzZXQ6ZnVuY3Rpb24oZSx0KXtpZighbGUucmFkaW9WYWx1ZSYmXCJyYWRpb1wiPT09dCYmZmUoZSxcImlucHV0XCIpKXt2YXIgbj1lLnZhbHVlO3JldHVybiBlLnNldEF0dHJpYnV0ZShcInR5cGVcIix0KSxuJiYoZS52YWx1ZT1uKSx0fX19fSxyZW1vdmVBdHRyOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj0wLGk9dCYmdC5tYXRjaChEKTtpZihpJiYxPT09ZS5ub2RlVHlwZSl3aGlsZShuPWlbcisrXSllLnJlbW92ZUF0dHJpYnV0ZShuKX19KSxtdD17c2V0OmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4hMT09PXQ/Y2UucmVtb3ZlQXR0cihlLG4pOmUuc2V0QXR0cmlidXRlKG4sbiksbn19LGNlLmVhY2goY2UuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSxmdW5jdGlvbihlLHQpe3ZhciBhPXh0W3RdfHxjZS5maW5kLmF0dHI7eHRbdF09ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbz10LnRvTG93ZXJDYXNlKCk7cmV0dXJuIG58fChpPXh0W29dLHh0W29dPXIscj1udWxsIT1hKGUsdCxuKT9vOm51bGwseHRbb109aSkscn19KTt2YXIgYnQ9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSx3dD0vXig/OmF8YXJlYSkkL2k7ZnVuY3Rpb24gVHQoZSl7cmV0dXJuKGUubWF0Y2goRCl8fFtdKS5qb2luKFwiIFwiKX1mdW5jdGlvbiBDdChlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUmJmUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCJ9ZnVuY3Rpb24ga3QoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZTpcInN0cmluZ1wiPT10eXBlb2YgZSYmZS5tYXRjaChEKXx8W119Y2UuZm4uZXh0ZW5kKHtwcm9wOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIE0odGhpcyxjZS5wcm9wLGUsdCwxPGFyZ3VtZW50cy5sZW5ndGgpfSxyZW1vdmVQcm9wOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtkZWxldGUgdGhpc1tjZS5wcm9wRml4W2VdfHxlXX0pfX0pLGNlLmV4dGVuZCh7cHJvcDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPWUubm9kZVR5cGU7aWYoMyE9PW8mJjghPT1vJiYyIT09bylyZXR1cm4gMT09PW8mJmNlLmlzWE1MRG9jKGUpfHwodD1jZS5wcm9wRml4W3RdfHx0LGk9Y2UucHJvcEhvb2tzW3RdKSx2b2lkIDAhPT1uP2kmJlwic2V0XCJpbiBpJiZ2b2lkIDAhPT0ocj1pLnNldChlLG4sdCkpP3I6ZVt0XT1uOmkmJlwiZ2V0XCJpbiBpJiZudWxsIT09KHI9aS5nZXQoZSx0KSk/cjplW3RdfSxwcm9wSG9va3M6e3RhYkluZGV4OntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9Y2UuZmluZC5hdHRyKGUsXCJ0YWJpbmRleFwiKTtyZXR1cm4gdD9wYXJzZUludCh0LDEwKTpidC50ZXN0KGUubm9kZU5hbWUpfHx3dC50ZXN0KGUubm9kZU5hbWUpJiZlLmhyZWY/MDotMX19fSxwcm9wRml4OntcImZvclwiOlwiaHRtbEZvclwiLFwiY2xhc3NcIjpcImNsYXNzTmFtZVwifX0pLGxlLm9wdFNlbGVjdGVkfHwoY2UucHJvcEhvb2tzLnNlbGVjdGVkPXtnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wYXJlbnROb2RlO3JldHVybiB0JiZ0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LG51bGx9LHNldDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7dCYmKHQuc2VsZWN0ZWRJbmRleCx0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KX19KSxjZS5lYWNoKFtcInRhYkluZGV4XCIsXCJyZWFkT25seVwiLFwibWF4TGVuZ3RoXCIsXCJjZWxsU3BhY2luZ1wiLFwiY2VsbFBhZGRpbmdcIixcInJvd1NwYW5cIixcImNvbFNwYW5cIixcInVzZU1hcFwiLFwiZnJhbWVCb3JkZXJcIixcImNvbnRlbnRFZGl0YWJsZVwiXSxmdW5jdGlvbigpe2NlLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXT10aGlzfSksY2UuZm4uZXh0ZW5kKHthZGRDbGFzczpmdW5jdGlvbih0KXt2YXIgZSxuLHIsaSxvLGE7cmV0dXJuIHYodCk/dGhpcy5lYWNoKGZ1bmN0aW9uKGUpe2NlKHRoaXMpLmFkZENsYXNzKHQuY2FsbCh0aGlzLGUsQ3QodGhpcykpKX0pOihlPWt0KHQpKS5sZW5ndGg/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7aWYocj1DdCh0aGlzKSxuPTE9PT10aGlzLm5vZGVUeXBlJiZcIiBcIitUdChyKStcIiBcIil7Zm9yKG89MDtvPGUubGVuZ3RoO28rKylpPWVbb10sbi5pbmRleE9mKFwiIFwiK2krXCIgXCIpPDAmJihuKz1pK1wiIFwiKTthPVR0KG4pLHIhPT1hJiZ0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYSl9fSk6dGhpc30scmVtb3ZlQ2xhc3M6ZnVuY3Rpb24odCl7dmFyIGUsbixyLGksbyxhO3JldHVybiB2KHQpP3RoaXMuZWFjaChmdW5jdGlvbihlKXtjZSh0aGlzKS5yZW1vdmVDbGFzcyh0LmNhbGwodGhpcyxlLEN0KHRoaXMpKSl9KTphcmd1bWVudHMubGVuZ3RoPyhlPWt0KHQpKS5sZW5ndGg/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7aWYocj1DdCh0aGlzKSxuPTE9PT10aGlzLm5vZGVUeXBlJiZcIiBcIitUdChyKStcIiBcIil7Zm9yKG89MDtvPGUubGVuZ3RoO28rKyl7aT1lW29dO3doaWxlKC0xPG4uaW5kZXhPZihcIiBcIitpK1wiIFwiKSluPW4ucmVwbGFjZShcIiBcIitpK1wiIFwiLFwiIFwiKX1hPVR0KG4pLHIhPT1hJiZ0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYSl9fSk6dGhpczp0aGlzLmF0dHIoXCJjbGFzc1wiLFwiXCIpfSx0b2dnbGVDbGFzczpmdW5jdGlvbih0LG4pe3ZhciBlLHIsaSxvLGE9dHlwZW9mIHQscz1cInN0cmluZ1wiPT09YXx8QXJyYXkuaXNBcnJheSh0KTtyZXR1cm4gdih0KT90aGlzLmVhY2goZnVuY3Rpb24oZSl7Y2UodGhpcykudG9nZ2xlQ2xhc3ModC5jYWxsKHRoaXMsZSxDdCh0aGlzKSxuKSxuKX0pOlwiYm9vbGVhblwiPT10eXBlb2YgbiYmcz9uP3RoaXMuYWRkQ2xhc3ModCk6dGhpcy5yZW1vdmVDbGFzcyh0KTooZT1rdCh0KSx0aGlzLmVhY2goZnVuY3Rpb24oKXtpZihzKWZvcihvPWNlKHRoaXMpLGk9MDtpPGUubGVuZ3RoO2krKylyPWVbaV0sby5oYXNDbGFzcyhyKT9vLnJlbW92ZUNsYXNzKHIpOm8uYWRkQ2xhc3Mocik7ZWxzZSB2b2lkIDAhPT10JiZcImJvb2xlYW5cIiE9PWF8fCgocj1DdCh0aGlzKSkmJl8uc2V0KHRoaXMsXCJfX2NsYXNzTmFtZV9fXCIsciksdGhpcy5zZXRBdHRyaWJ1dGUmJnRoaXMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixyfHwhMT09PXQ/XCJcIjpfLmdldCh0aGlzLFwiX19jbGFzc05hbWVfX1wiKXx8XCJcIikpfSkpfSxoYXNDbGFzczpmdW5jdGlvbihlKXt2YXIgdCxuLHI9MDt0PVwiIFwiK2UrXCIgXCI7d2hpbGUobj10aGlzW3IrK10paWYoMT09PW4ubm9kZVR5cGUmJi0xPChcIiBcIitUdChDdChuKSkrXCIgXCIpLmluZGV4T2YodCkpcmV0dXJuITA7cmV0dXJuITF9fSk7dmFyIFN0PS9cXHIvZztjZS5mbi5leHRlbmQoe3ZhbDpmdW5jdGlvbihuKXt2YXIgcixlLGksdD10aGlzWzBdO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhpPXYobiksdGhpcy5lYWNoKGZ1bmN0aW9uKGUpe3ZhciB0OzE9PT10aGlzLm5vZGVUeXBlJiYobnVsbD09KHQ9aT9uLmNhbGwodGhpcyxlLGNlKHRoaXMpLnZhbCgpKTpuKT90PVwiXCI6XCJudW1iZXJcIj09dHlwZW9mIHQ/dCs9XCJcIjpBcnJheS5pc0FycmF5KHQpJiYodD1jZS5tYXAodCxmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT9cIlwiOmUrXCJcIn0pKSwocj1jZS52YWxIb29rc1t0aGlzLnR5cGVdfHxjZS52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSYmXCJzZXRcImluIHImJnZvaWQgMCE9PXIuc2V0KHRoaXMsdCxcInZhbHVlXCIpfHwodGhpcy52YWx1ZT10KSl9KSk6dD8ocj1jZS52YWxIb29rc1t0LnR5cGVdfHxjZS52YWxIb29rc1t0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSYmXCJnZXRcImluIHImJnZvaWQgMCE9PShlPXIuZ2V0KHQsXCJ2YWx1ZVwiKSk/ZTpcInN0cmluZ1wiPT10eXBlb2YoZT10LnZhbHVlKT9lLnJlcGxhY2UoU3QsXCJcIik6bnVsbD09ZT9cIlwiOmU6dm9pZCAwfX0pLGNlLmV4dGVuZCh7dmFsSG9va3M6e29wdGlvbjp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0PWNlLmZpbmQuYXR0cihlLFwidmFsdWVcIik7cmV0dXJuIG51bGwhPXQ/dDpUdChjZS50ZXh0KGUpKX19LHNlbGVjdDp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpPWUub3B0aW9ucyxvPWUuc2VsZWN0ZWRJbmRleCxhPVwic2VsZWN0LW9uZVwiPT09ZS50eXBlLHM9YT9udWxsOltdLHU9YT9vKzE6aS5sZW5ndGg7Zm9yKHI9bzwwP3U6YT9vOjA7cjx1O3IrKylpZigoKG49aVtyXSkuc2VsZWN0ZWR8fHI9PT1vKSYmIW4uZGlzYWJsZWQmJighbi5wYXJlbnROb2RlLmRpc2FibGVkfHwhZmUobi5wYXJlbnROb2RlLFwib3B0Z3JvdXBcIikpKXtpZih0PWNlKG4pLnZhbCgpLGEpcmV0dXJuIHQ7cy5wdXNoKHQpfXJldHVybiBzfSxzZXQ6ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGk9ZS5vcHRpb25zLG89Y2UubWFrZUFycmF5KHQpLGE9aS5sZW5ndGg7d2hpbGUoYS0tKSgocj1pW2FdKS5zZWxlY3RlZD0tMTxjZS5pbkFycmF5KGNlLnZhbEhvb2tzLm9wdGlvbi5nZXQociksbykpJiYobj0hMCk7cmV0dXJuIG58fChlLnNlbGVjdGVkSW5kZXg9LTEpLG99fX19KSxjZS5lYWNoKFtcInJhZGlvXCIsXCJjaGVja2JveFwiXSxmdW5jdGlvbigpe2NlLnZhbEhvb2tzW3RoaXNdPXtzZXQ6ZnVuY3Rpb24oZSx0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiBlLmNoZWNrZWQ9LTE8Y2UuaW5BcnJheShjZShlKS52YWwoKSx0KX19LGxlLmNoZWNrT258fChjZS52YWxIb29rc1t0aGlzXS5nZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PT1lLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpP1wib25cIjplLnZhbHVlfSl9KTt2YXIgRXQ9aWUubG9jYXRpb24sanQ9e2d1aWQ6RGF0ZS5ub3coKX0sQXQ9L1xcPy87Y2UucGFyc2VYTUw9ZnVuY3Rpb24oZSl7dmFyIHQsbjtpZighZXx8XCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuIG51bGw7dHJ5e3Q9KG5ldyBpZS5ET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyhlLFwidGV4dC94bWxcIil9Y2F0Y2goZSl7fXJldHVybiBuPXQmJnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKVswXSx0JiYhbnx8Y2UuZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIrKG4/Y2UubWFwKG4uY2hpbGROb2RlcyxmdW5jdGlvbihlKXtyZXR1cm4gZS50ZXh0Q29udGVudH0pLmpvaW4oXCJcXG5cIik6ZSkpLHR9O3ZhciBEdD0vXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sTnQ9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKX07Y2UuZXh0ZW5kKGNlLmV2ZW50LHt0cmlnZ2VyOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYSxzLHUsbCxjLGYscD1bbnx8Q10sZD11ZS5jYWxsKGUsXCJ0eXBlXCIpP2UudHlwZTplLGg9dWUuY2FsbChlLFwibmFtZXNwYWNlXCIpP2UubmFtZXNwYWNlLnNwbGl0KFwiLlwiKTpbXTtpZihvPWY9YT1uPW58fEMsMyE9PW4ubm9kZVR5cGUmJjghPT1uLm5vZGVUeXBlJiYhRHQudGVzdChkK2NlLmV2ZW50LnRyaWdnZXJlZCkmJigtMTxkLmluZGV4T2YoXCIuXCIpJiYoZD0oaD1kLnNwbGl0KFwiLlwiKSkuc2hpZnQoKSxoLnNvcnQoKSksdT1kLmluZGV4T2YoXCI6XCIpPDAmJlwib25cIitkLChlPWVbY2UuZXhwYW5kb10/ZTpuZXcgY2UuRXZlbnQoZCxcIm9iamVjdFwiPT10eXBlb2YgZSYmZSkpLmlzVHJpZ2dlcj1yPzI6MyxlLm5hbWVzcGFjZT1oLmpvaW4oXCIuXCIpLGUucm5hbWVzcGFjZT1lLm5hbWVzcGFjZT9uZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIraC5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikrXCIoXFxcXC58JClcIik6bnVsbCxlLnJlc3VsdD12b2lkIDAsZS50YXJnZXR8fChlLnRhcmdldD1uKSx0PW51bGw9PXQ/W2VdOmNlLm1ha2VBcnJheSh0LFtlXSksYz1jZS5ldmVudC5zcGVjaWFsW2RdfHx7fSxyfHwhYy50cmlnZ2VyfHwhMSE9PWMudHJpZ2dlci5hcHBseShuLHQpKSl7aWYoIXImJiFjLm5vQnViYmxlJiYheShuKSl7Zm9yKHM9Yy5kZWxlZ2F0ZVR5cGV8fGQsRHQudGVzdChzK2QpfHwobz1vLnBhcmVudE5vZGUpO287bz1vLnBhcmVudE5vZGUpcC5wdXNoKG8pLGE9bzthPT09KG4ub3duZXJEb2N1bWVudHx8QykmJnAucHVzaChhLmRlZmF1bHRWaWV3fHxhLnBhcmVudFdpbmRvd3x8aWUpfWk9MDt3aGlsZSgobz1wW2krK10pJiYhZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWY9byxlLnR5cGU9MTxpP3M6Yy5iaW5kVHlwZXx8ZCwobD0oXy5nZXQobyxcImV2ZW50c1wiKXx8T2JqZWN0LmNyZWF0ZShudWxsKSlbZS50eXBlXSYmXy5nZXQobyxcImhhbmRsZVwiKSkmJmwuYXBwbHkobyx0KSwobD11JiZvW3VdKSYmbC5hcHBseSYmJChvKSYmKGUucmVzdWx0PWwuYXBwbHkobyx0KSwhMT09PWUucmVzdWx0JiZlLnByZXZlbnREZWZhdWx0KCkpO3JldHVybiBlLnR5cGU9ZCxyfHxlLmlzRGVmYXVsdFByZXZlbnRlZCgpfHxjLl9kZWZhdWx0JiYhMSE9PWMuX2RlZmF1bHQuYXBwbHkocC5wb3AoKSx0KXx8ISQobil8fHUmJnYobltkXSkmJiF5KG4pJiYoKGE9blt1XSkmJihuW3VdPW51bGwpLGNlLmV2ZW50LnRyaWdnZXJlZD1kLGUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSYmZi5hZGRFdmVudExpc3RlbmVyKGQsTnQpLG5bZF0oKSxlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkmJmYucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLE50KSxjZS5ldmVudC50cmlnZ2VyZWQ9dm9pZCAwLGEmJihuW3VdPWEpKSxlLnJlc3VsdH19LHNpbXVsYXRlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1jZS5leHRlbmQobmV3IGNlLkV2ZW50LG4se3R5cGU6ZSxpc1NpbXVsYXRlZDohMH0pO2NlLmV2ZW50LnRyaWdnZXIocixudWxsLHQpfX0pLGNlLmZuLmV4dGVuZCh7dHJpZ2dlcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtjZS5ldmVudC50cmlnZ2VyKGUsdCx0aGlzKX0pfSx0cmlnZ2VySGFuZGxlcjpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXNbMF07aWYobilyZXR1cm4gY2UuZXZlbnQudHJpZ2dlcihlLHQsbiwhMCl9fSk7dmFyIHF0PS9cXFtcXF0kLyxMdD0vXFxyP1xcbi9nLEh0PS9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxPdD0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7ZnVuY3Rpb24gUHQobixlLHIsaSl7dmFyIHQ7aWYoQXJyYXkuaXNBcnJheShlKSljZS5lYWNoKGUsZnVuY3Rpb24oZSx0KXtyfHxxdC50ZXN0KG4pP2kobix0KTpQdChuK1wiW1wiKyhcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9dD9lOlwiXCIpK1wiXVwiLHQscixpKX0pO2Vsc2UgaWYocnx8XCJvYmplY3RcIiE9PXgoZSkpaShuLGUpO2Vsc2UgZm9yKHQgaW4gZSlQdChuK1wiW1wiK3QrXCJdXCIsZVt0XSxyLGkpfWNlLnBhcmFtPWZ1bmN0aW9uKGUsdCl7dmFyIG4scj1bXSxpPWZ1bmN0aW9uKGUsdCl7dmFyIG49dih0KT90KCk6dDtyW3IubGVuZ3RoXT1lbmNvZGVVUklDb21wb25lbnQoZSkrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KG51bGw9PW4/XCJcIjpuKX07aWYobnVsbD09ZSlyZXR1cm5cIlwiO2lmKEFycmF5LmlzQXJyYXkoZSl8fGUuanF1ZXJ5JiYhY2UuaXNQbGFpbk9iamVjdChlKSljZS5lYWNoKGUsZnVuY3Rpb24oKXtpKHRoaXMubmFtZSx0aGlzLnZhbHVlKX0pO2Vsc2UgZm9yKG4gaW4gZSlQdChuLGVbbl0sdCxpKTtyZXR1cm4gci5qb2luKFwiJlwiKX0sY2UuZm4uZXh0ZW5kKHtzZXJpYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gY2UucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKX0sc2VyaWFsaXplQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXt2YXIgZT1jZS5wcm9wKHRoaXMsXCJlbGVtZW50c1wiKTtyZXR1cm4gZT9jZS5tYWtlQXJyYXkoZSk6dGhpc30pLmZpbHRlcihmdW5jdGlvbigpe3ZhciBlPXRoaXMudHlwZTtyZXR1cm4gdGhpcy5uYW1lJiYhY2UodGhpcykuaXMoXCI6ZGlzYWJsZWRcIikmJk90LnRlc3QodGhpcy5ub2RlTmFtZSkmJiFIdC50ZXN0KGUpJiYodGhpcy5jaGVja2VkfHwhd2UudGVzdChlKSl9KS5tYXAoZnVuY3Rpb24oZSx0KXt2YXIgbj1jZSh0aGlzKS52YWwoKTtyZXR1cm4gbnVsbD09bj9udWxsOkFycmF5LmlzQXJyYXkobik/Y2UubWFwKG4sZnVuY3Rpb24oZSl7cmV0dXJue25hbWU6dC5uYW1lLHZhbHVlOmUucmVwbGFjZShMdCxcIlxcclxcblwiKX19KTp7bmFtZTp0Lm5hbWUsdmFsdWU6bi5yZXBsYWNlKEx0LFwiXFxyXFxuXCIpfX0pLmdldCgpfX0pO3ZhciBNdD0vJTIwL2csUnQ9LyMuKiQvLEl0PS8oWz8mXSlfPVteJl0qLyxXdD0vXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL2dtLEZ0PS9eKD86R0VUfEhFQUQpJC8sJHQ9L15cXC9cXC8vLEJ0PXt9LF90PXt9LHp0PVwiKi9cIi5jb25jYXQoXCIqXCIpLFh0PUMuY3JlYXRlRWxlbWVudChcImFcIik7ZnVuY3Rpb24gVXQobyl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7XCJzdHJpbmdcIiE9dHlwZW9mIGUmJih0PWUsZT1cIipcIik7dmFyIG4scj0wLGk9ZS50b0xvd2VyQ2FzZSgpLm1hdGNoKEQpfHxbXTtpZih2KHQpKXdoaWxlKG49aVtyKytdKVwiK1wiPT09blswXT8obj1uLnNsaWNlKDEpfHxcIipcIiwob1tuXT1vW25dfHxbXSkudW5zaGlmdCh0KSk6KG9bbl09b1tuXXx8W10pLnB1c2godCl9fWZ1bmN0aW9uIFZ0KHQsaSxvLGEpe3ZhciBzPXt9LHU9dD09PV90O2Z1bmN0aW9uIGwoZSl7dmFyIHI7cmV0dXJuIHNbZV09ITAsY2UuZWFjaCh0W2VdfHxbXSxmdW5jdGlvbihlLHQpe3ZhciBuPXQoaSxvLGEpO3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBufHx1fHxzW25dP3U/IShyPW4pOnZvaWQgMDooaS5kYXRhVHlwZXMudW5zaGlmdChuKSxsKG4pLCExKX0pLHJ9cmV0dXJuIGwoaS5kYXRhVHlwZXNbMF0pfHwhc1tcIipcIl0mJmwoXCIqXCIpfWZ1bmN0aW9uIEd0KGUsdCl7dmFyIG4scixpPWNlLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9uc3x8e307Zm9yKG4gaW4gdCl2b2lkIDAhPT10W25dJiYoKGlbbl0/ZTpyfHwocj17fSkpW25dPXRbbl0pO3JldHVybiByJiZjZS5leHRlbmQoITAsZSxyKSxlfVh0LmhyZWY9RXQuaHJlZixjZS5leHRlbmQoe2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9LGFqYXhTZXR0aW5nczp7dXJsOkV0LmhyZWYsdHlwZTpcIkdFVFwiLGlzTG9jYWw6L14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8udGVzdChFdC5wcm90b2NvbCksZ2xvYmFsOiEwLHByb2Nlc3NEYXRhOiEwLGFzeW5jOiEwLGNvbnRlbnRUeXBlOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsYWNjZXB0czp7XCIqXCI6enQsdGV4dDpcInRleHQvcGxhaW5cIixodG1sOlwidGV4dC9odG1sXCIseG1sOlwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLGpzb246XCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIn0sY29udGVudHM6e3htbDovXFxieG1sXFxiLyxodG1sOi9cXGJodG1sLyxqc29uOi9cXGJqc29uXFxiL30scmVzcG9uc2VGaWVsZHM6e3htbDpcInJlc3BvbnNlWE1MXCIsdGV4dDpcInJlc3BvbnNlVGV4dFwiLGpzb246XCJyZXNwb25zZUpTT05cIn0sY29udmVydGVyczp7XCIqIHRleHRcIjpTdHJpbmcsXCJ0ZXh0IGh0bWxcIjohMCxcInRleHQganNvblwiOkpTT04ucGFyc2UsXCJ0ZXh0IHhtbFwiOmNlLnBhcnNlWE1MfSxmbGF0T3B0aW9uczp7dXJsOiEwLGNvbnRleHQ6ITB9fSxhamF4U2V0dXA6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD9HdChHdChlLGNlLmFqYXhTZXR0aW5ncyksdCk6R3QoY2UuYWpheFNldHRpbmdzLGUpfSxhamF4UHJlZmlsdGVyOlV0KEJ0KSxhamF4VHJhbnNwb3J0OlV0KF90KSxhamF4OmZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGUmJih0PWUsZT12b2lkIDApLHQ9dHx8e307dmFyIGMsZixwLG4sZCxyLGgsZyxpLG8sdj1jZS5hamF4U2V0dXAoe30sdCkseT12LmNvbnRleHR8fHYsbT12LmNvbnRleHQmJih5Lm5vZGVUeXBlfHx5LmpxdWVyeSk/Y2UoeSk6Y2UuZXZlbnQseD1jZS5EZWZlcnJlZCgpLGI9Y2UuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksdz12LnN0YXR1c0NvZGV8fHt9LGE9e30scz17fSx1PVwiY2FuY2VsZWRcIixUPXtyZWFkeVN0YXRlOjAsZ2V0UmVzcG9uc2VIZWFkZXI6ZnVuY3Rpb24oZSl7dmFyIHQ7aWYoaCl7aWYoIW4pe249e307d2hpbGUodD1XdC5leGVjKHApKW5bdFsxXS50b0xvd2VyQ2FzZSgpK1wiIFwiXT0oblt0WzFdLnRvTG93ZXJDYXNlKCkrXCIgXCJdfHxbXSkuY29uY2F0KHRbMl0pfXQ9bltlLnRvTG93ZXJDYXNlKCkrXCIgXCJdfXJldHVybiBudWxsPT10P251bGw6dC5qb2luKFwiLCBcIil9LGdldEFsbFJlc3BvbnNlSGVhZGVyczpmdW5jdGlvbigpe3JldHVybiBoP3A6bnVsbH0sc2V0UmVxdWVzdEhlYWRlcjpmdW5jdGlvbihlLHQpe3JldHVybiBudWxsPT1oJiYoZT1zW2UudG9Mb3dlckNhc2UoKV09c1tlLnRvTG93ZXJDYXNlKCldfHxlLGFbZV09dCksdGhpc30sb3ZlcnJpZGVNaW1lVHlwZTpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09aCYmKHYubWltZVR5cGU9ZSksdGhpc30sc3RhdHVzQ29kZTpmdW5jdGlvbihlKXt2YXIgdDtpZihlKWlmKGgpVC5hbHdheXMoZVtULnN0YXR1c10pO2Vsc2UgZm9yKHQgaW4gZSl3W3RdPVt3W3RdLGVbdF1dO3JldHVybiB0aGlzfSxhYm9ydDpmdW5jdGlvbihlKXt2YXIgdD1lfHx1O3JldHVybiBjJiZjLmFib3J0KHQpLGwoMCx0KSx0aGlzfX07aWYoeC5wcm9taXNlKFQpLHYudXJsPSgoZXx8di51cmx8fEV0LmhyZWYpK1wiXCIpLnJlcGxhY2UoJHQsRXQucHJvdG9jb2wrXCIvL1wiKSx2LnR5cGU9dC5tZXRob2R8fHQudHlwZXx8di5tZXRob2R8fHYudHlwZSx2LmRhdGFUeXBlcz0odi5kYXRhVHlwZXx8XCIqXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2goRCl8fFtcIlwiXSxudWxsPT12LmNyb3NzRG9tYWluKXtyPUMuY3JlYXRlRWxlbWVudChcImFcIik7dHJ5e3IuaHJlZj12LnVybCxyLmhyZWY9ci5ocmVmLHYuY3Jvc3NEb21haW49WHQucHJvdG9jb2wrXCIvL1wiK1h0Lmhvc3QhPXIucHJvdG9jb2wrXCIvL1wiK3IuaG9zdH1jYXRjaChlKXt2LmNyb3NzRG9tYWluPSEwfX1pZih2LmRhdGEmJnYucHJvY2Vzc0RhdGEmJlwic3RyaW5nXCIhPXR5cGVvZiB2LmRhdGEmJih2LmRhdGE9Y2UucGFyYW0odi5kYXRhLHYudHJhZGl0aW9uYWwpKSxWdChCdCx2LHQsVCksaClyZXR1cm4gVDtmb3IoaSBpbihnPWNlLmV2ZW50JiZ2Lmdsb2JhbCkmJjA9PWNlLmFjdGl2ZSsrJiZjZS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLHYudHlwZT12LnR5cGUudG9VcHBlckNhc2UoKSx2Lmhhc0NvbnRlbnQ9IUZ0LnRlc3Qodi50eXBlKSxmPXYudXJsLnJlcGxhY2UoUnQsXCJcIiksdi5oYXNDb250ZW50P3YuZGF0YSYmdi5wcm9jZXNzRGF0YSYmMD09PSh2LmNvbnRlbnRUeXBlfHxcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpJiYodi5kYXRhPXYuZGF0YS5yZXBsYWNlKE10LFwiK1wiKSk6KG89di51cmwuc2xpY2UoZi5sZW5ndGgpLHYuZGF0YSYmKHYucHJvY2Vzc0RhdGF8fFwic3RyaW5nXCI9PXR5cGVvZiB2LmRhdGEpJiYoZis9KEF0LnRlc3QoZik/XCImXCI6XCI/XCIpK3YuZGF0YSxkZWxldGUgdi5kYXRhKSwhMT09PXYuY2FjaGUmJihmPWYucmVwbGFjZShJdCxcIiQxXCIpLG89KEF0LnRlc3QoZik/XCImXCI6XCI/XCIpK1wiXz1cIitqdC5ndWlkKysrbyksdi51cmw9ZitvKSx2LmlmTW9kaWZpZWQmJihjZS5sYXN0TW9kaWZpZWRbZl0mJlQuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsY2UubGFzdE1vZGlmaWVkW2ZdKSxjZS5ldGFnW2ZdJiZULnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Ob25lLU1hdGNoXCIsY2UuZXRhZ1tmXSkpLCh2LmRhdGEmJnYuaGFzQ29udGVudCYmITEhPT12LmNvbnRlbnRUeXBlfHx0LmNvbnRlbnRUeXBlKSYmVC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsdi5jb250ZW50VHlwZSksVC5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsdi5kYXRhVHlwZXNbMF0mJnYuYWNjZXB0c1t2LmRhdGFUeXBlc1swXV0/di5hY2NlcHRzW3YuZGF0YVR5cGVzWzBdXSsoXCIqXCIhPT12LmRhdGFUeXBlc1swXT9cIiwgXCIrenQrXCI7IHE9MC4wMVwiOlwiXCIpOnYuYWNjZXB0c1tcIipcIl0pLHYuaGVhZGVycylULnNldFJlcXVlc3RIZWFkZXIoaSx2LmhlYWRlcnNbaV0pO2lmKHYuYmVmb3JlU2VuZCYmKCExPT09di5iZWZvcmVTZW5kLmNhbGwoeSxULHYpfHxoKSlyZXR1cm4gVC5hYm9ydCgpO2lmKHU9XCJhYm9ydFwiLGIuYWRkKHYuY29tcGxldGUpLFQuZG9uZSh2LnN1Y2Nlc3MpLFQuZmFpbCh2LmVycm9yKSxjPVZ0KF90LHYsdCxUKSl7aWYoVC5yZWFkeVN0YXRlPTEsZyYmbS50cmlnZ2VyKFwiYWpheFNlbmRcIixbVCx2XSksaClyZXR1cm4gVDt2LmFzeW5jJiYwPHYudGltZW91dCYmKGQ9aWUuc2V0VGltZW91dChmdW5jdGlvbigpe1QuYWJvcnQoXCJ0aW1lb3V0XCIpfSx2LnRpbWVvdXQpKTt0cnl7aD0hMSxjLnNlbmQoYSxsKX1jYXRjaChlKXtpZihoKXRocm93IGU7bCgtMSxlKX19ZWxzZSBsKC0xLFwiTm8gVHJhbnNwb3J0XCIpO2Z1bmN0aW9uIGwoZSx0LG4scil7dmFyIGksbyxhLHMsdSxsPXQ7aHx8KGg9ITAsZCYmaWUuY2xlYXJUaW1lb3V0KGQpLGM9dm9pZCAwLHA9cnx8XCJcIixULnJlYWR5U3RhdGU9MDxlPzQ6MCxpPTIwMDw9ZSYmZTwzMDB8fDMwND09PWUsbiYmKHM9ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhLHM9ZS5jb250ZW50cyx1PWUuZGF0YVR5cGVzO3doaWxlKFwiKlwiPT09dVswXSl1LnNoaWZ0KCksdm9pZCAwPT09ciYmKHI9ZS5taW1lVHlwZXx8dC5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSk7aWYocilmb3IoaSBpbiBzKWlmKHNbaV0mJnNbaV0udGVzdChyKSl7dS51bnNoaWZ0KGkpO2JyZWFrfWlmKHVbMF1pbiBuKW89dVswXTtlbHNle2ZvcihpIGluIG4pe2lmKCF1WzBdfHxlLmNvbnZlcnRlcnNbaStcIiBcIit1WzBdXSl7bz1pO2JyZWFrfWF8fChhPWkpfW89b3x8YX1pZihvKXJldHVybiBvIT09dVswXSYmdS51bnNoaWZ0KG8pLG5bb119KHYsVCxuKSksIWkmJi0xPGNlLmluQXJyYXkoXCJzY3JpcHRcIix2LmRhdGFUeXBlcykmJmNlLmluQXJyYXkoXCJqc29uXCIsdi5kYXRhVHlwZXMpPDAmJih2LmNvbnZlcnRlcnNbXCJ0ZXh0IHNjcmlwdFwiXT1mdW5jdGlvbigpe30pLHM9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHMsdSxsPXt9LGM9ZS5kYXRhVHlwZXMuc2xpY2UoKTtpZihjWzFdKWZvcihhIGluIGUuY29udmVydGVycylsW2EudG9Mb3dlckNhc2UoKV09ZS5jb252ZXJ0ZXJzW2FdO289Yy5zaGlmdCgpO3doaWxlKG8paWYoZS5yZXNwb25zZUZpZWxkc1tvXSYmKG5bZS5yZXNwb25zZUZpZWxkc1tvXV09dCksIXUmJnImJmUuZGF0YUZpbHRlciYmKHQ9ZS5kYXRhRmlsdGVyKHQsZS5kYXRhVHlwZSkpLHU9byxvPWMuc2hpZnQoKSlpZihcIipcIj09PW8pbz11O2Vsc2UgaWYoXCIqXCIhPT11JiZ1IT09byl7aWYoIShhPWxbdStcIiBcIitvXXx8bFtcIiogXCIrb10pKWZvcihpIGluIGwpaWYoKHM9aS5zcGxpdChcIiBcIikpWzFdPT09byYmKGE9bFt1K1wiIFwiK3NbMF1dfHxsW1wiKiBcIitzWzBdXSkpeyEwPT09YT9hPWxbaV06ITAhPT1sW2ldJiYobz1zWzBdLGMudW5zaGlmdChzWzFdKSk7YnJlYWt9aWYoITAhPT1hKWlmKGEmJmVbXCJ0aHJvd3NcIl0pdD1hKHQpO2Vsc2UgdHJ5e3Q9YSh0KX1jYXRjaChlKXtyZXR1cm57c3RhdGU6XCJwYXJzZXJlcnJvclwiLGVycm9yOmE/ZTpcIk5vIGNvbnZlcnNpb24gZnJvbSBcIit1K1wiIHRvIFwiK299fX1yZXR1cm57c3RhdGU6XCJzdWNjZXNzXCIsZGF0YTp0fX0odixzLFQsaSksaT8odi5pZk1vZGlmaWVkJiYoKHU9VC5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIikpJiYoY2UubGFzdE1vZGlmaWVkW2ZdPXUpLCh1PVQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpKSYmKGNlLmV0YWdbZl09dSkpLDIwND09PWV8fFwiSEVBRFwiPT09di50eXBlP2w9XCJub2NvbnRlbnRcIjozMDQ9PT1lP2w9XCJub3Rtb2RpZmllZFwiOihsPXMuc3RhdGUsbz1zLmRhdGEsaT0hKGE9cy5lcnJvcikpKTooYT1sLCFlJiZsfHwobD1cImVycm9yXCIsZTwwJiYoZT0wKSkpLFQuc3RhdHVzPWUsVC5zdGF0dXNUZXh0PSh0fHxsKStcIlwiLGk/eC5yZXNvbHZlV2l0aCh5LFtvLGwsVF0pOngucmVqZWN0V2l0aCh5LFtULGwsYV0pLFQuc3RhdHVzQ29kZSh3KSx3PXZvaWQgMCxnJiZtLnRyaWdnZXIoaT9cImFqYXhTdWNjZXNzXCI6XCJhamF4RXJyb3JcIixbVCx2LGk/bzphXSksYi5maXJlV2l0aCh5LFtULGxdKSxnJiYobS50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsW1Qsdl0pLC0tY2UuYWN0aXZlfHxjZS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIikpKX1yZXR1cm4gVH0sZ2V0SlNPTjpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGNlLmdldChlLHQsbixcImpzb25cIil9LGdldFNjcmlwdDpmdW5jdGlvbihlLHQpe3JldHVybiBjZS5nZXQoZSx2b2lkIDAsdCxcInNjcmlwdFwiKX19KSxjZS5lYWNoKFtcImdldFwiLFwicG9zdFwiXSxmdW5jdGlvbihlLGkpe2NlW2ldPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB2KHQpJiYocj1yfHxuLG49dCx0PXZvaWQgMCksY2UuYWpheChjZS5leHRlbmQoe3VybDplLHR5cGU6aSxkYXRhVHlwZTpyLGRhdGE6dCxzdWNjZXNzOm59LGNlLmlzUGxhaW5PYmplY3QoZSkmJmUpKX19KSxjZS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uKGUpe3ZhciB0O2Zvcih0IGluIGUuaGVhZGVycylcImNvbnRlbnQtdHlwZVwiPT09dC50b0xvd2VyQ2FzZSgpJiYoZS5jb250ZW50VHlwZT1lLmhlYWRlcnNbdF18fFwiXCIpfSksY2UuX2V2YWxVcmw9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBjZS5hamF4KHt1cmw6ZSx0eXBlOlwiR0VUXCIsZGF0YVR5cGU6XCJzY3JpcHRcIixjYWNoZTohMCxhc3luYzohMSxnbG9iYWw6ITEsY29udmVydGVyczp7XCJ0ZXh0IHNjcmlwdFwiOmZ1bmN0aW9uKCl7fX0sZGF0YUZpbHRlcjpmdW5jdGlvbihlKXtjZS5nbG9iYWxFdmFsKGUsdCxuKX19KX0sY2UuZm4uZXh0ZW5kKHt3cmFwQWxsOmZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiB0aGlzWzBdJiYodihlKSYmKGU9ZS5jYWxsKHRoaXNbMF0pKSx0PWNlKGUsdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCksdGhpc1swXS5wYXJlbnROb2RlJiZ0Lmluc2VydEJlZm9yZSh0aGlzWzBdKSx0Lm1hcChmdW5jdGlvbigpe3ZhciBlPXRoaXM7d2hpbGUoZS5maXJzdEVsZW1lbnRDaGlsZCllPWUuZmlyc3RFbGVtZW50Q2hpbGQ7cmV0dXJuIGV9KS5hcHBlbmQodGhpcykpLHRoaXN9LHdyYXBJbm5lcjpmdW5jdGlvbihuKXtyZXR1cm4gdihuKT90aGlzLmVhY2goZnVuY3Rpb24oZSl7Y2UodGhpcykud3JhcElubmVyKG4uY2FsbCh0aGlzLGUpKX0pOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlPWNlKHRoaXMpLHQ9ZS5jb250ZW50cygpO3QubGVuZ3RoP3Qud3JhcEFsbChuKTplLmFwcGVuZChuKX0pfSx3cmFwOmZ1bmN0aW9uKHQpe3ZhciBuPXYodCk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihlKXtjZSh0aGlzKS53cmFwQWxsKG4/dC5jYWxsKHRoaXMsZSk6dCl9KX0sdW53cmFwOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnBhcmVudChlKS5ub3QoXCJib2R5XCIpLmVhY2goZnVuY3Rpb24oKXtjZSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpfSksdGhpc319KSxjZS5leHByLnBzZXVkb3MuaGlkZGVuPWZ1bmN0aW9uKGUpe3JldHVybiFjZS5leHByLnBzZXVkb3MudmlzaWJsZShlKX0sY2UuZXhwci5wc2V1ZG9zLnZpc2libGU9ZnVuY3Rpb24oZSl7cmV0dXJuISEoZS5vZmZzZXRXaWR0aHx8ZS5vZmZzZXRIZWlnaHR8fGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpfSxjZS5hamF4U2V0dGluZ3MueGhyPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBuZXcgaWUuWE1MSHR0cFJlcXVlc3R9Y2F0Y2goZSl7fX07dmFyIFl0PXswOjIwMCwxMjIzOjIwNH0sUXQ9Y2UuYWpheFNldHRpbmdzLnhocigpO2xlLmNvcnM9ISFRdCYmXCJ3aXRoQ3JlZGVudGlhbHNcImluIFF0LGxlLmFqYXg9UXQ9ISFRdCxjZS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKGkpe3ZhciBvLGE7aWYobGUuY29yc3x8UXQmJiFpLmNyb3NzRG9tYWluKXJldHVybntzZW5kOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj1pLnhocigpO2lmKHIub3BlbihpLnR5cGUsaS51cmwsaS5hc3luYyxpLnVzZXJuYW1lLGkucGFzc3dvcmQpLGkueGhyRmllbGRzKWZvcihuIGluIGkueGhyRmllbGRzKXJbbl09aS54aHJGaWVsZHNbbl07Zm9yKG4gaW4gaS5taW1lVHlwZSYmci5vdmVycmlkZU1pbWVUeXBlJiZyLm92ZXJyaWRlTWltZVR5cGUoaS5taW1lVHlwZSksaS5jcm9zc0RvbWFpbnx8ZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl18fChlW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXT1cIlhNTEh0dHBSZXF1ZXN0XCIpLGUpci5zZXRSZXF1ZXN0SGVhZGVyKG4sZVtuXSk7bz1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtvJiYobz1hPXIub25sb2FkPXIub25lcnJvcj1yLm9uYWJvcnQ9ci5vbnRpbWVvdXQ9ci5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxcImFib3J0XCI9PT1lP3IuYWJvcnQoKTpcImVycm9yXCI9PT1lP1wibnVtYmVyXCIhPXR5cGVvZiByLnN0YXR1cz90KDAsXCJlcnJvclwiKTp0KHIuc3RhdHVzLHIuc3RhdHVzVGV4dCk6dChZdFtyLnN0YXR1c118fHIuc3RhdHVzLHIuc3RhdHVzVGV4dCxcInRleHRcIiE9PShyLnJlc3BvbnNlVHlwZXx8XCJ0ZXh0XCIpfHxcInN0cmluZ1wiIT10eXBlb2Ygci5yZXNwb25zZVRleHQ/e2JpbmFyeTpyLnJlc3BvbnNlfTp7dGV4dDpyLnJlc3BvbnNlVGV4dH0sci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpfX0sci5vbmxvYWQ9bygpLGE9ci5vbmVycm9yPXIub250aW1lb3V0PW8oXCJlcnJvclwiKSx2b2lkIDAhPT1yLm9uYWJvcnQ/ci5vbmFib3J0PWE6ci5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXs0PT09ci5yZWFkeVN0YXRlJiZpZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7byYmYSgpfSl9LG89byhcImFib3J0XCIpO3RyeXtyLnNlbmQoaS5oYXNDb250ZW50JiZpLmRhdGF8fG51bGwpfWNhdGNoKGUpe2lmKG8pdGhyb3cgZX19LGFib3J0OmZ1bmN0aW9uKCl7byYmbygpfX19KSxjZS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uKGUpe2UuY3Jvc3NEb21haW4mJihlLmNvbnRlbnRzLnNjcmlwdD0hMSl9KSxjZS5hamF4U2V0dXAoe2FjY2VwdHM6e3NjcmlwdDpcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJ9LGNvbnRlbnRzOntzY3JpcHQ6L1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvfSxjb252ZXJ0ZXJzOntcInRleHQgc2NyaXB0XCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGNlLmdsb2JhbEV2YWwoZSksZX19fSksY2UuYWpheFByZWZpbHRlcihcInNjcmlwdFwiLGZ1bmN0aW9uKGUpe3ZvaWQgMD09PWUuY2FjaGUmJihlLmNhY2hlPSExKSxlLmNyb3NzRG9tYWluJiYoZS50eXBlPVwiR0VUXCIpfSksY2UuYWpheFRyYW5zcG9ydChcInNjcmlwdFwiLGZ1bmN0aW9uKG4pe3ZhciByLGk7aWYobi5jcm9zc0RvbWFpbnx8bi5zY3JpcHRBdHRycylyZXR1cm57c2VuZDpmdW5jdGlvbihlLHQpe3I9Y2UoXCI8c2NyaXB0PlwiKS5hdHRyKG4uc2NyaXB0QXR0cnN8fHt9KS5wcm9wKHtjaGFyc2V0Om4uc2NyaXB0Q2hhcnNldCxzcmM6bi51cmx9KS5vbihcImxvYWQgZXJyb3JcIixpPWZ1bmN0aW9uKGUpe3IucmVtb3ZlKCksaT1udWxsLGUmJnQoXCJlcnJvclwiPT09ZS50eXBlPzQwNDoyMDAsZS50eXBlKX0pLEMuaGVhZC5hcHBlbmRDaGlsZChyWzBdKX0sYWJvcnQ6ZnVuY3Rpb24oKXtpJiZpKCl9fX0pO3ZhciBKdCxLdD1bXSxadD0vKD0pXFw/KD89JnwkKXxcXD9cXD8vO2NlLmFqYXhTZXR1cCh7anNvbnA6XCJjYWxsYmFja1wiLGpzb25wQ2FsbGJhY2s6ZnVuY3Rpb24oKXt2YXIgZT1LdC5wb3AoKXx8Y2UuZXhwYW5kbytcIl9cIitqdC5ndWlkKys7cmV0dXJuIHRoaXNbZV09ITAsZX19KSxjZS5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLGZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYT0hMSE9PWUuanNvbnAmJihadC50ZXN0KGUudXJsKT9cInVybFwiOlwic3RyaW5nXCI9PXR5cGVvZiBlLmRhdGEmJjA9PT0oZS5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmWnQudGVzdChlLmRhdGEpJiZcImRhdGFcIik7aWYoYXx8XCJqc29ucFwiPT09ZS5kYXRhVHlwZXNbMF0pcmV0dXJuIHI9ZS5qc29ucENhbGxiYWNrPXYoZS5qc29ucENhbGxiYWNrKT9lLmpzb25wQ2FsbGJhY2soKTplLmpzb25wQ2FsbGJhY2ssYT9lW2FdPWVbYV0ucmVwbGFjZShadCxcIiQxXCIrcik6ITEhPT1lLmpzb25wJiYoZS51cmwrPShBdC50ZXN0KGUudXJsKT9cIiZcIjpcIj9cIikrZS5qc29ucCtcIj1cIityKSxlLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXT1mdW5jdGlvbigpe3JldHVybiBvfHxjZS5lcnJvcihyK1wiIHdhcyBub3QgY2FsbGVkXCIpLG9bMF19LGUuZGF0YVR5cGVzWzBdPVwianNvblwiLGk9aWVbcl0saWVbcl09ZnVuY3Rpb24oKXtvPWFyZ3VtZW50c30sbi5hbHdheXMoZnVuY3Rpb24oKXt2b2lkIDA9PT1pP2NlKGllKS5yZW1vdmVQcm9wKHIpOmllW3JdPWksZVtyXSYmKGUuanNvbnBDYWxsYmFjaz10Lmpzb25wQ2FsbGJhY2ssS3QucHVzaChyKSksbyYmdihpKSYmaShvWzBdKSxvPWk9dm9pZCAwfSksXCJzY3JpcHRcIn0pLGxlLmNyZWF0ZUhUTUxEb2N1bWVudD0oKEp0PUMuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpLmJvZHkpLmlubmVySFRNTD1cIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCIsMj09PUp0LmNoaWxkTm9kZXMubGVuZ3RoKSxjZS5wYXJzZUhUTUw9ZnVuY3Rpb24oZSx0LG4pe3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBlP1tdOihcImJvb2xlYW5cIj09dHlwZW9mIHQmJihuPXQsdD0hMSksdHx8KGxlLmNyZWF0ZUhUTUxEb2N1bWVudD8oKHI9KHQ9Qy5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikpLmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpKS5ocmVmPUMubG9jYXRpb24uaHJlZix0LmhlYWQuYXBwZW5kQ2hpbGQocikpOnQ9Qyksbz0hbiYmW10sKGk9dy5leGVjKGUpKT9bdC5jcmVhdGVFbGVtZW50KGlbMV0pXTooaT1BZShbZV0sdCxvKSxvJiZvLmxlbmd0aCYmY2UobykucmVtb3ZlKCksY2UubWVyZ2UoW10saS5jaGlsZE5vZGVzKSkpO3ZhciByLGksb30sY2UuZm4ubG9hZD1mdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGE9dGhpcyxzPWUuaW5kZXhPZihcIiBcIik7cmV0dXJuLTE8cyYmKHI9VHQoZS5zbGljZShzKSksZT1lLnNsaWNlKDAscykpLHYodCk/KG49dCx0PXZvaWQgMCk6dCYmXCJvYmplY3RcIj09dHlwZW9mIHQmJihpPVwiUE9TVFwiKSwwPGEubGVuZ3RoJiZjZS5hamF4KHt1cmw6ZSx0eXBlOml8fFwiR0VUXCIsZGF0YVR5cGU6XCJodG1sXCIsZGF0YTp0fSkuZG9uZShmdW5jdGlvbihlKXtvPWFyZ3VtZW50cyxhLmh0bWwocj9jZShcIjxkaXY+XCIpLmFwcGVuZChjZS5wYXJzZUhUTUwoZSkpLmZpbmQocik6ZSl9KS5hbHdheXMobiYmZnVuY3Rpb24oZSx0KXthLmVhY2goZnVuY3Rpb24oKXtuLmFwcGx5KHRoaXMsb3x8W2UucmVzcG9uc2VUZXh0LHQsZV0pfSl9KSx0aGlzfSxjZS5leHByLnBzZXVkb3MuYW5pbWF0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIGNlLmdyZXAoY2UudGltZXJzLGZ1bmN0aW9uKGUpe3JldHVybiB0PT09ZS5lbGVtfSkubGVuZ3RofSxjZS5vZmZzZXQ9e3NldE9mZnNldDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGEscyx1LGw9Y2UuY3NzKGUsXCJwb3NpdGlvblwiKSxjPWNlKGUpLGY9e307XCJzdGF0aWNcIj09PWwmJihlLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIikscz1jLm9mZnNldCgpLG89Y2UuY3NzKGUsXCJ0b3BcIiksdT1jZS5jc3MoZSxcImxlZnRcIiksKFwiYWJzb2x1dGVcIj09PWx8fFwiZml4ZWRcIj09PWwpJiYtMTwobyt1KS5pbmRleE9mKFwiYXV0b1wiKT8oYT0ocj1jLnBvc2l0aW9uKCkpLnRvcCxpPXIubGVmdCk6KGE9cGFyc2VGbG9hdChvKXx8MCxpPXBhcnNlRmxvYXQodSl8fDApLHYodCkmJih0PXQuY2FsbChlLG4sY2UuZXh0ZW5kKHt9LHMpKSksbnVsbCE9dC50b3AmJihmLnRvcD10LnRvcC1zLnRvcCthKSxudWxsIT10LmxlZnQmJihmLmxlZnQ9dC5sZWZ0LXMubGVmdCtpKSxcInVzaW5nXCJpbiB0P3QudXNpbmcuY2FsbChlLGYpOmMuY3NzKGYpfX0sY2UuZm4uZXh0ZW5kKHtvZmZzZXQ6ZnVuY3Rpb24odCl7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdm9pZCAwPT09dD90aGlzOnRoaXMuZWFjaChmdW5jdGlvbihlKXtjZS5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsdCxlKX0pO3ZhciBlLG4scj10aGlzWzBdO3JldHVybiByP3IuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg/KGU9ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxuPXIub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyx7dG9wOmUudG9wK24ucGFnZVlPZmZzZXQsbGVmdDplLmxlZnQrbi5wYWdlWE9mZnNldH0pOnt0b3A6MCxsZWZ0OjB9OnZvaWQgMH0scG9zaXRpb246ZnVuY3Rpb24oKXtpZih0aGlzWzBdKXt2YXIgZSx0LG4scj10aGlzWzBdLGk9e3RvcDowLGxlZnQ6MH07aWYoXCJmaXhlZFwiPT09Y2UuY3NzKHIsXCJwb3NpdGlvblwiKSl0PXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7ZWxzZXt0PXRoaXMub2Zmc2V0KCksbj1yLm93bmVyRG9jdW1lbnQsZT1yLm9mZnNldFBhcmVudHx8bi5kb2N1bWVudEVsZW1lbnQ7d2hpbGUoZSYmKGU9PT1uLmJvZHl8fGU9PT1uLmRvY3VtZW50RWxlbWVudCkmJlwic3RhdGljXCI9PT1jZS5jc3MoZSxcInBvc2l0aW9uXCIpKWU9ZS5wYXJlbnROb2RlO2UmJmUhPT1yJiYxPT09ZS5ub2RlVHlwZSYmKChpPWNlKGUpLm9mZnNldCgpKS50b3ArPWNlLmNzcyhlLFwiYm9yZGVyVG9wV2lkdGhcIiwhMCksaS5sZWZ0Kz1jZS5jc3MoZSxcImJvcmRlckxlZnRXaWR0aFwiLCEwKSl9cmV0dXJue3RvcDp0LnRvcC1pLnRvcC1jZS5jc3MocixcIm1hcmdpblRvcFwiLCEwKSxsZWZ0OnQubGVmdC1pLmxlZnQtY2UuY3NzKHIsXCJtYXJnaW5MZWZ0XCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBlPXRoaXMub2Zmc2V0UGFyZW50O3doaWxlKGUmJlwic3RhdGljXCI9PT1jZS5jc3MoZSxcInBvc2l0aW9uXCIpKWU9ZS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGV8fEp9KX19KSxjZS5lYWNoKHtzY3JvbGxMZWZ0OlwicGFnZVhPZmZzZXRcIixzY3JvbGxUb3A6XCJwYWdlWU9mZnNldFwifSxmdW5jdGlvbih0LGkpe3ZhciBvPVwicGFnZVlPZmZzZXRcIj09PWk7Y2UuZm5bdF09ZnVuY3Rpb24oZSl7cmV0dXJuIE0odGhpcyxmdW5jdGlvbihlLHQsbil7dmFyIHI7aWYoeShlKT9yPWU6OT09PWUubm9kZVR5cGUmJihyPWUuZGVmYXVsdFZpZXcpLHZvaWQgMD09PW4pcmV0dXJuIHI/cltpXTplW3RdO3I/ci5zY3JvbGxUbyhvP3IucGFnZVhPZmZzZXQ6bixvP246ci5wYWdlWU9mZnNldCk6ZVt0XT1ufSx0LGUsYXJndW1lbnRzLmxlbmd0aCl9fSksY2UuZWFjaChbXCJ0b3BcIixcImxlZnRcIl0sZnVuY3Rpb24oZSxuKXtjZS5jc3NIb29rc1tuXT1ZZShsZS5waXhlbFBvc2l0aW9uLGZ1bmN0aW9uKGUsdCl7aWYodClyZXR1cm4gdD1HZShlLG4pLF9lLnRlc3QodCk/Y2UoZSkucG9zaXRpb24oKVtuXStcInB4XCI6dH0pfSksY2UuZWFjaCh7SGVpZ2h0OlwiaGVpZ2h0XCIsV2lkdGg6XCJ3aWR0aFwifSxmdW5jdGlvbihhLHMpe2NlLmVhY2goe3BhZGRpbmc6XCJpbm5lclwiK2EsY29udGVudDpzLFwiXCI6XCJvdXRlclwiK2F9LGZ1bmN0aW9uKHIsbyl7Y2UuZm5bb109ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoJiYocnx8XCJib29sZWFuXCIhPXR5cGVvZiBlKSxpPXJ8fCghMD09PWV8fCEwPT09dD9cIm1hcmdpblwiOlwiYm9yZGVyXCIpO3JldHVybiBNKHRoaXMsZnVuY3Rpb24oZSx0LG4pe3ZhciByO3JldHVybiB5KGUpPzA9PT1vLmluZGV4T2YoXCJvdXRlclwiKT9lW1wiaW5uZXJcIithXTplLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiK2FdOjk9PT1lLm5vZGVUeXBlPyhyPWUuZG9jdW1lbnRFbGVtZW50LE1hdGgubWF4KGUuYm9keVtcInNjcm9sbFwiK2FdLHJbXCJzY3JvbGxcIithXSxlLmJvZHlbXCJvZmZzZXRcIithXSxyW1wib2Zmc2V0XCIrYV0scltcImNsaWVudFwiK2FdKSk6dm9pZCAwPT09bj9jZS5jc3MoZSx0LGkpOmNlLnN0eWxlKGUsdCxuLGkpfSxzLG4/ZTp2b2lkIDAsbil9fSl9KSxjZS5lYWNoKFtcImFqYXhTdGFydFwiLFwiYWpheFN0b3BcIixcImFqYXhDb21wbGV0ZVwiLFwiYWpheEVycm9yXCIsXCJhamF4U3VjY2Vzc1wiLFwiYWpheFNlbmRcIl0sZnVuY3Rpb24oZSx0KXtjZS5mblt0XT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5vbih0LGUpfX0pLGNlLmZuLmV4dGVuZCh7YmluZDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMub24oZSxudWxsLHQsbil9LHVuYmluZDpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm9mZihlLG51bGwsdCl9LGRlbGVnYXRlOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLm9uKHQsZSxuLHIpfSx1bmRlbGVnYXRlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5vZmYoZSxcIioqXCIpOnRoaXMub2ZmKHQsZXx8XCIqKlwiLG4pfSxob3ZlcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm9uKFwibW91c2VlbnRlclwiLGUpLm9uKFwibW91c2VsZWF2ZVwiLHR8fGUpfX0pLGNlLmVhY2goXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGUsbil7Y2UuZm5bbl09ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMDxhcmd1bWVudHMubGVuZ3RoP3RoaXMub24obixudWxsLGUsdCk6dGhpcy50cmlnZ2VyKG4pfX0pO3ZhciBlbj0vXltcXHNcXHVGRUZGXFx4QTBdK3woW15cXHNcXHVGRUZGXFx4QTBdKVtcXHNcXHVGRUZGXFx4QTBdKyQvZztjZS5wcm94eT1mdW5jdGlvbihlLHQpe3ZhciBuLHIsaTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCYmKG49ZVt0XSx0PWUsZT1uKSx2KGUpKXJldHVybiByPWFlLmNhbGwoYXJndW1lbnRzLDIpLChpPWZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkodHx8dGhpcyxyLmNvbmNhdChhZS5jYWxsKGFyZ3VtZW50cykpKX0pLmd1aWQ9ZS5ndWlkPWUuZ3VpZHx8Y2UuZ3VpZCsrLGl9LGNlLmhvbGRSZWFkeT1mdW5jdGlvbihlKXtlP2NlLnJlYWR5V2FpdCsrOmNlLnJlYWR5KCEwKX0sY2UuaXNBcnJheT1BcnJheS5pc0FycmF5LGNlLnBhcnNlSlNPTj1KU09OLnBhcnNlLGNlLm5vZGVOYW1lPWZlLGNlLmlzRnVuY3Rpb249dixjZS5pc1dpbmRvdz15LGNlLmNhbWVsQ2FzZT1GLGNlLnR5cGU9eCxjZS5ub3c9RGF0ZS5ub3csY2UuaXNOdW1lcmljPWZ1bmN0aW9uKGUpe3ZhciB0PWNlLnR5cGUoZSk7cmV0dXJuKFwibnVtYmVyXCI9PT10fHxcInN0cmluZ1wiPT09dCkmJiFpc05hTihlLXBhcnNlRmxvYXQoZSkpfSxjZS50cmltPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP1wiXCI6KGUrXCJcIikucmVwbGFjZShlbixcIiQxXCIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQmJmRlZmluZShcImpxdWVyeVwiLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIGNlfSk7dmFyIHRuPWllLmpRdWVyeSxubj1pZS4kO3JldHVybiBjZS5ub0NvbmZsaWN0PWZ1bmN0aW9uKGUpe3JldHVybiBpZS4kPT09Y2UmJihpZS4kPW5uKSxlJiZpZS5qUXVlcnk9PT1jZSYmKGllLmpRdWVyeT10biksY2V9LFwidW5kZWZpbmVkXCI9PXR5cGVvZiBlJiYoaWUualF1ZXJ5PWllLiQ9Y2UpLGNlfSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXksIGF0U3RhcnQsIGd1YXJhbnRlZSkge1xuICB2YXIgdGltZW91dDtcbiAgdmFyIGFyZ3M7XG4gIHZhciBzZWxmO1xuXG4gIHJldHVybiBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgc2VsZiA9IHRoaXM7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGltZW91dCAmJiAoYXRTdGFydCB8fCBndWFyYW50ZWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICghYXRTdGFydCkge1xuICAgICAgY2xlYXIoKTtcblxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocnVuLCBkZWxheSk7XG4gICAgICByZXR1cm4gdGltZW91dDtcbiAgICB9XG5cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhciwgZGVsYXkpO1xuICAgIGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgY2xlYXIoKTtcbiAgICAgIGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjcuMCA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVJbnRlcnBvbGF0ZTtcbiIsIi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbnZhciByZUludGVycG9sYXRlID0gcmVxdWlyZSgnbG9kYXNoLl9yZWludGVycG9sYXRlJyksXG4gICAgdGVtcGxhdGVTZXR0aW5ncyA9IHJlcXVpcmUoJ2xvZGFzaC50ZW1wbGF0ZXNldHRpbmdzJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xudmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2hcbiAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gKi9cbnZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4vKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAnXFxcXCc6ICdcXFxcJyxcbiAgXCInXCI6IFwiJ1wiLFxuICAnXFxuJzogJ24nLFxuICAnXFxyJzogJ3InLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRXaXRoXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbldpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAqIH1cbiAqXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gKlxuICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gKlxuICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J3RlbXBsYXRlU291cmNlc1tuXSddXG4gKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICpcbiAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICpcbiAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gKlxuICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gKlxuICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAqIGNvbXBpbGVkKGRhdGEpO1xuICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAqXG4gKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAqIGNvbXBpbGVkLnNvdXJjZTtcbiAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAqIC8vICAgcmV0dXJuIF9fcDtcbiAqIC8vIH1cbiAqXG4gKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAqICAgdmFyIEpTVCA9IHtcXFxuICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gKiAgIH07XFxcbiAqICcpO1xuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgdmFyIHNldHRpbmdzID0gdGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzLl8udGVtcGxhdGVTZXR0aW5ncyB8fCB0ZW1wbGF0ZVNldHRpbmdzO1xuXG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gIHZhciBpc0VzY2FwaW5nLFxuICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgLCAnZycpO1xuXG4gIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAvLyB3aXRoIGxvb2t1cCAoaW4gY2FzZSBvZiBlLmcuIHByb3RvdHlwZSBwb2xsdXRpb24pLCBhbmQgc3RyaXAgbmV3bGluZXMgaWYgYW55LlxuICAvLyBBIG5ld2xpbmUgd291bGRuJ3QgYmUgYSB2YWxpZCBzb3VyY2VVUkwgYW55d2F5LCBhbmQgaXQnZCBlbmFibGUgY29kZSBpbmplY3Rpb24uXG4gIHZhciBzb3VyY2VVUkwgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgID8gKCcvLyMgc291cmNlVVJMPScgK1xuICAgICAgIChvcHRpb25zLnNvdXJjZVVSTCArICcnKS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnICcpICtcbiAgICAgICAnXFxuJylcbiAgICA6ICcnO1xuXG4gIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgIH1cbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcblxuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAvLyBMaWtlIHdpdGggc291cmNlVVJMLCB3ZSB0YWtlIGNhcmUgdG8gbm90IGNoZWNrIHRoZSBvcHRpb24ncyBwcm90b3R5cGUsXG4gIC8vIGFzIHRoaXMgY29uZmlndXJhdGlvbiBpcyBhIGNvZGUgaW5qZWN0aW9uIHZlY3Rvci5cbiAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gIH1cbiAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAodmFyaWFibGVcbiAgICAgID8gJydcbiAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICApICtcbiAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgIChpc0VzY2FwaW5nXG4gICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICA6ICcnXG4gICAgKSArXG4gICAgKGlzRXZhbHVhdGluZ1xuICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgOiAnO1xcbidcbiAgICApICtcbiAgICBzb3VyY2UgK1xuICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgfSk7XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG4iLCIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG52YXIgcmVJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fcmVpbnRlcnBvbGF0ZScpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xudmFyIGh0bWxFc2NhcGVzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgJ2ltcG9ydHMnOiB7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgJ18nOiB7ICdlc2NhcGUnOiBlc2NhcGUgfVxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlU2V0dGluZ3M7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5T2Y7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVmFsdWVzO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDdG9yKEN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWZ1bmN0aW9uLW9iamVjdHMtY2FsbC10aGlzYXJndW1lbnQtYXJndW1lbnRzbGlzdFxuICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICB9XG4gICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ3RvcjtcbiIsInZhciBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVGaW5kO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKSxcbiAgICBjcmVhdGVDdG9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQ3RvcicpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVQYXJ0aWFsO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21EZWZhdWx0c0Fzc2lnbkluO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBiYXNlUHJvcGVydHlPZiA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eU9mJyk7XG5cbi8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG52YXIgaHRtbEVzY2FwZXMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xudmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZUh0bWxDaGFyO1xuIiwiLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gIFwiJ1wiOiBcIidcIixcbiAgJ1xcbic6ICduJyxcbiAgJ1xccic6ICdyJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVN0cmluZ0NoYXI7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2c7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVFc2NhcGU7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlRXZhbHVhdGU7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxubW9kdWxlLmV4cG9ydHMgPSByZUludGVycG9sYXRlO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGV4dGVuZFdpdGhcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICogfVxuICpcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAqXG4gKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbkluV2l0aDtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5JyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzRXJyb3IgPSByZXF1aXJlKCcuL2lzRXJyb3InKTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXR0ZW1wdDtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgY3JlYXRlV3JhcCA9IHJlcXVpcmUoJy4vX2NyZWF0ZVdyYXAnKSxcbiAgICBnZXRIb2xkZXIgPSByZXF1aXJlKCcuL19nZXRIb2xkZXInKSxcbiAgICByZXBsYWNlSG9sZGVycyA9IHJlcXVpcmUoJy4vX3JlcGxhY2VIb2xkZXJzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICogYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gKlxuICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgLCB0aGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICogfVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICogYm91bmQoJyEnKTtcbiAqIC8vID0+ICdoaSBmcmVkISdcbiAqXG4gKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICogYm91bmQoJ2hpJyk7XG4gKiAvLyA9PiAnaGkgZnJlZCEnXG4gKi9cbnZhciBiaW5kID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kKSk7XG4gICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgfVxuICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG59KTtcblxuLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuYmluZC5wbGFjZWhvbGRlciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQ7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgbm93ID0gcmVxdWlyZSgnLi9ub3cnKSxcbiAgICB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZ1xuICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgOiB0aW1lV2FpdGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBlc2NhcGVIdG1sQ2hhciA9IHJlcXVpcmUoJy4vX2VzY2FwZUh0bWxDaGFyJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbnZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAqXG4gKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAqIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlO1xuIiwidmFyIGNyZWF0ZUZpbmQgPSByZXF1aXJlKCcuL19jcmVhdGVGaW5kJyksXG4gICAgZmluZEluZGV4ID0gcmVxdWlyZSgnLi9maW5kSW5kZXgnKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKi9cbnZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmQ7XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRJbmRleDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Vycm9yO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwidmFyIGFzc2lnbkluV2l0aCA9IHJlcXVpcmUoJy4vYXNzaWduSW5XaXRoJyksXG4gICAgYXR0ZW1wdCA9IHJlcXVpcmUoJy4vYXR0ZW1wdCcpLFxuICAgIGJhc2VWYWx1ZXMgPSByZXF1aXJlKCcuL19iYXNlVmFsdWVzJyksXG4gICAgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2N1c3RvbURlZmF1bHRzQXNzaWduSW4nKSxcbiAgICBlc2NhcGVTdHJpbmdDaGFyID0gcmVxdWlyZSgnLi9fZXNjYXBlU3RyaW5nQ2hhcicpLFxuICAgIGlzRXJyb3IgPSByZXF1aXJlKCcuL2lzRXJyb3InKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpLFxuICAgIHJlSW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuL19yZUludGVycG9sYXRlJyksXG4gICAgdGVtcGxhdGVTZXR0aW5ncyA9IHJlcXVpcmUoJy4vdGVtcGxhdGVTZXR0aW5ncycpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCA9ICdJbnZhbGlkIGB2YXJpYWJsZWAgb3B0aW9uIHBhc3NlZCBpbnRvIGBfLnRlbXBsYXRlYCc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG52YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbi8qKlxuICogVXNlZCB0byB2YWxpZGF0ZSB0aGUgYHZhbGlkYXRlYCBvcHRpb24gaW4gYF8udGVtcGxhdGVgIHZhcmlhYmxlLlxuICpcbiAqIEZvcmJpZHMgY2hhcmFjdGVycyB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBjaGFuZ2UgdGhlIG1lYW5pbmcgb2YgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50IGRlZmluaXRpb246XG4gKiAtIFwiKCksXCIgKG1vZGlmaWNhdGlvbiBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICogLSBcIj1cIiAoZGVmYXVsdCB2YWx1ZSlcbiAqIC0gXCJbXXt9XCIgKGRlc3RydWN0dXJpbmcgb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcbiAqIC0gXCIvXCIgKGJlZ2lubmluZyBvZiBhIGNvbW1lbnQpXG4gKiAtIHdoaXRlc3BhY2VcbiAqL1xudmFyIHJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzID0gL1soKT0se31cXFtcXF1cXC9cXHNdLztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoXG4gKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICovXG52YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4vKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4vKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAqXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gKlxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gKlxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAqXG4gKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAqXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICpcbiAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICogY29tcGlsZWQoZGF0YSk7XG4gKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICpcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICogY29tcGlsZWQuc291cmNlO1xuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICogLy8gICByZXR1cm4gX19wO1xuICogLy8gfVxuICpcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICogICB2YXIgSlNUID0ge1xcXG4gKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAqICAgfTtcXFxuICogJyk7XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAsICdnJyk7XG5cbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gIC8vIHRvIG5vcm1hbGl6ZSBhbGwga2luZHMgb2Ygd2hpdGVzcGFjZSwgc28gZS5nLiBuZXdsaW5lcyAoYW5kIHVuaWNvZGUgdmVyc2lvbnMgb2YgaXQpIGNhbid0IHNuZWFrIGluXG4gIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cbiAgdmFyIHNvdXJjZVVSTCA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgPyAoJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1xccy9nLCAnICcpICtcbiAgICAgICAnXFxuJylcbiAgICA6ICcnO1xuXG4gIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgIH1cbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcblxuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gIGlmICghdmFyaWFibGUpIHtcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgfVxuICAvLyBUaHJvdyBhbiBlcnJvciBpZiBhIGZvcmJpZGRlbiBjaGFyYWN0ZXIgd2FzIGZvdW5kIGluIGB2YXJpYWJsZWAsIHRvIHByZXZlbnRcbiAgLy8gcG90ZW50aWFsIGNvbW1hbmQgaW5qZWN0aW9uIGF0dGFja3MuXG4gIGVsc2UgaWYgKHJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzLnRlc3QodmFyaWFibGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQpO1xuICB9XG5cbiAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAodmFyaWFibGVcbiAgICAgID8gJydcbiAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICApICtcbiAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgIChpc0VzY2FwaW5nXG4gICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICA6ICcnXG4gICAgKSArXG4gICAgKGlzRXZhbHVhdGluZ1xuICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgOiAnO1xcbidcbiAgICApICtcbiAgICBzb3VyY2UgK1xuICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgfSk7XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcbiIsInZhciBlc2NhcGUgPSByZXF1aXJlKCcuL2VzY2FwZScpLFxuICAgIHJlRXNjYXBlID0gcmVxdWlyZSgnLi9fcmVFc2NhcGUnKSxcbiAgICByZUV2YWx1YXRlID0gcmVxdWlyZSgnLi9fcmVFdmFsdWF0ZScpLFxuICAgIHJlSW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuL19yZUludGVycG9sYXRlJyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd2YXJpYWJsZSc6ICcnLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gICdpbXBvcnRzJzoge1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgICdfJzogeyAnZXNjYXBlJzogZXNjYXBlIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZVNldHRpbmdzO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgTWFwLnByb3RvdHlwZTtcbnZhciBtYXBTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzTWFwID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNYXAucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBtYXBTaXplID0gaGFzTWFwICYmIG1hcFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBtYXBTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBtYXBTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIG1hcEZvckVhY2ggPSBoYXNNYXAgJiYgTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZTtcbnZhciBzZXRTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzU2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTZXQucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBzZXRTaXplID0gaGFzU2V0ICYmIHNldFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBzZXRTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBzZXRTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIHNldEZvckVhY2ggPSBoYXNTZXQgJiYgU2V0LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrTWFwLnByb3RvdHlwZTtcbnZhciB3ZWFrTWFwSGFzID0gaGFzV2Vha01hcCA/IFdlYWtNYXAucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgaGFzV2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nICYmIFdlYWtTZXQucHJvdG90eXBlO1xudmFyIHdlYWtTZXRIYXMgPSBoYXNXZWFrU2V0ID8gV2Vha1NldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrUmVmID0gdHlwZW9mIFdlYWtSZWYgPT09ICdmdW5jdGlvbicgJiYgV2Vha1JlZi5wcm90b3R5cGU7XG52YXIgd2Vha1JlZkRlcmVmID0gaGFzV2Vha1JlZiA/IFdlYWtSZWYucHJvdG90eXBlLmRlcmVmIDogbnVsbDtcbnZhciBib29sZWFuVmFsdWVPZiA9IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgJG1hdGNoID0gU3RyaW5nLnByb3RvdHlwZS5tYXRjaDtcbnZhciAkc2xpY2UgPSBTdHJpbmcucHJvdG90eXBlLnNsaWNlO1xudmFyICRyZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyICR0b1VwcGVyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2U7XG52YXIgJHRvTG93ZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZTtcbnZhciAkdGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbnZhciAkY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciAkam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xudmFyICRhcnJTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciAkZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGJpZ0ludFZhbHVlT2YgPSB0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nID8gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mIDogbnVsbDtcbnZhciBnT1BTID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBzeW1Ub1N0cmluZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogbnVsbDtcbnZhciBoYXNTaGFtbWVkU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ29iamVjdCc7XG4vLyBpZSwgYGhhcy10b3N0cmluZ3RhZy9zaGFtc1xudmFyIHRvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IGhhc1NoYW1tZWRTeW1ib2xzID8gJ29iamVjdCcgOiAnc3ltYm9sJylcbiAgICA/IFN5bWJvbC50b1N0cmluZ1RhZ1xuICAgIDogbnVsbDtcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgZ1BPID0gKHR5cGVvZiBSZWZsZWN0ID09PSAnZnVuY3Rpb24nID8gUmVmbGVjdC5nZXRQcm90b3R5cGVPZiA6IE9iamVjdC5nZXRQcm90b3R5cGVPZikgfHwgKFxuICAgIFtdLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgPyBmdW5jdGlvbiAoTykge1xuICAgICAgICAgICAgcmV0dXJuIE8uX19wcm90b19fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsXG4pO1xuXG5mdW5jdGlvbiBhZGROdW1lcmljU2VwYXJhdG9yKG51bSwgc3RyKSB7XG4gICAgaWYgKFxuICAgICAgICBudW0gPT09IEluZmluaXR5XG4gICAgICAgIHx8IG51bSA9PT0gLUluZmluaXR5XG4gICAgICAgIHx8IG51bSAhPT0gbnVtXG4gICAgICAgIHx8IChudW0gJiYgbnVtID4gLTEwMDAgJiYgbnVtIDwgMTAwMClcbiAgICAgICAgfHwgJHRlc3QuY2FsbCgvZS8sIHN0cilcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgdmFyIHNlcFJlZ2V4ID0gL1swLTldKD89KD86WzAtOV17M30pKyg/IVswLTldKSkvZztcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGludCA9IG51bSA8IDAgPyAtJGZsb29yKC1udW0pIDogJGZsb29yKG51bSk7IC8vIHRydW5jKG51bSlcbiAgICAgICAgaWYgKGludCAhPT0gbnVtKSB7XG4gICAgICAgICAgICB2YXIgaW50U3RyID0gU3RyaW5nKGludCk7XG4gICAgICAgICAgICB2YXIgZGVjID0gJHNsaWNlLmNhbGwoc3RyLCBpbnRTdHIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChpbnRTdHIsIHNlcFJlZ2V4LCAnJCZfJykgKyAnLicgKyAkcmVwbGFjZS5jYWxsKCRyZXBsYWNlLmNhbGwoZGVjLCAvKFswLTldezN9KS9nLCAnJCZfJyksIC9fJC8sICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChzdHIsIHNlcFJlZ2V4LCAnJCZfJyk7XG59XG5cbnZhciB1dGlsSW5zcGVjdCA9IHJlcXVpcmUoJy4vdXRpbC5pbnNwZWN0Jyk7XG52YXIgaW5zcGVjdEN1c3RvbSA9IHV0aWxJbnNwZWN0LmN1c3RvbTtcbnZhciBpbnNwZWN0U3ltYm9sID0gaXNTeW1ib2woaW5zcGVjdEN1c3RvbSkgPyBpbnNwZWN0Q3VzdG9tIDogbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnNwZWN0XyhvYmosIG9wdGlvbnMsIGRlcHRoLCBzZWVuKSB7XG4gICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpICYmIChvcHRzLnF1b3RlU3R5bGUgIT09ICdzaW5nbGUnICYmIG9wdHMucXVvdGVTdHlsZSAhPT0gJ2RvdWJsZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcInF1b3RlU3R5bGVcIiBtdXN0IGJlIFwic2luZ2xlXCIgb3IgXCJkb3VibGVcIicpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnbWF4U3RyaW5nTGVuZ3RoJykgJiYgKHR5cGVvZiBvcHRzLm1heFN0cmluZ0xlbmd0aCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gb3B0cy5tYXhTdHJpbmdMZW5ndGggPCAwICYmIG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBJbmZpbml0eVxuICAgICAgICAgICAgOiBvcHRzLm1heFN0cmluZ0xlbmd0aCAhPT0gbnVsbFxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm1heFN0cmluZ0xlbmd0aFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIEluZmluaXR5LCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgdmFyIGN1c3RvbUluc3BlY3QgPSBoYXMob3B0cywgJ2N1c3RvbUluc3BlY3QnKSA/IG9wdHMuY3VzdG9tSW5zcGVjdCA6IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0ICE9PSAnYm9vbGVhbicgJiYgY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiY3VzdG9tSW5zcGVjdFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBgdHJ1ZWAsIGBmYWxzZWAsIG9yIGBcXCdzeW1ib2xcXCdgJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ2luZGVudCcpXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSBudWxsXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSAnXFx0J1xuICAgICAgICAmJiAhKHBhcnNlSW50KG9wdHMuaW5kZW50LCAxMCkgPT09IG9wdHMuaW5kZW50ICYmIG9wdHMuaW5kZW50ID4gMClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiaW5kZW50XCIgbXVzdCBiZSBcIlxcXFx0XCIsIGFuIGludGVnZXIgPiAwLCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgaWYgKGhhcyhvcHRzLCAnbnVtZXJpY1NlcGFyYXRvcicpICYmIHR5cGVvZiBvcHRzLm51bWVyaWNTZXBhcmF0b3IgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJudW1lcmljU2VwYXJhdG9yXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCBvciBgZmFsc2VgJyk7XG4gICAgfVxuICAgIHZhciBudW1lcmljU2VwYXJhdG9yID0gb3B0cy5udW1lcmljU2VwYXJhdG9yO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvYmogPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhvYmosIG9wdHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5IC8gb2JqID4gMCA/ICcwJyA6ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhvYmopO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBzdHIpIDogc3RyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFyIGJpZ0ludFN0ciA9IFN0cmluZyhvYmopICsgJ24nO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBiaWdJbnRTdHIpIDogYmlnSW50U3RyO1xuICAgIH1cblxuICAgIHZhciBtYXhEZXB0aCA9IHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDUgOiBvcHRzLmRlcHRoO1xuICAgIGlmICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnKSB7IGRlcHRoID0gMDsgfVxuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDAgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdbQXJyYXldJyA6ICdbT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IGdldEluZGVudChvcHRzLCBkZXB0aCk7XG5cbiAgICBpZiAodHlwZW9mIHNlZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlZW4gPSBbXTtcbiAgICB9IGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHNlZW4gPSAkYXJyU2xpY2UuY2FsbChzZWVuKTtcbiAgICAgICAgICAgIHNlZW4ucHVzaChmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9JbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdPcHRzID0ge1xuICAgICAgICAgICAgICAgIGRlcHRoOiBvcHRzLmRlcHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0cy5xdW90ZVN0eWxlID0gb3B0cy5xdW90ZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBuZXdPcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgb3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNSZWdFeHAob2JqKSkgeyAvLyBpbiBvbGRlciBlbmdpbmVzLCByZWdleGVzIGFyZSBjYWxsYWJsZVxuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPZihvYmopO1xuICAgICAgICB2YXIga2V5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgcmV0dXJuICdbRnVuY3Rpb24nICsgKG5hbWUgPyAnOiAnICsgbmFtZSA6ICcgKGFub255bW91cyknKSArICddJyArIChrZXlzLmxlbmd0aCA+IDAgPyAnIHsgJyArICRqb2luLmNhbGwoa2V5cywgJywgJykgKyAnIH0nIDogJycpO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wob2JqKSkge1xuICAgICAgICB2YXIgc3ltU3RyaW5nID0gaGFzU2hhbW1lZFN5bWJvbHMgPyAkcmVwbGFjZS5jYWxsKFN0cmluZyhvYmopLCAvXihTeW1ib2xcXCguKlxcKSlfW14pXSokLywgJyQxJykgOiBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaGFzU2hhbW1lZFN5bWJvbHMgPyBtYXJrQm94ZWQoc3ltU3RyaW5nKSA6IHN5bVN0cmluZztcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChvYmopKSB7XG4gICAgICAgIHZhciBzID0gJzwnICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpO1xuICAgICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyc1tpXS5uYW1lICsgJz0nICsgd3JhcFF1b3RlcyhxdW90ZShhdHRyc1tpXS52YWx1ZSksICdkb3VibGUnLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcbiAgICAgICAgaWYgKG9iai5jaGlsZE5vZGVzICYmIG9iai5jaGlsZE5vZGVzLmxlbmd0aCkgeyBzICs9ICcuLi4nOyB9XG4gICAgICAgIHMgKz0gJzwvJyArICR0b0xvd2VyQ2FzZS5jYWxsKFN0cmluZyhvYmoubm9kZU5hbWUpKSArICc+JztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbXSc7IH1cbiAgICAgICAgdmFyIHhzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICBpZiAoaW5kZW50ICYmICFzaW5nbGVMaW5lVmFsdWVzKHhzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGluZGVudGVkSm9pbih4cywgaW5kZW50KSArICddJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1sgJyArICRqb2luLmNhbGwoeHMsICcsICcpICsgJyBdJztcbiAgICB9XG4gICAgaWYgKGlzRXJyb3Iob2JqKSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmICghKCdjYXVzZScgaW4gRXJyb3IucHJvdG90eXBlKSAmJiAnY2F1c2UnIGluIG9iaiAmJiAhaXNFbnVtZXJhYmxlLmNhbGwob2JqLCAnY2F1c2UnKSkge1xuICAgICAgICAgICAgcmV0dXJuICd7IFsnICsgU3RyaW5nKG9iaikgKyAnXSAnICsgJGpvaW4uY2FsbCgkY29uY2F0LmNhbGwoJ1tjYXVzZV06ICcgKyBpbnNwZWN0KG9iai5jYXVzZSksIHBhcnRzKSwgJywgJykgKyAnIH0nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbJyArIFN0cmluZyhvYmopICsgJ10nOyB9XG4gICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArICRqb2luLmNhbGwocGFydHMsICcsICcpICsgJyB9JztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGN1c3RvbUluc3BlY3QpIHtcbiAgICAgICAgaWYgKGluc3BlY3RTeW1ib2wgJiYgdHlwZW9mIG9ialtpbnNwZWN0U3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJyAmJiB1dGlsSW5zcGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxJbnNwZWN0KG9iaiwgeyBkZXB0aDogbWF4RGVwdGggLSBkZXB0aCB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJyAmJiB0eXBlb2Ygb2JqLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouaW5zcGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc01hcChvYmopKSB7XG4gICAgICAgIHZhciBtYXBQYXJ0cyA9IFtdO1xuICAgICAgICBpZiAobWFwRm9yRWFjaCkge1xuICAgICAgICAgICAgbWFwRm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBtYXBQYXJ0cy5wdXNoKGluc3BlY3Qoa2V5LCBvYmosIHRydWUpICsgJyA9PiAnICsgaW5zcGVjdCh2YWx1ZSwgb2JqKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbk9mKCdNYXAnLCBtYXBTaXplLmNhbGwob2JqKSwgbWFwUGFydHMsIGluZGVudCk7XG4gICAgfVxuICAgIGlmIChpc1NldChvYmopKSB7XG4gICAgICAgIHZhciBzZXRQYXJ0cyA9IFtdO1xuICAgICAgICBpZiAoc2V0Rm9yRWFjaCkge1xuICAgICAgICAgICAgc2V0Rm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0UGFydHMucHVzaChpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ1NldCcsIHNldFNpemUuY2FsbChvYmopLCBzZXRQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha01hcChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrTWFwJyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtTZXQob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1NldCcpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrUmVmKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtSZWYnKTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KE51bWJlcihvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0JpZ0ludChvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoaXNCb29sZWFuKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChib29sZWFuVmFsdWVPZi5jYWxsKG9iaikpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoU3RyaW5nKG9iaikpKTtcbiAgICB9XG4gICAgLy8gbm90ZTogaW4gSUUgOCwgc29tZXRpbWVzIGBnbG9iYWwgIT09IHdpbmRvd2AgYnV0IGJvdGggYXJlIHRoZSBwcm90b3R5cGVzIG9mIGVhY2ggb3RoZXJcbiAgICAvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqID09PSB3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuICd7IFtvYmplY3QgV2luZG93XSB9JztcbiAgICB9XG4gICAgaWYgKFxuICAgICAgICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIG9iaiA9PT0gZ2xvYmFsVGhpcylcbiAgICAgICAgfHwgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIG9iaiA9PT0gZ2xvYmFsKVxuICAgICkge1xuICAgICAgICByZXR1cm4gJ3sgW29iamVjdCBnbG9iYWxUaGlzXSB9JztcbiAgICB9XG4gICAgaWYgKCFpc0RhdGUob2JqKSAmJiAhaXNSZWdFeHAob2JqKSkge1xuICAgICAgICB2YXIgeXMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIHZhciBpc1BsYWluT2JqZWN0ID0gZ1BPID8gZ1BPKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGUgOiBvYmogaW5zdGFuY2VvZiBPYmplY3QgfHwgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgICAgIHZhciBwcm90b1RhZyA9IG9iaiBpbnN0YW5jZW9mIE9iamVjdCA/ICcnIDogJ251bGwgcHJvdG90eXBlJztcbiAgICAgICAgdmFyIHN0cmluZ1RhZyA9ICFpc1BsYWluT2JqZWN0ICYmIHRvU3RyaW5nVGFnICYmIE9iamVjdChvYmopID09PSBvYmogJiYgdG9TdHJpbmdUYWcgaW4gb2JqID8gJHNsaWNlLmNhbGwodG9TdHIob2JqKSwgOCwgLTEpIDogcHJvdG9UYWcgPyAnT2JqZWN0JyA6ICcnO1xuICAgICAgICB2YXIgY29uc3RydWN0b3JUYWcgPSBpc1BsYWluT2JqZWN0IHx8IHR5cGVvZiBvYmouY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgPyAnJyA6IG9iai5jb25zdHJ1Y3Rvci5uYW1lID8gb2JqLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgOiAnJztcbiAgICAgICAgdmFyIHRhZyA9IGNvbnN0cnVjdG9yVGFnICsgKHN0cmluZ1RhZyB8fCBwcm90b1RhZyA/ICdbJyArICRqb2luLmNhbGwoJGNvbmNhdC5jYWxsKFtdLCBzdHJpbmdUYWcgfHwgW10sIHByb3RvVGFnIHx8IFtdKSwgJzogJykgKyAnXSAnIDogJycpO1xuICAgICAgICBpZiAoeXMubGVuZ3RoID09PSAwKSB7IHJldHVybiB0YWcgKyAne30nOyB9XG4gICAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcgKyAneycgKyBpbmRlbnRlZEpvaW4oeXMsIGluZGVudCkgKyAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZyArICd7ICcgKyAkam9pbi5jYWxsKHlzLCAnLCAnKSArICcgfSc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcob2JqKTtcbn07XG5cbmZ1bmN0aW9uIHdyYXBRdW90ZXMocywgZGVmYXVsdFN0eWxlLCBvcHRzKSB7XG4gICAgdmFyIHF1b3RlQ2hhciA9IChvcHRzLnF1b3RlU3R5bGUgfHwgZGVmYXVsdFN0eWxlKSA9PT0gJ2RvdWJsZScgPyAnXCInIDogXCInXCI7XG4gICAgcmV0dXJuIHF1b3RlQ2hhciArIHMgKyBxdW90ZUNoYXI7XG59XG5cbmZ1bmN0aW9uIHF1b3RlKHMpIHtcbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChTdHJpbmcocyksIC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBBcnJheV0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNEYXRlKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBSZWdFeHBdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBFcnJvcl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBTdHJpbmddJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBCb29sZWFuXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5cbi8vIFN5bWJvbCBhbmQgQmlnSW50IGRvIGhhdmUgU3ltYm9sLnRvU3RyaW5nVGFnIGJ5IHNwZWMsIHNvIHRoYXQgY2FuJ3QgYmUgdXNlZCB0byBlbGltaW5hdGUgZmFsc2UgcG9zaXRpdmVzXG5mdW5jdGlvbiBpc1N5bWJvbChvYmopIHtcbiAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMpIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogaW5zdGFuY2VvZiBTeW1ib2w7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgIXN5bVRvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc3ltVG9TdHJpbmcuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCaWdJbnQob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgIWJpZ0ludFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSBpbiB0aGlzOyB9O1xuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn1cblxuZnVuY3Rpb24gdG9TdHIob2JqKSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gbmFtZU9mKGYpIHtcbiAgICBpZiAoZi5uYW1lKSB7IHJldHVybiBmLm5hbWU7IH1cbiAgICB2YXIgbSA9ICRtYXRjaC5jYWxsKGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChmKSwgL15mdW5jdGlvblxccyooW1xcdyRdKykvKTtcbiAgICBpZiAobSkgeyByZXR1cm4gbVsxXTsgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHsgcmV0dXJuIHhzLmluZGV4T2YoeCk7IH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHsgcmV0dXJuIGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBpc01hcCh4KSB7XG4gICAgaWYgKCFtYXBTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtNYXAoeCkge1xuICAgIGlmICghd2Vha01hcEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha01hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha1JlZih4KSB7XG4gICAgaWYgKCF3ZWFrUmVmRGVyZWYgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha1JlZkRlcmVmLmNhbGwoeCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1NldCh4KSB7XG4gICAgaWYgKCFzZXRTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtTZXQoeCkge1xuICAgIGlmICghd2Vha1NldEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha1NldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCh4KSB7XG4gICAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHguZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0U3RyaW5nKHN0ciwgb3B0cykge1xuICAgIGlmIChzdHIubGVuZ3RoID4gb3B0cy5tYXhTdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHN0ci5sZW5ndGggLSBvcHRzLm1heFN0cmluZ0xlbmd0aDtcbiAgICAgICAgdmFyIHRyYWlsZXIgPSAnLi4uICcgKyByZW1haW5pbmcgKyAnIG1vcmUgY2hhcmFjdGVyJyArIChyZW1haW5pbmcgPiAxID8gJ3MnIDogJycpO1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZygkc2xpY2UuY2FsbChzdHIsIDAsIG9wdHMubWF4U3RyaW5nTGVuZ3RoKSwgb3B0cykgKyB0cmFpbGVyO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIHZhciBzID0gJHJlcGxhY2UuY2FsbCgkcmVwbGFjZS5jYWxsKHN0ciwgLyhbJ1xcXFxdKS9nLCAnXFxcXCQxJyksIC9bXFx4MDAtXFx4MWZdL2csIGxvd2J5dGUpO1xuICAgIHJldHVybiB3cmFwUXVvdGVzKHMsICdzaW5nbGUnLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gbG93Ynl0ZShjKSB7XG4gICAgdmFyIG4gPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHggPSB7XG4gICAgICAgIDg6ICdiJyxcbiAgICAgICAgOTogJ3QnLFxuICAgICAgICAxMDogJ24nLFxuICAgICAgICAxMjogJ2YnLFxuICAgICAgICAxMzogJ3InXG4gICAgfVtuXTtcbiAgICBpZiAoeCkgeyByZXR1cm4gJ1xcXFwnICsgeDsgfVxuICAgIHJldHVybiAnXFxcXHgnICsgKG4gPCAweDEwID8gJzAnIDogJycpICsgJHRvVXBwZXJDYXNlLmNhbGwobi50b1N0cmluZygxNikpO1xufVxuXG5mdW5jdGlvbiBtYXJrQm94ZWQoc3RyKSB7XG4gICAgcmV0dXJuICdPYmplY3QoJyArIHN0ciArICcpJztcbn1cblxuZnVuY3Rpb24gd2Vha0NvbGxlY3Rpb25PZih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgKyAnIHsgPyB9Jztcbn1cblxuZnVuY3Rpb24gY29sbGVjdGlvbk9mKHR5cGUsIHNpemUsIGVudHJpZXMsIGluZGVudCkge1xuICAgIHZhciBqb2luZWRFbnRyaWVzID0gaW5kZW50ID8gaW5kZW50ZWRKb2luKGVudHJpZXMsIGluZGVudCkgOiAkam9pbi5jYWxsKGVudHJpZXMsICcsICcpO1xuICAgIHJldHVybiB0eXBlICsgJyAoJyArIHNpemUgKyAnKSB7JyArIGpvaW5lZEVudHJpZXMgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZUxpbmVWYWx1ZXMoeHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhzW2ldLCAnXFxuJykgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRlbnQob3B0cywgZGVwdGgpIHtcbiAgICB2YXIgYmFzZUluZGVudDtcbiAgICBpZiAob3B0cy5pbmRlbnQgPT09ICdcXHQnKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAnXFx0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmluZGVudCA9PT0gJ251bWJlcicgJiYgb3B0cy5pbmRlbnQgPiAwKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAkam9pbi5jYWxsKEFycmF5KG9wdHMuaW5kZW50ICsgMSksICcgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IGJhc2VJbmRlbnQsXG4gICAgICAgIHByZXY6ICRqb2luLmNhbGwoQXJyYXkoZGVwdGggKyAxKSwgYmFzZUluZGVudClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbmRlbnRlZEpvaW4oeHMsIGluZGVudCkge1xuICAgIGlmICh4cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnOyB9XG4gICAgdmFyIGxpbmVKb2luZXIgPSAnXFxuJyArIGluZGVudC5wcmV2ICsgaW5kZW50LmJhc2U7XG4gICAgcmV0dXJuIGxpbmVKb2luZXIgKyAkam9pbi5jYWxsKHhzLCAnLCcgKyBsaW5lSm9pbmVyKSArICdcXG4nICsgaW5kZW50LnByZXY7XG59XG5cbmZ1bmN0aW9uIGFyck9iaktleXMob2JqLCBpbnNwZWN0KSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmopO1xuICAgIHZhciB4cyA9IFtdO1xuICAgIGlmIChpc0Fycikge1xuICAgICAgICB4cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHNbaV0gPSBoYXMob2JqLCBpKSA/IGluc3BlY3Qob2JqW2ldLCBvYmopIDogJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN5bXMgPSB0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJyA/IGdPUFMob2JqKSA6IFtdO1xuICAgIHZhciBzeW1NYXA7XG4gICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzKSB7XG4gICAgICAgIHN5bU1hcCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHN5bXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHN5bU1hcFsnJCcgKyBzeW1zW2tdXSA9IHN5bXNba107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgaWYgKCFoYXMob2JqLCBrZXkpKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIGlmIChpc0FyciAmJiBTdHJpbmcoTnVtYmVyKGtleSkpID09PSBrZXkgJiYga2V5IDwgb2JqLmxlbmd0aCkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMgJiYgc3ltTWFwWyckJyArIGtleV0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcHJldmVudCBzaGFtbWVkIFN5bWJvbHMsIHdoaWNoIGFyZSBzdG9yZWQgYXMgc3RyaW5ncywgZnJvbSBiZWluZyBpbmNsdWRlZCBpbiB0aGUgc3RyaW5nIGtleSBzZWN0aW9uXG4gICAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmICgkdGVzdC5jYWxsKC9bXlxcdyRdLywga2V5KSkge1xuICAgICAgICAgICAgeHMucHVzaChpbnNwZWN0KGtleSwgb2JqKSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhzLnB1c2goa2V5ICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN5bXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpc0VudW1lcmFibGUuY2FsbChvYmosIHN5bXNbal0pKSB7XG4gICAgICAgICAgICAgICAgeHMucHVzaCgnWycgKyBpbnNwZWN0KHN5bXNbal0pICsgJ106ICcgKyBpbnNwZWN0KG9ialtzeW1zW2pdXSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhzO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCdpcy1pbnRlZ2VyJylcbnZhciBpc0ludGVnZXJSZWdleCA9IC9eLT9cXGQrJC9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUludFN0cmljdCAoaW50ZWdlcikge1xuICBpZiAodHlwZW9mIGludGVnZXIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihpbnRlZ2VyKSA/IGludGVnZXIgOiB1bmRlZmluZWRcbiAgfVxuICBpZiAodHlwZW9mIGludGVnZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlclJlZ2V4LnRlc3QoaW50ZWdlcikgPyBwYXJzZUludChpbnRlZ2VyLCAxMCkgOiB1bmRlZmluZWRcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBwYXJzZUludFN0cmljdCA9IHJlcXVpcmUoJ3BhcnNlLWludCcpXG52YXIgZXhwYW5kWWVhciA9IHJlcXVpcmUoJ2V4cGFuZC15ZWFyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVllYXIgKHllYXIsIGV4cGFuZCwgbm93KSB7XG4gIHllYXIgPSBwYXJzZUludFN0cmljdCh5ZWFyKVxuICBpZiAoeWVhciA9PSBudWxsKSByZXR1cm5cbiAgaWYgKCFleHBhbmQpIHJldHVybiB5ZWFyXG4gIHJldHVybiBleHBhbmRZZWFyKHllYXIsIG5vdylcbn1cbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyIHBlcmNlbnRUd2VudGllcyA9IC8lMjAvZztcblxudmFyIEZvcm1hdCA9IHtcbiAgICBSRkMxNzM4OiAnUkZDMTczOCcsXG4gICAgUkZDMzk4NjogJ1JGQzM5ODYnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6IEZvcm1hdC5SRkMzOTg2LFxuICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgUkZDMTczODogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZS5jYWxsKHZhbHVlLCBwZXJjZW50VHdlbnRpZXMsICcrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJGQzM5ODY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFJGQzE3Mzg6IEZvcm1hdC5SRkMxNzM4LFxuICAgIFJGQzM5ODY6IEZvcm1hdC5SRkMzOTg2XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd0VtcHR5QXJyYXlzOiBmYWxzZSxcbiAgICBhbGxvd1Byb3RvdHlwZXM6IGZhbHNlLFxuICAgIGFsbG93U3BhcnNlOiBmYWxzZSxcbiAgICBhcnJheUxpbWl0OiAyMCxcbiAgICBjaGFyc2V0OiAndXRmLTgnLFxuICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG4gICAgY29tbWE6IGZhbHNlLFxuICAgIGRlY29kZURvdEluS2V5czogZmFsc2UsXG4gICAgZGVjb2RlcjogdXRpbHMuZGVjb2RlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGRlcHRoOiA1LFxuICAgIGR1cGxpY2F0ZXM6ICdjb21iaW5lJyxcbiAgICBpZ25vcmVRdWVyeVByZWZpeDogZmFsc2UsXG4gICAgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzOiBmYWxzZSxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMCxcbiAgICBwYXJzZUFycmF5czogdHJ1ZSxcbiAgICBwbGFpbk9iamVjdHM6IGZhbHNlLFxuICAgIHN0cmljdERlcHRoOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiMoXFxkKyk7L2csIGZ1bmN0aW9uICgkMCwgbnVtYmVyU3RyKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG51bWJlclN0ciwgMTApKTtcbiAgICB9KTtcbn07XG5cbnZhciBwYXJzZUFycmF5VmFsdWUgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmNvbW1hICYmIHZhbC5pbmRleE9mKCcsJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdmFsLnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIFRoaXMgaXMgd2hhdCBicm93c2VycyB3aWxsIHN1Ym1pdCB3aGVuIHRoZSDinJMgY2hhcmFjdGVyIG9jY3VycyBpbiBhblxuLy8gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIGJvZHkgYW5kIHRoZSBlbmNvZGluZyBvZiB0aGUgcGFnZSBjb250YWluaW5nXG4vLyB0aGUgZm9ybSBpcyBpc28tODg1OS0xLCBvciB3aGVuIHRoZSBzdWJtaXR0ZWQgZm9ybSBoYXMgYW4gYWNjZXB0LWNoYXJzZXRcbi8vIGF0dHJpYnV0ZSBvZiBpc28tODg1OS0xLiBQcmVzdW1hYmx5IGFsc28gd2l0aCBvdGhlciBjaGFyc2V0cyB0aGF0IGRvIG5vdCBjb250YWluXG4vLyB0aGUg4pyTIGNoYXJhY3Rlciwgc3VjaCBhcyB1cy1hc2NpaS5cbnZhciBpc29TZW50aW5lbCA9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpXG5cbi8vIFRoZXNlIGFyZSB0aGUgcGVyY2VudC1lbmNvZGVkIHV0Zi04IG9jdGV0cyByZXByZXNlbnRpbmcgYSBjaGVja21hcmssIGluZGljYXRpbmcgdGhhdCB0aGUgcmVxdWVzdCBhY3R1YWxseSBpcyB1dGYtOCBlbmNvZGVkLlxudmFyIGNoYXJzZXRTZW50aW5lbCA9ICd1dGY4PSVFMiU5QyU5Myc7IC8vIGVuY29kZVVSSUNvbXBvbmVudCgn4pyTJylcblxudmFyIHBhcnNlVmFsdWVzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ1ZhbHVlcyhzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0geyBfX3Byb3RvX186IG51bGwgfTtcblxuICAgIHZhciBjbGVhblN0ciA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPyBzdHIucmVwbGFjZSgvXlxcPy8sICcnKSA6IHN0cjtcbiAgICBjbGVhblN0ciA9IGNsZWFuU3RyLnJlcGxhY2UoLyU1Qi9naSwgJ1snKS5yZXBsYWNlKC8lNUQvZ2ksICddJyk7XG4gICAgdmFyIGxpbWl0ID0gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0O1xuICAgIHZhciBwYXJ0cyA9IGNsZWFuU3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBsaW1pdCk7XG4gICAgdmFyIHNraXBJbmRleCA9IC0xOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXJlIHRoZSB1dGY4IHNlbnRpbmVsIHdhcyBmb3VuZFxuICAgIHZhciBpO1xuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQ7XG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJ3V0Zjg9JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gPT09IGNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ3V0Zi04JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldID09PSBpc29TZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ2lzby04ODU5LTEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGkgPSBwYXJ0cy5sZW5ndGg7IC8vIFRoZSBlc2xpbnQgc2V0dGluZ3MgZG8gbm90IGFsbG93IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpID09PSBza2lwSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG4gICAgICAgIHZhciBwb3MgPSBicmFja2V0RXF1YWxzUG9zID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogYnJhY2tldEVxdWFsc1BvcyArIDE7XG5cbiAgICAgICAgdmFyIGtleSwgdmFsO1xuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQsIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID8gbnVsbCA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UoMCwgcG9zKSwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuICAgICAgICAgICAgdmFsID0gdXRpbHMubWF5YmVNYXAoXG4gICAgICAgICAgICAgICAgcGFyc2VBcnJheVZhbHVlKHBhcnQuc2xpY2UocG9zICsgMSksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbmNvZGVkVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlY29kZXIoZW5jb2RlZFZhbCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgJiYgb3B0aW9ucy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgJiYgY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICB2YWwgPSBpbnRlcnByZXROdW1lcmljRW50aXRpZXModmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0LmluZGV4T2YoJ1tdPScpID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IGlzQXJyYXkodmFsKSA/IFt2YWxdIDogdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4aXN0aW5nID0gaGFzLmNhbGwob2JqLCBrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmcgJiYgb3B0aW9ucy5kdXBsaWNhdGVzID09PSAnY29tYmluZScpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdXRpbHMuY29tYmluZShvYmpba2V5XSwgdmFsKTtcbiAgICAgICAgfSBlbHNlIGlmICghZXhpc3RpbmcgfHwgb3B0aW9ucy5kdXBsaWNhdGVzID09PSAnbGFzdCcpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcbiAgICB2YXIgbGVhZiA9IHZhbHVlc1BhcnNlZCA/IHZhbCA6IHBhcnNlQXJyYXlWYWx1ZSh2YWwsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgaSA9IGNoYWluLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBvYmo7XG4gICAgICAgIHZhciByb290ID0gY2hhaW5baV07XG5cbiAgICAgICAgaWYgKHJvb3QgPT09ICdbXScgJiYgb3B0aW9ucy5wYXJzZUFycmF5cykge1xuICAgICAgICAgICAgb2JqID0gb3B0aW9ucy5hbGxvd0VtcHR5QXJyYXlzICYmIChsZWFmID09PSAnJyB8fCAob3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgJiYgbGVhZiA9PT0gbnVsbCkpXG4gICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgIDogW10uY29uY2F0KGxlYWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XG4gICAgICAgICAgICB2YXIgZGVjb2RlZFJvb3QgPSBvcHRpb25zLmRlY29kZURvdEluS2V5cyA/IGNsZWFuUm9vdC5yZXBsYWNlKC8lMkUvZywgJy4nKSA6IGNsZWFuUm9vdDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGRlY29kZWRSb290LCAxMCk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucGFyc2VBcnJheXMgJiYgZGVjb2RlZFJvb3QgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgb2JqID0geyAwOiBsZWFmIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICFpc05hTihpbmRleClcbiAgICAgICAgICAgICAgICAmJiByb290ICE9PSBkZWNvZGVkUm9vdFxuICAgICAgICAgICAgICAgICYmIFN0cmluZyhpbmRleCkgPT09IGRlY29kZWRSb290XG4gICAgICAgICAgICAgICAgJiYgaW5kZXggPj0gMFxuICAgICAgICAgICAgICAgICYmIChvcHRpb25zLnBhcnNlQXJyYXlzICYmIGluZGV4IDw9IG9wdGlvbnMuYXJyYXlMaW1pdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgICAgIG9ialtpbmRleF0gPSBsZWFmO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWNvZGVkUm9vdCAhPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgICAgICBvYmpbZGVjb2RlZFJvb3RdID0gbGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWYgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYWY7XG59O1xuXG52YXIgcGFyc2VLZXlzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ0tleXMoZ2l2ZW5LZXksIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKSB7XG4gICAgaWYgKCFnaXZlbktleSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhbnNmb3JtIGRvdCBub3RhdGlvbiB0byBicmFja2V0IG5vdGF0aW9uXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuYWxsb3dEb3RzID8gZ2l2ZW5LZXkucmVwbGFjZSgvXFwuKFteLltdKykvZywgJ1skMV0nKSA6IGdpdmVuS2V5O1xuXG4gICAgLy8gVGhlIHJlZ2V4IGNodW5rc1xuXG4gICAgdmFyIGJyYWNrZXRzID0gLyhcXFtbXltcXF1dKl0pLztcbiAgICB2YXIgY2hpbGQgPSAvKFxcW1teW1xcXV0qXSkvZztcblxuICAgIC8vIEdldCB0aGUgcGFyZW50XG5cbiAgICB2YXIgc2VnbWVudCA9IG9wdGlvbnMuZGVwdGggPiAwICYmIGJyYWNrZXRzLmV4ZWMoa2V5KTtcbiAgICB2YXIgcGFyZW50ID0gc2VnbWVudCA/IGtleS5zbGljZSgwLCBzZWdtZW50LmluZGV4KSA6IGtleTtcblxuICAgIC8vIFN0YXNoIHRoZSBwYXJlbnQgaWYgaXQgZXhpc3RzXG5cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIHBsYWluIG9iamVjdHMsIG9wdGlvbmFsbHkgcHJlZml4IGtleXMgdGhhdCB3b3VsZCBvdmVyd3JpdGUgb2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgcGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMucHVzaChwYXJlbnQpO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBjaGlsZHJlbiBhcHBlbmRpbmcgdG8gdGhlIGFycmF5IHVudGlsIHdlIGhpdCBkZXB0aFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChvcHRpb25zLmRlcHRoID4gMCAmJiAoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNlZ21lbnRbMV0uc2xpY2UoMSwgLTEpKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goc2VnbWVudFsxXSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHJlbWFpbmRlciwgY2hlY2sgc3RyaWN0RGVwdGggb3B0aW9uIGZvciB0aHJvdywgZWxzZSBqdXN0IGFkZCB3aGF0ZXZlciBpcyBsZWZ0XG5cbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3REZXB0aCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0lucHV0IGRlcHRoIGV4Y2VlZGVkIGRlcHRoIG9wdGlvbiBvZiAnICsgb3B0aW9ucy5kZXB0aCArICcgYW5kIHN0cmljdERlcHRoIGlzIHRydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goJ1snICsga2V5LnNsaWNlKHNlZ21lbnQuaW5kZXgpICsgJ10nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpO1xufTtcblxudmFyIG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BhbGxvd0VtcHR5QXJyYXlzYCBvcHRpb24gY2FuIG9ubHkgYmUgYHRydWVgIG9yIGBmYWxzZWAsIHdoZW4gcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuZGVjb2RlRG90SW5LZXlzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5kZWNvZGVEb3RJbktleXMgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgZGVjb2RlRG90SW5LZXlzYCBvcHRpb24gY2FuIG9ubHkgYmUgYHRydWVgIG9yIGBmYWxzZWAsIHdoZW4gcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5kZWNvZGVyICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLmRlY29kZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmRlY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGVjb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjaGFyc2V0IG9wdGlvbiBtdXN0IGJlIGVpdGhlciB1dGYtOCwgaXNvLTg4NTktMSwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIHZhciBjaGFyc2V0ID0gdHlwZW9mIG9wdHMuY2hhcnNldCA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5jaGFyc2V0IDogb3B0cy5jaGFyc2V0O1xuXG4gICAgdmFyIGR1cGxpY2F0ZXMgPSB0eXBlb2Ygb3B0cy5kdXBsaWNhdGVzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmR1cGxpY2F0ZXMgOiBvcHRzLmR1cGxpY2F0ZXM7XG5cbiAgICBpZiAoZHVwbGljYXRlcyAhPT0gJ2NvbWJpbmUnICYmIGR1cGxpY2F0ZXMgIT09ICdmaXJzdCcgJiYgZHVwbGljYXRlcyAhPT0gJ2xhc3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBkdXBsaWNhdGVzIG9wdGlvbiBtdXN0IGJlIGVpdGhlciBjb21iaW5lLCBmaXJzdCwgb3IgbGFzdCcpO1xuICAgIH1cblxuICAgIHZhciBhbGxvd0RvdHMgPSB0eXBlb2Ygb3B0cy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID8gb3B0cy5kZWNvZGVEb3RJbktleXMgPT09IHRydWUgPyB0cnVlIDogZGVmYXVsdHMuYWxsb3dEb3RzIDogISFvcHRzLmFsbG93RG90cztcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbG93RG90czogYWxsb3dEb3RzLFxuICAgICAgICBhbGxvd0VtcHR5QXJyYXlzOiB0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzID09PSAnYm9vbGVhbicgPyAhIW9wdHMuYWxsb3dFbXB0eUFycmF5cyA6IGRlZmF1bHRzLmFsbG93RW1wdHlBcnJheXMsXG4gICAgICAgIGFsbG93UHJvdG90eXBlczogdHlwZW9mIG9wdHMuYWxsb3dQcm90b3R5cGVzID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93UHJvdG90eXBlcyA6IGRlZmF1bHRzLmFsbG93UHJvdG90eXBlcyxcbiAgICAgICAgYWxsb3dTcGFyc2U6IHR5cGVvZiBvcHRzLmFsbG93U3BhcnNlID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93U3BhcnNlIDogZGVmYXVsdHMuYWxsb3dTcGFyc2UsXG4gICAgICAgIGFycmF5TGltaXQ6IHR5cGVvZiBvcHRzLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0cy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdCxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBjb21tYTogdHlwZW9mIG9wdHMuY29tbWEgPT09ICdib29sZWFuJyA/IG9wdHMuY29tbWEgOiBkZWZhdWx0cy5jb21tYSxcbiAgICAgICAgZGVjb2RlRG90SW5LZXlzOiB0eXBlb2Ygb3B0cy5kZWNvZGVEb3RJbktleXMgPT09ICdib29sZWFuJyA/IG9wdHMuZGVjb2RlRG90SW5LZXlzIDogZGVmYXVsdHMuZGVjb2RlRG90SW5LZXlzLFxuICAgICAgICBkZWNvZGVyOiB0eXBlb2Ygb3B0cy5kZWNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0cy5kZWNvZGVyIDogZGVmYXVsdHMuZGVjb2RlcixcbiAgICAgICAgZGVsaW1pdGVyOiB0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnIHx8IHV0aWxzLmlzUmVnRXhwKG9wdHMuZGVsaW1pdGVyKSA/IG9wdHMuZGVsaW1pdGVyIDogZGVmYXVsdHMuZGVsaW1pdGVyLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW1wbGljaXQtY29lcmNpb24sIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICBkZXB0aDogKHR5cGVvZiBvcHRzLmRlcHRoID09PSAnbnVtYmVyJyB8fCBvcHRzLmRlcHRoID09PSBmYWxzZSkgPyArb3B0cy5kZXB0aCA6IGRlZmF1bHRzLmRlcHRoLFxuICAgICAgICBkdXBsaWNhdGVzOiBkdXBsaWNhdGVzLFxuICAgICAgICBpZ25vcmVRdWVyeVByZWZpeDogb3B0cy5pZ25vcmVRdWVyeVByZWZpeCA9PT0gdHJ1ZSxcbiAgICAgICAgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzOiB0eXBlb2Ygb3B0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgPT09ICdib29sZWFuJyA/IG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzIDogZGVmYXVsdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzLFxuICAgICAgICBwYXJhbWV0ZXJMaW1pdDogdHlwZW9mIG9wdHMucGFyYW1ldGVyTGltaXQgPT09ICdudW1iZXInID8gb3B0cy5wYXJhbWV0ZXJMaW1pdCA6IGRlZmF1bHRzLnBhcmFtZXRlckxpbWl0LFxuICAgICAgICBwYXJzZUFycmF5czogb3B0cy5wYXJzZUFycmF5cyAhPT0gZmFsc2UsXG4gICAgICAgIHBsYWluT2JqZWN0czogdHlwZW9mIG9wdHMucGxhaW5PYmplY3RzID09PSAnYm9vbGVhbicgPyBvcHRzLnBsYWluT2JqZWN0cyA6IGRlZmF1bHRzLnBsYWluT2JqZWN0cyxcbiAgICAgICAgc3RyaWN0RGVwdGg6IHR5cGVvZiBvcHRzLnN0cmljdERlcHRoID09PSAnYm9vbGVhbicgPyAhIW9wdHMuc3RyaWN0RGVwdGggOiBkZWZhdWx0cy5zdHJpY3REZXB0aCxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgIHZhciBvcHRpb25zID0gbm9ybWFsaXplUGFyc2VPcHRpb25zKG9wdHMpO1xuXG4gICAgaWYgKHN0ciA9PT0gJycgfHwgc3RyID09PSBudWxsIHx8IHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcE9iaiA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gcGFyc2VWYWx1ZXMoc3RyLCBvcHRpb25zKSA6IHN0cjtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGtleXMgYW5kIHNldHVwIHRoZSBuZXcgb2JqZWN0XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRlbXBPYmopO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIG5ld09iaiA9IHBhcnNlS2V5cyhrZXksIHRlbXBPYmpba2V5XSwgb3B0aW9ucywgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpO1xuICAgICAgICBvYmogPSB1dGlscy5tZXJnZShvYmosIG5ld09iaiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dTcGFyc2UgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMuY29tcGFjdChvYmopO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFNpZGVDaGFubmVsID0gcmVxdWlyZSgnc2lkZS1jaGFubmVsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBhcnJheVByZWZpeEdlbmVyYXRvcnMgPSB7XG4gICAgYnJhY2tldHM6IGZ1bmN0aW9uIGJyYWNrZXRzKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1tdJztcbiAgICB9LFxuICAgIGNvbW1hOiAnY29tbWEnLFxuICAgIGluZGljZXM6IGZ1bmN0aW9uIGluZGljZXMocHJlZml4LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbJyArIGtleSArICddJztcbiAgICB9LFxuICAgIHJlcGVhdDogZnVuY3Rpb24gcmVwZWF0KHByZWZpeCkge1xuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG52YXIgcHVzaFRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB2YWx1ZU9yQXJyYXkpIHtcbiAgICBwdXNoLmFwcGx5KGFyciwgaXNBcnJheSh2YWx1ZU9yQXJyYXkpID8gdmFsdWVPckFycmF5IDogW3ZhbHVlT3JBcnJheV0pO1xufTtcblxudmFyIHRvSVNPID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBkZWZhdWx0Rm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xudmFyIGRlZmF1bHRzID0ge1xuICAgIGFkZFF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93RW1wdHlBcnJheXM6IGZhbHNlLFxuICAgIGFycmF5Rm9ybWF0OiAnaW5kaWNlcycsXG4gICAgY2hhcnNldDogJ3V0Zi04JyxcbiAgICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGVuY29kZTogdHJ1ZSxcbiAgICBlbmNvZGVEb3RJbktleXM6IGZhbHNlLFxuICAgIGVuY29kZXI6IHV0aWxzLmVuY29kZSxcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OiBmYWxzZSxcbiAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXQsXG4gICAgZm9ybWF0dGVyOiBmb3JtYXRzLmZvcm1hdHRlcnNbZGVmYXVsdEZvcm1hdF0sXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGluZGljZXM6IGZhbHNlLFxuICAgIHNlcmlhbGl6ZURhdGU6IGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdG9JU08uY2FsbChkYXRlKTtcbiAgICB9LFxuICAgIHNraXBOdWxsczogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIGlzTm9uTnVsbGlzaFByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzTm9uTnVsbGlzaFByaW1pdGl2ZSh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcidcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdib29sZWFuJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ3N5bWJvbCdcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdiaWdpbnQnO1xufTtcblxudmFyIHNlbnRpbmVsID0ge307XG5cbnZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoXG4gICAgb2JqZWN0LFxuICAgIHByZWZpeCxcbiAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgIGNvbW1hUm91bmRUcmlwLFxuICAgIGFsbG93RW1wdHlBcnJheXMsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgIHNraXBOdWxscyxcbiAgICBlbmNvZGVEb3RJbktleXMsXG4gICAgZW5jb2RlcixcbiAgICBmaWx0ZXIsXG4gICAgc29ydCxcbiAgICBhbGxvd0RvdHMsXG4gICAgc2VyaWFsaXplRGF0ZSxcbiAgICBmb3JtYXQsXG4gICAgZm9ybWF0dGVyLFxuICAgIGVuY29kZVZhbHVlc09ubHksXG4gICAgY2hhcnNldCxcbiAgICBzaWRlQ2hhbm5lbFxuKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcblxuICAgIHZhciB0bXBTYyA9IHNpZGVDaGFubmVsO1xuICAgIHZhciBzdGVwID0gMDtcbiAgICB2YXIgZmluZEZsYWcgPSBmYWxzZTtcbiAgICB3aGlsZSAoKHRtcFNjID0gdG1wU2MuZ2V0KHNlbnRpbmVsKSkgIT09IHZvaWQgdW5kZWZpbmVkICYmICFmaW5kRmxhZykge1xuICAgICAgICAvLyBXaGVyZSBvYmplY3QgbGFzdCBhcHBlYXJlZCBpbiB0aGUgcmVmIHRyZWVcbiAgICAgICAgdmFyIHBvcyA9IHRtcFNjLmdldChvYmplY3QpO1xuICAgICAgICBzdGVwICs9IDE7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHBvcyA9PT0gc3RlcCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDeWNsaWMgb2JqZWN0IHZhbHVlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbmRGbGFnID0gdHJ1ZTsgLy8gQnJlYWsgd2hpbGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRtcFNjLmdldChzZW50aW5lbCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzdGVwID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9iaiA9IGZpbHRlcihwcmVmaXgsIG9iaik7XG4gICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9iaiA9IHNlcmlhbGl6ZURhdGUob2JqKTtcbiAgICB9IGVsc2UgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iaiA9IHV0aWxzLm1heWJlTWFwKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZURhdGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJpY3ROdWxsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVyICYmICFlbmNvZGVWYWx1ZXNPbmx5ID8gZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknLCBmb3JtYXQpIDogcHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGlzTm9uTnVsbGlzaFByaW1pdGl2ZShvYmopIHx8IHV0aWxzLmlzQnVmZmVyKG9iaikpIHtcbiAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGVuY29kZVZhbHVlc09ubHkgPyBwcmVmaXggOiBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCk7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAnPScgKyBmb3JtYXR0ZXIoZW5jb2RlcihvYmosIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICd2YWx1ZScsIGZvcm1hdCkpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihwcmVmaXgpICsgJz0nICsgZm9ybWF0dGVyKFN0cmluZyhvYmopKV07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgdmFyIG9iaktleXM7XG4gICAgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNBcnJheShvYmopKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gam9pbiBlbGVtZW50cyBpblxuICAgICAgICBpZiAoZW5jb2RlVmFsdWVzT25seSAmJiBlbmNvZGVyKSB7XG4gICAgICAgICAgICBvYmogPSB1dGlscy5tYXliZU1hcChvYmosIGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIG9iaktleXMgPSBbeyB2YWx1ZTogb2JqLmxlbmd0aCA+IDAgPyBvYmouam9pbignLCcpIHx8IG51bGwgOiB2b2lkIHVuZGVmaW5lZCB9XTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZmlsdGVyKSkge1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgb2JqS2V5cyA9IHNvcnQgPyBrZXlzLnNvcnQoc29ydCkgOiBrZXlzO1xuICAgIH1cblxuICAgIHZhciBlbmNvZGVkUHJlZml4ID0gZW5jb2RlRG90SW5LZXlzID8gcHJlZml4LnJlcGxhY2UoL1xcLi9nLCAnJTJFJykgOiBwcmVmaXg7XG5cbiAgICB2YXIgYWRqdXN0ZWRQcmVmaXggPSBjb21tYVJvdW5kVHJpcCAmJiBpc0FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCA9PT0gMSA/IGVuY29kZWRQcmVmaXggKyAnW10nIDogZW5jb2RlZFByZWZpeDtcblxuICAgIGlmIChhbGxvd0VtcHR5QXJyYXlzICYmIGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhZGp1c3RlZFByZWZpeCArICdbXSc7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmpLZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2pdO1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5LnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGtleS52YWx1ZSA6IG9ialtrZXldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuY29kZWRLZXkgPSBhbGxvd0RvdHMgJiYgZW5jb2RlRG90SW5LZXlzID8ga2V5LnJlcGxhY2UoL1xcLi9nLCAnJTJFJykgOiBrZXk7XG4gICAgICAgIHZhciBrZXlQcmVmaXggPSBpc0FycmF5KG9iailcbiAgICAgICAgICAgID8gdHlwZW9mIGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdmdW5jdGlvbicgPyBnZW5lcmF0ZUFycmF5UHJlZml4KGFkanVzdGVkUHJlZml4LCBlbmNvZGVkS2V5KSA6IGFkanVzdGVkUHJlZml4XG4gICAgICAgICAgICA6IGFkanVzdGVkUHJlZml4ICsgKGFsbG93RG90cyA/ICcuJyArIGVuY29kZWRLZXkgOiAnWycgKyBlbmNvZGVkS2V5ICsgJ10nKTtcblxuICAgICAgICBzaWRlQ2hhbm5lbC5zZXQob2JqZWN0LCBzdGVwKTtcbiAgICAgICAgdmFyIHZhbHVlU2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgICAgICB2YWx1ZVNpZGVDaGFubmVsLnNldChzZW50aW5lbCwgc2lkZUNoYW5uZWwpO1xuICAgICAgICBwdXNoVG9BcnJheSh2YWx1ZXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAga2V5UHJlZml4LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICAgICAgYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgIHNraXBOdWxscyxcbiAgICAgICAgICAgIGVuY29kZURvdEluS2V5cyxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgZW5jb2RlVmFsdWVzT25seSAmJiBpc0FycmF5KG9iaikgPyBudWxsIDogZW5jb2RlcixcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICBzZXJpYWxpemVEYXRlLFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgICAgIGNoYXJzZXQsXG4gICAgICAgICAgICB2YWx1ZVNpZGVDaGFubmVsXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG52YXIgbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgYWxsb3dFbXB0eUFycmF5c2Agb3B0aW9uIGNhbiBvbmx5IGJlIGB0cnVlYCBvciBgZmFsc2VgLCB3aGVuIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmVuY29kZURvdEluS2V5cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuZW5jb2RlRG90SW5LZXlzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGVuY29kZURvdEluS2V5c2Agb3B0aW9uIGNhbiBvbmx5IGJlIGB0cnVlYCBvciBgZmFsc2VgLCB3aGVuIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZW5jb2RlciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRzLmNoYXJzZXQgfHwgZGVmYXVsdHMuY2hhcnNldDtcbiAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjaGFyc2V0IG9wdGlvbiBtdXN0IGJlIGVpdGhlciB1dGYtOCwgaXNvLTg4NTktMSwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcbiAgICBpZiAodHlwZW9mIG9wdHMuZm9ybWF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIWhhcy5jYWxsKGZvcm1hdHMuZm9ybWF0dGVycywgb3B0cy5mb3JtYXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gb3B0cy5mb3JtYXQ7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgIHZhciBmaWx0ZXIgPSBkZWZhdWx0cy5maWx0ZXI7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0FycmF5KG9wdHMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRzLmZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdHMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5hcnJheUZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKCdpbmRpY2VzJyBpbiBvcHRzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBkZWZhdWx0cy5hcnJheUZvcm1hdDtcbiAgICB9XG5cbiAgICBpZiAoJ2NvbW1hUm91bmRUcmlwJyBpbiBvcHRzICYmIHR5cGVvZiBvcHRzLmNvbW1hUm91bmRUcmlwICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGNvbW1hUm91bmRUcmlwYCBtdXN0IGJlIGEgYm9vbGVhbiwgb3IgYWJzZW50Jyk7XG4gICAgfVxuXG4gICAgdmFyIGFsbG93RG90cyA9IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmVuY29kZURvdEluS2V5cyA9PT0gdHJ1ZSA/IHRydWUgOiBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkUXVlcnlQcmVmaXg6IHR5cGVvZiBvcHRzLmFkZFF1ZXJ5UHJlZml4ID09PSAnYm9vbGVhbicgPyBvcHRzLmFkZFF1ZXJ5UHJlZml4IDogZGVmYXVsdHMuYWRkUXVlcnlQcmVmaXgsXG4gICAgICAgIGFsbG93RG90czogYWxsb3dEb3RzLFxuICAgICAgICBhbGxvd0VtcHR5QXJyYXlzOiB0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzID09PSAnYm9vbGVhbicgPyAhIW9wdHMuYWxsb3dFbXB0eUFycmF5cyA6IGRlZmF1bHRzLmFsbG93RW1wdHlBcnJheXMsXG4gICAgICAgIGFycmF5Rm9ybWF0OiBhcnJheUZvcm1hdCxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBjb21tYVJvdW5kVHJpcDogb3B0cy5jb21tYVJvdW5kVHJpcCxcbiAgICAgICAgZGVsaW1pdGVyOiB0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZGVsaW1pdGVyIDogb3B0cy5kZWxpbWl0ZXIsXG4gICAgICAgIGVuY29kZTogdHlwZW9mIG9wdHMuZW5jb2RlID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZSA6IGRlZmF1bHRzLmVuY29kZSxcbiAgICAgICAgZW5jb2RlRG90SW5LZXlzOiB0eXBlb2Ygb3B0cy5lbmNvZGVEb3RJbktleXMgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlRG90SW5LZXlzIDogZGVmYXVsdHMuZW5jb2RlRG90SW5LZXlzLFxuICAgICAgICBlbmNvZGVyOiB0eXBlb2Ygb3B0cy5lbmNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0cy5lbmNvZGVyIDogZGVmYXVsdHMuZW5jb2RlcixcbiAgICAgICAgZW5jb2RlVmFsdWVzT25seTogdHlwZW9mIG9wdHMuZW5jb2RlVmFsdWVzT25seSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGVWYWx1ZXNPbmx5IDogZGVmYXVsdHMuZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICAgICAgc2VyaWFsaXplRGF0ZTogdHlwZW9mIG9wdHMuc2VyaWFsaXplRGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc2VyaWFsaXplRGF0ZSA6IGRlZmF1bHRzLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgIHNraXBOdWxsczogdHlwZW9mIG9wdHMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRzLnNraXBOdWxscyA6IGRlZmF1bHRzLnNraXBOdWxscyxcbiAgICAgICAgc29ydDogdHlwZW9mIG9wdHMuc29ydCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc29ydCA6IG51bGwsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdHMpIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuICAgIHZhciBvcHRpb25zID0gbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyhvcHRzKTtcblxuICAgIHZhciBvYmpLZXlzO1xuICAgIHZhciBmaWx0ZXI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmogPSBmaWx0ZXIoJycsIG9iaik7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyYXRlQXJyYXlQcmVmaXggPSBhcnJheVByZWZpeEdlbmVyYXRvcnNbb3B0aW9ucy5hcnJheUZvcm1hdF07XG4gICAgdmFyIGNvbW1hUm91bmRUcmlwID0gZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBvcHRpb25zLmNvbW1hUm91bmRUcmlwO1xuXG4gICAgaWYgKCFvYmpLZXlzKSB7XG4gICAgICAgIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICAgICAgb2JqS2V5cy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gICAgfVxuXG4gICAgdmFyIHNpZGVDaGFubmVsID0gZ2V0U2lkZUNoYW5uZWwoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoVG9BcnJheShrZXlzLCBzdHJpbmdpZnkoXG4gICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICBjb21tYVJvdW5kVHJpcCxcbiAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgb3B0aW9ucy5za2lwTnVsbHMsXG4gICAgICAgICAgICBvcHRpb25zLmVuY29kZURvdEluS2V5cyxcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jb2RlID8gb3B0aW9ucy5lbmNvZGVyIDogbnVsbCxcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5zb3J0LFxuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd0RvdHMsXG4gICAgICAgICAgICBvcHRpb25zLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBvcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgb3B0aW9ucy5jaGFyc2V0LFxuICAgICAgICAgICAgc2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMuYWRkUXVlcnlQcmVmaXggPT09IHRydWUgPyAnPycgOiAnJztcblxuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKSwgdGhlIFwibnVtZXJpYyBlbnRpdHlcIiByZXByZXNlbnRhdGlvbiBvZiBhIGNoZWNrbWFya1xuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG4gICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JUUyJTlDJTkzJic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgaGV4VGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgYXJyYXkucHVzaCgnJScgKyAoKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpKS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59KCkpO1xuXG52YXIgY29tcGFjdFF1ZXVlID0gZnVuY3Rpb24gY29tcGFjdFF1ZXVlKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBhcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gYXJyYXlUb09iamVjdChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucyAmJiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgIC8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogMCAqL1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgJiYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSkgfHwgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFt0YXJnZXRdLmNvbmNhdChzb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBtZXJnZVRhcmdldCA9IHRhcmdldDtcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmICFpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgbWVyZ2VUYXJnZXQgPSBhcnJheVRvT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbCh0YXJnZXQsIGkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0YXJnZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW0gJiYgdHlwZW9mIHRhcmdldEl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IG1lcmdlKHRhcmdldEl0ZW0sIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaGFzLmNhbGwoYWNjLCBrZXkpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IG1lcmdlKGFjY1trZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbWVyZ2VUYXJnZXQpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnblNpbmdsZVNvdXJjZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB0YXJnZXQpO1xufTtcblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uIChzdHIsIGRlY29kZXIsIGNoYXJzZXQpIHtcbiAgICB2YXIgc3RyV2l0aG91dFBsdXMgPSBzdHIucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAvLyB1bmVzY2FwZSBuZXZlciB0aHJvd3MsIG5vIHRyeS4uLmNhdGNoIG5lZWRlZDpcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzLnJlcGxhY2UoLyVbMC05YS1mXXsyfS9naSwgdW5lc2NhcGUpO1xuICAgIH1cbiAgICAvLyB1dGYtOFxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyV2l0aG91dFBsdXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzO1xuICAgIH1cbn07XG5cbnZhciBsaW1pdCA9IDEwMjQ7XG5cbi8qIGVzbGludCBvcGVyYXRvci1saW5lYnJlYWs6IFsyLCBcImJlZm9yZVwiXSAqL1xuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHN0ciwgZGVmYXVsdEVuY29kZXIsIGNoYXJzZXQsIGtpbmQsIGZvcm1hdCkge1xuICAgIC8vIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEJyaWFuIFdoaXRlIChtc2NkZXgpIGZvciB0aGUgaW8uanMgY29yZSBxdWVyeXN0cmluZyBsaWJyYXJ5LlxuICAgIC8vIEl0IGhhcyBiZWVuIGFkYXB0ZWQgaGVyZSBmb3Igc3RyaWN0ZXIgYWRoZXJlbmNlIHRvIFJGQyAzOTg2XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gc3RyO1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3ltYm9sJykge1xuICAgICAgICBzdHJpbmcgPSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0cmluZyA9IFN0cmluZyhzdHIpO1xuICAgIH1cblxuICAgIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZShzdHJpbmcpLnJlcGxhY2UoLyV1WzAtOWEtZl17NH0vZ2ksIGZ1bmN0aW9uICgkMCkge1xuICAgICAgICAgICAgcmV0dXJuICclMjYlMjMnICsgcGFyc2VJbnQoJDAuc2xpY2UoMiksIDE2KSArICclM0InO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHJpbmcubGVuZ3RoOyBqICs9IGxpbWl0KSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc3RyaW5nLmxlbmd0aCA+PSBsaW1pdCA/IHN0cmluZy5zbGljZShqLCBqICsgbGltaXQpIDogc3RyaW5nO1xuICAgICAgICB2YXIgYXJyID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHNlZ21lbnQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjID09PSAweDJEIC8vIC1cbiAgICAgICAgICAgICAgICB8fCBjID09PSAweDJFIC8vIC5cbiAgICAgICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgICAgICB8fCBjID09PSAweDdFIC8vIH5cbiAgICAgICAgICAgICAgICB8fCAoYyA+PSAweDMwICYmIGMgPD0gMHgzOSkgLy8gMC05XG4gICAgICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgICAgIHx8IChjID49IDB4NjEgJiYgYyA8PSAweDdBKSAvLyBBLVpcbiAgICAgICAgICAgICAgICB8fCAoZm9ybWF0ID09PSBmb3JtYXRzLlJGQzE3MzggJiYgKGMgPT09IDB4MjggfHwgYyA9PT0gMHgyOSkpIC8vICggKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gc2VnbWVudC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIGFyclthcnIubGVuZ3RoXSA9IGhleFRhYmxlW2NdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gaGV4VGFibGVbMHhDMCB8IChjID4+IDYpXVxuICAgICAgICAgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+PSAweEUwMDApIHtcbiAgICAgICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBoZXhUYWJsZVsweEUwIHwgKGMgPj4gMTIpXVxuICAgICAgICAgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV1cbiAgICAgICAgICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M0ZGKSA8PCAxMCkgfCAoc2VnbWVudC5jaGFyQ29kZUF0KGkpICYgMHgzRkYpKTtcblxuICAgICAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cbiAgICAgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzRildXG4gICAgICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildXG4gICAgICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgICAgIH1cblxuICAgICAgICBvdXQgKz0gYXJyLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG52YXIgY29tcGFjdCA9IGZ1bmN0aW9uIGNvbXBhY3QodmFsdWUpIHtcbiAgICB2YXIgcXVldWUgPSBbeyBvYmo6IHsgbzogdmFsdWUgfSwgcHJvcDogJ28nIH1dO1xuICAgIHZhciByZWZzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWVbaV07XG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgcmVmcy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh7IG9iajogb2JqLCBwcm9wOiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wYWN0UXVldWUocXVldWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGlzUmVnRXhwID0gZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn07XG5cbnZhciBpc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG59O1xuXG52YXIgY29tYmluZSA9IGZ1bmN0aW9uIGNvbWJpbmUoYSwgYikge1xuICAgIHJldHVybiBbXS5jb25jYXQoYSwgYik7XG59O1xuXG52YXIgbWF5YmVNYXAgPSBmdW5jdGlvbiBtYXliZU1hcCh2YWwsIGZuKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YXIgbWFwcGVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBtYXBwZWQucHVzaChmbih2YWxbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH1cbiAgICByZXR1cm4gZm4odmFsKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFycmF5VG9PYmplY3Q6IGFycmF5VG9PYmplY3QsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgY29tYmluZTogY29tYmluZSxcbiAgICBjb21wYWN0OiBjb21wYWN0LFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gICAgbWF5YmVNYXA6IG1heWJlTWFwLFxuICAgIG1lcmdlOiBtZXJnZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtZGF0YS1wcm9wZXJ0eScpO1xudmFyIGhhc0Rlc2NyaXB0b3JzID0gcmVxdWlyZSgnaGFzLXByb3BlcnR5LWRlc2NyaXB0b3JzJykoKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZ29wZCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy90eXBlJyk7XG52YXIgJGZsb29yID0gR2V0SW50cmluc2ljKCclTWF0aC5mbG9vciUnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0RnVuY3Rpb25MZW5ndGgoZm4sIGxlbmd0aCkge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BmbmAgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0fVxuXHRpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgbGVuZ3RoIDwgMCB8fCBsZW5ndGggPiAweEZGRkZGRkZGIHx8ICRmbG9vcihsZW5ndGgpICE9PSBsZW5ndGgpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGxlbmd0aGAgbXVzdCBiZSBhIHBvc2l0aXZlIDMyLWJpdCBpbnRlZ2VyJyk7XG5cdH1cblxuXHR2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiAhIWFyZ3VtZW50c1syXTtcblxuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdHZhciBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSB0cnVlO1xuXHRpZiAoJ2xlbmd0aCcgaW4gZm4gJiYgZ09QRCkge1xuXHRcdHZhciBkZXNjID0gZ09QRChmbiwgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0ZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoZGVzYyAmJiAhZGVzYy53cml0YWJsZSkge1xuXHRcdFx0ZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgfHwgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlIHx8ICFsb29zZSkge1xuXHRcdGlmIChoYXNEZXNjcmlwdG9ycykge1xuXHRcdFx0ZGVmaW5lKC8qKiBAdHlwZSB7UGFyYW1ldGVyczxkZWZpbmU+WzBdfSAqLyAoZm4pLCAnbGVuZ3RoJywgbGVuZ3RoLCB0cnVlLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVmaW5lKC8qKiBAdHlwZSB7UGFyYW1ldGVyczxkZWZpbmU+WzBdfSAqLyAoZm4pLCAnbGVuZ3RoJywgbGVuZ3RoKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcbnZhciAkV2Vha01hcCA9IEdldEludHJpbnNpYygnJVdlYWtNYXAlJywgdHJ1ZSk7XG52YXIgJE1hcCA9IEdldEludHJpbnNpYygnJU1hcCUnLCB0cnVlKTtcblxudmFyICR3ZWFrTWFwR2V0ID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbnZhciAkd2Vha01hcFNldCA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuc2V0JywgdHJ1ZSk7XG52YXIgJHdlYWtNYXBIYXMgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLmhhcycsIHRydWUpO1xudmFyICRtYXBHZXQgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuZ2V0JywgdHJ1ZSk7XG52YXIgJG1hcFNldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5zZXQnLCB0cnVlKTtcbnZhciAkbWFwSGFzID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmhhcycsIHRydWUpO1xuXG4vKlxuKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aGUgbGlzdCByZXR1cm5pbmcgdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4ga2V5LlxuKlxuKiBUaGF0IG5vZGUgaXMgYWxzbyBtb3ZlZCB0byB0aGUgaGVhZCBvZiB0aGUgbGlzdCwgc28gdGhhdCBpZiBpdCdzIGFjY2Vzc2VkIGFnYWluIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHdob2xlIGxpc3QuIEJ5IGRvaW5nIHNvLCBhbGwgdGhlIHJlY2VudGx5IHVzZWQgbm9kZXMgY2FuIGJlIGFjY2Vzc2VkIHJlbGF0aXZlbHkgcXVpY2tseS5cbiovXG4vKiogQHR5cGUge2ltcG9ydCgnLicpLmxpc3RHZXROb2RlfSAqL1xudmFyIGxpc3RHZXROb2RlID0gZnVuY3Rpb24gKGxpc3QsIGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdC8qKiBAdHlwZSB7dHlwZW9mIGxpc3QgfCBOb25OdWxsYWJsZTwodHlwZW9mIGxpc3QpWyduZXh0J10+fSAqL1xuXHR2YXIgcHJldiA9IGxpc3Q7XG5cdC8qKiBAdHlwZSB7KHR5cGVvZiBsaXN0KVsnbmV4dCddfSAqL1xuXHR2YXIgY3Vycjtcblx0Zm9yICg7IChjdXJyID0gcHJldi5uZXh0KSAhPT0gbnVsbDsgcHJldiA9IGN1cnIpIHtcblx0XHRpZiAoY3Vyci5rZXkgPT09IGtleSkge1xuXHRcdFx0cHJldi5uZXh0ID0gY3Vyci5uZXh0O1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuXHRcdFx0Y3Vyci5uZXh0ID0gLyoqIEB0eXBlIHtOb25OdWxsYWJsZTx0eXBlb2YgbGlzdC5uZXh0Pn0gKi8gKGxpc3QubmV4dCk7XG5cdFx0XHRsaXN0Lm5leHQgPSBjdXJyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0XHRyZXR1cm4gY3Vycjtcblx0XHR9XG5cdH1cbn07XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJykubGlzdEdldH0gKi9cbnZhciBsaXN0R2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdHJldHVybiBub2RlICYmIG5vZGUudmFsdWU7XG59O1xuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKS5saXN0U2V0fSAqL1xudmFyIGxpc3RTZXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5LCB2YWx1ZSkge1xuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdGlmIChub2RlKSB7XG5cdFx0bm9kZS52YWx1ZSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFByZXBlbmQgdGhlIG5ldyBub2RlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3Rcblx0XHRvYmplY3RzLm5leHQgPSAvKiogQHR5cGUge2ltcG9ydCgnLicpLkxpc3ROb2RlPHR5cGVvZiB2YWx1ZT59ICovICh7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIG5vLWV4dHJhLXBhcmVuc1xuXHRcdFx0a2V5OiBrZXksXG5cdFx0XHRuZXh0OiBvYmplY3RzLm5leHQsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9KTtcblx0fVxufTtcbi8qKiBAdHlwZSB7aW1wb3J0KCcuJykubGlzdEhhc30gKi9cbnZhciBsaXN0SGFzID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHRyZXR1cm4gISFsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2lkZUNoYW5uZWwoKSB7XG5cdC8qKiBAdHlwZSB7V2Vha01hcDxvYmplY3QsIHVua25vd24+fSAqLyB2YXIgJHdtO1xuXHQvKiogQHR5cGUge01hcDxvYmplY3QsIHVua25vd24+fSAqLyB2YXIgJG07XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuJykuUm9vdE5vZGU8dW5rbm93bj59ICovIHZhciAkbztcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnLicpLkNoYW5uZWx9ICovXG5cdHZhciBjaGFubmVsID0ge1xuXHRcdGFzc2VydDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCFjaGFubmVsLmhhcyhrZXkpKSB7XG5cdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdTaWRlIGNoYW5uZWwgZG9lcyBub3QgY29udGFpbiAnICsgaW5zcGVjdChrZXkpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldDogZnVuY3Rpb24gKGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoJHdtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICR3ZWFrTWFwR2V0KCR3bSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICgkbSkge1xuXHRcdFx0XHRcdHJldHVybiAkbWFwR2V0KCRtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRyZXR1cm4gbGlzdEdldCgkbywga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGFzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoJHdtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICR3ZWFrTWFwSGFzKCR3bSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICgkbSkge1xuXHRcdFx0XHRcdHJldHVybiAkbWFwSGFzKCRtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRyZXR1cm4gbGlzdEhhcygkbywga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCEkd20pIHtcblx0XHRcdFx0XHQkd20gPSBuZXcgJFdlYWtNYXAoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkd2Vha01hcFNldCgkd20sIGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICghJG0pIHtcblx0XHRcdFx0XHQkbSA9IG5ldyAkTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JG1hcFNldCgkbSwga2V5LCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoISRvKSB7XG5cdFx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgbGlua2VkIGxpc3QgYXMgYW4gZW1wdHkgbm9kZSwgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHNwZWNpYWwtY2FzZSBoYW5kbGluZyBvZiB0aGUgZmlyc3Qgbm9kZTogd2UgY2FuIGFsd2F5cyByZWZlciB0byBpdCBhcyAocHJldmlvdXMgbm9kZSkubmV4dCwgaW5zdGVhZCBvZiBzb21ldGhpbmcgbGlrZSAobGlzdCkuaGVhZFxuXHRcdFx0XHRcdCRvID0geyBrZXk6IHt9LCBuZXh0OiBudWxsIH07XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdFNldCgkbywga2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gY2hhbm5lbDtcbn07XG4iLCIvKlxuICAgICBfIF8gICAgICBfICAgICAgIF9cbiBfX198IChfKSBfX198IHwgX18gIChfKV9fX1xuLyBfX3wgfCB8LyBfX3wgfC8gLyAgfCAvIF9ffFxuXFxfXyBcXCB8IHwgKF9ffCAgIDwgXyB8IFxcX18gXFxcbnxfX18vX3xffFxcX19ffF98XFxfKF8pLyB8X19fL1xuICAgICAgICAgICAgICAgICAgIHxfXy9cblxuIFZlcnNpb246IDEuOC4xXG4gIEF1dGhvcjogS2VuIFdoZWVsZXJcbiBXZWJzaXRlOiBodHRwOi8va2Vud2hlZWxlci5naXRodWIuaW9cbiAgICBEb2NzOiBodHRwOi8va2Vud2hlZWxlci5naXRodWIuaW8vc2xpY2tcbiAgICBSZXBvOiBodHRwOi8vZ2l0aHViLmNvbS9rZW53aGVlbGVyL3NsaWNrXG4gIElzc3VlczogaHR0cDovL2dpdGh1Yi5jb20va2Vud2hlZWxlci9zbGljay9pc3N1ZXNcblxuICovXG4vKiBnbG9iYWwgd2luZG93LCBkb2N1bWVudCwgZGVmaW5lLCBqUXVlcnksIHNldEludGVydmFsLCBjbGVhckludGVydmFsICovXG47KGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KGpRdWVyeSk7XG4gICAgfVxuXG59KGZ1bmN0aW9uKCQpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIFNsaWNrID0gd2luZG93LlNsaWNrIHx8IHt9O1xuXG4gICAgU2xpY2sgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGluc3RhbmNlVWlkID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBTbGljayhlbGVtZW50LCBzZXR0aW5ncykge1xuXG4gICAgICAgICAgICB2YXIgXyA9IHRoaXMsIGRhdGFTZXR0aW5ncztcblxuICAgICAgICAgICAgXy5kZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGFkYXB0aXZlSGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhcHBlbmRBcnJvd3M6ICQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgYXBwZW5kRG90czogJChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBhcnJvd3M6IHRydWUsXG4gICAgICAgICAgICAgICAgYXNOYXZGb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldkFycm93OiAnPGJ1dHRvbiBjbGFzcz1cInNsaWNrLXByZXZcIiBhcmlhLWxhYmVsPVwiUHJldmlvdXNcIiB0eXBlPVwiYnV0dG9uXCI+UHJldmlvdXM8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgIG5leHRBcnJvdzogJzxidXR0b24gY2xhc3M9XCJzbGljay1uZXh0XCIgYXJpYS1sYWJlbD1cIk5leHRcIiB0eXBlPVwiYnV0dG9uXCI+TmV4dDwvYnV0dG9uPicsXG4gICAgICAgICAgICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF1dG9wbGF5U3BlZWQ6IDMwMDAsXG4gICAgICAgICAgICAgICAgY2VudGVyTW9kZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2VudGVyUGFkZGluZzogJzUwcHgnLFxuICAgICAgICAgICAgICAgIGNzc0Vhc2U6ICdlYXNlJyxcbiAgICAgICAgICAgICAgICBjdXN0b21QYWdpbmc6IGZ1bmN0aW9uKHNsaWRlciwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgLz4nKS50ZXh0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRvdHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRvdHNDbGFzczogJ3NsaWNrLWRvdHMnLFxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgICAgICAgIGVkZ2VGcmljdGlvbjogMC4zNSxcbiAgICAgICAgICAgICAgICBmYWRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb2N1c09uU2VsZWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb2N1c09uQ2hhbmdlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbmZpbml0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbml0aWFsU2xpZGU6IDAsXG4gICAgICAgICAgICAgICAgbGF6eUxvYWQ6ICdvbmRlbWFuZCcsXG4gICAgICAgICAgICAgICAgbW9iaWxlRmlyc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhdXNlT25Ib3ZlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXVzZU9uRm9jdXM6IHRydWUsXG4gICAgICAgICAgICAgICAgcGF1c2VPbkRvdHNIb3ZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVzcG9uZFRvOiAnd2luZG93JyxcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlOiBudWxsLFxuICAgICAgICAgICAgICAgIHJvd3M6IDEsXG4gICAgICAgICAgICAgICAgcnRsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzbGlkZTogJycsXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyUm93OiAxLFxuICAgICAgICAgICAgICAgIHNsaWRlc1RvU2hvdzogMSxcbiAgICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbDogMSxcbiAgICAgICAgICAgICAgICBzcGVlZDogNTAwLFxuICAgICAgICAgICAgICAgIHN3aXBlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN3aXBlVG9TbGlkZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdG91Y2hNb3ZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRvdWNoVGhyZXNob2xkOiA1LFxuICAgICAgICAgICAgICAgIHVzZUNTUzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1c2VUcmFuc2Zvcm06IHRydWUsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVXaWR0aDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsU3dpcGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FpdEZvckFuaW1hdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgekluZGV4OiAxMDAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfLmluaXRpYWxzID0ge1xuICAgICAgICAgICAgICAgIGFuaW1hdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF1dG9QbGF5VGltZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudERpcmVjdGlvbjogMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVmdDogbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50U2xpZGU6IDAsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAxLFxuICAgICAgICAgICAgICAgICRkb3RzOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpc3RXaWR0aDogbnVsbCxcbiAgICAgICAgICAgICAgICBsaXN0SGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgICAgIGxvYWRJbmRleDogMCxcbiAgICAgICAgICAgICAgICAkbmV4dEFycm93OiBudWxsLFxuICAgICAgICAgICAgICAgICRwcmV2QXJyb3c6IG51bGwsXG4gICAgICAgICAgICAgICAgc2Nyb2xsaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzbGlkZUNvdW50OiBudWxsLFxuICAgICAgICAgICAgICAgIHNsaWRlV2lkdGg6IG51bGwsXG4gICAgICAgICAgICAgICAgJHNsaWRlVHJhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgJHNsaWRlczogbnVsbCxcbiAgICAgICAgICAgICAgICBzbGlkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzbGlkZU9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBzd2lwZUxlZnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc3dpcGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJGxpc3Q6IG51bGwsXG4gICAgICAgICAgICAgICAgdG91Y2hPYmplY3Q6IHt9LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybXNFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bnNsaWNrZWQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkLmV4dGVuZChfLCBfLmluaXRpYWxzKTtcblxuICAgICAgICAgICAgXy5hY3RpdmVCcmVha3BvaW50ID0gbnVsbDtcbiAgICAgICAgICAgIF8uYW5pbVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgXy5hbmltUHJvcCA9IG51bGw7XG4gICAgICAgICAgICBfLmJyZWFrcG9pbnRzID0gW107XG4gICAgICAgICAgICBfLmJyZWFrcG9pbnRTZXR0aW5ncyA9IFtdO1xuICAgICAgICAgICAgXy5jc3NUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgXy5mb2N1c3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgXy5oaWRkZW4gPSAnaGlkZGVuJztcbiAgICAgICAgICAgIF8ucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIF8ucG9zaXRpb25Qcm9wID0gbnVsbDtcbiAgICAgICAgICAgIF8ucmVzcG9uZFRvID0gbnVsbDtcbiAgICAgICAgICAgIF8ucm93Q291bnQgPSAxO1xuICAgICAgICAgICAgXy5zaG91bGRDbGljayA9IHRydWU7XG4gICAgICAgICAgICBfLiRzbGlkZXIgPSAkKGVsZW1lbnQpO1xuICAgICAgICAgICAgXy4kc2xpZGVzQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gbnVsbDtcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSBudWxsO1xuICAgICAgICAgICAgXy52aXNpYmlsaXR5Q2hhbmdlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgXy53aW5kb3dXaWR0aCA9IDA7XG4gICAgICAgICAgICBfLndpbmRvd1RpbWVyID0gbnVsbDtcblxuICAgICAgICAgICAgZGF0YVNldHRpbmdzID0gJChlbGVtZW50KS5kYXRhKCdzbGljaycpIHx8IHt9O1xuXG4gICAgICAgICAgICBfLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgXy5kZWZhdWx0cywgc2V0dGluZ3MsIGRhdGFTZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gXy5vcHRpb25zLmluaXRpYWxTbGlkZTtcblxuICAgICAgICAgICAgXy5vcmlnaW5hbFNldHRpbmdzID0gXy5vcHRpb25zO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50Lm1vekhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBfLmhpZGRlbiA9ICdtb3pIaWRkZW4nO1xuICAgICAgICAgICAgICAgIF8udmlzaWJpbGl0eUNoYW5nZSA9ICdtb3p2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBfLmhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xuICAgICAgICAgICAgICAgIF8udmlzaWJpbGl0eUNoYW5nZSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5hdXRvUGxheSA9ICQucHJveHkoXy5hdXRvUGxheSwgXyk7XG4gICAgICAgICAgICBfLmF1dG9QbGF5Q2xlYXIgPSAkLnByb3h5KF8uYXV0b1BsYXlDbGVhciwgXyk7XG4gICAgICAgICAgICBfLmF1dG9QbGF5SXRlcmF0b3IgPSAkLnByb3h5KF8uYXV0b1BsYXlJdGVyYXRvciwgXyk7XG4gICAgICAgICAgICBfLmNoYW5nZVNsaWRlID0gJC5wcm94eShfLmNoYW5nZVNsaWRlLCBfKTtcbiAgICAgICAgICAgIF8uY2xpY2tIYW5kbGVyID0gJC5wcm94eShfLmNsaWNrSGFuZGxlciwgXyk7XG4gICAgICAgICAgICBfLnNlbGVjdEhhbmRsZXIgPSAkLnByb3h5KF8uc2VsZWN0SGFuZGxlciwgXyk7XG4gICAgICAgICAgICBfLnNldFBvc2l0aW9uID0gJC5wcm94eShfLnNldFBvc2l0aW9uLCBfKTtcbiAgICAgICAgICAgIF8uc3dpcGVIYW5kbGVyID0gJC5wcm94eShfLnN3aXBlSGFuZGxlciwgXyk7XG4gICAgICAgICAgICBfLmRyYWdIYW5kbGVyID0gJC5wcm94eShfLmRyYWdIYW5kbGVyLCBfKTtcbiAgICAgICAgICAgIF8ua2V5SGFuZGxlciA9ICQucHJveHkoXy5rZXlIYW5kbGVyLCBfKTtcblxuICAgICAgICAgICAgXy5pbnN0YW5jZVVpZCA9IGluc3RhbmNlVWlkKys7XG5cbiAgICAgICAgICAgIC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG4gICAgICAgICAgICAvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAobXVzdCBzdGFydCB3aXRoIDwpXG4gICAgICAgICAgICAvLyBFeHRyYWN0ZWQgZnJvbSBqUXVlcnkgdjEuMTEgc291cmNlXG4gICAgICAgICAgICBfLmh0bWxFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qKSQvO1xuXG5cbiAgICAgICAgICAgIF8ucmVnaXN0ZXJCcmVha3BvaW50cygpO1xuICAgICAgICAgICAgXy5pbml0KHRydWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU2xpY2s7XG5cbiAgICB9KCkpO1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmFjdGl2YXRlQURBID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLiRzbGlkZVRyYWNrLmZpbmQoJy5zbGljay1hY3RpdmUnKS5hdHRyKHtcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6ICdmYWxzZSdcbiAgICAgICAgfSkuZmluZCgnYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0JykuYXR0cih7XG4gICAgICAgICAgICAndGFiaW5kZXgnOiAnMCdcbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmFkZFNsaWRlID0gU2xpY2sucHJvdG90eXBlLnNsaWNrQWRkID0gZnVuY3Rpb24obWFya3VwLCBpbmRleCwgYWRkQmVmb3JlKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICh0eXBlb2YoaW5kZXgpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGFkZEJlZm9yZSA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgMCB8fCAoaW5kZXggPj0gXy5zbGlkZUNvdW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgXy51bmxvYWQoKTtcblxuICAgICAgICBpZiAodHlwZW9mKGluZGV4KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBfLiRzbGlkZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgJChtYXJrdXApLmFwcGVuZFRvKF8uJHNsaWRlVHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhZGRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAkKG1hcmt1cCkuaW5zZXJ0QmVmb3JlKF8uJHNsaWRlcy5lcShpbmRleCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKG1hcmt1cCkuaW5zZXJ0QWZ0ZXIoXy4kc2xpZGVzLmVxKGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWRkQmVmb3JlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgJChtYXJrdXApLnByZXBlbmRUbyhfLiRzbGlkZVRyYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChtYXJrdXApLmFwcGVuZFRvKF8uJHNsaWRlVHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVzID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrLmFwcGVuZChfLiRzbGlkZXMpO1xuXG4gICAgICAgIF8uJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAkKGVsZW1lbnQpLmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnLCBpbmRleCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uJHNsaWRlc0NhY2hlID0gXy4kc2xpZGVzO1xuXG4gICAgICAgIF8ucmVpbml0KCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmFuaW1hdGVIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuICAgICAgICBpZiAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA9PT0gMSAmJiBfLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQgPT09IHRydWUgJiYgXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEhlaWdodCA9IF8uJHNsaWRlcy5lcShfLmN1cnJlbnRTbGlkZSkub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgICAgICAgICBfLiRsaXN0LmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIGhlaWdodDogdGFyZ2V0SGVpZ2h0XG4gICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hbmltYXRlU2xpZGUgPSBmdW5jdGlvbih0YXJnZXRMZWZ0LCBjYWxsYmFjaykge1xuXG4gICAgICAgIHZhciBhbmltUHJvcHMgPSB7fSxcbiAgICAgICAgICAgIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uYW5pbWF0ZUhlaWdodCgpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlICYmIF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRhcmdldExlZnQgPSAtdGFyZ2V0TGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy50cmFuc2Zvcm1zRW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGFyZ2V0TGVmdFxuICAgICAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCwgXy5vcHRpb25zLmVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHRhcmdldExlZnRcbiAgICAgICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQsIF8ub3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoXy5jc3NUcmFuc2l0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnRMZWZ0ID0gLShfLmN1cnJlbnRMZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJCh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1TdGFydDogXy5jdXJyZW50TGVmdFxuICAgICAgICAgICAgICAgIH0pLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICAgICBhbmltU3RhcnQ6IHRhcmdldExlZnRcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBfLm9wdGlvbnMuc3BlZWQsXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZzogXy5vcHRpb25zLmVhc2luZyxcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogZnVuY3Rpb24obm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBNYXRoLmNlaWwobm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZSgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ICsgJ3B4LCAwcHgpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhhbmltUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltUHJvcHNbXy5hbmltVHlwZV0gPSAndHJhbnNsYXRlKDBweCwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ICsgJ3B4KSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MoYW5pbVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBfLmFwcGx5VHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSBNYXRoLmNlaWwodGFyZ2V0TGVmdCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBhbmltUHJvcHNbXy5hbmltVHlwZV0gPSAndHJhbnNsYXRlM2QoJyArIHRhcmdldExlZnQgKyAncHgsIDBweCwgMHB4KSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZTNkKDBweCwnICsgdGFyZ2V0TGVmdCArICdweCwgMHB4KSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKGFuaW1Qcm9wcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXy5kaXNhYmxlVHJhbnNpdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXROYXZUYXJnZXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBhc05hdkZvciA9IF8ub3B0aW9ucy5hc05hdkZvcjtcblxuICAgICAgICBpZiAoIGFzTmF2Rm9yICYmIGFzTmF2Rm9yICE9PSBudWxsICkge1xuICAgICAgICAgICAgYXNOYXZGb3IgPSAkKGFzTmF2Rm9yKS5ub3QoXy4kc2xpZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc05hdkZvcjtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYXNOYXZGb3IgPSBmdW5jdGlvbihpbmRleCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGFzTmF2Rm9yID0gXy5nZXROYXZUYXJnZXQoKTtcblxuICAgICAgICBpZiAoIGFzTmF2Rm9yICE9PSBudWxsICYmIHR5cGVvZiBhc05hdkZvciA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICBhc05hdkZvci5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAkKHRoaXMpLnNsaWNrKCdnZXRTbGljaycpO1xuICAgICAgICAgICAgICAgIGlmKCF0YXJnZXQudW5zbGlja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5zbGlkZUhhbmRsZXIoaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmFwcGx5VHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHNsaWRlKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHt9O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25bXy50cmFuc2l0aW9uVHlwZV0gPSBfLnRyYW5zZm9ybVR5cGUgKyAnICcgKyBfLm9wdGlvbnMuc3BlZWQgKyAnbXMgJyArIF8ub3B0aW9ucy5jc3NFYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNpdGlvbltfLnRyYW5zaXRpb25UeXBlXSA9ICdvcGFjaXR5ICcgKyBfLm9wdGlvbnMuc3BlZWQgKyAnbXMgJyArIF8ub3B0aW9ucy5jc3NFYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3ModHJhbnNpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGUpLmNzcyh0cmFuc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hdXRvUGxheSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmF1dG9QbGF5Q2xlYXIoKTtcblxuICAgICAgICBpZiAoIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKSB7XG4gICAgICAgICAgICBfLmF1dG9QbGF5VGltZXIgPSBzZXRJbnRlcnZhbCggXy5hdXRvUGxheUl0ZXJhdG9yLCBfLm9wdGlvbnMuYXV0b3BsYXlTcGVlZCApO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmF1dG9QbGF5Q2xlYXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uYXV0b1BsYXlUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfLmF1dG9QbGF5VGltZXIpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmF1dG9QbGF5SXRlcmF0b3IgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBzbGlkZVRvID0gXy5jdXJyZW50U2xpZGUgKyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG5cbiAgICAgICAgaWYgKCAhXy5wYXVzZWQgJiYgIV8uaW50ZXJydXB0ZWQgJiYgIV8uZm9jdXNzZWQgKSB7XG5cbiAgICAgICAgICAgIGlmICggXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggXy5kaXJlY3Rpb24gPT09IDEgJiYgKCBfLmN1cnJlbnRTbGlkZSArIDEgKSA9PT0gKCBfLnNsaWRlQ291bnQgLSAxICkpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5kaXJlY3Rpb24gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBfLmRpcmVjdGlvbiA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBzbGlkZVRvID0gXy5jdXJyZW50U2xpZGUgLSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBfLmN1cnJlbnRTbGlkZSAtIDEgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmRpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLnNsaWRlSGFuZGxlciggc2xpZGVUbyApO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYnVpbGRBcnJvd3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hcnJvd3MgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgIF8uJHByZXZBcnJvdyA9ICQoXy5vcHRpb25zLnByZXZBcnJvdykuYWRkQ2xhc3MoJ3NsaWNrLWFycm93Jyk7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3cgPSAkKF8ub3B0aW9ucy5uZXh0QXJyb3cpLmFkZENsYXNzKCdzbGljay1hcnJvdycpO1xuXG4gICAgICAgICAgICBpZiggXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyApIHtcblxuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2staGlkZGVuJykucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4gdGFiaW5kZXgnKTtcbiAgICAgICAgICAgICAgICBfLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWhpZGRlbicpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuIHRhYmluZGV4Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5odG1sRXhwci50ZXN0KF8ub3B0aW9ucy5wcmV2QXJyb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5wcmVwZW5kVG8oXy5vcHRpb25zLmFwcGVuZEFycm93cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF8uaHRtbEV4cHIudGVzdChfLm9wdGlvbnMubmV4dEFycm93KSkge1xuICAgICAgICAgICAgICAgICAgICBfLiRuZXh0QXJyb3cuYXBwZW5kVG8oXy5vcHRpb25zLmFwcGVuZEFycm93cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stZGlzYWJsZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5hZGQoIF8uJG5leHRBcnJvdyApXG5cbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1oaWRkZW4nKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0YWJpbmRleCc6ICctMSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmJ1aWxkRG90cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGksIGRvdDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRvdHMgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXIuYWRkQ2xhc3MoJ3NsaWNrLWRvdHRlZCcpO1xuXG4gICAgICAgICAgICBkb3QgPSAkKCc8dWwgLz4nKS5hZGRDbGFzcyhfLm9wdGlvbnMuZG90c0NsYXNzKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBfLmdldERvdENvdW50KCk7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGRvdC5hcHBlbmQoJCgnPGxpIC8+JykuYXBwZW5kKF8ub3B0aW9ucy5jdXN0b21QYWdpbmcuY2FsbCh0aGlzLCBfLCBpKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLiRkb3RzID0gZG90LmFwcGVuZFRvKF8ub3B0aW9ucy5hcHBlbmREb3RzKTtcblxuICAgICAgICAgICAgXy4kZG90cy5maW5kKCdsaScpLmZpcnN0KCkuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYnVpbGRPdXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kc2xpZGVzID1cbiAgICAgICAgICAgIF8uJHNsaWRlclxuICAgICAgICAgICAgICAgIC5jaGlsZHJlbiggXy5vcHRpb25zLnNsaWRlICsgJzpub3QoLnNsaWNrLWNsb25lZCknKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stc2xpZGUnKTtcblxuICAgICAgICBfLnNsaWRlQ291bnQgPSBfLiRzbGlkZXMubGVuZ3RoO1xuXG4gICAgICAgIF8uJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnLCBpbmRleClcbiAgICAgICAgICAgICAgICAuZGF0YSgnb3JpZ2luYWxTdHlsaW5nJywgJChlbGVtZW50KS5hdHRyKCdzdHlsZScpIHx8ICcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy4kc2xpZGVyLmFkZENsYXNzKCdzbGljay1zbGlkZXInKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrID0gKF8uc2xpZGVDb3VudCA9PT0gMCkgP1xuICAgICAgICAgICAgJCgnPGRpdiBjbGFzcz1cInNsaWNrLXRyYWNrXCIvPicpLmFwcGVuZFRvKF8uJHNsaWRlcikgOlxuICAgICAgICAgICAgXy4kc2xpZGVzLndyYXBBbGwoJzxkaXYgY2xhc3M9XCJzbGljay10cmFja1wiLz4nKS5wYXJlbnQoKTtcblxuICAgICAgICBfLiRsaXN0ID0gXy4kc2xpZGVUcmFjay53cmFwKFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJzbGljay1saXN0XCIvPicpLnBhcmVudCgpO1xuICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcygnb3BhY2l0eScsIDApO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSB8fCBfLm9wdGlvbnMuc3dpcGVUb1NsaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgJCgnaW1nW2RhdGEtbGF6eV0nLCBfLiRzbGlkZXIpLm5vdCgnW3NyY10nKS5hZGRDbGFzcygnc2xpY2stbG9hZGluZycpO1xuXG4gICAgICAgIF8uc2V0dXBJbmZpbml0ZSgpO1xuXG4gICAgICAgIF8uYnVpbGRBcnJvd3MoKTtcblxuICAgICAgICBfLmJ1aWxkRG90cygpO1xuXG4gICAgICAgIF8udXBkYXRlRG90cygpO1xuXG5cbiAgICAgICAgXy5zZXRTbGlkZUNsYXNzZXModHlwZW9mIF8uY3VycmVudFNsaWRlID09PSAnbnVtYmVyJyA/IF8uY3VycmVudFNsaWRlIDogMCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kcmFnZ2FibGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJGxpc3QuYWRkQ2xhc3MoJ2RyYWdnYWJsZScpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmJ1aWxkUm93cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcywgYSwgYiwgYywgbmV3U2xpZGVzLCBudW1PZlNsaWRlcywgb3JpZ2luYWxTbGlkZXMsc2xpZGVzUGVyU2VjdGlvbjtcblxuICAgICAgICBuZXdTbGlkZXMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIG9yaWdpbmFsU2xpZGVzID0gXy4kc2xpZGVyLmNoaWxkcmVuKCk7XG5cbiAgICAgICAgaWYoXy5vcHRpb25zLnJvd3MgPiAwKSB7XG5cbiAgICAgICAgICAgIHNsaWRlc1BlclNlY3Rpb24gPSBfLm9wdGlvbnMuc2xpZGVzUGVyUm93ICogXy5vcHRpb25zLnJvd3M7XG4gICAgICAgICAgICBudW1PZlNsaWRlcyA9IE1hdGguY2VpbChcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFNsaWRlcy5sZW5ndGggLyBzbGlkZXNQZXJTZWN0aW9uXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmb3IoYSA9IDA7IGEgPCBudW1PZlNsaWRlczsgYSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgc2xpZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBmb3IoYiA9IDA7IGIgPCBfLm9wdGlvbnMucm93czsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGMgPSAwOyBjIDwgXy5vcHRpb25zLnNsaWRlc1BlclJvdzsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gKGEgKiBzbGlkZXNQZXJTZWN0aW9uICsgKChiICogXy5vcHRpb25zLnNsaWRlc1BlclJvdykgKyBjKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxTbGlkZXMuZ2V0KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQob3JpZ2luYWxTbGlkZXMuZ2V0KHRhcmdldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlLmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NsaWRlcy5hcHBlbmRDaGlsZChzbGlkZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uJHNsaWRlci5lbXB0eSgpLmFwcGVuZChuZXdTbGlkZXMpO1xuICAgICAgICAgICAgXy4kc2xpZGVyLmNoaWxkcmVuKCkuY2hpbGRyZW4oKS5jaGlsZHJlbigpXG4gICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6KDEwMCAvIF8ub3B0aW9ucy5zbGlkZXNQZXJSb3cpICsgJyUnLFxuICAgICAgICAgICAgICAgICAgICAnZGlzcGxheSc6ICdpbmxpbmUtYmxvY2snXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jaGVja1Jlc3BvbnNpdmUgPSBmdW5jdGlvbihpbml0aWFsLCBmb3JjZVVwZGF0ZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGJyZWFrcG9pbnQsIHRhcmdldEJyZWFrcG9pbnQsIHJlc3BvbmRUb1dpZHRoLCB0cmlnZ2VyQnJlYWtwb2ludCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2xpZGVyV2lkdGggPSBfLiRzbGlkZXIud2lkdGgoKTtcbiAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgJCh3aW5kb3cpLndpZHRoKCk7XG5cbiAgICAgICAgaWYgKF8ucmVzcG9uZFRvID09PSAnd2luZG93Jykge1xuICAgICAgICAgICAgcmVzcG9uZFRvV2lkdGggPSB3aW5kb3dXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChfLnJlc3BvbmRUbyA9PT0gJ3NsaWRlcicpIHtcbiAgICAgICAgICAgIHJlc3BvbmRUb1dpZHRoID0gc2xpZGVyV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5yZXNwb25kVG8gPT09ICdtaW4nKSB7XG4gICAgICAgICAgICByZXNwb25kVG9XaWR0aCA9IE1hdGgubWluKHdpbmRvd1dpZHRoLCBzbGlkZXJXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5yZXNwb25zaXZlICYmXG4gICAgICAgICAgICBfLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGggJiZcbiAgICAgICAgICAgIF8ub3B0aW9ucy5yZXNwb25zaXZlICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKGJyZWFrcG9pbnQgaW4gXy5icmVha3BvaW50cykge1xuICAgICAgICAgICAgICAgIGlmIChfLmJyZWFrcG9pbnRzLmhhc093blByb3BlcnR5KGJyZWFrcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLm9yaWdpbmFsU2V0dGluZ3MubW9iaWxlRmlyc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uZFRvV2lkdGggPCBfLmJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludCA9IF8uYnJlYWtwb2ludHNbYnJlYWtwb2ludF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uZFRvV2lkdGggPiBfLmJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludCA9IF8uYnJlYWtwb2ludHNbYnJlYWtwb2ludF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRCcmVha3BvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uYWN0aXZlQnJlYWtwb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0QnJlYWtwb2ludCAhPT0gXy5hY3RpdmVCcmVha3BvaW50IHx8IGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmFjdGl2ZUJyZWFrcG9pbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5icmVha3BvaW50U2V0dGluZ3NbdGFyZ2V0QnJlYWtwb2ludF0gPT09ICd1bnNsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8udW5zbGljayh0YXJnZXRCcmVha3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zID0gJC5leHRlbmQoe30sIF8ub3JpZ2luYWxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50U2V0dGluZ3NbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCcmVha3BvaW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLm9wdGlvbnMuaW5pdGlhbFNsaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLnJlZnJlc2goaW5pdGlhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQnJlYWtwb2ludCA9IHRhcmdldEJyZWFrcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfLmFjdGl2ZUJyZWFrcG9pbnQgPSB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5icmVha3BvaW50U2V0dGluZ3NbdGFyZ2V0QnJlYWtwb2ludF0gPT09ICd1bnNsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy51bnNsaWNrKHRhcmdldEJyZWFrcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zID0gJC5leHRlbmQoe30sIF8ub3JpZ2luYWxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmJyZWFrcG9pbnRTZXR0aW5nc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IF8ub3B0aW9ucy5pbml0aWFsU2xpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnJlZnJlc2goaW5pdGlhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckJyZWFrcG9pbnQgPSB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uYWN0aXZlQnJlYWtwb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfLmFjdGl2ZUJyZWFrcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMgPSBfLm9yaWdpbmFsU2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IF8ub3B0aW9ucy5pbml0aWFsU2xpZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXy5yZWZyZXNoKGluaXRpYWwpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQnJlYWtwb2ludCA9IHRhcmdldEJyZWFrcG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbmx5IHRyaWdnZXIgYnJlYWtwb2ludHMgZHVyaW5nIGFuIGFjdHVhbCBicmVhay4gbm90IG9uIGluaXRpYWxpemUuXG4gICAgICAgICAgICBpZiggIWluaXRpYWwgJiYgdHJpZ2dlckJyZWFrcG9pbnQgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdicmVha3BvaW50JywgW18sIHRyaWdnZXJCcmVha3BvaW50XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2hhbmdlU2xpZGUgPSBmdW5jdGlvbihldmVudCwgZG9udEFuaW1hdGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KSxcbiAgICAgICAgICAgIGluZGV4T2Zmc2V0LCBzbGlkZU9mZnNldCwgdW5ldmVuT2Zmc2V0O1xuXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBhIGxpbmssIHByZXZlbnQgZGVmYXVsdCBhY3Rpb24uXG4gICAgICAgIGlmKCR0YXJnZXQuaXMoJ2EnKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBub3QgdGhlIDxsaT4gZWxlbWVudCAoaWU6IGEgY2hpbGQpLCBmaW5kIHRoZSA8bGk+LlxuICAgICAgICBpZighJHRhcmdldC5pcygnbGknKSkge1xuICAgICAgICAgICAgJHRhcmdldCA9ICR0YXJnZXQuY2xvc2VzdCgnbGknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVuZXZlbk9mZnNldCA9IChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgIT09IDApO1xuICAgICAgICBpbmRleE9mZnNldCA9IHVuZXZlbk9mZnNldCA/IDAgOiAoXy5zbGlkZUNvdW50IC0gXy5jdXJyZW50U2xpZGUpICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGF0YS5tZXNzYWdlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3ByZXZpb3VzJzpcbiAgICAgICAgICAgICAgICBzbGlkZU9mZnNldCA9IGluZGV4T2Zmc2V0ID09PSAwID8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIGluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKF8uY3VycmVudFNsaWRlIC0gc2xpZGVPZmZzZXQsIGZhbHNlLCBkb250QW5pbWF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICBzbGlkZU9mZnNldCA9IGluZGV4T2Zmc2V0ID09PSAwID8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogaW5kZXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoXy5jdXJyZW50U2xpZGUgKyBzbGlkZU9mZnNldCwgZmFsc2UsIGRvbnRBbmltYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2luZGV4JzpcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBldmVudC5kYXRhLmluZGV4ID09PSAwID8gMCA6XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXggfHwgJHRhcmdldC5pbmRleCgpICogXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuXG4gICAgICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoXy5jaGVja05hdmlnYWJsZShpbmRleCksIGZhbHNlLCBkb250QW5pbWF0ZSk7XG4gICAgICAgICAgICAgICAgJHRhcmdldC5jaGlsZHJlbigpLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNoZWNrTmF2aWdhYmxlID0gZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBuYXZpZ2FibGVzLCBwcmV2TmF2aWdhYmxlO1xuXG4gICAgICAgIG5hdmlnYWJsZXMgPSBfLmdldE5hdmlnYWJsZUluZGV4ZXMoKTtcbiAgICAgICAgcHJldk5hdmlnYWJsZSA9IDA7XG4gICAgICAgIGlmIChpbmRleCA+IG5hdmlnYWJsZXNbbmF2aWdhYmxlcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgaW5kZXggPSBuYXZpZ2FibGVzW25hdmlnYWJsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuIGluIG5hdmlnYWJsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBuYXZpZ2FibGVzW25dKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcHJldk5hdmlnYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZOYXZpZ2FibGUgPSBuYXZpZ2FibGVzW25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2xlYW5VcEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRvdHMgJiYgXy4kZG90cyAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAkKCdsaScsIF8uJGRvdHMpXG4gICAgICAgICAgICAgICAgLm9mZignY2xpY2suc2xpY2snLCBfLmNoYW5nZVNsaWRlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ21vdXNlZW50ZXIuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCB0cnVlKSlcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3VzZWxlYXZlLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgZmFsc2UpKTtcblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy4kZG90cy5vZmYoJ2tleWRvd24uc2xpY2snLCBfLmtleUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVyLm9mZignZm9jdXMuc2xpY2sgYmx1ci5zbGljaycpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYXJyb3dzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8uJHByZXZBcnJvdyAmJiBfLiRwcmV2QXJyb3cub2ZmKCdjbGljay5zbGljaycsIF8uY2hhbmdlU2xpZGUpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93ICYmIF8uJG5leHRBcnJvdy5vZmYoJ2NsaWNrLnNsaWNrJywgXy5jaGFuZ2VTbGlkZSk7XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdyAmJiBfLiRwcmV2QXJyb3cub2ZmKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBfLiRuZXh0QXJyb3cgJiYgXy4kbmV4dEFycm93Lm9mZigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfLiRsaXN0Lm9mZigndG91Y2hzdGFydC5zbGljayBtb3VzZWRvd24uc2xpY2snLCBfLnN3aXBlSGFuZGxlcik7XG4gICAgICAgIF8uJGxpc3Qub2ZmKCd0b3VjaG1vdmUuc2xpY2sgbW91c2Vtb3ZlLnNsaWNrJywgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9mZigndG91Y2hlbmQuc2xpY2sgbW91c2V1cC5zbGljaycsIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vZmYoJ3RvdWNoY2FuY2VsLnNsaWNrIG1vdXNlbGVhdmUuc2xpY2snLCBfLnN3aXBlSGFuZGxlcik7XG5cbiAgICAgICAgXy4kbGlzdC5vZmYoJ2NsaWNrLnNsaWNrJywgXy5jbGlja0hhbmRsZXIpO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLm9mZihfLnZpc2liaWxpdHlDaGFuZ2UsIF8udmlzaWJpbGl0eSk7XG5cbiAgICAgICAgXy5jbGVhblVwU2xpZGVFdmVudHMoKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJGxpc3Qub2ZmKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZm9jdXNPblNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgJChfLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9mZignY2xpY2suc2xpY2snLCBfLnNlbGVjdEhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh3aW5kb3cpLm9mZignb3JpZW50YXRpb25jaGFuZ2Uuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsIF8ub3JpZW50YXRpb25DaGFuZ2UpO1xuXG4gICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgXy5yZXNpemUpO1xuXG4gICAgICAgICQoJ1tkcmFnZ2FibGUhPXRydWVdJywgXy4kc2xpZGVUcmFjaykub2ZmKCdkcmFnc3RhcnQnLCBfLnByZXZlbnREZWZhdWx0KTtcblxuICAgICAgICAkKHdpbmRvdykub2ZmKCdsb2FkLnNsaWNrLnNsaWNrLScgKyBfLmluc3RhbmNlVWlkLCBfLnNldFBvc2l0aW9uKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2xlYW5VcFNsaWRlRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uJGxpc3Qub2ZmKCdtb3VzZWVudGVyLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgdHJ1ZSkpO1xuICAgICAgICBfLiRsaXN0Lm9mZignbW91c2VsZWF2ZS5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIGZhbHNlKSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNsZWFuVXBSb3dzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLCBvcmlnaW5hbFNsaWRlcztcblxuICAgICAgICBpZihfLm9wdGlvbnMucm93cyA+IDApIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU2xpZGVzID0gXy4kc2xpZGVzLmNoaWxkcmVuKCkuY2hpbGRyZW4oKTtcbiAgICAgICAgICAgIG9yaWdpbmFsU2xpZGVzLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICAgICAgICBfLiRzbGlkZXIuZW1wdHkoKS5hcHBlbmQob3JpZ2luYWxTbGlkZXMpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLnNob3VsZENsaWNrID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKHJlZnJlc2gpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5hdXRvUGxheUNsZWFyKCk7XG5cbiAgICAgICAgXy50b3VjaE9iamVjdCA9IHt9O1xuXG4gICAgICAgIF8uY2xlYW5VcEV2ZW50cygpO1xuXG4gICAgICAgICQoJy5zbGljay1jbG9uZWQnLCBfLiRzbGlkZXIpLmRldGFjaCgpO1xuXG4gICAgICAgIGlmIChfLiRkb3RzKSB7XG4gICAgICAgICAgICBfLiRkb3RzLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLiRwcmV2QXJyb3cgJiYgXy4kcHJldkFycm93Lmxlbmd0aCApIHtcblxuICAgICAgICAgICAgXy4kcHJldkFycm93XG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCBzbGljay1hcnJvdyBzbGljay1oaWRkZW4nKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4JylcbiAgICAgICAgICAgICAgICAuY3NzKCdkaXNwbGF5JywnJyk7XG5cbiAgICAgICAgICAgIGlmICggXy5odG1sRXhwci50ZXN0KCBfLm9wdGlvbnMucHJldkFycm93ICkpIHtcbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8uJG5leHRBcnJvdyAmJiBfLiRuZXh0QXJyb3cubGVuZ3RoICkge1xuXG4gICAgICAgICAgICBfLiRuZXh0QXJyb3dcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkIHNsaWNrLWFycm93IHNsaWNrLWhpZGRlbicpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuIGFyaWEtZGlzYWJsZWQgdGFiaW5kZXgnKVxuICAgICAgICAgICAgICAgIC5jc3MoJ2Rpc3BsYXknLCcnKTtcblxuICAgICAgICAgICAgaWYgKCBfLmh0bWxFeHByLnRlc3QoIF8ub3B0aW9ucy5uZXh0QXJyb3cgKSkge1xuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKF8uJHNsaWRlcykge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLXNsaWRlIHNsaWNrLWFjdGl2ZSBzbGljay1jZW50ZXIgc2xpY2stdmlzaWJsZSBzbGljay1jdXJyZW50JylcbiAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4nKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXNsaWNrLWluZGV4JylcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoJ3N0eWxlJywgJCh0aGlzKS5kYXRhKCdvcmlnaW5hbFN0eWxpbmcnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kbGlzdC5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVyLmFwcGVuZChfLiRzbGlkZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5jbGVhblVwUm93cygpO1xuXG4gICAgICAgIF8uJHNsaWRlci5yZW1vdmVDbGFzcygnc2xpY2stc2xpZGVyJyk7XG4gICAgICAgIF8uJHNsaWRlci5yZW1vdmVDbGFzcygnc2xpY2staW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgXy4kc2xpZGVyLnJlbW92ZUNsYXNzKCdzbGljay1kb3R0ZWQnKTtcblxuICAgICAgICBfLnVuc2xpY2tlZCA9IHRydWU7XG5cbiAgICAgICAgaWYoIXJlZnJlc2gpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdkZXN0cm95JywgW19dKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5kaXNhYmxlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHNsaWRlKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHt9O1xuXG4gICAgICAgIHRyYW5zaXRpb25bXy50cmFuc2l0aW9uVHlwZV0gPSAnJztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyh0cmFuc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZSkuY3NzKHRyYW5zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmZhZGVTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlSW5kZXgsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLmNzc1RyYW5zaXRpb25zID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGVJbmRleCkuY3NzKHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGVJbmRleCkuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkLCBfLm9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgXy5hcHBseVRyYW5zaXRpb24oc2xpZGVJbmRleCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZUluZGV4KS5jc3Moe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBfLmRpc2FibGVUcmFuc2l0aW9uKHNsaWRlSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoKTtcbiAgICAgICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZmFkZVNsaWRlT3V0ID0gZnVuY3Rpb24oc2xpZGVJbmRleCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5jc3NUcmFuc2l0aW9ucyA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlSW5kZXgpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4IC0gMlxuICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkLCBfLm9wdGlvbnMuZWFzaW5nKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfLmFwcGx5VHJhbnNpdGlvbihzbGlkZUluZGV4KTtcblxuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlSW5kZXgpLmNzcyh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXggLSAyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmZpbHRlclNsaWRlcyA9IFNsaWNrLnByb3RvdHlwZS5zbGlja0ZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoZmlsdGVyICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc0NhY2hlID0gXy4kc2xpZGVzO1xuXG4gICAgICAgICAgICBfLnVubG9hZCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc0NhY2hlLmZpbHRlcihmaWx0ZXIpLmFwcGVuZFRvKF8uJHNsaWRlVHJhY2spO1xuXG4gICAgICAgICAgICBfLnJlaW5pdCgpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZm9jdXNIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uJHNsaWRlclxuICAgICAgICAgICAgLm9mZignZm9jdXMuc2xpY2sgYmx1ci5zbGljaycpXG4gICAgICAgICAgICAub24oJ2ZvY3VzLnNsaWNrIGJsdXIuc2xpY2snLCAnKicsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdmFyICRzZiA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICBpZiggXy5vcHRpb25zLnBhdXNlT25Gb2N1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgXy5mb2N1c3NlZCA9ICRzZi5pcygnOmZvY3VzJyk7XG4gICAgICAgICAgICAgICAgICAgIF8uYXV0b1BsYXkoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IFNsaWNrLnByb3RvdHlwZS5zbGlja0N1cnJlbnRTbGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF8uY3VycmVudFNsaWRlO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXREb3RDb3VudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICB2YXIgYnJlYWtQb2ludCA9IDA7XG4gICAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgICAgdmFyIHBhZ2VyUXR5ID0gMDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICAgKytwYWdlclF0eTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGJyZWFrUG9pbnQgPCBfLnNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgKytwYWdlclF0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtQb2ludCA9IGNvdW50ZXIgKyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgOiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcGFnZXJRdHkgPSBfLnNsaWRlQ291bnQ7XG4gICAgICAgIH0gZWxzZSBpZighXy5vcHRpb25zLmFzTmF2Rm9yKSB7XG4gICAgICAgICAgICBwYWdlclF0eSA9IDEgKyBNYXRoLmNlaWwoKF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIC8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKTtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGJyZWFrUG9pbnQgPCBfLnNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICArK3BhZ2VyUXR5O1xuICAgICAgICAgICAgICAgIGJyZWFrUG9pbnQgPSBjb3VudGVyICsgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgOiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhZ2VyUXR5IC0gMTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uKHNsaWRlSW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXRMZWZ0LFxuICAgICAgICAgICAgdmVydGljYWxIZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9IDAsXG4gICAgICAgICAgICB0YXJnZXRTbGlkZSxcbiAgICAgICAgICAgIGNvZWY7XG5cbiAgICAgICAgXy5zbGlkZU9mZnNldCA9IDA7XG4gICAgICAgIHZlcnRpY2FsSGVpZ2h0ID0gXy4kc2xpZGVzLmZpcnN0KCkub3V0ZXJIZWlnaHQodHJ1ZSk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gKF8uc2xpZGVXaWR0aCAqIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpICogLTE7XG4gICAgICAgICAgICAgICAgY29lZiA9IC0xXG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSB0cnVlICYmIF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmID0gLTEuNTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmID0gLTJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9ICh2ZXJ0aWNhbEhlaWdodCAqIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpICogY29lZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA+IF8uc2xpZGVDb3VudCAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZUluZGV4ID4gXy5zbGlkZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gKChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gKHNsaWRlSW5kZXggLSBfLnNsaWRlQ291bnQpKSAqIF8uc2xpZGVXaWR0aCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gKChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gKHNsaWRlSW5kZXggLSBfLnNsaWRlQ291bnQpKSAqIHZlcnRpY2FsSGVpZ2h0KSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9ICgoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSAqIF8uc2xpZGVXaWR0aCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gKChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpICogdmVydGljYWxIZWlnaHQpICogLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPiBfLnNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gKChzbGlkZUluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgLSBfLnNsaWRlQ291bnQpICogXy5zbGlkZVdpZHRoO1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gKChzbGlkZUluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgLSBfLnNsaWRlQ291bnQpICogdmVydGljYWxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmVydGljYWxPZmZzZXQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gKChfLnNsaWRlV2lkdGggKiBNYXRoLmZsb29yKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpKSAvIDIpIC0gKChfLnNsaWRlV2lkdGggKiBfLnNsaWRlQ291bnQpIC8gMik7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUgJiYgXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ICs9IF8uc2xpZGVXaWR0aCAqIE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpIC0gXy5zbGlkZVdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgKz0gXy5zbGlkZVdpZHRoICogTWF0aC5mbG9vcihfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGFyZ2V0TGVmdCA9ICgoc2xpZGVJbmRleCAqIF8uc2xpZGVXaWR0aCkgKiAtMSkgKyBfLnNsaWRlT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0TGVmdCA9ICgoc2xpZGVJbmRleCAqIHZlcnRpY2FsSGVpZ2h0KSAqIC0xKSArIHZlcnRpY2FsT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52YXJpYWJsZVdpZHRoID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyB8fCBfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2xpZGUgPSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS5lcShzbGlkZUluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2xpZGUgPSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS5lcShzbGlkZUluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFNsaWRlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAoXy4kc2xpZGVUcmFjay53aWR0aCgpIC0gdGFyZ2V0U2xpZGVbMF0ub2Zmc2V0TGVmdCAtIHRhcmdldFNsaWRlLndpZHRoKCkpICogLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9ICAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IHRhcmdldFNsaWRlWzBdID8gdGFyZ2V0U2xpZGVbMF0ub2Zmc2V0TGVmdCAqIC0xIDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93IHx8IF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2xpZGUgPSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS5lcShzbGlkZUluZGV4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmVxKHNsaWRlSW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5ydGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFNsaWRlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gKF8uJHNsaWRlVHJhY2sud2lkdGgoKSAtIHRhcmdldFNsaWRlWzBdLm9mZnNldExlZnQgLSB0YXJnZXRTbGlkZS53aWR0aCgpKSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9ICAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IHRhcmdldFNsaWRlWzBdID8gdGFyZ2V0U2xpZGVbMF0ub2Zmc2V0TGVmdCAqIC0xIDogMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ICs9IChfLiRsaXN0LndpZHRoKCkgLSB0YXJnZXRTbGlkZS5vdXRlcldpZHRoKCkpIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRMZWZ0O1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXRPcHRpb24gPSBTbGljay5wcm90b3R5cGUuc2xpY2tHZXRPcHRpb24gPSBmdW5jdGlvbihvcHRpb24pIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIF8ub3B0aW9uc1tvcHRpb25dO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXROYXZpZ2FibGVJbmRleGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgYnJlYWtQb2ludCA9IDAsXG4gICAgICAgICAgICBjb3VudGVyID0gMCxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIG1heDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbWF4ID0gXy5zbGlkZUNvdW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtQb2ludCA9IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAqIC0xO1xuICAgICAgICAgICAgY291bnRlciA9IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAqIC0xO1xuICAgICAgICAgICAgbWF4ID0gXy5zbGlkZUNvdW50ICogMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChicmVha1BvaW50IDwgbWF4KSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goYnJlYWtQb2ludCk7XG4gICAgICAgICAgICBicmVha1BvaW50ID0gY291bnRlciArIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgICAgIGNvdW50ZXIgKz0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgOiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldFNsaWNrID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldFNsaWRlQ291bnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBzbGlkZXNUcmF2ZXJzZWQsIHN3aXBlZFNsaWRlLCBjZW50ZXJPZmZzZXQ7XG5cbiAgICAgICAgY2VudGVyT2Zmc2V0ID0gXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUgPyBfLnNsaWRlV2lkdGggKiBNYXRoLmZsb29yKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKSA6IDA7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5zd2lwZVRvU2xpZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suZmluZCgnLnNsaWNrLXNsaWRlJykuZWFjaChmdW5jdGlvbihpbmRleCwgc2xpZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2xpZGUub2Zmc2V0TGVmdCAtIGNlbnRlck9mZnNldCArICgkKHNsaWRlKS5vdXRlcldpZHRoKCkgLyAyKSA+IChfLnN3aXBlTGVmdCAqIC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2lwZWRTbGlkZSA9IHNsaWRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNsaWRlc1RyYXZlcnNlZCA9IE1hdGguYWJzKCQoc3dpcGVkU2xpZGUpLmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnKSAtIF8uY3VycmVudFNsaWRlKSB8fCAxO1xuXG4gICAgICAgICAgICByZXR1cm4gc2xpZGVzVHJhdmVyc2VkO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdvVG8gPSBTbGljay5wcm90b3R5cGUuc2xpY2tHb1RvID0gZnVuY3Rpb24oc2xpZGUsIGRvbnRBbmltYXRlKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcnNlSW50KHNsaWRlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkb250QW5pbWF0ZSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihjcmVhdGlvbikge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoISQoXy4kc2xpZGVyKS5oYXNDbGFzcygnc2xpY2staW5pdGlhbGl6ZWQnKSkge1xuXG4gICAgICAgICAgICAkKF8uJHNsaWRlcikuYWRkQ2xhc3MoJ3NsaWNrLWluaXRpYWxpemVkJyk7XG5cbiAgICAgICAgICAgIF8uYnVpbGRSb3dzKCk7XG4gICAgICAgICAgICBfLmJ1aWxkT3V0KCk7XG4gICAgICAgICAgICBfLnNldFByb3BzKCk7XG4gICAgICAgICAgICBfLnN0YXJ0TG9hZCgpO1xuICAgICAgICAgICAgXy5sb2FkU2xpZGVyKCk7XG4gICAgICAgICAgICBfLmluaXRpYWxpemVFdmVudHMoKTtcbiAgICAgICAgICAgIF8udXBkYXRlQXJyb3dzKCk7XG4gICAgICAgICAgICBfLnVwZGF0ZURvdHMoKTtcbiAgICAgICAgICAgIF8uY2hlY2tSZXNwb25zaXZlKHRydWUpO1xuICAgICAgICAgICAgXy5mb2N1c0hhbmRsZXIoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNyZWF0aW9uKSB7XG4gICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignaW5pdCcsIFtfXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uaW5pdEFEQSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMuYXV0b3BsYXkgKSB7XG5cbiAgICAgICAgICAgIF8ucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBfLmF1dG9QbGF5KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0QURBID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgICAgICBudW1Eb3RHcm91cHMgPSBNYXRoLmNlaWwoXy5zbGlkZUNvdW50IC8gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyksXG4gICAgICAgICAgICAgICAgdGFiQ29udHJvbEluZGV4ZXMgPSBfLmdldE5hdmlnYWJsZUluZGV4ZXMoKS5maWx0ZXIoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodmFsID49IDApICYmICh2YWwgPCBfLnNsaWRlQ291bnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIF8uJHNsaWRlcy5hZGQoXy4kc2xpZGVUcmFjay5maW5kKCcuc2xpY2stY2xvbmVkJykpLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogJy0xJ1xuICAgICAgICB9KS5maW5kKCdhLCBpbnB1dCwgYnV0dG9uLCBzZWxlY3QnKS5hdHRyKHtcbiAgICAgICAgICAgICd0YWJpbmRleCc6ICctMSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKF8uJGRvdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlcy5ub3QoXy4kc2xpZGVUcmFjay5maW5kKCcuc2xpY2stY2xvbmVkJykpLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgIHZhciBzbGlkZUNvbnRyb2xJbmRleCA9IHRhYkNvbnRyb2xJbmRleGVzLmluZGV4T2YoaSk7XG5cbiAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICd0YWJwYW5lbCcsXG4gICAgICAgICAgICAgICAgICAgICdpZCc6ICdzbGljay1zbGlkZScgKyBfLmluc3RhbmNlVWlkICsgaSxcbiAgICAgICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogLTFcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChzbGlkZUNvbnRyb2xJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgYXJpYUJ1dHRvbkNvbnRyb2wgPSAnc2xpY2stc2xpZGUtY29udHJvbCcgKyBfLmluc3RhbmNlVWlkICsgc2xpZGVDb250cm9sSW5kZXhcbiAgICAgICAgICAgICAgICAgICBpZiAoJCgnIycgKyBhcmlhQnV0dG9uQ29udHJvbCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogYXJpYUJ1dHRvbkNvbnRyb2xcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgXy4kZG90cy5hdHRyKCdyb2xlJywgJ3RhYmxpc3QnKS5maW5kKCdsaScpLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXBwZWRTbGlkZUluZGV4ID0gdGFiQ29udHJvbEluZGV4ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdwcmVzZW50YXRpb24nXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAkKHRoaXMpLmZpbmQoJ2J1dHRvbicpLmZpcnN0KCkuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3RhYicsXG4gICAgICAgICAgICAgICAgICAgICdpZCc6ICdzbGljay1zbGlkZS1jb250cm9sJyArIF8uaW5zdGFuY2VVaWQgKyBpLFxuICAgICAgICAgICAgICAgICAgICAnYXJpYS1jb250cm9scyc6ICdzbGljay1zbGlkZScgKyBfLmluc3RhbmNlVWlkICsgbWFwcGVkU2xpZGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiAoaSArIDEpICsgJyBvZiAnICsgbnVtRG90R3JvdXBzLFxuICAgICAgICAgICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICd0YWJpbmRleCc6ICctMSdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSkuZXEoXy5jdXJyZW50U2xpZGUpLmZpbmQoJ2J1dHRvbicpLmF0dHIoe1xuICAgICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICd0YWJpbmRleCc6ICcwJ1xuICAgICAgICAgICAgfSkuZW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpPV8uY3VycmVudFNsaWRlLCBtYXg9aStfLm9wdGlvbnMuc2xpZGVzVG9TaG93OyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICBpZiAoXy5vcHRpb25zLmZvY3VzT25DaGFuZ2UpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShpKS5hdHRyKHsndGFiaW5kZXgnOiAnMCd9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKGkpLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXy5hY3RpdmF0ZUFEQSgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0QXJyb3dFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hcnJvd3MgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy4kcHJldkFycm93XG4gICAgICAgICAgICAgICAub2ZmKCdjbGljay5zbGljaycpXG4gICAgICAgICAgICAgICAub24oJ2NsaWNrLnNsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAncHJldmlvdXMnXG4gICAgICAgICAgICAgICB9LCBfLmNoYW5nZVNsaWRlKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvd1xuICAgICAgICAgICAgICAgLm9mZignY2xpY2suc2xpY2snKVxuICAgICAgICAgICAgICAgLm9uKCdjbGljay5zbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ25leHQnXG4gICAgICAgICAgICAgICB9LCBfLmNoYW5nZVNsaWRlKTtcblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93Lm9uKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBfLiRuZXh0QXJyb3cub24oJ2tleWRvd24uc2xpY2snLCBfLmtleUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXREb3RFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICQoJ2xpJywgXy4kZG90cykub24oJ2NsaWNrLnNsaWNrJywge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbmRleCdcbiAgICAgICAgICAgIH0sIF8uY2hhbmdlU2xpZGUpO1xuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLiRkb3RzLm9uKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZG90cyA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMucGF1c2VPbkRvdHNIb3ZlciA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgICQoJ2xpJywgXy4kZG90cylcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlZW50ZXIuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCB0cnVlKSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbGVhdmUuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCBmYWxzZSkpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdFNsaWRlRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICggXy5vcHRpb25zLnBhdXNlT25Ib3ZlciApIHtcblxuICAgICAgICAgICAgXy4kbGlzdC5vbignbW91c2VlbnRlci5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIHRydWUpKTtcbiAgICAgICAgICAgIF8uJGxpc3Qub24oJ21vdXNlbGVhdmUuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCBmYWxzZSkpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdGlhbGl6ZUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmluaXRBcnJvd0V2ZW50cygpO1xuXG4gICAgICAgIF8uaW5pdERvdEV2ZW50cygpO1xuICAgICAgICBfLmluaXRTbGlkZUV2ZW50cygpO1xuXG4gICAgICAgIF8uJGxpc3Qub24oJ3RvdWNoc3RhcnQuc2xpY2sgbW91c2Vkb3duLnNsaWNrJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnc3RhcnQnXG4gICAgICAgIH0sIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vbigndG91Y2htb3ZlLnNsaWNrIG1vdXNlbW92ZS5zbGljaycsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ21vdmUnXG4gICAgICAgIH0sIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vbigndG91Y2hlbmQuc2xpY2sgbW91c2V1cC5zbGljaycsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2VuZCdcbiAgICAgICAgfSwgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9uKCd0b3VjaGNhbmNlbC5zbGljayBtb3VzZWxlYXZlLnNsaWNrJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnZW5kJ1xuICAgICAgICB9LCBfLnN3aXBlSGFuZGxlcik7XG5cbiAgICAgICAgXy4kbGlzdC5vbignY2xpY2suc2xpY2snLCBfLmNsaWNrSGFuZGxlcik7XG5cbiAgICAgICAgJChkb2N1bWVudCkub24oXy52aXNpYmlsaXR5Q2hhbmdlLCAkLnByb3h5KF8udmlzaWJpbGl0eSwgXykpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy4kbGlzdC5vbigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZvY3VzT25TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICQoXy4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vbignY2xpY2suc2xpY2snLCBfLnNlbGVjdEhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdvcmllbnRhdGlvbmNoYW5nZS5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgJC5wcm94eShfLm9yaWVudGF0aW9uQ2hhbmdlLCBfKSk7XG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsICQucHJveHkoXy5yZXNpemUsIF8pKTtcblxuICAgICAgICAkKCdbZHJhZ2dhYmxlIT10cnVlXScsIF8uJHNsaWRlVHJhY2spLm9uKCdkcmFnc3RhcnQnLCBfLnByZXZlbnREZWZhdWx0KTtcblxuICAgICAgICAkKHdpbmRvdykub24oJ2xvYWQuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsIF8uc2V0UG9zaXRpb24pO1xuICAgICAgICAkKF8uc2V0UG9zaXRpb24pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0VUkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hcnJvd3MgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cuc2hvdygpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93LnNob3coKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgXy4kZG90cy5zaG93KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5rZXlIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG4gICAgICAgICAvL0RvbnQgc2xpZGUgaWYgdGhlIGN1cnNvciBpcyBpbnNpZGUgdGhlIGZvcm0gZmllbGRzIGFuZCBhcnJvdyBrZXlzIGFyZSBwcmVzc2VkXG4gICAgICAgIGlmKCFldmVudC50YXJnZXQudGFnTmFtZS5tYXRjaCgnVEVYVEFSRUF8SU5QVVR8U0VMRUNUJykpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAzNyAmJiBfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfLm9wdGlvbnMucnRsID09PSB0cnVlID8gJ25leHQnIDogICdwcmV2aW91cydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAzOSAmJiBfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfLm9wdGlvbnMucnRsID09PSB0cnVlID8gJ3ByZXZpb3VzJyA6ICduZXh0J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUubGF6eUxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBsb2FkUmFuZ2UsIGNsb25lUmFuZ2UsIHJhbmdlU3RhcnQsIHJhbmdlRW5kO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoaW1hZ2VzU2NvcGUpIHtcblxuICAgICAgICAgICAgJCgnaW1nW2RhdGEtbGF6eV0nLCBpbWFnZXNTY29wZSkuZWFjaChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU291cmNlID0gJCh0aGlzKS5hdHRyKCdkYXRhLWxhenknKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtc3Jjc2V0JyksXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU2l6ZXMgID0gJCh0aGlzKS5hdHRyKCdkYXRhLXNpemVzJykgfHwgXy4kc2xpZGVyLmF0dHIoJ2RhdGEtc2l6ZXMnKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VUb0xvYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgICAgICAgICAgICAgIGltYWdlVG9Mb2FkLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAuYW5pbWF0ZSh7IG9wYWNpdHk6IDAgfSwgMTAwLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZVNyY1NldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3NyY3NldCcsIGltYWdlU3JjU2V0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlU2l6ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3NpemVzJywgaW1hZ2VTaXplcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3NyYycsIGltYWdlU291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYW5pbWF0ZSh7IG9wYWNpdHk6IDEgfSwgMjAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtbGF6eSBkYXRhLXNyY3NldCBkYXRhLXNpemVzJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2xhenlMb2FkZWQnLCBbXywgaW1hZ2UsIGltYWdlU291cmNlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpbWFnZVRvTG9hZC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCAnZGF0YS1sYXp5JyApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoICdzbGljay1sb2FkaW5nJyApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoICdzbGljay1sYXp5bG9hZC1lcnJvcicgKTtcblxuICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignbGF6eUxvYWRFcnJvcicsIFsgXywgaW1hZ2UsIGltYWdlU291cmNlIF0pO1xuXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGltYWdlVG9Mb2FkLnNyYyA9IGltYWdlU291cmNlO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VTdGFydCA9IF8uY3VycmVudFNsaWRlICsgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyICsgMSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VFbmQgPSByYW5nZVN0YXJ0ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBNYXRoLm1heCgwLCBfLmN1cnJlbnRTbGlkZSAtIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMiArIDEpKTtcbiAgICAgICAgICAgICAgICByYW5nZUVuZCA9IDIgKyAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIgKyAxKSArIF8uY3VycmVudFNsaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2VTdGFydCA9IF8ub3B0aW9ucy5pbmZpbml0ZSA/IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyBfLmN1cnJlbnRTbGlkZSA6IF8uY3VycmVudFNsaWRlO1xuICAgICAgICAgICAgcmFuZ2VFbmQgPSBNYXRoLmNlaWwocmFuZ2VTdGFydCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpO1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlU3RhcnQgPiAwKSByYW5nZVN0YXJ0LS07XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRW5kIDw9IF8uc2xpZGVDb3VudCkgcmFuZ2VFbmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWRSYW5nZSA9IF8uJHNsaWRlci5maW5kKCcuc2xpY2stc2xpZGUnKS5zbGljZShyYW5nZVN0YXJ0LCByYW5nZUVuZCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5sYXp5TG9hZCA9PT0gJ2FudGljaXBhdGVkJykge1xuICAgICAgICAgICAgdmFyIHByZXZTbGlkZSA9IHJhbmdlU3RhcnQgLSAxLFxuICAgICAgICAgICAgICAgIG5leHRTbGlkZSA9IHJhbmdlRW5kLFxuICAgICAgICAgICAgICAgICRzbGlkZXMgPSBfLiRzbGlkZXIuZmluZCgnLnNsaWNrLXNsaWRlJyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlNsaWRlIDwgMCkgcHJldlNsaWRlID0gXy5zbGlkZUNvdW50IC0gMTtcbiAgICAgICAgICAgICAgICBsb2FkUmFuZ2UgPSBsb2FkUmFuZ2UuYWRkKCRzbGlkZXMuZXEocHJldlNsaWRlKSk7XG4gICAgICAgICAgICAgICAgbG9hZFJhbmdlID0gbG9hZFJhbmdlLmFkZCgkc2xpZGVzLmVxKG5leHRTbGlkZSkpO1xuICAgICAgICAgICAgICAgIHByZXZTbGlkZS0tO1xuICAgICAgICAgICAgICAgIG5leHRTbGlkZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9hZEltYWdlcyhsb2FkUmFuZ2UpO1xuXG4gICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgY2xvbmVSYW5nZSA9IF8uJHNsaWRlci5maW5kKCcuc2xpY2stc2xpZGUnKTtcbiAgICAgICAgICAgIGxvYWRJbWFnZXMoY2xvbmVSYW5nZSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICBpZiAoXy5jdXJyZW50U2xpZGUgPj0gXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgY2xvbmVSYW5nZSA9IF8uJHNsaWRlci5maW5kKCcuc2xpY2stY2xvbmVkJykuc2xpY2UoMCwgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyk7XG4gICAgICAgICAgICBsb2FkSW1hZ2VzKGNsb25lUmFuZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKF8uY3VycmVudFNsaWRlID09PSAwKSB7XG4gICAgICAgICAgICBjbG9uZVJhbmdlID0gXy4kc2xpZGVyLmZpbmQoJy5zbGljay1jbG9uZWQnKS5zbGljZShfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICogLTEpO1xuICAgICAgICAgICAgbG9hZEltYWdlcyhjbG9uZVJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5sb2FkU2xpZGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uc2V0UG9zaXRpb24oKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uJHNsaWRlci5yZW1vdmVDbGFzcygnc2xpY2stbG9hZGluZycpO1xuXG4gICAgICAgIF8uaW5pdFVJKCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5sYXp5TG9hZCA9PT0gJ3Byb2dyZXNzaXZlJykge1xuICAgICAgICAgICAgXy5wcm9ncmVzc2l2ZUxhenlMb2FkKCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUubmV4dCA9IFNsaWNrLnByb3RvdHlwZS5zbGlja05leHQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ25leHQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5vcmllbnRhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmNoZWNrUmVzcG9uc2l2ZSgpO1xuICAgICAgICBfLnNldFBvc2l0aW9uKCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnBhdXNlID0gU2xpY2sucHJvdG90eXBlLnNsaWNrUGF1c2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5hdXRvUGxheUNsZWFyKCk7XG4gICAgICAgIF8ucGF1c2VkID0gdHJ1ZTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucGxheSA9IFNsaWNrLnByb3RvdHlwZS5zbGlja1BsYXkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5hdXRvUGxheSgpO1xuICAgICAgICBfLm9wdGlvbnMuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICBfLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBfLmZvY3Vzc2VkID0gZmFsc2U7XG4gICAgICAgIF8uaW50ZXJydXB0ZWQgPSBmYWxzZTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucG9zdFNsaWRlID0gZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYoICFfLnVuc2xpY2tlZCApIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2FmdGVyQ2hhbmdlJywgW18sIGluZGV4XSk7XG5cbiAgICAgICAgICAgIF8uYW5pbWF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgXy5zZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLnN3aXBlTGVmdCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICggXy5vcHRpb25zLmF1dG9wbGF5ICkge1xuICAgICAgICAgICAgICAgIF8uYXV0b1BsYXkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy5pbml0QURBKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLmZvY3VzT25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRjdXJyZW50U2xpZGUgPSAkKF8uJHNsaWRlcy5nZXQoXy5jdXJyZW50U2xpZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgJGN1cnJlbnRTbGlkZS5hdHRyKCd0YWJpbmRleCcsIDApLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucHJldiA9IFNsaWNrLnByb3RvdHlwZS5zbGlja1ByZXYgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ3ByZXZpb3VzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnByb2dyZXNzaXZlTGF6eUxvYWQgPSBmdW5jdGlvbiggdHJ5Q291bnQgKSB7XG5cbiAgICAgICAgdHJ5Q291bnQgPSB0cnlDb3VudCB8fCAxO1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgICRpbWdzVG9Mb2FkID0gJCggJ2ltZ1tkYXRhLWxhenldJywgXy4kc2xpZGVyICksXG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIGltYWdlU291cmNlLFxuICAgICAgICAgICAgaW1hZ2VTcmNTZXQsXG4gICAgICAgICAgICBpbWFnZVNpemVzLFxuICAgICAgICAgICAgaW1hZ2VUb0xvYWQ7XG5cbiAgICAgICAgaWYgKCAkaW1nc1RvTG9hZC5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGltYWdlID0gJGltZ3NUb0xvYWQuZmlyc3QoKTtcbiAgICAgICAgICAgIGltYWdlU291cmNlID0gaW1hZ2UuYXR0cignZGF0YS1sYXp5Jyk7XG4gICAgICAgICAgICBpbWFnZVNyY1NldCA9IGltYWdlLmF0dHIoJ2RhdGEtc3Jjc2V0Jyk7XG4gICAgICAgICAgICBpbWFnZVNpemVzICA9IGltYWdlLmF0dHIoJ2RhdGEtc2l6ZXMnKSB8fCBfLiRzbGlkZXIuYXR0cignZGF0YS1zaXplcycpO1xuICAgICAgICAgICAgaW1hZ2VUb0xvYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgICAgICAgICAgaW1hZ2VUb0xvYWQub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VTcmNTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzcmNzZXQnLCBpbWFnZVNyY1NldCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZVNpemVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzaXplcycsIGltYWdlU2l6ZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCAnc3JjJywgaW1hZ2VTb3VyY2UgKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1sYXp5IGRhdGEtc3Jjc2V0IGRhdGEtc2l6ZXMnKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWxvYWRpbmcnKTtcblxuICAgICAgICAgICAgICAgIGlmICggXy5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0ID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICBfLnNldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2xhenlMb2FkZWQnLCBbIF8sIGltYWdlLCBpbWFnZVNvdXJjZSBdKTtcbiAgICAgICAgICAgICAgICBfLnByb2dyZXNzaXZlTGF6eUxvYWQoKTtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1hZ2VUb0xvYWQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0cnlDb3VudCA8IDMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIHRyeSB0byBsb2FkIHRoZSBpbWFnZSAzIHRpbWVzLFxuICAgICAgICAgICAgICAgICAgICAgKiBsZWF2ZSBhIHNsaWdodCBkZWxheSBzbyB3ZSBkb24ndCBnZXRcbiAgICAgICAgICAgICAgICAgICAgICogc2VydmVycyBibG9ja2luZyB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5wcm9ncmVzc2l2ZUxhenlMb2FkKCB0cnlDb3VudCArIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgNTAwICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0ciggJ2RhdGEtbGF6eScgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCAnc2xpY2stbG9hZGluZycgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCAnc2xpY2stbGF6eWxvYWQtZXJyb3InICk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2xhenlMb2FkRXJyb3InLCBbIF8sIGltYWdlLCBpbWFnZVNvdXJjZSBdKTtcblxuICAgICAgICAgICAgICAgICAgICBfLnByb2dyZXNzaXZlTGF6eUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1hZ2VUb0xvYWQuc3JjID0gaW1hZ2VTb3VyY2U7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2FsbEltYWdlc0xvYWRlZCcsIFsgXyBdKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiggaW5pdGlhbGl6aW5nICkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcywgY3VycmVudFNsaWRlLCBsYXN0VmlzaWJsZUluZGV4O1xuXG4gICAgICAgIGxhc3RWaXNpYmxlSW5kZXggPSBfLnNsaWRlQ291bnQgLSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuXG4gICAgICAgIC8vIGluIG5vbi1pbmZpbml0ZSBzbGlkZXJzLCB3ZSBkb24ndCB3YW50IHRvIGdvIHBhc3QgdGhlXG4gICAgICAgIC8vIGxhc3QgdmlzaWJsZSBpbmRleC5cbiAgICAgICAgaWYoICFfLm9wdGlvbnMuaW5maW5pdGUgJiYgKCBfLmN1cnJlbnRTbGlkZSA+IGxhc3RWaXNpYmxlSW5kZXggKSkge1xuICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBsYXN0VmlzaWJsZUluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbGVzcyBzbGlkZXMgdGhhbiB0byBzaG93LCBnbyB0byBzdGFydC5cbiAgICAgICAgaWYgKCBfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyApIHtcbiAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gMDtcblxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFNsaWRlID0gXy5jdXJyZW50U2xpZGU7XG5cbiAgICAgICAgXy5kZXN0cm95KHRydWUpO1xuXG4gICAgICAgICQuZXh0ZW5kKF8sIF8uaW5pdGlhbHMsIHsgY3VycmVudFNsaWRlOiBjdXJyZW50U2xpZGUgfSk7XG5cbiAgICAgICAgXy5pbml0KCk7XG5cbiAgICAgICAgaWYoICFpbml0aWFsaXppbmcgKSB7XG5cbiAgICAgICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2luZGV4JyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRTbGlkZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnJlZ2lzdGVyQnJlYWtwb2ludHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsIGJyZWFrcG9pbnQsIGN1cnJlbnRCcmVha3BvaW50LCBsLFxuICAgICAgICAgICAgcmVzcG9uc2l2ZVNldHRpbmdzID0gXy5vcHRpb25zLnJlc3BvbnNpdmUgfHwgbnVsbDtcblxuICAgICAgICBpZiAoICQudHlwZShyZXNwb25zaXZlU2V0dGluZ3MpID09PSAnYXJyYXknICYmIHJlc3BvbnNpdmVTZXR0aW5ncy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIF8ucmVzcG9uZFRvID0gXy5vcHRpb25zLnJlc3BvbmRUbyB8fCAnd2luZG93JztcblxuICAgICAgICAgICAgZm9yICggYnJlYWtwb2ludCBpbiByZXNwb25zaXZlU2V0dGluZ3MgKSB7XG5cbiAgICAgICAgICAgICAgICBsID0gXy5icmVha3BvaW50cy5sZW5ndGgtMTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zaXZlU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYnJlYWtwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJyZWFrcG9pbnQgPSByZXNwb25zaXZlU2V0dGluZ3NbYnJlYWtwb2ludF0uYnJlYWtwb2ludDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGJyZWFrcG9pbnRzIGFuZCBjdXQgb3V0IGFueSBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmVzIHdpdGggdGhlIHNhbWUgYnJlYWtwb2ludCBudW1iZXIsIHdlIGRvbid0IHdhbnQgZHVwZXMuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKCBsID49IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggXy5icmVha3BvaW50c1tsXSAmJiBfLmJyZWFrcG9pbnRzW2xdID09PSBjdXJyZW50QnJlYWtwb2ludCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmJyZWFrcG9pbnRzLnNwbGljZShsLDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50cy5wdXNoKGN1cnJlbnRCcmVha3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50U2V0dGluZ3NbY3VycmVudEJyZWFrcG9pbnRdID0gcmVzcG9uc2l2ZVNldHRpbmdzW2JyZWFrcG9pbnRdLnNldHRpbmdzO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uYnJlYWtwb2ludHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICggXy5vcHRpb25zLm1vYmlsZUZpcnN0ICkgPyBhLWIgOiBiLWE7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnJlaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLiRzbGlkZXMgPVxuICAgICAgICAgICAgXy4kc2xpZGVUcmFja1xuICAgICAgICAgICAgICAgIC5jaGlsZHJlbihfLm9wdGlvbnMuc2xpZGUpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1zbGlkZScpO1xuXG4gICAgICAgIF8uc2xpZGVDb3VudCA9IF8uJHNsaWRlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKF8uY3VycmVudFNsaWRlID49IF8uc2xpZGVDb3VudCAmJiBfLmN1cnJlbnRTbGlkZSAhPT0gMCkge1xuICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLmN1cnJlbnRTbGlkZSAtIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5yZWdpc3RlckJyZWFrcG9pbnRzKCk7XG5cbiAgICAgICAgXy5zZXRQcm9wcygpO1xuICAgICAgICBfLnNldHVwSW5maW5pdGUoKTtcbiAgICAgICAgXy5idWlsZEFycm93cygpO1xuICAgICAgICBfLnVwZGF0ZUFycm93cygpO1xuICAgICAgICBfLmluaXRBcnJvd0V2ZW50cygpO1xuICAgICAgICBfLmJ1aWxkRG90cygpO1xuICAgICAgICBfLnVwZGF0ZURvdHMoKTtcbiAgICAgICAgXy5pbml0RG90RXZlbnRzKCk7XG4gICAgICAgIF8uY2xlYW5VcFNsaWRlRXZlbnRzKCk7XG4gICAgICAgIF8uaW5pdFNsaWRlRXZlbnRzKCk7XG5cbiAgICAgICAgXy5jaGVja1Jlc3BvbnNpdmUoZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZm9jdXNPblNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgJChfLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9uKCdjbGljay5zbGljaycsIF8uc2VsZWN0SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBfLnNldFNsaWRlQ2xhc3Nlcyh0eXBlb2YgXy5jdXJyZW50U2xpZGUgPT09ICdudW1iZXInID8gXy5jdXJyZW50U2xpZGUgOiAwKTtcblxuICAgICAgICBfLnNldFBvc2l0aW9uKCk7XG4gICAgICAgIF8uZm9jdXNIYW5kbGVyKCk7XG5cbiAgICAgICAgXy5wYXVzZWQgPSAhXy5vcHRpb25zLmF1dG9wbGF5O1xuICAgICAgICBfLmF1dG9QbGF5KCk7XG5cbiAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ3JlSW5pdCcsIFtfXSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoJCh3aW5kb3cpLndpZHRoKCkgIT09IF8ud2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfLndpbmRvd0RlbGF5KTtcbiAgICAgICAgICAgIF8ud2luZG93RGVsYXkgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfLndpbmRvd1dpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgXy5jaGVja1Jlc3BvbnNpdmUoKTtcbiAgICAgICAgICAgICAgICBpZiggIV8udW5zbGlja2VkICkgeyBfLnNldFBvc2l0aW9uKCk7IH1cbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucmVtb3ZlU2xpZGUgPSBTbGljay5wcm90b3R5cGUuc2xpY2tSZW1vdmUgPSBmdW5jdGlvbihpbmRleCwgcmVtb3ZlQmVmb3JlLCByZW1vdmVBbGwpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZihpbmRleCkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmVtb3ZlQmVmb3JlID0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IHJlbW92ZUJlZm9yZSA9PT0gdHJ1ZSA/IDAgOiBfLnNsaWRlQ291bnQgLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSByZW1vdmVCZWZvcmUgPT09IHRydWUgPyAtLWluZGV4IDogaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDwgMSB8fCBpbmRleCA8IDAgfHwgaW5kZXggPiBfLnNsaWRlQ291bnQgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBfLnVubG9hZCgpO1xuXG4gICAgICAgIGlmIChyZW1vdmVBbGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oKS5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5lcShpbmRleCkucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfLiRzbGlkZXMgPSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suYXBwZW5kKF8uJHNsaWRlcyk7XG5cbiAgICAgICAgXy4kc2xpZGVzQ2FjaGUgPSBfLiRzbGlkZXM7XG5cbiAgICAgICAgXy5yZWluaXQoKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0Q1NTID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBwb3NpdGlvblByb3BzID0ge30sXG4gICAgICAgICAgICB4LCB5O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IC1wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB4ID0gXy5wb3NpdGlvblByb3AgPT0gJ2xlZnQnID8gTWF0aC5jZWlsKHBvc2l0aW9uKSArICdweCcgOiAnMHB4JztcbiAgICAgICAgeSA9IF8ucG9zaXRpb25Qcm9wID09ICd0b3AnID8gTWF0aC5jZWlsKHBvc2l0aW9uKSArICdweCcgOiAnMHB4JztcblxuICAgICAgICBwb3NpdGlvblByb3BzW18ucG9zaXRpb25Qcm9wXSA9IHBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChfLnRyYW5zZm9ybXNFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MocG9zaXRpb25Qcm9wcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvblByb3BzID0ge307XG4gICAgICAgICAgICBpZiAoXy5jc3NUcmFuc2l0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknO1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHBvc2l0aW9uUHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJywgJyArIHkgKyAnLCAwcHgpJztcbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhwb3NpdGlvblByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXREaW1lbnNpb25zID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLiRsaXN0LmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICgnMHB4ICcgKyBfLm9wdGlvbnMuY2VudGVyUGFkZGluZylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJGxpc3QuaGVpZ2h0KF8uJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KHRydWUpICogXy5vcHRpb25zLnNsaWRlc1RvU2hvdyk7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLiRsaXN0LmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IChfLm9wdGlvbnMuY2VudGVyUGFkZGluZyArICcgMHB4JylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF8ubGlzdFdpZHRoID0gXy4kbGlzdC53aWR0aCgpO1xuICAgICAgICBfLmxpc3RIZWlnaHQgPSBfLiRsaXN0LmhlaWdodCgpO1xuXG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UgJiYgXy5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLnNsaWRlV2lkdGggPSBNYXRoLmNlaWwoXy5saXN0V2lkdGggLyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KTtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2sud2lkdGgoTWF0aC5jZWlsKChfLnNsaWRlV2lkdGggKiBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS5sZW5ndGgpKSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMudmFyaWFibGVXaWR0aCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay53aWR0aCg1MDAwICogXy5zbGlkZUNvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uc2xpZGVXaWR0aCA9IE1hdGguY2VpbChfLmxpc3RXaWR0aCk7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmhlaWdodChNYXRoLmNlaWwoKF8uJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KHRydWUpICogXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykubGVuZ3RoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IF8uJHNsaWRlcy5maXJzdCgpLm91dGVyV2lkdGgodHJ1ZSkgLSBfLiRzbGlkZXMuZmlyc3QoKS53aWR0aCgpO1xuICAgICAgICBpZiAoXy5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09IGZhbHNlKSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS53aWR0aChfLnNsaWRlV2lkdGggLSBvZmZzZXQpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRGYWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgdGFyZ2V0TGVmdDtcblxuICAgICAgICBfLiRzbGlkZXMuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IChfLnNsaWRlV2lkdGggKiBpbmRleCkgKiAtMTtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRhcmdldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4IC0gMixcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleCAtIDIsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy4kc2xpZGVzLmVxKF8uY3VycmVudFNsaWRlKS5jc3Moe1xuICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4IC0gMSxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA9PT0gMSAmJiBfLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQgPT09IHRydWUgJiYgXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEhlaWdodCA9IF8uJHNsaWRlcy5lcShfLmN1cnJlbnRTbGlkZSkub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgICAgICAgICBfLiRsaXN0LmNzcygnaGVpZ2h0JywgdGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRPcHRpb24gPVxuICAgIFNsaWNrLnByb3RvdHlwZS5zbGlja1NldE9wdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhY2NlcHRzIGFyZ3VtZW50cyBpbiBmb3JtYXQgb2Y6XG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGZvciBjaGFuZ2luZyBhIHNpbmdsZSBvcHRpb24ncyB2YWx1ZTpcbiAgICAgICAgICogICAgIC5zbGljayhcInNldE9wdGlvblwiLCBvcHRpb24sIHZhbHVlLCByZWZyZXNoIClcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gZm9yIGNoYW5naW5nIGEgc2V0IG9mIHJlc3BvbnNpdmUgb3B0aW9uczpcbiAgICAgICAgICogICAgIC5zbGljayhcInNldE9wdGlvblwiLCAncmVzcG9uc2l2ZScsIFt7fSwgLi4uXSwgcmVmcmVzaCApXG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGZvciB1cGRhdGluZyBtdWx0aXBsZSB2YWx1ZXMgYXQgb25jZSAobm90IHJlc3BvbnNpdmUpXG4gICAgICAgICAqICAgICAuc2xpY2soXCJzZXRPcHRpb25cIiwgeyAnb3B0aW9uJzogdmFsdWUsIC4uLiB9LCByZWZyZXNoIClcbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLCBsLCBpdGVtLCBvcHRpb24sIHZhbHVlLCByZWZyZXNoID0gZmFsc2UsIHR5cGU7XG5cbiAgICAgICAgaWYoICQudHlwZSggYXJndW1lbnRzWzBdICkgPT09ICdvYmplY3QnICkge1xuXG4gICAgICAgICAgICBvcHRpb24gPSAgYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgcmVmcmVzaCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHR5cGUgPSAnbXVsdGlwbGUnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoICQudHlwZSggYXJndW1lbnRzWzBdICkgPT09ICdzdHJpbmcnICkge1xuXG4gICAgICAgICAgICBvcHRpb24gPSAgYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZWZyZXNoID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICAgICAgICBpZiAoIGFyZ3VtZW50c1swXSA9PT0gJ3Jlc3BvbnNpdmUnICYmICQudHlwZSggYXJndW1lbnRzWzFdICkgPT09ICdhcnJheScgKSB7XG5cbiAgICAgICAgICAgICAgICB0eXBlID0gJ3Jlc3BvbnNpdmUnO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgYXJndW1lbnRzWzFdICE9PSAndW5kZWZpbmVkJyApIHtcblxuICAgICAgICAgICAgICAgIHR5cGUgPSAnc2luZ2xlJztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHR5cGUgPT09ICdzaW5nbGUnICkge1xuXG4gICAgICAgICAgICBfLm9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xuXG5cbiAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gJ211bHRpcGxlJyApIHtcblxuICAgICAgICAgICAgJC5lYWNoKCBvcHRpb24gLCBmdW5jdGlvbiggb3B0LCB2YWwgKSB7XG5cbiAgICAgICAgICAgICAgICBfLm9wdGlvbnNbb3B0XSA9IHZhbDtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09PSAncmVzcG9uc2l2ZScgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIGl0ZW0gaW4gdmFsdWUgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiggJC50eXBlKCBfLm9wdGlvbnMucmVzcG9uc2l2ZSApICE9PSAnYXJyYXknICkge1xuXG4gICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5yZXNwb25zaXZlID0gWyB2YWx1ZVtpdGVtXSBdO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBsID0gXy5vcHRpb25zLnJlc3BvbnNpdmUubGVuZ3RoLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSByZXNwb25zaXZlIG9iamVjdCBhbmQgc3BsaWNlIG91dCBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSggbCA+PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggXy5vcHRpb25zLnJlc3BvbnNpdmVbbF0uYnJlYWtwb2ludCA9PT0gdmFsdWVbaXRlbV0uYnJlYWtwb2ludCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5yZXNwb25zaXZlLnNwbGljZShsLDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGwtLTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zLnJlc3BvbnNpdmUucHVzaCggdmFsdWVbaXRlbV0gKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHJlZnJlc2ggKSB7XG5cbiAgICAgICAgICAgIF8udW5sb2FkKCk7XG4gICAgICAgICAgICBfLnJlaW5pdCgpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5zZXREaW1lbnNpb25zKCk7XG5cbiAgICAgICAgXy5zZXRIZWlnaHQoKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLnNldENTUyhfLmdldExlZnQoXy5jdXJyZW50U2xpZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uc2V0RmFkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ3NldFBvc2l0aW9uJywgW19dKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0UHJvcHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuXG4gICAgICAgIF8ucG9zaXRpb25Qcm9wID0gXy5vcHRpb25zLnZlcnRpY2FsID09PSB0cnVlID8gJ3RvcCcgOiAnbGVmdCc7XG5cbiAgICAgICAgaWYgKF8ucG9zaXRpb25Qcm9wID09PSAndG9wJykge1xuICAgICAgICAgICAgXy4kc2xpZGVyLmFkZENsYXNzKCdzbGljay12ZXJ0aWNhbCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy4kc2xpZGVyLnJlbW92ZUNsYXNzKCdzbGljay12ZXJ0aWNhbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHlTdHlsZS5XZWJraXRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGJvZHlTdHlsZS5Nb3pUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGJvZHlTdHlsZS5tc1RyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy51c2VDU1MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLmNzc1RyYW5zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmZhZGUgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBfLm9wdGlvbnMuekluZGV4ID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICBpZiggXy5vcHRpb25zLnpJbmRleCA8IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy56SW5kZXggPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXy5vcHRpb25zLnpJbmRleCA9IF8uZGVmYXVsdHMuekluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHlTdHlsZS5PVHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF8uYW5pbVR5cGUgPSAnT1RyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSAnLW8tdHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSAnT1RyYW5zaXRpb24nO1xuICAgICAgICAgICAgaWYgKGJvZHlTdHlsZS5wZXJzcGVjdGl2ZVByb3BlcnR5ID09PSB1bmRlZmluZWQgJiYgYm9keVN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID09PSB1bmRlZmluZWQpIF8uYW5pbVR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keVN0eWxlLk1velRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gJ01velRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSAnLW1vei10cmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2l0aW9uVHlwZSA9ICdNb3pUcmFuc2l0aW9uJztcbiAgICAgICAgICAgIGlmIChib2R5U3R5bGUucGVyc3BlY3RpdmVQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICYmIGJvZHlTdHlsZS5Nb3pQZXJzcGVjdGl2ZSA9PT0gdW5kZWZpbmVkKSBfLmFuaW1UeXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlTdHlsZS53ZWJraXRUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9ICd3ZWJraXRUcmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJy13ZWJraXQtdHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSAnd2Via2l0VHJhbnNpdGlvbic7XG4gICAgICAgICAgICBpZiAoYm9keVN0eWxlLnBlcnNwZWN0aXZlUHJvcGVydHkgPT09IHVuZGVmaW5lZCAmJiBib2R5U3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPT09IHVuZGVmaW5lZCkgXy5hbmltVHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5U3R5bGUubXNUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9ICdtc1RyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSAnLW1zLXRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gJ21zVHJhbnNpdGlvbic7XG4gICAgICAgICAgICBpZiAoYm9keVN0eWxlLm1zVHJhbnNmb3JtID09PSB1bmRlZmluZWQpIF8uYW5pbVR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keVN0eWxlLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkICYmIF8uYW5pbVR5cGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gJ3RyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSAndHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSAndHJhbnNpdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgXy50cmFuc2Zvcm1zRW5hYmxlZCA9IF8ub3B0aW9ucy51c2VUcmFuc2Zvcm0gJiYgKF8uYW5pbVR5cGUgIT09IG51bGwgJiYgXy5hbmltVHlwZSAhPT0gZmFsc2UpO1xuICAgIH07XG5cblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRTbGlkZUNsYXNzZXMgPSBmdW5jdGlvbihpbmRleCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGNlbnRlck9mZnNldCwgYWxsU2xpZGVzLCBpbmRleE9mZnNldCwgcmVtYWluZGVyO1xuXG4gICAgICAgIGFsbFNsaWRlcyA9IF8uJHNsaWRlclxuICAgICAgICAgICAgLmZpbmQoJy5zbGljay1zbGlkZScpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWFjdGl2ZSBzbGljay1jZW50ZXIgc2xpY2stY3VycmVudCcpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgLmVxKGluZGV4KVxuICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1jdXJyZW50Jyk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgIHZhciBldmVuQ29lZiA9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgJSAyID09PSAwID8gMSA6IDA7XG5cbiAgICAgICAgICAgIGNlbnRlck9mZnNldCA9IE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpO1xuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gY2VudGVyT2Zmc2V0ICYmIGluZGV4IDw9IChfLnNsaWRlQ291bnQgLSAxKSAtIGNlbnRlck9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleCAtIGNlbnRlck9mZnNldCArIGV2ZW5Db2VmLCBpbmRleCArIGNlbnRlck9mZnNldCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZmZzZXQgPSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4T2Zmc2V0IC0gY2VudGVyT2Zmc2V0ICsgMSArIGV2ZW5Db2VmLCBpbmRleE9mZnNldCArIGNlbnRlck9mZnNldCArIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKGFsbFNsaWRlcy5sZW5ndGggLSAxIC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stY2VudGVyJyk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBfLnNsaWRlQ291bnQgLSAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXEoXy5vcHRpb25zLnNsaWRlc1RvU2hvdylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stY2VudGVyJyk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy4kc2xpZGVzXG4gICAgICAgICAgICAgICAgLmVxKGluZGV4KVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stY2VudGVyJyk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gKF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpKSB7XG5cbiAgICAgICAgICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4LCBpbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxsU2xpZGVzLmxlbmd0aCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJlbWFpbmRlciA9IF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG4gICAgICAgICAgICAgICAgaW5kZXhPZmZzZXQgPSBfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUgPyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgaW5kZXggOiBpbmRleDtcblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID09IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAmJiAoXy5zbGlkZUNvdW50IC0gaW5kZXgpIDwgXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4T2Zmc2V0IC0gKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLSByZW1haW5kZXIpLCBpbmRleE9mZnNldCArIHJlbWFpbmRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleE9mZnNldCwgaW5kZXhPZmZzZXQgKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5sYXp5TG9hZCA9PT0gJ29uZGVtYW5kJyB8fCBfLm9wdGlvbnMubGF6eUxvYWQgPT09ICdhbnRpY2lwYXRlZCcpIHtcbiAgICAgICAgICAgIF8ubGF6eUxvYWQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0dXBJbmZpbml0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGksIHNsaWRlSW5kZXgsIGluZmluaXRlQ291bnQ7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLm9wdGlvbnMuY2VudGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgc2xpZGVJbmRleCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5maW5pdGVDb3VudCA9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZmluaXRlQ291bnQgPSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IF8uc2xpZGVDb3VudDsgaSA+IChfLnNsaWRlQ291bnQgLVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5maW5pdGVDb3VudCk7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUluZGV4ID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICQoXy4kc2xpZGVzW3NsaWRlSW5kZXhdKS5jbG9uZSh0cnVlKS5hdHRyKCdpZCcsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnLCBzbGlkZUluZGV4IC0gXy5zbGlkZUNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnByZXBlbmRUbyhfLiRzbGlkZVRyYWNrKS5hZGRDbGFzcygnc2xpY2stY2xvbmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmZpbml0ZUNvdW50ICArIF8uc2xpZGVDb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAkKF8uJHNsaWRlc1tzbGlkZUluZGV4XSkuY2xvbmUodHJ1ZSkuYXR0cignaWQnLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkYXRhLXNsaWNrLWluZGV4Jywgc2xpZGVJbmRleCArIF8uc2xpZGVDb3VudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhfLiRzbGlkZVRyYWNrKS5hZGRDbGFzcygnc2xpY2stY2xvbmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suZmluZCgnLnNsaWNrLWNsb25lZCcpLmZpbmQoJ1tpZF0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoJ2lkJywgJycpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbiggdG9nZ2xlICkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiggIXRvZ2dsZSApIHtcbiAgICAgICAgICAgIF8uYXV0b1BsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBfLmludGVycnVwdGVkID0gdG9nZ2xlO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZWxlY3RIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPVxuICAgICAgICAgICAgJChldmVudC50YXJnZXQpLmlzKCcuc2xpY2stc2xpZGUnKSA/XG4gICAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpIDpcbiAgICAgICAgICAgICAgICAkKGV2ZW50LnRhcmdldCkucGFyZW50cygnLnNsaWNrLXNsaWRlJyk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQodGFyZ2V0RWxlbWVudC5hdHRyKCdkYXRhLXNsaWNrLWluZGV4JykpO1xuXG4gICAgICAgIGlmICghaW5kZXgpIGluZGV4ID0gMDtcblxuICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoaW5kZXgsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgXy5zbGlkZUhhbmRsZXIoaW5kZXgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zbGlkZUhhbmRsZXIgPSBmdW5jdGlvbihpbmRleCwgc3luYywgZG9udEFuaW1hdGUpIHtcblxuICAgICAgICB2YXIgdGFyZ2V0U2xpZGUsIGFuaW1TbGlkZSwgb2xkU2xpZGUsIHNsaWRlTGVmdCwgdGFyZ2V0TGVmdCA9IG51bGwsXG4gICAgICAgICAgICBfID0gdGhpcywgbmF2VGFyZ2V0O1xuXG4gICAgICAgIHN5bmMgPSBzeW5jIHx8IGZhbHNlO1xuXG4gICAgICAgIGlmIChfLmFuaW1hdGluZyA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMud2FpdEZvckFuaW1hdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gdHJ1ZSAmJiBfLmN1cnJlbnRTbGlkZSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy5hc05hdkZvcihpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRTbGlkZSA9IGluZGV4O1xuICAgICAgICB0YXJnZXRMZWZ0ID0gXy5nZXRMZWZ0KHRhcmdldFNsaWRlKTtcbiAgICAgICAgc2xpZGVMZWZ0ID0gXy5nZXRMZWZ0KF8uY3VycmVudFNsaWRlKTtcblxuICAgICAgICBfLmN1cnJlbnRMZWZ0ID0gXy5zd2lwZUxlZnQgPT09IG51bGwgPyBzbGlkZUxlZnQgOiBfLnN3aXBlTGVmdDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSAmJiBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gZmFsc2UgJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+IF8uZ2V0RG90Q291bnQoKSAqIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkpIHtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uY3VycmVudFNsaWRlO1xuICAgICAgICAgICAgICAgIGlmIChkb250QW5pbWF0ZSAhPT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIF8uYW5pbWF0ZVNsaWRlKHNsaWRlTGVmdCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZSh0YXJnZXRTbGlkZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKHRhcmdldFNsaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSAmJiBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSAmJiAoaW5kZXggPCAwIHx8IGluZGV4ID4gKF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkpKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2xpZGUgPSBfLmN1cnJlbnRTbGlkZTtcbiAgICAgICAgICAgICAgICBpZiAoZG9udEFuaW1hdGUgIT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgICAgICBfLmFuaW1hdGVTbGlkZShzbGlkZUxlZnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUodGFyZ2V0U2xpZGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZSh0YXJnZXRTbGlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMuYXV0b3BsYXkgKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKF8uYXV0b1BsYXlUaW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0U2xpZGUgPCAwKSB7XG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgYW5pbVNsaWRlID0gXy5zbGlkZUNvdW50IC0gKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1TbGlkZSA9IF8uc2xpZGVDb3VudCArIHRhcmdldFNsaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFNsaWRlID49IF8uc2xpZGVDb3VudCkge1xuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGFuaW1TbGlkZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1TbGlkZSA9IHRhcmdldFNsaWRlIC0gXy5zbGlkZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5pbVNsaWRlID0gdGFyZ2V0U2xpZGU7XG4gICAgICAgIH1cblxuICAgICAgICBfLmFuaW1hdGluZyA9IHRydWU7XG5cbiAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2JlZm9yZUNoYW5nZScsIFtfLCBfLmN1cnJlbnRTbGlkZSwgYW5pbVNsaWRlXSk7XG5cbiAgICAgICAgb2xkU2xpZGUgPSBfLmN1cnJlbnRTbGlkZTtcbiAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBhbmltU2xpZGU7XG5cbiAgICAgICAgXy5zZXRTbGlkZUNsYXNzZXMoXy5jdXJyZW50U2xpZGUpO1xuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmFzTmF2Rm9yICkge1xuXG4gICAgICAgICAgICBuYXZUYXJnZXQgPSBfLmdldE5hdlRhcmdldCgpO1xuICAgICAgICAgICAgbmF2VGFyZ2V0ID0gbmF2VGFyZ2V0LnNsaWNrKCdnZXRTbGljaycpO1xuXG4gICAgICAgICAgICBpZiAoIG5hdlRhcmdldC5zbGlkZUNvdW50IDw9IG5hdlRhcmdldC5vcHRpb25zLnNsaWRlc1RvU2hvdyApIHtcbiAgICAgICAgICAgICAgICBuYXZUYXJnZXQuc2V0U2xpZGVDbGFzc2VzKF8uY3VycmVudFNsaWRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgXy51cGRhdGVEb3RzKCk7XG4gICAgICAgIF8udXBkYXRlQXJyb3dzKCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoZG9udEFuaW1hdGUgIT09IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIF8uZmFkZVNsaWRlT3V0KG9sZFNsaWRlKTtcblxuICAgICAgICAgICAgICAgIF8uZmFkZVNsaWRlKGFuaW1TbGlkZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKGFuaW1TbGlkZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUoYW5pbVNsaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8uYW5pbWF0ZUhlaWdodCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbnRBbmltYXRlICE9PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8uYW5pbWF0ZVNsaWRlKHRhcmdldExlZnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKGFuaW1TbGlkZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8ucG9zdFNsaWRlKGFuaW1TbGlkZSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc3RhcnRMb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYXJyb3dzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgXy4kcHJldkFycm93LmhpZGUoKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdy5oaWRlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZG90cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uJGRvdHMuaGlkZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfLiRzbGlkZXIuYWRkQ2xhc3MoJ3NsaWNrLWxvYWRpbmcnKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc3dpcGVEaXJlY3Rpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgeERpc3QsIHlEaXN0LCByLCBzd2lwZUFuZ2xlLCBfID0gdGhpcztcblxuICAgICAgICB4RGlzdCA9IF8udG91Y2hPYmplY3Quc3RhcnRYIC0gXy50b3VjaE9iamVjdC5jdXJYO1xuICAgICAgICB5RGlzdCA9IF8udG91Y2hPYmplY3Quc3RhcnRZIC0gXy50b3VjaE9iamVjdC5jdXJZO1xuICAgICAgICByID0gTWF0aC5hdGFuMih5RGlzdCwgeERpc3QpO1xuXG4gICAgICAgIHN3aXBlQW5nbGUgPSBNYXRoLnJvdW5kKHIgKiAxODAgLyBNYXRoLlBJKTtcbiAgICAgICAgaWYgKHN3aXBlQW5nbGUgPCAwKSB7XG4gICAgICAgICAgICBzd2lwZUFuZ2xlID0gMzYwIC0gTWF0aC5hYnMoc3dpcGVBbmdsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHN3aXBlQW5nbGUgPD0gNDUpICYmIChzd2lwZUFuZ2xlID49IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gKF8ub3B0aW9ucy5ydGwgPT09IGZhbHNlID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzd2lwZUFuZ2xlIDw9IDM2MCkgJiYgKHN3aXBlQW5nbGUgPj0gMzE1KSkge1xuICAgICAgICAgICAgcmV0dXJuIChfLm9wdGlvbnMucnRsID09PSBmYWxzZSA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3dpcGVBbmdsZSA+PSAxMzUpICYmIChzd2lwZUFuZ2xlIDw9IDIyNSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoXy5vcHRpb25zLnJ0bCA9PT0gZmFsc2UgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKChzd2lwZUFuZ2xlID49IDM1KSAmJiAoc3dpcGVBbmdsZSA8PSAxMzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ3ZlcnRpY2FsJztcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc3dpcGVFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHNsaWRlQ291bnQsXG4gICAgICAgICAgICBkaXJlY3Rpb247XG5cbiAgICAgICAgXy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBfLnN3aXBpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoXy5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIF8uc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBfLmludGVycnVwdGVkID0gZmFsc2U7XG4gICAgICAgIF8uc2hvdWxkQ2xpY2sgPSAoIF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPiAxMCApID8gZmFsc2UgOiB0cnVlO1xuXG4gICAgICAgIGlmICggXy50b3VjaE9iamVjdC5jdXJYID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8udG91Y2hPYmplY3QuZWRnZUhpdCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdlZGdlJywgW18sIF8uc3dpcGVEaXJlY3Rpb24oKSBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA+PSBfLnRvdWNoT2JqZWN0Lm1pblN3aXBlICkge1xuXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBfLnN3aXBlRGlyZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGRpcmVjdGlvbiApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rvd24nOlxuXG4gICAgICAgICAgICAgICAgICAgIHNsaWRlQ291bnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zLnN3aXBlVG9TbGlkZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jaGVja05hdmlnYWJsZSggXy5jdXJyZW50U2xpZGUgKyBfLmdldFNsaWRlQ291bnQoKSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSArIF8uZ2V0U2xpZGVDb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIF8uY3VycmVudERpcmVjdGlvbiA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndXAnOlxuXG4gICAgICAgICAgICAgICAgICAgIHNsaWRlQ291bnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zLnN3aXBlVG9TbGlkZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jaGVja05hdmlnYWJsZSggXy5jdXJyZW50U2xpZGUgLSBfLmdldFNsaWRlQ291bnQoKSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSAtIF8uZ2V0U2xpZGVDb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIF8uY3VycmVudERpcmVjdGlvbiA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIGRpcmVjdGlvbiAhPSAndmVydGljYWwnICkge1xuXG4gICAgICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoIHNsaWRlQ291bnQgKTtcbiAgICAgICAgICAgICAgICBfLnRvdWNoT2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ3N3aXBlJywgW18sIGRpcmVjdGlvbiBdKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICggXy50b3VjaE9iamVjdC5zdGFydFggIT09IF8udG91Y2hPYmplY3QuY3VyWCApIHtcblxuICAgICAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKCBfLmN1cnJlbnRTbGlkZSApO1xuICAgICAgICAgICAgICAgIF8udG91Y2hPYmplY3QgPSB7fTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc3dpcGVIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKChfLm9wdGlvbnMuc3dpcGUgPT09IGZhbHNlKSB8fCAoJ29udG91Y2hlbmQnIGluIGRvY3VtZW50ICYmIF8ub3B0aW9ucy5zd2lwZSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLmRyYWdnYWJsZSA9PT0gZmFsc2UgJiYgZXZlbnQudHlwZS5pbmRleE9mKCdtb3VzZScpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgXy50b3VjaE9iamVjdC5maW5nZXJDb3VudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzLmxlbmd0aCA6IDE7XG5cbiAgICAgICAgXy50b3VjaE9iamVjdC5taW5Td2lwZSA9IF8ubGlzdFdpZHRoIC8gXy5vcHRpb25zXG4gICAgICAgICAgICAudG91Y2hUaHJlc2hvbGQ7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8udG91Y2hPYmplY3QubWluU3dpcGUgPSBfLmxpc3RIZWlnaHQgLyBfLm9wdGlvbnNcbiAgICAgICAgICAgICAgICAudG91Y2hUaHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmRhdGEuYWN0aW9uKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICBfLnN3aXBlU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtb3ZlJzpcbiAgICAgICAgICAgICAgICBfLnN3aXBlTW92ZShldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgXy5zd2lwZUVuZChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zd2lwZU1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGVkZ2VXYXNIaXQgPSBmYWxzZSxcbiAgICAgICAgICAgIGN1ckxlZnQsIHN3aXBlRGlyZWN0aW9uLCBzd2lwZUxlbmd0aCwgcG9zaXRpb25PZmZzZXQsIHRvdWNoZXMsIHZlcnRpY2FsU3dpcGVMZW5ndGg7XG5cbiAgICAgICAgdG91Y2hlcyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgIT09IHVuZGVmaW5lZCA/IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyA6IG51bGw7XG5cbiAgICAgICAgaWYgKCFfLmRyYWdnaW5nIHx8IF8uc2Nyb2xsaW5nIHx8IHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1ckxlZnQgPSBfLmdldExlZnQoXy5jdXJyZW50U2xpZGUpO1xuXG4gICAgICAgIF8udG91Y2hPYmplY3QuY3VyWCA9IHRvdWNoZXMgIT09IHVuZGVmaW5lZCA/IHRvdWNoZXNbMF0ucGFnZVggOiBldmVudC5jbGllbnRYO1xuICAgICAgICBfLnRvdWNoT2JqZWN0LmN1clkgPSB0b3VjaGVzICE9PSB1bmRlZmluZWQgPyB0b3VjaGVzWzBdLnBhZ2VZIDogZXZlbnQuY2xpZW50WTtcblxuICAgICAgICBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoXG4gICAgICAgICAgICBNYXRoLnBvdyhfLnRvdWNoT2JqZWN0LmN1clggLSBfLnRvdWNoT2JqZWN0LnN0YXJ0WCwgMikpKTtcblxuICAgICAgICB2ZXJ0aWNhbFN3aXBlTGVuZ3RoID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoXG4gICAgICAgICAgICBNYXRoLnBvdyhfLnRvdWNoT2JqZWN0LmN1clkgLSBfLnRvdWNoT2JqZWN0LnN0YXJ0WSwgMikpKTtcblxuICAgICAgICBpZiAoIV8ub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgJiYgIV8uc3dpcGluZyAmJiB2ZXJ0aWNhbFN3aXBlTGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgXy5zY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPSB2ZXJ0aWNhbFN3aXBlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVEaXJlY3Rpb24gPSBfLnN3aXBlRGlyZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgIT09IHVuZGVmaW5lZCAmJiBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgXy5zd2lwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvbk9mZnNldCA9IChfLm9wdGlvbnMucnRsID09PSBmYWxzZSA/IDEgOiAtMSkgKiAoXy50b3VjaE9iamVjdC5jdXJYID4gXy50b3VjaE9iamVjdC5zdGFydFggPyAxIDogLTEpO1xuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcG9zaXRpb25PZmZzZXQgPSBfLnRvdWNoT2JqZWN0LmN1clkgPiBfLnRvdWNoT2JqZWN0LnN0YXJ0WSA/IDEgOiAtMTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc3dpcGVMZW5ndGggPSBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoO1xuXG4gICAgICAgIF8udG91Y2hPYmplY3QuZWRnZUhpdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoKF8uY3VycmVudFNsaWRlID09PSAwICYmIHN3aXBlRGlyZWN0aW9uID09PSAncmlnaHQnKSB8fCAoXy5jdXJyZW50U2xpZGUgPj0gXy5nZXREb3RDb3VudCgpICYmIHN3aXBlRGlyZWN0aW9uID09PSAnbGVmdCcpKSB7XG4gICAgICAgICAgICAgICAgc3dpcGVMZW5ndGggPSBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoICogXy5vcHRpb25zLmVkZ2VGcmljdGlvbjtcbiAgICAgICAgICAgICAgICBfLnRvdWNoT2JqZWN0LmVkZ2VIaXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uc3dpcGVMZWZ0ID0gY3VyTGVmdCArIHN3aXBlTGVuZ3RoICogcG9zaXRpb25PZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLnN3aXBlTGVmdCA9IGN1ckxlZnQgKyAoc3dpcGVMZW5ndGggKiAoXy4kbGlzdC5oZWlnaHQoKSAvIF8ubGlzdFdpZHRoKSkgKiBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5zd2lwZUxlZnQgPSBjdXJMZWZ0ICsgc3dpcGVMZW5ndGggKiBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gdHJ1ZSB8fCBfLm9wdGlvbnMudG91Y2hNb3ZlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uYW5pbWF0aW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnN3aXBlTGVmdCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBfLnNldENTUyhfLnN3aXBlTGVmdCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHRvdWNoZXM7XG5cbiAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKF8udG91Y2hPYmplY3QuZmluZ2VyQ291bnQgIT09IDEgfHwgXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8udG91Y2hPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvdWNoZXMgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICBfLnRvdWNoT2JqZWN0LnN0YXJ0WCA9IF8udG91Y2hPYmplY3QuY3VyWCA9IHRvdWNoZXMgIT09IHVuZGVmaW5lZCA/IHRvdWNoZXMucGFnZVggOiBldmVudC5jbGllbnRYO1xuICAgICAgICBfLnRvdWNoT2JqZWN0LnN0YXJ0WSA9IF8udG91Y2hPYmplY3QuY3VyWSA9IHRvdWNoZXMgIT09IHVuZGVmaW5lZCA/IHRvdWNoZXMucGFnZVkgOiBldmVudC5jbGllbnRZO1xuXG4gICAgICAgIF8uZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51bmZpbHRlclNsaWRlcyA9IFNsaWNrLnByb3RvdHlwZS5zbGlja1VuZmlsdGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLiRzbGlkZXNDYWNoZSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBfLnVubG9hZCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc0NhY2hlLmFwcGVuZFRvKF8uJHNsaWRlVHJhY2spO1xuXG4gICAgICAgICAgICBfLnJlaW5pdCgpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudW5sb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgICQoJy5zbGljay1jbG9uZWQnLCBfLiRzbGlkZXIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmIChfLiRkb3RzKSB7XG4gICAgICAgICAgICBfLiRkb3RzLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uJHByZXZBcnJvdyAmJiBfLmh0bWxFeHByLnRlc3QoXy5vcHRpb25zLnByZXZBcnJvdykpIHtcbiAgICAgICAgICAgIF8uJHByZXZBcnJvdy5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLiRuZXh0QXJyb3cgJiYgXy5odG1sRXhwci50ZXN0KF8ub3B0aW9ucy5uZXh0QXJyb3cpKSB7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3cucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stc2xpZGUgc2xpY2stYWN0aXZlIHNsaWNrLXZpc2libGUgc2xpY2stY3VycmVudCcpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpXG4gICAgICAgICAgICAuY3NzKCd3aWR0aCcsICcnKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudW5zbGljayA9IGZ1bmN0aW9uKGZyb21CcmVha3BvaW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcigndW5zbGljaycsIFtfLCBmcm9tQnJlYWtwb2ludF0pO1xuICAgICAgICBfLmRlc3Ryb3koKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudXBkYXRlQXJyb3dzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgY2VudGVyT2Zmc2V0O1xuXG4gICAgICAgIGNlbnRlck9mZnNldCA9IE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpO1xuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJlxuICAgICAgICAgICAgIV8ub3B0aW9ucy5pbmZpbml0ZSApIHtcblxuICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIGlmIChfLmN1cnJlbnRTbGlkZSA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LmFkZENsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5jdXJyZW50U2xpZGUgPj0gXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJiBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5hZGRDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uY3VycmVudFNsaWRlID49IF8uc2xpZGVDb3VudCAtIDEgJiYgXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5hZGRDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51cGRhdGVEb3RzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLiRkb3RzICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIF8uJGRvdHNcbiAgICAgICAgICAgICAgICAuZmluZCgnbGknKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgIC5lbmQoKTtcblxuICAgICAgICAgICAgXy4kZG90c1xuICAgICAgICAgICAgICAgIC5maW5kKCdsaScpXG4gICAgICAgICAgICAgICAgLmVxKE1hdGguZmxvb3IoXy5jdXJyZW50U2xpZGUgLyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJyk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS52aXNpYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmF1dG9wbGF5ICkge1xuXG4gICAgICAgICAgICBpZiAoIGRvY3VtZW50W18uaGlkZGVuXSApIHtcblxuICAgICAgICAgICAgICAgIF8uaW50ZXJydXB0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgICQuZm4uc2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgb3B0ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBsID0gXy5sZW5ndGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcmV0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdCA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb3B0ID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIF9baV0uc2xpY2sgPSBuZXcgU2xpY2soX1tpXSwgb3B0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXQgPSBfW2ldLnNsaWNrW29wdF0uYXBwbHkoX1tpXS5zbGljaywgYXJncyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJldCAhPSAndW5kZWZpbmVkJykgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXztcbiAgICB9O1xuXG59KSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuICogcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gKiBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuICogTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gKiBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcbiAqIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbiAqIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZS8nKTtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLypcbiAqIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4gKiBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbiAqL1xudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXj9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgLypcbiAgICogUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICogV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICovXG4gIGRlbGltcyA9IFtcbiAgICAnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCdcbiAgXSxcblxuICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICB1bndpc2UgPSBbXG4gICAgJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ1xuICBdLmNvbmNhdChkZWxpbXMpLFxuXG4gIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gIC8qXG4gICAqIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAqIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICogYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAqIHRoZW0uXG4gICAqL1xuICBub25Ib3N0Q2hhcnMgPSBbXG4gICAgJyUnLCAnLycsICc/JywgJzsnLCAnIydcbiAgXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gIGhvc3RFbmRpbmdDaGFycyA9IFtcbiAgICAnLycsICc/JywgJyMnXG4gIF0sXG4gIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gIHVuc2FmZVByb3RvY29sID0ge1xuICAgIGphdmFzY3JpcHQ6IHRydWUsXG4gICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICB9LFxuICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgamF2YXNjcmlwdDogdHJ1ZSxcbiAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gIH0sXG4gIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgaHR0cDogdHJ1ZSxcbiAgICBodHRwczogdHJ1ZSxcbiAgICBmdHA6IHRydWUsXG4gICAgZ29waGVyOiB0cnVlLFxuICAgIGZpbGU6IHRydWUsXG4gICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAnZnRwOic6IHRydWUsXG4gICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICdmaWxlOic6IHRydWVcbiAgfSxcbiAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxcycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSB7IHJldHVybiB1cmw7IH1cblxuICB2YXIgdSA9IG5ldyBVcmwoKTtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLypcbiAgICogQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gICAqIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAgKiBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICAgKi9cbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgIHNwbGl0dGVyID0gcXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykgPyAnPycgOiAnIycsXG4gICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8qXG4gICAqIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gICAqIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgICovXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvKlxuICAgKiBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAgKiB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gICAqIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgICogaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gICAqL1xuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQC9dK0BbXkAvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJiAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLypcbiAgICAgKiB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgICogdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAgKiB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgICAqIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgICogVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgICAqXG4gICAgICogZXg6XG4gICAgICogaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAgKiBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG4gICAgICovXG5cbiAgICAvKlxuICAgICAqIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAgKiBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuICAgICAqL1xuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkgeyBob3N0RW5kID0gaGVjOyB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAgKiBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICAgKi9cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLypcbiAgICAgICAqIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgICAqIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICAgKi9cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgICAqIFB1bGwgdGhhdCBvZmYuXG4gICAgICovXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHsgaG9zdEVuZCA9IGhlYzsgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7IGhvc3RFbmQgPSByZXN0Lmxlbmd0aDsgfVxuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8qXG4gICAgICogd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAgKiBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgICAqL1xuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLypcbiAgICAgKiBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgICAqIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgICAqL1xuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiYgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAqIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgKiB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgICAqIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLypcbiAgICAgICAqIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgICogSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgICogaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgICogeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8qXG4gICAgICogc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgICAqIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgICovXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAgKiBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gICAqL1xuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvKlxuICAgICAqIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAgKiBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAgKiBuZWVkIHRvIGJlLlxuICAgICAqL1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpIHsgY29udGludWU7IH1cbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiYgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvKlxuICAgKiBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAgKiBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAgKiB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gICAqIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gICAqL1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHsgb2JqID0gdXJsUGFyc2Uob2JqKTsgfVxuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSB7IHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7IH1cbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgIGhvc3QgPSBmYWxzZSxcbiAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID8gdGhpcy5ob3N0bmFtZSA6ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmIHR5cGVvZiB0aGlzLnF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5LCB7XG4gICAgICBhcnJheUZvcm1hdDogJ3JlcGVhdCcsXG4gICAgICBhZGRRdWVyeVByZWZpeDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgeyBwcm90b2NvbCArPSAnOic7IH1cblxuICAvKlxuICAgKiBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgICogdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgICovXG4gIGlmICh0aGlzLnNsYXNoZXMgfHwgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgeyBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lOyB9XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSB7IGhhc2ggPSAnIycgKyBoYXNoOyB9XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSB7IHNlYXJjaCA9ICc/JyArIHNlYXJjaDsgfVxuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgeyByZXR1cm4gcmVsYXRpdmU7IH1cbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbiAocmVsYXRpdmUpIHtcbiAgaWYgKHR5cGVvZiByZWxhdGl2ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLypcbiAgICogaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gICAqIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICAgKi9cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpIHsgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07IH1cbiAgICB9XG5cbiAgICAvLyB1cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiYgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8qXG4gICAgICogaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgICAqIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgICAqIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgICAqIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgICogdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgICAqIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgICogYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgICogYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgICAqL1xuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKSB7IH1cbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgeyByZWxhdGl2ZS5ob3N0ID0gJyc7IH1cbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHsgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJzsgfVxuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSB7IHJlbFBhdGgudW5zaGlmdCgnJyk7IH1cbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHsgcmVsUGF0aC51bnNoaWZ0KCcnKTsgfVxuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgIGlzUmVsQWJzID0gcmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyxcbiAgICBtdXN0RW5kQWJzID0gaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSxcbiAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLypcbiAgICogaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAgKiBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gICAqIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgICogcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgICogTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gICAqL1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSB7IHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDsgfSBlbHNlIHsgc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTsgfVxuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHsgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7IH0gZWxzZSB7IHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTsgfVxuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJyA/IHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycgPyByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLypcbiAgICAgKiBpdCdzIHJlbGF0aXZlXG4gICAgICogdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgICovXG4gICAgaWYgKCFzcmNQYXRoKSB7IHNyY1BhdGggPSBbXTsgfVxuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAocmVsYXRpdmUuc2VhcmNoICE9IG51bGwpIHtcbiAgICAvKlxuICAgICAqIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAgKiBsaWtlIGhyZWY9Jz9mb28nLlxuICAgICAqIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgICAqL1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3Q7XG4gICAgICAvKlxuICAgICAgICogb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAqIHRoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAqIHVybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgICovXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgPyByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgIT09IG51bGwgfHwgcmVzdWx0LnNlYXJjaCAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICsgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8qXG4gICAgICogbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgICAqIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgICovXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qXG4gICAqIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgKiBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgICogdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICovXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnO1xuXG4gIC8qXG4gICAqIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgICogaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgICovXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJiAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fCAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gaXNBYnNvbHV0ZSA/ICcnIDogc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZTtcbiAgICAvKlxuICAgICAqIG9jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICogdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAqIHVybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAqL1xuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/IHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChzcmNQYXRoLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfVxuXG4gIC8vIHRvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmIChyZXN1bHQucGF0aG5hbWUgIT09IG51bGwgfHwgcmVzdWx0LnNlYXJjaCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB7IHRoaXMuaG9zdG5hbWUgPSBob3N0OyB9XG59O1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcbiIsImNvbnN0IHJhbmRvbVVVSUQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCAmJiBjcnlwdG8ucmFuZG9tVVVJRC5iaW5kKGNyeXB0byk7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSURcbn07IiwiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICByZXR1cm4gYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV07XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwiaW1wb3J0IG5hdGl2ZSBmcm9tICcuL25hdGl2ZS5qcyc7XG5pbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7IiwiLyohXG4gKiBWYWxpZGV0dGEgKGh0dHBzOi8vZ2l0aHViLmNvbS9QaXhlbFVuaW9uL3ZhbGlkZXR0YSlcbiAqIFZlcnNpb24gMi4wLjNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL2hzbmF5ZC92YWxpZGV0dGEvYmxvYi9tYXN0ZXIvTElDRU5DRSlcbiAqIENvcHlyaWdodCAyMDEzLTIwMTcgSGFzYW4gQXlkb8SfZHUgLSBodHRwOi8vd3d3Lmhhc2FuYXlkb2dkdS5jb20gXG4gKi9cbi8qZXNsaW50LWVudiBlczY6ZmFsc2UqL1xuXG4oZnVuY3Rpb24oJCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiAgRGVjbGFyZSB2YXJpYWJsZXNcbiAgICovXG4gIHZhciBGSUVMRFMgPSB7fTsgLy8gQ3VycmVudCBmaWVsZHMvZmllbGRzXG4gIC8vIFJlZ0V4cCBmb3IgaW5wdXQgdmFsaWRhdGlvbiBydWxlc1xuICB2YXIgUlJVTEUgPSBuZXcgUmVnRXhwKC9eKG1pbkNoZWNrZWR8bWF4Q2hlY2tlZHxtaW5TZWxlY3RlZHxtYXhTZWxlY3RlZHxtaW5MZW5ndGh8bWF4TGVuZ3RofGVxdWFsVG98ZGlmZmVyZW50fHJlZ0V4cHxyZW1vdGV8Y2FsbGJhY2spXFxbKFxcd3sxLDE1fSlcXF0vaSk7XG4gIC8vIFJlZ0V4cCBmb3IgbWFpbCBjb250cm9sIG1ldGhvZFxuICAvLyBAZnJvbSAoaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2Uvc3RhdGVzLW9mLXRoZS10eXBlLWF0dHJpYnV0ZS5odG1sI2UtbWFpbC1zdGF0ZS0lMjh0eXBlPWVtYWlsJTI5KVxuICB2YXIgUk1BSUwgPSBuZXcgUmVnRXhwKC9eW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLyk7XG4gIC8vUmVnRXhwIGZvciBpbnB1dCBudW1iZXIgY29udHJvbCBtZXRob2RcbiAgdmFyIFJOVU1CRVIgPSBuZXcgUmVnRXhwKC9eW1xcLVxcK10/KFxcZCt8XFxkK1xcLj9cXGQrKSQvKTtcblxuICAvKipcbiAgICogIEZvcm0gdmFsaWRhdGUgZXJyb3IgbWVzc2FnZXNcbiAgICovXG4gIHZhciBtZXNzYWdlcyA9IHtcbiAgICByZXF1aXJlZCAgOiAnVGhpcyBmaWVsZCBpcyByZXF1aXJlZC4nLFxuICAgIGVtYWlsICAgICA6ICdZb3VyIEUtbWFpbCBhZGRyZXNzIGFwcGVhcnMgdG8gYmUgaW52YWxpZC4nLFxuICAgIG51bWJlciAgICA6ICdZb3UgY2FuIGVudGVyIG9ubHkgbnVtYmVycyBpbiB0aGlzIGZpZWxkLicsXG4gICAgbnVtTWF4ICAgIDogJ1BsZWFzZSBlbnRlciBhIG51bWJlciBsZXNzIHRoYW4ge21heH0uJyxcbiAgICBudW1NaW4gICAgOiAnUGxlYXNlIGVudGVyIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiB7bWlufS4nLFxuICAgIG51bVJhbmdlICA6ICdQbGVhc2UgZW50ZXIgYSBudW1iZXIgZ3JlYXRlciB0aGFuIHttaW59IGFuZCBsZXNzIHRoYW4ge21heH0uJyxcbiAgICBtYXhMZW5ndGggOiAnTWF4aW11bSB7Y291bnR9IGNoYXJhY3RlcnMgYWxsb3dlZC4nLFxuICAgIG1pbkxlbmd0aCA6ICdNaW5pbXVtIHtjb3VudH0gY2hhcmFjdGVycyBhbGxvd2VkLicsXG4gICAgbWF4Q2hlY2tlZCAgOiAnTWF4aW11bSB7Y291bnR9IG9wdGlvbnMgYWxsb3dlZC4nLFxuICAgIG1pbkNoZWNrZWQgIDogJ1BsZWFzZSBzZWxlY3QgbWluaW11bSB7Y291bnR9IG9wdGlvbnMuJyxcbiAgICBtYXhTZWxlY3RlZCA6ICdNYXhpbXVtIHtjb3VudH0gc2VsZWN0aW9uIGFsbG93ZWQuJyxcbiAgICBtaW5TZWxlY3RlZCA6ICdNaW5pbXVtIHtjb3VudH0gc2VsZWN0aW9uIGFsbG93ZWQuJyxcbiAgICBub3RFcXVhbCAgICA6ICdGaWVsZHMgZG8gbm90IG1hdGNoLicsXG4gICAgZGlmZmVyZW50ICAgOiAnRmllbGRzIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyBlYWNoIG90aGVyJyxcbiAgICBjcmVkaXRDYXJkICA6ICdJbnZhbGlkIGNyZWRpdCBjYXJkIG51bWJlci4nLFxuICB9O1xuXG4gIC8qKlxuICAgKiAgUGx1Z2luIGRlZmF1bHRzXG4gICAqL1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgc2hvd0Vycm9yTWVzc2FnZSA6IHRydWUsIC8vIElmIHlvdSBkb250IHdhbnQgdG8gZGlzcGxheSBlcnJvciBtZXNzYWdlcyBzZXQgdGhpcyBvcHRpb25zIGZhbHNlXG4gICAgc2hvd011bHRpcGxlOiBmYWxzZSwgLy8gd2hldGhlciBvciBub3QgdG8gc2hvdyBhbGwgZXJyb3JzIG9uIGFuIGlucHV0IGF0IG9uY2VcbiAgICBkaXNhYmxlTmF0aXZlOiB0cnVlLCAvLyB3aGV0aGVyIG9yIG5vdCB0byBzaG93IGFsbCBlcnJvcnMgb24gYW4gaW5wdXQgYXQgb25jZVxuICAgIHZhbGlkYXRpb25DbGFzczogJ2Zvcm0taW5wdXQnLCAvLyBDbGFzcyBvZiBlbGVtZW50cyB0byBiZSB2YWxpZGF0ZWRcbiAgICBpbnB1dFdyYXBwZXJDbGFzcyA6ICdmb3JtLWZpZWxkJywgLy8gQ2xhc3Mgb2YgdGhlIHBhcmVudCBjb250YWluZXIgd2Ugd2FudCB0byBhcHBlbmQgdGhlIGVycm9yIG1lc3NhZ2UgdG9cbiAgICBlcnJvclRlbXBsYXRlQ2xhc3MgOiAnZm9ybS1pbmxpbmUtbWVzc2FnZScsIC8vIENsYXNzIG9mIHRoZSBlcnJvciBtZXNzYWdlIHN0cmluZ1xuICAgIGVycm9yQ2xhc3MgOiAnZm9ybS1maWVsZC1pbnZhbGlkJywgLy8gQ2xhc3MgYWRkZWQgdG8gcGFyZW50IG9mIGVhY2ggZmFpbGluZyB2YWxpZGF0aW9uIGZpZWxkXG4gICAgdmFsaWRDbGFzcyA6ICdmb3JtLWZpZWxkLXZhbGlkJywgLy8gU2FtZSBmb3IgdmFsaWQgdmFsaWRhdGlvblxuICAgIHJlYWxUaW1lOiBmYWxzZSwgLy8gVG8gZW5hYmxlIHJlYWwtdGltZSBmb3JtIGNvbnRyb2wsIHNldCB0aGlzIG9wdGlvbiB0cnVlLlxuICAgIG9uVmFsaWQ6IGZ1bmN0aW9uKCl7fSwgLy8gVGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdWJtaXRzIHRoZSBmb3JtIGFuZCB0aGVyZSBpcyBubyBlcnJvci5cbiAgICBvbkVycm9yOiBmdW5jdGlvbigpe30sIC8vIFRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3VibWl0cyB0aGUgZm9ybSBhbmQgdGhlcmUgYXJlIHNvbWUgZXJyb3JzXG4gICAgdmFsaWRhdG9yczoge30sIC8vIEN1c3RvbSB2YWxpZGF0b3JzIHN0b3JlZCBpbiB0aGlzIHZhcmlhYmxlXG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgbGVmdCBhbmQgcmlnaHQgc3BhY2VzIG9mIGdpdmVuIHBhcmFtZXRlci5cbiAgICogVGhpcyBpcyB0aGUgZnVuY3Rpb24gZm9yIHN0cmluZyBwYXJhbWV0ZXIhXG4gICAqIElmIHBhcmFtZXRlciBpcyBhbiBhcnJheSwgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHVudHJpbW1lZCBwYXJhbWV0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEByZXR1cm4ge21peGVkfVxuICAgKi9cbiAgdmFyIHRyaW0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpIDogdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRvclxuICAgKiB7Y291bnR9IHdoaWNoIHVzZWQgYmVsb3cgaXMgdGhlIHNwZWNpZmllZCBtYXhpbXVtIG9yIG1pbmltdW0gdmFsdWVcbiAgICogZS5nIGlmIG1ldGhvZCBpcyBtaW5MZW5ndGggYW5kICBydWxlIGlzIDIgKG1pbkxlbmd0aFsyXSlcbiAgICogT3V0cHV0IGVycm9yIG1lc3NhZ2VzIHRleHQgd2lsbCBiZSA6ICdQbGVhc2Ugc2VsZWN0IG1pbmltdW0gMiBvcHRpb25zLidcbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdG1wID0gdGhpcy50bXAgVG1wIG9iamVjdCBmb3Igc3RvcmUgY3VycmVudCBmaWVsZCBhbmQgaXRzIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWw6IGZpZWxkIHZhbHVlXG4gICAqL1xuICB2YXIgVmFsaWRhdG9yID0ge1xuICAgIHJlcXVpcmVkOiBmdW5jdGlvbih0bXAsIHNlbGYpIHtcbiAgICAgIHN3aXRjaCAodG1wLmVsLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY2hlY2tib3gnIDogcmV0dXJuIHRtcC5lbC5jaGVja2VkIHx8IG1lc3NhZ2VzLnJlcXVpcmVkO1xuICAgICAgICBjYXNlICdyYWRpbycgOiByZXR1cm4gdGhpcy5yYWRpby5jYWxsKHNlbGYsIHRtcC5lbCkgfHwgbWVzc2FnZXMucmVxdWlyZWQ7XG4gICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZScgOiByZXR1cm4gdG1wLnZhbCAhPT0gbnVsbCB8fCBtZXNzYWdlcy5yZXF1aXJlZDtcbiAgICAgICAgY2FzZSAnc2VsZWN0LW9uZScgOiByZXR1cm4gdG1wLnZhbCAhPT0gbnVsbCB8fCBtZXNzYWdlcy5yZXF1aXJlZDtcbiAgICAgICAgZGVmYXVsdCA6IHJldHVybiB0bXAudmFsICE9PSAnJyB8fCBtZXNzYWdlcy5yZXF1aXJlZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIE1haWwgY2hlY2sgLSBpdCBjaGVja3MgdGhlIHZhbHVlIGlmIGl0J3MgYSB2YWxpZCBlbWFpbCBhZGRyZXNzIG9yIG5vdFxuICAgIGVtYWlsOiBmdW5jdGlvbih0bXApIHtcbiAgICAgIHJldHVybiBSTUFJTC50ZXN0KHRtcC52YWwpIHx8IG1lc3NhZ2VzLmVtYWlsO1xuICAgIH0sXG5cbiAgICAvLyBOdW1iZXIgY2hlY2tcbiAgICBudW1iZXI6IGZ1bmN0aW9uKHRtcCwgc2VsZikge1xuICAgICAgaWYgKFJOVU1CRVIudGVzdCh0bXAudmFsKSkge1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgdmFyIHZhbCA9IHBhcnNlSW50KHRtcC52YWwsIDEwKTtcbiAgICAgICAgdmFyIG1heCA9IHRtcC5lbC5tYXggPyBwYXJzZUludCh0bXAuZWwubWF4LCAxMCkgOiBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pbiA9IHRtcC5lbC5taW4gPyBwYXJzZUludCh0bXAuZWwubWluLCAxMCkgOiAtSW5maW5pdHk7XG5cbiAgICAgICAgLy8gY2hlY2sgYXR0cmlidXRlcyBhbmQgYXNzaWduIGVycm9yIG1lc3NhZ2VzLCBhdXRvLXZhbGlkYXRlIGlmIG5laXRoZXIgaXMgYXBwbGllZCB0byBlbGVtZW50XG4gICAgICAgIGlmICh0bXAuZWwubWF4ICYmIHRtcC5lbC5taW4pIHtcbiAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXMubnVtUmFuZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAodG1wLmVsLm1heCkge1xuICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlcy5udW1NYXg7XG4gICAgICAgIH0gZWxzZSBpZiAodG1wLmVsLm1pbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlcy5udW1NaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID49IG1pbiAmJiB2YWwgPD0gbWF4KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc051bWJlck1lc3NhZ2UobWVzc2FnZSwgdG1wLmVsLm1pbiwgdG1wLmVsLm1heCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcy5udW1iZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIE1pbmltdW0gbGVuZ3RoIGNoZWNrXG4gICAgbWluTGVuZ3RoOiBmdW5jdGlvbih0bXApIHtcbiAgICAgIHZhciBfbGVuZ3RoID0gdG1wLnZhbC5sZW5ndGg7XG4gICAgICByZXR1cm4gX2xlbmd0aCA9PT0gMCB8fCBfbGVuZ3RoID49IHRtcC5hcmcgfHwgbWVzc2FnZXMubWluTGVuZ3RoLnJlcGxhY2UoJ3tjb3VudH0nLCB0bXAuYXJnKTtcbiAgICB9LFxuXG4gICAgLy8gTWF4aW11bSBsZW5naHQgY2hlY2tcbiAgICBtYXhMZW5ndGg6IGZ1bmN0aW9uKHRtcCkge1xuICAgICAgcmV0dXJuIHRtcC52YWwubGVuZ3RoIDw9IHRtcC5hcmcgfHwgbWVzc2FnZXMubWF4TGVuZ3RoLnJlcGxhY2UoJ3tjb3VudH0nLCB0bXAuYXJnKTtcbiAgICB9LFxuXG4gICAgLy8gZXF1YWxUbyBjaGVja1xuICAgIGVxdWFsVG86IGZ1bmN0aW9uKHRtcCwgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuZm9ybS5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwiJyArIHRtcC5hcmcgKyAnXCJdJykudmFsdWUgPT09IHRtcC52YWwgfHwgbWVzc2FnZXMubm90RXF1YWw7XG4gICAgfSxcblxuICAgIGRpZmZlcmVudDogZnVuY3Rpb24odG1wLCBzZWxmKSB7XG4gICAgICByZXR1cm4gc2VsZi5mb3JtLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9XCInICsgdG1wLmFyZyArICdcIl0nKS52YWx1ZSAhPT0gdG1wLnZhbCB8fCBtZXNzYWdlcy5kaWZmZXJlbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWRpdCBDYXJkIENvbnRyb2xcbiAgICAgKiBAZnJvbSA6IGh0dHA6Ly9hZi1kZXNpZ24uY29tL2Jsb2cvMjAxMC8wOC8xOC92YWxpZGF0aW5nLWNyZWRpdC1jYXJkLW51bWJlcnNcbiAgICAgKi9cbiAgICBjcmVkaXRDYXJkOiBmdW5jdGlvbih0bXApIHtcbiAgICAgIGlmICh0bXAudmFsID09PSAnJykgcmV0dXJuIHRydWU7IC8vIGFsbG93IGVtcHR5IGJlY2F1c2UgZW1wdHkgY2hlY2sgZG9lcyBieSByZXF1aXJlZCBtZXRoZW9kXG4gICAgICB2YXIgcmVnO1xuICAgICAgdmFyIGNhcmROdW1iZXI7XG4gICAgICB2YXIgcG9zO1xuICAgICAgdmFyIGRpZ2l0O1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgc3ViVG90YWw7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIHZhciBzdHJsZW47XG4gICAgICByZWcgPSBuZXcgUmVnRXhwKC9bXjAtOV0rL2cpO1xuICAgICAgY2FyZE51bWJlciA9IHRtcC52YWwucmVwbGFjZShyZWcsICcnKTtcbiAgICAgIHN0cmxlbiA9IGNhcmROdW1iZXIubGVuZ3RoO1xuICAgICAgaWYgKHN0cmxlbiA8IDE2KSByZXR1cm4gbWVzc2FnZXMuY3JlZGl0Q2FyZDtcbiAgICAgIGZvciAoaSA9IDAgOyBpIDwgc3RybGVuIDsgaSsrKSB7XG4gICAgICAgIHBvcyA9IHN0cmxlbiAtIGk7XG4gICAgICAgIGRpZ2l0ID0gcGFyc2VJbnQoY2FyZE51bWJlci5zdWJzdHJpbmcocG9zIC0gMSwgcG9zKSwgMTApO1xuICAgICAgICBpZiAoaSAlIDIgPT09IDEpIHtcbiAgICAgICAgICBzdWJUb3RhbCA9IGRpZ2l0ICogMiA7XG4gICAgICAgICAgaWYgKHN1YlRvdGFsID4gOSkge1xuICAgICAgICAgICAgc3ViVG90YWwgPSAxICsgKHN1YlRvdGFsIC0gMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJUb3RhbCA9IGRpZ2l0IDtcbiAgICAgICAgfVxuICAgICAgICBzdW0gKz0gc3ViVG90YWwgO1xuICAgICAgfVxuICAgICAgaWYgKHN1bSA+IDAgJiYgc3VtICUgMTAgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzLmNyZWRpdENhcmQ7XG4gICAgfSxcblxuICAgIC8vQ2hlY2tib3ggY2hlY2tcbiAgICBtYXhDaGVja2VkOiBmdW5jdGlvbih0bXAsIHNlbGYpIHtcbiAgICAgIHZhciBjb250ID0gJChzZWxmLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1jaGVja2JveF1bbmFtZT1cIicgKyB0bXAuZWwubmFtZSArICdcIl0nKSk7XG4gICAgICB2YXIgY291bnQgPSAgY29udC5maWx0ZXIoJzpjaGVja2VkJykubGVuZ3RoO1xuICAgICAgaWYgKGNvdW50ID09PSAwKSByZXR1cm47XG4gICAgICByZXR1cm4gY291bnQgPD0gdG1wLmFyZyB8fCBtZXNzYWdlcy5tYXhDaGVja2VkLnJlcGxhY2UoJ3tjb3VudH0nLCB0bXAuYXJnKTtcbiAgICB9LFxuXG4gICAgbWluQ2hlY2tlZDogZnVuY3Rpb24odG1wLCBzZWxmKSB7XG4gICAgICB2YXIgY29udCA9ICQoc2VsZi5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9Y2hlY2tib3hdW25hbWU9XCInICsgdG1wLmVsLm5hbWUgKyAnXCJdJykpO1xuICAgICAgdmFyIGNvdW50ID0gIGNvbnQuZmlsdGVyKCc6Y2hlY2tlZCcpLmxlbmd0aDtcbiAgICAgIHJldHVybiBjb3VudCA+PSB0bXAuYXJnIHx8IG1lc3NhZ2VzLm1pbkNoZWNrZWQucmVwbGFjZSgne2NvdW50fScsIHRtcC5hcmcpO1xuICAgIH0sXG5cbiAgICAvL1NlbGVjdGJveCBjaGVja1xuICAgIG1heFNlbGVjdGVkOiBmdW5jdGlvbih0bXApIHtcbiAgICAgIGlmICh0bXAudmFsID09PSBudWxsKSByZXR1cm47XG4gICAgICByZXR1cm4gdG1wLnZhbC5sZW5ndGggPD0gdG1wLmFyZyB8fCBtZXNzYWdlcy5tYXhTZWxlY3RlZC5yZXBsYWNlKCd7Y291bnR9JywgdG1wLmFyZyk7XG4gICAgfSxcblxuICAgIG1pblNlbGVjdGVkOiBmdW5jdGlvbih0bXApIHtcbiAgICAgIHJldHVybiAodG1wLnZhbCAhPT0gbnVsbCAmJiB0bXAudmFsLmxlbmd0aCA+PSB0bXAuYXJnKSB8fCBtZXNzYWdlcy5taW5TZWxlY3RlZC5yZXBsYWNlKCd7Y291bnR9JywgdG1wLmFyZyk7XG4gICAgfSxcblxuICAgIC8vIFJhZGlvXG4gICAgcmFkaW86IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgY291bnQgPSB0aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1yYWRpb11bbmFtZT1cIicgKyBlbC5uYW1lICsgJ1wiXTpjaGVja2VkJykubGVuZ3RoO1xuICAgICAgcmV0dXJuIGNvdW50ID09PSAxO1xuICAgIH0sXG5cbiAgICAvLyBDdXN0b20gcmVnIGNoZWNrXG4gICAgcmVnRXhwOiBmdW5jdGlvbih0bXAsIHNlbGYpIHtcbiAgICAgIHZhciBfYXJnID0gc2VsZi5vcHRpb25zLnZhbGlkYXRvcnMucmVnRXhwW3RtcC5hcmddO1xuICAgICAgdmFyIF9yZWcgPSBuZXcgUmVnRXhwKF9hcmcucGF0dGVybik7XG4gICAgICByZXR1cm4gX3JlZy50ZXN0KHRtcC52YWwpIHx8IF9hcmcuZXJyb3JNZXNzYWdlO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdGVcbiAgICByZW1vdGU6IGZ1bmN0aW9uKHRtcCkge1xuICAgICAgdG1wLnJlbW90ZSA9IHRtcC5hcmc7XG4gICAgICByZXR1cm47XG4gICAgfSxcblxuICAgIC8vIENhbGxiYWNrXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uKHRtcCwgc2VsZikge1xuICAgICAgdmFyIF9jYiA9IHNlbGYub3B0aW9ucy52YWxpZGF0b3JzLmNhbGxiYWNrW3RtcC5hcmddO1xuICAgICAgcmV0dXJuIF9jYi5jYWxsYmFjayh0bXAuZWwsIHRtcC52YWwpIHx8IF9jYi5lcnJvck1lc3NhZ2U7XG4gICAgfSxcbiAgfTtcblxuICAvKipcbiAgICogUGx1Z2luIENsYXNzXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge29iamVjdH0gZm9ybSA6IDxmb3JtPiBlbGVtZW50IHdoaWNoIGJlaW5nIGNvbnRyb2xsZWRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgOiBVc2VyLXNwZWNpZmllZCBzZXR0aW5nc1xuICAgKiBAcmV0dXJuIHttZXRob2R9IGV2ZW50c1xuICAgKi9cbiAgdmFyIFZhbGlkZXR0YSA9IGZ1bmN0aW9uKGZvcm0sIG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiAgUHVibGljICBQcm9wZXJ0aWVzXG4gICAgICogIEBwcm9wZXJ0eSB7bWl4ZWR9IGhhbmRsZXIgSXQgaXMgdXNlZCB0byBzdG9wIG9yIHJlc3VtZSBzdWJtaXQgZXZlbnQgaGFuZGxlclxuICAgICAqICBAcHJvcGVydHkge29iamVjdH0gb3B0aW9ucyBQcm9wZXJ0eSBpcyBzdG9yZWQgaW4gcGx1Z2luIG9wdGlvbnNcbiAgICAgKiAgQHByb3BlcnR5IHtvYmplY3R9IHhociBTdG9yZXMgeGhyIHJlcXVlc3RzXG4gICAgICogIEBwcm9wZXJ0eSB7b2JqZWN0fSBmb3JtIFByb3BlcnR5IGlzIHN0b3JlZCBpbiA8Zm9ybT4gZWxlbWVudFxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlciA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLnhociA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZvcm0oKTtcbiAgICB0aGlzLmV2ZW50cygpO1xuICB9O1xuXG4gIFZhbGlkZXR0YS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IFZhbGlkZXR0YSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBuYXRpdmUgYnJvd3NlciB2YWxpZGF0aW9uIGZyb20gdGFyZ2V0IGZvcm0gaWYgYXBwbGljYWJsZVxuICAgICAqL1xuICAgIGluaXRpYWxpemVGb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZU5hdGl2ZSkge1xuICAgICAgICB0aGlzLmZvcm0uc2V0QXR0cmlidXRlKCdub3ZhbGlkYXRlJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIG1ldGhvZCBvZiBoYW5kbGluZyBldmVudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge21peGVkfVxuICAgICAqL1xuICAgIGV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIHN0b3JlZCB0aGlzXG4gICAgICAvLyBIYW5kbGUgc3VibWl0IGV2ZW50XG4gICAgICAkKHRoaXMuZm9ybSkuc3VibWl0KGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIGZpZWxkcyB0byBiZSBjb250cm9sbGVkIHRyYW5zZmVycmVkIHRvIGdsb2JhbCB2YXJpYWJsZVxuICAgICAgICBGSUVMRFMgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoc2VsZi5vcHRpb25zLnZhbGlkYXRpb25DbGFzcyk7XG4gICAgICAgIHJldHVybiBzZWxmLmluaXQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICAvLyByZWFsLXRpbWUgb3B0aW9uIGNvbnRyb2xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVhbFRpbWUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gaGFuZGxlIGNoYW5nZSBldmVudCBmb3IgZm9ybSBlbGVtZW50cyAod2l0aG91dCBjaGVja2JveClcbiAgICAgICAgJCh0aGlzLmZvcm0pLmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLnZhbGlkYXRpb25DbGFzcykubm90KCdbdHlwZT1jaGVja2JveF0nKS5vbignY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAvLyBmaWVsZCB0byBiZSBjb250cm9sbGVkIHRyYW5zZmVycmVkIHRvIGdsb2JhbCB2YXJpYWJsZVxuICAgICAgICAgIEZJRUxEUyA9ICQoc2VsZik7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuaW5pdChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBoYW5kbGUgY2xpY2sgZXZlbnQgZm9yIGNoZWNrYm94ZXNcbiAgICAgICAgJCh0aGlzLmZvcm0pLmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLnZhbGlkYXRpb25DbGFzcyArICdbdHlwZT1jaGVja2JveF0nKS5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIC8vIGZpZWxkcyB0byBiZSBjb250cm9sbGVkIHRyYW5zZmVycmVkIHRvIGdsb2JhbCB2YXJpYWJsZVxuICAgICAgICAgIEZJRUxEUyA9IHNlbGYuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIHNlbGYub3B0aW9ucy52YWxpZGF0aW9uQ2xhc3MgKyAnW3R5cGU9Y2hlY2tib3hdW25hbWU9XCInICsgc2VsZi5uYW1lICsgJ1wiXScpO1xuICAgICAgICAgIHJldHVybiBzZWxmLmluaXQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSA8Zm9ybT4gcmVzZXQgYnV0dG9uIHRvIGNsZWFyIGVycm9yIG1lc3NhZ2VzXG4gICAgICAkKHRoaXMuZm9ybSkub24oJ3Jlc2V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICQoc2VsZi5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgc2VsZi5vcHRpb25zLmVycm9yQ2xhc3MgKyAnICwgLicgKyBzZWxmLm9wdGlvbnMudmFsaWRDbGFzcykpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKHNlbGYub3B0aW9ucy5lcnJvckNsYXNzICsgJyAnICsgc2VsZi5vcHRpb25zLnZhbGlkQ2xhc3MpO1xuICAgICAgICByZXR1cm4gc2VsZi5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluIHRoaXMgbWV0aG9kLCBmaWVsZHMgYXJlIHZhbGlkYXRlZFxuICAgICAqXG4gICAgICogQHBhcmFtcyB7b2JqZWN0fSBlIDogZXZlbnQgb2JqZWN0XG4gICAgICogQHJldHVybiB7bWl4ZWR9XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIFJlc2V0IGVycm9yIG1lc3NhZ2VzIGZyb20gYWxsIGVsZW1lbnRzXG4gICAgICB0aGlzLnJlc2V0KEZJRUxEUyk7XG4gICAgICAvLyBTdGFydCBjb250cm9sIGVhY2ggZWxlbWVudHNcbiAgICAgIHRoaXMuY2hlY2tGaWVsZHMoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LnR5cGUgIT09ICdzdWJtaXQnKSByZXR1cm47IC8vIGlmIGV2ZW50IHR5cGUgaXMgbm90IHN1Ym1pdCwgYnJlYWtcbiAgICAgIC8vIFRoaXMgaXMgZm9yIHdoZW4gcnVubmluZyByZW1vdGUgcmVxdWVzdCwgcmV0dXJuIGZhbHNlIGFuZCB3YWl0IHJlcXVlc3QgcmVzcG9uc2VcbiAgICAgIGVsc2UgaWYgKHRoaXMuaGFuZGxlciA9PT0gJ3BlbmRpbmcnKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBpZiBldmVudCB0eXBlIGlzIHN1Ym1pdCBhbmQgaGFuZGxlciBpcyB0cnVlLCBicmVhayBzdWJtaXQgYW5kIGNhbGwgb25FcnJvcigpIGZ1bmN0aW9uXG4gICAgICBlbHNlIGlmICh0aGlzLmhhbmRsZXIgPT09IHRydWUpIHsgdGhpcy5vcHRpb25zLm9uRXJyb3IuY2FsbCh0aGlzLCBldmVudCk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgZWxzZSByZXR1cm4gdGhpcy5vcHRpb25zLm9uVmFsaWQuY2FsbCh0aGlzLCBldmVudCk7IC8vIGlmIGZvcm0gaXMgdmFsaWQgY2FsbCBvblZhbGlkKCkgZnVuY3Rpb25cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIEZpZWxkc1xuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBlIGV2ZW50IG9iamVjdFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgY2hlY2tGaWVsZHM6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIHN0b3JlZCB0aGlzXG4gICAgICB2YXIgaW52YWxpZEZpZWxkcyA9IFtdO1xuXG4gICAgICAvLyBNYWtlIGludmFsaWRGaWVsZHMgYWNjZXNzaWJsZVxuICAgICAgdGhpcy5nZXRJbnZhbGlkRmllbGRzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGludmFsaWRGaWVsZHM7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgX2xlbmd0aEZpZWxkcyA9IEZJRUxEUy5sZW5ndGg7IGkgPCBfbGVuZ3RoRmllbGRzOyBpKyspIHtcbiAgICAgICAgLy8gaWYgZmllbGQgaXMgZGlzYWJsZWQsIGRvIG5vdCBjaGVja1xuICAgICAgICBpZiAoRklFTERTW2ldLmRpc2FibGVkKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGVsID0gRklFTERTW2ldOyAvL2N1cnJlbnQgZmllbGRcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZXMgPSAnJzsgLy9jdXJyZW50IGZpZWxkJ3MgZXJyb3JzXG4gICAgICAgIHZhciB2YWwgPSB0cmltKCQoZWwpLnZhbCgpKTsgLy9jdXJyZW50IGZpZWxkJ3MgdmFsdWVcbiAgICAgICAgdmFyIG1ldGhvZHMgPSBzZWxmLmdldElucHV0VmFsaWRhdG9ycyhlbCk7IC8vY3VycmVudCBmaWVsZCdzIGNvbnRyb2wgbWV0aG9kc1xuICAgICAgICB2YXIgc3RhdGU7IC8vIFZhbGlkYXRpb24gc3RhdGVcbiAgICAgICAgLy8gQ3JlYXRlIHRtcFxuICAgICAgICB0aGlzLnRtcCA9IHt9O1xuICAgICAgICAvLyBzdG9yZSBlbCBhbmQgdmFsIHZhcmlhYmxlcyBpbiB0bXBcbiAgICAgICAgdGhpcy50bXAgPSB7IGVsIDogZWwsIHZhbCA6IHZhbCwgcGFyZW50IDogdGhpcy5wYXJlbnRzKGVsKSB9O1xuICAgICAgICAvLyBTdGFydCB0byBjaGVjayBmaWVsZHNcbiAgICAgICAgLy8gVmFsaWRhdG9yIDogRmllbGRzIENvbnRyb2wgT2JqZWN0XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBfbGVuZ3RoTWV0aG9kcyA9IG1ldGhvZHMubGVuZ3RoOyBqIDwgX2xlbmd0aE1ldGhvZHM7IGorKykge1xuICAgICAgICAgIC8vIENoZWNrIFJ1bGVcbiAgICAgICAgICB2YXIgcnVsZSA9IG1ldGhvZHNbal0ubWF0Y2goUlJVTEUpO1xuICAgICAgICAgIHZhciBtZXRob2Q7XG4gICAgICAgICAgLy8gRG9lcyBpdCBoYXZlIHJ1bGU/XG4gICAgICAgICAgaWYgKHJ1bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERvZXMgaXQgaGF2ZSBhbnkgYXJndW1lbnQgP1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlWzJdICE9PSAndW5kZWZpbmVkJykgdGhpcy50bXAuYXJnID0gcnVsZVsyXTtcbiAgICAgICAgICAgIC8vIFNldCBtZXRob2QgbmFtZVxuICAgICAgICAgICAgbWV0aG9kID0gcnVsZVsxXTtcbiAgICAgICAgICB9IGVsc2UgeyBtZXRob2QgPSBtZXRob2RzW2pdOyB9XG4gICAgICAgICAgLy8gcHJldmVudCBlbXB0eSB2YWxpZGF0aW9uIGlmIG1ldGhvZCBpcyBub3QgcmVxdWlyZWRcbiAgICAgICAgICBpZiAodmFsID09PSAnJyAmJiBtZXRob2QgIT09ICdyZXF1aXJlZCcgJiYgbWV0aG9kICE9PSAnZXF1YWxUbycpIGNvbnRpbnVlO1xuICAgICAgICAgIC8vIElzIHRoZXJlIGEgbWV0aG9kIGluIFZhbGlkYXRvciA/XG4gICAgICAgICAgaWYgKFZhbGlkYXRvci5oYXNPd25Qcm9wZXJ0eShtZXRob2QpKSB7XG4gICAgICAgICAgICAvLyBWYWxpZGF0b3IgcmV0dXJucyBlcnJvciBtZXNzYWdlIGlmIG1ldGhvZCBpbnZhbGlkXG4gICAgICAgICAgICBzdGF0ZSA9IFZhbGlkYXRvclttZXRob2RdKHNlbGYudG1wLCBzZWxmKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgIT09ICd1bmRlZmluZWQnICYmIHN0YXRlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBfZGF0YU1zZyA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS12ZC1tZXNzYWdlLScgKyBtZXRob2QpO1xuICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIGN1c3RvbSBtZXNzYWdlP1xuICAgICAgICAgICAgICBpZiAoX2RhdGFNc2cgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IF9kYXRhTXNnO1xuICAgICAgICAgICAgICAgIC8vIGFkZCBvdXIgbWluIGFuZCBtYXggdmFsdWVzIGlmIGl0J3MgYSBudW1iZXIgaW5wdXRcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnByb2Nlc3NOdW1iZXJNZXNzYWdlKHN0YXRlLCB0aGlzLnRtcC5lbC5taW4sIHRoaXMudG1wLmVsLm1heCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdyBhbGwgc3RhdGVzIHRoYXQgcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzICs9IHN0YXRlICsgJzxicj4nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGp1c3Qgc2hvdyB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzID0gc3RhdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayB0aGUgZXJyb3JzXG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2VzICE9PSAnJykge1xuICAgICAgICAgIGludmFsaWRGaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBmaWVsZDogZWwsXG4gICAgICAgICAgICBlcnJvcnM6IGVycm9yTWVzc2FnZXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gaWYgcGFyZW50IGVsZW1lbnQgaGFzIHZhbGlkIGNsYXNzLCByZW1vdmUgYW5kIGFkZCBlcnJvciBjbGFzc1xuICAgICAgICAgIHRoaXMuYWRkRXJyb3JDbGFzcyh0aGlzLnRtcC5wYXJlbnQpO1xuICAgICAgICAgIC8vIHNob3cgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgIHRoaXMubm90aWZ5LnNob3cuY2FsbCh0aGlzICwgZWwsIGVycm9yTWVzc2FnZXMpO1xuICAgICAgICAvLyBDaGVjayByZW1vdGUgdmFsaWRhdGlvblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnRtcC5yZW1vdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1JlbW90ZShlbCwgZXZlbnQpO1xuICAgICAgICB9IGVsc2UgeyAvLyBOaWNlLCB0aGVyZSBhcmUgbm8gZXJyb3JcbiAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlICE9PSAndW5kZWZpbmVkJykgdGhpcy5hZGRWYWxpZENsYXNzKHRoaXMudG1wLnBhcmVudCk7XG4gICAgICAgICAgZWxzZSAkKHRoaXMudG1wLnBhcmVudCkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MgKyAnICcgKyB0aGlzLm9wdGlvbnMudmFsaWRDbGFzcyk7XG4gICAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7IC8vIFJlc2V0IHN0YXRlIHZhcmlhYmxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGF0IHZhbGlkYXRvcnMgdG8gcnVuIHBlciBpbnB1dFxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBlbCBjdXJyZW50IGZpZWxkXG4gICAgICogQHJldHVybiB7YXJyYXl9IGEgbGlzdCBvZiBhbGwgdmFsaWRhdG9ycyB0byBydW4gYWdhaW5zdCB0aGUgaW5wdXQncyB2YWx1ZVxuICAgICAqL1xuICAgIGdldElucHV0VmFsaWRhdG9yczogZnVuY3Rpb24oZWwpIHtcbiAgICAgIC8vIHZhbGlkYXRvcnMgZGVmaW5lZCBvdXRzaWRlIG9mIG5hdGl2ZSBodG1sNSBhdHRyc1xuICAgICAgdmFyIHZhbGlkYXRvcnMgPSBlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtdmFsaWRhdGVzJykgPyBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsaWRhdGVzJykuc3BsaXQoJywnKSA6IFtdO1xuXG4gICAgICBpZiAoZWwucmVxdWlyZWQgJiYgdmFsaWRhdG9ycy5pbmRleE9mKCdyZXF1aXJlZCcpID09PSAtMSkgdmFsaWRhdG9ycy5wdXNoKCdyZXF1aXJlZCcpO1xuICAgICAgaWYgKGVsLnR5cGUgPT09ICdudW1iZXInICYmIHZhbGlkYXRvcnMuaW5kZXhPZignbnVtYmVyJykgPT09IC0xKSB2YWxpZGF0b3JzLnB1c2goJ251bWJlcicpO1xuICAgICAgaWYgKGVsLnR5cGUgPT09ICdlbWFpbCcgJiYgdmFsaWRhdG9ycy5pbmRleE9mKCdlbWFpbCcpID09PSAtMSkgdmFsaWRhdG9ycy5wdXNoKCdlbWFpbCcpO1xuXG4gICAgICByZXR1cm4gdmFsaWRhdG9ycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHJlbW90ZSB2YWxpZGF0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBlbCBjdXJyZW50IGZpZWxkXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBlIGV2ZW50IG9iamVjdFxuICAgICAqIEB0aHJvd3Mge2Vycm9yfSBJZiBwcmV2aW91cyByZW1vdGUgcmVxdWVzdCBmb3Igc2FtZSB2YWx1ZSBoYXMgcmVqZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIGNoZWNrUmVtb3RlOiBmdW5jdGlvbihlbCwgZXZlbnQpIHtcbiAgICAgIHZhciBhamF4T3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgIHZhciBmaWVsZE5hbWUgPSBlbC5uYW1lIHx8IGVsLmlkO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMucmVtb3RlQ2FjaGUgPT09ICd1bmRlZmluZWQnKSB0aGlzLnJlbW90ZUNhY2hlID0ge307XG5cbiAgICAgIGRhdGFbZmllbGROYW1lXSA9IHRoaXMudG1wLnZhbDsgLy8gU2V0IGRhdGFcbiAgICAgIC8vIGV4ZW5kcyBhamF4IG9wdGlvbnNcbiAgICAgIGFqYXhPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgIH0sIHRoaXMub3B0aW9ucy52YWxpZGF0b3JzLnJlbW90ZVt0aGlzLnRtcC5yZW1vdGVdIHx8IHt9KTtcblxuICAgICAgLy8gdXNlICQucGFyYW0oKSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGUgc3BlY2lmaWMgY2FjaGUga2V5XG4gICAgICB2YXIgY2FjaGVLZXkgPSAkLnBhcmFtKGFqYXhPcHRpb25zKTtcblxuICAgICAgLy8gQ2hlY2sgY2FjaGVcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMucmVtb3RlQ2FjaGVbY2FjaGVLZXldO1xuXG4gICAgICBpZiAodHlwZW9mIGNhY2hlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzd2l0Y2goY2FjaGUuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdwZW5kaW5nJyA6IC8vIHBlbmRpbmcgbWVhbnMgcmVtb3RlIHJlcXVlc3Qgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gJ3BlbmRpbmcnOyAvLyB1cGRhdGUgaGFuZGxlciBhbmQgY2FjaGUgZXZlbnQgdHlwZVxuICAgICAgICAgICAgY2FjaGUuZXZlbnQgPSBldmVudC50eXBlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmVqZWN0ZWQnIDogLy8gcmVqZWN0ZWQgbWVhbnMgcmVtb3RlIHJlcXVlc3QgY291bGQgbm90IGJlIHBlcmZvcm1lZFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gd2UgaGF2ZSB0byBicmVhayBzdWJtaXQgYmVjYXVzZSBvZiB0aHJvdyBlcnJvclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNhY2hlLnJlc3VsdC5tZXNzYWdlKTtcbiAgICAgICAgICBjYXNlICdyZXNvbHZlZCcgOiAvLyByZXNvbHZlZCBtZWFucyByZW1vdGUgcmVxdWVzdCBoYXMgZG9uZVxuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gY2FjaGUsIGlmIHJlc3VsdCBpcyBpbnZhbGlkLCBzaG93IGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIGlmIChjYWNoZS5yZXN1bHQudmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkRXJyb3JDbGFzcyh0aGlzLnRtcC5wYXJlbnQpO1xuICAgICAgICAgICAgICB0aGlzLm5vdGlmeS5zaG93LmNhbGwodGhpcywgZWwsIGNhY2hlLnJlc3VsdC5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkVmFsaWRDbGFzcyh0aGlzLnRtcC5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBYm9ydCBpZiBwcmV2aW91cyBhamF4IHJlcXVlc3Qgc3RpbGwgcnVubmluZ1xuICAgICAgICB2YXIgX3hociA9IHRoaXMueGhyW2ZpZWxkTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgX3hociAhPT0gJ3VuZGVmaW5lZCcgJiYgX3hoci5zdGF0ZSgpID09PSAncGVuZGluZycpIF94aHIuYWJvcnQoKTtcbiAgICAgICAgLy8gU3RhcnQgY2FjaGluZ1xuICAgICAgICBjYWNoZSA9IHRoaXMucmVtb3RlQ2FjaGVbY2FjaGVLZXldID0geyBzdGF0ZSA6ICdwZW5kaW5nJywgZXZlbnQgOiBldmVudC50eXBlIH07XG4gICAgICAgIC8vIG1ha2UgYSByZW1vdGUgcmVxdWVzdFxuICAgICAgICB0aGlzLnJlbW90ZVJlcXVlc3QoYWpheE9wdGlvbnMsIGNhY2hlLCBlbCwgZmllbGROYW1lKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgYWpheCByZXF1ZXN0IGZvciByZW1vdGUgdmFsaWRhdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gYWpheE9wdGlvbnMgQWpheCBvcHRpb25zXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBjYWNoZSBDYWNoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGVsIHByb2Nlc3NpbmcgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZmllbGROYW1lIEZpZWxkIG5hbWUgZm9yIG1ha2Ugc3BlY2lmaWMgY2FjaGluZ1xuICAgICAqIEBwYXJhbSAge29iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgcmVtb3RlUmVxdWVzdDogZnVuY3Rpb24oYWpheE9wdGlvbnMsIGNhY2hlLCBlbCwgZmllbGROYW1lKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICQodGhpcy50bXAucGFyZW50KS5hZGRDbGFzcygndmFsaWRldHRhLXBlbmRpbmcnKTtcblxuICAgICAgLy8gY2FjaGUgeGhyXG4gICAgICB0aGlzLnhocltmaWVsZE5hbWVdID0gJC5hamF4KGFqYXhPcHRpb25zKVxuICAgICAgICAuZG9uZShmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KTtcbiAgICAgICAgICBjYWNoZS5zdGF0ZSA9ICdyZXNvbHZlZCc7XG4gICAgICAgICAgY2FjaGUucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgIGlmIChjYWNoZS5ldmVudCA9PT0gJ3N1Ym1pdCcpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlciA9IGZhbHNlO1xuICAgICAgICAgICAgJChzZWxmLmZvcm0pLnRyaWdnZXIoJ3N1Ym1pdCcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZi5hZGRFcnJvckNsYXNzKHNlbGYudG1wLnBhcmVudCk7XG4gICAgICAgICAgICBzZWxmLm5vdGlmeS5zaG93LmNhbGwoc2VsZiwgZWwsIHJlc3VsdC5tZXNzYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5hZGRWYWxpZENsYXNzKHNlbGYudG1wLnBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuZmFpbChmdW5jdGlvbihqcVhIUiwgdGV4dFN0YXR1cykge1xuICAgICAgICAgIGlmICh0ZXh0U3RhdHVzICE9PSAnYWJvcnQnKSB7IC8vIERvbnQgdGhyb3cgZXJyb3IgaWYgcmVxdWVzdCBpcyBhYm9ydGVkXG4gICAgICAgICAgICB2YXIgX21zZyA9ICdBamF4IHJlcXVlc3QgZmFpbGVkIGZvciBmaWVsZCAoJyArIGZpZWxkTmFtZSArICcpIDogJyArIGpxWEhSLnN0YXR1cyArICcgJyArIGpxWEhSLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICBjYWNoZS5zdGF0ZSA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICBjYWNoZS5yZXN1bHQgPSB7IHZhbGlkOiBmYWxzZSwgbWVzc2FnZSA6IF9tc2cgfTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfbXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5hbHdheXMoZnVuY3Rpb24oKSB7ICQoc2VsZi50bXAucGFyZW50KS5yZW1vdmVDbGFzcygndmFsaWRldHRhLXBlbmRpbmcnKTsgfSk7XG5cbiAgICAgIHRoaXMuaGFuZGxlciA9ICdwZW5kaW5nJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvd2luZyBvciBoaWRpbmcgZXJyb3IgbWVzc2FnZXNcbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBub3RpZnk6IHtcbiAgICAgIC8qKlxuICAgICAgICogRXJyb3IgbWVzc2FnZSBzaG93c1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbXMge29iamVjdH0gZWwgOiBlbGVtZW50IHdoaWNoIGhhcyBhbiBlcnJvciAoaXQgY2FuIGJlIG5hdGl2ZSBlbGVtZW50IG9yIGpRdWVyeSBvYmplY3QpXG4gICAgICAgKiBAcGFyYW1zIHtzdHJpbmd9IGVycm9yIDogZXJyb3IgbWVzc2FnZXNcbiAgICAgICAqL1xuICAgICAgc2hvdzogZnVuY3Rpb24oZWwsIGVycm9yKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgZGlzcGxheSBlcnJvcnMgP1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgLy8gYmVjYXVzZSBvZiBmb3JtIG5vdCB2YWxpZCwgc2V0IGhhbmRsZXIgdHJ1ZSBmb3IgYnJlYWsgc3VibWl0XG4gICAgICAgICAgdGhpcy5oYW5kbGVyID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsUGFyZW50ID0gdGhpcy5wYXJlbnRzKGVsKTtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBlbGVtZW50IHVuZGVmaW5lZCwgdGhhdCBtZWFucyBlbCBpcyBhbiBvYmplY3QuIFNvIHdlIG5lZWQgdG8gdHJhbnNmb3JtIHRvIHRoZSBlbGVtZW50XG4gICAgICAgIGlmICh0eXBlb2YgZWxQYXJlbnQgPT09ICd1bmRlZmluZWQnKSBlbFBhcmVudCA9IGVsWzBdLnBhcmVudE5vZGU7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGVycm9yIG1lc3NhZ2Ugd2hpY2ggcHJldmlvdXNseSBzaG93biBmb3IgZWwsIHJldHVyblxuICAgICAgICBpZiAoZWxQYXJlbnQucXVlcnlTZWxlY3RvckFsbCgnLicgKyB0aGlzLm9wdGlvbnMuZXJyb3JUZW1wbGF0ZUNsYXNzKS5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBlcnJvciBtZXNzYWdlIG9iamVjdFxuICAgICAgICB2YXIgZXJyb3JPYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGVycm9yT2JqZWN0LmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5lcnJvclRlbXBsYXRlQ2xhc3M7XG4gICAgICAgIGVsUGFyZW50LmFwcGVuZENoaWxkKGVycm9yT2JqZWN0KTtcbiAgICAgICAgZXJyb3JPYmplY3QuaW5uZXJIVE1MID0gZXJyb3IgO1xuXG4gICAgICAgIC8vIHdlIGhhdmUgYW4gZXJyb3Igc28gd2UgbmVlZCB0byBicmVhayBzdWJtaXRcbiAgICAgICAgLy8gc2V0IHRvIGhhbmRsZXIgdHJ1ZVxuICAgICAgICB0aGlzLmhhbmRsZXIgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogRXJyb3IgbWVzc2FnZSBoaWRlc1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbXMgZWwgOiB0aGUgZXJyb3IgbWVzc2FnZSB3aGljaCB3aWxsIGJlIGRpc2FwcGVhclxuICAgICAgICovXG4gICAgICBoaWRlOiBmdW5jdGlvbihlbCkge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH0sXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZXJyb3IgbWVzc2FnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvciB7dm9pZH0gZWwgOiBmb3JtIGVsZW1lbnRzIHdoaWNoIGhhdmUgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIF9lcnJvck1lc3NhZ2VzID0ge307XG4gICAgICAvLyBpZiBlbCBpcyB1bmRlZmluZWQgKFRoaXMgaXMgdGhlIHByb2Nlc3Mgb2YgcmVzZXR0aW5nIGFsbCA8Zm9ybT4pXG4gICAgICAvLyBvciBlbCBpcyBhbiBvYmplY3QgdGhhdCBoYXMgZWxlbWVudCBtb3JlIHRoYW4gb25lXG4gICAgICAvLyBhbmQgdGhlc2UgZWxlbWVudHMgYXJlIG5vdCBjaGVja2JveFxuICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3VuZGVmaW5lZCcgfHwgKGVsLmxlbmd0aCA+IDEgJiYgZWxbMF0udHlwZSAhPT0gJ2NoZWNrYm94JykpIHtcbiAgICAgICAgX2Vycm9yTWVzc2FnZXMgPSB0aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnLicgKyB0aGlzLm9wdGlvbnMuZXJyb3JUZW1wbGF0ZUNsYXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9lcnJvck1lc3NhZ2VzID0gdGhpcy5wYXJlbnRzKGVsWzBdKS5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIHRoaXMub3B0aW9ucy5lcnJvclRlbXBsYXRlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIF9sZW5ndGhFcnJvck1lc3NhZ2VzID0gX2Vycm9yTWVzc2FnZXMubGVuZ3RoOyBpIDwgX2xlbmd0aEVycm9yTWVzc2FnZXM7IGkrKykge1xuICAgICAgICB0aGlzLm5vdGlmeS5oaWRlLmNhbGwodGhpcywgX2Vycm9yTWVzc2FnZXNbaV0pO1xuICAgICAgfVxuICAgICAgLy8gc2V0IHRvIGhhbmRsZXIgZmFsc2VcbiAgICAgIC8vIG90aGVyd2lzZSBhdCB0aGUgbmV4dCB2YWxpZGF0aW9uIGF0dGVtcHQsIHN1Ym1pdCB3aWxsIG5vdCBjb250aW51ZSBldmVuIHRoZSB2YWxpZGF0aW9uIGlzIHN1Y2Nlc3NmdWxcbiAgICAgIHRoaXMuaGFuZGxlciA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGVycm9yIGNsYXNzIGFuZCByZW1vdmVzIHZhbGlkIGNsYXNzIGlmIGV4aXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZWwgZWxlbWVudFxuICAgICAqL1xuICAgIGFkZEVycm9yQ2xhc3M6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAkKGVsKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudmFsaWRDbGFzcykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhbGlkIGNsYXNzIGFuZCByZW1vdmVzIGVycm9yIGNsYXNzIGlmIGV4aXN0XG4gICAgICogaWYgZXJyb3IgY2xhc3Mgbm90IGV4aXN0LCBkbyBub3QgYWRkIHZhbGlkIGNsYXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZWwgZWxlbWVudFxuICAgICAqL1xuICAgIGFkZFZhbGlkQ2xhc3M6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAkKGVsKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnZhbGlkQ2xhc3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBwYXJlbnQgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBlbCBlbGVtZW50XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBlbCBwYXJlbnQgZWxlbWVudFxuICAgICAqL1xuICAgIHBhcmVudHM6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gJChlbCkucGFyZW50cygnLicgKyB0aGlzLm9wdGlvbnMuaW5wdXRXcmFwcGVyQ2xhc3MpWzBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBtaW4gJiBtYSBwbGFjZWhvbGRlcnMgaW4gbnVtYmVyIGlucHV0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSByYXcgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtaW4gLSB0aGUgaW5wdXQncyBtaW4gcmFuZ2UgKGNhbiBiZSBudWxsKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXggLSB0aGUgaW5wdXQncyBtYXggcmFuZ2UgKGNhbiBiZSBudWxsKVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gbWVzc2FnZSAtIHByb2Nlc3NlZCBtZXNzYWdlXG4gICAgICovXG4gICAgcHJvY2Vzc051bWJlck1lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UsIG1pbiwgbWF4KSB7XG4gICAgICBpZiAobWluKSBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKCd7bWlufScsIG1pbik7XG4gICAgICBpZiAobWF4KSBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKCd7bWF4fScsIG1heCk7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICB9O1xuXG4gIC8qKlxuICAgKiBQbHVnaW4gVmFsaWRldHRhXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIDogVXNlci1zcGVjaWZpZWQgc2V0dGluZ3NcbiAgICogQHJldHVybiB7b2JqZWN0fSB0aGlzXG4gICAqL1xuICAkLmZuLnZhbGlkZXR0YSA9IGZ1bmN0aW9uKG9wdGlvbnMsIF9tZXNzYWdlcykge1xuICAgIGlmICh0eXBlb2YgX21lc3NhZ2VzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbWVzc2FnZXMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgbWVzc2FnZXMsIF9tZXNzYWdlcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBuZXcgVmFsaWRldHRhKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9O1xufSkoalF1ZXJ5KTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xudmFyIGcgPVxuICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpIHx8XG4gIHt9XG5cbnZhciBzdXBwb3J0ID0ge1xuICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIGcsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICBibG9iOlxuICAgICdGaWxlUmVhZGVyJyBpbiBnICYmXG4gICAgJ0Jsb2InIGluIGcgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGcsXG4gIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdcbn1cblxuZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG59XG5cbmlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICBdXG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gIH1cbiAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH4hXS9pLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlcnMgY29uc3RydWN0b3I6IGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQnICsgaGVhZGVyLmxlbmd0aClcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbkhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2gobmFtZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaXRlbXMucHVzaCh2YWx1ZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5pZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xufVxuXG5mdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gIGlmIChib2R5Ll9ub0JvZHkpIHJldHVyblxuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgfVxuICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHZhciBtYXRjaCA9IC9jaGFyc2V0PShbQS1aYS16MC05Xy1dKykvLmV4ZWMoYmxvYi50eXBlKVxuICB2YXIgZW5jb2RpbmcgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ3V0Zi04J1xuICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZylcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgaWYgKGJ1Zi5zbGljZSkge1xuICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gQm9keSgpIHtcbiAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgLypcbiAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgRVM1IGJyb3dzZXJzIHdpdGhvdXQgZmV0Y2ggb3IgUHJveHkgc3VwcG9ydCBwb2xseWZpbGxzIG11c3QgYmUgdXNlZDtcbiAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgUmVzcG9uc2UuYm9keVVzZWQgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZSwgd2hpbGUgbWFpbnRhaW5pbmcgdGhlXG4gICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkXG4gICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aGlzLl9ub0JvZHkgPSB0cnVlO1xuICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBpc0NvbnN1bWVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChpc0NvbnN1bWVkKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQgKyB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBhcyBBcnJheUJ1ZmZlcicpXG4gICAgfVxuICB9XG5cbiAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3RlZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxudmFyIG1ldGhvZHMgPSBbJ0NPTk5FQ1QnLCAnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUEFUQ0gnLCAnUE9TVCcsICdQVVQnLCAnVFJBQ0UnXVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgfVxuICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsXG4gICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gIH1cblxuICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbidcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB9XG4gIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbCB8fCAoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnQWJvcnRDb250cm9sbGVyJyBpbiBnKSB7XG4gICAgICB2YXIgY3RybCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHJldHVybiBjdHJsLnNpZ25hbDtcbiAgICB9XG4gIH0oKSk7XG4gIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgfVxuICB0aGlzLl9pbml0Qm9keShib2R5KVxuXG4gIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgIGlmIChvcHRpb25zLmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IG9wdGlvbnMuY2FjaGUgPT09ICduby1jYWNoZScpIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovXG4gICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cyB0aGVuIHNldCB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB2YXIgcmVRdWVyeVN0cmluZyA9IC9cXD8vXG4gICAgICAgIHRoaXMudXJsICs9IChyZVF1ZXJ5U3RyaW5nLnRlc3QodGhpcy51cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBib2R5XG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBmb3JtXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gIC8vIEF2b2lkaW5nIHNwbGl0IHZpYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIGNvbW1vbiBJRTExIGJ1ZyB3aXRoIHRoZSBjb3JlLWpzIDMuNi4wIHJlZ2V4IHBvbHlmaWxsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gIHByZVByb2Nlc3NlZEhlYWRlcnNcbiAgICAuc3BsaXQoJ1xccicpXG4gICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHJldHVybiBoZWFkZXIuaW5kZXhPZignXFxuJykgPT09IDAgPyBoZWFkZXIuc3Vic3RyKDEsIGhlYWRlci5sZW5ndGgpIDogaGVhZGVyXG4gICAgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Jlc3BvbnNlICcgKyBlcnJvci5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1c1xuICBpZiAodGhpcy5zdGF0dXMgPCAyMDAgfHwgdGhpcy5zdGF0dXMgPiA1OTkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Jlc3BvbnNlJzogVGhlIHN0YXR1cyBwcm92aWRlZCAoMCkgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgWzIwMCwgNTk5XS5cIilcbiAgfVxuICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dFxuICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG59XG5cbkJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cblJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICB1cmw6IHRoaXMudXJsXG4gIH0pXG59XG5cblJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2Uub2sgPSBmYWxzZVxuICByZXNwb25zZS5zdGF0dXMgPSAwXG4gIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gIHJldHVybiByZXNwb25zZVxufVxuXG52YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG59XG5cbmV4cG9ydCB2YXIgRE9NRXhjZXB0aW9uID0gZy5ET01FeGNlcHRpb25cbnRyeSB7XG4gIG5ldyBET01FeGNlcHRpb24oKVxufSBjYXRjaCAoZXJyKSB7XG4gIERPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpXG4gICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrXG4gIH1cbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRE9NRXhjZXB0aW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICB4aHIuYWJvcnQoKVxuICAgIH1cblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgY2hlY2sgaWYgc3BlY2lmaWNhbGx5IGZvciB3aGVuIGEgdXNlciBmZXRjaGVzIGEgZmlsZSBsb2NhbGx5IGZyb20gdGhlIGZpbGUgc3lzdGVtXG4gICAgICAvLyBPbmx5IGlmIHRoZSBzdGF0dXMgaXMgb3V0IG9mIGEgbm9ybWFsIHJhbmdlXG4gICAgICBpZiAocmVxdWVzdC51cmwuaW5kZXhPZignZmlsZTovLycpID09PSAwICYmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPiA1OTkpKSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0gMjAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCB0aW1lZCBvdXQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4VXJsKHVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVybCA9PT0gJycgJiYgZy5sb2NhdGlvbi5ocmVmID8gZy5sb2NhdGlvbi5ocmVmIDogdXJsXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgZml4VXJsKHJlcXVlc3QudXJsKSwgdHJ1ZSlcblxuICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpIHtcbiAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgc3VwcG9ydC5hcnJheUJ1ZmZlclxuICAgICAgKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQuaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgIShpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzIHx8IChnLkhlYWRlcnMgJiYgaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgZy5IZWFkZXJzKSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZXMucHVzaChub3JtYWxpemVOYW1lKG5hbWUpKVxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBub3JtYWxpemVWYWx1ZShpbml0LmhlYWRlcnNbbmFtZV0pKVxuICAgICAgfSlcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gIH0pXG59XG5cbmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxuXG5pZiAoIWcuZmV0Y2gpIHtcbiAgZy5mZXRjaCA9IGZldGNoXG4gIGcuSGVhZGVycyA9IEhlYWRlcnNcbiAgZy5SZXF1ZXN0ID0gUmVxdWVzdFxuICBnLlJlc3BvbnNlID0gUmVzcG9uc2Vcbn1cbiIsIi8qISB6ZXJvLWZpbGwuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qKlxuICogR2l2ZW4gYSBudW1iZXIsIHJldHVybiBhIHplcm8tZmlsbGVkIHN0cmluZy5cbiAqIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjY3MjgzL1xuICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSBudW1iZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB6ZXJvRmlsbCAod2lkdGgsIG51bWJlciwgcGFkKSB7XG4gIGlmIChudW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobnVtYmVyLCBwYWQpIHtcbiAgICAgIHJldHVybiB6ZXJvRmlsbCh3aWR0aCwgbnVtYmVyLCBwYWQpXG4gICAgfVxuICB9XG4gIGlmIChwYWQgPT09IHVuZGVmaW5lZCkgcGFkID0gJzAnXG4gIHdpZHRoIC09IG51bWJlci50b1N0cmluZygpLmxlbmd0aFxuICBpZiAod2lkdGggPiAwKSByZXR1cm4gbmV3IEFycmF5KHdpZHRoICsgKC9cXC4vLnRlc3QobnVtYmVyKSA/IDIgOiAxKSkuam9pbihwYWQpICsgbnVtYmVyXG4gIHJldHVybiBudW1iZXIgKyAnJ1xufVxuIiwiLyogKGlnbm9yZWQpICovIiwiLyoqXG4gKiBDcmVhdGVzIGEgY29udGludWF0aW9uIGZ1bmN0aW9uIHdpdGggc29tZSBhcmd1bWVudHMgYWxyZWFkeSBhcHBsaWVkLlxuICpcbiAqIFVzZWZ1bCBhcyBhIHNob3J0aGFuZCB3aGVuIGNvbWJpbmVkIHdpdGggb3RoZXIgY29udHJvbCBmbG93IGZ1bmN0aW9ucy4gQW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBhcmUgYWRkZWQgdG8gdGhlIGFyZ3VtZW50c1xuICogb3JpZ2luYWxseSBwYXNzZWQgdG8gYXBwbHkuXG4gKlxuICogQG5hbWUgYXBwbHlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5IGFsbFxuICogYXJndW1lbnRzIHRvLiBJbnZva2VzIHdpdGggKGFyZ3VtZW50cy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHlcbiAqIHdoZW4gdGhlIGNvbnRpbnVhdGlvbiBpcyBjYWxsZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSBwYXJ0aWFsbHktYXBwbGllZCBmdW5jdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyB1c2luZyBhcHBseVxuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMScsICd0ZXN0MScpLFxuICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMicsICd0ZXN0MicpXG4gKiBdKTtcbiAqXG4gKlxuICogLy8gdGhlIHNhbWUgcHJvY2VzcyB3aXRob3V0IHVzaW5nIGFwcGx5XG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgZnMud3JpdGVGaWxlKCd0ZXN0ZmlsZTEnLCAndGVzdDEnLCBjYWxsYmFjayk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMicsICd0ZXN0MicsIGNhbGxiYWNrKTtcbiAqICAgICB9XG4gKiBdKTtcbiAqXG4gKiAvLyBJdCdzIHBvc3NpYmxlIHRvIHBhc3MgYW55IG51bWJlciBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aGVuIGNhbGxpbmcgdGhlXG4gKiAvLyBjb250aW51YXRpb246XG4gKlxuICogbm9kZT4gdmFyIGZuID0gYXN5bmMuYXBwbHkoc3lzLnB1dHMsICdvbmUnKTtcbiAqIG5vZGU+IGZuKCd0d28nLCAndGhyZWUnKTtcbiAqIG9uZVxuICogdHdvXG4gKiB0aHJlZVxuICovXG5mdW5jdGlvbiBhcHBseShmbiwgLi4uYXJncykge1xuICAgIHJldHVybiAoLi4uY2FsbEFyZ3MpID0+IGZuKC4uLmFyZ3MsLi4uY2FsbEFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsUGFyYW1zIChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncy8qLCBjYWxsYmFjayovKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGFyZ3MsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXG52YXIgaGFzUXVldWVNaWNyb3Rhc2sgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicgJiYgcXVldWVNaWNyb3Rhc2s7XG52YXIgaGFzU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXRJbW1lZGlhdGU7XG52YXIgaGFzTmV4dFRpY2sgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIGZhbGxiYWNrKGZuKSB7XG4gICAgc2V0VGltZW91dChmbiwgMCk7XG59XG5cbmZ1bmN0aW9uIHdyYXAoZGVmZXIpIHtcbiAgICByZXR1cm4gKGZuLCAuLi5hcmdzKSA9PiBkZWZlcigoKSA9PiBmbiguLi5hcmdzKSk7XG59XG5cbnZhciBfZGVmZXIkMTtcblxuaWYgKGhhc1F1ZXVlTWljcm90YXNrKSB7XG4gICAgX2RlZmVyJDEgPSBxdWV1ZU1pY3JvdGFzaztcbn0gZWxzZSBpZiAoaGFzU2V0SW1tZWRpYXRlKSB7XG4gICAgX2RlZmVyJDEgPSBzZXRJbW1lZGlhdGU7XG59IGVsc2UgaWYgKGhhc05leHRUaWNrKSB7XG4gICAgX2RlZmVyJDEgPSBwcm9jZXNzLm5leHRUaWNrO1xufSBlbHNlIHtcbiAgICBfZGVmZXIkMSA9IGZhbGxiYWNrO1xufVxuXG52YXIgc2V0SW1tZWRpYXRlJDEgPSB3cmFwKF9kZWZlciQxKTtcblxuLyoqXG4gKiBUYWtlIGEgc3luYyBmdW5jdGlvbiBhbmQgbWFrZSBpdCBhc3luYywgcGFzc2luZyBpdHMgcmV0dXJuIHZhbHVlIHRvIGFcbiAqIGNhbGxiYWNrLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcGx1Z2dpbmcgc3luYyBmdW5jdGlvbnMgaW50byBhIHdhdGVyZmFsbCxcbiAqIHNlcmllcywgb3Igb3RoZXIgYXN5bmMgZnVuY3Rpb25zLiBBbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZ2VuZXJhdGVkXG4gKiBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvbiAoZXhjZXB0IGZvciB0aGUgZmluYWxcbiAqIGNhbGxiYWNrIGFyZ3VtZW50KS4gRXJyb3JzIHRocm93biB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG4gKlxuICogSWYgdGhlIGZ1bmN0aW9uIHBhc3NlZCB0byBgYXN5bmNpZnlgIHJldHVybnMgYSBQcm9taXNlLCB0aGF0IHByb21pc2VzJ3NcbiAqIHJlc29sdmVkL3JlamVjdGVkIHN0YXRlIHdpbGwgYmUgdXNlZCB0byBjYWxsIHRoZSBjYWxsYmFjaywgcmF0aGVyIHRoYW4gc2ltcGx5XG4gKiB0aGUgc3luY2hyb25vdXMgcmV0dXJuIHZhbHVlLlxuICpcbiAqIFRoaXMgYWxzbyBtZWFucyB5b3UgY2FuIGFzeW5jaWZ5IEVTMjAxNyBgYXN5bmNgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAbmFtZSBhc3luY2lmeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGFsaWFzIHdyYXBTeW5jXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIFRoZSBzeW5jaHJvbm91cyBmdW5jdGlvbiwgb3IgUHJvbWlzZS1yZXR1cm5pbmdcbiAqIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdG8gYW4ge0BsaW5rIEFzeW5jRnVuY3Rpb259LlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IEFuIGFzeW5jaHJvbm91cyB3cmFwcGVyIG9mIHRoZSBgZnVuY2AuIFRvIGJlXG4gKiBpbnZva2VkIHdpdGggYChhcmdzLi4uLCBjYWxsYmFjaylgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBwYXNzaW5nIGEgcmVndWxhciBzeW5jaHJvbm91cyBmdW5jdGlvblxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBhc3luYy5hc3luY2lmeShKU09OLnBhcnNlKSxcbiAqICAgICBmdW5jdGlvbiAoZGF0YSwgbmV4dCkge1xuICogICAgICAgICAvLyBkYXRhIGlzIHRoZSByZXN1bHQgb2YgcGFyc2luZyB0aGUgdGV4dC5cbiAqICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGFyc2luZyBlcnJvciwgaXQgd291bGQgaGF2ZSBiZWVuIGNhdWdodC5cbiAqICAgICB9XG4gKiBdLCBjYWxsYmFjayk7XG4gKlxuICogLy8gcGFzc2luZyBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHByb21pc2VcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsIGZpbGVuYW1lLCBcInV0ZjhcIiksXG4gKiAgICAgYXN5bmMuYXN5bmNpZnkoZnVuY3Rpb24gKGNvbnRlbnRzKSB7XG4gKiAgICAgICAgIHJldHVybiBkYi5tb2RlbC5jcmVhdGUoY29udGVudHMpO1xuICogICAgIH0pLFxuICogICAgIGZ1bmN0aW9uIChtb2RlbCwgbmV4dCkge1xuICogICAgICAgICAvLyBgbW9kZWxgIGlzIHRoZSBpbnN0YW50aWF0ZWQgbW9kZWwgb2JqZWN0LlxuICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gZXJyb3IsIHRoaXMgZnVuY3Rpb24gd291bGQgYmUgc2tpcHBlZC5cbiAqICAgICB9XG4gKiBdLCBjYWxsYmFjayk7XG4gKlxuICogLy8gZXMyMDE3IGV4YW1wbGUsIHRob3VnaCBgYXN5bmNpZnlgIGlzIG5vdCBuZWVkZWQgaWYgeW91ciBKUyBlbnZpcm9ubWVudFxuICogLy8gc3VwcG9ydHMgYXN5bmMgZnVuY3Rpb25zIG91dCBvZiB0aGUgYm94XG4gKiB2YXIgcSA9IGFzeW5jLnF1ZXVlKGFzeW5jLmFzeW5jaWZ5KGFzeW5jIGZ1bmN0aW9uKGZpbGUpIHtcbiAqICAgICB2YXIgaW50ZXJtZWRpYXRlU3RlcCA9IGF3YWl0IHByb2Nlc3NGaWxlKGZpbGUpO1xuICogICAgIHJldHVybiBhd2FpdCBzb21lUHJvbWlzZShpbnRlcm1lZGlhdGVTdGVwKVxuICogfSkpO1xuICpcbiAqIHEucHVzaChmaWxlcyk7XG4gKi9cbmZ1bmN0aW9uIGFzeW5jaWZ5KGZ1bmMpIHtcbiAgICBpZiAoaXNBc3luYyhmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MvKiwgY2FsbGJhY2sqLykge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUHJvbWlzZShwcm9taXNlLCBjYWxsYmFjaylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHJlc3VsdCBpcyBQcm9taXNlIG9iamVjdFxuICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVByb21pc2UocmVzdWx0LCBjYWxsYmFjaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUHJvbWlzZShwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgbnVsbCwgdmFsdWUpO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnIgJiYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IGVyci5tZXNzYWdlKSA/IGVyciA6IG5ldyBFcnJvcihlcnIpKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIGVycm9yLCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSQxKGUgPT4geyB0aHJvdyBlIH0sIGVycik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0FzeW5jKGZuKSB7XG4gICAgcmV0dXJuIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNHZW5lcmF0b3InO1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiB3cmFwQXN5bmMoYXN5bmNGbikge1xuICAgIGlmICh0eXBlb2YgYXN5bmNGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhIGZ1bmN0aW9uJylcbiAgICByZXR1cm4gaXNBc3luYyhhc3luY0ZuKSA/IGFzeW5jaWZ5KGFzeW5jRm4pIDogYXN5bmNGbjtcbn1cblxuLy8gY29uZGl0aW9uYWxseSBwcm9taXNpZnkgYSBmdW5jdGlvbi5cbi8vIG9ubHkgcmV0dXJuIGEgcHJvbWlzZSBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbmZ1bmN0aW9uIGF3YWl0aWZ5IChhc3luY0ZuLCBhcml0eSkge1xuICAgIGlmICghYXJpdHkpIGFyaXR5ID0gYXN5bmNGbi5sZW5ndGg7XG4gICAgaWYgKCFhcml0eSkgdGhyb3cgbmV3IEVycm9yKCdhcml0eSBpcyB1bmRlZmluZWQnKVxuICAgIGZ1bmN0aW9uIGF3YWl0YWJsZSAoLi4uYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbYXJpdHkgLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jRm4uYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhcmdzW2FyaXR5IC0gMV0gPSAoZXJyLCAuLi5jYkFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICAgICAgICByZXNvbHZlKGNiQXJncy5sZW5ndGggPiAxID8gY2JBcmdzIDogY2JBcmdzWzBdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luY0ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdGFibGVcbn1cblxuZnVuY3Rpb24gYXBwbHlFYWNoJDEgKGVhY2hmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBhcHBseUVhY2goZm5zLCAuLi5jYWxsQXJncykge1xuICAgICAgICBjb25zdCBnbyA9IGF3YWl0aWZ5KGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIChmbiwgY2IpID0+IHtcbiAgICAgICAgICAgICAgICB3cmFwQXN5bmMoZm4pLmFwcGx5KHRoYXQsIGNhbGxBcmdzLmNvbmNhdChjYikpO1xuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdvO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIF9hc3luY01hcChlYWNoZm4sIGFyciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgYXJyID0gYXJyIHx8IFtdO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuXG4gICAgcmV0dXJuIGVhY2hmbihhcnIsICh2YWx1ZSwgXywgaXRlckNiKSA9PiB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgX2l0ZXJhdGVlKHZhbHVlLCAoZXJyLCB2KSA9PiB7XG4gICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHY7XG4gICAgICAgICAgICBpdGVyQ2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICAgdmFsdWUubGVuZ3RoICUgMSA9PT0gMDtcbn1cblxuLy8gQSB0ZW1wb3JhcnkgdmFsdWUgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgbG9vcCBzaG91bGQgYmUgYnJva2VuLlxuLy8gU2VlICMxMDY0LCAjMTI5M1xuY29uc3QgYnJlYWtMb29wID0ge307XG5cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICBmdW5jdGlvbiB3cmFwcGVyICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHdyYXBwZXIsIGZuKTtcbiAgICByZXR1cm4gd3JhcHBlclxufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvciAoY29sbCkge1xuICAgIHJldHVybiBjb2xsW1N5bWJvbC5pdGVyYXRvcl0gJiYgY29sbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCkge1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IGNvbGwubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gKytpIDwgbGVuID8ge3ZhbHVlOiBjb2xsW2ldLCBrZXk6IGl9IDogbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVTMjAxNUl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVtLmRvbmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICByZXR1cm4ge3ZhbHVlOiBpdGVtLnZhbHVlLCBrZXk6IGl9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0SXRlcmF0b3Iob2JqKSB7XG4gICAgdmFyIG9rZXlzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IG9rZXlzLmxlbmd0aDtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIGtleSA9IG9rZXlzWysraV07XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpIDwgbGVuID8ge3ZhbHVlOiBvYmpba2V5XSwga2V5fSA6IG51bGw7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoY29sbCkge1xuICAgIGlmIChpc0FycmF5TGlrZShjb2xsKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKTtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihjb2xsKTtcbiAgICByZXR1cm4gaXRlcmF0b3IgPyBjcmVhdGVFUzIwMTVJdGVyYXRvcihpdGVyYXRvcikgOiBjcmVhdGVPYmplY3RJdGVyYXRvcihjb2xsKTtcbn1cblxuZnVuY3Rpb24gb25seU9uY2UoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGZuID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG59XG5cbi8vIGZvciBhc3luYyBnZW5lcmF0b3JzXG5mdW5jdGlvbiBhc3luY0VhY2hPZkxpbWl0KGdlbmVyYXRvciwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgbGV0IGF3YWl0aW5nID0gZmFsc2U7XG4gICAgbGV0IHJ1bm5pbmcgPSAwO1xuICAgIGxldCBpZHggPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVwbGVuaXNoKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXBsZW5pc2gnKVxuICAgICAgICBpZiAocnVubmluZyA+PSBsaW1pdCB8fCBhd2FpdGluZyB8fCBkb25lKSByZXR1cm5cbiAgICAgICAgLy9jb25zb2xlLmxvZygncmVwbGVuaXNoIGF3YWl0aW5nJylcbiAgICAgICAgYXdhaXRpbmcgPSB0cnVlO1xuICAgICAgICBnZW5lcmF0b3IubmV4dCgpLnRoZW4oKHt2YWx1ZSwgZG9uZTogaXRlckRvbmV9KSA9PiB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdnb3QgdmFsdWUnLCB2YWx1ZSlcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCB8fCBkb25lKSByZXR1cm5cbiAgICAgICAgICAgIGF3YWl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaXRlckRvbmUpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RvbmUgbmV4dENiJylcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bm5pbmcrKztcbiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCBpZHgsIGl0ZXJhdGVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgfSkuY2F0Y2goaGFuZGxlRXJyb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlQ2FsbGJhY2soZXJyLCByZXN1bHQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnaXRlcmF0ZWVDYWxsYmFjaycpXG4gICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm5cbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGhhbmRsZUVycm9yKGVycilcblxuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGJyZWFrTG9vcCB8fCAoZG9uZSAmJiBydW5uaW5nIDw9IDApKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RvbmUgaXRlckNiJylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXBsZW5pc2goKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm5cbiAgICAgICAgYXdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgcmVwbGVuaXNoKCk7XG59XG5cbnZhciBlYWNoT2ZMaW1pdCQyID0gKGxpbWl0KSA9PiB7XG4gICAgcmV0dXJuIChvYmosIGl0ZXJhdGVlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NvbmN1cnJlbmN5IGxpbWl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMScpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBc3luY0dlbmVyYXRvcihvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNFYWNoT2ZMaW1pdChvYmosIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXN5bmNJdGVyYWJsZShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNFYWNoT2ZMaW1pdChvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCksIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRFbGVtID0gY3JlYXRlSXRlcmF0b3Iob2JqKTtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBydW5uaW5nID0gMDtcbiAgICAgICAgdmFyIGxvb3BpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuXG4gICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gYnJlYWtMb29wIHx8IChkb25lICYmIHJ1bm5pbmcgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghbG9vcGluZykge1xuICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcbiAgICAgICAgICAgIGxvb3BpbmcgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiAhZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gbmV4dEVsZW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUoZWxlbS52YWx1ZSwgZWxlbS5rZXksIG9ubHlPbmNlKGl0ZXJhdGVlQ2FsbGJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvb3BpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcGxlbmlzaCgpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hPZkxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9XG4gKiBAYWxpYXMgZm9yRWFjaE9mTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC4gVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhblxuICogYXJyYXkuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICovXG5mdW5jdGlvbiBlYWNoT2ZMaW1pdChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGVhY2hPZkxpbWl0JDIobGltaXQpKGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTtcbn1cblxudmFyIGVhY2hPZkxpbWl0JDEgPSBhd2FpdGlmeShlYWNoT2ZMaW1pdCwgNCk7XG5cbi8vIGVhY2hPZiBpbXBsZW1lbnRhdGlvbiBvcHRpbWl6ZWQgZm9yIGFycmF5LWxpa2VzXG5mdW5jdGlvbiBlYWNoT2ZBcnJheUxpa2UoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICBjb21wbGV0ZWQgPSAwLFxuICAgICAgICB7bGVuZ3RofSA9IGNvbGwsXG4gICAgICAgIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRvckNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsZWQgPT09IHRydWUpIHJldHVyblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCgrK2NvbXBsZXRlZCA9PT0gbGVuZ3RoKSB8fCB2YWx1ZSA9PT0gYnJlYWtMb29wKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpdGVyYXRlZShjb2xsW2luZGV4XSwgaW5kZXgsIG9ubHlPbmNlKGl0ZXJhdG9yQ2FsbGJhY2spKTtcbiAgICB9XG59XG5cbi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy5cbmZ1bmN0aW9uIGVhY2hPZkdlbmVyaWMgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBlYWNoT2ZMaW1pdCQxKGNvbGwsIEluZmluaXR5LCBpdGVyYXRlZSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAqIHRvIHRoZSBpdGVyYXRlZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoT2ZcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuIGFycmF5LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGV2Lmpzb24gaXMgYSBmaWxlIGNvbnRhaW5pbmcgYSB2YWxpZCBqc29uIG9iamVjdCBjb25maWcgZm9yIGRldiBlbnZpcm9ubWVudFxuICogLy8gZGV2Lmpzb24gaXMgYSBmaWxlIGNvbnRhaW5pbmcgYSB2YWxpZCBqc29uIG9iamVjdCBjb25maWcgZm9yIHRlc3QgZW52aXJvbm1lbnRcbiAqIC8vIHByb2QuanNvbiBpcyBhIGZpbGUgY29udGFpbmluZyBhIHZhbGlkIGpzb24gb2JqZWN0IGNvbmZpZyBmb3IgcHJvZCBlbnZpcm9ubWVudFxuICogLy8gaW52YWxpZC5qc29uIGlzIGEgZmlsZSB3aXRoIGEgbWFsZm9ybWVkIGpzb24gb2JqZWN0XG4gKlxuICogbGV0IGNvbmZpZ3MgPSB7fTsgLy9nbG9iYWwgdmFyaWFibGVcbiAqIGxldCB2YWxpZENvbmZpZ0ZpbGVNYXAgPSB7ZGV2OiAnZGV2Lmpzb24nLCB0ZXN0OiAndGVzdC5qc29uJywgcHJvZDogJ3Byb2QuanNvbid9O1xuICogbGV0IGludmFsaWRDb25maWdGaWxlTWFwID0ge2RldjogJ2Rldi5qc29uJywgdGVzdDogJ3Rlc3QuanNvbicsIGludmFsaWQ6ICdpbnZhbGlkLmpzb24nfTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCByZWFkcyBhIGpzb24gZmlsZSBhbmQgcGFyc2VzIHRoZSBjb250ZW50cyBhcyBqc29uIG9iamVjdFxuICogZnVuY3Rpb24gcGFyc2VGaWxlKGZpbGUsIGtleSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5yZWFkRmlsZShmaWxlLCBcInV0ZjhcIiwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxiYWNrKGVycik7XG4gKiAgICAgICAgIHRyeSB7XG4gKiAgICAgICAgICAgICBjb25maWdzW2tleV0gPSBKU09OLnBhcnNlKGRhdGEpO1xuICogICAgICAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2soKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLmZvckVhY2hPZih2YWxpZENvbmZpZ0ZpbGVNYXAsIHBhcnNlRmlsZSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGNvbmZpZ3MpO1xuICogICAgICAgICAvLyBjb25maWdzIGlzIG5vdyBhIG1hcCBvZiBKU09OIGRhdGEsIGUuZy5cbiAqICAgICAgICAgLy8geyBkZXY6IC8vcGFyc2VkIGRldi5qc29uLCB0ZXN0OiAvL3BhcnNlZCB0ZXN0Lmpzb24sIHByb2Q6IC8vcGFyc2VkIHByb2QuanNvbn1cbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvL0Vycm9yIGhhbmRpbmdcbiAqIGFzeW5jLmZvckVhY2hPZihpbnZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlLCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gKiAgICAgICAgIC8vIEpTT04gcGFyc2UgZXJyb3IgZXhjZXB0aW9uXG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmZvckVhY2hPZih2YWxpZENvbmZpZ0ZpbGVNYXAsIHBhcnNlRmlsZSlcbiAqIC50aGVuKCAoKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gKiAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhLCBlLmcuXG4gKiAgICAgLy8geyBkZXY6IC8vcGFyc2VkIGRldi5qc29uLCB0ZXN0OiAvL3BhcnNlZCB0ZXN0Lmpzb24sIHByb2Q6IC8vcGFyc2VkIHByb2QuanNvbn1cbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vRXJyb3IgaGFuZGluZ1xuICogYXN5bmMuZm9yRWFjaE9mKGludmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUpXG4gKiAudGhlbiggKCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGNvbmZpZ3MpO1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICogICAgIC8vIEpTT04gcGFyc2UgZXJyb3IgZXhjZXB0aW9uXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5mb3JFYWNoT2YodmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhjb25maWdzKTtcbiAqICAgICAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhLCBlLmcuXG4gKiAgICAgICAgIC8vIHsgZGV2OiAvL3BhcnNlZCBkZXYuanNvbiwgdGVzdDogLy9wYXJzZWQgdGVzdC5qc29uLCBwcm9kOiAvL3BhcnNlZCBwcm9kLmpzb259XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy9FcnJvciBoYW5kaW5nXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLmZvckVhY2hPZihpbnZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlKTtcbiAqICAgICAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gSlNPTiBwYXJzZSBlcnJvciBleGNlcHRpb25cbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBlYWNoT2YoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVhY2hPZkltcGxlbWVudGF0aW9uID0gaXNBcnJheUxpa2UoY29sbCkgPyBlYWNoT2ZBcnJheUxpa2UgOiBlYWNoT2ZHZW5lcmljO1xuICAgIHJldHVybiBlYWNoT2ZJbXBsZW1lbnRhdGlvbihjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG59XG5cbnZhciBlYWNoT2YkMSA9IGF3YWl0aWZ5KGVhY2hPZiwgMyk7XG5cbi8qKlxuICogUHJvZHVjZXMgYSBuZXcgY29sbGVjdGlvbiBvZiB2YWx1ZXMgYnkgbWFwcGluZyBlYWNoIHZhbHVlIGluIGBjb2xsYCB0aHJvdWdoXG4gKiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggYW4gaXRlbSBmcm9tIGBjb2xsYFxuICogYW5kIGEgY2FsbGJhY2sgZm9yIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcuIEVhY2ggb2YgdGhlc2UgY2FsbGJhY2tzXG4gKiB0YWtlcyAyIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYGNvbGxgLiBJZlxuICogYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlXG4gKiBgbWFwYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpblxuICogcGFyYWxsZWwsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlXG4gKiBpbiBvcmRlci4gSG93ZXZlciwgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbiAqIG9yaWdpbmFsIGBjb2xsYC5cbiAqXG4gKiBJZiBgbWFwYCBpcyBwYXNzZWQgYW4gT2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGFuIEFycmF5LiAgVGhlIHJlc3VsdHNcbiAqIHdpbGwgcm91Z2hseSBiZSBpbiB0aGUgb3JkZXIgb2YgdGhlIG9yaWdpbmFsIE9iamVjdHMnIGtleXMgKGJ1dCB0aGlzIGNhblxuICogdmFyeSBhY3Jvc3MgSmF2YVNjcmlwdCBlbmdpbmVzKS5cbiAqXG4gKiBAbmFtZSBtYXBcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gQXJyYXkgb2YgdGhlXG4gKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlNC50eHQgZG9lcyBub3QgZXhpc3RcbiAqXG4gKiBjb25zdCBmaWxlTGlzdCA9IFsnZmlsZTEudHh0JywnZmlsZTIudHh0JywnZmlsZTMudHh0J107XG4gKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlNC50eHQnXTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXNcbiAqIGZ1bmN0aW9uIGdldEZpbGVTaXplSW5CeXRlcyhmaWxlLCBjYWxsYmFjaykge1xuICogICAgIGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXQuc2l6ZSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5tYXAoZmlsZUxpc3QsIGdldEZpbGVTaXplSW5CeXRlcywgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZmlsZSBzaXplIGluIGJ5dGVzIGZvciBlYWNoIGZpbGUsIGUuZy5cbiAqICAgICAgICAgLy8gWyAxMDAwLCAyMDAwLCAzMDAwXVxuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYy5tYXAod2l0aE1pc3NpbmdGaWxlTGlzdCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLm1hcChmaWxlTGlzdCwgZ2V0RmlsZVNpemVJbkJ5dGVzKVxuICogLnRoZW4oIHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICogICAgIC8vIFsgMTAwMCwgMjAwMCwgMzAwMF1cbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMubWFwKHdpdGhNaXNzaW5nRmlsZUxpc3QsIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5tYXAoZmlsZUxpc3QsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZmlsZSBzaXplIGluIGJ5dGVzIGZvciBlYWNoIGZpbGUsIGUuZy5cbiAqICAgICAgICAgLy8gWyAxMDAwLCAyMDAwLCAzMDAwXVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5tYXAod2l0aE1pc3NpbmdGaWxlTGlzdCwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBtYXAgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfYXN5bmNNYXAoZWFjaE9mJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBtYXAkMSA9IGF3YWl0aWZ5KG1hcCwgMyk7XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIHRvIGVhY2ggZnVuY3Rpb24gaW4gdGhlIGFycmF5LCBjYWxsaW5nXG4gKiBgY2FsbGJhY2tgIGFmdGVyIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIElmIHlvdSBvbmx5IHByb3ZpZGUgdGhlIGZpcnN0XG4gKiBhcmd1bWVudCwgYGZuc2AsIHRoZW4gaXQgd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB3aGljaCBsZXRzIHlvdSBwYXNzIGluIHRoZVxuICogYXJndW1lbnRzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUgZnVuY3Rpb24gY2FsbC4gSWYgbW9yZSBhcmd1bWVudHMgYXJlXG4gKiBwcm92aWRlZCwgYGNhbGxiYWNrYCBpcyByZXF1aXJlZCB3aGlsZSBgYXJnc2AgaXMgc3RpbGwgb3B0aW9uYWwuIFRoZSByZXN1bHRzXG4gKiBmb3IgZWFjaCBvZiB0aGUgYXBwbGllZCBhc3luYyBmdW5jdGlvbnMgYXJlIHBhc3NlZCB0byB0aGUgZmluYWwgY2FsbGJhY2tcbiAqIGFzIGFuIGFycmF5LlxuICpcbiAqIEBuYW1lIGFwcGx5RWFjaFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gZm5zIC0gQSBjb2xsZWN0aW9uIG9mIHtAbGluayBBc3luY0Z1bmN0aW9ufXNcbiAqIHRvIGFsbCBjYWxsIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzXG4gKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIGFueSBudW1iZXIgb2Ygc2VwYXJhdGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gKiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSB0aGUgZmluYWwgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSBjYWxsYmFjayxcbiAqIGNhbGxlZCB3aGVuIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgcHJvY2Vzc2luZy5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSAtIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vIGFyZ3Mgb3RoZXIgdGhhblxuICogYW4gb3B0aW9uYWwgY2FsbGJhY2ssIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgYGFyZ3NgIHRvIGVhY2hcbiAqIG9mIHRoZSBmdW5jdGlvbnMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNvbnN0IGFwcGxpZWRGbiA9IGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdLCAnYnVja2V0JylcbiAqXG4gKiBhcHBsaWVkRm4oKGVyciwgcmVzdWx0cykgPT4ge1xuICogICAgIC8vIHJlc3VsdHNbMF0gaXMgdGhlIHJlc3VsdHMgZm9yIGBlbmFibGVTZWFyY2hgXG4gKiAgICAgLy8gcmVzdWx0c1sxXSBpcyB0aGUgcmVzdWx0cyBmb3IgYHVwZGF0ZVNjaGVtYWBcbiAqIH0pO1xuICpcbiAqIC8vIHBhcnRpYWwgYXBwbGljYXRpb24gZXhhbXBsZTpcbiAqIGFzeW5jLmVhY2goXG4gKiAgICAgYnVja2V0cyxcbiAqICAgICBhc3luYyAoYnVja2V0KSA9PiBhc3luYy5hcHBseUVhY2goW2VuYWJsZVNlYXJjaCwgdXBkYXRlU2NoZW1hXSwgYnVja2V0KSgpLFxuICogICAgIGNhbGxiYWNrXG4gKiApO1xuICovXG52YXIgYXBwbHlFYWNoID0gYXBwbHlFYWNoJDEobWFwJDEpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hPZlNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfVxuICogQGFsaWFzIGZvckVhY2hPZlNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqL1xuZnVuY3Rpb24gZWFjaE9mU2VyaWVzKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBlYWNoT2ZMaW1pdCQxKGNvbGwsIDEsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBlYWNoT2ZTZXJpZXMkMSA9IGF3YWl0aWZ5KGVhY2hPZlNlcmllcywgMyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BtYXBgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgbWFwU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gbWFwU2VyaWVzIChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2FzeW5jTWFwKGVhY2hPZlNlcmllcyQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgbWFwU2VyaWVzJDEgPSBhd2FpdGlmeShtYXBTZXJpZXMsIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgYXBwbHlFYWNoYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmFwcGx5RWFjaH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGFwcGx5RWFjaFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuYXBwbHlFYWNoXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXBwbHlFYWNofVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gZm5zIC0gQSBjb2xsZWN0aW9uIG9mIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgdG8gYWxsXG4gKiBjYWxsIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzXG4gKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIGFueSBudW1iZXIgb2Ygc2VwYXJhdGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gKiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSB0aGUgZmluYWwgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSBjYWxsYmFjayxcbiAqIGNhbGxlZCB3aGVuIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgcHJvY2Vzc2luZy5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSAtIEEgZnVuY3Rpb24sIHRoYXQgd2hlbiBjYWxsZWQsIGlzIHRoZSByZXN1bHQgb2ZcbiAqIGFwcGxpbmcgdGhlIGBhcmdzYCB0byB0aGUgbGlzdCBvZiBmdW5jdGlvbnMuICBJdCB0YWtlcyBubyBhcmdzLCBvdGhlciB0aGFuXG4gKiBhIGNhbGxiYWNrLlxuICovXG52YXIgYXBwbHlFYWNoU2VyaWVzID0gYXBwbHlFYWNoJDEobWFwU2VyaWVzJDEpO1xuXG5jb25zdCBQUk9NSVNFX1NZTUJPTCA9IFN5bWJvbCgncHJvbWlzZUNhbGxiYWNrJyk7XG5cbmZ1bmN0aW9uIHByb21pc2VDYWxsYmFjayAoKSB7XG4gICAgbGV0IHJlc29sdmUsIHJlamVjdDtcbiAgICBmdW5jdGlvbiBjYWxsYmFjayAoZXJyLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICByZXNvbHZlKGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3MgOiBhcmdzWzBdKTtcbiAgICB9XG5cbiAgICBjYWxsYmFja1tQUk9NSVNFX1NZTUJPTF0gPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHJlcyxcbiAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBvcmRlciBmb3IgcnVubmluZyB0aGUge0BsaW5rIEFzeW5jRnVuY3Rpb259cyBpbiBgdGFza3NgLCBiYXNlZCBvblxuICogdGhlaXIgcmVxdWlyZW1lbnRzLiBFYWNoIGZ1bmN0aW9uIGNhbiBvcHRpb25hbGx5IGRlcGVuZCBvbiBvdGhlciBmdW5jdGlvbnNcbiAqIGJlaW5nIGNvbXBsZXRlZCBmaXJzdCwgYW5kIGVhY2ggZnVuY3Rpb24gaXMgcnVuIGFzIHNvb24gYXMgaXRzIHJlcXVpcmVtZW50c1xuICogYXJlIHNhdGlzZmllZC5cbiAqXG4gKiBJZiBhbnkgb2YgdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjaywgdGhlIGBhdXRvYCBzZXF1ZW5jZVxuICogd2lsbCBzdG9wLiBGdXJ0aGVyIHRhc2tzIHdpbGwgbm90IGV4ZWN1dGUgKHNvIGFueSBvdGhlciBmdW5jdGlvbnMgZGVwZW5kaW5nXG4gKiBvbiBpdCB3aWxsIG5vdCBydW4pLCBhbmQgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGVcbiAqIGVycm9yLlxuICpcbiAqIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgYWxzbyByZWNlaXZlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIGZ1bmN0aW9ucyB3aGljaFxuICogaGF2ZSBjb21wbGV0ZWQgc28gZmFyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgdGhleSBoYXZlIGRlcGVuZGVuY2llcy4gSWYgYVxuICogdGFzayBmdW5jdGlvbiBoYXMgbm8gZGVwZW5kZW5jaWVzLCBpdCB3aWxsIG9ubHkgYmUgcGFzc2VkIGEgY2FsbGJhY2suXG4gKlxuICogQG5hbWUgYXV0b1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtPYmplY3R9IHRhc2tzIC0gQW4gb2JqZWN0LiBFYWNoIG9mIGl0cyBwcm9wZXJ0aWVzIGlzIGVpdGhlciBhXG4gKiBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiByZXF1aXJlbWVudHMsIHdpdGggdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufSBpdHNlbGYgdGhlIGxhc3QgaXRlbVxuICogaW4gdGhlIGFycmF5LiBUaGUgb2JqZWN0J3Mga2V5IG9mIGEgcHJvcGVydHkgc2VydmVzIGFzIHRoZSBuYW1lIG9mIHRoZSB0YXNrXG4gKiBkZWZpbmVkIGJ5IHRoYXQgcHJvcGVydHksIGkuZS4gY2FuIGJlIHVzZWQgd2hlbiBzcGVjaWZ5aW5nIHJlcXVpcmVtZW50cyBmb3JcbiAqIG90aGVyIHRhc2tzLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgb25lIG9yIHR3byBhcmd1bWVudHM6XG4gKiAqIGEgYHJlc3VsdHNgIG9iamVjdCwgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXNseSBleGVjdXRlZFxuICogICBmdW5jdGlvbnMsIG9ubHkgcGFzc2VkIGlmIHRoZSB0YXNrIGhhcyBhbnkgZGVwZW5kZW5jaWVzLFxuICogKiBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGZ1bmN0aW9uLCB3aGljaCBtdXN0IGJlIGNhbGxlZCB3aGVuIGZpbmlzaGVkLFxuICogICBwYXNzaW5nIGFuIGBlcnJvcmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbidzXG4gKiAgIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIC0gQW4gb3B0aW9uYWwgYGludGVnZXJgIGZvclxuICogZGV0ZXJtaW5pbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRhc2tzIHRoYXQgY2FuIGJlIHJ1biBpbiBwYXJhbGxlbC4gQnlcbiAqIGRlZmF1bHQsIGFzIG1hbnkgYXMgcG9zc2libGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgXG4gKiBwYXNzIGFuIGVycm9yIHRvIHRoZWlyIGNhbGxiYWNrLiBSZXN1bHRzIGFyZSBhbHdheXMgcmV0dXJuZWQ7IGhvd2V2ZXIsIGlmIGFuXG4gKiBlcnJvciBvY2N1cnMsIG5vIGZ1cnRoZXIgYHRhc2tzYCB3aWxsIGJlIHBlcmZvcm1lZCwgYW5kIHRoZSByZXN1bHRzIG9iamVjdFxuICogd2lsbCBvbmx5IGNvbnRhaW4gcGFydGlhbCByZXN1bHRzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG5vdCBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy9Vc2luZyBDYWxsYmFja3NcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGdldCBzb21lIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gKiAgICAgfSxcbiAqICAgICBtYWtlX2ZvbGRlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluXG4gKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZm9sZGVyJyk7XG4gKiAgICAgfSxcbiAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gb25jZSB0aGVyZSBpcyBzb21lIGRhdGEgYW5kIHRoZSBkaXJlY3RvcnkgZXhpc3RzLFxuICogICAgICAgICAvLyB3cml0ZSB0aGUgZGF0YSB0byBhIGZpbGUgaW4gdGhlIGRpcmVjdG9yeVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAqICAgICB9XSxcbiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6cmVzdWx0cy53cml0ZV9maWxlLCAnZW1haWwnOid1c2VyQGV4YW1wbGUuY29tJ30pO1xuICogICAgIH1dXG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpO1xuICogICAgIH1cbiAqICAgICBjb25zb2xlLmxvZygncmVzdWx0cyA9ICcsIHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgPSB7XG4gKiAgICAgLy8gICAgIGdldF9kYXRhOiBbJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5J11cbiAqICAgICAvLyAgICAgbWFrZV9mb2xkZXI7ICdmb2xkZXInLFxuICogICAgIC8vICAgICB3cml0ZV9maWxlOiAnZmlsZW5hbWUnXG4gKiAgICAgLy8gICAgIGVtYWlsX2xpbms6IHsgZmlsZTogJ2ZpbGVuYW1lJywgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJyB9XG4gKiAgICAgLy8gfVxuICogfSk7XG4gKlxuICogLy9Vc2luZyBQcm9taXNlc1xuICogYXN5bmMuYXV0byh7XG4gKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBnZXRfZGF0YScpO1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGdldCBzb21lIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gKiAgICAgfSxcbiAqICAgICBtYWtlX2ZvbGRlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ2luIG1ha2VfZm9sZGVyJyk7XG4gKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRvIHN0b3JlIGEgZmlsZSBpblxuICogICAgICAgICAvLyB0aGlzIGlzIHJ1biBhdCB0aGUgc2FtZSB0aW1lIGFzIGdldHRpbmcgdGhlIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpO1xuICogICAgIH0sXG4gKiAgICAgd3JpdGVfZmlsZTogWydnZXRfZGF0YScsICdtYWtlX2ZvbGRlcicsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cyxcbiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnlcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZpbGVuYW1lJyk7XG4gKiAgICAgfV0sXG4gKiAgICAgZW1haWxfbGluazogWyd3cml0ZV9maWxlJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gb25jZSB0aGUgZmlsZSBpcyB3cml0dGVuIGxldCdzIGVtYWlsIGEgbGluayB0byBpdC4uLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOnJlc3VsdHMud3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XVxuICogfSkudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygncmVzdWx0cyA9ICcsIHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgPSB7XG4gKiAgICAgLy8gICAgIGdldF9kYXRhOiBbJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5J11cbiAqICAgICAvLyAgICAgbWFrZV9mb2xkZXI7ICdmb2xkZXInLFxuICogICAgIC8vICAgICB3cml0ZV9maWxlOiAnZmlsZW5hbWUnXG4gKiAgICAgLy8gICAgIGVtYWlsX2xpbms6IHsgZmlsZTogJ2ZpbGVuYW1lJywgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJyB9XG4gKiAgICAgLy8gfVxuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLmF1dG8oe1xuICogICAgICAgICAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhXG4gKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluXG4gKiAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhXG4gKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpO1xuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cyxcbiAqICAgICAgICAgICAgICAgICAvLyB3cml0ZSB0aGUgZGF0YSB0byBhIGZpbGUgaW4gdGhlIGRpcmVjdG9yeVxuICogICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgICAgICAgICAgfV0sXG4gKiAgICAgICAgICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi5cbiAqICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOnJlc3VsdHMud3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICAgICAgICAgIH1dXG4gKiAgICAgICAgIH0pO1xuICogICAgICAgICBjb25zb2xlLmxvZygncmVzdWx0cyA9ICcsIHJlc3VsdHMpO1xuICogICAgICAgICAvLyByZXN1bHRzID0ge1xuICogICAgICAgICAvLyAgICAgZ2V0X2RhdGE6IFsnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknXVxuICogICAgICAgICAvLyAgICAgbWFrZV9mb2xkZXI7ICdmb2xkZXInLFxuICogICAgICAgICAvLyAgICAgd3JpdGVfZmlsZTogJ2ZpbGVuYW1lJ1xuICogICAgICAgICAvLyAgICAgZW1haWxfbGluazogeyBmaWxlOiAnZmlsZW5hbWUnLCBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nIH1cbiAqICAgICAgICAgLy8gfVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gYXV0byh0YXNrcywgY29uY3VycmVuY3ksIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjb25jdXJyZW5jeSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gY29uY3VycmVuY3kgaXMgb3B0aW9uYWwsIHNoaWZ0IHRoZSBhcmdzLlxuICAgICAgICBjYWxsYmFjayA9IGNvbmN1cnJlbmN5O1xuICAgICAgICBjb25jdXJyZW5jeSA9IG51bGw7XG4gICAgfVxuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBwcm9taXNlQ2FsbGJhY2soKSk7XG4gICAgdmFyIG51bVRhc2tzID0gT2JqZWN0LmtleXModGFza3MpLmxlbmd0aDtcbiAgICBpZiAoIW51bVRhc2tzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgaWYgKCFjb25jdXJyZW5jeSkge1xuICAgICAgICBjb25jdXJyZW5jeSA9IG51bVRhc2tzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgdmFyIHJ1bm5pbmdUYXNrcyA9IDA7XG4gICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHZhciByZWFkeVRhc2tzID0gW107XG5cbiAgICAvLyBmb3IgY3ljbGUgZGV0ZWN0aW9uOlxuICAgIHZhciByZWFkeVRvQ2hlY2sgPSBbXTsgLy8gdGFza3MgdGhhdCBoYXZlIGJlZW4gaWRlbnRpZmllZCBhcyByZWFjaGFibGVcbiAgICAvLyB3aXRob3V0IHRoZSBwb3NzaWJpbGl0eSBvZiByZXR1cm5pbmcgdG8gYW4gYW5jZXN0b3IgdGFza1xuICAgIHZhciB1bmNoZWNrZWREZXBlbmRlbmNpZXMgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKHRhc2tzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHZhciB0YXNrID0gdGFza3Nba2V5XTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhc2spKSB7XG4gICAgICAgICAgICAvLyBubyBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIGVucXVldWVUYXNrKGtleSwgW3Rhc2tdKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RlcGVuZGVuY2llcyA9PT0gMCkge1xuICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5jaGVja2VkRGVwZW5kZW5jaWVzW2tleV0gPSByZW1haW5pbmdEZXBlbmRlbmNpZXM7XG5cbiAgICAgICAgZGVwZW5kZW5jaWVzLmZvckVhY2goZGVwZW5kZW5jeU5hbWUgPT4ge1xuICAgICAgICAgICAgaWYgKCF0YXNrc1tkZXBlbmRlbmN5TmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jLmF1dG8gdGFzayBgJyArIGtleSArXG4gICAgICAgICAgICAgICAgICAgICdgIGhhcyBhIG5vbi1leGlzdGVudCBkZXBlbmRlbmN5IGAnICtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeU5hbWUgKyAnYCBpbiAnICtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkTGlzdGVuZXIoZGVwZW5kZW5jeU5hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmdEZXBlbmRlbmNpZXMtLTtcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nRGVwZW5kZW5jaWVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVucXVldWVUYXNrKGtleSwgdGFzayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY2hlY2tGb3JEZWFkbG9ja3MoKTtcbiAgICBwcm9jZXNzUXVldWUoKTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWVUYXNrKGtleSwgdGFzaykge1xuICAgICAgICByZWFkeVRhc2tzLnB1c2goKCkgPT4gcnVuVGFzayhrZXksIHRhc2spKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUXVldWUoKSB7XG4gICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuXG4gICAgICAgIGlmIChyZWFkeVRhc2tzLmxlbmd0aCA9PT0gMCAmJiBydW5uaW5nVGFza3MgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShyZWFkeVRhc2tzLmxlbmd0aCAmJiBydW5uaW5nVGFza3MgPCBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgdmFyIHJ1biA9IHJlYWR5VGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0YXNrTmFtZSwgZm4pIHtcbiAgICAgICAgdmFyIHRhc2tMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbdGFza05hbWVdO1xuICAgICAgICBpZiAoIXRhc2tMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRhc2tMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbdGFza05hbWVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0YXNrTGlzdGVuZXJzLnB1c2goZm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRhc2tDb21wbGV0ZSh0YXNrTmFtZSkge1xuICAgICAgICB2YXIgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gfHwgW107XG4gICAgICAgIHRhc2tMaXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbigpKTtcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBydW5UYXNrKGtleSwgdGFzaykge1xuICAgICAgICBpZiAoaGFzRXJyb3IpIHJldHVybjtcblxuICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gb25seU9uY2UoKGVyciwgLi4ucmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBydW5uaW5nVGFza3MtLTtcbiAgICAgICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgW3Jlc3VsdF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0cykuZm9yRWFjaChya2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSByZXN1bHRzW3JrZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHRhc2tDb21wbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBydW5uaW5nVGFza3MrKztcbiAgICAgICAgdmFyIHRhc2tGbiA9IHdyYXBBc3luYyh0YXNrW3Rhc2subGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAodGFzay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0YXNrRm4ocmVzdWx0cywgdGFza0NhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhc2tGbih0YXNrQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tGb3JEZWFkbG9ja3MoKSB7XG4gICAgICAgIC8vIEthaG4ncyBhbGdvcml0aG1cbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9wb2xvZ2ljYWxfc29ydGluZyNLYWhuLjI3c19hbGdvcml0aG1cbiAgICAgICAgLy8gaHR0cDovL2Nvbm5hbGxlLmJsb2dzcG90LmNvbS8yMDEzLzEwL3RvcG9sb2dpY2FsLXNvcnRpbmdrYWhuLWFsZ29yaXRobS5odG1sXG4gICAgICAgIHZhciBjdXJyZW50VGFzaztcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICB3aGlsZSAocmVhZHlUb0NoZWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFRhc2sgPSByZWFkeVRvQ2hlY2sucG9wKCk7XG4gICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICBnZXREZXBlbmRlbnRzKGN1cnJlbnRUYXNrKS5mb3JFYWNoKGRlcGVuZGVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKC0tdW5jaGVja2VkRGVwZW5kZW5jaWVzW2RlcGVuZGVudF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlUb0NoZWNrLnB1c2goZGVwZW5kZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3VudGVyICE9PSBudW1UYXNrcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdhc3luYy5hdXRvIGNhbm5vdCBleGVjdXRlIHRhc2tzIGR1ZSB0byBhIHJlY3Vyc2l2ZSBkZXBlbmRlbmN5J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERlcGVuZGVudHModGFza05hbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyh0YXNrcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IHRhc2tzW2tleV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXNrKSAmJiB0YXNrLmluZGV4T2YodGFza05hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2tbUFJPTUlTRV9TWU1CT0xdXG59XG5cbnZhciBGTl9BUkdTID0gL14oPzphc3luY1xccyk/KD86ZnVuY3Rpb24pP1xccyooPzpcXHcrXFxzKik/XFwoKFteKV0rKVxcKSg/Olxccyp7KS87XG52YXIgQVJST1dfRk5fQVJHUyA9IC9eKD86YXN5bmNcXHMpP1xccyooPzpcXChcXHMqKT8oKD86W14pPVxcc11cXHMqKSopKD86XFwpXFxzKik/PT4vO1xudmFyIEZOX0FSR19TUExJVCA9IC8sLztcbnZhciBGTl9BUkcgPSAvKD0uKyk/KFxccyopJC87XG5cbmZ1bmN0aW9uIHN0cmlwQ29tbWVudHMoc3RyaW5nKSB7XG4gICAgbGV0IHN0cmlwcGVkID0gJyc7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgZW5kQmxvY2tDb21tZW50ID0gc3RyaW5nLmluZGV4T2YoJyovJyk7XG4gICAgd2hpbGUgKGluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3RyaW5nW2luZGV4XSA9PT0gJy8nICYmIHN0cmluZ1tpbmRleCsxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAvLyBpbmxpbmUgY29tbWVudFxuICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gKGVuZEluZGV4ID09PSAtMSkgPyBzdHJpbmcubGVuZ3RoIDogZW5kSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZiAoKGVuZEJsb2NrQ29tbWVudCAhPT0gLTEpICYmIChzdHJpbmdbaW5kZXhdID09PSAnLycpICYmIChzdHJpbmdbaW5kZXgrMV0gPT09ICcqJykpIHtcbiAgICAgICAgICAgIC8vIGJsb2NrIGNvbW1lbnRcbiAgICAgICAgICAgIGxldCBlbmRJbmRleCA9IHN0cmluZy5pbmRleE9mKCcqLycsIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGVuZEluZGV4ICsgMjtcbiAgICAgICAgICAgICAgICBlbmRCbG9ja0NvbW1lbnQgPSBzdHJpbmcuaW5kZXhPZignKi8nLCBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmlwcGVkICs9IHN0cmluZ1tpbmRleF07XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmlwcGVkICs9IHN0cmluZ1tpbmRleF07XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJpcHBlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbXMoZnVuYykge1xuICAgIGNvbnN0IHNyYyA9IHN0cmlwQ29tbWVudHMoZnVuYy50b1N0cmluZygpKTtcbiAgICBsZXQgbWF0Y2ggPSBzcmMubWF0Y2goRk5fQVJHUyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBtYXRjaCA9IHNyYy5tYXRjaChBUlJPV19GTl9BUkdTKTtcbiAgICB9XG4gICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcGFyc2UgYXJncyBpbiBhdXRvSW5qZWN0XFxuU291cmNlOlxcbicgKyBzcmMpXG4gICAgbGV0IFssIGFyZ3NdID0gbWF0Y2g7XG4gICAgcmV0dXJuIGFyZ3NcbiAgICAgICAgLnJlcGxhY2UoL1xccy9nLCAnJylcbiAgICAgICAgLnNwbGl0KEZOX0FSR19TUExJVClcbiAgICAgICAgLm1hcCgoYXJnKSA9PiBhcmcucmVwbGFjZShGTl9BUkcsICcnKS50cmltKCkpO1xufVxuXG4vKipcbiAqIEEgZGVwZW5kZW5jeS1pbmplY3RlZCB2ZXJzaW9uIG9mIHRoZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99IGZ1bmN0aW9uLiBEZXBlbmRlbnRcbiAqIHRhc2tzIGFyZSBzcGVjaWZpZWQgYXMgcGFyYW1ldGVycyB0byB0aGUgZnVuY3Rpb24sIGFmdGVyIHRoZSB1c3VhbCBjYWxsYmFja1xuICogcGFyYW1ldGVyLCB3aXRoIHRoZSBwYXJhbWV0ZXIgbmFtZXMgbWF0Y2hpbmcgdGhlIG5hbWVzIG9mIHRoZSB0YXNrcyBpdFxuICogZGVwZW5kcyBvbi4gVGhpcyBjYW4gcHJvdmlkZSBldmVuIG1vcmUgcmVhZGFibGUgdGFzayBncmFwaHMgd2hpY2ggY2FuIGJlXG4gKiBlYXNpZXIgdG8gbWFpbnRhaW4uXG4gKlxuICogSWYgYSBmaW5hbCBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHRoZSB0YXNrIHJlc3VsdHMgYXJlIHNpbWlsYXJseSBpbmplY3RlZCxcbiAqIHNwZWNpZmllZCBhcyBuYW1lZCBwYXJhbWV0ZXJzIGFmdGVyIHRoZSBpbml0aWFsIGVycm9yIHBhcmFtZXRlci5cbiAqXG4gKiBUaGUgYXV0b0luamVjdCBmdW5jdGlvbiBpcyBwdXJlbHkgc3ludGFjdGljIHN1Z2FyIGFuZCBpdHMgc2VtYW50aWNzIGFyZVxuICogb3RoZXJ3aXNlIGVxdWl2YWxlbnQgdG8gW2FzeW5jLmF1dG9de0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfS5cbiAqXG4gKiBAbmFtZSBhdXRvSW5qZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdCwgZWFjaCBvZiB3aG9zZSBwcm9wZXJ0aWVzIGlzIGFuIHtAbGluayBBc3luY0Z1bmN0aW9ufSBvZlxuICogdGhlIGZvcm0gJ2Z1bmMoW2RlcGVuZGVuY2llcy4uLl0sIGNhbGxiYWNrKS4gVGhlIG9iamVjdCdzIGtleSBvZiBhIHByb3BlcnR5XG4gKiBzZXJ2ZXMgYXMgdGhlIG5hbWUgb2YgdGhlIHRhc2sgZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkXG4gKiB3aGVuIHNwZWNpZnlpbmcgcmVxdWlyZW1lbnRzIGZvciBvdGhlciB0YXNrcy5cbiAqICogVGhlIGBjYWxsYmFja2AgcGFyYW1ldGVyIGlzIGEgYGNhbGxiYWNrKGVyciwgcmVzdWx0KWAgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqICAgd2hlbiBmaW5pc2hlZCwgcGFzc2luZyBhbiBgZXJyb3JgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgdGhlIHJlc3VsdCBvZlxuICogICB0aGUgZnVuY3Rpb24ncyBleGVjdXRpb24uIFRoZSByZW1haW5pbmcgcGFyYW1ldGVycyBuYW1lIG90aGVyIHRhc2tzIG9uXG4gKiAgIHdoaWNoIHRoZSB0YXNrIGlzIGRlcGVuZGVudCwgYW5kIHRoZSByZXN1bHRzIGZyb20gdGhvc2UgdGFza3MgYXJlIHRoZVxuICogICBhcmd1bWVudHMgb2YgdGhvc2UgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIHRoZSB0YXNrcyBoYXZlIGJlZW4gY29tcGxldGVkLiBJdCByZWNlaXZlcyB0aGUgYGVycmAgYXJndW1lbnQgaWYgYW55IGB0YXNrc2BcbiAqIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIGFuZCBhIGByZXN1bHRzYCBvYmplY3Qgd2l0aCBhbnkgY29tcGxldGVkXG4gKiB0YXNrIHJlc3VsdHMsIHNpbWlsYXIgdG8gYGF1dG9gLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vICBUaGUgZXhhbXBsZSBmcm9tIGBhdXRvYCBjYW4gYmUgcmV3cml0dGVuIGFzIGZvbGxvd3M6XG4gKiBhc3luYy5hdXRvSW5qZWN0KHtcbiAqICAgICBnZXRfZGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpO1xuICogICAgIH0sXG4gKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRvIHN0b3JlIGEgZmlsZSBpblxuICogICAgICAgICAvLyB0aGlzIGlzIHJ1biBhdCB0aGUgc2FtZSB0aW1lIGFzIGdldHRpbmcgdGhlIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpO1xuICogICAgIH0sXG4gKiAgICAgd3JpdGVfZmlsZTogZnVuY3Rpb24oZ2V0X2RhdGEsIG1ha2VfZm9sZGVyLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsXG4gKiAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgIH0sXG4gKiAgICAgZW1haWxfbGluazogZnVuY3Rpb24od3JpdGVfZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gb25jZSB0aGUgZmlsZSBpcyB3cml0dGVuIGxldCdzIGVtYWlsIGEgbGluayB0byBpdC4uLlxuICogICAgICAgICAvLyB3cml0ZV9maWxlIGNvbnRhaW5zIHRoZSBmaWxlbmFtZSByZXR1cm5lZCBieSB3cml0ZV9maWxlLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2VyciA9ICcsIGVycik7XG4gKiAgICAgY29uc29sZS5sb2coJ2VtYWlsX2xpbmsgPSAnLCByZXN1bHRzLmVtYWlsX2xpbmspO1xuICogfSk7XG4gKlxuICogLy8gSWYgeW91IGFyZSB1c2luZyBhIEpTIG1pbmlmaWVyIHRoYXQgbWFuZ2xlcyBwYXJhbWV0ZXIgbmFtZXMsIGBhdXRvSW5qZWN0YFxuICogLy8gd2lsbCBub3Qgd29yayB3aXRoIHBsYWluIGZ1bmN0aW9ucywgc2luY2UgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsIGJlXG4gKiAvLyBjb2xsYXBzZWQgdG8gYSBzaW5nbGUgbGV0dGVyIGlkZW50aWZpZXIuICBUbyB3b3JrIGFyb3VuZCB0aGlzLCB5b3UgY2FuXG4gKiAvLyBleHBsaWNpdGx5IHNwZWNpZnkgdGhlIG5hbWVzIG9mIHRoZSBwYXJhbWV0ZXJzIHlvdXIgdGFzayBmdW5jdGlvbiBuZWVkc1xuICogLy8gaW4gYW4gYXJyYXksIHNpbWlsYXIgdG8gQW5ndWxhci5qcyBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAqXG4gKiAvLyBUaGlzIHN0aWxsIGhhcyBhbiBhZHZhbnRhZ2Ugb3ZlciBwbGFpbiBgYXV0b2AsIHNpbmNlIHRoZSByZXN1bHRzIGEgdGFza1xuICogLy8gZGVwZW5kcyBvbiBhcmUgc3RpbGwgc3ByZWFkIGludG8gYXJndW1lbnRzLlxuICogYXN5bmMuYXV0b0luamVjdCh7XG4gKiAgICAgLy8uLi5cbiAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24oZ2V0X2RhdGEsIG1ha2VfZm9sZGVyLCBjYWxsYmFjaykge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAqICAgICB9XSxcbiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7XG4gKiAgICAgfV1cbiAqICAgICAvLy4uLlxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2VyciA9ICcsIGVycik7XG4gKiAgICAgY29uc29sZS5sb2coJ2VtYWlsX2xpbmsgPSAnLCByZXN1bHRzLmVtYWlsX2xpbmspO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGF1dG9JbmplY3QodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5ld1Rhc2tzID0ge307XG5cbiAgICBPYmplY3Qua2V5cyh0YXNrcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICB2YXIgdGFza0ZuID0gdGFza3Nba2V5XTtcbiAgICAgICAgdmFyIHBhcmFtcztcbiAgICAgICAgdmFyIGZuSXNBc3luYyA9IGlzQXN5bmModGFza0ZuKTtcbiAgICAgICAgdmFyIGhhc05vRGVwcyA9XG4gICAgICAgICAgICAoIWZuSXNBc3luYyAmJiB0YXNrRm4ubGVuZ3RoID09PSAxKSB8fFxuICAgICAgICAgICAgKGZuSXNBc3luYyAmJiB0YXNrRm4ubGVuZ3RoID09PSAwKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXNrRm4pKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBbLi4udGFza0ZuXTtcbiAgICAgICAgICAgIHRhc2tGbiA9IHBhcmFtcy5wb3AoKTtcblxuICAgICAgICAgICAgbmV3VGFza3Nba2V5XSA9IHBhcmFtcy5jb25jYXQocGFyYW1zLmxlbmd0aCA+IDAgPyBuZXdUYXNrIDogdGFza0ZuKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNOb0RlcHMpIHtcbiAgICAgICAgICAgIC8vIG5vIGRlcGVuZGVuY2llcywgdXNlIHRoZSBmdW5jdGlvbiBhcy1pc1xuICAgICAgICAgICAgbmV3VGFza3Nba2V5XSA9IHRhc2tGbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1zKHRhc2tGbik7XG4gICAgICAgICAgICBpZiAoKHRhc2tGbi5sZW5ndGggPT09IDAgJiYgIWZuSXNBc3luYykgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dG9JbmplY3QgdGFzayBmdW5jdGlvbnMgcmVxdWlyZSBleHBsaWNpdCBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGNhbGxiYWNrIHBhcmFtXG4gICAgICAgICAgICBpZiAoIWZuSXNBc3luYykgcGFyYW1zLnBvcCgpO1xuXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChuZXdUYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5ld1Rhc2socmVzdWx0cywgdGFza0NiKSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJncyA9IHBhcmFtcy5tYXAobmFtZSA9PiByZXN1bHRzW25hbWVdKTtcbiAgICAgICAgICAgIG5ld0FyZ3MucHVzaCh0YXNrQ2IpO1xuICAgICAgICAgICAgd3JhcEFzeW5jKHRhc2tGbikoLi4ubmV3QXJncyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhdXRvKG5ld1Rhc2tzLCBjYWxsYmFjayk7XG59XG5cbi8vIFNpbXBsZSBkb3VibHkgbGlua2VkIGxpc3QgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWJseV9saW5rZWRfbGlzdCkgaW1wbGVtZW50YXRpb25cbi8vIHVzZWQgZm9yIHF1ZXVlcy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoYXQgdGhlIG5vZGUgcHJvdmlkZWQgYnkgdGhlIHVzZXIgY2FuIGJlIG1vZGlmaWVkXG4vLyB0byBhZGp1c3QgdGhlIG5leHQgYW5kIGxhc3QgcHJvcGVydGllcy4gV2UgaW1wbGVtZW50IG9ubHkgdGhlIG1pbmltYWwgZnVuY3Rpb25hbGl0eVxuLy8gZm9yIHF1ZXVlIHN1cHBvcnQuXG5jbGFzcyBETEwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmVtb3ZlTGluayhub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IG5vZGUubmV4dDtcbiAgICAgICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgICAgIGVsc2UgdGhpcy50YWlsID0gbm9kZS5wcmV2O1xuXG4gICAgICAgIG5vZGUucHJldiA9IG5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGVtcHR5ICgpIHtcbiAgICAgICAgd2hpbGUodGhpcy5oZWFkKSB0aGlzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGluc2VydEFmdGVyKG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgbmV3Tm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgbmV3Tm9kZS5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICBpZiAobm9kZS5uZXh0KSBub2RlLm5leHQucHJldiA9IG5ld05vZGU7XG4gICAgICAgIGVsc2UgdGhpcy50YWlsID0gbmV3Tm9kZTtcbiAgICAgICAgbm9kZS5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICB9XG5cbiAgICBpbnNlcnRCZWZvcmUobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICBuZXdOb2RlLnByZXYgPSBub2RlLnByZXY7XG4gICAgICAgIG5ld05vZGUubmV4dCA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgZWxzZSB0aGlzLmhlYWQgPSBuZXdOb2RlO1xuICAgICAgICBub2RlLnByZXYgPSBuZXdOb2RlO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSAxO1xuICAgIH1cblxuICAgIHVuc2hpZnQobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkKSB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsIG5vZGUpO1xuICAgICAgICBlbHNlIHNldEluaXRpYWwodGhpcywgbm9kZSk7XG4gICAgfVxuXG4gICAgcHVzaChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnRhaWwpIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy50YWlsLCBub2RlKTtcbiAgICAgICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpO1xuICAgIH1cblxuICAgIHNoaWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkICYmIHRoaXMucmVtb3ZlTGluayh0aGlzLmhlYWQpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFpbCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy50YWlsKTtcbiAgICB9XG5cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXNdXG4gICAgfVxuXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cikge1xuICAgICAgICAgICAgeWllbGQgY3VyLmRhdGE7XG4gICAgICAgICAgICBjdXIgPSBjdXIubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZSAodGVzdEZuKSB7XG4gICAgICAgIHZhciBjdXJyID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZShjdXJyKSB7XG4gICAgICAgICAgICB2YXIge25leHR9ID0gY3VycjtcbiAgICAgICAgICAgIGlmICh0ZXN0Rm4oY3VycikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpbmsoY3Vycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWwoZGxsLCBub2RlKSB7XG4gICAgZGxsLmxlbmd0aCA9IDE7XG4gICAgZGxsLmhlYWQgPSBkbGwudGFpbCA9IG5vZGU7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlJDEod29ya2VyLCBjb25jdXJyZW5jeSwgcGF5bG9hZCkge1xuICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7XG4gICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICB9XG4gICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ29uY3VycmVuY3kgbXVzdCBub3QgYmUgemVybycpO1xuICAgIH1cblxuICAgIHZhciBfd29ya2VyID0gd3JhcEFzeW5jKHdvcmtlcik7XG4gICAgdmFyIG51bVJ1bm5pbmcgPSAwO1xuICAgIHZhciB3b3JrZXJzTGlzdCA9IFtdO1xuICAgIGNvbnN0IGV2ZW50cyA9IHtcbiAgICAgICAgZXJyb3I6IFtdLFxuICAgICAgICBkcmFpbjogW10sXG4gICAgICAgIHNhdHVyYXRlZDogW10sXG4gICAgICAgIHVuc2F0dXJhdGVkOiBbXSxcbiAgICAgICAgZW1wdHk6IFtdXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICBldmVudHNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25jZSAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlQW5kUmVtb3ZlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIG9mZihldmVudCwgaGFuZGxlQW5kUmVtb3ZlKTtcbiAgICAgICAgICAgIGhhbmRsZXIoLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50c1tldmVudF0ucHVzaChoYW5kbGVBbmRSZW1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFldmVudCkgcmV0dXJuIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaChldiA9PiBldmVudHNbZXZdID0gW10pXG4gICAgICAgIGlmICghaGFuZGxlcikgcmV0dXJuIGV2ZW50c1tldmVudF0gPSBbXVxuICAgICAgICBldmVudHNbZXZlbnRdID0gZXZlbnRzW2V2ZW50XS5maWx0ZXIoZXYgPT4gZXYgIT09IGhhbmRsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXIgKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGV2ZW50c1tldmVudF0uZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoLi4uYXJncykpO1xuICAgIH1cblxuICAgIHZhciBwcm9jZXNzaW5nU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gX2luc2VydChkYXRhLCBpbnNlcnRBdEZyb250LCByZWplY3RPbkVycm9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciByZXMsIHJlajtcbiAgICAgICAgZnVuY3Rpb24gcHJvbWlzZUNhbGxiYWNrIChlcnIsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yLCBsZXQgdGhlIGdsb2JhbCBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICAvLyBkZWFsIHdpdGggaXRcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3RPbkVycm9yID8gcmVqKGVycikgOiByZXMoKVxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHJldHVybiByZXMoYXJnc1swXSlcbiAgICAgICAgICAgIHJlcyhhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVtID0gcS5fY3JlYXRlVGFza0l0ZW0oXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVqZWN0T25FcnJvciA/IHByb21pc2VDYWxsYmFjayA6XG4gICAgICAgICAgICAgICAgKGNhbGxiYWNrIHx8IHByb21pc2VDYWxsYmFjaylcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaW5zZXJ0QXRGcm9udCkge1xuICAgICAgICAgICAgcS5fdGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHEuX3Rhc2tzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb2Nlc3NpbmdTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlamVjdE9uRXJyb3IgfHwgIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgcmVqID0gcmVqZWN0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVDQih0YXNrcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgLi4uYXJncykge1xuICAgICAgICAgICAgbnVtUnVubmluZyAtPSAxO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NbaV07XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB3b3JrZXJzTGlzdC5pbmRleE9mKHRhc2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjayhlcnIsIC4uLmFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2Vycm9yJywgZXJyLCB0YXNrLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPD0gKHEuY29uY3VycmVuY3kgLSBxLmJ1ZmZlcikgKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcigndW5zYXR1cmF0ZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcignZHJhaW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9tYXliZURyYWluKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwICYmIHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4gdHJpZ2dlcignZHJhaW4nKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TWV0aG9kID0gKG5hbWUpID0+IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBvbmNlKG5hbWUsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIG9mZihuYW1lKTtcbiAgICAgICAgb24obmFtZSwgaGFuZGxlcik7XG5cbiAgICB9O1xuXG4gICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHZhciBxID0ge1xuICAgICAgICBfdGFza3M6IG5ldyBETEwoKSxcbiAgICAgICAgX2NyZWF0ZVRhc2tJdGVtIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgICAgICAgeWllbGQqIHEuX3Rhc2tzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIGJ1ZmZlcjogY29uY3VycmVuY3kgLyA0LFxuICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgcHVzaCAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9tYXliZURyYWluKGRhdGEpKSByZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoZGF0dW0gPT4gX2luc2VydChkYXR1bSwgZmFsc2UsIGZhbHNlLCBjYWxsYmFjaykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2luc2VydChkYXRhLCBmYWxzZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaEFzeW5jIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX21heWJlRHJhaW4oZGF0YSkpIHJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChkYXR1bSA9PiBfaW5zZXJ0KGRhdHVtLCBmYWxzZSwgdHJ1ZSwgY2FsbGJhY2spKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9pbnNlcnQoZGF0YSwgZmFsc2UsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAga2lsbCAoKSB7XG4gICAgICAgICAgICBvZmYoKTtcbiAgICAgICAgICAgIHEuX3Rhc2tzLmVtcHR5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2hpZnQgKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChfbWF5YmVEcmFpbihkYXRhKSkgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGRhdHVtID0+IF9pbnNlcnQoZGF0dW0sIHRydWUsIGZhbHNlLCBjYWxsYmFjaykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2luc2VydChkYXRhLCB0cnVlLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICB1bnNoaWZ0QXN5bmMgKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChfbWF5YmVEcmFpbihkYXRhKSkgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGRhdHVtID0+IF9pbnNlcnQoZGF0dW0sIHRydWUsIHRydWUsIGNhbGxiYWNrKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfaW5zZXJ0KGRhdGEsIHRydWUsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlICh0ZXN0Rm4pIHtcbiAgICAgICAgICAgIHEuX3Rhc2tzLnJlbW92ZSh0ZXN0Rm4pO1xuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzICgpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIHRyeWluZyB0byBzdGFydCB0b28gbWFueSBwcm9jZXNzaW5nIG9wZXJhdGlvbnMuIFRoaXMgY2FuIG9jY3VyXG4gICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyByZXNvbHZlIHN5bmNocm9ub3VzbHkgKCMxMjY3KS5cbiAgICAgICAgICAgIGlmIChpc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUoIXEucGF1c2VkICYmIG51bVJ1bm5pbmcgPCBxLmNvbmN1cnJlbmN5ICYmIHEuX3Rhc2tzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2tzID0gW10sIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHEuX3Rhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXlsb2FkKSBsID0gTWF0aC5taW4obCwgcS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHEuX3Rhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChub2RlLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG51bVJ1bm5pbmcgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChxLl90YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcignZW1wdHknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtUnVubmluZyA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdzYXR1cmF0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5T25jZShfY3JlYXRlQ0IodGFza3MpKTtcbiAgICAgICAgICAgICAgICBfd29ya2VyKGRhdGEsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBsZW5ndGggKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgcnVubmluZyAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtUnVubmluZztcbiAgICAgICAgfSxcbiAgICAgICAgd29ya2Vyc0xpc3QgKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnNMaXN0O1xuICAgICAgICB9LFxuICAgICAgICBpZGxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aCArIG51bVJ1bm5pbmcgPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdXNlICgpIHtcbiAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdW1lICgpIHtcbiAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICBxLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEocS5wcm9jZXNzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZGVmaW5lIHRoZXNlIGFzIGZpeGVkIHByb3BlcnRpZXMsIHNvIHBlb3BsZSBnZXQgdXNlZnVsIGVycm9ycyB3aGVuIHVwZGF0aW5nXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocSwge1xuICAgICAgICBzYXR1cmF0ZWQ6IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudE1ldGhvZCgnc2F0dXJhdGVkJylcbiAgICAgICAgfSxcbiAgICAgICAgdW5zYXR1cmF0ZWQ6IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudE1ldGhvZCgndW5zYXR1cmF0ZWQnKVxuICAgICAgICB9LFxuICAgICAgICBlbXB0eToge1xuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50TWV0aG9kKCdlbXB0eScpXG4gICAgICAgIH0sXG4gICAgICAgIGRyYWluOiB7XG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZXZlbnRNZXRob2QoJ2RyYWluJylcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudE1ldGhvZCgnZXJyb3InKVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBxO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgY2FyZ29gIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBjYXJnbyB3aWxsIGJlIHByb2Nlc3NlZCBhbHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KS4gSWYgdGhlXG4gKiBgd29ya2VyYCBpcyBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIGl0IGJlY29tZXMgYXZhaWxhYmxlLiBPbmNlXG4gKiB0aGUgYHdvcmtlcmAgaGFzIGNvbXBsZXRlZCBzb21lIHRhc2tzLCBlYWNoIGNhbGxiYWNrIG9mIHRob3NlIHRhc2tzIGlzXG4gKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NilcbiAqIGZvciBob3cgYGNhcmdvYCBhbmQgYHF1ZXVlYCB3b3JrLlxuICpcbiAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnNcbiAqIGF0IGEgdGltZSwgY2FyZ28gcGFzc2VzIGFuIGFycmF5IG9mIHRhc2tzIHRvIGEgc2luZ2xlIHdvcmtlciwgcmVwZWF0aW5nXG4gKiB3aGVuIHRoZSB3b3JrZXIgaXMgZmluaXNoZWQuXG4gKlxuICogQG5hbWUgY2FyZ29cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhbiBhcnJheVxuICogb2YgcXVldWVkIHRhc2tzLiBJbnZva2VkIHdpdGggYCh0YXNrcywgY2FsbGJhY2spYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGF5bG9hZD1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nXG4gKiBob3cgbWFueSB0YXNrcyBzaG91bGQgYmUgcHJvY2Vzc2VkIHBlciByb3VuZDsgaWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXNcbiAqIHVubGltaXRlZC5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgY2FyZ28gb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvIGFuZCBpbm5lciBxdWV1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gY3JlYXRlIGEgY2FyZ28gb2JqZWN0IHdpdGggcGF5bG9hZCAyXG4gKiB2YXIgY2FyZ28gPSBhc3luYy5jYXJnbyhmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAqICAgICBmb3IgKHZhciBpPTA7IGk8dGFza3MubGVuZ3RoOyBpKyspIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrc1tpXS5uYW1lKTtcbiAqICAgICB9XG4gKiAgICAgY2FsbGJhY2soKTtcbiAqIH0sIDIpO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zXG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKiBhd2FpdCBjYXJnby5wdXNoKHtuYW1lOiAnYmF6J30pO1xuICogY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmF6Jyk7XG4gKi9cbmZ1bmN0aW9uIGNhcmdvJDEod29ya2VyLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHF1ZXVlJDEod29ya2VyLCAxLCBwYXlsb2FkKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYGNhcmdvUXVldWVgIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBjYXJnb1F1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KSBpbiBgY29uY3VycmVuY3lgIHBhcmFsbGVsIHdvcmtlcnMuXG4gKiBJZiB0aGUgYWxsIGB3b3JrZXJzYCBhcmUgaW4gcHJvZ3Jlc3MsIHRoZSB0YXNrIGlzIHF1ZXVlZCB1bnRpbCBvbmUgYmVjb21lcyBhdmFpbGFibGUuIE9uY2VcbiAqIGEgYHdvcmtlcmAgaGFzIGNvbXBsZXRlZCBzb21lIHRhc2tzLCBlYWNoIGNhbGxiYWNrIG9mIHRob3NlIHRhc2tzIGlzXG4gKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NilcbiAqIGZvciBob3cgYGNhcmdvYCBhbmQgYHF1ZXVlYCB3b3JrLlxuICpcbiAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnNcbiAqIGF0IGEgdGltZSwgYW5kIFtgY2FyZ29gXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuY2FyZ299IHBhc3NlcyBhbiBhcnJheSBvZiB0YXNrcyB0byBhIHNpbmdsZSB3b3JrZXIsXG4gKiB0aGUgY2FyZ29RdWV1ZSBwYXNzZXMgYW4gYXJyYXkgb2YgdGFza3MgdG8gbXVsdGlwbGUgcGFyYWxsZWwgd29ya2Vycy5cbiAqXG4gKiBAbmFtZSBjYXJnb1F1ZXVlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfVxuICogQHNlZSBbYXN5bmMuY2FyZ29de0BsaW5rIG1vZHVsZTpDb250cm9sRkxvdy5jYXJnb31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGFuIGFycmF5XG4gKiBvZiBxdWV1ZWQgdGFza3MuIEludm9rZWQgd2l0aCBgKHRhc2tzLCBjYWxsYmFjaylgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW5jeT0xXSAtIEFuIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnlcbiAqIGB3b3JrZXJgIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5XG4gKiBkZWZhdWx0cyB0byBgMWAuICBJZiB0aGUgY29uY3VycmVuY3kgaXMgYDBgLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcGFyYW0ge251bWJlcn0gW3BheWxvYWQ9SW5maW5pdHldIC0gQW4gb3B0aW9uYWwgYGludGVnZXJgIGZvciBkZXRlcm1pbmluZ1xuICogaG93IG1hbnkgdGFza3Mgc2hvdWxkIGJlIHByb2Nlc3NlZCBwZXIgcm91bmQ7IGlmIG9taXR0ZWQsIHRoZSBkZWZhdWx0IGlzXG4gKiB1bmxpbWl0ZWQuXG4gKiBAcmV0dXJucyB7bW9kdWxlOkNvbnRyb2xGbG93LlF1ZXVlT2JqZWN0fSBBIGNhcmdvUXVldWUgb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvUXVldWUgYW5kIGlubmVyIHF1ZXVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBjcmVhdGUgYSBjYXJnb1F1ZXVlIG9iamVjdCB3aXRoIHBheWxvYWQgMiBhbmQgY29uY3VycmVuY3kgMlxuICogdmFyIGNhcmdvUXVldWUgPSBhc3luYy5jYXJnb1F1ZXVlKGZ1bmN0aW9uKHRhc2tzLCBjYWxsYmFjaykge1xuICogICAgIGZvciAodmFyIGk9MDsgaTx0YXNrcy5sZW5ndGg7IGkrKykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaGVsbG8gJyArIHRhc2tzW2ldLm5hbWUpO1xuICogICAgIH1cbiAqICAgICBjYWxsYmFjaygpO1xuICogfSwgMiwgMik7XG4gKlxuICogLy8gYWRkIHNvbWUgaXRlbXNcbiAqIGNhcmdvUXVldWUucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBmb28nKTtcbiAqIH0pO1xuICogY2FyZ29RdWV1ZS5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKiBjYXJnb1F1ZXVlLnB1c2goe25hbWU6ICdiYXonfSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmF6Jyk7XG4gKiB9KTtcbiAqIGNhcmdvUXVldWUucHVzaCh7bmFtZTogJ2Jvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBib28nKTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjYXJnbyh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHF1ZXVlJDEod29ya2VyLCBjb25jdXJyZW5jeSwgcGF5bG9hZCk7XG59XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGAgaW50byBhIHNpbmdsZSB2YWx1ZSB1c2luZyBhbiBhc3luYyBgaXRlcmF0ZWVgIHRvIHJldHVybiBlYWNoXG4gKiBzdWNjZXNzaXZlIHN0ZXAuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBvbmx5IG9wZXJhdGVzIGluIHNlcmllcy5cbiAqXG4gKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgbWF5IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb25cbiAqIGludG8gYSBwYXJhbGxlbCBtYXAsIGFuZCB0aGVuIHVzZSB0aGUgbm9ybWFsIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBvbiB0aGVcbiAqIHJlc3VsdHMuIFRoaXMgZnVuY3Rpb24gaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmUgZWFjaCBzdGVwIGluIHRoZSByZWR1Y3Rpb25cbiAqIG5lZWRzIHRvIGJlIGFzeW5jOyBpZiB5b3UgY2FuIGdldCB0aGUgZGF0YSBiZWZvcmUgcmVkdWNpbmcgaXQsIHRoZW4gaXQnc1xuICogcHJvYmFibHkgYSBnb29kIGlkZWEgdG8gZG8gc28uXG4gKlxuICogQG5hbWUgcmVkdWNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgaW5qZWN0XG4gKiBAYWxpYXMgZm9sZGxcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Kn0gbWVtbyAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggaXRlbSBpbiB0aGVcbiAqIGFycmF5IHRvIHByb2R1Y2UgdGhlIG5leHQgc3RlcCBpbiB0aGUgcmVkdWN0aW9uLlxuICogVGhlIGBpdGVyYXRlZWAgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIG5leHQgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAqIElmIHRoZSBpdGVyYXRlZSBjb21wbGV0ZXMgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBJbnZva2VkIHdpdGggKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlNC50eHQgZG9lcyBub3QgZXhpc3RcbiAqXG4gKiBjb25zdCBmaWxlTGlzdCA9IFsnZmlsZTEudHh0JywnZmlsZTIudHh0JywnZmlsZTMudHh0J107XG4gKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlMy50eHQnLCAnZmlsZTQudHh0J107XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlIGZpbGUgc2l6ZSBpbiBieXRlc1xuICogLy8gZmlsZSBzaXplIGlzIGFkZGVkIHRvIHRoZSBtZW1vaXplZCB2YWx1ZSwgdGhlbiByZXR1cm5lZFxuICogZnVuY3Rpb24gZ2V0RmlsZVNpemVJbkJ5dGVzKG1lbW8sIGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVtbyArIHN0YXQuc2l6ZSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5yZWR1Y2UoZmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcywgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8gNjAwMFxuICogICAgICAgICAvLyB3aGljaCBpcyB0aGUgc3VtIG9mIHRoZSBmaWxlIHNpemVzIG9mIHRoZSB0aHJlZSBmaWxlc1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYy5yZWR1Y2Uod2l0aE1pc3NpbmdGaWxlTGlzdCwgMCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5yZWR1Y2UoZmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHQgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gNjAwMFxuICogICAgIC8vIHdoaWNoIGlzIHRoZSBzdW0gb2YgdGhlIGZpbGUgc2l6ZXMgb2YgdGhlIHRocmVlIGZpbGVzXG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLnJlZHVjZSh3aXRoTWlzc2luZ0ZpbGVMaXN0LCAwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMucmVkdWNlKGZpbGVMaXN0LCAwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyA2MDAwXG4gKiAgICAgICAgIC8vIHdoaWNoIGlzIHRoZSBzdW0gb2YgdGhlIGZpbGUgc2l6ZXMgb2YgdGhlIHRocmVlIGZpbGVzXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMucmVkdWNlKHdpdGhNaXNzaW5nRmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICByZXR1cm4gZWFjaE9mU2VyaWVzJDEoY29sbCwgKHgsIGksIGl0ZXJDYikgPT4ge1xuICAgICAgICBfaXRlcmF0ZWUobWVtbywgeCwgKGVyciwgdikgPT4ge1xuICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICBpdGVyQ2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgbWVtbykpO1xufVxudmFyIHJlZHVjZSQxID0gYXdhaXRpZnkocmVkdWNlLCA0KTtcblxuLyoqXG4gKiBWZXJzaW9uIG9mIHRoZSBjb21wb3NlIGZ1bmN0aW9uIHRoYXQgaXMgbW9yZSBuYXR1cmFsIHRvIHJlYWQuIEVhY2ggZnVuY3Rpb25cbiAqIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzIGZ1bmN0aW9uLiBJdCBpcyB0aGUgZXF1aXZhbGVudCBvZlxuICogW2NvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfSB3aXRoIHRoZSBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gKlxuICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gKlxuICogQG5hbWUgc2VxXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb21wb3NlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuY29tcG9zZX1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7Li4uQXN5bmNGdW5jdGlvbn0gZnVuY3Rpb25zIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgY29tcG9zZXMgdGhlIGBmdW5jdGlvbnNgIGluIG9yZGVyXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFJlcXVpcmVzIGxvZGFzaCAob3IgdW5kZXJzY29yZSksIGV4cHJlc3MzIGFuZCBkcmVzZW5kZSdzIG9ybTIuXG4gKiAvLyBQYXJ0IG9mIGFuIGFwcCwgdGhhdCBmZXRjaGVzIGNhdHMgb2YgdGhlIGxvZ2dlZCB1c2VyLlxuICogLy8gVGhpcyBleGFtcGxlIHVzZXMgYHNlcWAgZnVuY3Rpb24gdG8gYXZvaWQgb3Zlcm5lc3RpbmcgYW5kIGVycm9yXG4gKiAvLyBoYW5kbGluZyBjbHV0dGVyLlxuICogYXBwLmdldCgnL2NhdHMnLCBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSkge1xuICogICAgIHZhciBVc2VyID0gcmVxdWVzdC5tb2RlbHMuVXNlcjtcbiAqICAgICBhc3luYy5zZXEoXG4gKiAgICAgICAgIFVzZXIuZ2V0LmJpbmQoVXNlciksICAvLyAnVXNlci5nZXQnIGhhcyBzaWduYXR1cmUgKGlkLCBjYWxsYmFjayhlcnIsIGRhdGEpKVxuICogICAgICAgICBmdW5jdGlvbih1c2VyLCBmbikge1xuICogICAgICAgICAgICAgdXNlci5nZXRDYXRzKGZuKTsgICAgICAvLyAnZ2V0Q2F0cycgaGFzIHNpZ25hdHVyZSAoY2FsbGJhY2soZXJyLCBkYXRhKSlcbiAqICAgICAgICAgfVxuICogICAgICkocmVxLnNlc3Npb24udXNlcl9pZCwgZnVuY3Rpb24gKGVyciwgY2F0cykge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gKiAgICAgICAgICAgICByZXNwb25zZS5qc29uKHsgc3RhdHVzOiAnZXJyb3InLCBtZXNzYWdlOiBlcnIubWVzc2FnZSB9KTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdvaycsIG1lc3NhZ2U6ICdDYXRzIGZvdW5kJywgZGF0YTogY2F0cyB9KTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHNlcSguLi5mdW5jdGlvbnMpIHtcbiAgICB2YXIgX2Z1bmN0aW9ucyA9IGZ1bmN0aW9ucy5tYXAod3JhcEFzeW5jKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2IgPSBwcm9taXNlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZHVjZSQxKF9mdW5jdGlvbnMsIGFyZ3MsIChuZXdhcmdzLCBmbiwgaXRlckNiKSA9PiB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdCgoZXJyLCAuLi5uZXh0YXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZXJDYihlcnIsIG5leHRhcmdzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVyciwgcmVzdWx0cykgPT4gY2IoZXJyLCAuLi5yZXN1bHRzKSk7XG5cbiAgICAgICAgcmV0dXJuIGNiW1BST01JU0VfU1lNQk9MXVxuICAgIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGlzIGEgY29tcG9zaXRpb24gb2YgdGhlIHBhc3NlZCBhc3luY2hyb25vdXNcbiAqIGZ1bmN0aW9ucy4gRWFjaCBmdW5jdGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0XG4gKiBmb2xsb3dzLiBDb21wb3NpbmcgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHdvdWxkIHByb2R1Y2UgdGhlIHJlc3VsdFxuICogb2YgYGYoZyhoKCkpKWAsIG9ubHkgdGhpcyB2ZXJzaW9uIHVzZXMgY2FsbGJhY2tzIHRvIG9idGFpbiB0aGUgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBJZiB0aGUgbGFzdCBhcmd1bWVudCB0byB0aGUgY29tcG9zZWQgZnVuY3Rpb24gaXMgbm90IGEgZnVuY3Rpb24sIGEgcHJvbWlzZVxuICogaXMgcmV0dXJuZWQgd2hlbiB5b3UgY2FsbCBpdC5cbiAqXG4gKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAqXG4gKiBAbmFtZSBjb21wb3NlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0gey4uLkFzeW5jRnVuY3Rpb259IGZ1bmN0aW9ucyAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2VkXG4gKiBhc3luY2hyb25vdXMgYGZ1bmN0aW9uc2BcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gYWRkMShuLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICsgMSk7XG4gKiAgICAgfSwgMTApO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIG11bDMobiwgY2FsbGJhY2spIHtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbiAqIDMpO1xuICogICAgIH0sIDEwKTtcbiAqIH1cbiAqXG4gKiB2YXIgYWRkMW11bDMgPSBhc3luYy5jb21wb3NlKG11bDMsIGFkZDEpO1xuICogYWRkMW11bDMoNCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgMTVcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjb21wb3NlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VxKC4uLmFyZ3MucmV2ZXJzZSgpKTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gbWFwTGltaXQgKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2FzeW5jTWFwKGVhY2hPZkxpbWl0JDIobGltaXQpLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgbWFwTGltaXQkMSA9IGF3YWl0aWZ5KG1hcExpbWl0LCA0KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGNvbmNhdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGNvbmNhdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQGFsaWFzIGZsYXRNYXBMaW1pdFxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLFxuICogd2hpY2ggc2hvdWxkIHVzZSBhbiBhcnJheSBhcyBpdHMgcmVzdWx0LiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMgQSBQcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gY29uY2F0TGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHJldHVybiBtYXBMaW1pdCQxKGNvbGwsIGxpbWl0LCAodmFsLCBpdGVyQ2IpID0+IHtcbiAgICAgICAgX2l0ZXJhdGVlKHZhbCwgKGVyciwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJDYihlcnIsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9LCAoZXJyLCBtYXBSZXN1bHRzKSA9PiB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBSZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWFwUmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoLi4ubWFwUmVzdWx0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgIH0pO1xufVxudmFyIGNvbmNhdExpbWl0JDEgPSBhd2FpdGlmeShjb25jYXRMaW1pdCwgNCk7XG5cbi8qKlxuICogQXBwbGllcyBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsIGNvbmNhdGVuYXRpbmcgdGhlIHJlc3VsdHMuIFJldHVybnNcbiAqIHRoZSBjb25jYXRlbmF0ZWQgbGlzdC4gVGhlIGBpdGVyYXRlZWBzIGFyZSBjYWxsZWQgaW4gcGFyYWxsZWwsIGFuZCB0aGVcbiAqIHJlc3VsdHMgYXJlIGNvbmNhdGVuYXRlZCBhcyB0aGV5IHJldHVybi4gVGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSByZXR1cm5lZCBpblxuICogdGhlIG9yaWdpbmFsIG9yZGVyIG9mIGBjb2xsYCBwYXNzZWQgdG8gdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uXG4gKlxuICogQG5hbWUgY29uY2F0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQGFsaWFzIGZsYXRNYXBcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCxcbiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gKiAvLyBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogbGV0IGRpcmVjdG9yeUxpc3QgPSBbJ2RpcjEnLCdkaXIyJywnZGlyMyddO1xuICogbGV0IHdpdGhNaXNzaW5nRGlyZWN0b3J5TGlzdCA9IFsnZGlyMScsJ2RpcjInLCdkaXIzJywgJ2RpcjQnXTtcbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLmNvbmNhdChkaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgIGlmIChlcnIpIHtcbiAqICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgfSBlbHNlIHtcbiAqICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAvLyBbICdmaWxlMS50eHQnLCAnZmlsZTIudHh0JywgJ2ZpbGUzLnR4dCcsICdmaWxlNC50eHQnLCBmaWxlNS50eHQgXVxuICogICAgfVxuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLmNvbmNhdCh3aXRoTWlzc2luZ0RpcmVjdG9yeUxpc3QsIGZzLnJlYWRkaXIsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgaWYgKGVycikge1xuICogICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAgICAvLyBzaW5jZSBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKiAgICB9IGVsc2Uge1xuICogICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmNvbmNhdChkaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyKVxuICogLnRoZW4ocmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gWyAnZmlsZTEudHh0JywgJ2ZpbGUyLnR4dCcsICdmaWxlMy50eHQnLCAnZmlsZTQudHh0JywgZmlsZTUudHh0IF1cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMuY29uY2F0KHdpdGhNaXNzaW5nRGlyZWN0b3J5TGlzdCwgZnMucmVhZGRpcilcbiAqIC50aGVuKHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgLy8gc2luY2UgZGlyNCBkb2VzIG5vdCBleGlzdFxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLmNvbmNhdChkaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIFsgJ2ZpbGUxLnR4dCcsICdmaWxlMi50eHQnLCAnZmlsZTMudHh0JywgJ2ZpbGU0LnR4dCcsIGZpbGU1LnR4dCBdXG4gKiAgICAgfSBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5jb25jYXQod2l0aE1pc3NpbmdEaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgfSBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgICAgIC8vIHNpbmNlIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBjb25jYXQoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGNvbmNhdExpbWl0JDEoY29sbCwgSW5maW5pdHksIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBjb25jYXQkMSA9IGF3YWl0aWZ5KGNvbmNhdCwgMyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bjb25jYXRgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgY29uY2F0U2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQGFsaWFzIGZsYXRNYXBTZXJpZXNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhbiBhcnJheSBhbiBhcnJheSBvZiByZXN1bHRzLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdFNlcmllcyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY29uY2F0TGltaXQkMShjb2xsLCAxLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgY29uY2F0U2VyaWVzJDEgPSBhd2FpdGlmeShjb25jYXRTZXJpZXMsIDMpO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gY2FsbGVkLCBjYWxscy1iYWNrIHdpdGggdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAqIFVzZWZ1bCBhcyB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gYSBbYHdhdGVyZmFsbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53YXRlcmZhbGx9LCBvciBmb3IgcGx1Z2dpbmcgdmFsdWVzIGluIHRvXG4gKiBbYGF1dG9gXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uXG4gKlxuICogQG5hbWUgY29uc3RhbnRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgaW52b2tlXG4gKiBjYWxsYmFjayB3aXRoLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gaW52b2tlZCwgYXV0b21hdGljYWxseVxuICogaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJldmlvdXMgZ2l2ZW4gYXJndW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmNvbnN0YW50KDQyKSxcbiAqICAgICBmdW5jdGlvbiAodmFsdWUsIG5leHQpIHtcbiAqICAgICAgICAgLy8gdmFsdWUgPT09IDQyXG4gKiAgICAgfSxcbiAqICAgICAvLy4uLlxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuY29uc3RhbnQoZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBmcy5yZWFkRmlsZSxcbiAqICAgICBmdW5jdGlvbiAoZmlsZURhdGEsIG5leHQpIHtcbiAqICAgICAgICAgLy8uLi5cbiAqICAgICB9XG4gKiAgICAgLy8uLi5cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiBhc3luYy5hdXRvKHtcbiAqICAgICBob3N0bmFtZTogYXN5bmMuY29uc3RhbnQoXCJodHRwczovL3NlcnZlci5uZXQvXCIpLFxuICogICAgIHBvcnQ6IGZpbmRGcmVlUG9ydCxcbiAqICAgICBsYXVuY2hTZXJ2ZXI6IFtcImhvc3RuYW1lXCIsIFwicG9ydFwiLCBmdW5jdGlvbiAob3B0aW9ucywgY2IpIHtcbiAqICAgICAgICAgc3RhcnRTZXJ2ZXIob3B0aW9ucywgY2IpO1xuICogICAgIH1dLFxuICogICAgIC8vLi4uXG4gKiB9LCBjYWxsYmFjayk7XG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50JDEoLi4uYXJncykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uaWdub3JlZEFyZ3MvKiwgY2FsbGJhY2sqLykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBpZ25vcmVkQXJncy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVUZXN0ZXIoY2hlY2ssIGdldFJlc3VsdCkge1xuICAgIHJldHVybiAoZWFjaGZuLCBhcnIsIF9pdGVyYXRlZSwgY2IpID0+IHtcbiAgICAgICAgdmFyIHRlc3RQYXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRlc3RSZXN1bHQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGVlID0gd3JhcEFzeW5jKF9pdGVyYXRlZSk7XG4gICAgICAgIGVhY2hmbihhcnIsICh2YWx1ZSwgXywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIHx8IGVyciA9PT0gZmFsc2UpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrKHJlc3VsdCkgJiYgIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdFBhc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RSZXN1bHQgPSBnZXRSZXN1bHQodHJ1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYnJlYWtMb29wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICBjYihudWxsLCB0ZXN0UGFzc2VkID8gdGVzdFJlc3VsdCA6IGdldFJlc3VsdChmYWxzZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIGBjb2xsYCB0aGF0IHBhc3NlcyBhbiBhc3luYyB0cnV0aCB0ZXN0LiBUaGVcbiAqIGBpdGVyYXRlZWAgaXMgYXBwbGllZCBpbiBwYXJhbGxlbCwgbWVhbmluZyB0aGUgZmlyc3QgaXRlcmF0ZWUgdG8gcmV0dXJuXG4gKiBgdHJ1ZWAgd2lsbCBmaXJlIHRoZSBkZXRlY3QgYGNhbGxiYWNrYCB3aXRoIHRoYXQgcmVzdWx0LiBUaGF0IG1lYW5zIHRoZVxuICogcmVzdWx0IG1pZ2h0IG5vdCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgb3JpZ2luYWwgYGNvbGxgIChpbiB0ZXJtcyBvZiBvcmRlcilcbiAqIHRoYXQgcGFzc2VzIHRoZSB0ZXN0LlxuXG4gKiBJZiBvcmRlciB3aXRoaW4gdGhlIG9yaWdpbmFsIGBjb2xsYCBpcyBpbXBvcnRhbnQsIHRoZW4gbG9vayBhdFxuICogW2BkZXRlY3RTZXJpZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0U2VyaWVzfS5cbiAqXG4gKiBAbmFtZSBkZXRlY3RcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmaW5kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAqIGZ1bmN0aW9uIGZpbGVFeGlzdHMoZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgIGZzLmFjY2VzcyhmaWxlLCBmcy5jb25zdGFudHMuRl9PSywgKGVycikgPT4ge1xuICogICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpO1xuICogICAgfSk7XG4gKiB9XG4gKlxuICogYXN5bmMuZGV0ZWN0KFsnZmlsZTMudHh0JywnZmlsZTIudHh0JywnZGlyMS9maWxlMS50eHQnXSwgZmlsZUV4aXN0cyxcbiAqICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAvLyBkaXIxL2ZpbGUxLnR4dFxuICogICAgICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzIHRoZSBmaXJzdCBmaWxlIGluIHRoZSBsaXN0IHRoYXQgZXhpc3RzXG4gKiAgICB9XG4gKik7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmRldGVjdChbJ2ZpbGUzLnR4dCcsJ2ZpbGUyLnR4dCcsJ2RpcjEvZmlsZTEudHh0J10sIGZpbGVFeGlzdHMpXG4gKiAudGhlbihyZXN1bHQgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gZGlyMS9maWxlMS50eHRcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyB0aGUgZmlyc3QgZmlsZSBpbiB0aGUgbGlzdCB0aGF0IGV4aXN0c1xuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZGV0ZWN0KFsnZmlsZTMudHh0JywnZmlsZTIudHh0JywnZGlyMS9maWxlMS50eHQnXSwgZmlsZUV4aXN0cyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIGRpcjEvZmlsZTEudHh0XG4gKiAgICAgICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzIHRoZSBmaWxlIGluIHRoZSBsaXN0IHRoYXQgZXhpc3RzXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBkZXRlY3QoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoYm9vbCA9PiBib29sLCAocmVzLCBpdGVtKSA9PiBpdGVtKShlYWNoT2YkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGRldGVjdCQxID0gYXdhaXRpZnkoZGV0ZWN0LCAzKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSBkZXRlY3RMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZGV0ZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fVxuICogQGFsaWFzIGZpbmRMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdFxuICogKGl0ZXJhdGVlKSBvciB0aGUgdmFsdWUgYHVuZGVmaW5lZGAgaWYgbm9uZSBwYXNzZWQuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICovXG5mdW5jdGlvbiBkZXRlY3RMaW1pdChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoYm9vbCA9PiBib29sLCAocmVzLCBpdGVtKSA9PiBpdGVtKShlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGRldGVjdExpbWl0JDEgPSBhd2FpdGlmeShkZXRlY3RMaW1pdCwgNCk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZGV0ZWN0U2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kZXRlY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9XG4gKiBAYWxpYXMgZmluZFNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdFxuICogKGl0ZXJhdGVlKSBvciB0aGUgdmFsdWUgYHVuZGVmaW5lZGAgaWYgbm9uZSBwYXNzZWQuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICovXG5mdW5jdGlvbiBkZXRlY3RTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoYm9vbCA9PiBib29sLCAocmVzLCBpdGVtKSA9PiBpdGVtKShlYWNoT2ZMaW1pdCQyKDEpLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG5cbnZhciBkZXRlY3RTZXJpZXMkMSA9IGF3YWl0aWZ5KGRldGVjdFNlcmllcywgMyk7XG5cbmZ1bmN0aW9uIGNvbnNvbGVGdW5jKG5hbWUpIHtcbiAgICByZXR1cm4gKGZuLCAuLi5hcmdzKSA9PiB3cmFwQXN5bmMoZm4pKC4uLmFyZ3MsIChlcnIsIC4uLnJlc3VsdEFyZ3MpID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICByZXN1bHRBcmdzLmZvckVhY2goeCA9PiBjb25zb2xlW25hbWVdKHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG59XG5cbi8qKlxuICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIFtgYXN5bmNgIGZ1bmN0aW9uXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byB0aGVcbiAqIGBjb25zb2xlYCB1c2luZyBgY29uc29sZS5kaXJgIHRvIGRpc3BsYXkgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBPbmx5IHdvcmtzIGluIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmRpcmAgYW5kXG4gKiBgY29uc29sZS5lcnJvcmAgKHN1Y2ggYXMgRkYgYW5kIENocm9tZSkuXG4gKiBJZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHJldHVybmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9uLFxuICogYGNvbnNvbGUuZGlyYCBpcyBjYWxsZWQgb24gZWFjaCBhcmd1bWVudCBpbiBvcmRlci5cbiAqXG4gKiBAbmFtZSBkaXJcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHlcbiAqIGFsbCBhcmd1bWVudHMgdG8uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gaW4gYSBtb2R1bGVcbiAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwge2hlbGxvOiBuYW1lfSk7XG4gKiAgICAgfSwgMTAwMCk7XG4gKiB9O1xuICpcbiAqIC8vIGluIHRoZSBub2RlIHJlcGxcbiAqIG5vZGU+IGFzeW5jLmRpcihoZWxsbywgJ3dvcmxkJyk7XG4gKiB7aGVsbG86ICd3b3JsZCd9XG4gKi9cbnZhciBkaXIgPSBjb25zb2xlRnVuYygnZGlyJyk7XG5cbi8qKlxuICogVGhlIHBvc3QtY2hlY2sgdmVyc2lvbiBvZiBbYHdoaWxzdGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9LiBUbyByZWZsZWN0IHRoZSBkaWZmZXJlbmNlIGluXG4gKiB0aGUgb3JkZXIgb2Ygb3BlcmF0aW9ucywgdGhlIGFyZ3VtZW50cyBgdGVzdGAgYW5kIGBpdGVyYXRlZWAgYXJlIHN3aXRjaGVkLlxuICpcbiAqIGBkb1doaWxzdGAgaXMgdG8gYHdoaWxzdGAgYXMgYGRvIHdoaWxlYCBpcyB0byBgd2hpbGVgIGluIHBsYWluIEphdmFTY3JpcHQuXG4gKlxuICogQG5hbWUgZG9XaGlsc3RcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUgYHRlc3RgXG4gKiBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0ZXN0IC0gYXN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBhZnRlciBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoICguLi5hcmdzLCBjYWxsYmFjayksIHdoZXJlIGAuLi5hcmdzYCBhcmUgdGhlXG4gKiBub24tZXJyb3IgYXJncyBmcm9tIHRoZSBwcmV2aW91cyBjYWxsYmFjayBvZiBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC5cbiAqIGBjYWxsYmFja2Agd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbFxuICogYGl0ZXJhdGVlYCdzIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBkb1doaWxzdChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrKTtcbiAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICB2YXIgX3Rlc3QgPSB3cmFwQXN5bmModGVzdCk7XG4gICAgdmFyIHJlc3VsdHM7XG5cbiAgICBmdW5jdGlvbiBuZXh0KGVyciwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgcmVzdWx0cyA9IGFyZ3M7XG4gICAgICAgIF90ZXN0KC4uLmFyZ3MsIGNoZWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVjayhlcnIsIHRydXRoKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBpZiAoIXRydXRoKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgLi4ucmVzdWx0cyk7XG4gICAgICAgIF9mbihuZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hlY2sobnVsbCwgdHJ1ZSk7XG59XG5cbnZhciBkb1doaWxzdCQxID0gYXdhaXRpZnkoZG9XaGlsc3QsIDMpO1xuXG4vKipcbiAqIExpa2UgWydkb1doaWxzdCdde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kb1doaWxzdH0sIGV4Y2VwdCB0aGUgYHRlc3RgIGlzIGludmVydGVkLiBOb3RlIHRoZVxuICogYXJndW1lbnQgb3JkZXJpbmcgZGlmZmVycyBmcm9tIGB1bnRpbGAuXG4gKlxuICogQG5hbWUgZG9VbnRpbFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZG9XaGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kb1doaWxzdH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lXG4gKiBgdGVzdGAgZmFpbHMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0ZXN0IC0gYXN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBhZnRlciBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoICguLi5hcmdzLCBjYWxsYmFjayksIHdoZXJlIGAuLi5hcmdzYCBhcmUgdGhlXG4gKiBub24tZXJyb3IgYXJncyBmcm9tIHRoZSBwcmV2aW91cyBjYWxsYmFjayBvZiBgaXRlcmF0ZWVgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBwYXNzZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgXG4gKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsIGBpdGVyYXRlZWAnc1xuICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pO1xuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGRvVW50aWwoaXRlcmF0ZWUsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgX3Rlc3QgPSB3cmFwQXN5bmModGVzdCk7XG4gICAgcmV0dXJuIGRvV2hpbHN0JDEoaXRlcmF0ZWUsICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGNiID0gYXJncy5wb3AoKTtcbiAgICAgICAgX3Rlc3QoLi4uYXJncywgKGVyciwgdHJ1dGgpID0+IGNiIChlcnIsICF0cnV0aCkpO1xuICAgIH0sIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gX3dpdGhvdXRJbmRleChpdGVyYXRlZSkge1xuICAgIHJldHVybiAodmFsdWUsIGluZGV4LCBjYWxsYmFjaykgPT4gaXRlcmF0ZWUodmFsdWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBmdW5jdGlvbiBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsIGluIHBhcmFsbGVsLlxuICogVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggYW4gaXRlbSBmcm9tIHRoZSBsaXN0LCBhbmQgYSBjYWxsYmFjayBmb3Igd2hlblxuICogaXQgaGFzIGZpbmlzaGVkLiBJZiB0aGUgYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGBjYWxsYmFja2AsIHRoZVxuICogbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBlYWNoYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiBlcnJvci5cbiAqXG4gKiBOb3RlLCB0aGF0IHNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBwYXJhbGxlbCxcbiAqIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci5cbiAqXG4gKiBAbmFtZSBlYWNoXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgZm9yRWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvXG4gKiBlYWNoIGl0ZW0gaW4gYGNvbGxgLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBkaXIxIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTEudHh0LCBmaWxlMi50eHRcbiAqIC8vIGRpcjIgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMy50eHQsIGZpbGU0LnR4dFxuICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICogLy8gZGlyNCBkb2VzIG5vdCBleGlzdFxuICpcbiAqIGNvbnN0IGZpbGVMaXN0ID0gWyAnZGlyMS9maWxlMi50eHQnLCAnZGlyMi9maWxlMy50eHQnLCAnZGlyL2ZpbGU1LnR4dCddO1xuICogY29uc3Qgd2l0aE1pc3NpbmdGaWxlTGlzdCA9IFsnZGlyMS9maWxlMS50eHQnLCAnZGlyNC9maWxlMi50eHQnXTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBkZWxldGVzIGEgZmlsZVxuICogY29uc3QgZGVsZXRlRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMudW5saW5rKGZpbGUsIGNhbGxiYWNrKTtcbiAqIH07XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5lYWNoKGZpbGVMaXN0LCBkZWxldGVGaWxlLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBpZiggZXJyICkge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLmVhY2god2l0aE1pc3NpbmdGaWxlTGlzdCwgZGVsZXRlRmlsZSwgZnVuY3Rpb24oZXJyKXtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgLy8gc2luY2UgZGlyNC9maWxlMi50eHQgZG9lcyBub3QgZXhpc3RcbiAqICAgICAvLyBkaXIxL2ZpbGUxLnR4dCBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZFxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmVhY2goZmlsZUxpc3QsIGRlbGV0ZUZpbGUpXG4gKiAudGhlbiggKCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLmVhY2goZmlsZUxpc3QsIGRlbGV0ZUZpbGUpXG4gKiAudGhlbiggKCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgLy8gc2luY2UgZGlyNC9maWxlMi50eHQgZG9lcyBub3QgZXhpc3RcbiAqICAgICAvLyBkaXIxL2ZpbGUxLnR4dCBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZFxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBhd2FpdCBhc3luYy5lYWNoKGZpbGVzLCBkZWxldGVGaWxlKTtcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGF3YWl0IGFzeW5jLmVhY2god2l0aE1pc3NpbmdGaWxlTGlzdCwgZGVsZXRlRmlsZSk7XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAgICAgLy8gc2luY2UgZGlyNC9maWxlMi50eHQgZG9lcyBub3QgZXhpc3RcbiAqICAgICAgICAgLy8gZGlyMS9maWxlMS50eHQgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWRcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBlYWNoTGltaXQkMihjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZWFjaE9mJDEoY29sbCwgX3dpdGhvdXRJbmRleCh3cmFwQXN5bmMoaXRlcmF0ZWUpKSwgY2FsbGJhY2spO1xufVxuXG52YXIgZWFjaCA9IGF3YWl0aWZ5KGVhY2hMaW1pdCQyLCAzKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBhbGlhcyBmb3JFYWNoTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZMaW1pdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqL1xuZnVuY3Rpb24gZWFjaExpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZWFjaE9mTGltaXQkMihsaW1pdCkoY29sbCwgX3dpdGhvdXRJbmRleCh3cmFwQXN5bmMoaXRlcmF0ZWUpKSwgY2FsbGJhY2spO1xufVxudmFyIGVhY2hMaW1pdCQxID0gYXdhaXRpZnkoZWFjaExpbWl0LCA0KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIE5vdGUsIHRoYXQgdW5saWtlIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSwgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIGl0ZXJhdGVlIHRvIGVhY2ggaXRlbVxuICogaW4gc2VyaWVzIGFuZCB0aGVyZWZvcmUgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlIGluIG9yZGVyLlxuXG4gKiBAbmFtZSBlYWNoU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBhbGlhcyBmb3JFYWNoU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgYXJyYXkgaW5kZXggaXMgbm90IHBhc3NlZCB0byB0aGUgaXRlcmF0ZWUuXG4gKiBJZiB5b3UgbmVlZCB0aGUgaW5kZXgsIHVzZSBgZWFjaE9mU2VyaWVzYC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICovXG5mdW5jdGlvbiBlYWNoU2VyaWVzKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBlYWNoTGltaXQkMShjb2xsLCAxLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZWFjaFNlcmllcyQxID0gYXdhaXRpZnkoZWFjaFNlcmllcywgMyk7XG5cbi8qKlxuICogV3JhcCBhbiBhc3luYyBmdW5jdGlvbiBhbmQgZW5zdXJlIGl0IGNhbGxzIGl0cyBjYWxsYmFjayBvbiBhIGxhdGVyIHRpY2sgb2ZcbiAqIHRoZSBldmVudCBsb29wLiAgSWYgdGhlIGZ1bmN0aW9uIGFscmVhZHkgY2FsbHMgaXRzIGNhbGxiYWNrIG9uIGEgbmV4dCB0aWNrLFxuICogbm8gZXh0cmEgZGVmZXJyYWwgaXMgYWRkZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBwcmV2ZW50aW5nIHN0YWNrIG92ZXJmbG93c1xuICogKGBSYW5nZUVycm9yOiBNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZGApIGFuZCBnZW5lcmFsbHkga2VlcGluZ1xuICogW1phbGdvXShodHRwOi8vYmxvZy5penMubWUvcG9zdC81OTE0Mjc0MjE0My9kZXNpZ25pbmctYXBpcy1mb3ItYXN5bmNocm9ueSlcbiAqIGNvbnRhaW5lZC4gRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25zIGFyZSByZXR1cm5lZCBhcy1pcyAtLSB0aGV5IGFyZSBpbW11bmVcbiAqIHRvIFphbGdvJ3MgY29ycnVwdGluZyBpbmZsdWVuY2VzLCBhcyB0aGV5IGFsd2F5cyByZXNvbHZlIG9uIGEgbGF0ZXIgdGljay5cbiAqXG4gKiBAbmFtZSBlbnN1cmVBc3luY1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBhbiBhc3luYyBmdW5jdGlvbiwgb25lIHRoYXQgZXhwZWN0cyBhIG5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrIGFzIGl0cyBsYXN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSB3cmFwcGVkIGZ1bmN0aW9uIHdpdGggdGhlIGV4YWN0IHNhbWUgY2FsbFxuICogc2lnbmF0dXJlIGFzIHRoZSBmdW5jdGlvbiBwYXNzZWQgaW4uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNvbWV0aW1lc0FzeW5jKGFyZywgY2FsbGJhY2spIHtcbiAqICAgICBpZiAoY2FjaGVbYXJnXSkge1xuICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY2FjaGVbYXJnXSk7IC8vIHRoaXMgd291bGQgYmUgc3luY2hyb25vdXMhIVxuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGRvU29tZUlPKGFyZywgY2FsbGJhY2spOyAvLyB0aGlzIElPIHdvdWxkIGJlIGFzeW5jaHJvbm91c1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiAvLyB0aGlzIGhhcyBhIHJpc2sgb2Ygc3RhY2sgb3ZlcmZsb3dzIGlmIG1hbnkgcmVzdWx0cyBhcmUgY2FjaGVkIGluIGEgcm93XG4gKiBhc3luYy5tYXBTZXJpZXMoYXJncywgc29tZXRpbWVzQXN5bmMsIGRvbmUpO1xuICpcbiAqIC8vIHRoaXMgd2lsbCBkZWZlciBzb21ldGltZXNBc3luYydzIGNhbGxiYWNrIGlmIG5lY2Vzc2FyeSxcbiAqIC8vIHByZXZlbnRpbmcgc3RhY2sgb3ZlcmZsb3dzXG4gKiBhc3luYy5tYXBTZXJpZXMoYXJncywgYXN5bmMuZW5zdXJlQXN5bmMoc29tZXRpbWVzQXN5bmMpLCBkb25lKTtcbiAqL1xuZnVuY3Rpb24gZW5zdXJlQXN5bmMoZm4pIHtcbiAgICBpZiAoaXNBc3luYyhmbikpIHJldHVybiBmbjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MvKiwgY2FsbGJhY2sqLykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgICAgIGFyZ3MucHVzaCgoLi4uaW5uZXJBcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKCgpID0+IGNhbGxiYWNrKC4uLmlubmVyQXJncykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayguLi5pbm5lckFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGV2ZXJ5IGVsZW1lbnQgaW4gYGNvbGxgIHNhdGlzZmllcyBhbiBhc3luYyB0ZXN0LiBJZiBhbnlcbiAqIGl0ZXJhdGVlIGNhbGwgcmV0dXJucyBgZmFsc2VgLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZC5cbiAqXG4gKiBAbmFtZSBldmVyeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGFsbFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gKiAvLyBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogY29uc3QgZmlsZUxpc3QgPSBbJ2RpcjEvZmlsZTEudHh0JywnZGlyMi9maWxlMy50eHQnLCdkaXIzL2ZpbGU1LnR4dCddO1xuICogY29uc3Qgd2l0aE1pc3NpbmdGaWxlTGlzdCA9IFsnZmlsZTEudHh0JywnZmlsZTIudHh0JywnZmlsZTQudHh0J107XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAqIGZ1bmN0aW9uIGZpbGVFeGlzdHMoZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgIGZzLmFjY2VzcyhmaWxlLCBmcy5jb25zdGFudHMuRl9PSywgKGVycikgPT4ge1xuICogICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpO1xuICogICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5ldmVyeShmaWxlTGlzdCwgZmlsZUV4aXN0cywgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIHRydWVcbiAqICAgICAvLyByZXN1bHQgaXMgdHJ1ZSBzaW5jZSBldmVyeSBmaWxlIGV4aXN0c1xuICogfSk7XG4gKlxuICogYXN5bmMuZXZlcnkod2l0aE1pc3NpbmdGaWxlTGlzdCwgZmlsZUV4aXN0cywgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIGZhbHNlXG4gKiAgICAgLy8gcmVzdWx0IGlzIGZhbHNlIHNpbmNlIE5PVCBldmVyeSBmaWxlIGV4aXN0c1xuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmV2ZXJ5KGZpbGVMaXN0LCBmaWxlRXhpc3RzKVxuICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyB0cnVlXG4gKiAgICAgLy8gcmVzdWx0IGlzIHRydWUgc2luY2UgZXZlcnkgZmlsZSBleGlzdHNcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiBhc3luYy5ldmVyeSh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBmaWxlRXhpc3RzKVxuICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyBmYWxzZVxuICogICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBOT1QgZXZlcnkgZmlsZSBleGlzdHNcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5ldmVyeShmaWxlTGlzdCwgZmlsZUV4aXN0cyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIHRydWVcbiAqICAgICAgICAgLy8gcmVzdWx0IGlzIHRydWUgc2luY2UgZXZlcnkgZmlsZSBleGlzdHNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLmV2ZXJ5KHdpdGhNaXNzaW5nRmlsZUxpc3QsIGZpbGVFeGlzdHMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyBmYWxzZVxuICogICAgICAgICAvLyByZXN1bHQgaXMgZmFsc2Ugc2luY2UgTk9UIGV2ZXJ5IGZpbGUgZXhpc3RzXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBldmVyeShjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+ICFib29sLCByZXMgPT4gIXJlcykoZWFjaE9mJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBldmVyeSQxID0gYXdhaXRpZnkoZXZlcnksIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZXZlcnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGV2ZXJ5TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9XG4gKiBAYWxpYXMgYWxsTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gcGFyYWxsZWwuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWBcbiAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYyB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICovXG5mdW5jdGlvbiBldmVyeUxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+ICFib29sLCByZXMgPT4gIXJlcykoZWFjaE9mTGltaXQkMihsaW1pdCksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBldmVyeUxpbWl0JDEgPSBhd2FpdGlmeShldmVyeUxpbWl0LCA0KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZXZlcnlTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9XG4gKiBAYWxpYXMgYWxsU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9uIGluIHNlcmllcy5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIGV2ZXJ5U2VyaWVzKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKGJvb2wgPT4gIWJvb2wsIHJlcyA9PiAhcmVzKShlYWNoT2ZTZXJpZXMkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGV2ZXJ5U2VyaWVzJDEgPSBhd2FpdGlmeShldmVyeVNlcmllcywgMyk7XG5cbmZ1bmN0aW9uIGZpbHRlckFycmF5KGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJ1dGhWYWx1ZXMgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgZWFjaGZuKGFyciwgKHgsIGluZGV4LCBpdGVyQ2IpID0+IHtcbiAgICAgICAgaXRlcmF0ZWUoeCwgKGVyciwgdikgPT4ge1xuICAgICAgICAgICAgdHJ1dGhWYWx1ZXNbaW5kZXhdID0gISF2O1xuICAgICAgICAgICAgaXRlckNiKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRydXRoVmFsdWVzW2ldKSByZXN1bHRzLnB1c2goYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyR2VuZXJpYyhlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZWFjaGZuKGNvbGwsICh4LCBpbmRleCwgaXRlckNiKSA9PiB7XG4gICAgICAgIGl0ZXJhdGVlKHgsIChlcnIsIHYpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBpdGVyQ2IoZXJyKTtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtpbmRleCwgdmFsdWU6IHh9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXJDYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0c1xuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KVxuICAgICAgICAgICAgLm1hcCh2ID0+IHYudmFsdWUpKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2ZpbHRlcihlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWx0ZXIgPSBpc0FycmF5TGlrZShjb2xsKSA/IGZpbHRlckFycmF5IDogZmlsdGVyR2VuZXJpYztcbiAgICByZXR1cm4gZmlsdGVyKGVhY2hmbiwgY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYXJyYXkgb2YgYWxsIHRoZSB2YWx1ZXMgaW4gYGNvbGxgIHdoaWNoIHBhc3MgYW4gYXN5bmMgdHJ1dGhcbiAqIHRlc3QuIFRoaXMgb3BlcmF0aW9uIGlzIHBlcmZvcm1lZCBpbiBwYXJhbGxlbCwgYnV0IHRoZSByZXN1bHRzIGFycmF5IHdpbGwgYmVcbiAqIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBvcmlnaW5hbC5cbiAqXG4gKiBAbmFtZSBmaWx0ZXJcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBzZWxlY3RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gKlxuICogY29uc3QgZmlsZXMgPSBbJ2RpcjEvZmlsZTEudHh0JywnZGlyMi9maWxlMy50eHQnLCdkaXIzL2ZpbGU2LnR4dCddO1xuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhIGZpbGUgZXhpc3RzXG4gKiBmdW5jdGlvbiBmaWxlRXhpc3RzKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICBmcy5hY2Nlc3MoZmlsZSwgZnMuY29uc3RhbnRzLkZfT0ssIChlcnIpID0+IHtcbiAqICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKTtcbiAqICAgIH0pO1xuICogfVxuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMuZmlsdGVyKGZpbGVzLCBmaWxlRXhpc3RzLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgIGlmKGVycikge1xuICogICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICB9IGVsc2Uge1xuICogICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgIC8vIFsgJ2RpcjEvZmlsZTEudHh0JywgJ2RpcjIvZmlsZTMudHh0JyBdXG4gKiAgICAgICAgLy8gcmVzdWx0cyBpcyBub3cgYW4gYXJyYXkgb2YgdGhlIGV4aXN0aW5nIGZpbGVzXG4gKiAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuZmlsdGVyKGZpbGVzLCBmaWxlRXhpc3RzKVxuICogLnRoZW4ocmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gWyAnZGlyMS9maWxlMS50eHQnLCAnZGlyMi9maWxlMy50eHQnIF1cbiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5maWx0ZXIoZmlsZXMsIGZpbGVFeGlzdHMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gWyAnZGlyMS9maWxlMS50eHQnLCAnZGlyMi9maWxlMy50eHQnIF1cbiAqICAgICAgICAgLy8gcmVzdWx0cyBpcyBub3cgYW4gYXJyYXkgb2YgdGhlIGV4aXN0aW5nIGZpbGVzXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBmaWx0ZXIgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfZmlsdGVyKGVhY2hPZiQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZmlsdGVyJDEgPSBhd2FpdGlmeShmaWx0ZXIsIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIGZpbHRlckxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9XG4gKiBAYWxpYXMgc2VsZWN0TGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckxpbWl0IChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9maWx0ZXIoZWFjaE9mTGltaXQkMihsaW1pdCksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBmaWx0ZXJMaW1pdCQxID0gYXdhaXRpZnkoZmlsdGVyTGltaXQsIDQpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGZpbHRlclNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGFsaWFzIHNlbGVjdFNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICovXG5mdW5jdGlvbiBmaWx0ZXJTZXJpZXMgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfZmlsdGVyKGVhY2hPZlNlcmllcyQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZmlsdGVyU2VyaWVzJDEgPSBhd2FpdGlmeShmaWx0ZXJTZXJpZXMsIDMpO1xuXG4vKipcbiAqIENhbGxzIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb24gYGZuYCB3aXRoIGEgY2FsbGJhY2sgcGFyYW1ldGVyIHRoYXQgYWxsb3dzIGl0XG4gKiB0byBjYWxsIGl0c2VsZiBhZ2FpbiwgaW4gc2VyaWVzLCBpbmRlZmluaXRlbHkuXG5cbiAqIElmIGFuIGVycm9yIGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgdGhlbiBgZXJyYmFja2AgaXMgY2FsbGVkIHdpdGggdGhlXG4gKiBlcnJvciwgYW5kIGV4ZWN1dGlvbiBzdG9wcywgb3RoZXJ3aXNlIGl0IHdpbGwgbmV2ZXIgYmUgY2FsbGVkLlxuICpcbiAqIEBuYW1lIGZvcmV2ZXJcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBhbiBhc3luYyBmdW5jdGlvbiB0byBjYWxsIHJlcGVhdGVkbHkuXG4gKiBJbnZva2VkIHdpdGggKG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2VycmJhY2tdIC0gd2hlbiBgZm5gIHBhc3NlcyBhbiBlcnJvciB0byBpdCdzIGNhbGxiYWNrLFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCwgYW5kIGV4ZWN1dGlvbiBzdG9wcy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgaWYgYW4gZXJyb3Igb2NjdXJzIGFuZCBhbiBlcnJiYWNrXG4gKiBpcyBub3QgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmZvcmV2ZXIoXG4gKiAgICAgZnVuY3Rpb24obmV4dCkge1xuICogICAgICAgICAvLyBuZXh0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIHRvIHRoaW5ncyB0aGF0IG5lZWQgYSBjYWxsYmFjayhlcnIgWywgd2hhdGV2ZXJdKTtcbiAqICAgICAgICAgLy8gaXQgd2lsbCByZXN1bHQgaW4gdGhpcyBmdW5jdGlvbiBiZWluZyBjYWxsZWQgYWdhaW4uXG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgLy8gaWYgbmV4dCBpcyBjYWxsZWQgd2l0aCBhIHZhbHVlIGluIGl0cyBmaXJzdCBwYXJhbWV0ZXIsIGl0IHdpbGwgYXBwZWFyXG4gKiAgICAgICAgIC8vIGluIGhlcmUgYXMgJ2VycicsIGFuZCBleGVjdXRpb24gd2lsbCBzdG9wLlxuICogICAgIH1cbiAqICk7XG4gKi9cbmZ1bmN0aW9uIGZvcmV2ZXIoZm4sIGVycmJhY2spIHtcbiAgICB2YXIgZG9uZSA9IG9ubHlPbmNlKGVycmJhY2spO1xuICAgIHZhciB0YXNrID0gd3JhcEFzeW5jKGVuc3VyZUFzeW5jKGZuKSk7XG5cbiAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB0YXNrKG5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dCgpO1xufVxudmFyIGZvcmV2ZXIkMSA9IGF3YWl0aWZ5KGZvcmV2ZXIsIDIpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZ3JvdXBCeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBncm91cEJ5TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYGtleWAgdG8gZ3JvdXAgdGhlIHZhbHVlIHVuZGVyLlxuICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdCBpcyBhbiBgT2JqZWN0YCB3aG9zZXNcbiAqIHByb3BlcnRpZXMgYXJlIGFycmF5cyBvZiB2YWx1ZXMgd2hpY2ggcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGdyb3VwQnlMaW1pdChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgcmV0dXJuIG1hcExpbWl0JDEoY29sbCwgbGltaXQsICh2YWwsIGl0ZXJDYikgPT4ge1xuICAgICAgICBfaXRlcmF0ZWUodmFsLCAoZXJyLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBpdGVyQ2IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyQ2IoZXJyLCB7a2V5LCB2YWx9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgKGVyciwgbWFwUmVzdWx0cykgPT4ge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIGZyb20gTUROLCBoYW5kbGUgb2JqZWN0IGhhdmluZyBhbiBgaGFzT3duUHJvcGVydHlgIHByb3BcbiAgICAgICAgdmFyIHtoYXNPd25Qcm9wZXJ0eX0gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgICB2YXIge2tleX0gPSBtYXBSZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB7dmFsfSA9IG1hcFJlc3VsdHNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gW3ZhbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICB9KTtcbn1cblxudmFyIGdyb3VwQnlMaW1pdCQxID0gYXdhaXRpZnkoZ3JvdXBCeUxpbWl0LCA0KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IG9iamVjdCwgd2hlcmUgZWFjaCB2YWx1ZSBjb3JyZXNwb25kcyB0byBhbiBhcnJheSBvZiBpdGVtcywgZnJvbVxuICogYGNvbGxgLCB0aGF0IHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS4gVGhhdCBpcywgdGhlIGtleXMgb2YgdGhlIG9iamVjdFxuICogY29ycmVzcG9uZCB0byB0aGUgdmFsdWVzIHBhc3NlZCB0byB0aGUgYGl0ZXJhdGVlYCBjYWxsYmFjay5cbiAqXG4gKiBOb3RlOiBTaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgdGhlIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIHBhcmFsbGVsLFxuICogdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuXG4gKiBIb3dldmVyLCB0aGUgdmFsdWVzIGZvciBlYWNoIGtleSBpbiB0aGUgYHJlc3VsdGAgd2lsbCBiZSBpbiB0aGUgc2FtZSBvcmRlciBhc1xuICogdGhlIG9yaWdpbmFsIGBjb2xsYC4gRm9yIE9iamVjdHMsIHRoZSB2YWx1ZXMgd2lsbCByb3VnaGx5IGJlIGluIHRoZSBvcmRlciBvZlxuICogdGhlIG9yaWdpbmFsIE9iamVjdHMnIGtleXMgKGJ1dCB0aGlzIGNhbiB2YXJ5IGFjcm9zcyBKYXZhU2NyaXB0IGVuZ2luZXMpLlxuICpcbiAqIEBuYW1lIGdyb3VwQnlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBkaXIxIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTEudHh0LCBmaWxlMi50eHRcbiAqIC8vIGRpcjIgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMy50eHQsIGZpbGU0LnR4dFxuICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICogLy8gZGlyNCBkb2VzIG5vdCBleGlzdFxuICpcbiAqIGNvbnN0IGZpbGVzID0gWydkaXIxL2ZpbGUxLnR4dCcsJ2RpcjInLCdkaXI0J11cbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBkZXRlY3RzIGZpbGUgdHlwZSBhcyBub25lLCBmaWxlLCBvciBkaXJlY3RvcnlcbiAqIGZ1bmN0aW9uIGRldGVjdEZpbGUoZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ25vbmUnKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnZGlyZWN0b3J5JyA6ICdmaWxlJyk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy9Vc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLmdyb3VwQnkoZmlsZXMsIGRldGVjdEZpbGUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgaWYoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqXHQgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8ge1xuICogICAgICAgICAvLyAgICAgZmlsZTogWyAnZGlyMS9maWxlMS50eHQnIF0sXG4gKiAgICAgICAgIC8vICAgICBub25lOiBbICdkaXI0JyBdLFxuICogICAgICAgICAvLyAgICAgZGlyZWN0b3J5OiBbICdkaXIyJ11cbiAqICAgICAgICAgLy8gfVxuICogICAgICAgICAvLyByZXN1bHQgaXMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpbGVzIGdyb3VwZWQgYnkgdHlwZVxuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5ncm91cEJ5KGZpbGVzLCBkZXRlY3RGaWxlKVxuICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyB7XG4gKiAgICAgLy8gICAgIGZpbGU6IFsgJ2RpcjEvZmlsZTEudHh0JyBdLFxuICogICAgIC8vICAgICBub25lOiBbICdkaXI0JyBdLFxuICogICAgIC8vICAgICBkaXJlY3Rvcnk6IFsgJ2RpcjInXVxuICogICAgIC8vIH1cbiAqICAgICAvLyByZXN1bHQgaXMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpbGVzIGdyb3VwZWQgYnkgdHlwZVxuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLmdyb3VwQnkoZmlsZXMsIGRldGVjdEZpbGUpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyB7XG4gKiAgICAgICAgIC8vICAgICBmaWxlOiBbICdkaXIxL2ZpbGUxLnR4dCcgXSxcbiAqICAgICAgICAgLy8gICAgIG5vbmU6IFsgJ2RpcjQnIF0sXG4gKiAgICAgICAgIC8vICAgICBkaXJlY3Rvcnk6IFsgJ2RpcjInXVxuICogICAgICAgICAvLyB9XG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgZ3JvdXBlZCBieSB0eXBlXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBncm91cEJ5IChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZ3JvdXBCeUxpbWl0JDEoY29sbCwgSW5maW5pdHksIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGdyb3VwQnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGdyb3VwQnlTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYGtleWAgdG8gZ3JvdXAgdGhlIHZhbHVlIHVuZGVyLlxuICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdCBpcyBhbiBgT2JqZWN0YCB3aG9zZVxuICogcHJvcGVydGllcyBhcmUgYXJyYXlzIG9mIHZhbHVlcyB3aGljaCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZ3JvdXBCeVNlcmllcyAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGdyb3VwQnlMaW1pdCQxKGNvbGwsIDEsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cblxuLyoqXG4gKiBMb2dzIHRoZSByZXN1bHQgb2YgYW4gYGFzeW5jYCBmdW5jdGlvbiB0byB0aGUgYGNvbnNvbGVgLiBPbmx5IHdvcmtzIGluXG4gKiBOb2RlLmpzIG9yIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBgY29uc29sZS5sb2dgIGFuZCBgY29uc29sZS5lcnJvcmAgKHN1Y2hcbiAqIGFzIEZGIGFuZCBDaHJvbWUpLiBJZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHJldHVybmVkIGZyb20gdGhlIGFzeW5jXG4gKiBmdW5jdGlvbiwgYGNvbnNvbGUubG9nYCBpcyBjYWxsZWQgb24gZWFjaCBhcmd1bWVudCBpbiBvcmRlci5cbiAqXG4gKiBAbmFtZSBsb2dcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHlcbiAqIGFsbCBhcmd1bWVudHMgdG8uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gaW4gYSBtb2R1bGVcbiAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2hlbGxvICcgKyBuYW1lKTtcbiAqICAgICB9LCAxMDAwKTtcbiAqIH07XG4gKlxuICogLy8gaW4gdGhlIG5vZGUgcmVwbFxuICogbm9kZT4gYXN5bmMubG9nKGhlbGxvLCAnd29ybGQnKTtcbiAqICdoZWxsbyB3b3JsZCdcbiAqL1xudmFyIGxvZyA9IGNvbnNvbGVGdW5jKCdsb2cnKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcFZhbHVlc2Bde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSBtYXBWYWx1ZXNMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWFwVmFsdWVzXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gKiBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBtYXBWYWx1ZXNMaW1pdChvYmosIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICByZXR1cm4gZWFjaE9mTGltaXQkMihsaW1pdCkob2JqLCAodmFsLCBrZXksIG5leHQpID0+IHtcbiAgICAgICAgX2l0ZXJhdGVlKHZhbCwga2V5LCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIG5leHQoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgbmV3T2JqKSk7XG59XG5cbnZhciBtYXBWYWx1ZXNMaW1pdCQxID0gYXdhaXRpZnkobWFwVmFsdWVzTGltaXQsIDQpO1xuXG4vKipcbiAqIEEgcmVsYXRpdmUgb2YgW2BtYXBgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfSwgZGVzaWduZWQgZm9yIHVzZSB3aXRoIG9iamVjdHMuXG4gKlxuICogUHJvZHVjZXMgYSBuZXcgT2JqZWN0IGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBvZiBgb2JqYCB0aHJvdWdoIHRoZSBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbi4gVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIGVhY2ggYHZhbHVlYCBhbmQgYGtleWAgZnJvbSBgb2JqYCBhbmQgYVxuICogY2FsbGJhY2sgZm9yIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcuIEVhY2ggb2YgdGhlc2UgY2FsbGJhY2tzIHRha2VzXG4gKiB0d28gYXJndW1lbnRzOiBhbiBgZXJyb3JgLCBhbmQgdGhlIHRyYW5zZm9ybWVkIGl0ZW0gZnJvbSBgb2JqYC4gSWYgYGl0ZXJhdGVlYFxuICogcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZSBgbWFwVmFsdWVzYFxuICogZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBOb3RlLCB0aGUgb3JkZXIgb2YgdGhlIGtleXMgaW4gdGhlIHJlc3VsdCBpcyBub3QgZ3VhcmFudGVlZC4gIFRoZSBrZXlzIHdpbGxcbiAqIGJlIHJvdWdobHkgaW4gdGhlIG9yZGVyIHRoZXkgY29tcGxldGUsIChidXQgdGhpcyBpcyB2ZXJ5IGVuZ2luZS1zcGVjaWZpYylcbiAqXG4gKiBAbmFtZSBtYXBWYWx1ZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleVxuICogaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYHJlc3VsdGAgaXMgYSBuZXcgb2JqZWN0IGNvbnNpc3RpbmdcbiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZmlsZTEudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDEwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTIudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDIwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTMudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDMwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTQudHh0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogY29uc3QgZmlsZU1hcCA9IHtcbiAqICAgICBmMTogJ2ZpbGUxLnR4dCcsXG4gKiAgICAgZjI6ICdmaWxlMi50eHQnLFxuICogICAgIGYzOiAnZmlsZTMudHh0J1xuICogfTtcbiAqXG4gKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVNYXAgPSB7XG4gKiAgICAgZjE6ICdmaWxlMS50eHQnLFxuICogICAgIGYyOiAnZmlsZTIudHh0JyxcbiAqICAgICBmMzogJ2ZpbGU0LnR4dCdcbiAqIH07XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZmlsZSBzaXplIGluIGJ5dGVzXG4gKiBmdW5jdGlvbiBnZXRGaWxlU2l6ZUluQnl0ZXMoZmlsZSwga2V5LCBjYWxsYmFjaykge1xuICogICAgIGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXQuc2l6ZSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5tYXBWYWx1ZXMoZmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyByZXN1bHQgaXMgbm93IGEgbWFwIG9mIGZpbGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaCBmaWxlLCBlLmcuXG4gKiAgICAgICAgIC8vIHtcbiAqICAgICAgICAgLy8gICAgIGYxOiAxMDAwLFxuICogICAgICAgICAvLyAgICAgZjI6IDIwMDAsXG4gKiAgICAgICAgIC8vICAgICBmMzogMzAwMFxuICogICAgICAgICAvLyB9XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gRXJyb3IgaGFuZGxpbmdcbiAqIGFzeW5jLm1hcFZhbHVlcyh3aXRoTWlzc2luZ0ZpbGVNYXAsIGdldEZpbGVTaXplSW5CeXRlcywgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMubWFwVmFsdWVzKGZpbGVNYXAsIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHQgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gcmVzdWx0IGlzIG5vdyBhIG1hcCBvZiBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICogICAgIC8vIHtcbiAqICAgICAvLyAgICAgZjE6IDEwMDAsXG4gKiAgICAgLy8gICAgIGYyOiAyMDAwLFxuICogICAgIC8vICAgICBmMzogMzAwMFxuICogICAgIC8vIH1cbiAqIH0pLmNhdGNoIChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMubWFwVmFsdWVzKHdpdGhNaXNzaW5nRmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzKVxuICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIH0pLmNhdGNoIChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLm1hcFZhbHVlcyhmaWxlTWFwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyByZXN1bHQgaXMgbm93IGEgbWFwIG9mIGZpbGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaCBmaWxlLCBlLmcuXG4gKiAgICAgICAgIC8vIHtcbiAqICAgICAgICAgLy8gICAgIGYxOiAxMDAwLFxuICogICAgICAgICAvLyAgICAgZjI6IDIwMDAsXG4gKiAgICAgICAgIC8vICAgICBmMzogMzAwMFxuICogICAgICAgICAvLyB9XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMubWFwVmFsdWVzKHdpdGhNaXNzaW5nRmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmosIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBtYXBWYWx1ZXNMaW1pdCQxKG9iaiwgSW5maW5pdHksIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcFZhbHVlc2Bde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBtYXBWYWx1ZXNTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1hcFZhbHVlc117QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc31cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleVxuICogaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYHJlc3VsdGAgaXMgYSBuZXcgb2JqZWN0IGNvbnNpc3RpbmdcbiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzU2VyaWVzKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1hcFZhbHVlc0xpbWl0JDEob2JqLCAxLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG5cbi8qKlxuICogQ2FjaGVzIHRoZSByZXN1bHRzIG9mIGFuIGFzeW5jIGZ1bmN0aW9uLiBXaGVuIGNyZWF0aW5nIGEgaGFzaCB0byBzdG9yZVxuICogZnVuY3Rpb24gcmVzdWx0cyBhZ2FpbnN0LCB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCBmcm9tIHRoZSBoYXNoIGFuZCBhblxuICogb3B0aW9uYWwgaGFzaCBmdW5jdGlvbiBjYW4gYmUgdXNlZC5cbiAqXG4gKiAqKk5vdGU6IGlmIHRoZSBhc3luYyBmdW5jdGlvbiBlcnJzLCB0aGUgcmVzdWx0IHdpbGwgbm90IGJlIGNhY2hlZCBhbmRcbiAqIHN1YnNlcXVlbnQgY2FsbHMgd2lsbCBjYWxsIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLioqXG4gKlxuICogSWYgbm8gaGFzaCBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGFzaCBrZXksXG4gKiB3aGljaCBtYXkgd29yayByZWFzb25hYmx5IGlmIGl0IGlzIGEgc3RyaW5nIG9yIGEgZGF0YSB0eXBlIHRoYXQgY29udmVydHMgdG8gYVxuICogZGlzdGluY3Qgc3RyaW5nLiBOb3RlIHRoYXQgb2JqZWN0cyBhbmQgYXJyYXlzIHdpbGwgbm90IGJlaGF2ZSByZWFzb25hYmx5LlxuICogTmVpdGhlciB3aWxsIGNhc2VzIHdoZXJlIHRoZSBvdGhlciBhcmd1bWVudHMgYXJlIHNpZ25pZmljYW50LiBJbiBzdWNoIGNhc2VzLFxuICogc3BlY2lmeSB5b3VyIG93biBoYXNoIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBjYWNoZSBvZiByZXN1bHRzIGlzIGV4cG9zZWQgYXMgdGhlIGBtZW1vYCBwcm9wZXJ0eSBvZiB0aGUgZnVuY3Rpb25cbiAqIHJldHVybmVkIGJ5IGBtZW1vaXplYC5cbiAqXG4gKiBAbmFtZSBtZW1vaXplXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBwcm94eSBhbmQgY2FjaGUgcmVzdWx0cyBmcm9tLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzaGVyIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYSBjdXN0b20gaGFzaFxuICogZm9yIHN0b3JpbmcgcmVzdWx0cy4gSXQgaGFzIGFsbCB0aGUgYXJndW1lbnRzIGFwcGxpZWQgdG8gaXQgYXBhcnQgZnJvbSB0aGVcbiAqIGNhbGxiYWNrLCBhbmQgbXVzdCBiZSBzeW5jaHJvbm91cy5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIG1lbW9pemVkIHZlcnNpb24gb2YgYGZuYFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2xvd19mbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nXG4gKiAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAqIH07XG4gKiB2YXIgZm4gPSBhc3luYy5tZW1vaXplKHNsb3dfZm4pO1xuICpcbiAqIC8vIGZuIGNhbiBub3cgYmUgdXNlZCBhcyBpZiBpdCB3ZXJlIHNsb3dfZm5cbiAqIGZuKCdzb21lIG5hbWUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAvLyBjYWxsYmFja1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZm4sIGhhc2hlciA9IHYgPT4gdikge1xuICAgIHZhciBtZW1vID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcXVldWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGZuKTtcbiAgICB2YXIgbWVtb2l6ZWQgPSBpbml0aWFsUGFyYW1zKChhcmdzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICB2YXIga2V5ID0gaGFzaGVyKC4uLmFyZ3MpO1xuICAgICAgICBpZiAoa2V5IGluIG1lbW8pIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKCgpID0+IGNhbGxiYWNrKG51bGwsIC4uLm1lbW9ba2V5XSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiBxdWV1ZXMpIHtcbiAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgX2ZuKC4uLmFyZ3MsIChlcnIsIC4uLnJlc3VsdEFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAvLyAjMTQ2NSBkb24ndCBtZW1vaXplIGlmIGFuIGVycm9yIG9jY3VycmVkXG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1trZXldID0gcmVzdWx0QXJncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBxW2ldKGVyciwgLi4ucmVzdWx0QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXG4vKipcbiAqIENhbGxzIGBjYWxsYmFja2Agb24gYSBsYXRlciBsb29wIGFyb3VuZCB0aGUgZXZlbnQgbG9vcC4gSW4gTm9kZS5qcyB0aGlzIGp1c3RcbiAqIGNhbGxzIGBwcm9jZXNzLm5leHRUaWNrYC4gIEluIHRoZSBicm93c2VyIGl0IHdpbGwgdXNlIGBzZXRJbW1lZGlhdGVgIGlmXG4gKiBhdmFpbGFibGUsIG90aGVyd2lzZSBgc2V0VGltZW91dChjYWxsYmFjaywgMClgLCB3aGljaCBtZWFucyBvdGhlciBoaWdoZXJcbiAqIHByaW9yaXR5IGV2ZW50cyBtYXkgcHJlY2VkZSB0aGUgZXhlY3V0aW9uIG9mIGBjYWxsYmFja2AuXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgZm9yIGJyb3dzZXItY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cbiAqXG4gKiBAbmFtZSBuZXh0VGlja1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuc2V0SW1tZWRpYXRlXXtAbGluayBtb2R1bGU6VXRpbHMuc2V0SW1tZWRpYXRlfVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gYSBsYXRlciBsb29wIGFyb3VuZFxuICogdGhlIGV2ZW50IGxvb3AuIEludm9rZWQgd2l0aCAoYXJncy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MuLi4gLSBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gKiBjYWxsYmFjayBvbiB0aGUgbmV4dCB0aWNrLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY2FsbF9vcmRlciA9IFtdO1xuICogYXN5bmMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gKiAgICAgY2FsbF9vcmRlci5wdXNoKCd0d28nKTtcbiAqICAgICAvLyBjYWxsX29yZGVyIG5vdyBlcXVhbHMgWydvbmUnLCd0d28nXVxuICogfSk7XG4gKiBjYWxsX29yZGVyLnB1c2goJ29uZScpO1xuICpcbiAqIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoYSwgYiwgYykge1xuICogICAgIC8vIGEsIGIsIGFuZCBjIGVxdWFsIDEsIDIsIGFuZCAzXG4gKiB9LCAxLCAyLCAzKTtcbiAqL1xudmFyIF9kZWZlcjtcblxuaWYgKGhhc05leHRUaWNrKSB7XG4gICAgX2RlZmVyID0gcHJvY2Vzcy5uZXh0VGljaztcbn0gZWxzZSBpZiAoaGFzU2V0SW1tZWRpYXRlKSB7XG4gICAgX2RlZmVyID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIHtcbiAgICBfZGVmZXIgPSBmYWxsYmFjaztcbn1cblxudmFyIG5leHRUaWNrID0gd3JhcChfZGVmZXIpO1xuXG52YXIgX3BhcmFsbGVsID0gYXdhaXRpZnkoKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgdmFyIHJlc3VsdHMgPSBpc0FycmF5TGlrZSh0YXNrcykgPyBbXSA6IHt9O1xuXG4gICAgZWFjaGZuKHRhc2tzLCAodGFzaywga2V5LCB0YXNrQ2IpID0+IHtcbiAgICAgICAgd3JhcEFzeW5jKHRhc2spKChlcnIsIC4uLnJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgW3Jlc3VsdF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB0YXNrQ2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgcmVzdWx0cykpO1xufSwgMyk7XG5cbi8qKlxuICogUnVuIHRoZSBgdGFza3NgIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIGluIHBhcmFsbGVsLCB3aXRob3V0IHdhaXRpbmcgdW50aWxcbiAqIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBJZiBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBwYXNzIGFuIGVycm9yIHRvXG4gKiBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZVxuICogZXJyb3IuIE9uY2UgdGhlIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQsIHRoZSByZXN1bHRzIGFyZSBwYXNzZWQgdG8gdGhlIGZpbmFsXG4gKiBgY2FsbGJhY2tgIGFzIGFuIGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBgcGFyYWxsZWxgIGlzIGFib3V0IGtpY2tpbmctb2ZmIEkvTyB0YXNrcyBpbiBwYXJhbGxlbCwgbm90IGFib3V0XG4gKiBwYXJhbGxlbCBleGVjdXRpb24gb2YgY29kZS4gIElmIHlvdXIgdGFza3MgZG8gbm90IHVzZSBhbnkgdGltZXJzIG9yIHBlcmZvcm1cbiAqIGFueSBJL08sIHRoZXkgd2lsbCBhY3R1YWxseSBiZSBleGVjdXRlZCBpbiBzZXJpZXMuICBBbnkgc3luY2hyb25vdXMgc2V0dXBcbiAqIHNlY3Rpb25zIGZvciBlYWNoIHRhc2sgd2lsbCBoYXBwZW4gb25lIGFmdGVyIHRoZSBvdGhlci4gIEphdmFTY3JpcHQgcmVtYWluc1xuICogc2luZ2xlLXRocmVhZGVkLlxuICpcbiAqICoqSGludDoqKiBVc2UgW2ByZWZsZWN0YF17QGxpbmsgbW9kdWxlOlV0aWxzLnJlZmxlY3R9IHRvIGNvbnRpbnVlIHRoZVxuICogZXhlY3V0aW9uIG9mIG90aGVyIHRhc2tzIHdoZW4gYSB0YXNrIGZhaWxzLlxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBFYWNoIHByb3BlcnR5IHdpbGxcbiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYFxuICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmdcbiAqIHJlc3VsdHMgZnJvbSB7QGxpbmsgYXN5bmMucGFyYWxsZWx9LlxuICpcbiAqIEBuYW1lIHBhcmFsbGVsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLlxuICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBub3QgcGFzc2VkXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAvL1VzaW5nIENhbGxiYWNrc1xuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIF0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXSBldmVuIHRob3VnaFxuICogICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LlxuICogfSk7XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICogYXN5bmMucGFyYWxsZWwoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0bzogeyBvbmU6IDEsIHR3bzogMiB9XG4gKiB9KTtcbiAqXG4gKiAvL1VzaW5nIFByb21pc2VzXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSkudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2hcbiAqICAgICAvLyB0aGUgc2Vjb25kIGZ1bmN0aW9uIGhhZCBhIHNob3J0ZXIgdGltZW91dC5cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jLnBhcmFsbGVsKHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0pLnRoZW4ocmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0bzogeyBvbmU6IDEsIHR3bzogMiB9XG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvL1VzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgICAgICAgICB9XG4gKiAgICAgICAgIF0pO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddIGV2ZW4gdGhvdWdoXG4gKiAgICAgICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LlxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnBhcmFsbGVsKHtcbiAqICAgICAgICAgICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgICAgICAgIH1cbiAqICAgICAgICAgfSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIHBhcmFsbGVsKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfcGFyYWxsZWwoZWFjaE9mJDEsIHRhc2tzLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BwYXJhbGxlbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIHBhcmFsbGVsTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnBhcmFsbGVsXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucGFyYWxsZWx9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLlxuICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBub3QgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQodGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfcGFyYWxsZWwoZWFjaE9mTGltaXQkMihsaW1pdCksIHRhc2tzLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogQSBxdWV1ZSBvZiB0YXNrcyBmb3IgdGhlIHdvcmtlciBmdW5jdGlvbiB0byBjb21wbGV0ZS5cbiAqIEB0eXBlZGVmIHtJdGVyYWJsZX0gUXVldWVPYmplY3RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxlbmd0aCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgaXRlbXNcbiAqIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkLiBJbnZva2Ugd2l0aCBgcXVldWUubGVuZ3RoKClgLlxuICogQHByb3BlcnR5IHtib29sZWFufSBzdGFydGVkIC0gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgYW55XG4gKiBpdGVtcyBoYXZlIGJlZW4gcHVzaGVkIGFuZCBwcm9jZXNzZWQgYnkgdGhlIHF1ZXVlLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcnVubmluZyAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgaXRlbXNcbiAqIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5ydW5uaW5nKClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gd29ya2Vyc0xpc3QgLSBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgYXJyYXkgb2YgaXRlbXNcbiAqIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS53b3JrZXJzTGlzdCgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGlkbGUgLSBhIGZ1bmN0aW9uIHJldHVybmluZyBmYWxzZSBpZiB0aGVyZSBhcmUgaXRlbXNcbiAqIHdhaXRpbmcgb3IgYmVpbmcgcHJvY2Vzc2VkLCBvciB0cnVlIGlmIG5vdC4gSW52b2tlIHdpdGggYHF1ZXVlLmlkbGUoKWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29uY3VycmVuY3kgLSBhbiBpbnRlZ2VyIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSBgd29ya2VyYFxuICogZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGNoYW5nZWQgYWZ0ZXIgYVxuICogYHF1ZXVlYCBpcyBjcmVhdGVkIHRvIGFsdGVyIHRoZSBjb25jdXJyZW5jeSBvbi10aGUtZmx5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBheWxvYWQgLSBhbiBpbnRlZ2VyIHRoYXQgc3BlY2lmaWVzIGhvdyBtYW55IGl0ZW1zIGFyZVxuICogcGFzc2VkIHRvIHRoZSB3b3JrZXIgZnVuY3Rpb24gYXQgYSB0aW1lLiBvbmx5IGFwcGxpZXMgaWYgdGhpcyBpcyBhXG4gKiBbY2FyZ29de0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jYXJnb30gb2JqZWN0XG4gKiBAcHJvcGVydHkge0FzeW5jRnVuY3Rpb259IHB1c2ggLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgYHF1ZXVlYC4gQ2FsbHMgYGNhbGxiYWNrYFxuICogb25jZSB0aGUgYHdvcmtlcmAgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcgdGhlIHRhc2suIEluc3RlYWQgb2YgYSBzaW5nbGUgdGFzayxcbiAqIGEgYHRhc2tzYCBhcnJheSBjYW4gYmUgc3VibWl0dGVkLiBUaGUgcmVzcGVjdGl2ZSBjYWxsYmFjayBpcyB1c2VkIGZvciBldmVyeVxuICogdGFzayBpbiB0aGUgbGlzdC4gSW52b2tlIHdpdGggYHF1ZXVlLnB1c2godGFzaywgW2NhbGxiYWNrXSlgLFxuICogQHByb3BlcnR5IHtBc3luY0Z1bmN0aW9ufSB1bnNoaWZ0IC0gYWRkIGEgbmV3IHRhc2sgdG8gdGhlIGZyb250IG9mIHRoZSBgcXVldWVgLlxuICogSW52b2tlIHdpdGggYHF1ZXVlLnVuc2hpZnQodGFzaywgW2NhbGxiYWNrXSlgLlxuICogQHByb3BlcnR5IHtBc3luY0Z1bmN0aW9ufSBwdXNoQXN5bmMgLSB0aGUgc2FtZSBhcyBgcS5wdXNoYCwgZXhjZXB0IHRoaXMgcmV0dXJuc1xuICogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyBpZiBhbiBlcnJvciBvY2N1cnMuXG4gKiBAcHJvcGVydHkge0FzeW5jRnVuY3Rpb259IHVuc2hpZnRBc3luYyAtIHRoZSBzYW1lIGFzIGBxLnVuc2hpZnRgLCBleGNlcHQgdGhpcyByZXR1cm5zXG4gKiBhIHByb21pc2UgdGhhdCByZWplY3RzIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlbW92ZSAtIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBxdWV1ZSB0aGF0IG1hdGNoIGEgdGVzdFxuICogZnVuY3Rpb24uICBUaGUgdGVzdCBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbiBvYmplY3Qgd2l0aCBhIGBkYXRhYCBwcm9wZXJ0eSxcbiAqIGFuZCBhIGBwcmlvcml0eWAgcHJvcGVydHksIGlmIHRoaXMgaXMgYVxuICogW3ByaW9yaXR5UXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wcmlvcml0eVF1ZXVlfSBvYmplY3QuXG4gKiBJbnZva2VkIHdpdGggYHF1ZXVlLnJlbW92ZSh0ZXN0Rm4pYCwgd2hlcmUgYHRlc3RGbmAgaXMgb2YgdGhlIGZvcm1cbiAqIGBmdW5jdGlvbiAoe2RhdGEsIHByaW9yaXR5fSkge31gIGFuZCByZXR1cm5zIGEgQm9vbGVhbi5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHNhdHVyYXRlZCAtIGEgZnVuY3Rpb24gdGhhdCBzZXRzIGEgY2FsbGJhY2sgdGhhdCBpc1xuICogY2FsbGVkIHdoZW4gdGhlIG51bWJlciBvZiBydW5uaW5nIHdvcmtlcnMgaGl0cyB0aGUgYGNvbmN1cnJlbmN5YCBsaW1pdCwgYW5kXG4gKiBmdXJ0aGVyIHRhc2tzIHdpbGwgYmUgcXVldWVkLiAgSWYgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQsIGBxLnNhdHVyYXRlZCgpYFxuICogcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBuZXh0IG9jY3VycmVuY2UuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1bnNhdHVyYXRlZCAtIGEgZnVuY3Rpb24gdGhhdCBzZXRzIGEgY2FsbGJhY2sgdGhhdCBpc1xuICogY2FsbGVkIHdoZW4gdGhlIG51bWJlciBvZiBydW5uaW5nIHdvcmtlcnMgaXMgbGVzcyB0aGFuIHRoZSBgY29uY3VycmVuY3lgICZcbiAqIGBidWZmZXJgIGxpbWl0cywgYW5kIGZ1cnRoZXIgdGFza3Mgd2lsbCBub3QgYmUgcXVldWVkLiBJZiB0aGUgY2FsbGJhY2sgaXNcbiAqIG9taXR0ZWQsIGBxLnVuc2F0dXJhdGVkKClgIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgbmV4dCBvY2N1cnJlbmNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJ1ZmZlciAtIEEgbWluaW11bSB0aHJlc2hvbGQgYnVmZmVyIGluIG9yZGVyIHRvIHNheSB0aGF0XG4gKiB0aGUgYHF1ZXVlYCBpcyBgdW5zYXR1cmF0ZWRgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZW1wdHkgLSBhIGZ1bmN0aW9uIHRoYXQgc2V0cyBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkXG4gKiB3aGVuIHRoZSBsYXN0IGl0ZW0gZnJvbSB0aGUgYHF1ZXVlYCBpcyBnaXZlbiB0byBhIGB3b3JrZXJgLiBJZiB0aGUgY2FsbGJhY2tcbiAqIGlzIG9taXR0ZWQsIGBxLmVtcHR5KClgIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgbmV4dCBvY2N1cnJlbmNlLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZHJhaW4gLSBhIGZ1bmN0aW9uIHRoYXQgc2V0cyBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkXG4gKiB3aGVuIHRoZSBsYXN0IGl0ZW0gZnJvbSB0aGUgYHF1ZXVlYCBoYXMgcmV0dXJuZWQgZnJvbSB0aGUgYHdvcmtlcmAuIElmIHRoZVxuICogY2FsbGJhY2sgaXMgb21pdHRlZCwgYHEuZHJhaW4oKWAgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBuZXh0IG9jY3VycmVuY2UuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlcnJvciAtIGEgZnVuY3Rpb24gdGhhdCBzZXRzIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWRcbiAqIHdoZW4gYSB0YXNrIGVycm9ycy4gSGFzIHRoZSBzaWduYXR1cmUgYGZ1bmN0aW9uKGVycm9yLCB0YXNrKWAuIElmIHRoZVxuICogY2FsbGJhY2sgaXMgb21pdHRlZCwgYGVycm9yKClgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVqZWN0cyBvbiB0aGUgbmV4dFxuICogZXJyb3IuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhdXNlZCAtIGEgYm9vbGVhbiBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgcXVldWUgaXNcbiAqIGluIGEgcGF1c2VkIHN0YXRlLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcGF1c2UgLSBhIGZ1bmN0aW9uIHRoYXQgcGF1c2VzIHRoZSBwcm9jZXNzaW5nIG9mIHRhc2tzXG4gKiB1bnRpbCBgcmVzdW1lKClgIGlzIGNhbGxlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnBhdXNlKClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVzdW1lIC0gYSBmdW5jdGlvbiB0aGF0IHJlc3VtZXMgdGhlIHByb2Nlc3Npbmcgb2ZcbiAqIHF1ZXVlZCB0YXNrcyB3aGVuIHRoZSBxdWV1ZSBpcyBwYXVzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5yZXN1bWUoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBraWxsIC0gYSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgdGhlIGBkcmFpbmAgY2FsbGJhY2sgYW5kXG4gKiBlbXB0aWVzIHJlbWFpbmluZyB0YXNrcyBmcm9tIHRoZSBxdWV1ZSBmb3JjaW5nIGl0IHRvIGdvIGlkbGUuIE5vIG1vcmUgdGFza3NcbiAqIHNob3VsZCBiZSBwdXNoZWQgdG8gdGhlIHF1ZXVlIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4gSW52b2tlIHdpdGggYHF1ZXVlLmtpbGwoKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHEgPSBhc3luYy5xdWV1ZSh3b3JrZXIsIDIpXG4gKiBxLnB1c2goaXRlbTEpXG4gKiBxLnB1c2goaXRlbTIpXG4gKiBxLnB1c2goaXRlbTMpXG4gKiAvLyBxdWV1ZXMgYXJlIGl0ZXJhYmxlLCBzcHJlYWQgaW50byBhbiBhcnJheSB0byBpbnNwZWN0XG4gKiBjb25zdCBpdGVtcyA9IFsuLi5xXSAvLyBbaXRlbTEsIGl0ZW0yLCBpdGVtM11cbiAqIC8vIG9yIHVzZSBmb3Igb2ZcbiAqIGZvciAobGV0IGl0ZW0gb2YgcSkge1xuICogICAgIGNvbnNvbGUubG9nKGl0ZW0pXG4gKiB9XG4gKlxuICogcS5kcmFpbigoKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ2FsbCBkb25lJylcbiAqIH0pXG4gKiAvLyBvclxuICogYXdhaXQgcS5kcmFpbigpXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYHF1ZXVlYCBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGBjb25jdXJyZW5jeWAuIFRhc2tzIGFkZGVkIHRvIHRoZVxuICogYHF1ZXVlYCBhcmUgcHJvY2Vzc2VkIGluIHBhcmFsbGVsICh1cCB0byB0aGUgYGNvbmN1cnJlbmN5YCBsaW1pdCkuIElmIGFsbFxuICogYHdvcmtlcmBzIGFyZSBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIG9uZSBiZWNvbWVzIGF2YWlsYWJsZS5cbiAqIE9uY2UgYSBgd29ya2VyYCBjb21wbGV0ZXMgYSBgdGFza2AsIHRoYXQgYHRhc2tgJ3MgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICpcbiAqIEBuYW1lIHF1ZXVlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGEgcXVldWVkIHRhc2suXG4gKiBJZiB5b3Ugd2FudCB0byBoYW5kbGUgZXJyb3JzIGZyb20gYW4gaW5kaXZpZHVhbCB0YXNrLCBwYXNzIGEgY2FsbGJhY2sgdG9cbiAqIGBxLnB1c2goKWAuIEludm9rZWQgd2l0aCAodGFzaywgY2FsbGJhY2spLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW5jeT0xXSAtIEFuIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnlcbiAqIGB3b3JrZXJgIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5XG4gKiBkZWZhdWx0cyB0byBgMWAuICBJZiB0aGUgY29uY3VycmVuY3kgaXMgYDBgLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyB7bW9kdWxlOkNvbnRyb2xGbG93LlF1ZXVlT2JqZWN0fSBBIHF1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBDYWxsYmFja3MgY2FuIGJlXG4gKiBhdHRhY2hlZCBhcyBjZXJ0YWluIHByb3BlcnRpZXMgdG8gbGlzdGVuIGZvciBzcGVjaWZpYyBldmVudHMgZHVyaW5nIHRoZVxuICogbGlmZWN5Y2xlIG9mIHRoZSBxdWV1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gY3JlYXRlIGEgcXVldWUgb2JqZWN0IHdpdGggY29uY3VycmVuY3kgMlxuICogdmFyIHEgPSBhc3luYy5xdWV1ZShmdW5jdGlvbih0YXNrLCBjYWxsYmFjaykge1xuICogICAgIGNvbnNvbGUubG9nKCdoZWxsbyAnICsgdGFzay5uYW1lKTtcbiAqICAgICBjYWxsYmFjaygpO1xuICogfSwgMik7XG4gKlxuICogLy8gYXNzaWduIGEgY2FsbGJhY2tcbiAqIHEuZHJhaW4oZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2FsbCBpdGVtcyBoYXZlIGJlZW4gcHJvY2Vzc2VkJyk7XG4gKiB9KTtcbiAqIC8vIG9yIGF3YWl0IHRoZSBlbmRcbiAqIGF3YWl0IHEuZHJhaW4oKVxuICpcbiAqIC8vIGFzc2lnbiBhbiBlcnJvciBjYWxsYmFja1xuICogcS5lcnJvcihmdW5jdGlvbihlcnIsIHRhc2spIHtcbiAqICAgICBjb25zb2xlLmVycm9yKCd0YXNrIGV4cGVyaWVuY2VkIGFuIGVycm9yJyk7XG4gKiB9KTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWVcbiAqIHEucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBmb28nKTtcbiAqIH0pO1xuICogLy8gY2FsbGJhY2sgaXMgb3B0aW9uYWxcbiAqIHEucHVzaCh7bmFtZTogJ2Jhcid9KTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWUgKGJhdGNoLXdpc2UpXG4gKiBxLnB1c2goW3tuYW1lOiAnYmF6J30se25hbWU6ICdiYXknfSx7bmFtZTogJ2JheCd9XSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgaXRlbScpO1xuICogfSk7XG4gKlxuICogLy8gYWRkIHNvbWUgaXRlbXMgdG8gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICogcS51bnNoaWZ0KHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXInKTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBxdWV1ZSAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgIHZhciBfd29ya2VyID0gd3JhcEFzeW5jKHdvcmtlcik7XG4gICAgcmV0dXJuIHF1ZXVlJDEoKGl0ZW1zLCBjYikgPT4ge1xuICAgICAgICBfd29ya2VyKGl0ZW1zWzBdLCBjYik7XG4gICAgfSwgY29uY3VycmVuY3ksIDEpO1xufVxuXG4vLyBCaW5hcnkgbWluLWhlYXAgaW1wbGVtZW50YXRpb24gdXNlZCBmb3IgcHJpb3JpdHkgcXVldWUuXG4vLyBJbXBsZW1lbnRhdGlvbiBpcyBzdGFibGUsIGkuZS4gcHVzaCB0aW1lIGlzIGNvbnNpZGVyZWQgZm9yIGVxdWFsIHByaW9yaXRpZXNcbmNsYXNzIEhlYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBbXTtcbiAgICAgICAgdGhpcy5wdXNoQ291bnQgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFwLmxlbmd0aDtcbiAgICB9XG5cbiAgICBlbXB0eSAoKSB7XG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwZXJjVXAoaW5kZXgpIHtcbiAgICAgICAgbGV0IHA7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiBzbWFsbGVyKHRoaXMuaGVhcFtpbmRleF0sIHRoaXMuaGVhcFtwPXBhcmVudChpbmRleCldKSkge1xuICAgICAgICAgICAgbGV0IHQgPSB0aGlzLmhlYXBbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5oZWFwW2luZGV4XSA9IHRoaXMuaGVhcFtwXTtcbiAgICAgICAgICAgIHRoaXMuaGVhcFtwXSA9IHQ7XG5cbiAgICAgICAgICAgIGluZGV4ID0gcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBlcmNEb3duKGluZGV4KSB7XG4gICAgICAgIGxldCBsO1xuXG4gICAgICAgIHdoaWxlICgobD1sZWZ0Q2hpKGluZGV4KSkgPCB0aGlzLmhlYXAubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobCsxIDwgdGhpcy5oZWFwLmxlbmd0aCAmJiBzbWFsbGVyKHRoaXMuaGVhcFtsKzFdLCB0aGlzLmhlYXBbbF0pKSB7XG4gICAgICAgICAgICAgICAgbCA9IGwrMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNtYWxsZXIodGhpcy5oZWFwW2luZGV4XSwgdGhpcy5oZWFwW2xdKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdCA9IHRoaXMuaGVhcFtpbmRleF07XG4gICAgICAgICAgICB0aGlzLmhlYXBbaW5kZXhdID0gdGhpcy5oZWFwW2xdO1xuICAgICAgICAgICAgdGhpcy5oZWFwW2xdID0gdDtcblxuICAgICAgICAgICAgaW5kZXggPSBsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaChub2RlKSB7XG4gICAgICAgIG5vZGUucHVzaENvdW50ID0gKyt0aGlzLnB1c2hDb3VudDtcbiAgICAgICAgdGhpcy5oZWFwLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMucGVyY1VwKHRoaXMuaGVhcC5sZW5ndGgtMSk7XG4gICAgfVxuXG4gICAgdW5zaGlmdChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgbGV0IFt0b3BdID0gdGhpcy5oZWFwO1xuXG4gICAgICAgIHRoaXMuaGVhcFswXSA9IHRoaXMuaGVhcFt0aGlzLmhlYXAubGVuZ3RoLTFdO1xuICAgICAgICB0aGlzLmhlYXAucG9wKCk7XG4gICAgICAgIHRoaXMucGVyY0Rvd24oMCk7XG5cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXNdO1xuICAgIH1cblxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oZWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmhlYXBbaV0uZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZSAodGVzdEZuKSB7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhlYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGVzdEZuKHRoaXMuaGVhcFtpXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYXBbal0gPSB0aGlzLmhlYXBbaV07XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oZWFwLnNwbGljZShqKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gcGFyZW50KHRoaXMuaGVhcC5sZW5ndGgtMSk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmNEb3duKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsZWZ0Q2hpKGkpIHtcbiAgICByZXR1cm4gKGk8PDEpKzE7XG59XG5cbmZ1bmN0aW9uIHBhcmVudChpKSB7XG4gICAgcmV0dXJuICgoaSsxKT4+MSktMTtcbn1cblxuZnVuY3Rpb24gc21hbGxlcih4LCB5KSB7XG4gICAgaWYgKHgucHJpb3JpdHkgIT09IHkucHJpb3JpdHkpIHtcbiAgICAgICAgcmV0dXJuIHgucHJpb3JpdHkgPCB5LnByaW9yaXR5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHgucHVzaENvdW50IDwgeS5wdXNoQ291bnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfSBvbmx5IHRhc2tzIGFyZSBhc3NpZ25lZCBhIHByaW9yaXR5IGFuZFxuICogY29tcGxldGVkIGluIGFzY2VuZGluZyBwcmlvcml0eSBvcmRlci5cbiAqXG4gKiBAbmFtZSBwcmlvcml0eVF1ZXVlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luYyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZCB0YXNrLlxuICogSWYgeW91IHdhbnQgdG8gaGFuZGxlIGVycm9ycyBmcm9tIGFuIGluZGl2aWR1YWwgdGFzaywgcGFzcyBhIGNhbGxiYWNrIHRvXG4gKiBgcS5wdXNoKClgLlxuICogSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge251bWJlcn0gY29uY3VycmVuY3kgLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gIElmIG9taXR0ZWQsIHRoZSBjb25jdXJyZW5jeSBkZWZhdWx0cyB0b1xuICogYDFgLiAgSWYgdGhlIGNvbmN1cnJlbmN5IGlzIGAwYCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBwcmlvcml0eVF1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBUaGVyZSBhcmUgdGhyZWVcbiAqIGRpZmZlcmVuY2VzIGJldHdlZW4gYHF1ZXVlYCBhbmQgYHByaW9yaXR5UXVldWVgIG9iamVjdHM6XG4gKiAqIGBwdXNoKHRhc2ssIHByaW9yaXR5LCBbY2FsbGJhY2tdKWAgLSBgcHJpb3JpdHlgIHNob3VsZCBiZSBhIG51bWJlci4gSWYgYW5cbiAqICAgYXJyYXkgb2YgYHRhc2tzYCBpcyBnaXZlbiwgYWxsIHRhc2tzIHdpbGwgYmUgYXNzaWduZWQgdGhlIHNhbWUgcHJpb3JpdHkuXG4gKiAqIGBwdXNoQXN5bmModGFzaywgcHJpb3JpdHksIFtjYWxsYmFja10pYCAtIHRoZSBzYW1lIGFzIGBwcmlvcml0eVF1ZXVlLnB1c2hgLFxuICogICBleGNlcHQgdGhpcyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICogKiBUaGUgYHVuc2hpZnRgIGFuZCBgdW5zaGlmdEFzeW5jYCBtZXRob2RzIHdlcmUgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcHJpb3JpdHlRdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgIHZhciBxID0gcXVldWUod29ya2VyLCBjb25jdXJyZW5jeSk7XG5cbiAgICB2YXIge1xuICAgICAgICBwdXNoLFxuICAgICAgICBwdXNoQXN5bmNcbiAgICB9ID0gcTtcblxuICAgIHEuX3Rhc2tzID0gbmV3IEhlYXAoKTtcbiAgICBxLl9jcmVhdGVUYXNrSXRlbSA9ICh7ZGF0YSwgcHJpb3JpdHl9LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0YUl0ZW1zKHRhc2tzLCBwcmlvcml0eSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2RhdGE6IHRhc2tzLCBwcmlvcml0eX07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhc2tzLm1hcChkYXRhID0+IHsgcmV0dXJuIHtkYXRhLCBwcmlvcml0eX07IH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgcS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgcHJpb3JpdHkgPSAwLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcHVzaChjcmVhdGVEYXRhSXRlbXMoZGF0YSwgcHJpb3JpdHkpLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHEucHVzaEFzeW5jID0gZnVuY3Rpb24oZGF0YSwgcHJpb3JpdHkgPSAwLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcHVzaEFzeW5jKGNyZWF0ZURhdGFJdGVtcyhkYXRhLCBwcmlvcml0eSksIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLy8gUmVtb3ZlIHVuc2hpZnQgZnVuY3Rpb25zXG4gICAgZGVsZXRlIHEudW5zaGlmdDtcbiAgICBkZWxldGUgcS51bnNoaWZ0QXN5bmM7XG5cbiAgICByZXR1cm4gcTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBwYXJhbGxlbCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZVxuICogcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gT25jZSBhbnkgb2YgdGhlIGB0YXNrc2AgY29tcGxldGUgb3IgcGFzcyBhblxuICogZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZC4gSXQnc1xuICogZXF1aXZhbGVudCB0byBgUHJvbWlzZS5yYWNlKClgLlxuICpcbiAqIEBuYW1lIHJhY2VcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl9IHRhc2tzIC0gQW4gYXJyYXkgY29udGFpbmluZyBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufVxuICogdG8gcnVuLiBFYWNoIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFuIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFueSBvZiB0aGUgZnVuY3Rpb25zIGhhdmVcbiAqIGNvbXBsZXRlZC4gVGhpcyBmdW5jdGlvbiBnZXRzIGFuIGVycm9yIG9yIHJlc3VsdCBmcm9tIHRoZSBmaXJzdCBmdW5jdGlvbiB0aGF0XG4gKiBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLnJhY2UoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIF0sXG4gKiAvLyBtYWluIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHRoZSByZXN1bHQgd2lsbCBiZSBlcXVhbCB0byAndHdvJyBhcyBpdCBmaW5pc2hlcyBlYXJsaWVyXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmFjZSh0YXNrcywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCB0byByYWNlIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB3cmFwQXN5bmModGFza3NbaV0pKGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbnZhciByYWNlJDEgPSBhd2FpdGlmeShyYWNlLCAyKTtcblxuLyoqXG4gKiBTYW1lIGFzIFtgcmVkdWNlYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlZHVjZX0sIG9ubHkgb3BlcmF0ZXMgb24gYGFycmF5YCBpbiByZXZlcnNlIG9yZGVyLlxuICpcbiAqIEBuYW1lIHJlZHVjZVJpZ2h0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWR1Y2Vde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWR1Y2V9XG4gKiBAYWxpYXMgZm9sZHJcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0geyp9IG1lbW8gLSBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi5cbiAqIFRoZSBgaXRlcmF0ZWVgIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSBuZXh0IHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uXG4gKiBJZiB0aGUgaXRlcmF0ZWUgY29tcGxldGVzIHdpdGggYW4gZXJyb3IsIHRoZSByZWR1Y3Rpb24gaXMgc3RvcHBlZCBhbmQgdGhlXG4gKiBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICogSW52b2tlZCB3aXRoIChtZW1vLCBpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSByZWR1Y2VkIHZhbHVlLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gcmVkdWNlUmlnaHQgKGFycmF5LCBtZW1vLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmV2ZXJzZWQgPSBbLi4uYXJyYXldLnJldmVyc2UoKTtcbiAgICByZXR1cm4gcmVkdWNlJDEocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIGFzeW5jIGZ1bmN0aW9uIGluIGFub3RoZXIgZnVuY3Rpb24gdGhhdCBhbHdheXMgY29tcGxldGVzIHdpdGggYVxuICogcmVzdWx0IG9iamVjdCwgZXZlbiB3aGVuIGl0IGVycm9ycy5cbiAqXG4gKiBUaGUgcmVzdWx0IG9iamVjdCBoYXMgZWl0aGVyIHRoZSBwcm9wZXJ0eSBgZXJyb3JgIG9yIGB2YWx1ZWAuXG4gKlxuICogQG5hbWUgcmVmbGVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24geW91IHdhbnQgdG8gd3JhcFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcGFzc2VzIG51bGwgdG8gaXQncyBjYWxsYmFjayBhc1xuICogdGhlIGVycm9yLiBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayB3aWxsIGJlIGFuIGBvYmplY3RgIHdpdGhcbiAqIGVpdGhlciBhbiBgZXJyb3JgIG9yIGEgYHZhbHVlYCBwcm9wZXJ0eS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgIH0pLFxuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIGJ1dCBlcnJvciAuLi5cbiAqICAgICAgICAgY2FsbGJhY2soJ2JhZCBzdHVmZiBoYXBwZW5lZCcpO1xuICogICAgIH0pLFxuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIC4uLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgfSlcbiAqIF0sXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gdmFsdWVzXG4gKiAgICAgLy8gcmVzdWx0c1swXS52YWx1ZSA9ICdvbmUnXG4gKiAgICAgLy8gcmVzdWx0c1sxXS5lcnJvciA9ICdiYWQgc3R1ZmYgaGFwcGVuZWQnXG4gKiAgICAgLy8gcmVzdWx0c1syXS52YWx1ZSA9ICd0d28nXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmVmbGVjdChmbikge1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIHJlZmxlY3RPbihhcmdzLCByZWZsZWN0Q2FsbGJhY2spIHtcbiAgICAgICAgYXJncy5wdXNoKChlcnJvciwgLi4uY2JBcmdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmV0VmFsID0ge307XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXRWYWwuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYkFyZ3MubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2JBcmdzO1xuICAgICAgICAgICAgICAgIGlmIChjYkFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXSA9IGNiQXJncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0VmFsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZsZWN0Q2FsbGJhY2sobnVsbCwgcmV0VmFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIF9mbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdyYXBzIGFuIGFycmF5IG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgd2l0aCBgcmVmbGVjdGAuXG4gKlxuICogQG5hbWUgcmVmbGVjdEFsbFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucmVmbGVjdF17QGxpbmsgbW9kdWxlOlV0aWxzLnJlZmxlY3R9XG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8SXRlcmFibGV9IHRhc2tzIC0gVGhlIGNvbGxlY3Rpb24gb2ZcbiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHdyYXAgaW4gYGFzeW5jLnJlZmxlY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGFzeW5jIGZ1bmN0aW9ucywgZWFjaCB3cmFwcGVkIGluXG4gKiBgYXN5bmMucmVmbGVjdGBcbiAqIEBleGFtcGxlXG4gKlxuICogbGV0IHRhc2tzID0gW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgYnV0IGVycm9yIC4uLlxuICogICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2JhZCBzdHVmZiBoYXBwZW5lZCcpKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXTtcbiAqXG4gKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB2YWx1ZXNcbiAqICAgICAvLyByZXN1bHRzWzBdLnZhbHVlID0gJ29uZSdcbiAqICAgICAvLyByZXN1bHRzWzFdLmVycm9yID0gRXJyb3IoJ2JhZCBzdHVmZiBoYXBwZW5lZCcpXG4gKiAgICAgLy8gcmVzdWx0c1syXS52YWx1ZSA9ICd0d28nXG4gKiB9KTtcbiAqXG4gKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gKiBsZXQgdGFza3MgPSB7XG4gKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBjYWxsYmFjaygndHdvJyk7XG4gKiAgICAgfSxcbiAqICAgICB0aHJlZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH07XG4gKlxuICogYXN5bmMucGFyYWxsZWwoYXN5bmMucmVmbGVjdEFsbCh0YXNrcyksXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gdmFsdWVzXG4gKiAgICAgLy8gcmVzdWx0cy5vbmUudmFsdWUgPSAnb25lJ1xuICogICAgIC8vIHJlc3VsdHMudHdvLmVycm9yID0gJ3R3bydcbiAqICAgICAvLyByZXN1bHRzLnRocmVlLnZhbHVlID0gJ3RocmVlJ1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHJlZmxlY3RBbGwodGFza3MpIHtcbiAgICB2YXIgcmVzdWx0cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgcmVzdWx0cyA9IHRhc2tzLm1hcChyZWZsZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHRhc2tzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZWZsZWN0LmNhbGwodGhpcywgdGFza3Nba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcmVqZWN0JDIoZWFjaGZuLCBhcnIsIF9pdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpdGVyYXRlZSA9IHdyYXBBc3luYyhfaXRlcmF0ZWUpO1xuICAgIHJldHVybiBfZmlsdGVyKGVhY2hmbiwgYXJyLCAodmFsdWUsIGNiKSA9PiB7XG4gICAgICAgIGl0ZXJhdGVlKHZhbHVlLCAoZXJyLCB2KSA9PiB7XG4gICAgICAgICAgICBjYihlcnIsICF2KTtcbiAgICAgICAgfSk7XG4gICAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9LiBSZW1vdmVzIHZhbHVlcyB0aGF0IHBhc3MgYW4gYGFzeW5jYCB0cnV0aCB0ZXN0LlxuICpcbiAqIEBuYW1lIHJlamVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAqXG4gKiBjb25zdCBmaWxlTGlzdCA9IFsnZGlyMS9maWxlMS50eHQnLCdkaXIyL2ZpbGUzLnR4dCcsJ2RpcjMvZmlsZTYudHh0J107XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAqIGZ1bmN0aW9uIGZpbGVFeGlzdHMoZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgIGZzLmFjY2VzcyhmaWxlLCBmcy5jb25zdGFudHMuRl9PSywgKGVycikgPT4ge1xuICogICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpO1xuICogICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5yZWplY3QoZmlsZUxpc3QsIGZpbGVFeGlzdHMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgLy8gWyAnZGlyMy9maWxlNi50eHQnIF1cbiAqICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiB0aGUgbm9uLWV4aXN0aW5nIGZpbGVzXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMucmVqZWN0KGZpbGVMaXN0LCBmaWxlRXhpc3RzKVxuICogLnRoZW4oIHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIFsgJ2RpcjMvZmlsZTYudHh0JyBdXG4gKiAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIHRoZSBub24tZXhpc3RpbmcgZmlsZXNcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMucmVqZWN0KGZpbGVMaXN0LCBmaWxlRXhpc3RzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIFsgJ2RpcjMvZmlsZTYudHh0JyBdXG4gKiAgICAgICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiB0aGUgbm9uLWV4aXN0aW5nIGZpbGVzXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiByZWplY3QgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiByZWplY3QkMihlYWNoT2YkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIHJlamVjdCQxID0gYXdhaXRpZnkocmVqZWN0LCAzKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHJlamVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSByZWplY3RMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucmVqZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gcmVqZWN0TGltaXQgKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVqZWN0JDIoZWFjaE9mTGltaXQkMihsaW1pdCksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciByZWplY3RMaW1pdCQxID0gYXdhaXRpZnkocmVqZWN0TGltaXQsIDQpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIHJlamVjdFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucmVqZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gcmVqZWN0U2VyaWVzIChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVqZWN0JDIoZWFjaE9mU2VyaWVzJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciByZWplY3RTZXJpZXMkMSA9IGF3YWl0aWZ5KHJlamVjdFNlcmllcywgMyk7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBnZXQgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGZyb20gYHRhc2tgIG5vIG1vcmUgdGhhbiBgdGltZXNgIHRpbWVzXG4gKiBiZWZvcmUgcmV0dXJuaW5nIGFuIGVycm9yLiBJZiB0aGUgdGFzayBpcyBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlXG4gKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgYXR0ZW1wdHMgZmFpbCwgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC5cbiAqXG4gKiBAbmFtZSByZXRyeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHNlZSBbYXN5bmMucmV0cnlhYmxlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnlhYmxlfVxuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIENhbiBiZSBlaXRoZXIgYW5cbiAqIG9iamVjdCB3aXRoIGB0aW1lc2AgYW5kIGBpbnRlcnZhbGAgb3IgYSBudW1iZXIuXG4gKiAqIGB0aW1lc2AgLSBUaGUgbnVtYmVyIG9mIGF0dGVtcHRzIHRvIG1ha2UgYmVmb3JlIGdpdmluZyB1cC4gIFRoZSBkZWZhdWx0XG4gKiAgIGlzIGA1YC5cbiAqICogYGludGVydmFsYCAtIFRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiByZXRyaWVzLCBpbiBtaWxsaXNlY29uZHMuICBUaGVcbiAqICAgZGVmYXVsdCBpcyBgMGAuIFRoZSBpbnRlcnZhbCBtYXkgYWxzbyBiZSBzcGVjaWZpZWQgYXMgYSBmdW5jdGlvbiBvZiB0aGVcbiAqICAgcmV0cnkgY291bnQgKHNlZSBleGFtcGxlKS5cbiAqICogYGVycm9yRmlsdGVyYCAtIEFuIG9wdGlvbmFsIHN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBvblxuICogICBlcnJvbmVvdXMgcmVzdWx0LiBJZiBpdCByZXR1cm5zIGB0cnVlYCB0aGUgcmV0cnkgYXR0ZW1wdHMgd2lsbCBjb250aW51ZTtcbiAqICAgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGUgcmV0cnkgZmxvdyBpcyBhYm9ydGVkIHdpdGggdGhlIGN1cnJlbnRcbiAqICAgYXR0ZW1wdCdzIGVycm9yIGFuZCByZXN1bHQgYmVpbmcgcmV0dXJuZWQgdG8gdGhlIGZpbmFsIGNhbGxiYWNrLlxuICogICBJbnZva2VkIHdpdGggKGVycikuXG4gKiAqIElmIGBvcHRzYCBpcyBhIG51bWJlciwgdGhlIG51bWJlciBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSxcbiAqICAgd2l0aCB0aGUgZGVmYXVsdCBpbnRlcnZhbCBvZiBgMGAuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRhc2sgLSBBbiBhc3luYyBmdW5jdGlvbiB0byByZXRyeS5cbiAqIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZVxuICogdGFzayBoYXMgc3VjY2VlZGVkLCBvciBhZnRlciB0aGUgZmluYWwgZmFpbGVkIGF0dGVtcHQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYFxuICogYW5kIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZFxuICogd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFRoZSBgcmV0cnlgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGFzIGEgc3RhbmQtYWxvbmUgY29udHJvbCBmbG93IGJ5IHBhc3NpbmdcbiAqIC8vIGEgY2FsbGJhY2ssIGFzIHNob3duIGJlbG93OlxuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAzIHRpbWVzXG4gKiBhc3luYy5yZXRyeSgzLCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXMsIHdhaXRpbmcgMjAwIG1zIGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoe3RpbWVzOiAzLCBpbnRlcnZhbDogMjAwfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAxMCB0aW1lcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIC8vIChpLmUuIGludGVydmFscyBvZiAxMDAsIDIwMCwgNDAwLCA4MDAsIDE2MDAsIC4uLiBtaWxsaXNlY29uZHMpXG4gKiBhc3luYy5yZXRyeSh7XG4gKiAgIHRpbWVzOiAxMCxcbiAqICAgaW50ZXJ2YWw6IGZ1bmN0aW9uKHJldHJ5Q291bnQpIHtcbiAqICAgICByZXR1cm4gNTAgKiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAqICAgfVxuICogfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCB0aGUgZGVmYXVsdCA1IHRpbWVzIG5vIGRlbGF5IGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCBvbmx5IHdoZW4gZXJyb3IgY29uZGl0aW9uIHNhdGlzZmllcywgYWxsIG90aGVyXG4gKiAvLyBlcnJvcnMgd2lsbCBhYm9ydCB0aGUgcmV0cnkgY29udHJvbCBmbG93IGFuZCByZXR1cm4gdG8gZmluYWwgY2FsbGJhY2tcbiAqIGFzeW5jLnJldHJ5KHtcbiAqICAgZXJyb3JGaWx0ZXI6IGZ1bmN0aW9uKGVycikge1xuICogICAgIHJldHVybiBlcnIubWVzc2FnZSA9PT0gJ1RlbXBvcmFyeSBlcnJvcic7IC8vIG9ubHkgcmV0cnkgb24gYSBzcGVjaWZpYyBlcnJvclxuICogICB9XG4gKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdG8gcmV0cnkgaW5kaXZpZHVhbCBtZXRob2RzIHRoYXQgYXJlIG5vdCBhcyByZWxpYWJsZSB3aXRoaW4gb3RoZXJcbiAqIC8vIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMsIHVzZSB0aGUgYHJldHJ5YWJsZWAgd3JhcHBlcjpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIHVzZXJzOiBhcGkuZ2V0VXNlcnMuYmluZChhcGkpLFxuICogICAgIHBheW1lbnRzOiBhc3luYy5yZXRyeWFibGUoMywgYXBpLmdldFBheW1lbnRzLmJpbmQoYXBpKSlcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRzXG4gKiB9KTtcbiAqXG4gKi9cbmNvbnN0IERFRkFVTFRfVElNRVMgPSA1O1xuY29uc3QgREVGQVVMVF9JTlRFUlZBTCA9IDA7XG5cbmZ1bmN0aW9uIHJldHJ5KG9wdHMsIHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHRpbWVzOiBERUZBVUxUX1RJTUVTLFxuICAgICAgICBpbnRlcnZhbEZ1bmM6IGNvbnN0YW50KERFRkFVTFRfSU5URVJWQUwpXG4gICAgfTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMyAmJiB0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHRhc2sgfHwgcHJvbWlzZUNhbGxiYWNrKCk7XG4gICAgICAgIHRhc2sgPSBvcHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlVGltZXMob3B0aW9ucywgb3B0cyk7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgcHJvbWlzZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICB9XG5cbiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7XG5cbiAgICB2YXIgYXR0ZW1wdCA9IDE7XG4gICAgZnVuY3Rpb24gcmV0cnlBdHRlbXB0KCkge1xuICAgICAgICBfdGFzaygoZXJyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuXG4gICAgICAgICAgICBpZiAoZXJyICYmIGF0dGVtcHQrKyA8IG9wdGlvbnMudGltZXMgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMuZXJyb3JGaWx0ZXIgIT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVycm9yRmlsdGVyKGVycikpKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXRyeUF0dGVtcHQsIG9wdGlvbnMuaW50ZXJ2YWxGdW5jKGF0dGVtcHQgLSAxKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHJ5QXR0ZW1wdCgpO1xuICAgIHJldHVybiBjYWxsYmFja1tQUk9NSVNFX1NZTUJPTF1cbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lcyhhY2MsIHQpIHtcbiAgICBpZiAodHlwZW9mIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFjYy50aW1lcyA9ICt0LnRpbWVzIHx8IERFRkFVTFRfVElNRVM7XG5cbiAgICAgICAgYWNjLmludGVydmFsRnVuYyA9IHR5cGVvZiB0LmludGVydmFsID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIHQuaW50ZXJ2YWwgOlxuICAgICAgICAgICAgY29uc3RhbnQoK3QuaW50ZXJ2YWwgfHwgREVGQVVMVF9JTlRFUlZBTCk7XG5cbiAgICAgICAgYWNjLmVycm9yRmlsdGVyID0gdC5lcnJvckZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWNjLnRpbWVzID0gK3QgfHwgREVGQVVMVF9USU1FUztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgYXN5bmMucmV0cnlcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgY2xvc2UgcmVsYXRpdmUgb2YgW2ByZXRyeWBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeX0uICBUaGlzIG1ldGhvZFxuICogd3JhcHMgYSB0YXNrIGFuZCBtYWtlcyBpdCByZXRyeWFibGUsIHJhdGhlciB0aGFuIGltbWVkaWF0ZWx5IGNhbGxpbmcgaXRcbiAqIHdpdGggcmV0cmllcy5cbiAqXG4gKiBAbmFtZSByZXRyeWFibGVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnJldHJ5XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRzID0ge3RpbWVzOiA1LCBpbnRlcnZhbDogMH18IDVdIC0gb3B0aW9uYWxcbiAqIG9wdGlvbnMsIGV4YWN0bHkgdGhlIHNhbWUgYXMgZnJvbSBgcmV0cnlgLCBleGNlcHQgZm9yIGEgYG9wdHMuYXJpdHlgIHRoYXRcbiAqIGlzIHRoZSBhcml0eSBvZiB0aGUgYHRhc2tgIGZ1bmN0aW9uLCBkZWZhdWx0aW5nIHRvIGB0YXNrLmxlbmd0aGBcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHJldHVybmVkIHdyYXBwZXIuXG4gKiBJbnZva2VkIHdpdGggKC4uLmFyZ3MsIGNhbGxiYWNrKS5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbiwgd2hpY2ggd2hlbiBpbnZva2VkLCB3aWxsXG4gKiByZXRyeSBvbiBhbiBlcnJvciwgYmFzZWQgb24gdGhlIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIGBvcHRzYC5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhY2NlcHQgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyBgdGFza2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIGRlcDE6IGFzeW5jLnJldHJ5YWJsZSgzLCBnZXRGcm9tRmxha3lTZXJ2aWNlKSxcbiAqICAgICBwcm9jZXNzOiBbXCJkZXAxXCIsIGFzeW5jLnJldHJ5YWJsZSgzLCBmdW5jdGlvbiAocmVzdWx0cywgY2IpIHtcbiAqICAgICAgICAgbWF5YmVQcm9jZXNzRGF0YShyZXN1bHRzLmRlcDEsIGNiKTtcbiAqICAgICB9KV1cbiAqIH0sIGNhbGxiYWNrKTtcbiAqL1xuZnVuY3Rpb24gcmV0cnlhYmxlIChvcHRzLCB0YXNrKSB7XG4gICAgaWYgKCF0YXNrKSB7XG4gICAgICAgIHRhc2sgPSBvcHRzO1xuICAgICAgICBvcHRzID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IGFyaXR5ID0gKG9wdHMgJiYgb3B0cy5hcml0eSkgfHwgdGFzay5sZW5ndGg7XG4gICAgaWYgKGlzQXN5bmModGFzaykpIHtcbiAgICAgICAgYXJpdHkgKz0gMTtcbiAgICB9XG4gICAgdmFyIF90YXNrID0gd3JhcEFzeW5jKHRhc2spO1xuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKChhcmdzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBhcml0eSAtIDEgfHwgY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcHJvbWlzZUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGFza0ZuKGNiKSB7XG4gICAgICAgICAgICBfdGFzayguLi5hcmdzLCBjYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cykgcmV0cnkob3B0cywgdGFza0ZuLCBjYWxsYmFjayk7XG4gICAgICAgIGVsc2UgcmV0cnkodGFza0ZuLCBjYWxsYmFjayk7XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrW1BST01JU0VfU1lNQk9MXVxuICAgIH0pO1xufVxuXG4vKipcbiAqIFJ1biB0aGUgZnVuY3Rpb25zIGluIHRoZSBgdGFza3NgIGNvbGxlY3Rpb24gaW4gc2VyaWVzLCBlYWNoIG9uZSBydW5uaW5nIG9uY2VcbiAqIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBJZiBhbnkgZnVuY3Rpb25zIGluIHRoZSBzZXJpZXMgcGFzcyBhblxuICogZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCBubyBtb3JlIGZ1bmN0aW9ucyBhcmUgcnVuLCBhbmQgYGNhbGxiYWNrYCBpc1xuICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBlcnJvci4gT3RoZXJ3aXNlLCBgY2FsbGJhY2tgXG4gKiByZWNlaXZlcyBhbiBhcnJheSBvZiByZXN1bHRzIHdoZW4gYHRhc2tzYCBoYXZlIGNvbXBsZXRlZC5cbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gRWFjaCBwcm9wZXJ0eSB3aWxsXG4gKiBiZSBydW4gYXMgYSBmdW5jdGlvbiwgYW5kIHRoZSByZXN1bHRzIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmaW5hbCBgY2FsbGJhY2tgXG4gKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZ1xuICogIHJlc3VsdHMgZnJvbSB7QGxpbmsgYXN5bmMuc2VyaWVzfS5cbiAqXG4gKiAqKk5vdGUqKiB0aGF0IHdoaWxlIG1hbnkgaW1wbGVtZW50YXRpb25zIHByZXNlcnZlIHRoZSBvcmRlciBvZiBvYmplY3RcbiAqIHByb3BlcnRpZXMsIHRoZSBbRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC42KVxuICogZXhwbGljaXRseSBzdGF0ZXMgdGhhdFxuICpcbiAqID4gVGhlIG1lY2hhbmljcyBhbmQgb3JkZXIgb2YgZW51bWVyYXRpbmcgdGhlIHByb3BlcnRpZXMgaXMgbm90IHNwZWNpZmllZC5cbiAqXG4gKiBTbyBpZiB5b3UgcmVseSBvbiB0aGUgb3JkZXIgaW4gd2hpY2ggeW91ciBzZXJpZXMgb2YgZnVuY3Rpb25zIGFyZSBleGVjdXRlZCxcbiAqIGFuZCB3YW50IHRoaXMgdG8gd29yayBvbiBhbGwgcGxhdGZvcm1zLCBjb25zaWRlciB1c2luZyBhbiBhcnJheS5cbiAqXG4gKiBAbmFtZSBzZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIGNvbnRhaW5pbmdcbiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHJ1biBpbiBzZXJpZXMuXG4gKiBFYWNoIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGVcbiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gVGhpcyBmdW5jdGlvbiBnZXRzIGEgcmVzdWx0cyBhcnJheSAob3Igb2JqZWN0KVxuICogY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBgdGFza2AgY2FsbGJhY2tzLiBJbnZva2VkXG4gKiB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvL1VzaW5nIENhbGxiYWNrc1xuICogYXN5bmMuc2VyaWVzKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgLy8gZG8gc29tZSBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgLy8gdGhlbiBkbyBhbm90aGVyIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvIFsnb25lJywndHdvJ11cbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgb2JqZWN0cyBpbnN0ZWFkIG9mIGFycmF5c1xuICogYXN5bmMuc2VyaWVzKHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyBkbyBzb21lIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgLy8gdGhlbiBkbyBhbm90aGVyIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG86IHsgb25lOiAxLCB0d286IDIgfVxuICogfSk7XG4gKlxuICogLy9Vc2luZyBQcm9taXNlc1xuICogYXN5bmMuc2VyaWVzKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdKS50aGVuKHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXVxuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICogYXN5bmMuc2VyaWVzKHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyBkbyBzb21lIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgLy8gdGhlbiBkbyBhbm90aGVyIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0pLnRoZW4ocmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0bzogeyBvbmU6IDEsIHR3bzogMiB9XG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvL1VzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5zZXJpZXMoW1xuICogICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICAvLyBkbyBzb21lIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGRvIGFub3RoZXIgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgXSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvIFsnb25lJywndHdvJ11cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5wYXJhbGxlbCh7XG4gKiAgICAgICAgICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgLy8gZG8gc29tZSBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBkbyBhbm90aGVyIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAqICAgICAgICAgICAgfVxuICogICAgICAgICB9KTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG86IHsgb25lOiAxLCB0d286IDIgfVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gc2VyaWVzKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfcGFyYWxsZWwoZWFjaE9mU2VyaWVzJDEsIHRhc2tzLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGBjb2xsYCBzYXRpc2ZpZXMgYW4gYXN5bmMgdGVzdC5cbiAqIElmIGFueSBpdGVyYXRlZSBjYWxsIHJldHVybnMgYHRydWVgLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5XG4gKiBjYWxsZWQuXG4gKlxuICogQG5hbWUgc29tZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGFueVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbnMgaW4gcGFyYWxsZWwuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luY1xuICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAqIC8vIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICogZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlLCBjYWxsYmFjaykge1xuICogICAgZnMuYWNjZXNzKGZpbGUsIGZzLmNvbnN0YW50cy5GX09LLCAoZXJyKSA9PiB7XG4gKiAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycik7XG4gKiAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLnNvbWUoWydkaXIxL21pc3NpbmcudHh0JywnZGlyMi9taXNzaW5nLnR4dCcsJ2RpcjMvZmlsZTUudHh0J10sIGZpbGVFeGlzdHMsXG4gKiAgICBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgLy8gdHJ1ZVxuICogICAgICAgIC8vIHJlc3VsdCBpcyB0cnVlIHNpbmNlIHNvbWUgZmlsZSBpbiB0aGUgbGlzdCBleGlzdHNcbiAqICAgIH1cbiAqKTtcbiAqXG4gKiBhc3luYy5zb21lKFsnZGlyMS9taXNzaW5nLnR4dCcsJ2RpcjIvbWlzc2luZy50eHQnLCdkaXI0L21pc3NpbmcudHh0J10sIGZpbGVFeGlzdHMsXG4gKiAgICBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgLy8gZmFsc2VcbiAqICAgICAgICAvLyByZXN1bHQgaXMgZmFsc2Ugc2luY2Ugbm9uZSBvZiB0aGUgZmlsZXMgZXhpc3RzXG4gKiAgICB9XG4gKik7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnNvbWUoWydkaXIxL21pc3NpbmcudHh0JywnZGlyMi9taXNzaW5nLnR4dCcsJ2RpcjMvZmlsZTUudHh0J10sIGZpbGVFeGlzdHMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIHRydWVcbiAqICAgICAvLyByZXN1bHQgaXMgdHJ1ZSBzaW5jZSBzb21lIGZpbGUgaW4gdGhlIGxpc3QgZXhpc3RzXG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogYXN5bmMuc29tZShbJ2RpcjEvbWlzc2luZy50eHQnLCdkaXIyL21pc3NpbmcudHh0JywnZGlyNC9taXNzaW5nLnR4dCddLCBmaWxlRXhpc3RzKVxuICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyBmYWxzZVxuICogICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBub25lIG9mIHRoZSBmaWxlcyBleGlzdHNcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5zb21lKFsnZGlyMS9taXNzaW5nLnR4dCcsJ2RpcjIvbWlzc2luZy50eHQnLCdkaXIzL2ZpbGU1LnR4dCddLCBmaWxlRXhpc3RzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8gdHJ1ZVxuICogICAgICAgICAvLyByZXN1bHQgaXMgdHJ1ZSBzaW5jZSBzb21lIGZpbGUgaW4gdGhlIGxpc3QgZXhpc3RzXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5zb21lKFsnZGlyMS9taXNzaW5nLnR4dCcsJ2RpcjIvbWlzc2luZy50eHQnLCdkaXI0L21pc3NpbmcudHh0J10sIGZpbGVFeGlzdHMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyBmYWxzZVxuICogICAgICAgICAvLyByZXN1bHQgaXMgZmFsc2Ugc2luY2Ugbm9uZSBvZiB0aGUgZmlsZXMgZXhpc3RzXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBzb21lKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKEJvb2xlYW4sIHJlcyA9PiByZXMpKGVhY2hPZiQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgc29tZSQxID0gYXdhaXRpZnkoc29tZSwgMyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bzb21lYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIHNvbWVMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuc29tZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9XG4gKiBAYWxpYXMgYW55TGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIHNvbWVMaW1pdChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgcmVzID0+IHJlcykoZWFjaE9mTGltaXQkMihsaW1pdCksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBzb21lTGltaXQkMSA9IGF3YWl0aWZ5KHNvbWVMaW1pdCwgNCk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bzb21lYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBzb21lU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX1cbiAqIEBhbGlhcyBhbnlTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHNlcmllcy5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gYHJlc3VsdGAgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jXG4gKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICovXG5mdW5jdGlvbiBzb21lU2VyaWVzKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKEJvb2xlYW4sIHJlcyA9PiByZXMpKGVhY2hPZlNlcmllcyQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgc29tZVNlcmllcyQxID0gYXdhaXRpZnkoc29tZVNlcmllcywgMyk7XG5cbi8qKlxuICogU29ydHMgYSBsaXN0IGJ5IHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBgY29sbGAgdmFsdWUgdGhyb3VnaCBhbiBhc3luY1xuICogYGl0ZXJhdGVlYC5cbiAqXG4gKiBAbmFtZSBzb3J0QnlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIHZhbHVlIHRvIHVzZSBhcyB0aGUgc29ydCBjcml0ZXJpYSBhc1xuICogaXRzIGByZXN1bHRgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyB0aGUgaXRlbXNcbiAqIGZyb20gdGhlIG9yaWdpbmFsIGBjb2xsYCBzb3J0ZWQgYnkgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgYGl0ZXJhdGVlYFxuICogY2FsbHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBiaWdmaWxlLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAyNTExMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gbWVkaXVtZmlsZS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTEwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gc21hbGxmaWxlLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAxMjEgYnl0ZXMgaW4gc2l6ZVxuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpbGUgc2l6ZSBpbiBieXRlc1xuICogZnVuY3Rpb24gZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdC5zaXplKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLnNvcnRCeShbJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCcsJ2JpZ2ZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcyxcbiAqICAgICBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieVxuICogICAgICAgICAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAqICAgICAgICAgICAgIC8vIFsgJ3NtYWxsZmlsZS50eHQnLCAnbWVkaXVtZmlsZS50eHQnLCAnYmlnZmlsZS50eHQnXVxuICogICAgICAgICB9XG4gKiAgICAgfVxuICogKTtcbiAqXG4gKiAvLyBCeSBtb2RpZnlpbmcgdGhlIGNhbGxiYWNrIHBhcmFtZXRlciB0aGVcbiAqIC8vIHNvcnRpbmcgb3JkZXIgY2FuIGJlIGluZmx1ZW5jZWQ6XG4gKlxuICogLy8gYXNjZW5kaW5nIG9yZGVyXG4gKiBhc3luYy5zb3J0QnkoWydtZWRpdW1maWxlLnR4dCcsJ3NtYWxsZmlsZS50eHQnLCdiaWdmaWxlLnR4dCddLCBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaykge1xuICogICAgIGdldEZpbGVTaXplSW5CeXRlcyhmaWxlLCBmdW5jdGlvbihnZXRGaWxlU2l6ZUVyciwgZmlsZVNpemUpIHtcbiAqICAgICAgICAgaWYgKGdldEZpbGVTaXplRXJyKSByZXR1cm4gY2FsbGJhY2soZ2V0RmlsZVNpemVFcnIpO1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCBmaWxlU2l6ZSk7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieVxuICogICAgICAgICAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAqICAgICAgICAgICAgIC8vIFsgJ3NtYWxsZmlsZS50eHQnLCAnbWVkaXVtZmlsZS50eHQnLCAnYmlnZmlsZS50eHQnXVxuICogICAgICAgICB9XG4gKiAgICAgfVxuICogKTtcbiAqXG4gKiAvLyBkZXNjZW5kaW5nIG9yZGVyXG4gKiBhc3luYy5zb3J0QnkoWydiaWdmaWxlLnR4dCcsJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCddLCBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaykge1xuICogICAgIGdldEZpbGVTaXplSW5CeXRlcyhmaWxlLCBmdW5jdGlvbihnZXRGaWxlU2l6ZUVyciwgZmlsZVNpemUpIHtcbiAqICAgICAgICAgaWYgKGdldEZpbGVTaXplRXJyKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZ2V0RmlsZVNpemVFcnIpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbGVTaXplICogLTEpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgICAgIC8vIHJlc3VsdHMgaXMgbm93IHRoZSBvcmlnaW5hbCBhcnJheSBvZiBmaWxlcyBzb3J0ZWQgYnlcbiAqICAgICAgICAgICAgIC8vIGZpbGUgc2l6ZSAoYXNjZW5kaW5nIGJ5IGRlZmF1bHQpLCBlLmcuXG4gKiAgICAgICAgICAgICAvLyBbICdiaWdmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdzbWFsbGZpbGUudHh0J11cbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqICk7XG4gKlxuICogLy8gRXJyb3IgaGFuZGxpbmdcbiAqIGFzeW5jLnNvcnRCeShbJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCcsJ21pc3NpbmdmaWxlLnR4dCddLCBnZXRGaWxlU2l6ZUluQnl0ZXMsXG4gKiAgICAgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKiApO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5zb3J0QnkoWydtZWRpdW1maWxlLnR4dCcsJ3NtYWxsZmlsZS50eHQnLCdiaWdmaWxlLnR4dCddLCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gKiAudGhlbiggcmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieVxuICogICAgIC8vIGZpbGUgc2l6ZSAoYXNjZW5kaW5nIGJ5IGRlZmF1bHQpLCBlLmcuXG4gKiAgICAgLy8gWyAnc21hbGxmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdiaWdmaWxlLnR4dCddXG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gRXJyb3IgaGFuZGxpbmdcbiAqIGFzeW5jLnNvcnRCeShbJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCcsJ21pc3NpbmdmaWxlLnR4dCddLCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gKiAudGhlbiggcmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogKGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnNvcnRCeShbJ2JpZ2ZpbGUudHh0JywnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gKiAgICAgICAgIC8vIGZpbGUgc2l6ZSAoYXNjZW5kaW5nIGJ5IGRlZmF1bHQpLCBlLmcuXG4gKiAgICAgICAgIC8vIFsgJ3NtYWxsZmlsZS50eHQnLCAnbWVkaXVtZmlsZS50eHQnLCAnYmlnZmlsZS50eHQnXVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfSkoKTtcbiAqXG4gKiAvLyBFcnJvciBoYW5kbGluZ1xuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMuc29ydEJ5KFsnbWlzc2luZ2ZpbGUudHh0JywnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gc29ydEJ5IChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICByZXR1cm4gbWFwJDEoY29sbCwgKHgsIGl0ZXJDYikgPT4ge1xuICAgICAgICBfaXRlcmF0ZWUoeCwgKGVyciwgY3JpdGVyaWEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBpdGVyQ2IoZXJyKTtcbiAgICAgICAgICAgIGl0ZXJDYihlcnIsIHt2YWx1ZTogeCwgY3JpdGVyaWF9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgKGVyciwgcmVzdWx0cykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cy5zb3J0KGNvbXBhcmF0b3IpLm1hcCh2ID0+IHYudmFsdWUpKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICB9XG59XG52YXIgc29ydEJ5JDEgPSBhd2FpdGlmeShzb3J0QnksIDMpO1xuXG4vKipcbiAqIFNldHMgYSB0aW1lIGxpbWl0IG9uIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGNhbGxcbiAqIGl0cyBjYWxsYmFjayB3aXRoaW4gdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMsIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYVxuICogdGltZW91dCBlcnJvci4gVGhlIGNvZGUgcHJvcGVydHkgZm9yIHRoZSBlcnJvciBvYmplY3Qgd2lsbCBiZSBgJ0VUSU1FRE9VVCdgLlxuICpcbiAqIEBuYW1lIHRpbWVvdXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGFzeW5jRm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gbGltaXQgaW4gdGltZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXNlY29uZHMgLSBUaGUgc3BlY2lmaWVkIHRpbWUgbGltaXQuXG4gKiBAcGFyYW0geyp9IFtpbmZvXSAtIEFueSB2YXJpYWJsZSB5b3Ugd2FudCBhdHRhY2hlZCAoYHN0cmluZ2AsIGBvYmplY3RgLCBldGMpXG4gKiB0byB0aW1lb3V0IEVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLi5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgd3JhcHBlZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHdpdGggYW55XG4gKiBvZiB0aGUgY29udHJvbCBmbG93IGZ1bmN0aW9ucy5cbiAqIEludm9rZSB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB5b3Ugd291bGQgYGFzeW5jRnVuY2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIG15RnVuY3Rpb24oZm9vLCBjYWxsYmFjaykge1xuICogICAgIGRvQXN5bmNUYXNrKGZvbywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gKiAgICAgICAgIC8vIGhhbmRsZSBlcnJvcnNcbiAqICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gKlxuICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLlxuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHByb2Nlc3NlZCBkYXRhXG4gKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiB2YXIgd3JhcHBlZCA9IGFzeW5jLnRpbWVvdXQobXlGdW5jdGlvbiwgMTAwMCk7XG4gKlxuICogLy8gY2FsbCBgd3JhcHBlZGAgYXMgeW91IHdvdWxkIGBteUZ1bmN0aW9uYFxuICogd3JhcHBlZCh7IGJhcjogJ2JhcicgfSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gKiAgICAgLy8gaWYgYG15RnVuY3Rpb25gIHRha2VzIDwgMTAwMCBtcyB0byBleGVjdXRlLCBgZXJyYFxuICogICAgIC8vIGFuZCBgZGF0YWAgd2lsbCBoYXZlIHRoZWlyIGV4cGVjdGVkIHZhbHVlc1xuICpcbiAqICAgICAvLyBlbHNlIGBlcnJgIHdpbGwgYmUgYW4gRXJyb3Igd2l0aCB0aGUgY29kZSAnRVRJTUVET1VUJ1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQoYXN5bmNGbiwgbWlsbGlzZWNvbmRzLCBpbmZvKSB7XG4gICAgdmFyIGZuID0gd3JhcEFzeW5jKGFzeW5jRm4pO1xuXG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoKGFyZ3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHZhciB0aW1lZE91dCA9IGZhbHNlO1xuICAgICAgICB2YXIgdGltZXI7XG5cbiAgICAgICAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBhc3luY0ZuLm5hbWUgfHwgJ2Fub255bW91cyc7XG4gICAgICAgICAgICB2YXIgZXJyb3IgID0gbmV3IEVycm9yKCdDYWxsYmFjayBmdW5jdGlvbiBcIicgKyBuYW1lICsgJ1wiIHRpbWVkIG91dC4nKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSAnRVRJTUVET1VUJztcbiAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuaW5mbyA9IGluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzLnB1c2goKC4uLmNiQXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aW1lZE91dCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC4uLmNiQXJncyk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2V0dXAgdGltZXIgYW5kIGNhbGwgb3JpZ2luYWwgZnVuY3Rpb25cbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJhbmdlKHNpemUpIHtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkoc2l6ZSk7XG4gICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICByZXN1bHRbc2l6ZV0gPSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgdGltZXNMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMudGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZFxuICovXG5mdW5jdGlvbiB0aW1lc0xpbWl0KGNvdW50LCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgcmV0dXJuIG1hcExpbWl0JDEocmFuZ2UoY291bnQpLCBsaW1pdCwgX2l0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogQ2FsbHMgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24gYG5gIHRpbWVzLCBhbmQgYWNjdW11bGF0ZXMgcmVzdWx0cyBpbiB0aGUgc2FtZVxuICogbWFubmVyIHlvdSB3b3VsZCB1c2Ugd2l0aCBbbWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS5cbiAqXG4gKiBAbmFtZSB0aW1lc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJ1biB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgYG5gIHRpbWVzLlxuICogSW52b2tlZCB3aXRoIHRoZSBpdGVyYXRpb24gaW5kZXggYW5kIGEgY2FsbGJhY2s6IChuLCBuZXh0KS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gc2VlIHtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFByZXRlbmQgdGhpcyBpcyBzb21lIGNvbXBsaWNhdGVkIGFzeW5jIGZhY3RvcnlcbiAqIHZhciBjcmVhdGVVc2VyID0gZnVuY3Rpb24oaWQsIGNhbGxiYWNrKSB7XG4gKiAgICAgY2FsbGJhY2sobnVsbCwge1xuICogICAgICAgICBpZDogJ3VzZXInICsgaWRcbiAqICAgICB9KTtcbiAqIH07XG4gKlxuICogLy8gZ2VuZXJhdGUgNSB1c2Vyc1xuICogYXN5bmMudGltZXMoNSwgZnVuY3Rpb24obiwgbmV4dCkge1xuICogICAgIGNyZWF0ZVVzZXIobiwgZnVuY3Rpb24oZXJyLCB1c2VyKSB7XG4gKiAgICAgICAgIG5leHQoZXJyLCB1c2VyKTtcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgdXNlcnMpIHtcbiAqICAgICAvLyB3ZSBzaG91bGQgbm93IGhhdmUgNSB1c2Vyc1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHRpbWVzIChuLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGltZXNMaW1pdChuLCBJbmZpbml0eSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgdGltZXNTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnRpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqL1xuZnVuY3Rpb24gdGltZXNTZXJpZXMgKG4sIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aW1lc0xpbWl0KG4sIDEsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cblxuLyoqXG4gKiBBIHJlbGF0aXZlIG9mIGByZWR1Y2VgLiAgVGFrZXMgYW4gT2JqZWN0IG9yIEFycmF5LCBhbmQgaXRlcmF0ZXMgb3ZlciBlYWNoXG4gKiBlbGVtZW50IGluIHBhcmFsbGVsLCBlYWNoIHN0ZXAgcG90ZW50aWFsbHkgbXV0YXRpbmcgYW4gYGFjY3VtdWxhdG9yYCB2YWx1ZS5cbiAqIFRoZSB0eXBlIG9mIHRoZSBhY2N1bXVsYXRvciBkZWZhdWx0cyB0byB0aGUgdHlwZSBvZiBjb2xsZWN0aW9uIHBhc3NlZCBpbi5cbiAqXG4gKiBAbmFtZSB0cmFuc2Zvcm1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSB0cmFuc2Zvcm0uICBJZiBvbWl0dGVkLFxuICogaXQgd2lsbCBkZWZhdWx0IHRvIGFuIGVtcHR5IE9iamVjdCBvciBBcnJheSwgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGBjb2xsYFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBjb2xsZWN0aW9uIHRoYXQgcG90ZW50aWFsbHkgbW9kaWZpZXMgdGhlIGFjY3VtdWxhdG9yLlxuICogSW52b2tlZCB3aXRoIChhY2N1bXVsYXRvciwgaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSB0cmFuc2Zvcm1lZCBhY2N1bXVsYXRvci5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZmlsZTEudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDEwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTIudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDIwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTMudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDMwMDAgYnl0ZXMgaW4gc2l6ZVxuICpcbiAqIC8vIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgaHVtYW4tcmVhZGFibGUgc2l6ZSBmb3JtYXQgZnJvbSBieXRlc1xuICogZnVuY3Rpb24gZm9ybWF0Qnl0ZXMoYnl0ZXMsIGRlY2ltYWxzID0gMikge1xuICogICAvLyBpbXBsZW1lbnRhdGlvbiBub3QgaW5jbHVkZWQgZm9yIGJyZXZpdHlcbiAqICAgcmV0dXJuIGh1bWFuUmVhZGJsZUZpbGVzaXplO1xuICogfVxuICpcbiAqIGNvbnN0IGZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlMy50eHQnXTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBmaWxlIHNpemUsIHRyYW5zZm9ybWVkIHRvIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICogLy8gZS5nLiAxMDI0IGJ5dGVzID0gMUtCLCAxMjM0IGJ5dGVzID0gMS4yMSBLQiwgMTA0ODU3NiBieXRlcyA9IDFNQiwgZXRjLlxuICogZnVuY3Rpb24gdHJhbnNmb3JtRmlsZVNpemUoYWNjLCB2YWx1ZSwga2V5LCBjYWxsYmFjaykge1xuICogICAgIGZzLnN0YXQodmFsdWUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBhY2Nba2V5XSA9IGZvcm1hdEJ5dGVzKHN0YXQuc2l6ZSk7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICogICAgIH0pO1xuICogfVxuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMudHJhbnNmb3JtKGZpbGVMaXN0LCB0cmFuc2Zvcm1GaWxlU2l6ZSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICBpZihlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyBbICcxMDAwIEJ5dGVzJywgJzEuOTUgS0InLCAnMi45MyBLQicgXVxuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy50cmFuc2Zvcm0oZmlsZUxpc3QsIHRyYW5zZm9ybUZpbGVTaXplKVxuICogLnRoZW4ocmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIFsgJzEwMDAgQnl0ZXMnLCAnMS45NSBLQicsICcyLjkzIEtCJyBdXG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogKGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMudHJhbnNmb3JtKGZpbGVMaXN0LCB0cmFuc2Zvcm1GaWxlU2l6ZSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIFsgJzEwMDAgQnl0ZXMnLCAnMS45NSBLQicsICcyLjkzIEtCJyBdXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9KSgpO1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZmlsZTEudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDEwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTIudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDIwMDAgYnl0ZXMgaW4gc2l6ZVxuICogLy8gZmlsZTMudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDMwMDAgYnl0ZXMgaW4gc2l6ZVxuICpcbiAqIC8vIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgaHVtYW4tcmVhZGFibGUgc2l6ZSBmb3JtYXQgZnJvbSBieXRlc1xuICogZnVuY3Rpb24gZm9ybWF0Qnl0ZXMoYnl0ZXMsIGRlY2ltYWxzID0gMikge1xuICogICAvLyBpbXBsZW1lbnRhdGlvbiBub3QgaW5jbHVkZWQgZm9yIGJyZXZpdHlcbiAqICAgcmV0dXJuIGh1bWFuUmVhZGJsZUZpbGVzaXplO1xuICogfVxuICpcbiAqIGNvbnN0IGZpbGVNYXAgPSB7IGYxOiAnZmlsZTEudHh0JywgZjI6ICdmaWxlMi50eHQnLCBmMzogJ2ZpbGUzLnR4dCcgfTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBmaWxlIHNpemUsIHRyYW5zZm9ybWVkIHRvIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICogLy8gZS5nLiAxMDI0IGJ5dGVzID0gMUtCLCAxMjM0IGJ5dGVzID0gMS4yMSBLQiwgMTA0ODU3NiBieXRlcyA9IDFNQiwgZXRjLlxuICogZnVuY3Rpb24gdHJhbnNmb3JtRmlsZVNpemUoYWNjLCB2YWx1ZSwga2V5LCBjYWxsYmFjaykge1xuICogICAgIGZzLnN0YXQodmFsdWUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBhY2Nba2V5XSA9IGZvcm1hdEJ5dGVzKHN0YXQuc2l6ZSk7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICogICAgIH0pO1xuICogfVxuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMudHJhbnNmb3JtKGZpbGVNYXAsIHRyYW5zZm9ybUZpbGVTaXplLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGlmKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIHsgZjE6ICcxMDAwIEJ5dGVzJywgZjI6ICcxLjk1IEtCJywgZjM6ICcyLjkzIEtCJyB9XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnRyYW5zZm9ybShmaWxlTWFwLCB0cmFuc2Zvcm1GaWxlU2l6ZSlcbiAqIC50aGVuKHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyB7IGYxOiAnMTAwMCBCeXRlcycsIGYyOiAnMS45NSBLQicsIGYzOiAnMi45MyBLQicgfVxuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMudHJhbnNmb3JtKGZpbGVNYXAsIHRyYW5zZm9ybUZpbGVTaXplKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8geyBmMTogJzEwMDAgQnl0ZXMnLCBmMjogJzEuOTUgS0InLCBmMzogJzIuOTMgS0InIH1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybSAoY29sbCwgYWNjdW11bGF0b3IsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDMgJiYgdHlwZW9mIGFjY3VtdWxhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gaXRlcmF0ZWU7XG4gICAgICAgIGl0ZXJhdGVlID0gYWNjdW11bGF0b3I7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gQXJyYXkuaXNBcnJheShjb2xsKSA/IFtdIDoge307XG4gICAgfVxuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBwcm9taXNlQ2FsbGJhY2soKSk7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG5cbiAgICBlYWNoT2YkMShjb2xsLCAodiwgaywgY2IpID0+IHtcbiAgICAgICAgX2l0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2LCBrLCBjYik7XG4gICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgYWNjdW11bGF0b3IpKTtcbiAgICByZXR1cm4gY2FsbGJhY2tbUFJPTUlTRV9TWU1CT0xdXG59XG5cbi8qKlxuICogSXQgcnVucyBlYWNoIHRhc2sgaW4gc2VyaWVzIGJ1dCBzdG9wcyB3aGVuZXZlciBhbnkgb2YgdGhlIGZ1bmN0aW9ucyB3ZXJlXG4gKiBzdWNjZXNzZnVsLiBJZiBvbmUgb2YgdGhlIHRhc2tzIHdlcmUgc3VjY2Vzc2Z1bCwgdGhlIGBjYWxsYmFja2Agd2lsbCBiZVxuICogcGFzc2VkIHRoZSByZXN1bHQgb2YgdGhlIHN1Y2Nlc3NmdWwgdGFzay4gSWYgYWxsIHRhc2tzIGZhaWwsIHRoZSBjYWxsYmFja1xuICogd2lsbCBiZSBwYXNzZWQgdGhlIGVycm9yIGFuZCByZXN1bHQgKGlmIGFueSkgb2YgdGhlIGZpbmFsIGF0dGVtcHQuXG4gKlxuICogQG5hbWUgdHJ5RWFjaFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZyBmdW5jdGlvbnMgdG9cbiAqIHJ1biwgZWFjaCBmdW5jdGlvbiBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBpdCBtdXN0IGNhbGwgb25cbiAqIGNvbXBsZXRpb24gd2l0aCBhbiBlcnJvciBgZXJyYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIGFuIG9wdGlvbmFsIGByZXN1bHRgXG4gKiB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBvbmVcbiAqIG9mIHRoZSB0YXNrcyBoYXMgc3VjY2VlZGVkLCBvciBhbGwgaGF2ZSBmYWlsZWQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYCBhbmRcbiAqIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIGFzeW5jLnRyeUVhY2goW1xuICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tRmlyc3RXZWJzaXRlKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGZpcnN0IHdlYnNpdGVcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tU2Vjb25kV2Vic2l0ZShjYWxsYmFjaykge1xuICogICAgICAgICAvLyBGaXJzdCB3ZWJzaXRlIGZhaWxlZCxcbiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgYmFja3VwIHdlYnNpdGVcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIE5vdyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS5cbiAqIH0pO1xuICpcbiAqL1xuZnVuY3Rpb24gdHJ5RWFjaCh0YXNrcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIGVhY2hTZXJpZXMkMSh0YXNrcywgKHRhc2ssIHRhc2tDYikgPT4ge1xuICAgICAgICB3cmFwQXN5bmModGFzaykoKGVyciwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHJldHVybiB0YXNrQ2IoZXJyKTtcblxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIFtyZXN1bHRdID0gYXJncztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgdGFza0NiKGVyciA/IG51bGwgOiB7fSk7XG4gICAgICAgIH0pO1xuICAgIH0sICgpID0+IGNhbGxiYWNrKGVycm9yLCByZXN1bHQpKTtcbn1cblxudmFyIHRyeUVhY2gkMSA9IGF3YWl0aWZ5KHRyeUVhY2gpO1xuXG4vKipcbiAqIFVuZG9lcyBhIFttZW1vaXplXXtAbGluayBtb2R1bGU6VXRpbHMubWVtb2l6ZX1kIGZ1bmN0aW9uLCByZXZlcnRpbmcgaXQgdG8gdGhlIG9yaWdpbmFsLFxuICogdW5tZW1vaXplZCBmb3JtLiBIYW5keSBmb3IgdGVzdGluZy5cbiAqXG4gKiBAbmFtZSB1bm1lbW9pemVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSB0aGUgbWVtb2l6ZWQgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIG9yaWdpbmFsIHVubWVtb2l6ZWQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdW5tZW1vaXplKGZuKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikoLi4uYXJncyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXBlYXRlZGx5IGNhbGwgYGl0ZXJhdGVlYCwgd2hpbGUgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW5cbiAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy5cbiAqXG4gKiBAbmFtZSB3aGlsc3RcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGVzdCAtIGFzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lXG4gKiBgdGVzdGAgcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdFxuICogZnVuY3Rpb24gaGFzIGZhaWxlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2BcbiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzXG4gKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGNvdW50ID0gMDtcbiAqIGFzeW5jLndoaWxzdChcbiAqICAgICBmdW5jdGlvbiB0ZXN0KGNiKSB7IGNiKG51bGwsIGNvdW50IDwgNSk7IH0sXG4gKiAgICAgZnVuY3Rpb24gaXRlcihjYWxsYmFjaykge1xuICogICAgICAgICBjb3VudCsrO1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY291bnQpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uIChlcnIsIG4pIHtcbiAqICAgICAgICAgLy8gNSBzZWNvbmRzIGhhdmUgcGFzc2VkLCBuID0gNVxuICogICAgIH1cbiAqICk7XG4gKi9cbmZ1bmN0aW9uIHdoaWxzdCh0ZXN0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrKTtcbiAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICB2YXIgX3Rlc3QgPSB3cmFwQXN5bmModGVzdCk7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyLCAuLi5yZXN0KSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXN1bHRzID0gcmVzdDtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgX3Rlc3QoY2hlY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrKGVyciwgdHJ1dGgpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGlmICghdHJ1dGgpIHJldHVybiBjYWxsYmFjayhudWxsLCAuLi5yZXN1bHRzKTtcbiAgICAgICAgX2ZuKG5leHQpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGVzdChjaGVjayk7XG59XG52YXIgd2hpbHN0JDEgPSBhd2FpdGlmeSh3aGlsc3QsIDMpO1xuXG4vKipcbiAqIFJlcGVhdGVkbHkgY2FsbCBgaXRlcmF0ZWVgIHVudGlsIGB0ZXN0YCByZXR1cm5zIGB0cnVlYC4gQ2FsbHMgYGNhbGxiYWNrYCB3aGVuXG4gKiBzdG9wcGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGBjYWxsYmFja2Agd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueVxuICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzIGNhbGxiYWNrLlxuICpcbiAqIFRoZSBpbnZlcnNlIG9mIFt3aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9LlxuICpcbiAqIEBuYW1lIHVudGlsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy53aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdFxuICogZnVuY3Rpb24gaGFzIHBhc3NlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2BcbiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzXG4gKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG5vdCBwYXNzZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcmVzdWx0cyA9IFtdXG4gKiBsZXQgZmluaXNoZWQgPSBmYWxzZVxuICogYXN5bmMudW50aWwoZnVuY3Rpb24gdGVzdChjYikge1xuICogICAgIGNiKG51bGwsIGZpbmlzaGVkKVxuICogfSwgZnVuY3Rpb24gaXRlcihuZXh0KSB7XG4gKiAgICAgZmV0Y2hQYWdlKHVybCwgKGVyciwgYm9keSkgPT4ge1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpXG4gKiAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChib2R5Lm9iamVjdHMpXG4gKiAgICAgICAgIGZpbmlzaGVkID0gISFib2R5Lm5leHRcbiAqICAgICAgICAgbmV4dChlcnIpXG4gKiAgICAgfSlcbiAqIH0sIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICogICAgIC8vIGFsbCBwYWdlcyBoYXZlIGJlZW4gZmV0Y2hlZFxuICogfSlcbiAqL1xuZnVuY3Rpb24gdW50aWwodGVzdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgX3Rlc3QgPSB3cmFwQXN5bmModGVzdCk7XG4gICAgcmV0dXJuIHdoaWxzdCQxKChjYikgPT4gX3Rlc3QoKGVyciwgdHJ1dGgpID0+IGNiIChlcnIsICF0cnV0aCkpLCBpdGVyYXRlZSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHNlcmllcywgZWFjaCBwYXNzaW5nIHRoZWlyIHJlc3VsdHMgdG9cbiAqIHRoZSBuZXh0IGluIHRoZSBhcnJheS4gSG93ZXZlciwgaWYgYW55IG9mIHRoZSBgdGFza3NgIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXJcbiAqIG93biBjYWxsYmFjaywgdGhlIG5leHQgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhbmQgdGhlIG1haW4gYGNhbGxiYWNrYCBpc1xuICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIEBuYW1lIHdhdGVyZmFsbFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheX0gdGFza3MgLSBBbiBhcnJheSBvZiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufVxuICogdG8gcnVuLlxuICogRWFjaCBmdW5jdGlvbiBzaG91bGQgY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIGByZXN1bHRgIHZhbHVlcy5cbiAqIFRoZSBgcmVzdWx0YCB2YWx1ZXMgd2lsbCBiZSBwYXNzZWQgYXMgYXJndW1lbnRzLCBpbiBvcmRlciwgdG8gdGhlIG5leHQgdGFzay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIFRoaXMgd2lsbCBiZSBwYXNzZWQgdGhlIHJlc3VsdHMgb2YgdGhlIGxhc3QgdGFzaydzXG4gKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJywgJ3R3bycpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICdvbmUnIGFuZCBhcmcyIG5vdyBlcXVhbHMgJ3R3bydcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihhcmcxLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ3RocmVlJ1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZG9uZScpO1xuICogICAgIH1cbiAqIF0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJ1xuICogfSk7XG4gKlxuICogLy8gT3IsIHdpdGggbmFtZWQgZnVuY3Rpb25zOlxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBteUZpcnN0RnVuY3Rpb24sXG4gKiAgICAgbXlTZWNvbmRGdW5jdGlvbixcbiAqICAgICBteUxhc3RGdW5jdGlvbixcbiAqIF0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJ1xuICogfSk7XG4gKiBmdW5jdGlvbiBteUZpcnN0RnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICBjYWxsYmFjayhudWxsLCAnb25lJywgJ3R3bycpO1xuICogfVxuICogZnVuY3Rpb24gbXlTZWNvbmRGdW5jdGlvbihhcmcxLCBhcmcyLCBjYWxsYmFjaykge1xuICogICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nXG4gKiAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gKiB9XG4gKiBmdW5jdGlvbiBteUxhc3RGdW5jdGlvbihhcmcxLCBjYWxsYmFjaykge1xuICogICAgIC8vIGFyZzEgbm93IGVxdWFscyAndGhyZWUnXG4gKiAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gd2F0ZXJmYWxsICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpKTtcbiAgICBpZiAoIXRhc2tzLmxlbmd0aCkgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgdmFyIHRhc2tJbmRleCA9IDA7XG5cbiAgICBmdW5jdGlvbiBuZXh0VGFzayhhcmdzKSB7XG4gICAgICAgIHZhciB0YXNrID0gd3JhcEFzeW5jKHRhc2tzW3Rhc2tJbmRleCsrXSk7XG4gICAgICAgIHRhc2soLi4uYXJncywgb25seU9uY2UobmV4dCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgaWYgKGVyciB8fCB0YXNrSW5kZXggPT09IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRhc2soYXJncyk7XG4gICAgfVxuXG4gICAgbmV4dFRhc2soW10pO1xufVxuXG52YXIgd2F0ZXJmYWxsJDEgPSBhd2FpdGlmeSh3YXRlcmZhbGwpO1xuXG4vKipcbiAqIEFuIFwiYXN5bmMgZnVuY3Rpb25cIiBpbiB0aGUgY29udGV4dCBvZiBBc3luYyBpcyBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gd2l0aFxuICogYSB2YXJpYWJsZSBudW1iZXIgb2YgcGFyYW1ldGVycywgd2l0aCB0aGUgZmluYWwgcGFyYW1ldGVyIGJlaW5nIGEgY2FsbGJhY2suXG4gKiAoYGZ1bmN0aW9uIChhcmcxLCBhcmcyLCAuLi4sIGNhbGxiYWNrKSB7fWApXG4gKiBUaGUgZmluYWwgY2FsbGJhY2sgaXMgb2YgdGhlIGZvcm0gYGNhbGxiYWNrKGVyciwgcmVzdWx0cy4uLilgLCB3aGljaCBtdXN0IGJlXG4gKiBjYWxsZWQgb25jZSB0aGUgZnVuY3Rpb24gaXMgY29tcGxldGVkLiAgVGhlIGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhXG4gKiBFcnJvciBhcyBpdHMgZmlyc3QgYXJndW1lbnQgdG8gc2lnbmFsIHRoYXQgYW4gZXJyb3Igb2NjdXJyZWQuXG4gKiBPdGhlcndpc2UsIGlmIG5vIGVycm9yIG9jY3VycmVkLCBpdCBzaG91bGQgYmUgY2FsbGVkIHdpdGggYG51bGxgIGFzIHRoZSBmaXJzdFxuICogYXJndW1lbnQsIGFuZCBhbnkgYWRkaXRpb25hbCBgcmVzdWx0YCBhcmd1bWVudHMgdGhhdCBtYXkgYXBwbHksIHRvIHNpZ25hbFxuICogc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICogVGhlIGNhbGxiYWNrIG11c3QgYmUgY2FsbGVkIGV4YWN0bHkgb25jZSwgaWRlYWxseSBvbiBhIGxhdGVyIHRpY2sgb2YgdGhlXG4gKiBKYXZhU2NyaXB0IGV2ZW50IGxvb3AuXG4gKlxuICogVGhpcyB0eXBlIG9mIGZ1bmN0aW9uIGlzIGFsc28gcmVmZXJyZWQgdG8gYXMgYSBcIk5vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25cIixcbiAqIG9yIGEgXCJjb250aW51YXRpb24gcGFzc2luZy1zdHlsZSBmdW5jdGlvblwiIChDUFMpLiBNb3N0IG9mIHRoZSBtZXRob2RzIG9mIHRoaXNcbiAqIGxpYnJhcnkgYXJlIHRoZW1zZWx2ZXMgQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLCBvciBmdW5jdGlvbnMgdGhhdFxuICogcmV0dXJuIENQUy9Ob2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9ucy5cbiAqXG4gKiBXaGVyZXZlciB3ZSBhY2NlcHQgYSBOb2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9uLCB3ZSBhbHNvIGRpcmVjdGx5IGFjY2VwdCBhblxuICogW0VTMjAxNyBgYXN5bmNgIGZ1bmN0aW9uXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9TdGF0ZW1lbnRzL2FzeW5jX2Z1bmN0aW9ufS5cbiAqIEluIHRoaXMgY2FzZSwgdGhlIGBhc3luY2AgZnVuY3Rpb24gd2lsbCBub3QgYmUgcGFzc2VkIGEgZmluYWwgY2FsbGJhY2tcbiAqIGFyZ3VtZW50LCBhbmQgYW55IHRocm93biBlcnJvciB3aWxsIGJlIHVzZWQgYXMgdGhlIGBlcnJgIGFyZ3VtZW50IG9mIHRoZVxuICogaW1wbGljaXQgY2FsbGJhY2ssIGFuZCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgYHJlc3VsdGAgdmFsdWUuXG4gKiAoaS5lLiBhIGByZWplY3RlZGAgb2YgdGhlIHJldHVybmVkIFByb21pc2UgYmVjb21lcyB0aGUgYGVycmAgY2FsbGJhY2tcbiAqIGFyZ3VtZW50LCBhbmQgYSBgcmVzb2x2ZWRgIHZhbHVlIGJlY29tZXMgdGhlIGByZXN1bHRgLilcbiAqXG4gKiBOb3RlLCBkdWUgdG8gSmF2YVNjcmlwdCBsaW1pdGF0aW9ucywgd2UgY2FuIG9ubHkgZGV0ZWN0IG5hdGl2ZSBgYXN5bmNgXG4gKiBmdW5jdGlvbnMgYW5kIG5vdCB0cmFuc3BpbGllZCBpbXBsZW1lbnRhdGlvbnMuXG4gKiBZb3VyIGVudmlyb25tZW50IG11c3QgaGF2ZSBgYXN5bmNgL2Bhd2FpdGAgc3VwcG9ydCBmb3IgdGhpcyB0byB3b3JrLlxuICogKGUuZy4gTm9kZSA+IHY3LjYsIG9yIGEgcmVjZW50IHZlcnNpb24gb2YgYSBtb2Rlcm4gYnJvd3NlcikuXG4gKiBJZiB5b3UgYXJlIHVzaW5nIGBhc3luY2AgZnVuY3Rpb25zIHRocm91Z2ggYSB0cmFuc3BpbGVyIChlLmcuIEJhYmVsKSwgeW91XG4gKiBtdXN0IHN0aWxsIHdyYXAgdGhlIGZ1bmN0aW9uIHdpdGggW2FzeW5jaWZ5XXtAbGluayBtb2R1bGU6VXRpbHMuYXN5bmNpZnl9LFxuICogYmVjYXVzZSB0aGUgYGFzeW5jIGZ1bmN0aW9uYCB3aWxsIGJlIGNvbXBpbGVkIHRvIGFuIG9yZGluYXJ5IGZ1bmN0aW9uIHRoYXRcbiAqIHJldHVybnMgYSBwcm9taXNlLlxuICpcbiAqIEB0eXBlZGVmIHtGdW5jdGlvbn0gQXN5bmNGdW5jdGlvblxuICogQHN0YXRpY1xuICovXG5cblxudmFyIGluZGV4ID0ge1xuICAgIGFwcGx5LFxuICAgIGFwcGx5RWFjaCxcbiAgICBhcHBseUVhY2hTZXJpZXMsXG4gICAgYXN5bmNpZnksXG4gICAgYXV0byxcbiAgICBhdXRvSW5qZWN0LFxuICAgIGNhcmdvOiBjYXJnbyQxLFxuICAgIGNhcmdvUXVldWU6IGNhcmdvLFxuICAgIGNvbXBvc2UsXG4gICAgY29uY2F0OiBjb25jYXQkMSxcbiAgICBjb25jYXRMaW1pdDogY29uY2F0TGltaXQkMSxcbiAgICBjb25jYXRTZXJpZXM6IGNvbmNhdFNlcmllcyQxLFxuICAgIGNvbnN0YW50OiBjb25zdGFudCQxLFxuICAgIGRldGVjdDogZGV0ZWN0JDEsXG4gICAgZGV0ZWN0TGltaXQ6IGRldGVjdExpbWl0JDEsXG4gICAgZGV0ZWN0U2VyaWVzOiBkZXRlY3RTZXJpZXMkMSxcbiAgICBkaXIsXG4gICAgZG9VbnRpbCxcbiAgICBkb1doaWxzdDogZG9XaGlsc3QkMSxcbiAgICBlYWNoLFxuICAgIGVhY2hMaW1pdDogZWFjaExpbWl0JDEsXG4gICAgZWFjaE9mOiBlYWNoT2YkMSxcbiAgICBlYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQkMSxcbiAgICBlYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcyQxLFxuICAgIGVhY2hTZXJpZXM6IGVhY2hTZXJpZXMkMSxcbiAgICBlbnN1cmVBc3luYyxcbiAgICBldmVyeTogZXZlcnkkMSxcbiAgICBldmVyeUxpbWl0OiBldmVyeUxpbWl0JDEsXG4gICAgZXZlcnlTZXJpZXM6IGV2ZXJ5U2VyaWVzJDEsXG4gICAgZmlsdGVyOiBmaWx0ZXIkMSxcbiAgICBmaWx0ZXJMaW1pdDogZmlsdGVyTGltaXQkMSxcbiAgICBmaWx0ZXJTZXJpZXM6IGZpbHRlclNlcmllcyQxLFxuICAgIGZvcmV2ZXI6IGZvcmV2ZXIkMSxcbiAgICBncm91cEJ5LFxuICAgIGdyb3VwQnlMaW1pdDogZ3JvdXBCeUxpbWl0JDEsXG4gICAgZ3JvdXBCeVNlcmllcyxcbiAgICBsb2csXG4gICAgbWFwOiBtYXAkMSxcbiAgICBtYXBMaW1pdDogbWFwTGltaXQkMSxcbiAgICBtYXBTZXJpZXM6IG1hcFNlcmllcyQxLFxuICAgIG1hcFZhbHVlcyxcbiAgICBtYXBWYWx1ZXNMaW1pdDogbWFwVmFsdWVzTGltaXQkMSxcbiAgICBtYXBWYWx1ZXNTZXJpZXMsXG4gICAgbWVtb2l6ZSxcbiAgICBuZXh0VGljayxcbiAgICBwYXJhbGxlbCxcbiAgICBwYXJhbGxlbExpbWl0LFxuICAgIHByaW9yaXR5UXVldWUsXG4gICAgcXVldWUsXG4gICAgcmFjZTogcmFjZSQxLFxuICAgIHJlZHVjZTogcmVkdWNlJDEsXG4gICAgcmVkdWNlUmlnaHQsXG4gICAgcmVmbGVjdCxcbiAgICByZWZsZWN0QWxsLFxuICAgIHJlamVjdDogcmVqZWN0JDEsXG4gICAgcmVqZWN0TGltaXQ6IHJlamVjdExpbWl0JDEsXG4gICAgcmVqZWN0U2VyaWVzOiByZWplY3RTZXJpZXMkMSxcbiAgICByZXRyeSxcbiAgICByZXRyeWFibGUsXG4gICAgc2VxLFxuICAgIHNlcmllcyxcbiAgICBzZXRJbW1lZGlhdGU6IHNldEltbWVkaWF0ZSQxLFxuICAgIHNvbWU6IHNvbWUkMSxcbiAgICBzb21lTGltaXQ6IHNvbWVMaW1pdCQxLFxuICAgIHNvbWVTZXJpZXM6IHNvbWVTZXJpZXMkMSxcbiAgICBzb3J0Qnk6IHNvcnRCeSQxLFxuICAgIHRpbWVvdXQsXG4gICAgdGltZXMsXG4gICAgdGltZXNMaW1pdCxcbiAgICB0aW1lc1NlcmllcyxcbiAgICB0cmFuc2Zvcm0sXG4gICAgdHJ5RWFjaDogdHJ5RWFjaCQxLFxuICAgIHVubWVtb2l6ZSxcbiAgICB1bnRpbCxcbiAgICB3YXRlcmZhbGw6IHdhdGVyZmFsbCQxLFxuICAgIHdoaWxzdDogd2hpbHN0JDEsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgYWxsOiBldmVyeSQxLFxuICAgIGFsbExpbWl0OiBldmVyeUxpbWl0JDEsXG4gICAgYWxsU2VyaWVzOiBldmVyeVNlcmllcyQxLFxuICAgIGFueTogc29tZSQxLFxuICAgIGFueUxpbWl0OiBzb21lTGltaXQkMSxcbiAgICBhbnlTZXJpZXM6IHNvbWVTZXJpZXMkMSxcbiAgICBmaW5kOiBkZXRlY3QkMSxcbiAgICBmaW5kTGltaXQ6IGRldGVjdExpbWl0JDEsXG4gICAgZmluZFNlcmllczogZGV0ZWN0U2VyaWVzJDEsXG4gICAgZmxhdE1hcDogY29uY2F0JDEsXG4gICAgZmxhdE1hcExpbWl0OiBjb25jYXRMaW1pdCQxLFxuICAgIGZsYXRNYXBTZXJpZXM6IGNvbmNhdFNlcmllcyQxLFxuICAgIGZvckVhY2g6IGVhY2gsXG4gICAgZm9yRWFjaFNlcmllczogZWFjaFNlcmllcyQxLFxuICAgIGZvckVhY2hMaW1pdDogZWFjaExpbWl0JDEsXG4gICAgZm9yRWFjaE9mOiBlYWNoT2YkMSxcbiAgICBmb3JFYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcyQxLFxuICAgIGZvckVhY2hPZkxpbWl0OiBlYWNoT2ZMaW1pdCQxLFxuICAgIGluamVjdDogcmVkdWNlJDEsXG4gICAgZm9sZGw6IHJlZHVjZSQxLFxuICAgIGZvbGRyOiByZWR1Y2VSaWdodCxcbiAgICBzZWxlY3Q6IGZpbHRlciQxLFxuICAgIHNlbGVjdExpbWl0OiBmaWx0ZXJMaW1pdCQxLFxuICAgIHNlbGVjdFNlcmllczogZmlsdGVyU2VyaWVzJDEsXG4gICAgd3JhcFN5bmM6IGFzeW5jaWZ5LFxuICAgIGR1cmluZzogd2hpbHN0JDEsXG4gICAgZG9EdXJpbmc6IGRvV2hpbHN0JDFcbn07XG5cbmV4cG9ydCB7IGV2ZXJ5JDEgYXMgYWxsLCBldmVyeUxpbWl0JDEgYXMgYWxsTGltaXQsIGV2ZXJ5U2VyaWVzJDEgYXMgYWxsU2VyaWVzLCBzb21lJDEgYXMgYW55LCBzb21lTGltaXQkMSBhcyBhbnlMaW1pdCwgc29tZVNlcmllcyQxIGFzIGFueVNlcmllcywgYXBwbHksIGFwcGx5RWFjaCwgYXBwbHlFYWNoU2VyaWVzLCBhc3luY2lmeSwgYXV0bywgYXV0b0luamVjdCwgY2FyZ28kMSBhcyBjYXJnbywgY2FyZ28gYXMgY2FyZ29RdWV1ZSwgY29tcG9zZSwgY29uY2F0JDEgYXMgY29uY2F0LCBjb25jYXRMaW1pdCQxIGFzIGNvbmNhdExpbWl0LCBjb25jYXRTZXJpZXMkMSBhcyBjb25jYXRTZXJpZXMsIGNvbnN0YW50JDEgYXMgY29uc3RhbnQsIGluZGV4IGFzIGRlZmF1bHQsIGRldGVjdCQxIGFzIGRldGVjdCwgZGV0ZWN0TGltaXQkMSBhcyBkZXRlY3RMaW1pdCwgZGV0ZWN0U2VyaWVzJDEgYXMgZGV0ZWN0U2VyaWVzLCBkaXIsIGRvV2hpbHN0JDEgYXMgZG9EdXJpbmcsIGRvVW50aWwsIGRvV2hpbHN0JDEgYXMgZG9XaGlsc3QsIHdoaWxzdCQxIGFzIGR1cmluZywgZWFjaCwgZWFjaExpbWl0JDEgYXMgZWFjaExpbWl0LCBlYWNoT2YkMSBhcyBlYWNoT2YsIGVhY2hPZkxpbWl0JDEgYXMgZWFjaE9mTGltaXQsIGVhY2hPZlNlcmllcyQxIGFzIGVhY2hPZlNlcmllcywgZWFjaFNlcmllcyQxIGFzIGVhY2hTZXJpZXMsIGVuc3VyZUFzeW5jLCBldmVyeSQxIGFzIGV2ZXJ5LCBldmVyeUxpbWl0JDEgYXMgZXZlcnlMaW1pdCwgZXZlcnlTZXJpZXMkMSBhcyBldmVyeVNlcmllcywgZmlsdGVyJDEgYXMgZmlsdGVyLCBmaWx0ZXJMaW1pdCQxIGFzIGZpbHRlckxpbWl0LCBmaWx0ZXJTZXJpZXMkMSBhcyBmaWx0ZXJTZXJpZXMsIGRldGVjdCQxIGFzIGZpbmQsIGRldGVjdExpbWl0JDEgYXMgZmluZExpbWl0LCBkZXRlY3RTZXJpZXMkMSBhcyBmaW5kU2VyaWVzLCBjb25jYXQkMSBhcyBmbGF0TWFwLCBjb25jYXRMaW1pdCQxIGFzIGZsYXRNYXBMaW1pdCwgY29uY2F0U2VyaWVzJDEgYXMgZmxhdE1hcFNlcmllcywgcmVkdWNlJDEgYXMgZm9sZGwsIHJlZHVjZVJpZ2h0IGFzIGZvbGRyLCBlYWNoIGFzIGZvckVhY2gsIGVhY2hMaW1pdCQxIGFzIGZvckVhY2hMaW1pdCwgZWFjaE9mJDEgYXMgZm9yRWFjaE9mLCBlYWNoT2ZMaW1pdCQxIGFzIGZvckVhY2hPZkxpbWl0LCBlYWNoT2ZTZXJpZXMkMSBhcyBmb3JFYWNoT2ZTZXJpZXMsIGVhY2hTZXJpZXMkMSBhcyBmb3JFYWNoU2VyaWVzLCBmb3JldmVyJDEgYXMgZm9yZXZlciwgZ3JvdXBCeSwgZ3JvdXBCeUxpbWl0JDEgYXMgZ3JvdXBCeUxpbWl0LCBncm91cEJ5U2VyaWVzLCByZWR1Y2UkMSBhcyBpbmplY3QsIGxvZywgbWFwJDEgYXMgbWFwLCBtYXBMaW1pdCQxIGFzIG1hcExpbWl0LCBtYXBTZXJpZXMkMSBhcyBtYXBTZXJpZXMsIG1hcFZhbHVlcywgbWFwVmFsdWVzTGltaXQkMSBhcyBtYXBWYWx1ZXNMaW1pdCwgbWFwVmFsdWVzU2VyaWVzLCBtZW1vaXplLCBuZXh0VGljaywgcGFyYWxsZWwsIHBhcmFsbGVsTGltaXQsIHByaW9yaXR5UXVldWUsIHF1ZXVlLCByYWNlJDEgYXMgcmFjZSwgcmVkdWNlJDEgYXMgcmVkdWNlLCByZWR1Y2VSaWdodCwgcmVmbGVjdCwgcmVmbGVjdEFsbCwgcmVqZWN0JDEgYXMgcmVqZWN0LCByZWplY3RMaW1pdCQxIGFzIHJlamVjdExpbWl0LCByZWplY3RTZXJpZXMkMSBhcyByZWplY3RTZXJpZXMsIHJldHJ5LCByZXRyeWFibGUsIGZpbHRlciQxIGFzIHNlbGVjdCwgZmlsdGVyTGltaXQkMSBhcyBzZWxlY3RMaW1pdCwgZmlsdGVyU2VyaWVzJDEgYXMgc2VsZWN0U2VyaWVzLCBzZXEsIHNlcmllcywgc2V0SW1tZWRpYXRlJDEgYXMgc2V0SW1tZWRpYXRlLCBzb21lJDEgYXMgc29tZSwgc29tZUxpbWl0JDEgYXMgc29tZUxpbWl0LCBzb21lU2VyaWVzJDEgYXMgc29tZVNlcmllcywgc29ydEJ5JDEgYXMgc29ydEJ5LCB0aW1lb3V0LCB0aW1lcywgdGltZXNMaW1pdCwgdGltZXNTZXJpZXMsIHRyYW5zZm9ybSwgdHJ5RWFjaCQxIGFzIHRyeUVhY2gsIHVubWVtb2l6ZSwgdW50aWwsIHdhdGVyZmFsbCQxIGFzIHdhdGVyZmFsbCwgd2hpbHN0JDEgYXMgd2hpbHN0LCBhc3luY2lmeSBhcyB3cmFwU3luYyB9O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5hbWRPID0ge307IiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG1vZHVsZSk7XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRzZXQ6ICgpID0+IHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRVMgTW9kdWxlcyBtYXkgbm90IGFzc2lnbiBtb2R1bGUuZXhwb3J0cyBvciBleHBvcnRzLiosIFVzZSBFU00gZXhwb3J0IHN5bnRheCwgaW5zdGVhZDogJyArIG1vZHVsZS5pZCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCIvLyBMb2FkIHBsdWdpbnNcbmltcG9ydCAnanF1ZXJ5LXRyZW5kJztcbmltcG9ydCAnanF1ZXJ5LXJldmVhbGVyJztcbmltcG9ydCAndmFsaWRldHRhJztcblxuaW1wb3J0IHN0ZW5jaWxVdGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XG5pbXBvcnQgYXN5bmMgZnJvbSAnYXN5bmMnO1xuaW1wb3J0IGFjY291bnQgZnJvbSAnLi90aGVtZS9jb3JlL0FjY291bnQnO1xuaW1wb3J0IGF1dGggZnJvbSAnLi90aGVtZS9BdXRoJztcbmltcG9ydCBibG9nIGZyb20gJy4vdGhlbWUvQmxvZyc7XG5pbXBvcnQgYnJhbmQgZnJvbSAnLi90aGVtZS9CcmFuZCc7XG5pbXBvcnQgYnJhbmRzIGZyb20gJy4vdGhlbWUvQnJhbmRzJztcbmltcG9ydCBjYXJ0IGZyb20gJy4vdGhlbWUvQ2FydCc7XG5pbXBvcnQgQ2F0ZWdvcnkgZnJvbSAnLi90aGVtZS9DYXRlZ29yeSc7XG5pbXBvcnQgY29tcGFyZSBmcm9tICcuL3RoZW1lL0NvbXBhcmUnO1xuaW1wb3J0IGNvbnRhY3RVcyBmcm9tICcuL3RoZW1lL0NvbnRhY3RVcyc7XG5pbXBvcnQgZXJyb3JzIGZyb20gJy4vdGhlbWUvRXJyb3JzJztcbmltcG9ydCBlcnJvcnM0MDQgZnJvbSAnLi90aGVtZS80MDQtZXJyb3InO1xuaW1wb3J0IGdpZnRDZXJ0aWZpY2F0ZSBmcm9tICcuL3RoZW1lL2NvcmUvR2lmdENlcnRpZmljYXRlJztcbmltcG9ydCBnbG9iYWwgZnJvbSAnLi90aGVtZS9HbG9iYWwnO1xuaW1wb3J0IGhvbWUgZnJvbSAnLi90aGVtZS9Ib21lJztcbmltcG9ydCBvcmRlckNvbXBsZXRlIGZyb20gJy4vdGhlbWUvT3JkZXJDb21wbGV0ZSc7XG5pbXBvcnQgcGFnZSBmcm9tICcuL3RoZW1lL1BhZ2UnO1xuaW1wb3J0IHByb2R1Y3QgZnJvbSAnLi90aGVtZS9Qcm9kdWN0JztcbmltcG9ydCBBbXBQcm9kdWN0IGZyb20gJy4vdGhlbWUvQW1wUHJvZHVjdCc7XG5pbXBvcnQgc2VhcmNoIGZyb20gJy4vdGhlbWUvU2VhcmNoJztcbmltcG9ydCBzaXRlbWFwIGZyb20gJy4vdGhlbWUvU2l0ZW1hcCc7XG5pbXBvcnQgc3Vic2NyaWJlIGZyb20gJy4vdGhlbWUvU3Vic2NyaWJlJztcbmltcG9ydCB3aXNobGlzdCBmcm9tICcuL3RoZW1lL1dpc2hsaXN0JztcblxubGV0IFBhZ2VDbGFzc2VzID0ge1xuICBtYXBwaW5nOiB7XG4gICAgJ3BhZ2VzL2FjY291bnQvb3JkZXJzL2FsbCc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvb3JkZXJzL2RldGFpbHMnOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L2FkZHJlc3Nlcyc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvYWRkLWFkZHJlc3MnOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L2FkZC1yZXR1cm4nOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L2FkZC13aXNobGlzdCc6IHdpc2hsaXN0LFxuICAgICdwYWdlcy9hY2NvdW50L2Rvd25sb2FkLWl0ZW0nOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L2VkaXQnOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L2luYm94JzogYWNjb3VudCxcbiAgICAncGFnZXMvYWNjb3VudC9hZGQtcGF5bWVudC1tZXRob2QnOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L2VkaXQtcGF5bWVudC1tZXRob2QnOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L3BheW1lbnQtbWV0aG9kcyc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvcmVjZW50LWl0ZW1zJzogYWNjb3VudCxcbiAgICAncGFnZXMvYWNjb3VudC9yZXR1cm4tc2F2ZWQnOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L3JldHVybnMnOiBhY2NvdW50LFxuICAgICdwYWdlcy9hdXRoL2xvZ2luJzogYXV0aCxcbiAgICAncGFnZXMvYXV0aC9hY2NvdW50LWNyZWF0ZWQnOiBhdXRoLFxuICAgICdwYWdlcy9hdXRoL2NyZWF0ZS1hY2NvdW50JzogYXV0aCxcbiAgICAncGFnZXMvYXV0aC9uZXctcGFzc3dvcmQnOiBhdXRoLFxuICAgICdwYWdlcy9hdXRoL2ZvcmdvdC1wYXNzd29yZCc6IGF1dGgsXG4gICAgJ3BhZ2VzL2Jsb2cnOiBibG9nLFxuICAgICdwYWdlcy9ibG9nLXBvc3QnOiBibG9nLFxuICAgICdwYWdlcy9icmFuZCc6IGJyYW5kLFxuICAgICdwYWdlcy9icmFuZHMnOiBicmFuZCxcbiAgICAncGFnZXMvY2FydCc6IGNhcnQsXG4gICAgJ3BhZ2VzL2NhdGVnb3J5JzogQ2F0ZWdvcnksXG4gICAgJ3BhZ2VzL2NvbXBhcmUnOiBjb21wYXJlLFxuICAgICdwYWdlcy9jb250YWN0LXVzJzogY29udGFjdFVzLFxuICAgICdwYWdlcy9lcnJvcnMnOiBlcnJvcnMsXG4gICAgJ3BhZ2VzL2Vycm9ycy80MDQnOiBlcnJvcnM0MDQsXG4gICAgJ3BhZ2VzL2dpZnQtY2VydGlmaWNhdGUvcHVyY2hhc2UnOiBnaWZ0Q2VydGlmaWNhdGUsXG4gICAgJ3BhZ2VzL2dpZnQtY2VydGlmaWNhdGUvYmFsYW5jZSc6IGdpZnRDZXJ0aWZpY2F0ZSxcbiAgICAncGFnZXMvZ2lmdC1jZXJ0aWZpY2F0ZS9yZWRlZW0nOiBnaWZ0Q2VydGlmaWNhdGUsXG4gICAgJ2dsb2JhbCc6IGdsb2JhbCxcbiAgICAncGFnZXMvaG9tZSc6IGhvbWUsXG4gICAgJ3BhZ2VzL29yZGVyLWNvbXBsZXRlJzogb3JkZXJDb21wbGV0ZSxcbiAgICAncGFnZXMvcGFnZSc6IHBhZ2UsXG4gICAgJ3BhZ2VzL3Byb2R1Y3QnOiBwcm9kdWN0LFxuICAgICdwYWdlcy9zZWFyY2gnOiBzZWFyY2gsXG4gICAgJ3BhZ2VzL3NpdGVtYXAnOiBzaXRlbWFwLFxuICAgICdwYWdlcy9zdWJzY3JpYmVkJzogc3Vic2NyaWJlLFxuICAgICdwYWdlcy9hY2NvdW50L3dpc2hsaXN0LWRldGFpbHMnOiB3aXNobGlzdCxcbiAgICAncGFnZXMvYWNjb3VudC93aXNobGlzdHMnOiB3aXNobGlzdCxcbiAgICAncGFnZXMvYW1wL3Byb2R1Y3Qtb3B0aW9ucyc6IEFtcFByb2R1Y3RcbiAgfSxcbiAgLyoqXG4gICAqIEdldHRlciBtZXRob2QgdG8gZW5zdXJlIGEgZ29vZCBwYWdlIHR5cGUgaXMgYWNjZXNzZWQuXG4gICAqIEBwYXJhbSBwYWdlXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbihwYWdlKSB7XG4gICAgaWYgKHRoaXMubWFwcGluZ1twYWdlXSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwcGluZ1twYWdlXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFnZU9ialxuICovXG5mdW5jdGlvbiBzZXJpZXMocGFnZU9iaikge1xuICBhc3luYy5zZXJpZXMoW1xuICAgIHBhZ2VPYmouYmVmb3JlLmJpbmQocGFnZU9iaiksIC8vIEV4ZWN1dGVkIGZpcnN0IGFmdGVyIGNvbnN0cnVjdG9yKClcbiAgICBwYWdlT2JqLmxvYWRlZC5iaW5kKHBhZ2VPYmopLCAvLyBNYWluIG1vZHVsZSBsb2dpY1xuICAgIHBhZ2VPYmouYWZ0ZXIuYmluZChwYWdlT2JqKSAvLyBDbGVhbiB1cCBtZXRob2QgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlbiBmb3IgY2xlYW51cC5cbiAgXSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBMb2FkcyB0aGUgZ2xvYmFsIG1vZHVsZSB0aGF0IGdldHMgZXhlY3V0ZWQgb24gZXZlcnkgcGFnZSBsb2FkLlxuICogQ29kZSB0aGF0IHlvdSB3YW50IHRvIHJ1biBvbiBldmVyeSBwYWdlIGdvZXMgaW4gdGhlIGdsb2JhbCBtb2R1bGUuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFnZXNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBsb2FkR2xvYmFsKHBhZ2VzKSB7XG4gIGxldCBHbG9iYWwgPSBwYWdlcy5nZXQoJ2dsb2JhbCcpO1xuXG4gIHJldHVybiBuZXcgR2xvYmFsO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYWdlRnVuY1xuICogQHBhcmFtIHt9IHBhZ2VzXG4gKi9cbmZ1bmN0aW9uIGxvYWRlcihwYWdlRnVuYywgcGFnZXMpIHtcbiAgaWYgKHBhZ2VzLmdldCgnZ2xvYmFsJykpIHtcbiAgICBsZXQgZ2xvYmFsUGFnZU1hbmFnZXIgPSBsb2FkR2xvYmFsKHBhZ2VzKTtcbiAgICBnbG9iYWxQYWdlTWFuYWdlci5jb250ZXh0ID0gcGFnZUZ1bmMuY29udGV4dDtcblxuICAgIHNlcmllcyhnbG9iYWxQYWdlTWFuYWdlcik7XG4gIH1cbiAgc2VyaWVzKHBhZ2VGdW5jKTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGdldHMgYWRkZWQgdG8gdGhlIGdsb2JhbCB3aW5kb3cgYW5kIHRoZW4gY2FsbGVkXG4gKiBvbiBwYWdlIGxvYWQgd2l0aCB0aGUgY3VycmVudCB0ZW1wbGF0ZSBsb2FkZWQgYW5kIEpTIENvbnRleHQgcGFzc2VkIGluXG4gKiBAcGFyYW0gdGVtcGxhdGVGaWxlIFN0cmluZ1xuICogQHBhcmFtIGNvbnRleHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG53aW5kb3cuc3RlbmNpbEJvb3RzdHJhcCA9IGZ1bmN0aW9uIHN0ZW5jaWxCb290c3RyYXAodGVtcGxhdGVGaWxlLCBjb250ZXh0KSB7XG4gIGxldCBwYWdlcyA9IFBhZ2VDbGFzc2VzO1xuXG4gIGNvbnRleHQgPSBjb250ZXh0IHx8ICd7fSc7XG4gIGNvbnRleHQgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuXG4gIHJldHVybiB7XG4gICAgbG9hZCgpIHtcbiAgICAgICQoKCkgPT4ge1xuICAgICAgICBsZXQgUGFnZVR5cGVGbiA9IHBhZ2VzLmdldCh0ZW1wbGF0ZUZpbGUpOyAvLyBGaW5kcyB0aGUgYXBwcm9wcmlhdGUgbW9kdWxlIGZyb20gdGhlIHBhZ2VUeXBlIG9iamVjdCBhbmQgc3RvcmUgdGhlIHJlc3VsdCBhcyBhIGZ1bmN0aW9uLlxuXG4gICAgICAgIGlmIChQYWdlVHlwZUZuKSB7XG4gICAgICAgICAgbGV0IHBhZ2VUeXBlID0gbmV3IFBhZ2VUeXBlRm4oKTtcblxuICAgICAgICAgIHBhZ2VUeXBlLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgICAgICAgcmV0dXJuIGxvYWRlcihwYWdlVHlwZSwgcGFnZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRlbXBsYXRlRmlsZSArICcgTW9kdWxlIG5vdCBmb3VuZCcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJQYWdlTWFuYWdlciIsIl9wcm90byIsInByb3RvdHlwZSIsImJlZm9yZSIsIm5leHQiLCJsb2FkZWQiLCJhZnRlciIsInR5cGUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJkZWZhdWx0IiwiRXJyb3JzNDA0IiwiX1BhZ2VNYW5hZ2VyIiwiY2FsbCIsIl9pbmhlcml0c0xvb3NlIiwiQW1wUHJvZHVjdFV0aWxzIiwiQW1wUXVhbnRpdHlXaWRnZXQiLCJpbml0Rm9ybVN3YXRjaEZpZWxkcyIsIkFtcFByb2R1Y3QiLCJjb250ZXh0IiwiX3RoaXMiLCJlbCIsInNjb3BlIiwiUHJvZHVjdFV0aWxzIiwiY2FsbGJhY2tzIiwidGVtcGxhdGUiLCJpbml0IiwiQ29yZUF1dGgiLCJTZWxlY3RXcmFwcGVyIiwiQXV0aCIsIl9Db3JlQXV0aCIsImFwcGx5IiwiYXJndW1lbnRzIiwic2VsZWN0V3JhcENhbGxiYWNrIiwiJHNlbGVjdEVsIiwiQmxvZyIsIkZhY2V0ZWRTZWFyY2giLCJpbml0Q29tcGFyZSIsInVwZGF0ZUNvbXBhcmUiLCJMb2FkaW5nIiwic3ZnSWNvbiIsImZpbGxGYWNldFJhdGluZ1N0YXJzIiwidG9nZ2xlRmFjZXQiLCJCcmFuZCIsIiRib2R5IiwiJCIsImRvY3VtZW50IiwiYm9keSIsImxlbmd0aCIsIl9iaW5kRXZlbnRzIiwiX2luaXRpYWxpemVGYWNldGVkU2VhcmNoIiwibGlzdGluZ1Byb2R1Y3RDb3VudCIsIl90aGlzMiIsIm9uIiwiZXZlbnQiLCJfdG9nZ2xlVmlldyIsInByZXZlbnREZWZhdWx0IiwiY3VycmVudFRhcmdldCIsInRvZ2dsZUNsYXNzIiwicHJvZHVjdENvdW50IiwibG9hZGluZ09wdGlvbnMiLCJsb2FkaW5nTWFya3VwIiwiZmFjZXRlZFNlYXJjaE92ZXJsYXkiLCJmYWNldGVkU2VhcmNoT3B0aW9ucyIsImNvbmZpZyIsImJyYW5kIiwic2hvcF9ieV9wcmljZSIsInByb2R1Y3RzIiwibGltaXQiLCJwcm9kdWN0TGlzdGluZyIsInNpZGViYXIiLCJzaG93TW9yZSIsIndpbGxVcGRhdGUiLCJzaG93IiwiZGlkVXBkYXRlIiwiaGlkZSIsImxpc3RpbmdWaWV3TW9kZSIsIiR0YXJnZXQiLCJkYXRhIiwib3B0aW9ucyIsImFkZENsYXNzIiwic2libGluZ3MiLCJyZW1vdmVDbGFzcyIsIkJyYW5kcyIsInV0aWxzIiwiQ2FydFV0aWxzIiwiU2hpcHBpbmdDYWxjdWxhdG9yIiwiQ291cG9uQ29kZXMiLCJHaWZ0Q2VydGlmaWNhdGVzIiwiR2lmdFdyYXBwaW5nIiwiUXVhbnRpdHlXaWRnZXQiLCJFZGl0T3B0aW9ucyIsIkNhcnQiLCIkY2FydENvbnRlbnQiLCJ3aW5kb3ciLCJBcHBsZVBheVNlc3Npb24iLCJfYWRkVG9DYXJ0IiwiY2FydENvbnRlbnRPdmVybGF5IiwiY2FydFRvdGFsc092ZXJsYXkiLCJ2aXNpYmxlQ2xhc3MiLCJjYXJ0RWRpdE9wdGlvbnMiLCJDYXRlZ29yeSIsImNhdGVnb3J5IiwiQ29tcGFyZSIsIkNvbnRhY3RVcyIsIkVycm9ycyIsIlNjcm9sbExpbmsiLCJGb3JtVmFsaWRhdG9yIiwiRHJvcGRvd24iLCJIZWFkZXIiLCJRdWlja1NlYXJjaCIsIk1pbmlDYXJ0IiwiUXVpY2tTaG9wIiwid2lzaGxpc3REcm9wZG93biIsIk1lZ2FOYXYiLCJNb2JpbGVOYXYiLCJHbG9iYWwiLCJzZWxlY3RvciIsIl90b2dnbGVTY3JvbGxMaW5rIiwiX2luaXRBbmNob3JzIiwiX2luaXRpYWxpemVRdWlja1NlYXJjaCIsInZhbGlkYXRvciIsImluaXRHbG9iYWwiLCJhbmNob3JTZWxlY3RvciIsImVhY2giLCJpbmRleCIsImVsZW1lbnQiLCJ0YXJnZXRJZCIsImF0dHIiLCJ0YXJnZXQiLCJzdWJzdHJpbmciLCJvZmZzZXQiLCJlIiwid2luU2Nyb2xsVG9wIiwic2Nyb2xsVG9wIiwid2luSGVpZ2h0IiwiaGVpZ2h0IiwiVGFicyIsInNsaWNrIiwiaW1hZ2VzTG9hZGVkIiwiSG9tZSIsIl9pbml0U2xpY2siLCJfaW5pdFRhYnMiLCJ0YWJzIiwiYWZ0ZXJTZXR1cCIsImFmdGVyQ2hhbmdlIiwiJGNhcm91c2VsIiwiaXNOYXR1cmFsQXNwZWN0UmF0aW8iLCJoYXNDbGFzcyIsInNwZWVkIiwidHJpZ2dlciIsImRvdHMiLCJmYWRlIiwiYXV0b3BsYXkiLCJhdXRvcGxheVNwZWVkIiwibGF6eUxvYWQiLCJhZGFwdGl2ZUhlaWdodCIsInByZXZBcnJvdyIsIm5leHRBcnJvdyIsImN1cnJlbnRTbGlkZSIsIm5leHRTbGlkZSIsInNldHRpbmdzIiwiaW5maW5pdGUiLCJzbGlkZXNUb1Nob3ciLCJzbGlkZXNUb1Njcm9sbCIsInJlc3BvbnNpdmUiLCJicmVha3BvaW50IiwiJHByb2R1Y3RDYXJvdXNlbCIsIndpZHRoIiwiT3JkZXJDb21wbGV0ZSIsIlBhZ2UiLCJjcmVhdGVXcmFwcGVyRm9yVGFibGUiLCJ0YWJsZSIsIiRwYXJlbnQiLCJwYXJlbnQiLCIkcHJldlNpYmxpbmciLCJwcmV2IiwiJGRpdiIsImFwcGVuZCIsImluc2VydEFmdGVyIiwicHJlcGVuZCIsIkFsZXJ0IiwiUHJvZHVjdEltYWdlcyIsIlByb2R1Y3RSZXZpZXdzIiwiQ29sb3JTd2F0Y2giLCJwcm9kdWN0Vmlld1RlbXBsYXRlcyIsInZhcmlhdGlvbkltZ1ByZXZpZXciLCJmaXRWaWRzIiwiUHJvZHVjdCIsIiRlbCIsInByb2R1Y3RJbWdzIiwiZml0Vmlkc0luaXRpYWxpemVkIiwicHJpY2VXaXRob3V0VGF4VGVtcGxhdGUiLCJwcmljZVdpdGhvdXRUYXgiLCJwcmljZVdpdGhUYXhUZW1wbGF0ZSIsInByaWNlV2l0aFRheCIsInByaWNlU2F2ZWRUZW1wbGF0ZSIsInByaWNlU2F2ZWQiLCJ2YXJpYXRpb25QcmV2aWV3SW1hZ2VUZW1wbGF0ZSIsInZhcmlhdGlvblByZXZpZXdJbWFnZSIsInN3aXRjaEltYWdlIiwic3dhdGNoZXMiLCJhY3RpdmF0ZVRhYiIsInNldFRpbWVvdXQiLCJyZXZlYWxlciIsIl9hY2NvcmRpb25UYWJUb2dnbGUiLCJfdGhpczMiLCJ0YWJJZCIsIl9pbml0VmlkcyIsImtlZXBUYWJzT3BlbiIsImNzcyIsInRhYiIsImZpbmQiLCJkaXNwbGF5VGFiQ29udGVudCIsIlNlYXJjaCIsImxvY2F0aW9uIiwic2VhcmNoIiwiaW5kZXhPZiIsInByb2R1Y3RfcmVzdWx0cyIsIlNpdGVNYXAiLCJTdWJzY3JpYmUiLCJ3aXNobGlzdFBhZ2luYXRpb25IZWxwZXIiLCJXaXNoTGlzdCIsIm9uUmVhZHkiLCJyZWZyZXNoQ29udGVudCIsIm1vZHVsZXMiLCIkYWRkVG9DYXJ0IiwicXVhbnRpdHlJbnB1dCIsImNhcnRBbGVydHMiLCJjYXJ0UHJvbW9zIiwicHJvZHVjdERhdGEiLCJleHRlbmQiLCJjb25zb2xlIiwibG9nIiwiX2NhY2hlSW5pdGlhbFF1YW50aXRpZXMiLCIkZm9ybSIsImNsb3Nlc3QiLCJmb3JtRGF0YSIsInNlcmlhbGl6ZSIsImFwaSIsImNhcnQiLCJpdGVtQWRkIiwiZXJyIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJlcnJvck1lc3NhZ2UiLCJlcnJvcnMiLCJqb2luIiwiZXJyb3IiLCJfYmluZCIsIl9kZWJvdW5jZSIsIl91cGRhdGVDYXJ0SXRlbSIsImV2dCIsIml0ZW1JZCIsInF1YW50aXR5QWx0ZXJlZCIsIm5ld1F1YW50aXR5IiwicGFyc2VJbnQiLCJ2YWwiLCJfcmVtb3ZlQ2FydEl0ZW0iLCJob29rcyIsInJlYWR5IiwiY2FydFV0aWxzIiwiaSIsIiRjYXJ0SXRlbSIsIm9sZFF1YW50aXR5IiwiX3RoaXM0IiwiJHF1YW50aXR5SW5wdXQiLCJpdGVtVXBkYXRlIiwicmVtb3ZlIiwiX3RoaXM1IiwiaXRlbVJlbW92ZSIsImNvdXBvbkFsZXJ0cyIsIiRzY29wZSIsIl9hZGRDb2RlIiwiJGlucHV0IiwiY29kZSIsImNsZWFyIiwiY291cG9uQ29kZUVtcHR5SW5wdXQiLCJhcHBseUNvZGUiLCJNb2RhbCIsIkF0dHJpYnV0ZXNIZWxwZXIiLCJDYXJ0RWRpdE9wdGlvbnMiLCJpZCIsImNhcnRPcHRpb25zTW9kYWwiLCJtb2RhbENsYXNzIiwiYWZ0ZXJTaG93IiwiJG1vZGFsIiwiX2ZldGNoUHJvZHVjdCIsImF0dHJpYnV0ZXNIZWxwZXIiLCJvcGVuIiwiJGl0ZW1JRCIsInByb2R1Y3RBdHRyaWJ1dGVzIiwiY29uZmlndXJlSW5DYXJ0IiwiY29udGVudCIsInBvc2l0aW9uIiwiJHNlbGVjdCIsIm9wdGlvbiIsIiRjaGFuZ2VkT3B0aW9uIiwiJHN1Ym1pdCIsIiRtZXNzYWdlQm94IiwiaXRlbSIsIm9wdGlvbkNoYW5nZSIsInJlc3VsdCIsInVwZGF0ZUF0dHJpYnV0ZXMiLCJwdXJjaGFzaW5nX21lc3NhZ2UiLCJodG1sIiwicHJvcCIsInB1cmNoYXNhYmxlIiwiaW5zdG9jayIsImVtaXQiLCJjZXJ0aWZpY2F0ZUFsZXJ0cyIsIl90b2dnbGUiLCJfaXNWYWxpZENvZGUiLCJnaWZ0Q2VydGlmaWNhdGVJbnB1dEVtcHR5IiwiYXBwbHlHaWZ0Q2VydGlmaWNhdGUiLCJfaW5pdGlhbGl6ZSIsIkdpZnRXcmFwTW9kYWwiLCJfZ2V0Rm9ybSIsIl9iaW5kUGFnZUV2ZW50cyIsImNvbmZpcm0iLCJyZW1vdmVHaWZ0V3JhcCIsImNsb3NlIiwiZ2V0SXRlbUdpZnRXcmFwcGluZ09wdGlvbnMiLCJfYmluZE1vZGFsRXZlbnRzIiwiX3RvZ2dsZVNpbmdsZU11bHRpcGxlIiwidmFsdWUiLCJjaGFuZ2UiLCJhbGxvd01lc3NhZ2UiLCIkc2luZ2xlRm9ybSIsIiRtdWx0aUZvcm0iLCJzaGlwcGluZ0FsZXJ0cyIsIl9jYWxjdWxhdGVTaGlwcGluZyIsIl91cGRhdGVTdGF0ZXMiLCJjb3VudHJ5IiwiJHN0YXRlRWxlbWVudCIsImdldEJ5TmFtZSIsInN0YXRlcyIsInN0YXRlQXJyYXkiLCJwdXNoIiwicHJlZml4Iiwic3RhdGUiLCJyZXBsYWNlV2l0aCIsInNoaXBwaW5nU3RhdGUiLCJwYXJhbXMiLCJjb3VudHJ5X2lkIiwiJGNhbGN1bGF0b3JGb3JtIiwic3RhdGVfaWQiLCJ6aXBfY29kZSIsImdldFNoaXBwaW5nUXVvdGVzIiwiJHNoaXBwaW5nUXVvdGVzIiwicXVvdGVzIiwicXVvdGVJZCIsInN1Ym1pdFNoaXBwaW5nUXVvdGUiLCIkY2FydFRvdGFscyIsIiRjYXJ0UHJvbW9zIiwidG90YWxzIiwicHJvbW9zIiwicmVsb2FkIiwiZ2V0Q29udGVudCIsImNsYXNzZXMiLCJiYXNlIiwiaW5mbyIsInN1Y2Nlc3MiLCJfaXNFbXB0eSIsIl90ZW1wbGF0ZSIsIiRhbGVydCIsIl9kaXNtaXNzTWVzc2FnZSIsIm9uZSIsInRleHQiLCJkaXNtaXNzYWJsZSIsIm1lc3NhZ2UiLCJlcSIsIm1lc3NhZ2VUeXBlIiwibWVzc2FnZVRleHQiLCJpc0Rpc21pc3NhYmxlIiwiJG1vZGFsQm9keSIsImFwcGVuZE1lc3NhZ2UiLCJwcm9kdWN0QWxlcnRzIiwiYWxlcnRzIiwiY250cmwiLCJhY3Rpb24iLCJtaW4iLCJtYXgiLCJJbmZpbml0eSIsIndyYXAiLCJ1cGRhdGVTZWxlY3RUZXh0IiwibmV3T3B0aW9uIiwiaW5pdEFsZXJ0RGlzbWlzc2FibGUiLCJpbml0RG93bmxvYWRHYWxsZXJ5IiwidXBkYXRlU3RhdGUiLCJjcmVkaXRDYXJkVHlwZSIsInN0b3JlSW5zdHJ1bWVudCIsIlZhbGlkYXRvcnMiLCJDQ1ZhbGlkYXRvcnMiLCJGb3JtYXR0ZXJzIiwiQ0NGb3JtYXR0ZXJzIiwiQWNjb3VudCIsIiRwYXltZW50TWV0aG9kRm9ybSIsImluaXRQYXltZW50TWV0aG9kRm9ybVZhbGlkYXRpb24iLCJwYWdlQWxlcnRzIiwiVmFsaWRhdG9yIiwiaW5pdFNpbmdsZSIsIiRyZW9yZGVyRm9ybSIsImluaXRSZW9yZGVyRm9ybSIsInRvZ2dsZSIsImJpbmREZWxldGVQYXltZW50TWV0aG9kIiwic3VibWl0Rm9ybSIsIiRwcm9kdWN0UmVvcmRlckNoZWNrYm94ZXMiLCJwcm9kdWN0Q2hlY2tib3giLCJwcm9kdWN0SWQiLCJmaXJzdE5hbWVMYWJlbCIsImxhc3ROYW1lTGFiZWwiLCJjb21wYW55TGFiZWwiLCJwaG9uZUxhYmVsIiwiYWRkcmVzczFMYWJlbCIsImFkZHJlc3MyTGFiZWwiLCJjaXR5TGFiZWwiLCJjb3VudHJ5TGFiZWwiLCJjaG9vc2VDb3VudHJ5TGFiZWwiLCJzdGF0ZUxhYmVsIiwicG9zdGFsQ29kZUxhYmVsIiwicGF5bWVudE1ldGhvZFNlbGVjdG9yIiwiJGxhc3QiLCJfcmVmIiwiY2FyZFR5cGUiLCJzZXRDcmVkaXRDYXJkTnVtYmVyVmFsaWRhdGlvbiIsImNyZWRpdENhcmROdW1iZXIiLCJzZXRFeHBpcmF0aW9uVmFsaWRhdGlvbiIsImV4cGlyYXRpb24iLCJzZXROYW1lT25DYXJkVmFsaWRhdGlvbiIsIm5hbWVPbkNhcmQiLCJzZXRDdnZWYWxpZGF0aW9uIiwiY3Z2Iiwic2V0Q3JlZGl0Q2FyZE51bWJlckZvcm1hdCIsInNldEV4cGlyYXRpb25Gb3JtYXQiLCIkZm9ybUlzVmFsaWQiLCJfcmVkdWNlIiwic2VyaWFsaXplQXJyYXkiLCJvYmoiLCJyZWZPYmoiLCJfZmluZCIsImNvdW50cmllcyIsIl9yZWYyIiwiX3JlZjMiLCJjb3VudHJ5X2NvZGUiLCJzdGF0ZV9vcl9wcm92aW5jZV9jb2RlIiwiZGVmYXVsdF9pbnN0cnVtZW50IiwiaHJlZiIsInBheW1lbnRNZXRob2RzVXJsIiwiZ2VuZXJpY19lcnJvciIsIkdpZnRDZXJ0aWZpY2F0ZSIsIiRwdXJjaGFzZUZvcm0iLCJfc2hvd1ByZXZpZXciLCJzdG9wUHJvcGFnYXRpb24iLCIkdGhlbWUiLCJiYXNlVXJsIiwidXJsIiwiJHByZXZpZXciLCJzcmMiLCJjb250ZW50RG9jdW1lbnQiLCJjcmVkaXRjYXJkcyIsIm9taXROdWxsU3RyaW5nIiwia2V5IiwiY2FyZCIsInBhcnNlIiwiZG9uZSIsImZhaWwiLCJwYXltZW50c1VybCIsInNob3BwZXJJZCIsInN0b3JlSGFzaCIsInZhdWx0VG9rZW4iLCJwcm92aWRlcl9pZCIsImN1cnJlbmN5X2NvZGUiLCJjcmVkaXRfY2FyZF9udW1iZXIiLCJuYW1lX29uX2NhcmQiLCJhZGRyZXNzMSIsImFkZHJlc3MyIiwiY2l0eSIsInBvc3RhbF9jb2RlIiwiY29tcGFueSIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJlbWFpbCIsInBob25lIiwiZXhwaXJ5Iiwic3BsaXQiLCJhamF4IiwiZGF0YVR5cGUiLCJtZXRob2QiLCJjYWNoZSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiQWNjZXB0IiwiSlNPTiIsInN0cmluZ2lmeSIsImluc3RydW1lbnQiLCJjYXJkaG9sZGVyX25hbWUiLCJudW1iZXIiLCJleHBpcnlfbW9udGgiLCJtb250aCIsImV4cGlyeV95ZWFyIiwieWVhciIsInZlcmlmaWNhdGlvbl92YWx1ZSIsImJpbGxpbmdfYWRkcmVzcyIsImZpZWxkIiwicmVmVGFyZ2V0IiwiZm9ybWF0IiwiX3JlZjQiLCJ3aGljaCIsInRlc3QiLCJzbGljZSIsInJlcGxhY2UiLCJhZGQiLCJ2YWxpZGF0ZSIsImNiIiwiaXNWYWxpZCIsImlzUGFzdCIsImN2YyIsIl9yZWFkT25seUVycm9yIiwiciIsIlR5cGVFcnJvciIsInRyZW5kIiwiQW1wQWxlcnQiLCJidXR0b25EaXNhYmxlZENsYXNzIiwiY2FydEFkZEFsZXJ0IiwiY2FydE9wdGlvbkFsZXJ0IiwiX2JpbmRQcm9kdWN0T3B0aW9uQ2hhbmdlIiwiX2JvdW5kQ2FydENhbGxiYWNrIiwiX2JpbmRDYXJ0QWRkIiwiYmluZCIsIl91cGRhdGVBdHRyaWJ1dGVzIiwiQkNEYXRhIiwicHJvZHVjdF9hdHRyaWJ1dGVzIiwiX2dldFZpZXdNb2RlbCIsImNoYW5nZWRPcHRpb24iLCJwYXJlbnRzIiwiRm9ybURhdGEiLCJ1bmRlZmluZWQiLCJwcm9kdWN0VGVtcGxhdGUiLCJ2aWV3TW9kZWwiLCJfdXBkYXRlUXVhbnRpdHkiLCIkcXVhbnRpdHkiLCJpc05hTiIsImlzIiwiYmVoYXZpb3IiLCJvdXRfb2Zfc3RvY2tfYmVoYXZpb3IiLCJpblN0b2NrSWRzIiwiaW5fc3RvY2tfYXR0cmlidXRlcyIsIm91dE9mU3RvY2tNZXNzYWdlIiwib3V0X29mX3N0b2NrX21lc3NhZ2UiLCJhdHRyaWJ1dGUiLCIkYXR0cmlidXRlIiwiYXR0cklkIiwiX2VuYWJsZUF0dHJpYnV0ZSIsIl9kaXNhYmxlQXR0cmlidXRlIiwiX2dldEF0dHJpYnV0ZVR5cGUiLCJkaXNhYmxlU2VsZWN0T3B0aW9uQXR0cmlidXRlIiwidG9nZ2xlT3B0aW9uIiwiZW5hYmxlU2VsZWN0T3B0aW9uQXR0cmlidXRlIiwicmVtb3ZlQXR0ciIsImZvcm0iLCJ0b3AiLCJ1cmxzQ2FydCIsImdhbGxlcnkiLCIkdGh1bWJzIiwiJGltYWdlIiwiZmllbGRTZWxlY3RvciIsInZhbHVlU2VsZWN0b3IiLCJsYWJlbFNlbGVjdG9yIiwiZm9ybVNlbGVjdGVkVmFsdWUiLCIkbGFiZWwiLCJjdXJyZW50U2VsZWN0RWxlbWVudCIsImRpc2FibGVkU2VsZWN0RWxlbWVudCIsInNlbGVjdEVsZW1lbnQiLCJzZWxlY3RlZE9wdGlvbiIsIiRwcmVmaXgiLCJwcmV2aW91c0luZGV4IiwiYXBwZW5kVG8iLCJwcmVwZW5kVG8iLCJmbiIsInN0YXRlQXNTZWxlY3QiLCJyZXNwb25zZURhdGEiLCJzdGF0ZUF0dHJzIiwidXNlSWQiLCJfaXRlcmF0b3IiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlIiwiX3N0ZXAiLCJvcHRpb25WYWx1ZSIsIiRzdGF0ZVNlbGVjdCIsImNsYXNzIiwic3RhdGVJZCIsInN0YXRlTmFtZSIsInJlcXVpcmVkIiwic3RhdGVBc0lucHV0IiwiJHN0YXRlSW5wdXQiLCJmZXRjaEFuZFVwZGF0ZVN0YXRlSW5wdXQiLCJjYWxsYmFjayIsIiRzdGF0ZVdyYXBwZXIiLCIkbmV3U3RhdGVFbGVtZW50IiwiJG5ld1N0YXRlRWxlbWVudFBhcmVudCIsIiRzZWxlY3RlZFRleHQiLCJ0aW1lb3V0TGVhdmUiLCJkZWxheUxlYXZlIiwiX2hhbmRsZVNjcm9sbCIsIl9oYW5kbGVNb3VzZUVudGVyIiwiX2hhbmRsZU1vdXNlTGVhdmUiLCJfaGlkZUFsbENoaWxkcmVuIiwiX2hhbmRsZVJvb3RJdGVtTW91c2VPdmVyIiwiJGRyb3Bkb3duIiwiJGRyb3Bkb3duUGFuZWwiLCJjbGVhclRpbWVvdXQiLCJub3QiLCIkZmlyc3RUaWVyMiIsImZpcnN0IiwiY2F0ZWdvcnlJZCIsIiRjaGlsZExpc3QiLCIkcm9vdEl0ZW0iLCJyZW1vdmVBY3RpdmUiLCJVcmwiLCJmYWNldFRvZ2dsZSIsIm1vcmVUb2dnbGUiLCJtb3JlRmFjZXRzIiwiX3Nhbml0aXplRmFjZXRzIiwiX29uU3RhdGVDaGFuZ2UiLCJfdG9nZ2xlRmFjZXQiLCJfc2hvd0FkZGl0aW9uYWxGaWx0ZXJzIiwiX3Nob3dNb3JlRmFjZXRzIiwiX29uRmFjZXRDbGljayIsIl9vblJhbmdlU3VibWl0IiwiX29uU29ydEJ5U3VibWl0Iiwib2xkVGFyZ2V0SWQiLCJuZXdUYXJnZXRJZCIsInRvTG93ZXJDYXNlIiwib2xkSHJlZiIsIm5ld0hyZWYiLCIkdG9nZ2xlIiwiJG5hdkxpc3QiLCJmYWNldCIsImZhY2V0VXJsIiwib3JpZ2luIiwicGF0aG5hbWUiLCJsaXN0X2FsbCIsInF1ZXJ5U3RyaW5nIiwidXJsUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiX3N0ZXAkdmFsdWUiLCJnZXRQYWdlIiwiRXJyb3IiLCJjaGlsZHJlbiIsIl9nb1RvVXJsIiwicXVlcnlQYXJhbXMiLCJjdXJyZW50U2VhcmNoIiwicXVlcnkiLCJIaXN0b3J5IiwiZ2V0U3RhdGUiLCJwdXNoU3RhdGUiLCJ0aXRsZSIsIiR3cmFwcGVyIiwiJHNlYXJjaFdyYXAiLCIkaGVhZGVyIiwiJHRvcEJhciIsIiRuYXZCYXIiLCJjYXJ0T3BlbkNsYXNzIiwic2VhcmNoT3BlbkNsYXNzIiwibmF2T3BlbkNsYXNzIiwiJGxvZ2luUmVnaXN0ZXIiLCIkZm9yZ290UGFzc3dvcmQiLCJfYWRqdXN0SGVpZ2h0cyIsIl9oZWFkZXJTY3JvbGwiLCJfdG9nZ2xlTWluaUNhcnQiLCJrZXlDb2RlIiwiX3RvZ2dsZVNlYXJjaCIsIl90b2dnbGVNb2JpbGVOYXYiLCJfaGFuZGxlUmVzaXplIiwicmVzaXplIiwiZm9jdXMiLCJkZWZhdWx0TmF2YmFySGVpZ2h0IiwiJGN1cnJlbnROYXZCYXIiLCJjdXJyZW50TmF2QmFySGVpZ2h0Iiwib3V0ZXJIZWlnaHQiLCIkd2luIiwiJGNhbnZhcyIsImRlZmF1bHRUb3BCYXJIZWlnaHQiLCJ0b3BCYXJIZWlnaHQiLCJkZWZhdWx0RnVsbEhlYWRlckhlaWdodCIsImN1cnJlbnRGdWxsSGVhZGVySGVpZ2h0IiwidG90YWxIZWlnaHQiLCIkbW9iaWxlTmF2IiwiJHJvb3RNZW51IiwiJGNoaWxkQ29udGFpbmVyIiwiJGRyb3Bkb3duVG9nZ2xlIiwiX2ZpbmRDaGlsZEZyb21Sb290IiwiZHJvcGRvd25PcGVuIiwiY2hpbGRUaW1lciIsIl9maW5kQ2hpbGQiLCJjaGlsZElkIiwiX2ZpbmRQYXJlbnQiLCIkbWludXMiLCJwYXJlbnRJZCIsIl9hZGp1c3RNZWdhTmF2UGFuZWwiLCIkbWVnYU5hdlBhbmVsIiwiY2FydENoYW5nZVJlbW90ZUhvb2tzIiwiX3VwZGF0ZSIsIl9yZW1vdmVQcm9kdWN0TWluaUNhcnQiLCJmb3JFYWNoIiwiaG9vayIsIl9iaW5kU2Nyb2xsIiwiJG1pbmlDYXJ0IiwiJG1pbmlDYXJ0VG90YWwiLCIkbWluaUNhcnRDb250ZW50cyIsInN1YnRvdGFsIiwic3VidG90YWxSYXciLCJhbmltYXRlIiwiYWxlcnQiLCJvbGRTY3JvbGxUb3AiLCJtaW5pQ2FydEhlaWdodCIsIm1heFNjcm9sbCIsIm5ld1Njcm9sbFRvcCIsImNhcnRUb3BQb3MiLCJzY3JvbGxBbW91bnQiLCJuYXZUb2dnbGUiLCJwYWdlQ292ZXIiLCIkbWVudSIsIiRuYXZCYWNrQnV0dG9uIiwiZ2V0TWVudXMiLCJ0YXJnZXRNZW51IiwibmF2UGFuZWwiLCJhY3RpdmUiLCJsZWZ0IiwicmlnaHQiLCJmb3JjZVN0YXRlIiwibWVudVN0YXRlIiwiX2luaXRNb2JpbGUiLCJfYmluZE1vYmlsZUV2ZW50cyIsIiRjaGlsZHJlbiIsImNvdW50ZXIiLCJfdHJhdmVyc2VEb3duIiwiX3RyYXZlcnNlQmFjayIsInByZXZNZW51IiwiZmlsdGVyIiwicG9wIiwicHJldkFsbCIsIlByb2R1Y3RDb21wYXJlIiwiY29tcGFyZSIsIm1heEl0ZW1zIiwiaXRlbVRlbXBsYXRlIiwiY29tcGFyZUxpc3QiLCJzaXplIiwicmVtb3ZlQWxsIiwidXBkYXRlQ2hlY2tib3hlcyIsImRlYm91bmNlV2FpdFRpbWUiLCIkcXVpY2tTZWFyY2hSZXN1bHRzIiwiJHF1aWNrU2VhcmNoRm9ybXMiLCIkc2VhcmNoUXVlcnkiLCIkcXVpY2tTZWFyY2hBcmlhTWVzc2FnZSIsInNlYXJjaFJlc3VsdHNWaXNpYmxlIiwiZG9TZWFyY2giLCJzZWFyY2hRdWVyeSIsImVtcHR5IiwiJHF1aWNrU2VhcmNoUmVzdWx0c0N1cnJlbnQiLCIkbm9SZXN1bHRzTWVzc2FnZSIsInJvbGUiLCJwcmVkZWZpbmVkVGV4dCIsIml0ZW1zRm91bmRDb3VudCIsImljb25DbGFzcyIsIiR0cmlnZ2VyIiwiZW5hYmxlQXR0cmlidXRlIiwiZGlzYWJsZUF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZVR5cGUiLCJiaW5kU3dhdGNoRXZlbnQiLCJjbGljayIsIiRzd2F0Y2hUZXh0IiwiJHN3YXRjaFZhbHVlIiwiSW1hZ2Vab29tIiwiZGVmYXVsdEltZyIsIkltYWdlIiwiaW1hZ2UiLCJfem9vbUltYWdlIiwidG9wT2Zmc2V0IiwibGVmdE9mZnNldCIsInBhZ2VZIiwicGFnZVgiLCJiYWd1ZXR0ZUJveCIsIm1heFNsaWRlc0JlZm9yZUFycm93cyIsImNvbnRhaW5lciIsInNsaWRlc1dyYXAiLCJwYWdpbmF0aW9uIiwicGFnaW5hdGlvbkl0ZW0iLCJsb2FkZXIiLCIkcGFnaW5hdGlvbiIsIl9pbml0IiwiYXJyb3dzIiwiYXNOYXZGb3IiLCJpbWFnZUNvdW50IiwiJHNsaWRlcyIsImNlbnRlck1vZGUiLCJ2YXJpYWJsZVdpZHRoIiwicm93cyIsImZvY3VzT25TZWxlY3QiLCJydW4iLCJfYmluZFJhdGluZyIsInJhdGluZyIsInJhdGluZ0xhYmVsIiwiUHJvZ3Jlc3NCdXR0b24iLCJyZXNldFByb2R1Y3RJbWFnZXMiLCJvbkltYWdlU3dpdGNoIiwicHJvZHVjdFRpdGxlIiwiJHByb2R1Y3RDb250YWluZXIiLCJwcm9kdWN0QXR0cmlidXRlc0RhdGEiLCJwcm9ncmVzc0J1dHRvbiIsIl9ib3VuZFByb2R1Y3RPcHRpb25DaGFuZ2UiLCJib3VuZENhcnRDYWxsYmFjayIsIl9iaW5kQWRkVG9DYXJ0IiwiX2NoZWNrUXVhbnRpdHkiLCIkcHJvZHVjdE9wdGlvbnNFbGVtZW50IiwiaGFzT3B0aW9ucyIsImhhc0RlZmF1bHRPcHRpb25zIiwiJHByb2R1Y3RJZCIsImF0dHJpYnV0ZXNEYXRhIiwiYXR0cmlidXRlc0NvbnRlbnQiLCJfdXBkYXRlVmlldyIsIl9iaW5kQWRkV2lzaGxpc3QiLCJkZXN0cm95Iiwib2ZmIiwiJHByaWNlIiwiJHByaWNlV2l0aFRheCIsIiRzYXZlZCIsIiRza3UiLCIkd2VpZ2h0IiwiJGltYWdlUHJldmlldyIsInN0b2NrIiwiJHNlbGVjdG9yIiwiJGxldmVsIiwiZmlsdGVyRW1wdHlGaWxlc0Zyb21Gb3JtIiwiRmlsZSIsImRlbGV0ZSIsImZvcm1Qcm9kdWN0SWQiLCJkYXRhc2V0IiwicHJvZHVjdEF0dHJpYnV0ZXNDb250ZW50Iiwic2V0UHJvZHVjdFZhcmlhbnQiLCJwcmljZVN0cmluZ3MiLCJwcmljZSIsImV4Y2x1ZGluZ1RheCIsInByb2R1Y3RFeGNsdWRpbmdUYXgiLCJzYWxlUHJpY2VMYWJlbCIsIm5vblNhbGVQcmljZUxhYmVsIiwicmV0YWlsUHJpY2VMYWJlbCIsInByaWNlTGFiZWwiLCJpbmNsdWRpbmdUYXgiLCJwcm9kdWN0SW5jbHVkaW5nVGF4Iiwic2F2ZWRTdHJpbmciLCJwcm9kdWN0WW91U2F2ZSIsInNrdSIsIndlaWdodCIsImZvcm1hdHRlZCIsInByb2R1Y3RJbWFnZVVybCIsInRvb2xzIiwiZ2V0U3JjIiwidGhlbWVJbWFnZVNpemVzIiwiem9vbSIsInpvb21JbWFnZVVybCIsInByb2R1Y3QiLCJpbWFnZUlkIiwiYWx0Iiwic3RvY2tfbWVzc2FnZSIsInNvbGRPdXRCdXR0b25MYWJlbCIsImFkZFRvQ2FydEJ1dHRvbkxhYmVsIiwicXVlcnlTZWxlY3RvciIsInF1YW50aXR5IiwicHJvZ3Jlc3MiLCJfcGFyc2VSZXNwb25zZSIsImNvbXBsZXRlIiwibWVzc2FnZXNQcm9kdWN0R2VuZXJhbCIsIm1lc3NhZ2VzUHJvZHVjdEFkZFN1Y2Nlc3NCYWciLCJiYWdMaW5rIiwidXJsc0NoZWNrb3V0IiwiY2hlY2tvdXRMaW5rIiwibWVzc2FnZXNQcm9kdWN0QWRkU3VjY2Vzc0NhcnQiLCJjYXJ0TGluayIsIl90aGlzNiIsIiRidXR0b24iLCJhZGRVcmwiLCJ2aWV3VXJsIiwibWVzc2FnZXNXaXNobGlzdEFkZFN1Y2Nlc3MiLCJtZXNzYWdlc1dpc2hsaXN0QWRkRXJyb3IiLCJ1bnNhdGlzZmllZFJlcXVpcmVkRmllbGRzIiwib3B0aW9uTGFiZWwiLCJpbm5lclRleHQiLCJvcHRpb25UaXRsZSIsInRyaW0iLCJpbmNsdWRlcyIsImdldEF0dHJpYnV0ZSIsImlzU2F0aXNmaWVkIiwiQXJyYXkiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsImV2ZXJ5Iiwic2VsZWN0Iiwic2VsZWN0ZWRJbmRleCIsImRhdGVTdHJpbmciLCJtYXAiLCJ4IiwiY2hlY2tlZCIsImxhYmVsIiwibGFiZWxzIiwicHJvZHVjdFZhcmlhbnQiLCJzb3J0IiwidmlldyIsInByb2R1Y3ROYW1lIiwiUXVpY2tTaG9wTW9kYWwiLCJjZW50ZXJWZXJ0aWNhbGx5IiwiYWZ0ZXJIaWRlIiwiZ2V0QnlJZCIsImQiLCJzIiwianMiLCJmanMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlRWxlbWVudCIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJ2YXJpYXRpb25JbWFnZSIsInZhcmlhdGlvbkltYWdlTmF2Iiwic2Nyb2xsVG9Ub3AiLCJudW1TbGlkZXMiLCJtYWluU2xpZGUiLCJwcm9kdWN0SW1hZ2VTcmMiLCJ6b29tSW1hZ2VTcmMiLCJiYWNrZ3JvdW5kIiwiZHJvcGRvd24iLCJwYW5lbCIsIl90b2dnbGVEcm9wZG93biIsImZvcm1TZWxlY3RvciIsInZhbGlkYXRpb25PcHRpb25zIiwidmFsaWRhdGlvbk1lc3NhZ2VzIiwidmFsaWRhdGlvblJlcXVpcmVkIiwidmFsaWRhdGlvbkVtYWlsIiwidmFsaWRhdGlvbk51bWJlciIsIm51bU1heCIsInZhbGlkYXRpb25OdW1iZXJNYXgiLCJudW1NaW4iLCJ2YWxpZGF0aW9uTnVtYmVyTWluIiwibnVtUmFuZ2UiLCJ2YWxpZGF0aW9uTnVtYmVyUmFuZ2UiLCJtYXhMZW5ndGgiLCJ2YWxpZGF0aW9uTWF4TGVuZ3RoIiwibWluTGVuZ3RoIiwidmFsaWRhdGlvbk1pbkxlbmd0aCIsIm1heENoZWNrZWQiLCJ2YWxpZGF0aW9uTWF4Q2hlY2tlZCIsIm1pbkNoZWNrZWQiLCJ2YWxpZGF0aW9uTWluQ2hlY2tlZCIsIm1heFNlbGVjdGVkIiwidmFsaWRhdGlvbk1heFNlbGVjdGVkIiwibWluU2VsZWN0ZWQiLCJ2YWxpZGF0aW9uTWluU2VsZWN0ZWQiLCJub3RFcXVhbCIsInZhbGlkYXRpb25Ob3RFcXVhbCIsImRpZmZlcmVudCIsInZhbGlkYXRpb25EaWZmZXJlbnQiLCJ2YWxpZGV0dGEiLCJsb2NhbE9wdGlvbnMiLCJjdXN0b21PcHRpb25zIiwicHJvZ3Jlc3NUZXh0Iiwic3Bpbm5lciIsImRlZmF1bHRUZXh0IiwiY2hhbmdlV2lzaGxpc3RQYWdpbmF0aW9uTGlua3MiLCJ3aXNobGlzdFVybCIsIl9sZW4iLCJwYWdpbmF0aW9uSXRlbXMiLCJfa2V5IiwiXyIsIiRpdGVtIiwicGFnZU51bWJlciIsIiRuZXh0SXRlbSIsIiRwcmV2SXRlbSIsImN1cnJlbnRIcmVmIiwicGFydGlhbFBhZ2luYXRpb25VcmwiLCJzaGlmdCIsInJlcXVlc3QiLCJfZGVmYXVsdCIsInZlcnNpb24iLCJyZW1vdGVWZXJzaW9uIiwicmVtb3RlQmFzZUVuZHBvaW50IiwibWFrZVJlcXVlc3QiLCJyZW1vdGUiLCJyZXF1ZXN0T3B0aW9ucyIsInJlbW90ZVJlcXVlc3QiLCJlbmRwb2ludCIsInJlbW90ZVVybCIsIkJvZGxFdmVudHNDYXJ0IiwiQmFzZSIsIkhvb2tzIiwiX0Jhc2UiLCJib2RsRXZlbnRzQ2FydCIsImdldEJvZGxFdmVudHNDYXJ0IiwiZ2V0Q2FydHMiLCJpbmNsdWRlT3B0aW9ucyIsImdldENhcnQiLCJjYXJ0SWQiLCJnZXRDYXJ0U3VtbWFyeSIsImdldENhcnRRdWFudGl0eSIsInRvdGFsX3F1YW50aXR5IiwiaGFuZGxlSXRlbUFkZCIsImVtaXRBZGRJdGVtIiwiZW1pdERhdGEiLCJxdHkiLCJjYWxsYmFja0FyZyIsIml0ZW1zIiwiaXNBcnJheSIsInVwZGF0ZSIsImVtaXRSZW1vdmVJdGVtIiwiaGFuZGxlSXRlbVJlbW92ZSIsIm9wdHMiLCJzdWJtaXRJdGVtR2lmdFdyYXBwaW5nT3B0aW9uIiwicGF5bG9hZCIsInJlbmRlcldpdGgiLCJyZW5kZXJXaXRoQXJnIiwic2hpcHBpbmdfbWV0aG9kIiwiQ291bnRyeUFwaSIsIlByb2R1Y3RBcGkiLCJQcm9kdWN0QXR0cmlidXRlc0FwaSIsIlNlYXJjaEFwaSIsIkNhcnRBcGkiLCJXaXNobGlzdCIsImludGVybmFscyIsImdldFBhZ2VCeUdRTCIsInBhZ2UiLCJ0ZW1wbGF0ZV9uYW1lIiwid2lzaGxpc3QiLCJpbkNhcnRFbmRwb2ludCIsInRlbXBsYXRlQXJnIiwicGFyYW1zQXJnIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwid2lzaGxpc3RJZCIsImNhbGxiYWNrRm4iLCJnZXRCT0RMRXZlbnRzIiwiYm9kbEV2ZW50cyIsImdldEV2ZW50SWQiLCJpc0JPRExFbmFibGVkIiwiQWRkQ2FydEl0ZW1FdmVudCIsIkNSRUFURSIsInNob3VsZEVtaXRSZW1vdmVJdGVtIiwiUmVtb3ZlQ2FydEl0ZW1FdmVudCIsIl9yZXNwb25zZSRkYXRhJGxpbmVfaSIsImxpbmVfaXRlbXMiLCJldmVudE5hbWUiLCJwcmVwYXJlUGF5bG9hZCIsImV2ZW50X2lkIiwiY2hhbm5lbF9pZCIsImN1cnJlbmN5IiwicHJvZHVjdF92YWx1ZSIsIk9iamVjdCIsImFzc2lnbiIsInByb2R1Y3RfaWQiLCJTdHJpbmciLCJ2NCIsInV1aWR2NCIsIkZha2VCT0RMRXZlbnRzIiwiYWRkSXRlbSIsInJlbW92ZUl0ZW0iLCJFdmVudEVtaXR0ZXIiLCJfRXZlbnRFbWl0dGVyIiwic3Vic2NyaWJlIiwiZWxlbWVudFNlbGVjdG9yIiwiaGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJtYXRjaGVzIiwiQmFzZUhvb2tzIiwiX0Jhc2VIb29rcyIsImN1cnJlbmN5U2VsZWN0b3IiLCJzZWFyY2hFdmVudHMiLCJDYXJ0SG9va3MiLCJDb29raWVIb29rcyIsIkN1cnJlbmN5U2VsZWN0b3JIb29rcyIsIlByb2R1Y3RIb29rcyIsIlNlYXJjaEhvb2tzIiwiRmFjZXRlZFNlYXJjaEhvb2tzIiwiU29ydEJ5SG9va3MiLCJjb29raWUiLCJmYWNldGVkU2VhcmNoIiwic29ydEJ5IiwicGFyc2VIb29rcyIsImhvb2tOYW1lIiwiaG9va1R5cGUiLCJvcHRpb25zQ2hhbmdlIiwicXVpY2tTZWFyY2giLCJFbGVtZW50IiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJzb3J0QnlFdmVudHMiLCJkZWZhdWx0UHJldmVudGVkIiwicGFyZW50RWxlbWVudCIsIm5vZGVUeXBlIiwiZW5jb2RlIiwic3RyaW5nIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJzcGxpdE9uRmlyc3QiLCJzZXBhcmF0b3IiLCJzZXBhcmF0b3JJbmRleCIsInNvcnRCeUtleXMiLCJpbnB1dCIsImtleXMiLCJhIiwiYiIsIk51bWJlciIsImdldFBhcnNlZFZhbHVlIiwiYWNjdW11bGF0b3IiLCJjb25jYXQiLCJyZWR1Y2VCeUtleSIsImluY2x1ZGVBcnJheUluZGV4Iiwia2V5T2ZWYWx1ZSIsInJldCIsImNyZWF0ZSIsImlucHV0UGFyc2VkIiwicGFyYW0iLCJfc3BsaXRPbkZpcnN0IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVkdWNlIiwiQm9vbGVhbiIsIm9iamVjdCIsImZpbHRlclZhbHVlcyIsImFycmF5SW5kZXgiLCJvYmplY3RDb3B5Iiwic2hvdWxkRmlsdGVyIiwiaXNWYWxpZEhUVFBNZXRob2QiLCJpc1VzaW5nU2VjdGlvbnMiLCJyZXF1ZXN0ZWRUZW1wbGF0ZSIsImdldFRlbXBsYXRlcyIsInRlbXBsYXRlcyIsInZhbHVlcyIsInJlbGF0aXZlVXJsIiwiZGVmYXVsdE9wdGlvbnMiLCJjc3JmX3Rva2VuIiwidXNpbmdTZWN0aW9ucyIsInVzaW5nVGVtcGxhdGVzIiwicmVuZGVyX3dpdGgiLCJjcmVkZW50aWFscyIsImRlbGltaXRlciIsImZldGNoIiwidGhlbiIsImdldCIsImpzb24iLCJjbGVhbktleSIsInRlbXBsYXRlVmFyaWFibGUiLCJjYXRjaCIsIlN0ZW5jaWxVdGlscyIsInJvb3QiLCJkZWZpbmUiLCJhbWQiLCJzdGVuY2lsVXRpbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwicGF0aCIsImRpbWVuc2lvbnMiLCJzaXplUmVnZXgiLCJnZXRTcmNzZXQiLCJzaXplcyIsImRlc2NyaXB0b3JSZWdleCIsInNyY3NldHMiLCJzb21lIiwiZGVzY3JpcHRvciIsIkltYWdlVG9vbCIsIkltYWdlU3Jjc2V0VG9vbCIsIlN0b3JhZ2VUb29scyIsImltYWdlU3Jjc2V0Iiwic3RvcmFnZSIsInN0b3JhZ2VBdmFpbGFibGUiLCJzZXRJdGVtIiwiRE9NRXhjZXB0aW9uIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiYXN5bmMiLCJhY2NvdW50IiwiYXV0aCIsImJsb2ciLCJicmFuZHMiLCJjb250YWN0VXMiLCJlcnJvcnM0MDQiLCJnaWZ0Q2VydGlmaWNhdGUiLCJnbG9iYWwiLCJob21lIiwib3JkZXJDb21wbGV0ZSIsInNpdGVtYXAiLCJQYWdlQ2xhc3NlcyIsIm1hcHBpbmciLCJzZXJpZXMiLCJwYWdlT2JqIiwibG9hZEdsb2JhbCIsInBhZ2VzIiwicGFnZUZ1bmMiLCJnbG9iYWxQYWdlTWFuYWdlciIsInN0ZW5jaWxCb290c3RyYXAiLCJ0ZW1wbGF0ZUZpbGUiLCJsb2FkIiwiUGFnZVR5cGVGbiIsInBhZ2VUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==