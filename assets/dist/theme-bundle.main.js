/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/js/PageManager.js":
/*!**********************************!*\
  !*** ./assets/js/PageManager.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PageManager)
/* harmony export */ });
var PageManager = /*#__PURE__*/function () {
  function PageManager() {}
  var _proto = PageManager.prototype;
  _proto.before = function before(next) {
    next();
  };
  _proto.loaded = function loaded(next) {
    next();
  };
  _proto.after = function after(next) {
    next();
  };
  _proto.type = function type() {
    return this.constructor.name;
  };
  return PageManager;
}();


/***/ }),

/***/ "./assets/js/theme/404-error.js":
/*!**************************************!*\
  !*** ./assets/js/theme/404-error.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Errors404)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Errors404 = /*#__PURE__*/function (_PageManager) {
  function Errors404() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Errors404, _PageManager);
  return Errors404;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/AmpProduct.js":
/*!***************************************!*\
  !*** ./assets/js/theme/AmpProduct.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AmpProduct)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _core_amp_AmpProductUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/amp/AmpProductUtils */ "./assets/js/theme/core/amp/AmpProductUtils.js");
/* harmony import */ var _core_amp_AmpQuantityWidget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/amp/AmpQuantityWidget */ "./assets/js/theme/core/amp/AmpQuantityWidget.js");
/* harmony import */ var _core_formSelectedValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/formSelectedValue */ "./assets/js/theme/core/formSelectedValue.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }




var AmpProduct = /*#__PURE__*/function (_PageManager) {
  function AmpProduct(context) {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.el = '[data-product-container]';
    return _this;
  }
  _inheritsLoose(AmpProduct, _PageManager);
  var _proto = AmpProduct.prototype;
  _proto.loaded = function loaded() {
    (0,_core_formSelectedValue__WEBPACK_IMPORTED_MODULE_3__["default"])();

    // Qty Control
    new _core_amp_AmpQuantityWidget__WEBPACK_IMPORTED_MODULE_2__["default"]({
      scope: '[data-cart-item-add]'
    });
    this.ProductUtils = new _core_amp_AmpProductUtils__WEBPACK_IMPORTED_MODULE_1__["default"](this.el, {
      callbacks: {},
      template: 'products/add-to-cart-form'
    }).init(this.context);
  };
  return AmpProduct;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Auth.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Auth.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Auth)
/* harmony export */ });
/* harmony import */ var _core_Auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Auth */ "./assets/js/theme/core/Auth.js");
/* harmony import */ var _components_SelectWrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/SelectWrapper */ "./assets/js/theme/components/SelectWrapper.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


var Auth = /*#__PURE__*/function (_CoreAuth) {
  function Auth() {
    return _CoreAuth.apply(this, arguments) || this;
  }
  _inheritsLoose(Auth, _CoreAuth);
  var _proto = Auth.prototype;
  _proto.selectWrapCallback = function selectWrapCallback($selectEl) {
    new _components_SelectWrapper__WEBPACK_IMPORTED_MODULE_1__["default"]($selectEl);
  };
  return Auth;
}(_core_Auth__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Blog.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Blog.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Blog)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Blog = /*#__PURE__*/function (_PageManager) {
  function Blog() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Blog, _PageManager);
  return Blog;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Brand.js":
/*!**********************************!*\
  !*** ./assets/js/theme/Brand.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Brand)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global/FacetedSearch */ "./assets/js/theme/global/FacetedSearch.js");
/* harmony import */ var _global_initCompare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global/initCompare */ "./assets/js/theme/global/initCompare.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./global/svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* harmony import */ var _global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global/fillFacetRatingStars */ "./assets/js/theme/global/fillFacetRatingStars.js");
/* harmony import */ var _global_toggleFacet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global/toggleFacet */ "./assets/js/theme/global/toggleFacet.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }







var Brand = /*#__PURE__*/function (_PageManager) {
  function Brand() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.$body = $(document.body);
    if ($('[data-product-compare]').length) {
      (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.initCompare)();
    }
    _this._bindEvents();
    (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__["default"])();
    return _this;
  }
  _inheritsLoose(Brand, _PageManager);
  var _proto = Brand.prototype;
  _proto.loaded = function loaded(next) {
    this._initializeFacetedSearch(this.context.listingProductCount);
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$body.on('click', '[data-listing-view]', function (event) {
      _this2._toggleView(event);
    });
    this.$body.on('click', '[data-faceted-search-toggle]', function (event) {
      event.preventDefault();
      $(event.currentTarget).toggleClass('is-open').next().toggleClass('visible');
    });
  };
  _proto._initializeFacetedSearch = function _initializeFacetedSearch(productCount) {
    var loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_4__["default"])('spinner') + "</div>"
    };
    var facetedSearchOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_3__["default"](loadingOptions, false, '.product-listing');
    var facetedSearchOptions = {
      config: {
        brand: {
          shop_by_price: true,
          products: {
            limit: productCount
          }
        }
      },
      template: {
        productListing: 'brand/product-listing',
        sidebar: 'brand/sidebar'
      },
      scope: {
        productListing: '[data-brand]',
        sidebar: '[data-brand-sidebar]'
      },
      showMore: 'brand/show-more',
      toggleFacet: function toggleFacet(event) {
        return (0,_global_toggleFacet__WEBPACK_IMPORTED_MODULE_6__["default"])(event);
      },
      callbacks: {
        willUpdate: function willUpdate() {
          facetedSearchOverlay.show();
        },
        didUpdate: function didUpdate() {
          facetedSearchOverlay.hide();
          if ($('[data-product-compare]').length) {
            (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.updateCompare)();
          }
          (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__["default"])();
        }
      }
    };

    // Change teplate option if view mode theme setting is "list"
    if (this.context.listingViewMode === 'list') {
      facetedSearchOptions.template = {
        productListing: 'brand/product-listing-list',
        sidebar: 'brand/sidebar'
      };
    }
    this.FacetedSearch = new _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__["default"](facetedSearchOptions);
  };
  _proto._toggleView = function _toggleView(event) {
    var $target = $(event.currentTarget);
    var template = $target.data('listing-view') === 'grid' ? 'brand/product-listing' : 'brand/product-listing-list';
    var options = {
      template: {
        productListing: template
      }
    };

    // re-init faceted search with new template option
    this.FacetedSearch.init(options);

    // toggle button classes
    $target.addClass('active').siblings().removeClass('active');
  };
  return Brand;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Brands.js":
/*!***********************************!*\
  !*** ./assets/js/theme/Brands.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Brands)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Brands = /*#__PURE__*/function (_PageManager) {
  function Brands() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Brands, _PageManager);
  return Brands;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Cart.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Cart.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Cart)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _cart_CartUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cart/CartUtils */ "./assets/js/theme/cart/CartUtils.js");
/* harmony import */ var _cart_ShippingCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cart/ShippingCalculator */ "./assets/js/theme/cart/ShippingCalculator.js");
/* harmony import */ var _cart_CouponCodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cart/CouponCodes */ "./assets/js/theme/cart/CouponCodes.js");
/* harmony import */ var _cart_GiftCertificates__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cart/GiftCertificates */ "./assets/js/theme/cart/GiftCertificates.js");
/* harmony import */ var _cart_GiftWrapping__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cart/GiftWrapping */ "./assets/js/theme/cart/GiftWrapping.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var _components_QuantityWidget__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/QuantityWidget */ "./assets/js/theme/components/QuantityWidget.js");
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./global/svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* harmony import */ var _cart_EditOptions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cart/EditOptions */ "./assets/js/theme/cart/EditOptions.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }











var Cart = /*#__PURE__*/function (_PageManager) {
  function Cart() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.$cartContent = $('[data-cart-content]');

    // brute-force apple-pay bodyclass in local environment
    if (window.ApplePaySession && $('.dev-environment').length) {
      $(document.body).addClass('apple-pay-supported');
    }
    return _this;
  }
  _inheritsLoose(Cart, _PageManager);
  var _proto = Cart.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    $('body').on('click', '.add-to-cart-button', function (event) {
      return _this2._addToCart(event);
    });
  };
  _proto.loaded = function loaded(next) {
    var context = this.context;
    new _components_QuantityWidget__WEBPACK_IMPORTED_MODULE_8__["default"]({
      scope: '[data-cart-content]'
    });
    var loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_9__["default"])('spinner') + "</div>"
    };
    new _cart_GiftWrapping__WEBPACK_IMPORTED_MODULE_6__["default"]({
      scope: '[data-cart-content]',
      context: context
    });
    var cartContentOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_7__["default"](loadingOptions, true, '.product-listing');
    var cartTotalsOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_7__["default"](loadingOptions, true, '[data-cart-totals]');
    this.ShippingCalculator = new _cart_ShippingCalculator__WEBPACK_IMPORTED_MODULE_3__["default"]('[data-shipping-calculator]', {
      context: context,
      visibleClass: 'visible',
      callbacks: {
        willUpdate: function willUpdate() {
          return cartTotalsOverlay.show();
        },
        didUpdate: function didUpdate() {
          return cartTotalsOverlay.hide();
        }
      }
    });
    this.CouponCodes = new _cart_CouponCodes__WEBPACK_IMPORTED_MODULE_4__["default"]('[data-coupon-codes]', {
      context: context,
      visibleClass: 'visible',
      callbacks: {
        willUpdate: function willUpdate() {
          return cartTotalsOverlay.show();
        },
        didUpdate: function didUpdate() {
          return cartTotalsOverlay.hide();
        }
      }
    });
    this.GiftCertificates = new _cart_GiftCertificates__WEBPACK_IMPORTED_MODULE_5__["default"]('[data-gift-certificates]', {
      context: context,
      visibleClass: 'visible',
      callbacks: {
        willUpdate: function willUpdate() {
          return cartTotalsOverlay.show();
        },
        didUpdate: function didUpdate() {
          return cartTotalsOverlay.hide();
        }
      }
    });
    this.CartUtils = new _cart_CartUtils__WEBPACK_IMPORTED_MODULE_2__["default"]({
      ShippingCalculator: this.ShippingCalculator,
      CouponCodes: this.CouponCodes,
      GiftCertificates: this.GiftCertificates
    }, {
      callbacks: {
        willUpdate: function willUpdate() {
          return cartContentOverlay.show();
        },
        didUpdate: function didUpdate() {
          return cartContentOverlay.hide();
        }
      }
    }).init();
    this.cartEditOptions = new _cart_EditOptions__WEBPACK_IMPORTED_MODULE_10__["default"](this.context, {
      willUpdate: function willUpdate() {
        return cartContentOverlay.show();
      },
      didUpdate: function didUpdate() {
        return cartContentOverlay.hide();
      }
    });
    next();
  };
  return Cart;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Category.js":
/*!*************************************!*\
  !*** ./assets/js/theme/Category.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Category)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global/FacetedSearch */ "./assets/js/theme/global/FacetedSearch.js");
/* harmony import */ var _global_initCompare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global/initCompare */ "./assets/js/theme/global/initCompare.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./global/svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* harmony import */ var _global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global/fillFacetRatingStars */ "./assets/js/theme/global/fillFacetRatingStars.js");
/* harmony import */ var _global_toggleFacet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global/toggleFacet */ "./assets/js/theme/global/toggleFacet.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }







var Category = /*#__PURE__*/function (_PageManager) {
  function Category() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.$body = $(document.body);
    if ($('[data-product-compare]').length) {
      (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.initCompare)();
    }
    _this._bindEvents();
    (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__["default"])();
    return _this;
  }
  _inheritsLoose(Category, _PageManager);
  var _proto = Category.prototype;
  _proto.loaded = function loaded(next) {
    this._initializeFacetedSearch(this.context.listingProductCount);
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$body.on('click', '[data-listing-view]', function (event) {
      _this2._toggleView(event);
    });
    this.$body.on('click', '[data-faceted-search-toggle]', function (event) {
      event.preventDefault();
      $(event.currentTarget).toggleClass('is-open').next().toggleClass('visible');
    });
  };
  _proto._initializeFacetedSearch = function _initializeFacetedSearch(productCount) {
    var loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_4__["default"])('spinner') + "</div>"
    };
    var facetedSearchOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_3__["default"](loadingOptions, false, '.product-listing');
    var facetedSearchOptions = {
      config: {
        category: {
          shop_by_price: true,
          products: {
            limit: productCount
          }
        }
      },
      toggleFacet: function toggleFacet(event) {
        return (0,_global_toggleFacet__WEBPACK_IMPORTED_MODULE_6__["default"])(event);
      },
      showMore: 'category/show-more',
      callbacks: {
        willUpdate: function willUpdate() {
          facetedSearchOverlay.show();
        },
        didUpdate: function didUpdate() {
          facetedSearchOverlay.hide();
          if ($('[data-product-compare]').length) {
            (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.updateCompare)();
          }
          (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_5__["default"])();
        }
      }
    };

    // Add teplate option if view mode theme setting is "list"
    if (this.context.listingViewMode === 'list') {
      facetedSearchOptions.template = {
        productListing: 'category/product-listing-list',
        sidebar: 'category/sidebar'
      };
    }
    this.FacetedSearch = new _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__["default"](facetedSearchOptions);
  };
  _proto._toggleView = function _toggleView(event) {
    var $target = $(event.currentTarget);
    var template = $target.data('listing-view') === 'grid' ? 'category/product-listing' : 'category/product-listing-list';
    var options = {
      template: {
        productListing: template
      }
    };

    // re-init faceted search with new template option
    this.FacetedSearch.init(options);

    // toggle button classes
    $target.addClass('active').siblings().removeClass('active');

    // TODO - possibly add this back after testing in live environ
    // if (typeof(Storage) !== 'undefined') {
    //   localStorage.setItem('listingView', $target.data('listing-view'));
    // }
  };
  return Category;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Compare.js":
/*!************************************!*\
  !*** ./assets/js/theme/Compare.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Compare)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Compare = /*#__PURE__*/function (_PageManager) {
  function Compare() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Compare, _PageManager);
  return Compare;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/ContactUs.js":
/*!**************************************!*\
  !*** ./assets/js/theme/ContactUs.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContactUs)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var ContactUs = /*#__PURE__*/function (_PageManager) {
  function ContactUs() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(ContactUs, _PageManager);
  return ContactUs;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Errors.js":
/*!***********************************!*\
  !*** ./assets/js/theme/Errors.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Errors)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Errors = /*#__PURE__*/function (_PageManager) {
  function Errors() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Errors, _PageManager);
  return Errors;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Global.js":
/*!***********************************!*\
  !*** ./assets/js/theme/Global.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Global)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var bc_scroll_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bc-scroll-link */ "./node_modules/bc-scroll-link/dist/scroll-link.js");
/* harmony import */ var _utils_FormValidator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/FormValidator */ "./assets/js/theme/utils/FormValidator.js");
/* harmony import */ var _global_Dropdown__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./global/Dropdown */ "./assets/js/theme/global/Dropdown.js");
/* harmony import */ var _global_Header__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./global/Header */ "./assets/js/theme/global/Header.js");
/* harmony import */ var _global_quick_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global/quick-search */ "./assets/js/theme/global/quick-search.js");
/* harmony import */ var _global_MiniCart__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global/MiniCart */ "./assets/js/theme/global/MiniCart.js");
/* harmony import */ var _product_QuickShop__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./product/QuickShop */ "./assets/js/theme/product/QuickShop.js");
/* harmony import */ var _product_wishlistDropdown__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./product/wishlistDropdown */ "./assets/js/theme/product/wishlistDropdown.js");
/* harmony import */ var _global_MegaNav__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./global/MegaNav */ "./assets/js/theme/global/MegaNav.js");
/* harmony import */ var _global_MobileNav__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./global/MobileNav */ "./assets/js/theme/global/MobileNav.js");
/* harmony import */ var _core_selectOption__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/selectOption */ "./assets/js/theme/core/selectOption.js");
/* harmony import */ var _core_selectOption__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_core_selectOption__WEBPACK_IMPORTED_MODULE_11__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }





 // Import QuickSearch






var Global = /*#__PURE__*/function (_PageManager) {
  function Global() {
    var _this;
    _this = _PageManager.call(this) || this;
    new _global_Dropdown__WEBPACK_IMPORTED_MODULE_3__["default"]($('.dropdown'));
    new _global_Header__WEBPACK_IMPORTED_MODULE_4__["default"]($('.site-header'));
    new bc_scroll_link__WEBPACK_IMPORTED_MODULE_1__["default"]({
      selector: '.button-top'
    });
    new _global_MegaNav__WEBPACK_IMPORTED_MODULE_9__["default"]($('.mega-nav-variant-container'));
    new _global_MobileNav__WEBPACK_IMPORTED_MODULE_10__["default"]();
    new _global_MiniCart__WEBPACK_IMPORTED_MODULE_6__["default"]();
    new _product_wishlistDropdown__WEBPACK_IMPORTED_MODULE_8__["default"]();
    _this._toggleScrollLink();
    _this._initAnchors();
    _this._initializeQuickSearch(); // Initialize quick search
    return _this;
  }

  /**
   * You can wrap the execution in this method with an asynchronous function map using the async library
   * if your global modules need async callback handling.
   * @param next
   */
  _inheritsLoose(Global, _PageManager);
  var _proto = Global.prototype;
  _proto.loaded = function loaded(next) {
    // global form validation
    this.validator = new _utils_FormValidator__WEBPACK_IMPORTED_MODULE_2__["default"](this.context);
    this.validator.initGlobal();

    // QuickShop
    if ($('[data-quick-shop]').length) {
      new _product_QuickShop__WEBPACK_IMPORTED_MODULE_7__["default"](this.context);
    }
    next();
  };
  _proto._initAnchors = function _initAnchors() {
    var anchorSelector = '.cms-page [href^="#"]';
    $(anchorSelector).each(function (index, element) {
      var targetId = $(element).attr('href');
      var target = targetId.substring(1);
      $(element).attr('data-scroll', targetId);
      $("[name='" + target + "']").attr('id', target);
    });
    new bc_scroll_link__WEBPACK_IMPORTED_MODULE_1__["default"]({
      selector: anchorSelector,
      offset: -150
    });
  };
  _proto._toggleScrollLink = function _toggleScrollLink() {
    $(window).on('scroll', function (e) {
      var winScrollTop = $(e.currentTarget).scrollTop();
      var winHeight = $(window).height();
      if (winScrollTop > winHeight) {
        $('.button-top').addClass('show');
      } else {
        $('.button-top').removeClass('show');
      }
    });
  };
  _proto._initializeQuickSearch = function _initializeQuickSearch() {
    new _global_quick_search__WEBPACK_IMPORTED_MODULE_5__["default"](); // Initialize quick search
  };
  return Global;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Home.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Home.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Home)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _product_ProductUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./product/ProductUtils */ "./assets/js/theme/product/ProductUtils.js");
/* harmony import */ var bc_tabs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bc-tabs */ "./node_modules/bc-tabs/dist/tabs.js");
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! slick-carousel */ "./node_modules/slick-carousel/slick/slick.js");
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(slick_carousel__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_4__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }





var Home = /*#__PURE__*/function (_PageManager) {
  function Home() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Home, _PageManager);
  var _proto = Home.prototype;
  _proto.loaded = function loaded(next) {
    this._initSlick();
    this._initTabs();
    next();
  };
  _proto._initTabs = function _initTabs() {
    this.tabs = new bc_tabs__WEBPACK_IMPORTED_MODULE_2__["default"]({
      afterSetup: function afterSetup() {
        $('.product-carousel').slick('setPosition');
      },
      afterChange: function afterChange() {
        $('.product-carousel').slick('setPosition');
      }
    });
  };
  _proto._initSlick = function _initSlick() {
    // Hero carousel
    var $carousel = $('.carousel');
    var isNaturalAspectRatio = $carousel.hasClass('ratio-natural');
    var speed = $carousel.data('swap-frequency');
    $carousel.on('init', function (event, slick) {
      $('.slick-active .carousel-item-info:has(*)').addClass('show');
      // Fix misalignment because no scrollbar on load
      $(window).trigger('resize');
    }).slick({
      dots: true,
      fade: true,
      autoplay: true,
      autoplaySpeed: speed,
      lazyLoad: 'progressive',
      adaptiveHeight: true,
      prevArrow: '<span class="carousel-navigation-item previous"><svg class="icon icon-arrow-left"><use xlink:href="#icon-arrow-left" /></svg></span>',
      nextArrow: '<span class="carousel-navigation-item next"><svg class="icon icon-arrow-right"><use xlink:href="#icon-arrow-right" /></svg></span>'
    }).on('beforeChange', function (event, slick, currentSlide, nextSlide) {
      $('.slick-active .carousel-item-info:has(*)').removeClass('show');
    }).on('afterChange', function (event, slick, currentSlide) {
      $('.slick-active .carousel-item-info:has(*)').addClass('show');
    });
    var settings = {
      infinite: true,
      slidesToShow: 4,
      slidesToScroll: 4,
      autoplaySpeed: 3000,
      // Autoplay speed in milliseconds (3 seconds)
      autoplay: true,
      // Enable autoplay
      lazyLoad: 'progressive',
      speed: 800,
      prevArrow: '<span class="carousel-navigation-item previous"><svg class="icon icon-arrow-left"><use xlink:href="#icon-arrow-left" /></svg></span>',
      nextArrow: '<span class="carousel-navigation-item next"><svg class="icon icon-arrow-right"><use xlink:href="#icon-arrow-right" /></svg></span>',
      responsive: [{
        breakpoint: 1024,
        settings: {
          slidesToShow: 3,
          slidesToScroll: 3,
          autoplay: false
        }
      }, {
        breakpoint: 768,
        settings: {
          slidesToShow: 2,
          slidesToScroll: 2,
          autoplay: true
        }
      }, {
        breakpoint: 480,
        settings: {
          slidesToShow: 2,
          slidesToScroll: 2,
          autoplay: true
        }
      }]
    };
    var $productCarousel = $('.product-carousel');
    $productCarousel.slick(settings);
    $(window).on('resize', function () {
      if ($(this).width() > 420 && !$productCarousel.hasClass('slick-initialized')) {
        $productCarousel.slick(settings);
      }
    });
  };
  return Home;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/OrderComplete.js":
/*!******************************************!*\
  !*** ./assets/js/theme/OrderComplete.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OrderComplete)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var OrderComplete = /*#__PURE__*/function (_PageManager) {
  function OrderComplete() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(OrderComplete, _PageManager);
  return OrderComplete;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Page.js":
/*!*********************************!*\
  !*** ./assets/js/theme/Page.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Page)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Page = /*#__PURE__*/function (_PageManager) {
  function Page() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.createWrapperForTable();
    return _this;
  }
  _inheritsLoose(Page, _PageManager);
  var _proto = Page.prototype;
  _proto.createWrapperForTable = function createWrapperForTable() {
    $('table', '.page-content').each(function (index, table) {
      var $parent = $(table).parent();
      var $prevSibling = $(table).prev();
      var $div = $('<div/>').addClass('horizontal-scrollbar').append(table);
      if ($prevSibling.length) {
        $div.insertAfter($prevSibling);
      } else {
        $parent.prepend($div);
      }
    });
  };
  return Page;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Product.js":
/*!************************************!*\
  !*** ./assets/js/theme/Product.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Product)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _product_ProductUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./product/ProductUtils */ "./assets/js/theme/product/ProductUtils.js");
/* harmony import */ var _product_ProductImages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./product/ProductImages */ "./assets/js/theme/product/ProductImages.js");
/* harmony import */ var _product_ProductReviews__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./product/ProductReviews */ "./assets/js/theme/product/ProductReviews.js");
/* harmony import */ var _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./product/ColorSwatch */ "./assets/js/theme/product/ColorSwatch.js");
/* harmony import */ var _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./product/productViewTemplates */ "./assets/js/theme/product/productViewTemplates.js");
/* harmony import */ var _product_variationImgPreview__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./product/variationImgPreview */ "./assets/js/theme/product/variationImgPreview.js");
/* harmony import */ var bc_tabs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! bc-tabs */ "./node_modules/bc-tabs/dist/tabs.js");
/* harmony import */ var fitvids__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! fitvids */ "./node_modules/fitvids/index.js");
/* harmony import */ var fitvids__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(fitvids__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var bc_scroll_link__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! bc-scroll-link */ "./node_modules/bc-scroll-link/dist/scroll-link.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }











var Product = /*#__PURE__*/function (_PageManager) {
  function Product() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.el = '[data-product-container]';
    _this.$el = $(_this.el);
    _this.productImgs = '.product-slides-wrap';
    _this.fitVidsInitialized = false;
    new _components_Alert__WEBPACK_IMPORTED_MODULE_1__["default"]($('[data-alerts]'));
    new bc_scroll_link__WEBPACK_IMPORTED_MODULE_10__["default"]({
      selector: '.accordion-title a',
      offset: -117
    });
    new bc_scroll_link__WEBPACK_IMPORTED_MODULE_10__["default"]({
      selector: '.reviews-jumplink'
    });
    return _this;
  }
  _inheritsLoose(Product, _PageManager);
  var _proto = Product.prototype;
  _proto.loaded = function loaded(next) {
    // Product Utils
    this.ProductUtils = new _product_ProductUtils__WEBPACK_IMPORTED_MODULE_2__["default"](this.el, {
      priceWithoutTaxTemplate: _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__["default"].priceWithoutTax,
      priceWithTaxTemplate: _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__["default"].priceWithTax,
      priceSavedTemplate: _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__["default"].priceSaved,
      variationPreviewImageTemplate: _product_productViewTemplates__WEBPACK_IMPORTED_MODULE_6__["default"].variationPreviewImage,
      callbacks: {
        switchImage: _product_variationImgPreview__WEBPACK_IMPORTED_MODULE_7__["default"]
      }
    }).init(this.context);

    // Product Images
    new _product_ProductImages__WEBPACK_IMPORTED_MODULE_3__["default"](this.productImgs);

    // Product Swatches
    this.swatches = new _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_5__["default"](); // Init our color swatches

    // Reviews
    new _product_ProductReviews__WEBPACK_IMPORTED_MODULE_4__["default"](this.context);

    // Product UI
    this._bindEvents();
    this._initTabs();
    this._initSlick();
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    // Activate the reviews tab when we jump down to it
    $('.product-reviews-link').on('click', function () {
      _this2.tabs.activateTab('#product-reviews');
      $('.accordion-title').removeClass('is-open');
      $('[href="#product-reviews"]').parent('.accordion-title').addClass('is-open');
    });

    // Show all the reviews
    $('.reviews-show-more-link').on('click', function (event) {
      event.preventDefault();
      $('.review-item.hidden').each(function (index, el) {
        setTimeout(function () {
          $(el).revealer('show');
        }, index * 250);
      });
      $(event.currentTarget).hide();
    });
    $('.accordion-title').on('click', function (event) {
      event.preventDefault();
      _this2._accordionTabToggle(event);
    });
  };
  _proto._initTabs = function _initTabs() {
    var _this3 = this;
    if ($('[data-tab-link]').length) {
      this.tabs = new bc_tabs__WEBPACK_IMPORTED_MODULE_8__["default"]({
        afterSetup: function afterSetup(tabId) {
          _this3._initVids(tabId);
          $('.tab-content-panel.active').prev('.accordion-title').addClass('is-open');
        },
        afterChange: function afterChange(tabId) {
          _this3._initVids(tabId);
        },
        keepTabsOpen: function keepTabsOpen() {
          return false;
        }
      });
    } else {
      $('.product-tabs').css('display', 'none');
    }
  }

  // Add accordion style buttons to toggle tab panels
  ;
  _proto._accordionTabToggle = function _accordionTabToggle(event) {
    var tab = $(event.currentTarget).find('a').attr('href');
    $(event.currentTarget).addClass('is-open').siblings('.accordion-title').removeClass('is-open');
    this.tabs.displayTabContent(tab);
  }

  // if page loads with tabs hidden, we need to wait until the proper tab is clicked before running fitVids.
  ;
  _proto._initVids = function _initVids(tabId) {
    if (tabId == '#product-videos' && !this.fitVidsInitialized) {
      fitvids__WEBPACK_IMPORTED_MODULE_9___default()('.product-videos-list');
      this.fitVidsInitialized = true;
    }
  };
  _proto._initSlick = function _initSlick() {
    // Related Product carousels
    $('.product-carousel').slick({
      infinite: true,
      slidesToShow: 4,
      slidesToScroll: 4,
      autoplaySpeed: 4000,
      speed: 800,
      prevArrow: '<span class="carousel-navigation-item previous"><svg class="icon icon-arrow-left"><use xlink:href="#icon-arrow-left" /></svg></span>',
      nextArrow: '<span class="carousel-navigation-item next"><svg class="icon icon-arrow-right"><use xlink:href="#icon-arrow-right" /></svg></span>',
      responsive: [{
        breakpoint: 1024,
        settings: {
          slidesToShow: 3,
          slidesToScroll: 3,
          autoplay: false
        }
      }, {
        breakpoint: 768,
        settings: {
          slidesToShow: 2,
          slidesToScroll: 2,
          autoplay: true
        }
      }, {
        breakpoint: 480,
        settings: {
          slidesToShow: 1,
          slidesToScroll: 1,
          autoplay: true
        }
      }]
    });
  };
  return Product;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Search.js":
/*!***********************************!*\
  !*** ./assets/js/theme/Search.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Search)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global/FacetedSearch */ "./assets/js/theme/global/FacetedSearch.js");
/* harmony import */ var _global_initCompare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global/initCompare */ "./assets/js/theme/global/initCompare.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var bc_tabs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bc-tabs */ "./node_modules/bc-tabs/dist/tabs.js");
/* harmony import */ var _global_MiniCart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global/MiniCart */ "./assets/js/theme/global/MiniCart.js");
/* harmony import */ var _global_quick_search__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global/quick-search */ "./assets/js/theme/global/quick-search.js");
/* harmony import */ var _global_Dropdown__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./global/Dropdown */ "./assets/js/theme/global/Dropdown.js");
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./global/svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* harmony import */ var _global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./global/fillFacetRatingStars */ "./assets/js/theme/global/fillFacetRatingStars.js");
/* harmony import */ var _global_toggleFacet__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./global/toggleFacet */ "./assets/js/theme/global/toggleFacet.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }






 // Import QuickSearch




var Search = /*#__PURE__*/function (_PageManager) {
  function Search() {
    var _this;
    _this = _PageManager.call(this) || this;
    new _global_Dropdown__WEBPACK_IMPORTED_MODULE_7__["default"]($('.dropdown'));
    new _global_MiniCart__WEBPACK_IMPORTED_MODULE_5__["default"]();
    _this.$body = $(document.body);
    if ($('[data-product-compare]').length) {
      (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.initCompare)();
    }
    _this._bindEvents();
    _this._initTabs();
    _this._initializeQuickSearch();
    (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_9__["default"])();
    return _this;
  }
  _inheritsLoose(Search, _PageManager);
  var _proto = Search.prototype;
  _proto.loaded = function loaded(next) {
    this._initializeFacetedSearch(this.context.listingProductCount);
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$body.on('click', '[data-listing-view]', function (event) {
      _this2._toggleView(event);
    });
    this.$body.on('click', '[data-faceted-search-toggle]', function (event) {
      event.preventDefault();
      $(event.currentTarget).toggleClass('is-open').next().toggleClass('visible');
    });
  };
  _proto._initTabs = function _initTabs() {
    this.tabs = new bc_tabs__WEBPACK_IMPORTED_MODULE_4__["default"]({
      afterChange: function afterChange() {},
      keepTabsOpen: function keepTabsOpen() {}
    });
    if (!$('#product-results .product-block').length || window.location.search.indexOf('section=content') > -1) {
      this.tabs.displayTabContent('#content-results');
    }
  };
  _proto._initializeQuickSearch = function _initializeQuickSearch() {
    new _global_quick_search__WEBPACK_IMPORTED_MODULE_6__["default"](); // Initialize quick search
  };
  _proto._initializeFacetedSearch = function _initializeFacetedSearch(productCount) {
    var loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_8__["default"])('spinner') + "</div>"
    };
    var facetedSearchOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_3__["default"](loadingOptions, false, '.product-listing');
    var facetedSearchOptions = {
      config: {
        product_results: {
          limit: productCount
        }
      },
      template: {
        productListing: 'search/product-listing',
        sidebar: 'search/sidebar'
      },
      scope: {
        productListing: '[data-search]',
        sidebar: '[data-search-sidebar]'
      },
      toggleFacet: function toggleFacet(event) {
        return (0,_global_toggleFacet__WEBPACK_IMPORTED_MODULE_10__["default"])(event);
      },
      showMore: 'search/show-more',
      callbacks: {
        willUpdate: function willUpdate() {
          facetedSearchOverlay.show();
        },
        didUpdate: function didUpdate() {
          facetedSearchOverlay.hide();
          if ($('[data-product-compare]').length) {
            (0,_global_initCompare__WEBPACK_IMPORTED_MODULE_2__.updateCompare)();
          }
          (0,_global_fillFacetRatingStars__WEBPACK_IMPORTED_MODULE_9__["default"])();
        }
      }
    };
    if (this.context.listingViewMode === 'list') {
      facetedSearchOptions.template = {
        productListing: 'search/product-listing-list',
        sidebar: 'search/sidebar'
      };
    }
    this.FacetedSearch = new _global_FacetedSearch__WEBPACK_IMPORTED_MODULE_1__["default"](facetedSearchOptions);
  };
  _proto._toggleView = function _toggleView(event) {
    var $target = $(event.currentTarget);
    var template = $target.data('listing-view') === 'grid' ? 'search/product-listing' : 'search/product-listing-list';
    var options = {
      template: {
        productListing: template
      }
    };
    this.FacetedSearch.init(options);
    $target.addClass('active').siblings().removeClass('active');
  };
  return Search;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Sitemap.js":
/*!************************************!*\
  !*** ./assets/js/theme/Sitemap.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SiteMap)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var SiteMap = /*#__PURE__*/function (_PageManager) {
  function SiteMap() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(SiteMap, _PageManager);
  return SiteMap;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Subscribe.js":
/*!**************************************!*\
  !*** ./assets/js/theme/Subscribe.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Subscribe)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var Subscribe = /*#__PURE__*/function (_PageManager) {
  function Subscribe() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Subscribe, _PageManager);
  return Subscribe;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/Wishlist.js":
/*!*************************************!*\
  !*** ./assets/js/theme/Wishlist.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WishList)
/* harmony export */ });
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _utils_pagination_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/pagination-utils */ "./assets/js/theme/utils/pagination-utils.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


var WishList = /*#__PURE__*/function (_PageManager) {
  function WishList() {
    var _this;
    _this = _PageManager.call(this) || this;
    _this.onReady();
    return _this;
  }
  _inheritsLoose(WishList, _PageManager);
  var _proto = WishList.prototype;
  _proto.onReady = function onReady() {
    if ($('[data-pagination-wishlist]').length) {
      (0,_utils_pagination_utils__WEBPACK_IMPORTED_MODULE_1__.wishlistPaginationHelper)();
    }
  };
  return WishList;
}(_PageManager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./assets/js/theme/cart/CartUtils.js":
/*!*******************************************!*\
  !*** ./assets/js/theme/cart/CartUtils.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CartUtils)
/* harmony export */ });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_bind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/bind */ "./node_modules/lodash/bind.js");
/* harmony import */ var lodash_bind__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_bind__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _refreshContent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./refreshContent */ "./assets/js/theme/cart/refreshContent.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");





var CartUtils = /*#__PURE__*/function () {
  function CartUtils(modules, options) {
    this.modules = modules;
    this.$cartContent = $('[data-cart-content]');
    this.$addToCart = $('[data-button-purchase]'); // Initialize $addToCart
    this.quantityInput = '[data-quantity-control-input]';
    this.cartAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_3__["default"]($('[data-alerts]'));
    this.cartPromos = $('[data-cart-promos]');
    this.productData = {};
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, options.callbacks);
  }
  var _proto = CartUtils.prototype;
  _proto.init = function init() {
    this._cacheInitialQuantities();
    this._bindEvents();
  };
  _proto._addToCart = function _addToCart(event) {
    var _this = this;
    event.preventDefault();
    var $target = $(event.currentTarget);
    var $form = $target.closest('form');
    var formData = $form.serialize();
    console.log('Form data being sent to API:', formData); // Debug line

    this.callbacks.willUpdate();

    // Use the BigCommerce Stencil utility to add the item to the cart
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__["default"].api.cart.itemAdd(formData, function (err, response) {
      if (response && response.data && response.data.status === 'succeed') {
        (0,_refreshContent__WEBPACK_IMPORTED_MODULE_4__["default"])(_this.callbacks.didUpdate, true);
      } else {
        var errorMessage = response.data.errors.join('\n') || "Unfortunately, this product is not available for purchase.";
        _this.cartAlerts.error(errorMessage, true);
        _this.callbacks.didUpdate();
      }
    });
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$cartContent.on('change', this.quantityInput, lodash_bind__WEBPACK_IMPORTED_MODULE_1___default()(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(this._updateCartItem, 750), this));

    // Attach event handler for add-to-cart buttons
    $('body').on('click', '[data-button-purchase]', function (event) {
      return _this2._addToCart(event);
    });
    this.$cartContent.on('change', '[data-quantity-control-input]', function (evt) {
      var $target = $(evt.target);
      var itemId = $target.closest('[data-quantity-control]').data('quantity-control');
      _this2.productData[itemId].quantityAltered = true;
      _this2.productData[itemId].newQuantity = parseInt($target.val(), 10);
    });
    this.$cartContent.on('click', '[data-cart-item-remove]', function (event) {
      event.preventDefault();
      _this2._removeCartItem(event);
    });
    $('body').on('click', '.mini-cart [data-cart-item-remove]', function () {
      _this2.callbacks.willUpdate();
    });
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__["default"].hooks.on('cart-item-remove-remote', function () {
      (0,_refreshContent__WEBPACK_IMPORTED_MODULE_4__["default"])(_this2.callbacks.didUpdate, true);
    });

    // Ensure the CartUtils is initialized after document is ready
    $(document).ready(function () {
      var cartUtils = new CartUtils();
      cartUtils.init();
    });
  };
  _proto._cacheInitialQuantities = function _cacheInitialQuantities() {
    var _this3 = this;
    $('[data-cart-item]').each(function (i, el) {
      var $cartItem = $(el);
      var itemId = $cartItem.data('item-id');
      _this3.productData[itemId] = {
        oldQuantity: parseInt($cartItem.find('[data-quantity-control-input]').attr('value'), 10),
        quantityAltered: false
      };
    });
  };
  _proto._updateCartItem = function _updateCartItem(event) {
    var _this4 = this;
    var $target = $(event.currentTarget);
    var $cartItem = $target.closest('[data-cart-item]');
    var itemId = $cartItem.data('item-id');
    this.callbacks.willUpdate();
    if (this.productData[itemId].quantityAltered) {
      var $quantityInput = $cartItem.find('[data-cart-item-quantity-input]');
      var newQuantity = this.productData[itemId].newQuantity;
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__["default"].api.cart.itemUpdate(itemId, newQuantity, function (err, response) {
        if (response.data.status === 'succeed') {
          var remove = newQuantity === 0;
          _this4.productData[itemId].oldQuantity = newQuantity;
          (0,_refreshContent__WEBPACK_IMPORTED_MODULE_4__["default"])(_this4.callbacks.didUpdate, remove);
        } else {
          $quantityInput.val(_this4.productData[itemId].oldQuantity);
          _this4.cartAlerts.error(response.data.errors.join('\n'), true);
          _this4.callbacks.didUpdate();
        }

        // this.cartPromos.empty();
      });
    }
  };
  _proto._removeCartItem = function _removeCartItem(event) {
    var _this5 = this;
    var itemId = $(event.currentTarget).closest('[data-cart-item]').data('item-id');
    this.callbacks.willUpdate();
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_2__["default"].api.cart.itemRemove(itemId, function (err, response) {
      if (response.data.status === 'succeed') {
        (0,_refreshContent__WEBPACK_IMPORTED_MODULE_4__["default"])(_this5.callbacks.didUpdate, true);
      } else {
        _this5.cartAlerts.error(response.data.errors.join('\n'), true);
        _this5.callbacks.didUpdate();
      }
    });
  };
  return CartUtils;
}();


/***/ }),

/***/ "./assets/js/theme/cart/CouponCodes.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/cart/CouponCodes.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CouponCodes)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _refreshContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./refreshContent */ "./assets/js/theme/cart/refreshContent.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");



var CouponCodes = /*#__PURE__*/function () {
  function CouponCodes(el, options) {
    this.$el = $(el);
    this.couponAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_1__["default"]($('[data-alerts]'));
    this.options = $.extend({
      context: {},
      $scope: $('[data-cart-totals]'),
      visibleClass: 'visible'
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = CouponCodes.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.options.$scope.on('submit', '[data-coupon-code-form]', function (event) {
      event.preventDefault();
      _this._addCode();
    });
  };
  _proto._addCode = function _addCode() {
    var _this2 = this;
    var $input = $('[data-coupon-code-input]', this.options.$scope);
    var code = $input.val();
    this.couponAlerts.clear();
    this.callbacks.willUpdate();
    if (!code) {
      this.couponAlerts.error(this.options.context.couponCodeEmptyInput, true);
      return this.callbacks.didUpdate();
    }
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.applyCode(code, function (err, response) {
      if (response.data.status === 'success') {
        (0,_refreshContent__WEBPACK_IMPORTED_MODULE_2__["default"])(_this2.callbacks.didUpdate);
      } else {
        _this2.couponAlerts.error(response.data.errors.join('\n'), true);
        _this2.callbacks.didUpdate();
      }
    });
  };
  return CouponCodes;
}();


/***/ }),

/***/ "./assets/js/theme/cart/EditOptions.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/cart/EditOptions.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CartEditOptions)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var bc_modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bc-modal */ "./node_modules/bc-modal/dist/js/modal.js");
/* harmony import */ var _product_AttributesHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../product/AttributesHelper */ "./assets/js/theme/product/AttributesHelper.js");
/* harmony import */ var _components_SelectWrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/SelectWrapper */ "./assets/js/theme/components/SelectWrapper.js");
/* harmony import */ var _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../product/ColorSwatch */ "./assets/js/theme/product/ColorSwatch.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");





var CartEditOptions = /*#__PURE__*/function () {
  function CartEditOptions(context, callbacks) {
    var _this = this;
    this.context = context;
    this.el = '<div id="cart-options-modal">';
    this.id = null;
    this.cartOptionsModal = new bc_modal__WEBPACK_IMPORTED_MODULE_1__["default"]({
      el: this.el,
      modalClass: 'cart-options-modal',
      afterShow: function afterShow($modal) {
        _this._fetchProduct($modal, _this.id);
      }
    });
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, callbacks);

    // Abstracted attributes functionality
    this.attributesHelper = new _product_AttributesHelper__WEBPACK_IMPORTED_MODULE_2__["default"]('#CartEditProductFieldsForm');
    this._bindEvents();
  }
  var _proto = CartEditOptions.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    $('body').on('click', '[data-item-edit]', function (event) {
      event.preventDefault();
      _this2.id = $(event.currentTarget).data('item-edit');
      if (!_this2.id) {
        return;
      }
      _this2.cartOptionsModal.open();
    });
    $('body').on('submit', '#CartEditProductFieldsForm', function () {
      _this2.callbacks.willUpdate();
    });
  }

  /**
   * Run ajax fetch of product and add to modal. Bind product functionality and show the modal
   * @param {jQuery} $modal - the root (appended) modal element.
   * @param {string} $itemId - product id
   */;
  _proto._fetchProduct = function _fetchProduct($modal, $itemID) {
    var _this3 = this;
    var options = {
      template: 'cart/edit-options'
    };
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.productAttributes.configureInCart($itemID, options, function (err, response) {
      $modal.find('.modal-content').append(response.content).find('.cart-edit-options').addClass('cart-edit-options-visible');
      _this3.cartOptionsModal.position();
      $modal.addClass('loaded');
      var $select = $modal.find('select');
      if ($select.length) {
        $select.each(function (i, el) {
          new _components_SelectWrapper__WEBPACK_IMPORTED_MODULE_3__["default"](el);
        });
      }
      _this3.swatches = new _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_4__["default"](); // Init our color swatches

      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.on('product-option-change', function (event, option) {
        _this3.callbacks.willUpdate();
        var $changedOption = $(option);
        var $form = $('#CartEditProductFieldsForm');
        var $submit = $('input[type="submit"]', $form);
        var $messageBox = $('[data-reconfigure-errors]');
        var item = $('[name="item_id"]', $form).attr('value');
        _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.productAttributes.optionChange(item, $form.serialize(), 'cart/edit-options', function (err, result) {
          var data = result.data || {};
          _this3.attributesHelper.updateAttributes(data);
          if (data.purchasing_message) {
            $($messageBox).html(data.purchasing_message);
            $submit.prop('disabled', true);
            $messageBox.show();
          } else {
            $submit.prop('disabled', false);
            $messageBox.hide();
          }
          if (!data.purchasable || !data.instock) {
            $submit.prop('disabled', true);
          } else {
            $submit.prop('disabled', false);
          }
          _this3.callbacks.didUpdate();
        });
      });
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.emit('product-option-change');
    });
  };
  return CartEditOptions;
}();


/***/ }),

/***/ "./assets/js/theme/cart/GiftCertificates.js":
/*!**************************************************!*\
  !*** ./assets/js/theme/cart/GiftCertificates.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GiftCertificates)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _refreshContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./refreshContent */ "./assets/js/theme/cart/refreshContent.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");



var GiftCertificates = /*#__PURE__*/function () {
  function GiftCertificates(el, options) {
    this.$el = $(el);
    this.certificateAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_1__["default"]($('[data-alerts]'));
    this.options = $.extend({
      context: {},
      $scope: $('[data-cart-totals]'),
      visibleClass: 'visible'
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = GiftCertificates.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.options.$scope.on('click', '[data-gift-certificate-toggle]', function (event) {
      event.preventDefault();
      _this._toggle();
    });
    this.options.$scope.on('submit', '[data-gift-certificate-form]', function (event) {
      event.preventDefault();
      _this._addCode();
    });
  };
  _proto._toggle = function _toggle() {
    $('[data-gift-certificate-form]', this.options.$scope).toggleClass(this.options.visibleClass);
  };
  _proto._addCode = function _addCode() {
    var _this2 = this;
    var $input = $('[data-gift-certificate-input]', this.options.$scope);
    var code = $input.val();
    this.callbacks.willUpdate();
    if (!this._isValidCode(code)) {
      this.certificateAlerts.error(this.options.context.giftCertificateInputEmpty, true);
      return this.callbacks.didUpdate();
    }
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.applyGiftCertificate(code, function (err, response) {
      if (response.data.status === 'success') {
        (0,_refreshContent__WEBPACK_IMPORTED_MODULE_2__["default"])(_this2.callbacks.didUpdate);
      } else {
        _this2.certificateAlerts.error(response.data.errors.join('\n'), true);
        _this2.callbacks.didUpdate();
      }
    });
  };
  _proto._isValidCode = function _isValidCode(code) {
    if (typeof code !== 'string') {
      return false;
    }
    return true;
  };
  return GiftCertificates;
}();


/***/ }),

/***/ "./assets/js/theme/cart/GiftWrapping.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/cart/GiftWrapping.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GiftWrapping)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var bc_modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bc-modal */ "./node_modules/bc-modal/dist/js/modal.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var GiftWrapping = /*#__PURE__*/function () {
  function GiftWrapping(options) {
    if (options === void 0) {
      options = {};
    }
    this.options = $.extend({
      scope: '[data-cart-content]',
      trigger: '[data-item-giftwrap]',
      remove: '[data-giftwrap-remove]'
    }, options);
    this.$cartContent = $(this.options.scope);
    this.context = options.context;
    this._initialize();
  }
  var _proto = GiftWrapping.prototype;
  _proto._initialize = function _initialize() {
    var _this = this;
    this.itemId; // later assigned the id of the current product

    this.GiftWrapModal = new bc_modal__WEBPACK_IMPORTED_MODULE_1__["default"]({
      modalClass: 'giftwrap-modal',
      afterShow: function afterShow($modal) {
        _this._getForm($modal);
      }
    });
    this._bindPageEvents();
  }

  // Bind functionality to giftwrap links.
  ;
  _proto._bindPageEvents = function _bindPageEvents() {
    var _this2 = this;
    this.$cartContent.on('click', this.options.trigger, function (event) {
      event.preventDefault();
      var $target = $(event.currentTarget);
      _this2.itemId = $target.data('item-giftwrap');
      _this2.GiftWrapModal.open();
    });
    this.$cartContent.on('click', this.options.remove, function (event) {
      if (!confirm(_this2.context.removeGiftWrap)) {
        event.preventDefault();
      }
      ;
    });
    $('body').on('click', '.button-cancel-giftwrap', function () {
      event.preventDefault();
      _this2.GiftWrapModal.close();
    });
  }

  // Run once the modal has been opened..
  ;
  _proto._getForm = function _getForm($modal) {
    var _this3 = this;
    var options = {
      template: 'cart/giftwrap-form'
    };
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.getItemGiftWrappingOptions(this.itemId, options, function (err, response) {
      if (response) {
        $modal.find('.modal-content').append(response.content);
        _this3._bindModalEvents($modal);

        // reposition modal with content
        _this3.GiftWrapModal.position();

        // Class added to display the modal once content is available
        $modal.addClass('visible');
      } else {
        _this3.GiftWrapModal.close();
      }
    });
  };
  _proto._bindModalEvents = function _bindModalEvents($modal) {
    var _this4 = this;
    $modal.on('change', function () {
      _this4.GiftWrapModal.position();
    });

    // Select giftwrapping individually or together
    $modal.find('[data-giftwrap-type]').on('change', function (event) {
      _this4._toggleSingleMultiple($modal, event.currentTarget.value);
    });

    // Select the type of gift wrapping for a particular item
    $('[data-giftwrap-select]').change(function (event) {
      var $select = $(event.target);
      var index = $select.data('index');
      var id = $select.val();
      if (!id) {
        return;
      }
      var allowMessage = $select.find("option[value=" + id + "]").data('allow-message');
      $("[data-giftwrap-image-" + index + "]").addClass('hidden');
      $("[data-giftwrap-image-" + index + "=\"" + id + "\"]").removeClass('hidden');
      if (allowMessage) {
        $("[data-giftwrap-message-" + index + "]").removeClass('hidden');
      } else {
        $("[data-giftwrap-message-" + index + "]").addClass('hidden');
      }
    });
    $('[data-giftwrap-select]').trigger('change');
  }

  // Toggles displaying single / multiple wrap options
  ;
  _proto._toggleSingleMultiple = function _toggleSingleMultiple($modal, value) {
    var $singleForm = $modal.find('[data-giftwrap-single]');
    var $multiForm = $modal.find('[data-giftwrap-multiple]');
    if (value === 'different') {
      $singleForm.addClass('hidden');
      $multiForm.removeClass('hidden');
    } else {
      $singleForm.removeClass('hidden');
      $multiForm.addClass('hidden');
    }
  };
  return GiftWrapping;
}();


/***/ }),

/***/ "./assets/js/theme/cart/ShippingCalculator.js":
/*!****************************************************!*\
  !*** ./assets/js/theme/cart/ShippingCalculator.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ShippingCalculator)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _refreshContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./refreshContent */ "./assets/js/theme/cart/refreshContent.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");



var ShippingCalculator = /*#__PURE__*/function () {
  function ShippingCalculator(el, options) {
    this.$el = $(el);
    this.shippingAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_1__["default"]($('[data-alerts]'));
    this.options = $.extend({
      context: {},
      $scope: $('[data-cart-totals]'),
      visibleClass: 'visible'
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      }
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = ShippingCalculator.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.options.$scope.on('click', '[data-shipping-calculator-toggle]', function (event) {
      event.preventDefault();
      _this._toggle();
    });
    this.options.$scope.on('submit', '[data-shipping-calculator] form', function (event) {
      event.preventDefault();
      _this._calculateShipping();
    });
    this.options.$scope.on('change', 'select[name="shipping-country"]', function (event) {
      _this._updateStates(event);
      _this.options.$scope.find('[name="shipping-zip"]').val('');
    });
  };
  _proto._toggle = function _toggle() {
    $('[data-shipping-calculator]', this.options.$scope).toggleClass(this.options.visibleClass);
  };
  _proto._updateStates = function _updateStates(event) {
    var _this2 = this;
    var $target = $(event.currentTarget);
    var country = $target.val();
    var $stateElement = $('[name="shipping-state"]');
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.country.getByName(country, function (err, response) {
      if (response.data.states.length) {
        var stateArray = [];
        stateArray.push("<option value=\"\">" + response.data.prefix + "</option>");
        $.each(response.data.states, function (i, state) {
          stateArray.push("<option value=\"" + state.id + "\">" + state.name + "</option>");
        });
        $stateElement.parent().addClass('form-select-wrapper');
        $stateElement.replaceWith("<select class=\"form-select form-input form-input-short\" id=\"shipping-state\" name=\"shipping-state\" data-field-type=\"State\">" + stateArray.join(' ') + "</select>");
      } else {
        $stateElement.parent().removeClass('form-select-wrapper');
        $stateElement.replaceWith("<input class=\"form-input form-input-short\" type=\"text\" id=\"shipping-state\" name=\"shipping-state\" data-field-type=\"State\" placeholder=\"" + _this2.options.context.shippingState + "\">");
      }
    });
  };
  _proto._calculateShipping = function _calculateShipping() {
    var _this3 = this;
    this.callbacks.willUpdate();
    var params = {
      country_id: $('[name="shipping-country"]', this.$calculatorForm).val(),
      state_id: $('[name="shipping-state"]', this.$calculatorForm).val(),
      zip_code: $('[name="shipping-zip"]', this.$calculatorForm).val()
    };
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.getShippingQuotes(params, 'cart/shipping-quotes', function (err, response) {
      var $shippingQuotes = $('[data-shipping-quotes]', _this3.options.$scope);
      if (response.data.quotes) {
        _this3.shippingAlerts.clear();
        $shippingQuotes.html(response.content);
      } else {
        _this3.shippingAlerts.error(response.data.errors.join('\n'), true);
      }
      _this3.callbacks.didUpdate();

      // bind the shipping method radios
      $shippingQuotes.find('.form').on('change', function (event) {
        event.preventDefault();
        _this3.callbacks.willUpdate();
        var quoteId = $('[data-shipping-quote]:checked').val();
        _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.submitShippingQuote(quoteId, function (response) {
          (0,_refreshContent__WEBPACK_IMPORTED_MODULE_2__["default"])(_this3.callbacks.didUpdate);
        });
      });
    });
  };
  return ShippingCalculator;
}();


/***/ }),

/***/ "./assets/js/theme/cart/refreshContent.js":
/*!************************************************!*\
  !*** ./assets/js/theme/cart/refreshContent.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(didUpdate, remove) {
  var $cartTotals = $('[data-cart-totals]');
  var $cartContent = $('[data-cart-content]');
  var $cartPromos = $('[data-cart-promos]');
  var $cartItem = $('[data-cart-item]', $cartContent);
  var options = {
    template: {
      content: 'cart/content',
      totals: 'cart/totals',
      promos: 'header/shipping-messages'
    }
  };

  // Remove last item from cart? Reload
  if (remove && $cartItem.length === 1) {
    return window.location.reload();
  }
  _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.getContent(options, function (err, response) {
    // TODO: Scope the call to this function by area that needs updating
    $cartContent.html(response.content);
    $cartTotals.html(response.totals);
    $cartPromos.replaceWith(response.promos);
    $cartContent.trigger('cart-initialize-modules');

    // TODO: If the loading overlay is scoped to an area that is replaced
    // it does not fade out, but is removed abrubtly (due to being a
    // part of that area's content).
    didUpdate();
  });
}

/***/ }),

/***/ "./assets/js/theme/components/Alert.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/components/Alert.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Alert)
/* harmony export */ });
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/template */ "./node_modules/lodash/template.js");
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_template__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
var Alert = /*#__PURE__*/function () {
  function Alert($el, options) {
    if (options === void 0) {
      options = {};
    }
    this.$el = $el;
    this.options = $.extend({
      classes: {
        base: 'alert',
        error: 'alert-error',
        info: 'alert-info',
        success: 'alert-success'
      },
      limit: 1,
      template: {},
      callbacks: {}
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {},
      didUpdate: function didUpdate() {}
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = Alert.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    if (lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(this.options.template)) {
      this.options.template = lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n        <div class='" + this.options.classes.base + " <%= messageType %>'>\n          <% if (isDismissable) { %>\n            <a class=\"alert-dismiss\">&times;</a>\n          <% } %>\n          <div class=\"alert-message\">\n            <%= messageText %>\n          </div>\n        </div>\n      ");
    }
    this.$el.on('click', '.alert-dismiss', function (event) {
      event.preventDefault();
      var $alert = $(event.currentTarget).parent('.alert');
      _this._dismissMessage($alert);
    });
    this.$el.on('clear-messages', function () {
      _this.clear();
    });
  }

  /**
   * This method can be used to reset the contents of this.$el
   */;
  _proto.clear = function clear() {
    var _this2 = this;
    this.$el.find("." + this.options.classes.base).each(function (index, target) {
      _this2._dismissMessage($(target));
    });
  }

  /**
   * If bc-core becomes integrated into bc-skeleton, this method should delegate to `dismissable()`
   * @param $alert
   * @private
   */;
  _proto._dismissMessage = function _dismissMessage($alert) {
    $alert.addClass('dismissed');
    $alert.one('trend', function () {
      $alert.remove();
    });
  }

  /**
   * Explicit usage to create an error alert
   * @param text
   * @param dismissable
   */;
  _proto.error = function error(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'error', dismissable);
  }

  /**
   * Explicit usage to create a success alert
   * @param text
   * @param dismissable
   */;
  _proto.success = function success(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'success', dismissable);
  }

  /**
   * Explicit usage to create an informational alert
   * @param text
   * @param dismissable
   */;
  _proto.info = function info(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'info', dismissable);
  }

  /**
   *
   * @param text
   * @param type
   * @param dismissable
   */;
  _proto.message = function message(text, type, dismissable) {
    var _this3 = this;
    if (type === void 0) {
      type = 'info';
    }
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.callbacks.willUpdate();
    if (typeof this.options.limit === 'number' && this.$el.find("." + this.options.classes.base).length > this.options.limit) {
      this._dismissMessage(this.$el.find("." + this.options.classes.base + ":not(.dismissed)").eq(0));
    }
    var message = {
      messageType: this.options.classes[type],
      messageText: text,
      isDismissable: dismissable
    };
    var $modalBody = $('.modal-body');
    var appendMessage = function appendMessage($el) {
      $el.append(_this3.options.template(message));
    };
    if ($modalBody.length) {
      var productAlerts = $modalBody.find('[data-product-alerts]');
      appendMessage(productAlerts);
    } else {
      var alerts = $('.site-header').find('[data-alerts]');
      appendMessage(alerts);
    }
    ;
    this.callbacks.didUpdate();
  };
  return Alert;
}();


/***/ }),

/***/ "./assets/js/theme/components/QuantityWidget.js":
/*!******************************************************!*\
  !*** ./assets/js/theme/components/QuantityWidget.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ QuantityWidget)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var QuantityWidget = function QuantityWidget(options) {
  if (options === void 0) {
    options = {};
  }
  this.options = $.extend({
    el: '[data-quantity-control]',
    cntrl: '[data-quantity-control-action]',
    scope: 'body'
  }, options);

  // Bind Control Actions
  $(this.options.scope).on('click', this.options.cntrl, function (event) {
    event.preventDefault(); //in case we use <button>/<a> instead of <span>'s
    var $target = $(event.target);
    var action = $target.data('quantity-control-action');
    var $quantityInput = $target.siblings('input');
    var value = parseInt($quantityInput.val(), 10);
    var min = $quantityInput.attr('min') ? parseInt($quantityInput.attr('min'), 10) : 0;
    var max = $quantityInput.attr('max') ? parseInt($quantityInput.attr('max'), 10) : Infinity;
    if (action === 'increment' && value < max) {
      $quantityInput.val(value + 1).trigger('change');
    } else if (action === 'decrement' && value > 0 && value > min) {
      $quantityInput.val(value - 1).trigger('change');
    }
  });

  // Simple input validation (keep input within min/max range)
  // Feel free to remove and replace with another form of validation
  $(this.options.scope).on('change', 'input', function (event) {
    var $target = $(event.target);
    var value = parseInt($target.val(), 10);
    var min = $target.attr('min') ? parseInt($target.attr('min'), 10) : 0;
    var max = $target.attr('max') ? parseInt($target.attr('max'), 10) : Infinity;
    if (value > max) {
      //TODO: Integrate Alert system
      console.error("Quantity \"" + value + "\" cannot be greater than maximum (" + max + ")");
      $target.val($target.attr('value'));
    }
    if (value < min) {
      console.error("Quantity value \"" + value + "\" cannot be less than minimum (" + min + ")");
      $target.val($target.attr('value'));
    }
  });
};


/***/ }),

/***/ "./assets/js/theme/components/SelectWrapper.js":
/*!*****************************************************!*\
  !*** ./assets/js/theme/components/SelectWrapper.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectWrapper)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var SelectWrapper = /*#__PURE__*/function () {
  function SelectWrapper(el) {
    this.$el = $(el);
    if (!this.$el.parent('.form-select-wrapper').length) {
      this.$el.wrap('<div class="form-select-wrapper" />').parent().prepend("<span class=\"selected-text\">" + this.$el.find('option:selected').text() + "</span>");
    }

    // Conditional required so I can use the currency code as opposed to
    // the full currency name in the currency switcher
    if (!this.$el.closest('.currency-switcher').length) {
      this._bindEvents();
    }
  }
  var _proto = SelectWrapper.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.$el.on('change', function () {
      _this.updateSelectText();
    });
  };
  _proto.updateSelectText = function updateSelectText(option) {
    var newOption = option ? option : this.$el.find('option:selected').text();
    this.$el.siblings('.selected-text').text(newOption);
  };
  return SelectWrapper;
}();


/***/ }),

/***/ "./assets/js/theme/core/Account.js":
/*!*****************************************!*\
  !*** ./assets/js/theme/core/Account.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Account)
/* harmony export */ });
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/find */ "./node_modules/lodash/find.js");
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_find__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js");
/* harmony import */ var lodash_reduce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_reduce__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _PageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../PageManager */ "./assets/js/PageManager.js");
/* harmony import */ var _alertDismissable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alertDismissable */ "./assets/js/theme/core/alertDismissable.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _utils_FormValidator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/FormValidator */ "./assets/js/theme/utils/FormValidator.js");
/* harmony import */ var _downloadGallery__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./downloadGallery */ "./assets/js/theme/core/downloadGallery.js");
/* harmony import */ var _updateState__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./updateState */ "./assets/js/theme/core/updateState.js");
/* harmony import */ var _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./account/paymentMethod */ "./assets/js/theme/core/account/paymentMethod.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
/**
 *
 * FormValidator does not currently exist in the core files, it is being
 * imported from the theme so that the credit card form can benefit from being
 * validated. Make sure the FormValidator file exists in the theme or that this
 * page is not called if adding it to the theme you are working on
 *
 */








var Account = /*#__PURE__*/function (_PageManager) {
  function Account() {
    return _PageManager.call(this) || this;
  }
  _inheritsLoose(Account, _PageManager);
  var _proto = Account.prototype;
  _proto.loaded = function loaded(next) {
    this._bindEvents();
    var $paymentMethodForm = $('form[data-payment-method-form]');
    if ($paymentMethodForm.length) {
      this.initPaymentMethodFormValidation($paymentMethodForm);
    }
    this.pageAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_4__["default"]($('[data-alerts]'));
    this.Validator = new _utils_FormValidator__WEBPACK_IMPORTED_MODULE_5__["default"](this.context);
    this.Validator.initSingle($(document.body).find('form[data-payment-method-form]'));
    (0,_updateState__WEBPACK_IMPORTED_MODULE_7__["default"])(false, this.selectWrapCallback);
    next();
  };
  _proto._bindEvents = function _bindEvents() {
    (0,_alertDismissable__WEBPACK_IMPORTED_MODULE_3__["default"])();
    (0,_downloadGallery__WEBPACK_IMPORTED_MODULE_6__["default"])();
    (0,_updateState__WEBPACK_IMPORTED_MODULE_7__["default"])(false, this.selectWrapCallback);
    var $reorderForm = $('[data-account-reorder-form]');
    if ($reorderForm.length) {
      this.initReorderForm($reorderForm);
    }

    // Toggle - a simple way to toggle elements
    $(document.body).on('click', '[data-account-toggle]', function (event) {
      var $el = $(event.currentTarget);
      var $target = $($el.data('account-toggle'));
      $target.toggle();
    });
    this.bindDeletePaymentMethod();
  };
  _proto.initReorderForm = function initReorderForm($reorderForm) {
    $reorderForm.on('submit', function (event) {
      var submitForm = false;
      var $productReorderCheckboxes = $('.account-item .form-checkbox:checked');
      $reorderForm.find('[name^="reorderitem"]').remove();
      $productReorderCheckboxes.each(function (index, productCheckbox) {
        var productId = $(productCheckbox).val();
        var $input = $('<input>', {
          type: 'hidden',
          name: "reorderitem[" + productId + "]",
          value: '1'
        });
        submitForm = true;
        $reorderForm.append($input);
      });
      if (!submitForm) {
        event.preventDefault();
        $('.account-toolbar .alert-error').show();
      }
    });
  }

  /**
   * Optional callback fired when a fresh state <select> element is added to the DOM
   */;
  _proto.selectWrapCallback = function selectWrapCallback($selectEl) {} //eslint-disable-line no-unused-vars

  /**
  * Binds a submit hook to ensure the customer receives a confirmation dialog before deleting a payment method
  */;
  _proto.bindDeletePaymentMethod = function bindDeletePaymentMethod() {
    $('[data-delete-payment-method]').on('submit', function (event) {
      var message = $(event.currentTarget).data('deletePaymentMethod');
      if (!window.confirm(message)) {
        event.preventDefault();
      }
    });
  };
  _proto.initPaymentMethodFormValidation = function initPaymentMethodFormValidation($paymentMethodForm) {
    var _this = this;
    // Inject validations into form fields before validation runs
    $paymentMethodForm.find('#first_name.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.firstNameLabel + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#last_name.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.lastNameLabel + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#company.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.companyLabel + "\", \"required\": false, \"maxlength\": 0 }");
    $paymentMethodForm.find('#phone.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.phoneLabel + "\", \"required\": false, \"maxlength\": 0 }");
    $paymentMethodForm.find('#address1.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.address1Label + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#address2.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.address2Label + "\", \"required\": false, \"maxlength\": 0 }");
    $paymentMethodForm.find('#city.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.cityLabel + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#country.form-field').attr('data-validation', "{ \"type\": \"singleselect\", \"label\": \"" + this.context.countryLabel + "\", \"required\": true, prefix: \"" + this.context.chooseCountryLabel + "\" }");
    $paymentMethodForm.find('#state.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.stateLabel + "\", \"required\": true, \"maxlength\": 0 }");
    $paymentMethodForm.find('#postal_code.form-field').attr('data-validation', "{ \"type\": \"singleline\", \"label\": \"" + this.context.postalCodeLabel + "\", \"required\": true, \"maxlength\": 0 }");
    var paymentMethodSelector = 'form[data-payment-method-form]';
    var $stateElement = $(paymentMethodSelector + " [data-field-type=\"State\"]");
    var $last;

    // Use credit card number input listener to highlight credit card type
    $(paymentMethodSelector + " input[name=\"credit_card_number\"]").on('keyup', function (_ref) {
      var target = _ref.target;
      var cardType = (0,_account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.creditCardType)(target.value);
      if (cardType) {
        $(paymentMethodSelector + " img[alt=\"" + cardType + "\"").siblings().css('opacity', '.2');
      } else {
        $(paymentMethodSelector + " img").css('opacity', '1');
      }
    });

    // Set of credit card validation
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Validators.setCreditCardNumberValidation($paymentMethodForm, paymentMethodSelector + " input[name=\"credit_card_number\"]", this.context.creditCardNumber);
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Validators.setExpirationValidation($paymentMethodForm, paymentMethodSelector + " input[name=\"expiration\"]", this.context.expiration);
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Validators.setNameOnCardValidation($paymentMethodForm, paymentMethodSelector + " input[name=\"name_on_card\"]", this.context.nameOnCard);
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Validators.setCvvValidation($paymentMethodForm, paymentMethodSelector + " input[name=\"cvv\"]", this.context.cvv);

    // Set of credit card format
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Formatters.setCreditCardNumberFormat(paymentMethodSelector + " input[name=\"credit_card_number\"]");
    _account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.Formatters.setExpirationFormat(paymentMethodSelector + " input[name=\"expiration\"");

    // Billing address validation
    $paymentMethodForm.on('submit', function (event) {
      event.preventDefault();
      var $formIsValid = $paymentMethodForm.find('.form-field-invalid') > 0 ? false : true;

      // Perform final form validation
      if ($formIsValid) {
        // Serialize form data and reduce it to object
        var data = lodash_reduce__WEBPACK_IMPORTED_MODULE_1___default()($paymentMethodForm.serializeArray(), function (obj, item) {
          var refObj = obj;
          refObj[item.name] = item.value;
          return refObj;
        }, {});

        // Assign country and state code
        var country = lodash_find__WEBPACK_IMPORTED_MODULE_0___default()(_this.context.countries, function (_ref2) {
          var value = _ref2.value;
          return value === data.country;
        });
        var state = country && lodash_find__WEBPACK_IMPORTED_MODULE_0___default()(country.states, function (_ref3) {
          var value = _ref3.value;
          return value === data.state;
        });
        data.country_code = country ? country.code : data.country;
        data.state_or_province_code = state ? state.code : data.state;

        // Default Instrument
        data.default_instrument = !!data.default_instrument;

        // Store credit card
        (0,_account_paymentMethod__WEBPACK_IMPORTED_MODULE_8__.storeInstrument)(_this.context, data, function () {
          window.location.href = _this.context.paymentMethodsUrl;
        }, function () {
          _this.pageAlerts.error(_this.context.generic_error, true);
        });
      }
    });
  };
  return Account;
}(_PageManager__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./assets/js/theme/core/Auth.js":
/*!**************************************!*\
  !*** ./assets/js/theme/core/Auth.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Account)
/* harmony export */ });
/* harmony import */ var _updateState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./updateState */ "./assets/js/theme/core/updateState.js");

var Account = /*#__PURE__*/function () {
  function Account() {
    (0,_updateState__WEBPACK_IMPORTED_MODULE_0__["default"])(false, this.selectWrapCallback);
  }

  /**
   * Optional callback fired when a fresh state <select> element is added to the DOM
   */
  var _proto = Account.prototype;
  _proto.selectWrapCallback = function selectWrapCallback($selectEl) {} //eslint-disable-line no-unused-vars

  // backwards compatibility for Page Manager
  ;
  _proto.loaded = function loaded() {};
  _proto.before = function before() {};
  _proto.after = function after() {};
  return Account;
}();


/***/ }),

/***/ "./assets/js/theme/core/GiftCertificate.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/core/GiftCertificate.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GiftCertificate)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var GiftCertificate = /*#__PURE__*/function () {
  function GiftCertificate(context) {
    this.$purchaseForm = $('[data-giftcard-purchase-form]');
    this._bindEvents();
  }
  var _proto = GiftCertificate.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.$purchaseForm.on('change', function () {
      if ($('#giftcard-amount').val() != "") {
        _this._showPreview();
      }
    });
    this.$purchaseForm.find('[data-no-refresh]').on('change', function (event) {
      event.stopPropagation();
    });
  }

  /**
   * Show or update the giftcard preview.
   */;
  _proto._showPreview = function _showPreview() {
    var $theme = this.$purchaseForm.find('[data-giftcard-theme]');

    // Only show a preview if a theme is selected
    if (!$theme.find('.form-input:checked').length) {
      return;
    }

    // Calculate preview URL based on form state
    var baseUrl = $theme.data('giftcard-preview-url');
    var data = this.$purchaseForm.serialize();
    var url = baseUrl + "&" + data;

    // Create preview
    var $preview = $('<iframe>', {
      src: url
    }).on('load', function (event) {
      // Calculate iframe height based on its document height
      var height = $(event.currentTarget.contentDocument).height();
      $(event.currentTarget).height(height);
    });

    // Update preview
    $theme.find('.giftcard-form-preview').addClass('has-preview').html($preview);
  }

  // backwards compatibility for Page Manager
  ;
  _proto.loaded = function loaded() {};
  _proto.before = function before() {};
  _proto.after = function after() {};
  return GiftCertificate;
}();


/***/ }),

/***/ "./assets/js/theme/core/account/paymentMethod.js":
/*!*******************************************************!*\
  !*** ./assets/js/theme/core/account/paymentMethod.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Formatters: () => (/* binding */ Formatters),
/* harmony export */   Validators: () => (/* binding */ Validators),
/* harmony export */   creditCardType: () => (/* binding */ creditCardType),
/* harmony export */   storeInstrument: () => (/* binding */ storeInstrument)
/* harmony export */ });
/* harmony import */ var creditcards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! creditcards */ "./node_modules/creditcards/index.js");
/* harmony import */ var creditcards__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(creditcards__WEBPACK_IMPORTED_MODULE_0__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


/**
 * Omit null or empty string properties of object
 * @param {Object} object
 * @returns {Object}
 */
var omitNullString = function omitNullString(obj) {
  var refObj = obj;
  $.each(refObj, function (key, value) {
    if (value === null || value === '') {
      delete refObj[key];
    }
  });
  return refObj;
};

/**
 * Get credit card type from credit card number
 * @param {string} value
 */
var creditCardType = function creditCardType(value) {
  return creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.type(creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.parse(value), true);
};

/**
 * Wrapper for ajax request to store a new instrument in bigpay
 * @param {object} Representing the data needed for the header
 * @param {object} Representing the data needed for the body
 * @param {function} done Function to execute on a successful response
 * @param {function} fail Function to execute on a unsuccessful response
 */
var storeInstrument = function storeInstrument(_ref, _ref2, done, fail) {
  var paymentsUrl = _ref.paymentsUrl,
    shopperId = _ref.shopperId,
    storeHash = _ref.storeHash,
    vaultToken = _ref.vaultToken;
  var provider_id = _ref2.provider_id,
    currency_code = _ref2.currency_code,
    credit_card_number = _ref2.credit_card_number,
    expiration = _ref2.expiration,
    name_on_card = _ref2.name_on_card,
    cvv = _ref2.cvv,
    default_instrument = _ref2.default_instrument,
    address1 = _ref2.address1,
    address2 = _ref2.address2,
    city = _ref2.city,
    postal_code = _ref2.postal_code,
    state_or_province_code = _ref2.state_or_province_code,
    country_code = _ref2.country_code,
    company = _ref2.company,
    first_name = _ref2.first_name,
    last_name = _ref2.last_name,
    email = _ref2.email,
    phone = _ref2.phone;
  var expiry = expiration.split('/');
  $.ajax({
    url: paymentsUrl + "/stores/" + storeHash + "/customers/" + shopperId + "/stored_instruments",
    dataType: 'json',
    method: 'POST',
    cache: false,
    headers: {
      Authorization: vaultToken,
      Accept: 'application/vnd.bc.v1+json',
      'Content-Type': 'application/vnd.bc.v1+json'
    },
    data: JSON.stringify({
      instrument: {
        type: 'card',
        cardholder_name: name_on_card,
        number: creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.parse(credit_card_number),
        expiry_month: creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.month.parse(expiry[0]),
        expiry_year: creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.year.parse(expiry[1], true),
        verification_value: cvv
      },
      billing_address: omitNullString({
        address1: address1,
        address2: address2,
        city: city,
        postal_code: postal_code,
        state_or_province_code: state_or_province_code,
        country_code: country_code,
        company: company,
        first_name: first_name,
        last_name: last_name,
        email: email,
        phone: phone
      }),
      provider_id: provider_id,
      default_instrument: default_instrument,
      currency_code: currency_code
    })
  }).done(done).fail(fail);
};
var Formatters = {
  /**
   * Sets up a format for credit card number
   * @param field
   */
  setCreditCardNumberFormat: function setCreditCardNumberFormat(field) {
    if (field) {
      $(field).on('keyup', function (_ref3) {
        var target = _ref3.target;
        var refTarget = target;
        refTarget.value = creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.format(creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.parse(target.value));
      });
    }
  },
  /**
   * Sets up a format for expiration date
   * @param field
   */
  setExpirationFormat: function setExpirationFormat(field) {
    if (field) {
      $(field).on('keyup', function (_ref4) {
        var target = _ref4.target,
          which = _ref4.which;
        var refTarget = target;
        if (which === 8 && /.*(\/)$/.test(target.value)) {
          refTarget.value = target.value.slice(0, -1);
        } else if (target.value.length > 4) {
          refTarget.value = target.value.slice(0, 5);
        } else if (which !== 8) {
          refTarget.value = target.value.replace(/^([1-9]\/|[2-9])$/g, '0$1/').replace(/^(0[1-9]|1[0-2])$/g, '$1/').replace(/^([0-1])([3-9])$/g, '0$1/$2').replace(/^(0[1-9]|1[0-2])([0-9]{2})$/g, '$1/$2').replace(/^([0]+)\/|[0]+$/g, '0').replace(/[^\d\/]|^[\/]*$/g, '').replace(/\/\//g, '/');
        }
      });
    }
  }
};
var Validators = {
  /**
   * Sets up a validation for credit card number
   * @param validator
   * @param field
   */
  setCreditCardNumberValidation: function setCreditCardNumberValidation(validator, field, errorMessage) {
    if (field) {
      validator.add({
        selector: field,
        validate: function validate(cb, val) {
          var result = val.length && creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.isValid(creditcards__WEBPACK_IMPORTED_MODULE_0___default().card.parse(val));
          cb(result);
        },
        errorMessage: errorMessage
      });
    }
  },
  /**
   * Sets up a validation for expiration date
   * @param validator
   * @param field
   */
  setExpirationValidation: function setExpirationValidation(validator, field, errorMessage) {
    if (field) {
      validator.add({
        selector: field,
        validate: function validate(cb, val) {
          var expiry = val.split('/');
          var result = val.length && /^(0[1-9]|1[0-2])\/([0-9]{2})$/.test(val);
          result = result && !creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.isPast(creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.month.parse(expiry[0]), creditcards__WEBPACK_IMPORTED_MODULE_0___default().expiration.year.parse(expiry[1], true));
          cb(result);
        },
        errorMessage: errorMessage
      });
    }
  },
  /**
   * Sets up a validation for name on card
   * @param validator
   * @param field
   */
  setNameOnCardValidation: function setNameOnCardValidation(validator, field, errorMessage) {
    if (field) {
      validator.add({
        selector: field,
        validate: function validate(cb, val) {
          var result = !!val.length;
          cb(result);
        },
        errorMessage: errorMessage
      });
    }
  },
  /**
   * Sets up a validation for cvv
   * @param validator
   * @param field
   */
  setCvvValidation: function setCvvValidation(validator, field, errorMessage) {
    if (field) {
      validator.add({
        selector: field,
        validate: function validate(cb, val) {
          var result = val.length && creditcards__WEBPACK_IMPORTED_MODULE_0___default().cvc.isValid(val);
          cb(result);
        },
        errorMessage: errorMessage
      });
    }
  }
};

/***/ }),

/***/ "./assets/js/theme/core/alertDismissable.js":
/*!**************************************************!*\
  !*** ./assets/js/theme/core/alertDismissable.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dismissable)
/* harmony export */ });
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery-trend */ "./node_modules/jquery-trend/jquery.trend.js");
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery_trend__WEBPACK_IMPORTED_MODULE_0__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


/**
 * Core Alert components can be loaded with a `dismissable` param. If this
 * is true, an alert-dismiss button is included in the markup.
 *
 * This function removes the alert when the button is clicked.
 */
function dismissable() {
  $('body').on('click', '.alert-dismiss', function (event) {
    event.preventDefault();
    var $target = $(event.currentTarget);
    var $alert = $target.parent('.alert');
    $alert.one('trend', function () {
      $alert.remove();
    });
    $alert.addClass('dismissed');
  });
}

/***/ }),

/***/ "./assets/js/theme/core/amp/AmpAlert.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/core/amp/AmpAlert.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Alert)
/* harmony export */ });
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/template */ "./node_modules/lodash/template.js");
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_template__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery-trend */ "./node_modules/jquery-trend/jquery.trend.js");
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_trend__WEBPACK_IMPORTED_MODULE_2__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


/**
 *  Alerts
 *
 *  Utility module to display status messages for components.
 *  Instantiate Class: new Alert()
 *
 *  @arg $el       jQuery object
 *    The specific element that will hold new alert messages.
 *
 *  @arg options  Object
 *  An object containing additional options for the module. (see below)
 */
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }

var Alert = /*#__PURE__*/function () {
  function Alert($el, options) {
    if (options === void 0) {
      options = {};
    }
    this.$el = $el;
    this.options = $.extend({
      classes: {
        base: 'alert',
        error: 'alert-error',
        info: 'alert-info',
        success: 'alert-success'
      },
      limit: 1,
      template: {},
      callbacks: {}
    }, options);
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {},
      didUpdate: function didUpdate() {}
    }, options.callbacks);
    this._bindEvents();
  }
  var _proto = Alert.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    if (lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(this.options.template)) {
      this.options.template = lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n        <div class='" + this.options.classes.base + " <%= messageType %>'>\n          <% if (isDismissable) { %>\n            <a class=\"alert-dismiss\">\n              <svg class=\"icon-x\" width=\"11\" height=\"11\" viewBox=\"0 0 11 11\" xmlns=\"http://www.w3.org/2000/svg\" role=\"presentation\">\n                <path d=\"M.367.933l9.2 9.2c.156.156.41.156.566 0 .156-.156.156-.41 0-.566l-9.2-9.2C.777.21.523.21.367.367.21.523.21.777.367.933zm9.2-.566l-9.2 9.2c-.156.156-.156.41 0 .566.156.156.41.156.566 0l9.2-9.2c.156-.156.156-.41 0-.566-.156-.156-.41-.156-.566 0z\" fill-rule=\"nonzero\" fill=\"currentColor\"/>\n              </svg>\n            </a>\n          <% } %>\n          <div class=\"alert-message\">\n            <%= messageText %>\n          </div>\n        </div>\n      ");
    }
    this.$el.on('click', '.alert-dismiss', function (event) {
      event.preventDefault();
      var $alert = $(event.currentTarget).parent('.alert');
      _this._dismissMessage($alert);
    });
    this.$el.on('clear-messages', function () {
      _this.clear();
    });
  }

  /**
   * This method can be used to reset the contents of this.$el
   */;
  _proto.clear = function clear() {
    var _this2 = this;
    this.$el.find("." + this.options.classes.base).each(function (index, target) {
      _this2._dismissMessage($(target));
    });
  }

  /**
   * If bc-core becomes integrated into bc-skeleton, this method should delegate to `dismissable()`
   * @param $alert
   * @private
   */;
  _proto._dismissMessage = function _dismissMessage($alert) {
    $alert.addClass('dismissed');
    $alert.one('trend', function () {
      $alert.remove();
    });
  }

  /**
   * Explicit usage to create an error alert
   * @param text
   * @param dismissable
   */;
  _proto.error = function error(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'error', dismissable);
  }

  /**
   * Explicit usage to create a success alert
   * @param text
   * @param dismissable
   */;
  _proto.success = function success(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'success', dismissable);
  }

  /**
   * Explicit usage to create an informational alert
   * @param text
   * @param dismissable
   */;
  _proto.info = function info(text, dismissable) {
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.message(text, 'info', dismissable);
  }

  /**
   *
   * @param text
   * @param type
   * @param dismissable
   */;
  _proto.message = function message(text, type, dismissable) {
    if (type === void 0) {
      type = 'info';
    }
    if (dismissable === void 0) {
      dismissable = false;
    }
    this.callbacks.willUpdate(this.$el);
    if (typeof this.options.limit === 'number' && this.$el.find("." + this.options.classes.base).length > this.options.limit) {
      this._dismissMessage(this.$el.find("." + this.options.classes.base + ":not(.dismissed)").eq(0));
    }
    var message = {
      messageType: this.options.classes[type],
      messageText: text,
      isDismissable: dismissable
    };
    var $alert = this.$el.append(this.options.template(message));
    this.callbacks.didUpdate($alert, this.$el);
  };
  return Alert;
}();


/***/ }),

/***/ "./assets/js/theme/core/amp/AmpProductUtils.js":
/*!*****************************************************!*\
  !*** ./assets/js/theme/core/amp/AmpProductUtils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProductUtils)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _AmpAlert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AmpAlert */ "./assets/js/theme/core/amp/AmpAlert.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var ProductUtils = /*#__PURE__*/function () {
  function ProductUtils(el, options) {
    this.$el = $(el);
    this.options = options;
    this.$body = $(document.body);
    this.productId = this.$el.find('[data-product-id]').val();

    // class to add or remove from cart-add button depending on variation availability
    this.buttonDisabledClass = 'button-disabled';

    // two alert locations based on action
    this.cartAddAlert = new _AmpAlert__WEBPACK_IMPORTED_MODULE_1__["default"](this.$body.find('[data-product-cart-message]'));
    this.cartOptionAlert = new _AmpAlert__WEBPACK_IMPORTED_MODULE_1__["default"](this.$el.find('[data-product-option-message]'));
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {},
      didUpdate: function didUpdate() {}
    }, options.callbacks);
  }
  var _proto = ProductUtils.prototype;
  _proto.init = function init(context) {
    this.context = context;
    this._bindProductOptionChange();
    this._boundCartCallback = this._bindCartAdd.bind(this);
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.on('cart-item-add', this._boundCartCallback);
    this._updateAttributes(window.BCData.product_attributes);
  }

  /**
   * Cache an object of jQuery elements for DOM updating
   * @param  jQuery $el - a wrapping element of the scoped product
   * @return {object} - buncha jQuery elements which may or may not exist on the page
   */;
  _proto._getViewModel = function _getViewModel($el) {
    return {
      $addToCart: $('[data-button-purchase]', $el)
    };
  }

  /**
   * Bind product options changes.
   */;
  _proto._bindProductOptionChange = function _bindProductOptionChange() {
    var _this = this;
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.on('product-option-change', function (event, changedOption) {
      var $changedOption = $(changedOption);
      var $form = $changedOption.parents('form');

      // Do not trigger an ajax request if it's a file or if the browser doesn't support FormData
      if ($changedOption.attr('type') === 'file' || window.FormData === undefined) {
        return;
      }
      _this.cartAddAlert.clear();
      _this.cartOptionAlert.clear();

      // product template should be passed as a string
      var productTemplate = _this.options.template && typeof _this.options.template === 'string' ? _this.options.template : null;
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.productAttributes.optionChange(_this.productId, $form.serialize(), productTemplate, function (err, response) {
        var viewModel = _this._getViewModel(_this.$el);
        var data = response ? response.data : {};

        // If our form data doesn't include the product-options-count with a positive value, return
        if (_this.$el.find('[data-product-options-count]').val < 1) {
          return;
        }
        _this._updateAttributes(data);

        // update submit button state
        if (!data.purchasable || !data.instock) {
          _this.cartOptionAlert.error(data.purchasing_message);
          viewModel.$addToCart.addClass(_this.buttonDisabledClass).prop('disabled', true);
        } else {
          viewModel.$addToCart.removeClass(_this.buttonDisabledClass).prop('disabled', false);
        }
      });
    });
  }

  /**
   * Validate and update quantity input value
   */;
  _proto._updateQuantity = function _updateQuantity(event) {
    var $target = $(event.currentTarget);
    var $quantity = $target.closest('[data-product-quantity]').find('[data-quantity-control-input]');
    var min = parseInt($quantity.prop('min'), 10);
    var max = parseInt($quantity.prop('max'), 10);
    var newQuantity = parseInt($quantity.val(), 10);
    if (isNaN(newQuantity)) {
      newQuantity = min;
    }
    if ($target.is('[data-quantity-increment]') && (!max || newQuantity < max)) {
      newQuantity = newQuantity + 1;
    } else if ($target.is('[data-quantity-decrement]') && newQuantity > min) {
      newQuantity = newQuantity - 1;
    }
    $quantity.val(newQuantity);
  };
  _proto._updateAttributes = function _updateAttributes(data) {
    var _this2 = this;
    var behavior = data.out_of_stock_behavior;
    var inStockIds = data.in_stock_attributes;
    var outOfStockMessage = " (" + data.out_of_stock_message + ")";
    if (behavior !== 'hide_option' && behavior !== 'label_option') {
      return;
    }
    $('[data-product-attribute-value]', this.$el).each(function (i, attribute) {
      var $attribute = $(attribute);
      var attrId = parseInt($attribute.data('product-attribute-value'), 10);
      if (inStockIds.indexOf(attrId) !== -1) {
        _this2._enableAttribute($attribute, behavior, outOfStockMessage);
      } else {
        _this2._disableAttribute($attribute, behavior, outOfStockMessage);
      }
    });
  };
  _proto._disableAttribute = function _disableAttribute($attribute, behavior, outOfStockMessage) {
    if (this._getAttributeType($attribute) === 'set-select') {
      return this.disableSelectOptionAttribute($attribute, behavior, outOfStockMessage);
    }
    if (behavior === 'hide_option') {
      $attribute.hide();
    } else {
      $attribute.addClass('option-unavailable');
    }
  };
  _proto.disableSelectOptionAttribute = function disableSelectOptionAttribute($attribute, behavior, outOfStockMessage) {
    if (behavior === 'hide_option') {
      $attribute.toggleOption(false);
    } else {
      $attribute.attr('disabled', 'disabled');
      $attribute.html($attribute.html().replace(outOfStockMessage, '') + outOfStockMessage);
    }
  };
  _proto._enableAttribute = function _enableAttribute($attribute, behavior, outOfStockMessage) {
    if (this._getAttributeType($attribute) === 'set-select') {
      return this.enableSelectOptionAttribute($attribute, behavior, outOfStockMessage);
    }
    if (behavior === 'hide_option') {
      $attribute.show();
    } else {
      $attribute.removeClass('option-unavailable');
    }
  };
  _proto.enableSelectOptionAttribute = function enableSelectOptionAttribute($attribute, behavior, outOfStockMessage) {
    if (behavior === 'hide_option') {
      $attribute.toggleOption(true);
    } else {
      $attribute.removeAttr('disabled');
      $attribute.html($attribute.html().replace(outOfStockMessage, ''));
    }
  };
  _proto._getAttributeType = function _getAttributeType($attribute) {
    var $parent = $attribute.closest('[data-product-attribute]');
    return $parent ? $parent.data('product-attribute') : null;
  }

  /**
   * Add a product to cart
   */;
  _proto._bindCartAdd = function _bindCartAdd(event, form) {
    var _this3 = this;
    // Do not do AJAX if browser doesn't support FormData
    if (window.FormData === undefined) {
      return;
    }
    event.preventDefault();
    var formData = new FormData(form);
    this.callbacks.willUpdate($(form));

    // Remove old alters
    this.cartAddAlert.clear();
    this.cartOptionAlert.clear();

    // Add item to cart
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.itemAdd(formData, function (err, response) {
      if (err || response.data.error) {
        response = err || response.data.error;

        /**
         * interpret and display cart-add error message
         */
        _this3.cartAddAlert.message(response, 'error', true);
        _this3.callbacks.didUpdate(response, $(form));
      } else {
        return window.top.location = _this3.context.urlsCart;
      }
    });
  };
  return ProductUtils;
}();


/***/ }),

/***/ "./assets/js/theme/core/amp/AmpQuantityWidget.js":
/*!*******************************************************!*\
  !*** ./assets/js/theme/core/amp/AmpQuantityWidget.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AmpQuantityWidget)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var AmpQuantityWidget = function AmpQuantityWidget(options) {
  if (options === void 0) {
    options = {};
  }
  this.options = $.extend({
    el: '[data-quantity-control]',
    cntrl: '[data-quantity-control-action]',
    scope: 'body'
  }, options);

  // Bind Control Actions
  $(this.options.scope).on('click', this.options.cntrl, function (event) {
    event.preventDefault(); //in case we use <button>/<a> instead of <span>'s
    var $target = $(event.currentTarget);
    var action = $target.data('quantity-control-action');
    var $quantityInput = $target.siblings('input');
    var value = parseInt($quantityInput.val(), 10);
    var min = $quantityInput.attr('min') ? parseInt($quantityInput.attr('min'), 10) : 0;
    var max = $quantityInput.attr('max') ? parseInt($quantityInput.attr('max'), 10) : Infinity;
    if (action === 'increment' && value < max) {
      $quantityInput.val(value + 1).trigger('change');
    } else if (action === 'decrement' && value > 0 && value > min) {
      $quantityInput.val(value - 1).trigger('change');
    }
  });

  // Simple input validation (keep input within min/max range)
  // Feel free to remove and replace with another form of validation
  $(this.options.scope).on('change', 'input', function (event) {
    var $target = $(event.target);
    var value = parseInt($target.val(), 10);
    var min = $target.attr('min') ? parseInt($target.attr('min'), 10) : 0;
    var max = $target.attr('max') ? parseInt($target.attr('max'), 10) : Infinity;
    if (value > max) {
      console.error("Quantity \"" + value + "\" cannot be greater than maximum (" + max + ")");
      $target.val($target.attr('value'));
    }
    if (value < min) {
      console.error("Quantity value \"" + value + "\" cannot be less than minimum (" + min + ")");
      $target.val($target.attr('value'));
    }
  });
};


/***/ }),

/***/ "./assets/js/theme/core/downloadGallery.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/core/downloadGallery.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ gallery)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/**
 * Simple image gallery for orders with digital downloads.
 */
function gallery() {
  var $thumbs = $('[data-account-download-thumb]');
  var $image = $('[data-account-download-image]');
  $thumbs.on('click', function (event) {
    var $target = $(event.currentTarget);
    $image.attr('src', $target.attr('src'));
  });
}

/***/ }),

/***/ "./assets/js/theme/core/formSelectedValue.js":
/*!***************************************************!*\
  !*** ./assets/js/theme/core/formSelectedValue.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formSelectedValue)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var fieldSelector = '[data-swatch-selector]';
var valueSelector = '.swatch-wrap[data-swatch-value]';
var labelSelector = '.swatch-value[data-swatch-value]';

/**
 * Show selected value next to the form field title.
 *
 * Only applies to swatch form fields.
 */
function formSelectedValue() {
  $(document.body).on('click', valueSelector, function (event) {
    var $target = $(event.currentTarget);
    var $label = $target.parents(fieldSelector).find(labelSelector);
    $label.html($target.data('swatch-value'));
  });
}

/***/ }),

/***/ "./assets/js/theme/core/selectOption.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/core/selectOption.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/**
 * Visually hides the option from user by moving option to an invisible
 * and disabled select placeholder element.
 *
 * This approach is required rather than simply hiding the option because
 * hidden option can still be included when serializeArray() is called and
 * cause wrong value to be submitted.
 * (eg. if you have option 1, 2, 3 and 2 is hidden, when you select 3,
 * serializeArray() will use the value of 2 instead of 3)
 */
function toggleOption(show) {
  var currentSelectElement = $(this).closest('select'); // the select containing this
  var disabledSelectElement; // the disabled select element
  var selectElement; // the real select element

  if (currentSelectElement.is(':disabled')) {
    disabledSelectElement = currentSelectElement;
    selectElement = disabledSelectElement.data('linkedSelectElement');
  } else {
    selectElement = currentSelectElement;
    disabledSelectElement = currentSelectElement.data('linkedSelectElement');
    if (!disabledSelectElement) {
      // create the disabled placeholder select element
      disabledSelectElement = $('<select>').prop('disabled', true).hide().attr('name', currentSelectElement.attr('name')).addClass(currentSelectElement.attr('class')).data('linkedSelectElement', selectElement).insertAfter(selectElement);
      selectElement.data('linkedSelectElement', disabledSelectElement);
    }
  }

  // save the selected option
  var selectedOption = selectElement.find('option:selected');

  // update .form-selected-text element
  var text = selectElement.find("[value=\"" + selectedOption.val() + "\"]").text();
  var $prefix = selectElement.parents('.form-select-wrapper').data('selected-prefix');
  $prefix = $prefix ? "<span class=\"form-selected-text-prefix\">" + $prefix + "</span>" : '';
  selectElement.siblings('.form-selected-text').html($prefix + text);

  // move the option to the correct select element if required
  if (currentSelectElement.is(':disabled') && show) {
    var previousIndex = this.data('index');
    if (previousIndex > 0) {
      // loop through to put the select element in it's proper place
      for (var i = previousIndex; i > 0; i--) {
        if (selectElement.find("option:eq(" + (i - 1) + ")").length) {
          this.insertAfter(selectElement.find("option:eq(" + (i - 1) + ")"));
          break;
        }
      }
    } else {
      $(this).appendTo(selectElement);
    }
  } else if (!currentSelectElement.is(':disabled') && !show) {
    this.data('index', currentSelectElement.find('option').index(this));
    $(this).prependTo(disabledSelectElement);
  }

  // make sure the option is still selected
  selectedOption.prop('selected', true);
}
$.fn.toggleOption = toggleOption;

/***/ }),

/***/ "./assets/js/theme/core/updateState.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/core/updateState.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateState)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }


/**
 * Return a "State" select input
 * @param  {obj}      responseData - response from utils.api.country.getByName
 * @param  {obj}      stateAttrs - name and ID of field
 * @param  {bool}     useId - should we use the state name or ID as the value?
 * @return {jQuery}   a select input
 */
function stateAsSelect(responseData, stateAttrs, useId) {
  var stateArray = [];
  stateArray.push("<option value=\"\">" + responseData.prefix + "</option>");
  for (var _iterator = _createForOfIteratorHelperLoose(responseData.states), _step; !(_step = _iterator()).done;) {
    var state = _step.value;
    var optionValue = useId ? state.id : state.name;
    stateArray.push("<option value=\"" + optionValue + "\">" + state.name + "</option>");
  }
  var $stateSelect = $('<select>', {
    class: 'form-input form-select',
    id: stateAttrs.stateId,
    name: stateAttrs.stateName,
    required: true,
    'aria-required': true,
    'data-field-type': 'State',
    html: stateArray.join(' ')
  });
  return $stateSelect;
}

/**
 * Return a "State" text input
 * @param  {obj}      stateAttrs - name and ID of field
 * @return {jQuery}   an text input
 */
function stateAsInput(stateAttrs) {
  var $stateInput = $('<input>', {
    class: 'form-input',
    type: 'text',
    id: stateAttrs.stateId,
    name: stateAttrs.stateName,
    'data-field-type': 'State'
  });
  return $stateInput;
}

/**
 * Toggle between a state select and text input
 * @param  {obj}      event    Country select change event
 * @param  {bool}     useId    whether to use the state id or name for option value
 * @param  {Function} callback [description]
 */
function fetchAndUpdateStateInput(event, useId, callback) {
  var $target = $(event.currentTarget);
  var country = $target.val();
  var $stateElement = $('[data-field-type="State"]');
  var stateAttrs = {
    stateId: $stateElement.attr('id'),
    stateName: $stateElement.attr('name')
  };
  var $stateWrapper = $('#FormField_12');
  _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.country.getByName(country, function (err, response) {
    if (response.data.states.length) {
      // build and attach our select input
      var $stateSelect = stateAsSelect(response.data, stateAttrs, useId);
      $stateElement.replaceWith($stateSelect);
      $stateWrapper.toggleClass('form-required', true);
    } else {
      // build and attach our text input
      var $stateInput = stateAsInput(stateAttrs);
      $stateElement.replaceWith($stateInput);
      $stateWrapper.toggleClass('form-required', false);
    }
    var $newStateElement = $('[data-field-type="State"]');
    var $newStateElementParent = $newStateElement.parent();
    var $selectedText = $newStateElementParent.find('.form-selected-text');
    if (response.data.states.length) {
      $newStateElementParent.addClass('form-select-wrapper');
      if ($selectedText.length) {
        $selectedText.text(response.data.prefix);
      } else {
        $newStateElementParent.prepend("<span class=\"form-selected-text\">" + response.data.prefix + "</span>");
      }
      if (callback) {
        callback($newStateElement);
      }
    } else {
      $selectedText.remove();
      $newStateElementParent.removeClass('form-select-wrapper');
    }
  });
}

/**
 * Bind the thing to the change event and export it
 */
function updateState(useId, callback) {
  $(document.body).on('change', '[data-field-type="Country"]', function (event) {
    fetchAndUpdateStateInput(event, useId, callback);
  });
}

/***/ }),

/***/ "./assets/js/theme/global/Dropdown.js":
/*!********************************************!*\
  !*** ./assets/js/theme/global/Dropdown.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Dropdown)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var Dropdown = /*#__PURE__*/function () {
  function Dropdown(el) {
    var _this = this;
    this.$el = $(el);
    this._bindEvents();
    this.timeoutLeave = null;
    this.delayLeave = 300; // Adjust the delay to a value that works best for you

    // Add event listener for scroll
    $(window).on('scroll', function () {
      _this._handleScroll();
    });

    // Apply margin-top initially if user is at the top
    this._handleScroll();
  }
  var _proto = Dropdown.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    // Using mouseenter and mouseleave for better control
    this.$el.on('mouseenter', function (event) {
      return _this2._handleMouseEnter(event);
    });
    this.$el.on('mouseleave', function (event) {
      return _this2._handleMouseLeave(event);
    });

    // Close dropdowns when mouse leaves the navigation container
    $('.navigation-container').on('mouseleave', function () {
      _this2._hideAllChildren(true);
    });

    // Add event listener for mouseover on root list items
    this.$el.find('.mega-nav-root-item').on('mouseover', function (event) {
      _this2._handleRootItemMouseOver(event);
    });
  };
  _proto._handleMouseEnter = function _handleMouseEnter(event) {
    var $dropdown = $(event.currentTarget);
    var $dropdownPanel = $dropdown.find('.dropdown-panel');
    clearTimeout(this.timeoutLeave); // Clear previous leave timeout

    $('.dropdown-open').not($dropdown).removeClass('dropdown-open').find('.dropdown-panel').revealer('hide');

    // Only apply margin-top when at the top
    if ($(window).scrollTop() === 0) {
      $dropdownPanel.css('margin-top', '-5px');
    }
    $dropdown.addClass('dropdown-open');
    $dropdown.find('.top-level-nav-link').addClass('dropdown-open');
    $dropdownPanel.revealer('show');

    // Reset visibility of all tier 3 categories
    $dropdownPanel.find('.mega-nav-child-list-container').removeClass('visible');

    // Remove any existing hover effect
    $dropdownPanel.find('.mega-nav-root-list .mega-nav-root-item').removeClass('hovered');
    $dropdownPanel.find('.mega-nav-root-list a').removeClass('active');

    // Simulate hover for the first immediate tier 2 category
    var $firstTier2 = $dropdownPanel.find('.mega-nav-root-list .mega-nav-root-item').first();
    if ($firstTier2.length > 0) {
      $firstTier2.addClass('hovered');

      // Apply effect to the <a> element inside elements with the class 'hovered'
      $firstTier2.find('a').addClass('active');

      // Show tier 3 categories belonging to the hovered tier 2 category
      var categoryId = $firstTier2.data('category-id');
      var $childList = $dropdownPanel.find('[data-root-category-id="' + categoryId + '"]');
      if ($childList.length > 0) {
        $childList.closest('.mega-nav-child-list-container').addClass('visible');
      }
    }
  };
  _proto._handleMouseLeave = function _handleMouseLeave(event) {
    var $dropdown = $(event.currentTarget);
    var $dropdownPanel = $dropdown.find('.dropdown-panel');
    this.timeoutLeave = setTimeout(function () {
      // Check if mouse pointer is not over the dropdown or its panel
      if (!$dropdown.is(':hover') && !$dropdownPanel.is(':hover')) {
        // Close the dropdown
        $dropdown.removeClass('dropdown-open');
        $dropdownPanel.revealer('hide');
        $dropdown.removeClass('active'); // Remove active class when mouse leaves
        $dropdown.find('.top-level-nav-link').removeClass('dropdown-open');
      }
    }, this.delayLeave);
  };
  _proto._handleRootItemMouseOver = function _handleRootItemMouseOver(event) {
    var $rootItem = $(event.currentTarget);
    var $dropdownPanel = $rootItem.closest('.dropdown-panel');

    // Remove 'hovered' class from all root list items
    $dropdownPanel.find('.mega-nav-root-item').removeClass('hovered');
    // Add 'hovered' class to the current root list item
    $rootItem.addClass('hovered');
    // Show tier 3 categories belonging to the hovered tier 2 category
    var categoryId = $rootItem.data('category-id');
    var $childList = $dropdownPanel.find('[data-root-category-id="' + categoryId + '"]');

    // Hide all child containers
    $dropdownPanel.find('.mega-nav-child-list-container').removeClass('visible');
    if ($childList.length > 0) {
      $childList.closest('.mega-nav-child-list-container').addClass('visible');
    }
  }

  // Handle scroll event to remove margin-top property when scrolled down more than 50px
  ;
  _proto._handleScroll = function _handleScroll() {
    var $dropdownPanel = this.$el.find('.dropdown-panel');
    if ($(window).scrollTop() > 50) {
      $dropdownPanel.css('margin-top', '');
    } else {
      $dropdownPanel.css('margin-top', '0px');
    }
  };
  _proto._hideAllChildren = function _hideAllChildren(removeActive) {
    if (removeActive === void 0) {
      removeActive = false;
    }
    if (removeActive) {
      this.$el.find('[data-mega-nav-root-item]').removeClass('hovered active');
    }
    this.$el.find('.mega-nav-child-list-container').removeClass('visible');
  };
  return Dropdown;
}();


/***/ }),

/***/ "./assets/js/theme/global/FacetedSearch.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/global/FacetedSearch.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FacetedSearch)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");
/* harmony import */ var bc_loading__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bc-loading */ "./node_modules/bc-loading/dist/loading.js");
/* harmony import */ var history_js_scripts_bundled_uncompressed_html4_html5_jquery_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history.js/scripts/bundled-uncompressed/html4+html5/jquery.history */ "./node_modules/history.js/scripts/bundled-uncompressed/html4+html5/jquery.history.js");
/* harmony import */ var history_js_scripts_bundled_uncompressed_html4_html5_jquery_history__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(history_js_scripts_bundled_uncompressed_html4_html5_jquery_history__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }





var FacetedSearch = /*#__PURE__*/function () {
  function FacetedSearch(options, callback) {
    var _this = this;
    this.callback = callback;
    this.$body = $(document.body);
    this.options = $.extend({
      config: {
        category: {
          shop_by_price: true
        }
      },
      template: {
        productListing: 'category/product-listing',
        sidebar: 'category/sidebar'
      },
      scope: {
        productListing: '[data-category]',
        sidebar: '[data-category-sidebar]'
      },
      facetToggle: '[data-facet-toggle]',
      moreToggle: '[data-facet-more]',
      moreFacets: '[data-show-more-facets]',
      toggleFacet: function toggleFacet() {
        return console.log('Facet toggled.');
      }
    }, options);
    this.loadingOptions = {
      loadingMarkup: "<div class=\"loading-overlay\">" + (0,_svgIcon__WEBPACK_IMPORTED_MODULE_4__["default"])('spinner') + "</div>"
    };
    this.facetedSearchOverlay = new bc_loading__WEBPACK_IMPORTED_MODULE_2__["default"](this.loadingOptions, false, '.listing-sidebar');
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return _this.facetedSearchOverlay.show();
      },
      didUpdate: function didUpdate() {
        return _this.facetedSearchOverlay.hide();
      }
    }, options.callbacks);
    this._bindEvents();
    this._sanitizeFacets();
  }
  var _proto = FacetedSearch.prototype;
  _proto.init = function init(options) {
    this.options.template = $.extend({
      productListing: this.options.template.productListing,
      sidebar: this.options.template.sidebar
    }, options.template);
    this._onStateChange();
  };
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    this.$body.on('click', this.options.facetToggle, function (event) {
      _this2._toggleFacet(event);
    });
    this.$body.on('click', this.options.moreToggle, function (event) {
      _this2._showAdditionalFilters(event);
    });
    this.$body.on('click', this.options.moreFacets, function (event) {
      _this2._showMoreFacets(event);
    });
    $(window).on('statechange', this._onStateChange.bind(this));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.hooks.on('facetedSearch-facet-clicked', this._onFacetClick.bind(this));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.hooks.on('facetedSearch-range-submitted', this._onRangeSubmit.bind(this));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.hooks.on('sortBy-submitted', this._onSortBySubmit.bind(this));
  }

  // clean up user defined facet ids / show more links for special characters
  ;
  _proto._sanitizeFacets = function _sanitizeFacets() {
    $('.facet-list-items').each(function (index, element) {
      var oldTargetId = $(element).attr('id');
      var newTargetId = oldTargetId.toLowerCase().replace(/[^a-z0-9-]+/g, '-');
      $(element).attr('id', newTargetId);
    });
    $('.facet-toggle-more').each(function (index, element) {
      var oldHref = $(element).attr('href');
      var newHref = oldHref.toLowerCase().replace(/[^a-z0-9\-#]+/g, '-');
      $(element).attr('href', newHref);
    });
  };
  _proto._showMoreFacets = function _showMoreFacets(event) {
    var _this3 = this;
    // Show/hide extra facets based on settings for product filtering
    event.preventDefault();
    this.callbacks.willUpdate();
    var $toggle = $(event.currentTarget);
    var $navList = $($toggle.attr('href'));
    var facet = $navList.data('facet');
    var facetUrl = "" + window.location.origin + window.location.pathname;
    var params = {
      list_all: facet
    };
    if (window.location.search) {
      var queryString = window.location.search;
      var urlParams = new URLSearchParams(queryString);
      for (var _iterator = _createForOfIteratorHelperLoose(urlParams), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
        params[key] = value;
      }
    }
    if ($toggle.siblings('.faceted-search-option-columns').length == 0) {
      if (this.options.showMore) {
        _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.api.getPage(facetUrl, {
          template: this.options.showMore,
          params: params
        }, function (err, response) {
          if (err) {
            throw new Error(err);
          }
          $(response).insertAfter($navList);
          $toggle.siblings('.faceted-search-option-columns').addClass('visible');
          _this3.callbacks.didUpdate();
        });
      }
    } else {
      $toggle.siblings('.faceted-search-option-columns').toggle();
      this.callbacks.didUpdate();
    }
    $navList.toggle();

    // toggle more/less link
    $toggle.children().toggle();
    return false;
  };
  _proto._showAdditionalFilters = function _showAdditionalFilters(event) {
    event.preventDefault();
    $(event.currentTarget).addClass('hidden').parent('li').siblings('li').removeClass('hidden');
  };
  _proto._toggleFacet = function _toggleFacet(event) {
    this.options.toggleFacet(event);
  };
  _proto._onFacetClick = function _onFacetClick(event, target) {
    event.preventDefault();
    var $target = $(target);
    var url = $target.attr('href');
    this._goToUrl(url);
  };
  _proto._onRangeSubmit = function _onRangeSubmit(event, target) {
    event.preventDefault();
    var url = url__WEBPACK_IMPORTED_MODULE_1__.parse(window.location.href);
    var queryParams = $(target).serialize();
    if (this.$body.hasClass('search')) {
      var currentSearch = "search_query=" + $('[data-faceted-search]').data('search-query') || 0;
      queryParams = currentSearch + "&" + queryParams;
    }
    this._goToUrl(url__WEBPACK_IMPORTED_MODULE_1__.format({
      pathname: url.pathname,
      search: '?' + queryParams
    }));
  };
  _proto._onSortBySubmit = function _onSortBySubmit(event, target) {
    event.preventDefault();
    var url = url__WEBPACK_IMPORTED_MODULE_1__.parse(location.href, true);
    var queryParams = $(target).serialize().split('=');
    url.query[queryParams[0]] = queryParams[1];
    delete url.query['page'];
    this._goToUrl(url__WEBPACK_IMPORTED_MODULE_1__.format({
      pathname: url.pathname,
      query: url.query
    }));
  };
  _proto._onStateChange = function _onStateChange(event) {
    var _this4 = this;
    this.callbacks.willUpdate();
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__.api.getPage(History.getState().url, this.options, function (err, content) {
      if (err) {
        throw new Error(err);
        _this4.callbacks.didUpdate();
        return;
      }
      if (content) {
        $(_this4.options.scope.productListing).html(content.productListing);
        $(_this4.options.scope.sidebar).html(content.sidebar);
        _this4.callbacks.didUpdate();
        _this4._sanitizeFacets();
      }
    });
  };
  _proto._goToUrl = function _goToUrl(url) {
    History.pushState({}, document.title, url);
  };
  return FacetedSearch;
}();


/***/ }),

/***/ "./assets/js/theme/global/Header.js":
/*!******************************************!*\
  !*** ./assets/js/theme/global/Header.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Header)
/* harmony export */ });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var Header = /*#__PURE__*/function () {
  function Header(el) {
    this.$el = $(el);
    this.$body = $('body');
    this.$wrapper = $('.site-wrapper');
    this.$searchWrap = $('.search-wrap');
    this.$header = $('.site-header');
    this.$topBar = this.$header.find('.top-bar');
    this.$navBar = this.$header.find('.main-nav-bar');
    this.cartOpenClass = 'mini-cart-open';
    this.searchOpenClass = 'search-open';
    this.navOpenClass = 'nav-mobile-open scroll-locked';
    this.$loginRegister = $('.login-register-block');
    this.$forgotPassword = $('.forgot-password-block');
    this._bindEvents();
    this._adjustHeights();
    this._headerScroll();
  }
  var _proto = Header.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    // Toggle mini cart panel
    this.$el.find('.button-cart-toggle').on('click', function (event) {
      _this._toggleMiniCart();
      event.stopPropagation();
    });

    // Close mini cart panel
    $('.button-cart-close').on('click', function () {
      _this._toggleMiniCart(false);
    });
    $('.on-canvas').on('click', function () {
      if ($('.mini-cart-open').length) {
        _this._toggleMiniCart(false);
      }
    });

    // Close UI elemets with esc key
    $(document).on('keyup', function (e) {
      // Mini cart
      if (e.keyCode === 27 && _this.$body.hasClass(_this.cartOpenClass)) {
        _this._toggleMiniCart(false);
      }

      // Search
      if (e.keyCode === 27 && _this.$searchWrap.hasClass(_this.searchOpenClass)) {
        _this._toggleSearch(false);
      }
    });

    // Toggle search
    $('.button-search-toggle').on('click', function () {
      _this._toggleSearch();

      // Close cart
      if (_this.$wrapper.hasClass(_this.cartOpenClass)) {
        _this._toggleMiniCart(false);
      }
    });

    // Close Search
    $('.button-search-close').on('click', function () {
      _this._toggleSearch(false);
    });

    // Toggle mobile nav
    $('.button-mobile-nav-toggle').on('click', function () {
      _this._toggleMobileNav();
    });

    // Handle resize events and provide debounce to prevent too much
    this._handleResize = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(this._handleResize.bind(this), 200);
    $(window).resize(this._handleResize);
  };
  _proto._handleResize = function _handleResize() {
    // Reset the mobile panel if window is made larger
    this._adjustHeights();

    // Check header height on resize for class application
    this._headerScroll();
  };
  _proto._toggleMiniCart = function _toggleMiniCart(open) {
    // Pass "false" to remove the class / close cart
    this.$body.toggleClass(this.cartOpenClass, open);
  };
  _proto._toggleSearch = function _toggleSearch(open) {
    this.$searchWrap.toggleClass(this.searchOpenClass, open);
    if (this.$searchWrap.hasClass(this.searchOpenClass)) {
      this.$searchWrap.find('.search-input').focus();
    }
  };
  _proto._toggleMobileNav = function _toggleMobileNav(open) {
    this.$body.toggleClass(this.navOpenClass, open);
    if (open === false) {
      $('.navigation-mobile').revealer('hide');
    } else {
      $('.navigation-mobile').revealer('toggle');
    }
  };
  _proto._headerScroll = function _headerScroll() {
    // determine whether the navigtion has a second row, and disallow "compressed" state if true
    var defaultNavbarHeight = 100;
    var $currentNavBar = this.$navBar.find('.navigation').find('ul:first-child');
    var currentNavBarHeight = $currentNavBar.outerHeight();
    if (currentNavBarHeight > defaultNavbarHeight) {
      this.$navBar.addClass('multi-row');
      $currentNavBar.addClass('enforce-max-width');
      return false;
    } else {
      this.$navBar.removeClass('multi-row');
      $currentNavBar.removeClass('enforce-max-width');
    }
    var $win = $(window);
    /*     const threshold = 80;
        const scrollClass = 'compressed';
    
        // if we load the page part way down
        if ($win.scrollTop() > threshold) {
          this.$header.addClass(scrollClass);
        }
    
        $win.resize(() => {
          const compressHeader = false;
          currentNavBarHeight = $currentNavBar.outerHeight();
    
          if (currentNavBarHeight > defaultNavbarHeight) {
            this.$header.toggleClass(scrollClass, compressHeader);
          }
        }); */

    /* $win.scroll(() => {
      const st = $win.scrollTop();
      const compressHeader = (st > 0) ? true : false; // Always compress header on scroll
         this.$header.toggleClass(scrollClass, compressHeader);
    }); */
  };
  _proto._adjustHeights = function _adjustHeights() {
    var $canvas = this.$body.find('.site-canvas');
    var defaultTopBarHeight = 56;
    var topBarHeight = this.$topBar.outerHeight();
    var defaultFullHeaderHeight = 156;
    var currentFullHeaderHeight = this.$header.outerHeight();
    if (this.$header.hasClass('compressed')) {
      $canvas.css('padding-top', defaultTopBarHeight + 'px'); // Remove padding when header is compressed
    } else {
      if (this.$navBar.is(':hidden')) {
        if (topBarHeight > defaultTopBarHeight) {
          $canvas.css('padding-top', topBarHeight + 'px');
        } else {
          $canvas.css('padding-top', defaultTopBarHeight + 'px');
        }
      } else {
        // Calculate the total height of the top bar and the main navigation bar
        var totalHeight = topBarHeight + this.$navBar.outerHeight();

        // If the total height exceeds the default full header height, reduce the top padding of the canvas
        if (totalHeight > defaultFullHeaderHeight) {
          $canvas.css('padding-top', totalHeight + 'px');
        } else {
          $canvas.css('padding-top', defaultFullHeaderHeight + 'px');
        }
      }
    }
    if (topBarHeight > defaultTopBarHeight) {
      var $mobileNav = this.$body.find('.navigation-mobile');
      $mobileNav.css({
        'top': topBarHeight + 'px'
      });
    }
  };
  return Header;
}();


/***/ }),

/***/ "./assets/js/theme/global/MegaNav.js":
/*!*******************************************!*\
  !*** ./assets/js/theme/global/MegaNav.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MegaNav)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var MegaNav = /*#__PURE__*/function () {
  function MegaNav(el) {
    this.$el = $(el);
    this.$rootMenu = this.$el.find('.mega-nav-root-list');
    this.$childContainer = this.$el.find('.mega-nav-child-container');
    this.$dropdownToggle = this.$el.closest('.dropdown').find('.dropdown-toggle');
    this._bindEvents();
    this._hideAllChildren(true);
  }
  var _proto = MegaNav.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    // Change event from 'mouseover' to 'mouseenter' for better performance
    this.$el.on('mouseenter', '[data-mega-nav-root-item]', function (e) {
      e.preventDefault();
      _this._findChildFromRoot(e);
      e.stopPropagation();
    });

    // Add event to remove hover effect when mouse leaves the entire navigation area
    this.$el.on('mouseleave', function () {
      // Remove hover effect from all root items
      _this.$el.find('[data-mega-nav-root-item]').removeClass('hovered');
    });
  };
  _proto._findChildFromRoot = function _findChildFromRoot(e) {
    if (this.dropdownOpen) {
      this._hideAllChildren(true);
    }
    this.dropdownOpen = true;
    var $rootItem = $(e.currentTarget);
    var categoryId = $rootItem.data('category-id');
    var $childList = this.$el.find('[data-root-category-id="' + categoryId + '"]');
    $rootItem.addClass('active');
    clearTimeout(this.childTimer);
    this.childTimer = setTimeout(function () {
      $childList.revealer('show');
    }, 100);
  };
  _proto._findChild = function _findChild(e) {
    if (this.dropdownOpen) {
      this._hideAllChildren(true);
    }
    var $target = $(e.currentTarget);
    var childId = $target.data('mega-nav-child-id');
    var $childList = this.$childContainer.find('[data-root-category-id="' + childId + '"]');

    // Hide all other child categories immediately

    this.$childContainer.find('.mega-nav-child-list-container').removeClass('visible');
    if ($childList.length > 0) {
      // Show the relevant child category after a short delay

      clearTimeout(this.childTimer);
      this.childTimer = setTimeout(function () {
        $childList.closest('.mega-nav-child-list-container').addClass('visible');
      }, 100); // Adjust the delay as needed
    }
    this.dropdownOpen = true;
  };
  _proto._findChild = function _findChild(e) {
    var $target = $(e.currentTarget);
    var childId = $target.data('mega-nav-child-id');
    var $childList = this.$childContainer.find('[data-root-category-id="' + childId + '"]');
    if ($childList.length > 0) {
      this._hideAllChildren();
      window.setTimeout(function () {
        $childList.revealer('show');
      }, 500);
    }
  };
  _proto._findParent = function _findParent(e) {
    var $minus = $(e.currentTarget);
    var parentId = $minus.closest('.mega-nav-child-list-container').data('root-category-id');
    var $parent = this.$childContainer.find('[data-mega-nav-child-id="' + parentId + '"]').closest('.mega-nav-child-list-container');
    if ($parent.length > 0) {
      this._hideAllChildren();
      window.setTimeout(function () {
        $parent.revealer('show');
      }, 500);
    }
  };
  _proto._hideAllChildren = function _hideAllChildren(removeActive) {
    if (removeActive === void 0) {
      removeActive = false;
    }
    if (removeActive) {
      this.$el.find('[data-mega-nav-root-item]').removeClass('active');
    }
    this.$el.find('.mega-nav-child-list-container').revealer('hide');
  };
  _proto._adjustMegaNavPanel = function _adjustMegaNavPanel() {
    var $dropdown = this.$dropdownToggle.closest('.dropdown');
    var $megaNavPanel = $dropdownToggle.find('.mega-nav-panel');
    if ($dropdown.length > 0 && $megaNavPanel.length > 0) {
      var offset = $dropdown.offset().top + $dropdown.outerHeight();
      $megaNavPanel.css({
        'top': offset + 'px'
      });
    }
  };
  return MegaNav;
}();


/***/ }),

/***/ "./assets/js/theme/global/MiniCart.js":
/*!********************************************!*\
  !*** ./assets/js/theme/global/MiniCart.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MiniCart)
/* harmony export */ });
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var MiniCart = /*#__PURE__*/function () {
  function MiniCart() {
    this.cartChangeRemoteHooks = ['cart-item-add-remote', 'cart-item-update-remote', 'cart-item-remove-remote'];
    this._bindEvents();
  }
  var _proto = MiniCart.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    // Update minicart on successful add to cart
    $(document).on('cart-item-add-success', function () {
      _this._update();
    });

    // Remove cart item using minicart button
    $('body').on('click', '.mini-cart [data-cart-item-remove]', function (event) {
      event.preventDefault();
      _this._removeProductMiniCart(event);
    });

    // remote events: when the proper response is sent
    this.cartChangeRemoteHooks.forEach(function (hook) {
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].hooks.on(hook, function () {
        _this._update();
      });
    });

    // Custom scroll UX for minicart
    this._bindScroll();
  }

  /**
   * Update the mini cart contents
   */;
  _proto._update = function _update(callback) {
    var $miniCart = $('.mini-cart-inner');
    var $miniCartTotal = $('.site-header .mini-cart-subtotal');
    var $miniCartContents = $('.mini-cart-contents');

    // Update the minicart items when
    // a product is added / removed
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.getContent({
      template: 'mini-cart/mini-cart-contents'
    }, function (err, response) {
      $miniCartContents.html(response);

      // Update the header subtotal
      var subtotal = $(response).find('[data-cart-subtotal]').text();
      var subtotalRaw = $(response).find('.mini-cart-subtotal').attr('data-cart-subtotal');
      $miniCartTotal.html(subtotal).attr('data-cart-subtotal', subtotalRaw);
      $miniCart.animate({
        top: 0
      });
      if (callback) {
        callback();
      }
    });
  }

  /**
   * Remove a product from the mini cart
   */;
  _proto._removeProductMiniCart = function _removeProductMiniCart(event) {
    var _this2 = this;
    var $el = $(event.currentTarget);
    var itemId = $el.data('product-id');
    if (!itemId) {
      return;
    }
    $el.closest('.mini-cart-item').addClass('removing').append("" + (0,_svgIcon__WEBPACK_IMPORTED_MODULE_1__["default"])('spinner'));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_0__["default"].api.cart.itemRemove(itemId, function (err, response) {
      if (response.data.status === 'succeed') {
        _this2._update();
      } else {
        alert(response.data.errors.join('\n'));
        $el.closest('.mini-cart-item').removeClass('removing').find('.icon-spinner').remove();
      }
    });
  }

  /**
   * Custom scroll behavior for mini cart panel
   */;
  _proto._bindScroll = function _bindScroll() {
    var $win = $(window);
    var $miniCart = $('.mini-cart-inner');
    var oldScrollTop = $(window).scrollTop();
    $win.on('scroll', function () {
      var winHeight = $win.height();
      var miniCartHeight = $miniCart.height();
      var maxScroll = miniCartHeight - winHeight;
      var newScrollTop = $win.scrollTop();
      var cartTopPos = parseInt($miniCart.css('top'));
      var scrollAmount;

      // If the menu is taller than the window and visible
      if (miniCartHeight > winHeight && $('body').hasClass('mini-cart-open')) {
        // Set the amount we've scrolled
        scrollAmount = oldScrollTop - newScrollTop;

        // Move the minicart up/down the amount we scrolled
        $miniCart.css({
          top: '+=' + scrollAmount
        });

        // Get the minicart's top value after it's updated
        cartTopPos = parseInt($miniCart.css('top'));

        // Don't scroll beyond the bottom or top limits of the menu
        // The second conditon checks for 'overscroll' that occurs in webkit
        if (cartTopPos < -maxScroll || newScrollTop + winHeight >= $('.site-wrapper').outerHeight()) {
          // stop at bottom of minicart
          $miniCart.css({
            top: -maxScroll + 'px'
          });
        } else if (cartTopPos > 0 || newScrollTop <= 0) {
          // stop at top of minicart
          $miniCart.css({
            top: 0
          });
        }
      }

      // Update oldScrollTop as we scroll
      oldScrollTop = newScrollTop;
    });
  };
  return MiniCart;
}();


/***/ }),

/***/ "./assets/js/theme/global/MobileNav.js":
/*!*********************************************!*\
  !*** ./assets/js/theme/global/MobileNav.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MobileNav)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var MobileNav = /*#__PURE__*/function () {
  function MobileNav() {
    this.$body = $('body');
    this.navToggle = $('.button-mobile-nav-toggle');
    this.pageCover = $('.site-wrapper');
    this.$menu = $('.navigation');
    this.$navBackButton = $('.button-mobile-nav-back');
    this.getMenus = function (targetMenu) {
      return $("[data-mobile-menu=\"" + targetMenu + "\"]");
    };
    this.navPanel = '.nav-mobile-panel';
    this.classes = {
      active: 'is-active',
      left: 'is-left',
      right: 'is-right',
      forceState: 'force-state'
    };
    this.menuState = [];
    this._initMobile();
    this._bindMobileEvents();
  }
  var _proto = MobileNav.prototype;
  _proto._initMobile = function _initMobile() {
    $('.nav-mobile-item-parent').each(function (index, element) {
      var $children = $(element).children('.nav-mobile-panel');
      var counter = 1;
      while ($children.length) {
        $children.attr('data-panel-depth', counter).insertAfter($('.nav-mobile-panel-parent'));
        $children = $children.children().children('.nav-mobile-panel');
        counter += 1;
      }
    });
  };
  _proto._bindMobileEvents = function _bindMobileEvents() {
    var _this = this;
    $('.nav-mobile-item.has-children').on('click', function (event) {
      event.preventDefault();
      _this._traverseDown(event);
    });
    this.$navBackButton.on('click', function (event) {
      _this._traverseBack();
    });
  };
  _proto._traverseDown = function _traverseDown(event) {
    var targetMenu = $(event.currentTarget).children().data('toggle-mobile');
    this.$body.addClass('mobile-nav-open');

    // Move previous active to the left
    $(event.currentTarget).closest(this.navPanel).addClass(this.classes.left).removeClass(this.classes.active);

    // Active new menu and move into place from right
    this.getMenus(targetMenu).removeClass(this.classes.right).addClass(this.classes.active);

    // Update the back button id
    var prevMenu = $(event.currentTarget).parents('.nav-mobile-panel').data('mobile-menu');
    this.menuState.push(prevMenu);
  };
  _proto._traverseBack = function _traverseBack() {
    // Move previous active to the right
    $(this.navPanel).filter("." + this.classes.active).removeClass(this.classes.active).addClass(this.classes.right);

    // Position new active menu from the left
    var targetMenu = this.menuState.pop();
    this.getMenus(targetMenu).removeClass(this.classes.left).addClass(this.classes.active);
    if (targetMenu === 'all') {
      this.$body.removeClass('mobile-nav-open');
    }
  };
  return MobileNav;
}();


/***/ }),

/***/ "./assets/js/theme/global/fillFacetRatingStars.js":
/*!********************************************************!*\
  !*** ./assets/js/theme/global/fillFacetRatingStars.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  $('.product-item-rating-facet.full').prevAll('.product-item-rating-facet').addClass('full');
}

/***/ }),

/***/ "./assets/js/theme/global/initCompare.js":
/*!***********************************************!*\
  !*** ./assets/js/theme/global/initCompare.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initCompare: () => (/* binding */ initCompare),
/* harmony export */   updateCompare: () => (/* binding */ updateCompare)
/* harmony export */ });
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/template */ "./node_modules/lodash/template.js");
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_template__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var bc_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bc-compare */ "./node_modules/bc-compare/dist/js/ProductCompare.js");
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");



var compare = new bc_compare__WEBPACK_IMPORTED_MODULE_1__["default"]({
  maxItems: 4,
  itemTemplate: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <li class=\"compare-tab-item\" data-compare-item>\n      <div class=\"compare-tab-item-wrap\">\n        <a class=\"compare-tab-item-remove\" data-compare-item-remove=\"<%= id %>\">" + (0,_svgIcon__WEBPACK_IMPORTED_MODULE_2__["default"])('close') + "</a>\n        <a href=\"<%= url %>\">\n          <div class=\"compare-tab-item-thumb\" style=\"background-image: url(<%= thumbnail %>)\"></div>\n        </a>\n\n        <div class=\"compare-tab-item-description\">\n          <a href=\"<%= url %>\" class=\"compare-tab-item-title\"><%= title %></a>\n          <div class=\"compare-tab-item-price\"><%= price %></div>\n        </div>\n      </div>\n    </li>\n  ")
});
function initCompare() {
  compare.on('updated', function () {
    $('.compare-items-count').text(compare.compareList.size);
    if (compare.compareList.size > 0) {
      $('[data-compare-widget], .mobile-compare-link').addClass('compare-active');
    } else {
      $('[data-compare-widget], .mobile-compare-link').removeClass('compare-active');
    }
  }, true);
  $('[data-compare-remove-all]').on('click', function (event) {
    event.preventDefault();
    compare.removeAll();
  });
}
function updateCompare() {
  compare.updateCheckboxes();
}

/***/ }),

/***/ "./assets/js/theme/global/quick-search.js":
/*!************************************************!*\
  !*** ./assets/js/theme/global/quick-search.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");


var QuickSearch = /*#__PURE__*/function () {
  function QuickSearch() {
    this.debounceWaitTime = 300; // Adjust debounce time as needed
    this.$quickSearchResults = $('.quickSearchResults');
    this.$quickSearchForms = $('[data-quick-search-form]');
    this.$searchQuery = this.$quickSearchForms.find('[data-search-quick]');
    this.$quickSearchAriaMessage = $('.aria-description--hidden');
    this.searchResultsVisible = false; // Track if search results are visible

    this._bindEvents();
  }
  var _proto = QuickSearch.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    var doSearch = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(function (searchQuery) {
      if (searchQuery.length === 0) {
        _this.$quickSearchResults.empty();
        _this.$quickSearchAriaMessage.empty(); // Clear aria-live region
        _this.searchResultsVisible = false;
        return;
      }
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.search.search(searchQuery, {
        template: 'search/quick-results'
      }, function (err, response) {
        if (err) {
          return false;
        }
        _this.$quickSearchResults.html(response);
        var $quickSearchResultsCurrent = _this.$quickSearchResults.filter(':visible');
        var $noResultsMessage = $quickSearchResultsCurrent.find('.quickSearchMessage');
        if ($noResultsMessage.length) {
          $noResultsMessage.attr({
            role: 'status',
            'aria-live': 'polite'
          });
          _this.$quickSearchAriaMessage.empty(); // Clear aria-live region
        } else {
          _this.$quickSearchAriaMessage.addClass('u-hidden');
          var predefinedText = _this.$quickSearchAriaMessage.data('search-aria-message-predefined-text');
          var itemsFoundCount = $quickSearchResultsCurrent.find('.product').length;
          _this.$quickSearchAriaMessage.text(itemsFoundCount + " " + predefinedText + " " + searchQuery);
          setTimeout(function () {
            _this.$quickSearchAriaMessage.removeClass('u-hidden');
          }, 100);
        }
        _this.searchResultsVisible = true; // Mark search results as visible
      });
    }, this.debounceWaitTime);
    this.$searchQuery.on('input', function (event) {
      var searchQuery = $(event.currentTarget).val();
      if (searchQuery.length === 0) {
        _this.$quickSearchResults.empty(); // Hide results if input is cleared
        _this.$quickSearchAriaMessage.empty(); // Clear aria-live region
        _this.searchResultsVisible = false;
      }
      $(event.currentTarget).trigger('search-quick', event.currentTarget);
    });
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.on('search-quick', function (event, currentTarget) {
      var searchQuery = $(currentTarget).val();
      doSearch(searchQuery);
    });

    // Hide search results when clicking outside
    $(document).on('click', function (event) {
      if (!$(event.target).closest(_this.$quickSearchForms).length) {
        _this.$quickSearchResults.empty(); // Hide results
        _this.searchResultsVisible = false;
      }
    });

    // Show search results when focusing on the search bar
    this.$searchQuery.on('focus', function (event) {
      if (_this.searchResultsVisible && _this.$searchQuery.val().length > 0) {
        var searchQuery = _this.$searchQuery.val();
        doSearch(searchQuery); // Re-fetch the results
      }
    });
  };
  return QuickSearch;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (QuickSearch);

/***/ }),

/***/ "./assets/js/theme/global/svgIcon.js":
/*!*******************************************!*\
  !*** ./assets/js/theme/global/svgIcon.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(iconClass) {
  return "<svg class=\"icon icon-" + iconClass + "\"><use xlink:href=\"#icon-" + iconClass + "\" /></svg>";
}
;

/***/ }),

/***/ "./assets/js/theme/global/toggleFacet.js":
/*!***********************************************!*\
  !*** ./assets/js/theme/global/toggleFacet.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _svgIcon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svgIcon */ "./assets/js/theme/global/svgIcon.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  var $target = $(event.currentTarget);
  var $trigger = $target.find('.facet-list-toggle');
  $target.parents('[data-facet-filter]').children('[data-facet-filter-wrapper]').toggleClass('is-open');
  if ($target.hasClass('is-open')) {
    $trigger.html((0,_svgIcon__WEBPACK_IMPORTED_MODULE_0__["default"])('minus'));
  } else {
    $trigger.html((0,_svgIcon__WEBPACK_IMPORTED_MODULE_0__["default"])('plus'));
  }
  $target.toggleClass('is-open');
}

/***/ }),

/***/ "./assets/js/theme/product/AttributesHelper.js":
/*!*****************************************************!*\
  !*** ./assets/js/theme/product/AttributesHelper.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AttributesHelper)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var AttributesHelper = /*#__PURE__*/function () {
  function AttributesHelper(el) {
    this.el = el;
  }
  var _proto = AttributesHelper.prototype;
  _proto.updateAttributes = function updateAttributes(data) {
    var _this = this;
    if (data === undefined) {
      return;
    }
    var behavior = data.out_of_stock_behavior;
    var inStockIds = data.in_stock_attributes;
    var outOfStockMessage = " (" + data.out_of_stock_message + ")";
    if (behavior !== 'hide_option' && behavior !== 'label_option') {
      return;
    }
    $('[data-product-attribute-value]', $('body').find(this.el)).each(function (i, attribute) {
      var $attribute = $(attribute);
      var attrId = parseInt($attribute.data('product-attribute-value'), 10);
      if (inStockIds.indexOf(attrId) !== -1) {
        _this.enableAttribute($attribute, behavior, outOfStockMessage);
      } else {
        _this.disableAttribute($attribute, behavior, outOfStockMessage);
      }
    });
  };
  _proto.disableAttribute = function disableAttribute($attribute, behavior, outOfStockMessage) {
    if (this.getAttributeType($attribute) === 'set-select') {
      return this.disableSelectOptionAttribute($attribute, behavior, outOfStockMessage);
    }
    if (behavior === 'hide_option') {
      $attribute.hide();
    } else {
      $attribute.addClass('option-unavailable');
    }
  };
  _proto.disableSelectOptionAttribute = function disableSelectOptionAttribute($attribute, behavior, outOfStockMessage) {
    if (behavior === 'hide_option') {
      $attribute.toggleOption(false);
    } else {
      $attribute.attr('disabled', 'disabled');
      $attribute.html($attribute.html().replace(outOfStockMessage, '') + outOfStockMessage);
    }
  };
  _proto.enableAttribute = function enableAttribute($attribute, behavior, outOfStockMessage) {
    if (this.getAttributeType($attribute) === 'set-select') {
      return this.enableSelectOptionAttribute($attribute, behavior, outOfStockMessage);
    }
    if (behavior === 'hide_option') {
      $attribute.show();
    } else {
      $attribute.removeClass('option-unavailable');
    }
  };
  _proto.enableSelectOptionAttribute = function enableSelectOptionAttribute($attribute, behavior, outOfStockMessage) {
    if (behavior === 'hide_option') {
      $attribute.toggleOption(true);
    } else {
      $attribute.removeAttr('disabled');
      $attribute.html($attribute.html().replace(outOfStockMessage, ''));
    }
  };
  _proto.getAttributeType = function getAttributeType($attribute) {
    var $parent = $attribute.closest('[data-product-attribute]');
    return $parent ? $parent.data('product-attribute') : null;
  };
  return AttributesHelper;
}();


/***/ }),

/***/ "./assets/js/theme/product/ColorSwatch.js":
/*!************************************************!*\
  !*** ./assets/js/theme/product/ColorSwatch.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ColorSwatch)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/**
 *  Attach functionality to Color Swatches
 *
 * Example: new ColorSwatch('.color-swatch-item')
 *          (defaults to [data-swatch-selector])
 */
var ColorSwatch = /*#__PURE__*/function () {
  function ColorSwatch(el) {
    if (el === void 0) {
      el = "[data-swatch-selector]";
    }
    this.$el = $(el);
    this.bindSwatchEvent();
    this.$el.find('[data-default]').click();
  }

  // Update Swatch text when color is selected
  var _proto = ColorSwatch.prototype;
  _proto.bindSwatchEvent = function bindSwatchEvent() {
    this.$el.on('click', 'label', function (e) {
      var $target = $(e.currentTarget);
      var $swatchText = $target.closest('[data-swatch-selector]').find('.swatch-value');
      var $swatchValue = $target.data('swatch-value');
      $swatchText.text($swatchValue);
    });
  };
  return ColorSwatch;
}();


/***/ }),

/***/ "./assets/js/theme/product/ImageZoom.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/product/ImageZoom.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageZoom)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var ImageZoom = /*#__PURE__*/function () {
  function ImageZoom(el) {
    this.$el = $(el);

    // create empty image
    var defaultImg = new Image();
    // set src so we can access the other attribute data
    defaultImg.src = this.$el.find('img').attr('src');
    this.image = {
      offset: this.$el.offset(),
      width: this.$el.width(),
      height: this.$el.height()
    };

    // Only init if image is wide enough to zoom
    if (defaultImg.width / this.image.width > 1.4) {
      this._bindEvents();
    } else {
      this.$el.addClass('no-zoom').height(this.$el.parent().height());
    }
  }
  var _proto = ImageZoom.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.$el.on('mousemove', function (event) {
      _this._zoomImage(event);
    });
  };
  _proto._zoomImage = function _zoomImage(event) {
    var $wrapper = $('.product-slides-wrap').offset();
    var topOffset = $wrapper.top;
    var leftOffset = $wrapper.left;
    var top = (event.pageY - topOffset) / this.image.height * 100;
    var left = (event.pageX - leftOffset) / this.image.width * 100;
    this.$el.css('background-position', left + "% " + top + "%");
  };
  return ImageZoom;
}();


/***/ }),

/***/ "./assets/js/theme/product/ProductImages.js":
/*!**************************************************!*\
  !*** ./assets/js/theme/product/ProductImages.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProductImages)
/* harmony export */ });
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slick-carousel */ "./node_modules/slick-carousel/slick/slick.js");
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(slick_carousel__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ImageZoom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ImageZoom */ "./assets/js/theme/product/ImageZoom.js");
/* harmony import */ var baguettebox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! baguettebox.js */ "./node_modules/baguettebox.js/dist/baguetteBox.min.js");
/* harmony import */ var baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(baguettebox_js__WEBPACK_IMPORTED_MODULE_3__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");





// Define custom black SVGs
var customLeftArrow = '<svg width="44" height="60">' + '<polyline points="30 10 10 30 30 50" stroke="black" stroke-width="4"' + 'stroke-linecap="butt" fill="none" stroke-linejoin="round"/>' + '</svg>';
var customRightArrow = '<svg width="44" height="60">' + '<polyline points="14 10 34 30 14 50" stroke="black" stroke-width="4"' + 'stroke-linecap="butt" fill="none" stroke-linejoin="round"/>' + '</svg>';
var customCloseX = '<svg width="30" height="30">' + '<g stroke="black" stroke-width="4">' + '<line x1="5" y1="5" x2="25" y2="25"/>' + '<line x1="5" y1="25" x2="25" y2="5"/>' + '</g></svg>';

// Custom Infinite Looping for baguetteBox
baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().run('.product-slides-wrap', {
  leftArrow: customLeftArrow,
  rightArrow: customRightArrow,
  closeX: customCloseX,
  preload: 2,
  buttons: 'auto',
  animation: 'slideIn',
  noScrollbars: false,
  fullScreen: false,
  afterShow: function afterShow() {
    // Rebinding event listeners for next and previous arrows
    var totalImages = document.querySelectorAll('.product-slides-wrap a').length;

    // Reset any existing event listeners
    var nextButton = document.querySelector('#next-button');
    var prevButton = document.querySelector('#previous-button');

    // Removing any existing listeners to avoid piling up
    nextButton.removeEventListener('click', nextImage);
    prevButton.removeEventListener('click', previousImage);

    // Next image function with loop
    var nextImage = function nextImage() {
      var currentIndex = baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().getCurrentIndex();
      var nextIndex = (currentIndex + 1) % totalImages; // Loop back to start after the last image
      baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().show(nextIndex); // Show the next image
    };

    // Previous image function with loop
    var previousImage = function previousImage() {
      var currentIndex = baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().getCurrentIndex();
      var prevIndex = (currentIndex - 1 + totalImages) % totalImages; // Loop back to end after the first image
      baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().show(prevIndex); // Show the previous image
    };

    // Bind new event listeners after clearing the old ones
    nextButton.addEventListener('click', nextImage);
    prevButton.addEventListener('click', previousImage);
  }
});
var ProductImages = /*#__PURE__*/function () {
  function ProductImages(el) {
    this.$el = $(el);
    this.maxSlidesBeforeArrows = 5;
    this.classes = {
      container: '.product-images-container',
      slidesWrap: '.product-slides-wrap',
      pagination: '.product-images-pagination',
      paginationItem: '.pagination-item',
      loader: '.product-images-loader'
    };
    this.$pagination = this.$el.closest(this.classes.container).find(this.classes.pagination);
    this._init();
  }
  var _proto = ProductImages.prototype;
  _proto._init = function _init() {
    var _this = this;
    imagesloaded__WEBPACK_IMPORTED_MODULE_1___default()(this.$el[0], function () {
      var _this$$pagination$sli;
      // Hide loader
      _this.$el.parents(_this.classes.container).find(_this.classes.loader).addClass('initialized');

      // Image zoom
      _this.$el.on('init', function () {
        _this.$el.find('[data-product-image]').each(function (i, el) {
          new _ImageZoom__WEBPACK_IMPORTED_MODULE_2__["default"](el);
        });
      });

      // Init slick carousel with infinite looping
      _this.$el.slick({
        infinite: true,
        // Enable infinite looping
        arrows: false,
        dots: false,
        adaptiveHeight: true,
        asNavFor: _this.classes.pagination,
        draggable: true,
        swipe: true,
        touchThreshold: 10,
        edgeFriction: 0.15
      });
      _this.imageCount = _this.$pagination.find(_this.classes.paginationItem).length;
      if (_this.imageCount > _this.maxSlidesBeforeArrows) {
        _this.$pagination.addClass('pagination-has-arrows');
      }
      _this.$pagination.on('setPosition', function (event, slick) {
        if (slick.$slides.length > _this.maxSlidesBeforeArrows) {
          _this.$pagination.addClass('pagination-has-arrows');
        } else {
          _this.$pagination.removeClass('pagination-has-arrows');
        }
      });
      _this.$pagination.slick((_this$$pagination$sli = {
        infinite: true,
        // Enable infinite looping
        centerMode: false,
        dots: false,
        swipe: true,
        loop: true,
        lazyLoad: 'progressive',
        arrows: true,
        prevArrow: '<div class="product-images-pagination-icon pagination-prev"><svg width="44" height="60"><polyline points="30 10 10 30 30 50" stroke="black" stroke-width="4" stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg></div>',
        nextArrow: '<div class="product-images-pagination-icon pagination-next"><svg width="44" height="60"><polyline points="14 10 34 30 14 50" stroke="black" stroke-width="4" stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg></div>',
        slidesToShow: 5,
        slidesToScroll: 1,
        variableWidth: false,
        rows: 0,
        asNavFor: _this.classes.slidesWrap,
        focusOnSelect: true,
        draggable: true
      }, _this$$pagination$sli["swipe"] = true, _this$$pagination$sli));

      // Reinitialize the baguetteBox with infinite looping for zoomed images
      baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().run(_this.classes.slidesWrap, {
        leftArrow: customLeftArrow,
        rightArrow: customRightArrow,
        closeX: customCloseX
      });
    });
  };
  return ProductImages;
}();


/***/ }),

/***/ "./assets/js/theme/product/ProductReviews.js":
/*!***************************************************!*\
  !*** ./assets/js/theme/product/ProductReviews.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProductReviews)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var ProductReviews = /*#__PURE__*/function () {
  function ProductReviews(context) {
    this.context = context;
    this._bindRating();
  }
  var _proto = ProductReviews.prototype;
  _proto._bindRating = function _bindRating() {
    $('#rating-stars').on('change', function (event) {
      var rating = $(event.currentTarget).val();
      var ratingLabel = $(event.currentTarget).find('option:selected').text();
      $('.review-form').find('.icon-star-wrap').removeClass('full').each(function (index, el) {
        if (index + 1 <= rating) {
          $(el).addClass('full');
        }
      });
      $('.review-form').find('.rating-stars-label').html(ratingLabel);
    });
  };
  return ProductReviews;
}();


/***/ }),

/***/ "./assets/js/theme/product/ProductUtils.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/product/ProductUtils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProductUtils)
/* harmony export */ });
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _components_Alert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/Alert */ "./assets/js/theme/components/Alert.js");
/* harmony import */ var _utils_FormValidator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/FormValidator */ "./assets/js/theme/utils/FormValidator.js");
/* harmony import */ var _utils_ProgressButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/ProgressButton */ "./assets/js/theme/utils/ProgressButton.js");
/* harmony import */ var _resetProductImages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resetProductImages */ "./assets/js/theme/product/resetProductImages.js");
/* harmony import */ var _AttributesHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AttributesHelper */ "./assets/js/theme/product/AttributesHelper.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }






var ProductUtils = /*#__PURE__*/function () {
  function ProductUtils(el, options) {
    this.$el = $(el);
    this.options = $.extend({
      onImageSwitch: function onImageSwitch() {}
    }, options);
    this.productId = this.$el.find('[data-product-id]').val();
    this.pageAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_2__["default"]($('[data-alerts]'));
    this.productAlerts = new _components_Alert__WEBPACK_IMPORTED_MODULE_2__["default"]($('[data-product-alerts]'));
    this.productTitle = $(el).data('product-title');
    this.$productContainer = $('[data-product-container]');
    this.productAttributesData = window.BCData.product_attributes;
    this.$form = this.$el.find('form[data-cart-item-add]');
    this.$addToCart = this.$form.find('[data-button-purchase]');
    this.attributesHelper = new _AttributesHelper__WEBPACK_IMPORTED_MODULE_6__["default"](el);
    this.progressButton = new _utils_ProgressButton__WEBPACK_IMPORTED_MODULE_4__["default"]();
    this.callbacks = $.extend({
      willUpdate: function willUpdate() {
        return console.log('Update requested.');
      },
      didUpdate: function didUpdate() {
        return console.log('Update executed.');
      },
      switchImage: function switchImage(url) {
        return console.log("Image switch attempted for " + url);
      }
    }, options.callbacks);
    this._boundProductOptionChange = this._bindProductOptionChange.bind(this);
    this.boundCartCallback = this._bindAddToCart.bind(this);
    this._bindEvents();
  }
  var _proto = ProductUtils.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    this.$el.find('.product-quantity-toggle').on('click', function (event) {
      _this._updateQuantity(event);
    });
    this.$el.find('.product-quantity').on('focusout', function (event) {
      _this._checkQuantity(event.currentTarget);
    });
  };
  _proto.init = function init(context) {
    var _this2 = this;
    this.context = context;
    var $productOptionsElement = $('[data-product-option-change]', this.$form);
    var hasOptions = $productOptionsElement.length > 0 ? true : false;
    var hasDefaultOptions = $productOptionsElement.find('[data-default]').length;
    if (hasDefaultOptions || lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default()(this.productAttributesData) && hasOptions) {
      var $productId = $('[name="product_id"]', this.$form).val();
      _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.productAttributes.optionChange($productId, this.$form.serialize(), 'products/add-to-cart-form', function (err, response) {
        var attributesData = response.data || {};
        var attributesContent = response.content || {};
        _this2.attributesHelper.updateAttributes(attributesData);
        if (hasDefaultOptions) {
          _this2._updateView(attributesData);
        }
      });
    } else {
      this.attributesHelper.updateAttributes(this.productAttributesData);
    }
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.on('product-option-change', this._boundProductOptionChange);
    this._bindAddWishlist();
    this.Validator = new _utils_FormValidator__WEBPACK_IMPORTED_MODULE_3__["default"](this.context);
    this.Validator.initSingle(this.$el.find('form[data-cart-item-add]'));
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.on('cart-item-add', this.boundCartCallback);

    // Trigger a change event so the values are correct for pre-selected options
    this.$el.find('[data-cart-item-add]').find('input[type="radio"], input[type="checkbox"], select').first().change();
  }

  /**
   *
   * Cleanup - useful for closing quickshop modals
   *
   */;
  _proto.destroy = function destroy() {
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.off('cart-item-add', this.boundCartCallback);
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.off('product-option-change', this._boundProductOptionChange);
  }

  /**
   * Cache an object of jQuery elements for DOM updating
   * @param  jQuery $el - a wrapping element of the scoped product
   * @return {object} - buncha jQuery elements which may or may not exist on the page
   */;
  _proto._getViewModel = function _getViewModel($el) {
    return {
      $price: $('[data-product-price-wrapper="without-tax"]', $el),
      $priceWithTax: $('[data-product-price-wrapper="with-tax"]', $el),
      $saved: $('[data-product-price-saved]', $el),
      $sku: $('[data-product-sku]', $el),
      $weight: $('[data-product-weight]', $el),
      $addToCart: $('[data-button-purchase]', $el),
      $imagePreview: $('[data-variation-preview]', $el),
      stock: {
        $selector: $('[data-product-stock]', $el),
        $level: $('[data-product-stock-level]', $el)
      }
    };
  }

  /**
  * https://stackoverflow.com/questions/49672992/ajax-request-fails-when-sending-formdata-including-empty-file-input-in-safari
  * Safari browser with jquery 3.3.1 has an issue uploading empty file parameters. This function removes any empty files from the form params
  * @param formData: FormData object
  * @returns FormData object
  */;
  _proto.filterEmptyFilesFromForm = function filterEmptyFilesFromForm(formData) {
    try {
      for (var _iterator = _createForOfIteratorHelperLoose(formData), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
          key = _step$value[0],
          val = _step$value[1];
        if (val instanceof File && !val.name && !val.size) {
          formData.delete(key);
        }
      }
    } catch (e) {
      console.error(e); // eslint-disable-line no-console
    }
    return formData;
  }

  /**
   * Bind product options changes.
   */;
  _proto._bindProductOptionChange = function _bindProductOptionChange(_ref, changedOption) {
    var _this3 = this;
    var target = _ref.target;
    var formProductId = target.closest('[data-product-id]').dataset.productId;
    if (formProductId !== this.productId) {
      return;
    }
    var $changedOption = $(changedOption);
    var $form = $changedOption.parents('form');

    // Do not trigger an ajax request if it's a file or if the browser doesn't support FormData
    if ($changedOption.attr('type') === 'file' || window.FormData === undefined) {
      return;
    }
    this.pageAlerts.clear();
    this.productAlerts.clear();
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.productAttributes.optionChange(this.productId, $form.serialize(), 'products/add-to-cart-form', function (err, response) {
      var productAttributesData = response.data || {};
      var productAttributesContent = response.content || {};

      // If our form data doesn't include the product-options-count with a positive value, return
      if (_this3.$el.find('[data-product-options-count]').val < 1) {
        return;
      }
      _this3.attributesHelper.updateAttributes(productAttributesData);
      _this3._updateView(productAttributesData);
      _this3.setProductVariant();
    });
  };
  _proto._updateView = function _updateView(data) {
    var _this4 = this;
    var viewModel = this._getViewModel(this.$el);

    // updating price
    if (viewModel.$price.length) {
      var priceStrings = {
        price: data.price,
        excludingTax: this.context.productExcludingTax,
        salePriceLabel: this.context.salePriceLabel,
        nonSalePriceLabel: this.context.nonSalePriceLabel,
        retailPriceLabel: this.context.retailPriceLabel,
        priceLabel: this.context.priceLabel
      };
      viewModel.$price.html(this.options.priceWithoutTaxTemplate(priceStrings));
    }
    if (viewModel.$priceWithTax.length) {
      var _priceStrings = {
        price: data.price,
        includingTax: this.context.productIncludingTax,
        salePriceLabel: this.context.salePriceLabel,
        nonSalePriceLabel: this.context.nonSalePriceLabel,
        retailPriceLabel: this.context.retailPriceLabel,
        priceLabel: this.context.priceLabel
      };
      viewModel.$priceWithTax.html(this.options.priceWithTaxTemplate(_priceStrings));
    }
    if (viewModel.$saved.length) {
      var _priceStrings2 = {
        price: data.price,
        savedString: this.context.productYouSave
      };
      viewModel.$saved.html(this.options.priceSavedTemplate(_priceStrings2));
    }

    // if stock view is on (CP settings)
    if (viewModel.stock.$selector.length && data.stock !== null) {
      viewModel.stock.$selector.removeClass('product-details-hidden');
      viewModel.stock.$level.text(data.stock);
    } else {
      viewModel.stock.$selector.addClass('product-details-hidden');
    }

    // update sku if exists
    if (viewModel.$sku.length) {
      viewModel.$sku.html(data.sku);
    }

    // update weight if exists
    if (data.weight && viewModel.$weight.length) {
      viewModel.$weight.html(data.weight.formatted);
    }

    // handle product variant image if exists
    if (data.image) {
      var productImageUrl = _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].tools.image.getSrc(data.image.data, this.context.themeImageSizes.zoom);
      var zoomImageUrl = _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].tools.image.getSrc(data.image.data, this.context.themeImageSizes.product);

      // to maintain a reference between option images, pull out the
      // filename from the image URL and use it as an ID
      var imageId = data.image.data.replace(/^.*[\\\/]/, '');
      this.callbacks.switchImage(productImageUrl, zoomImageUrl, data.image.alt, imageId);
    } else if (this.$el.find('[data-product-image-variant]').length) {
      (0,_resetProductImages__WEBPACK_IMPORTED_MODULE_5__["default"])(this.$el.find('.product-slides-wrap'));
    }

    // update submit button state
    if (!data.purchasable || !data.instock) {
      var out_of_stock_message = data.out_of_stock_message,
        stock_message = data.stock_message,
        purchasing_message = data.purchasing_message;
      if ($('.modal-quick-shop').length) {
        this.productAlerts.error(out_of_stock_message || stock_message || purchasing_message, true);
      } else {
        setTimeout(function () {
          _this4.pageAlerts.error(out_of_stock_message || stock_message || purchasing_message, true);
        }, 50);
      }
      viewModel.$addToCart.addClass(this.buttonDisabledClass).prop('disabled', true).children('.button-text').text(this.context.soldOutButtonLabel);
    } else {
      viewModel.$addToCart.removeClass(this.buttonDisabledClass).prop('disabled', false).children('.button-text').text(this.context.addToCartButtonLabel);
    }
  };
  _proto._updateQuantity = function _updateQuantity(event) {
    var $target = $(event.currentTarget);
    var $quantity = $target.closest('.product-quantity-container').find('.product-quantity');
    var min = parseInt($quantity.prop('min'), 10);
    var max = parseInt($quantity.prop('max'), 10);
    var newQuantity = parseInt($quantity.val(), 10);
    if (isNaN(newQuantity)) {
      newQuantity = min;
    }
    if ($target.hasClass('product-quantity-increment') && (!max || newQuantity < max)) {
      newQuantity = newQuantity + 1;
    } else if ($target.hasClass('product-quantity-decrement') && newQuantity > min) {
      newQuantity = newQuantity - 1;
    }
    $quantity.val(newQuantity);
  }

  /**
   * Add to cart
   */;
  _proto._bindAddToCart = function _bindAddToCart(event, form) {
    var _this5 = this;
    event.preventDefault();

    // Skip this callback if the product isn't the one this instance is tracking
    var formProductId = event.target.querySelector('[name=product_id]').value;
    if (formProductId !== this.productId) return;

    // Bail out if browser doesn't support FormData
    if (window.FormData === undefined) {
      return;
    }
    var quantity = this.$el.find('input.product-quantity').val();
    var formData = new FormData(form);

    // Update the button state
    this.progressButton.progress(this.$addToCart);

    // Remove old alerts
    this.pageAlerts.clear();
    this.productAlerts.clear();

    // Ajax add item to cart
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.cart.itemAdd(this.filterEmptyFilesFromForm(formData), function (err, response) {
      // Parse the ajax response so we can pass it to the message.
      response = _this5._parseResponse(err, response, _this5.productTitle, quantity);
      if (response.status === 'success') {
        setTimeout(function () {
          _this5.pageAlerts.message(response.message, response.status, true);
        }, 50);

        // Custom success event to close the quick shop and open the mini cart
        $.event.trigger('cart-item-add-success');
        setTimeout(function () {
          _this5.pageAlerts.clear();
        }, 5000);
      } else {
        _this5.productAlerts.message(response.message, response.status, true);
      }

      // Reset the button state
      _this5.progressButton.complete(_this5.$addToCart);
    });
  }

  /**
   * Build our error/success messages based on response.
   * @param {object} err - the (potential) returned error object.
   * @param {object} response - the ajax response from the add-to-cart action.
   * @param {string} title - The name of the added product.
   * @param {number} quantity - The added quantity.
   */;
  _proto._parseResponse = function _parseResponse(err, response, title, quantity) {
    var message = '';
    var status = '';
    if (err || response.data.error) {
      status = 'error';
      if (response.data.error) {
        message = response.data.error;
      } else {
        message = this.context.messagesProductGeneral;
      }
    } else {
      status = 'success';
      if (this.$productContainer.hasClass('bag-icon')) {
        message = this.context.messagesProductAddSuccessBag;
        message = message.replace('*product*', "\"" + title + "\"").replace('*bag_link*', "<a href=" + this.context.urlsCart + ">" + this.context.bagLink + "</a>").replace('*checkout_link*', "<a href=" + this.context.urlsCheckout + ">" + this.context.checkoutLink + "</a>");
      } else {
        message = this.context.messagesProductAddSuccessCart;
        message = message.replace('*product*', "\"" + title + "\"").replace('*cart_link*', "<a href=" + this.context.urlsCart + ">" + this.context.cartLink + "</a>").replace('*checkout_link*', "<a href=" + this.context.urlsCheckout + ">" + this.context.checkoutLink + "</a>");
      }
    }
    return {
      status: status,
      message: message
    };
  };
  _proto._checkQuantity = function _checkQuantity(el) {
    var $el = $(el);
    var quantity = parseInt($el.val(), 10);
    var min = parseInt($el.prop('min'));
    if (isNaN(quantity) || quantity < min) {
      $el.val(min);
    }
  }

  /**
   * Ajax add to wishlist
   *
   */;
  _proto._bindAddWishlist = function _bindAddWishlist() {
    var _this6 = this;
    $('[data-wishlist]').on('click', function (event) {
      var $button = $(event.currentTarget);
      var addUrl = $button.attr('href');
      var viewUrl = $button.data('wishlist');
      if ($('[data-is-customer]').length) {
        event.preventDefault();
        _this6.progressButton.progress($button);
        $.ajax({
          type: 'POST',
          url: addUrl,
          success: function success() {
            _this6.productAlerts.success(_this6.context.messagesWishlistAddSuccess.replace('*product*', _this6.productTitle).replace('*url*', viewUrl), true);
          },
          error: function error() {
            _this6.productAlerts.error(_this6.context.messagesWishlistAddError.replace('*product*', _this6.productTitle), true);
          },
          complete: function complete() {
            _this6.progressButton.complete($button);
            $button.closest('[data-wishlist-dropdown]').find('[data-wishlist-toggle]').trigger('click');
          }
        });
      }
    });
  };
  _proto.setProductVariant = function setProductVariant() {
    var unsatisfiedRequiredFields = [];
    var options = [];
    $.each($('[data-product-attribute]'), function (index, value) {
      var optionLabel = value.children[0].innerText;
      var optionTitle = optionLabel.split(':')[0].trim();
      var required = optionLabel.toLowerCase().includes('required');
      var type = value.getAttribute('data-product-attribute');
      if ((type === 'input-file' || type === 'input-text' || type === 'input-number') && value.querySelector('input').value === '' && required) {
        unsatisfiedRequiredFields.push(value);
      }
      if (type === 'textarea' && value.querySelector('textarea').value === '' && required) {
        unsatisfiedRequiredFields.push(value);
      }
      if (type === 'date') {
        var isSatisfied = Array.from(value.querySelectorAll('select')).every(function (select) {
          return select.selectedIndex !== 0;
        });
        if (isSatisfied) {
          var dateString = Array.from(value.querySelectorAll('select')).map(function (x) {
            return x.value;
          }).join('-');
          options.push(optionTitle + ":" + dateString);
          return;
        }
        if (required) {
          unsatisfiedRequiredFields.push(value);
        }
      }
      if (type === 'set-select') {
        var select = value.querySelector('select');
        var selectedIndex = select.selectedIndex;
        if (selectedIndex !== 0) {
          options.push(optionTitle + ":" + select.options[selectedIndex].innerText);
          return;
        }
        if (required) {
          unsatisfiedRequiredFields.push(value);
        }
      }
      if (type === 'set-rectangle' || type === 'set-radio' || type === 'swatch' || type === 'input-checkbox' || type === 'product-list') {
        var checked = value.querySelector(':checked');
        if (checked) {
          if (type === 'set-rectangle' || type === 'set-radio' || type === 'product-list') {
            var label = checked.labels[0].innerText;
            if (label) {
              options.push(optionTitle + ":" + label);
            }
          }
          if (type === 'swatch') {
            var _label = checked.labels[0].children[0];
            if (_label) {
              options.push(optionTitle + ":" + _label.title);
            }
          }
          if (type === 'input-checkbox') {
            options.push(optionTitle + ":Yes");
          }
          return;
        }
        if (type === 'input-checkbox') {
          options.push(optionTitle + ":No");
        }
        if (required) {
          unsatisfiedRequiredFields.push(value);
        }
      }
    });
    var productVariant = unsatisfiedRequiredFields.length === 0 ? options.sort().join(', ') : 'unsatisfied';
    var view = $('.product-details');
    if (productVariant) {
      productVariant = productVariant === 'unsatisfied' ? '' : productVariant;
      if (view.attr('data-event-type')) {
        view.attr('data-product-variant', productVariant);
      } else {
        var productName = view.find('.product-title')[0].innerText;
        var card = $("[data-name=\"" + productName + "\"]");
        card.attr('data-product-variant', productVariant);
      }
    }
  };
  return ProductUtils;
}();


/***/ }),

/***/ "./assets/js/theme/product/QuickShop.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/product/QuickShop.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ QuickShop)
/* harmony export */ });
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var _ProductUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ProductUtils */ "./assets/js/theme/product/ProductUtils.js");
/* harmony import */ var _ProductImages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ProductImages */ "./assets/js/theme/product/ProductImages.js");
/* harmony import */ var _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./productViewTemplates */ "./assets/js/theme/product/productViewTemplates.js");
/* harmony import */ var _variationImgPreview__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./variationImgPreview */ "./assets/js/theme/product/variationImgPreview.js");
/* harmony import */ var _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../product/ColorSwatch */ "./assets/js/theme/product/ColorSwatch.js");
/* harmony import */ var bc_modal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! bc-modal */ "./node_modules/bc-modal/dist/js/modal.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");








var QuickShop = /*#__PURE__*/function () {
  function QuickShop(context) {
    var _this = this;
    this.context = context;
    this.product;
    this.id = null;

    // Set up the modal options
    this.QuickShopModal = new bc_modal__WEBPACK_IMPORTED_MODULE_7__["default"]({
      modalClass: 'modal-quick-shop',
      centerVertically: false,
      afterShow: function afterShow($modal) {
        _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].hooks.off('product-option-change');
        _this._fetchProduct($modal, _this.id);
      },
      afterHide: function afterHide() {
        _this.ProductUtils = new _ProductUtils__WEBPACK_IMPORTED_MODULE_2__["default"]('[data-product-container]', {
          priceWithoutTaxTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceWithoutTax,
          priceWithTaxTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceWithTax,
          priceSavedTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceSaved,
          variationPreviewImageTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].variationPreviewImage,
          callbacks: {
            switchImage: _variationImgPreview__WEBPACK_IMPORTED_MODULE_5__["default"]
          }
        }).init(_this.context);
        _this.product.destroy();
      }
    });
    this._bindEvents();
  }

  /**
   * Launch quickshop modal on click and set up id variable
   */
  var _proto = QuickShop.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this2 = this;
    $('body').on('click', '[data-quick-shop]', function (event) {
      event.preventDefault();
      _this2.id = $(event.currentTarget).data('product-id');
      if (!_this2.id) {
        return;
      }
      _this2.QuickShopModal.open();
      $('.modal-content').prepend('<svg class="icon icon-spinner"><use xlink:href="#icon-spinner" /></svg>');
    });
  }

  /**
   * Run ajax fetch of product and add to modal. Bind product functionality and show the modal
   * @param {jQuery} $modal - the root (appended) modal element.
   * @param {integer} id - product id
   */;
  _proto._fetchProduct = function _fetchProduct($modal, id) {
    var _this3 = this;
    _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_1__["default"].api.product.getById(id, {
      template: 'quick-shop/quick-shop-modal'
    }, function (err, response) {
      $modal.find('.modal-content').append(response);

      // Init FB like if necessary
      if ($modal.find('.facebook-like').length) {
        (function (d, s, id) {
          var js,
            fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return;
          js = d.createElement(s);
          js.id = id;
          js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5";
          fjs.parentNode.insertBefore(js, fjs);
        })(document, 'script', 'facebook-jssdk');
      }

      // set up product utils (adding to cart, options)
      var $el = $modal.find('[data-product-quickshop-container]');
      _this3.product = new _ProductUtils__WEBPACK_IMPORTED_MODULE_2__["default"]($el, {
        priceWithoutTaxTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceWithoutTax,
        priceWithTaxTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceWithTax,
        priceSavedTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].priceSaved,
        variationPreviewImageTemplate: _productViewTemplates__WEBPACK_IMPORTED_MODULE_4__["default"].variationPreviewImage,
        callbacks: {
          switchImage: _variationImgPreview__WEBPACK_IMPORTED_MODULE_5__["default"]
        }
      });
      _this3.product.init(_this3.context);

      // set up simple image slideshow
      new _ProductImages__WEBPACK_IMPORTED_MODULE_3__["default"]('.modal-quick-shop .product-slides-wrap');
      _this3.swatches = new _product_ColorSwatch__WEBPACK_IMPORTED_MODULE_6__["default"](); // Init our color swatches

      // reposition modal with content
      _this3.QuickShopModal.position();
      $modal.addClass('loaded');
      $('.modal-content').children('.icon-spinner').remove();
    });
  };
  return QuickShop;
}();


/***/ }),

/***/ "./assets/js/theme/product/productViewTemplates.js":
/*!*********************************************************!*\
  !*** ./assets/js/theme/product/productViewTemplates.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/template */ "./node_modules/lodash/template.js");
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_template__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  priceWithoutTax: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <% if (price.rrp_without_tax) { %>\n      <div class=\"price-rrp-wrapper\">\n        <label class=\"price-rrp-label\"><%= retailPriceLabel %></label>\n        <span class=\"price-rrp\"><%= price.rrp_without_tax.formatted %></span>\n      </div>\n    <% } %>\n    <% if (price.non_sale_price_without_tax) { %>\n      <div class=\"price-ns-wrapper\">\n        <label class=\"price-ns-label\"><%= nonSalePriceLabel %></label>\n        <span class=\"price-ns\">\n          <%= price.non_sale_price_without_tax.formatted %>\n        </span>\n      </div>\n    <% } %>\n    <div class=\"price-value-wrapper\">\n      <!-- If there's another price show \"now\" label -->\n      <% if (price.non_sale_price_without_tax) { %>\n        <label class=\"price-value-label\"><%= salePriceLabel %></label>\n      <% } else { %>\n        <label class=\"price-label\"><%= priceLabel %></label>\n      <% } %>\n      <span class=\"price-value\" data-product-price>\n        <%= price.without_tax.formatted %>\n      </span>\n      <% if (price.with_tax && price.without_tax) { %>\n        <span class=\"price-tax-label\"><%= excludingTax %></span>\n      <% } %>\n    </div>\n  "),
  priceWithTax: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <% if (price.rrp_with_tax) { %>\n      <div class=\"price-rrp-wrapper\">\n        <label class=\"price-rrp-label\"><%= retailPriceLabel %></label>\n        <span class=\"price-rrp\"><%= price.rrp_with_tax.formatted %></span>\n      </div>\n    <% } %>\n    <% if (price.non_sale_price_without_tax) { %>\n      <div class=\"price-ns-wrapper\">\n        <label class=\"price-ns-label\"><%= nonSalePriceLabel %></label>\n        <span class=\"price-ns\">\n          <%= price.non_sale_price_with_tax.formatted %>\n        </span>\n      </div>\n    <% } %>\n    <div class=\"price-value-wrapper\">\n      <!-- If there's another price show \"now\" label -->\n      <% if (price.non_sale_price_with_tax) { %>\n        <label class=\"price-value-label\"><%= salePriceLabel %></label>\n      <% } else { %>\n        <label class=\"price-label\"><%= priceLabel %></label>\n      <% } %>\n      <span class=\"price-value\" data-product-price>\n        <%= price.with_tax.formatted %>\n      </span>\n      <% if (price.with_tax && price.without_tax) { %>\n        <span class=\"price-tax-label\"><%= includingTax %></span>\n      <% } %>\n    </div>\n  "),
  priceSaved: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <% if (price.saved) { %>\n      <%= savedString %> <%= price.saved.formatted %>\n    <% } %>\n  "),
  variationImage: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <a class=\"product-image\" style=\"background-image:url(<%= zoomImageSrc %>);\" href=\"<%= zoomImageSrc %>\" data-product-image data-product-image-variant>\n      <img src=\"<%= productImageSrc %>\">\n    </a>\n  "),
  variationImageNav: lodash_template__WEBPACK_IMPORTED_MODULE_0___default()("\n    <div class=\"pagination-item\" data-variant-id=\"<%= id %>\">\n      <img src=\"<%= productImageSrc %>\">\n    </div>\n  ")
});

/***/ }),

/***/ "./assets/js/theme/product/resetProductImages.js":
/*!*******************************************************!*\
  !*** ./assets/js/theme/product/resetProductImages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ resetProductImages)
/* harmony export */ });
/* harmony import */ var _utils_scrollToTop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/scrollToTop */ "./assets/js/theme/utils/scrollToTop.js");

function resetProductImages($el) {
  var numSlides = $el.find('[data-product-image]').length - 1;
  var mainSlide = $el.find('[data-product-image]').index('[data-product-main-image]');
  $el.slick('slickGoTo', mainSlide);
  $el.slick('slickRemove', numSlides);
  (0,_utils_scrollToTop__WEBPACK_IMPORTED_MODULE_0__["default"])();
}

/***/ }),

/***/ "./assets/js/theme/product/variationImgPreview.js":
/*!********************************************************!*\
  !*** ./assets/js/theme/product/variationImgPreview.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ variationImgPreview)
/* harmony export */ });
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slick-carousel */ "./node_modules/slick-carousel/slick/slick.js");
/* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(slick_carousel__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _productViewTemplates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./productViewTemplates */ "./assets/js/theme/product/productViewTemplates.js");
/* harmony import */ var _ProductImages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ProductImages */ "./assets/js/theme/product/ProductImages.js");
/* harmony import */ var baguettebox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! baguettebox.js */ "./node_modules/baguettebox.js/dist/baguetteBox.min.js");
/* harmony import */ var baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(baguettebox_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _ImageZoom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ImageZoom */ "./assets/js/theme/product/ImageZoom.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! imagesloaded */ "./node_modules/imagesloaded/imagesloaded.js");
/* harmony import */ var imagesloaded__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(imagesloaded__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _utils_scrollToTop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/scrollToTop */ "./assets/js/theme/utils/scrollToTop.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");







function variationImgPreview(productImageUrl, zoomImageUrl, alt, imageId) {
  var productImgs = '.product-slides-wrap';

  // Only append if image doesn't already exist.
  // Otherwise, scroll to it.
  if (!$("img[src=\"" + productImageUrl + "\"]").length) {
    var numSlides = $('[data-product-image]').length;
    if ($('[data-product-image-variant]').length) {
      $(productImgs).slick('slickRemove', numSlides - 1);
    }
    baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().destroy();

    // Add carousel image
    $(productImgs).slick('slickAdd', _productViewTemplates__WEBPACK_IMPORTED_MODULE_1__["default"].variationImage({
      productImageSrc: productImageUrl,
      zoomImageSrc: zoomImageUrl,
      alt: alt
    }));
    imagesloaded__WEBPACK_IMPORTED_MODULE_5___default()(productImgs, {
      background: true
    }, function () {
      baguettebox_js__WEBPACK_IMPORTED_MODULE_3___default().run('.product-slides-wrap', {});
      $(productImgs).slick('slickGoTo', numSlides + 1);

      // Image zoom for newly added image
      $(productImgs).find('[data-product-image]').each(function (i, el) {
        new _ImageZoom__WEBPACK_IMPORTED_MODULE_4__["default"](el);
      });
    });
  }
}
;

/***/ }),

/***/ "./assets/js/theme/product/wishlistDropdown.js":
/*!*****************************************************!*\
  !*** ./assets/js/theme/product/wishlistDropdown.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ wishlistDropdown)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var wishlistDropdown = /*#__PURE__*/function () {
  function wishlistDropdown() {
    this.dropdown = '[data-wishlist-dropdown]';
    this.toggle = '[data-wishlist-toggle]';
    this.panel = '[data-wishlist-panel]';
    this._bindEvents();
  }
  var _proto = wishlistDropdown.prototype;
  _proto._bindEvents = function _bindEvents() {
    var _this = this;
    $(document).on('click', this.toggle, function (event) {
      _this._toggleDropdown(event);
    });
  };
  _proto._toggleDropdown = function _toggleDropdown(event) {
    event.preventDefault();
    $(event.currentTarget).closest(this.dropdown).find(this.panel).revealer('toggle');
    $(this.toggle).filter($(this.toggle).not($(event.currentTarget))).closest(this.dropdown).find(this.panel).revealer('hide');
  };
  return wishlistDropdown;
}();


/***/ }),

/***/ "./assets/js/theme/utils/FormValidator.js":
/*!************************************************!*\
  !*** ./assets/js/theme/utils/FormValidator.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FormValidator)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var FormValidator = /*#__PURE__*/function () {
  function FormValidator(context) {
    this.context = context;
    this.formSelector = '[data-validated-form]';
    this.validationOptions = {};
    this.validationMessages = {
      required: this.context.validationRequired,
      email: this.context.validationEmail,
      number: this.context.validationNumber,
      numMax: this.context.validationNumberMax,
      numMin: this.context.validationNumberMin,
      numRange: this.context.validationNumberRange,
      maxLength: this.context.validationMaxLength,
      minLength: this.context.validationMinLength,
      maxChecked: this.context.validationMaxChecked,
      minChecked: this.context.validationMinChecked,
      maxSelected: this.context.validationMaxSelected,
      minSelected: this.context.validationMinSelected,
      notEqual: this.context.validationNotEqual,
      different: this.context.validationDifferent
    };
  }

  /*
   * Initialize validation on all matching forms on page load
   */
  var _proto = FormValidator.prototype;
  _proto.initGlobal = function initGlobal() {
    $(this.formSelector).validetta(this.options, this.validationMessages);
  }

  /*
   * Manually initialize validation on target form
   *
   * @param {jQuery} $form - target form to validate
   * @param {object} localOptions - a set of options separate from the ones defined here (optional)
   */;
  _proto.initSingle = function initSingle($form, localOptions) {
    var customOptions = localOptions ? localOptions : this.validationOptions;
    $($form).validetta(customOptions, this.validationMessages);
  };
  return FormValidator;
}();


/***/ }),

/***/ "./assets/js/theme/utils/ProgressButton.js":
/*!*************************************************!*\
  !*** ./assets/js/theme/utils/ProgressButton.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProgressButton)
/* harmony export */ });
/* harmony import */ var _global_svgIcon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global/svgIcon */ "./assets/js/theme/global/svgIcon.js");


/**
 * Toggle a progress button state with alternate text
 * the button needs a class of button-progress
 * the button text needs to be wrapped in an extra .button-text element within the button element itself
 * the button should probably have a data-progress-text attribute
 */
var ProgressButton = /*#__PURE__*/function () {
  function ProgressButton() {}
  var _proto = ProgressButton.prototype;
  _proto.progress = function progress($button) {
    // cache the current button text
    $button.data('defaultText', $button.text());
    var progressText = $button.attr('data-progress-text') || $button.text();
    var spinner = $button.hasClass('spinner') ? (0,_global_svgIcon__WEBPACK_IMPORTED_MODULE_0__["default"])('spinner') : '';
    $button.addClass('progress').attr('disabled', 'disabled').append(spinner).find('.button-text').html(progressText);
  };
  _proto.complete = function complete($button) {
    var defaultText = $button.data('defaultText');
    $button.removeClass('progress').attr('disabled', false).find('.button-text').html(defaultText).next('.icon-spinner').remove();
  };
  return ProgressButton;
}();


/***/ }),

/***/ "./assets/js/theme/utils/pagination-utils.js":
/*!***************************************************!*\
  !*** ./assets/js/theme/utils/pagination-utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wishlistPaginationHelper: () => (/* binding */ wishlistPaginationHelper)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
var changeWishlistPaginationLinks = function changeWishlistPaginationLinks(wishlistUrl) {
  for (var _len = arguments.length, paginationItems = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    paginationItems[_key - 1] = arguments[_key];
  }
  return $.each(paginationItems, function (_, $item) {
    if ($item.length && !$item.attr('href').includes('page=')) {
      var pageNumber = $item.attr('href');
      $item.attr('href', wishlistUrl + "page=" + pageNumber);
    }
  });
};

/**
* helps to withdraw differences in structures around the stencil resource pagination
*/

var wishlistPaginationHelper = function wishlistPaginationHelper() {
  var $pagination = $('.pagination');
  if (!$pagination.length) return;
  var $nextItem = $('.next', $pagination);
  var $prevItem = $('.previous', $pagination);
  var currentHref = $('[data-pagination-current-page-link]').attr('href');
  var partialPaginationUrl = currentHref.split('page=').shift();
  changeWishlistPaginationLinks(partialPaginationUrl, $prevItem, $nextItem);
};

/***/ }),

/***/ "./assets/js/theme/utils/scrollToTop.js":
/*!**********************************************!*\
  !*** ./assets/js/theme/utils/scrollToTop.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ scrollToTop)
/* harmony export */ });
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
function scrollToTop() {
  $('html, body').animate({
    scrollTop: $('.site-canvas').offset().top
  });
}

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/base.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _lib_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/request */ "./node_modules/@bigcommerce/stencil-utils/src/lib/request.js");

var _default = /*#__PURE__*/function () {
  /**
   * @Constructor
   */
  function _default(version) {
    this.remoteVersion = version || 'v1';
    this.remoteBaseEndpoint = '/remote/';
  }

  /**
   *
   * @param {String} url
   * @param {String} method ['GET', 'POST', 'PUT', 'DELETE']
   * @param {Object} options
   * @param {Boolean} remote
   * @param {Function} callback
   */
  var _proto = _default.prototype;
  _proto.makeRequest = function makeRequest(url, method, options, remote, callback) {
    (0,_lib_request__WEBPACK_IMPORTED_MODULE_0__["default"])(url, {
      method: method,
      remote: remote,
      requestOptions: options
    }, callback);
  }

  /**
   *
   * @param {String} endpoint
   * @param {String} method ['GET', 'POST', 'PUT', 'DELETE']
   * @param {Object} options
   * @param {Function} callback
   */;
  _proto.remoteRequest = function remoteRequest(endpoint, method, options, callback) {
    var remoteUrl = this.remoteBaseEndpoint + this.remoteVersion + endpoint;
    this.makeRequest(remoteUrl, method, options, true, callback);
  };
  return _default;
}();


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/cart.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/cart.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _bodl_emitters_cart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bodl/emitters/cart */ "./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/cart.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hooks */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }



var _default = /*#__PURE__*/function (_Base) {
  function _default(version) {
    var _this;
    _this = _Base.call(this, version) || this;
    _this.bodlEventsCart = null;
    return _this;
  }
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.getBodlEventsCart = function getBodlEventsCart() {
    if (!this.bodlEventsCart) {
      this.bodlEventsCart = new _bodl_emitters_cart__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }
    return this.bodlEventsCart;
  }

  /**
   * Get a collection of Carts. For now, this will only return an array of a single cart as multiple carts per session
   * are not currently supported.
   *
   * @param options
   * @param {Function} callback
   */;
  _proto.getCarts = function getCarts(options, callback) {
    if (options === void 0) {
      options = {};
    }
    var url = '/api/storefront/carts';
    if (options.includeOptions) {
      url = this.includeOptions(url);
    }
    this.makeRequest(url, 'GET', options, true, function (err, response) {
      callback(err, response);
    });
  }

  /**
   * Get the current Cart's details, either with or without Product Option selections.
   * Can also be used to get a particular cart provided a cartId in the options.
   *
   * @param options
   * @param {Function} callback
   */;
  _proto.getCart = function getCart(options, callback) {
    if (options === void 0) {
      options = {};
    }
    /* If no cart ID is provided, get the collection of carts and return the first one */
    if (!options.cartId) {
      return this.getCarts(options, function (err, response) {
        return callback(err, response[0]);
      });
    }
    var url = "/api/storefront/carts/" + options.cartId;
    if (options.includeOptions) {
      url = this.includeOptions(url);
    }
    this.makeRequest(url, 'GET', options, true, function (err, response) {
      callback(err, response);
    });
  }

  /**
   * Get the summary for the current primary cart. This summary does not include the full details of the cart, but
   * the response time is much faster and it's appropriate for summary use cases.
   *
   * @param options
   * @param {Function} callback
   */;
  _proto.getCartSummary = function getCartSummary(options, callback) {
    if (options === void 0) {
      options = {};
    }
    var url = '/api/storefront/cart-summary';
    this.makeRequest(url, 'GET', options, true, function (err, response) {
      callback(err, response);
    });
  }

  /**
   * Add the parameters to a URL needed to get product option details on cart line items
   * @param url
   */;
  _proto.includeOptions = function includeOptions(url) {
    return url + "?include=lineItems.physicalItems.options,lineItems.digitalItems.options";
  }

  /**
   * Get a sum of the cart line item quantities
   *
   * @param options
   * @param {Function} callback
   */;
  _proto.getCartQuantity = function getCartQuantity(options, callback) {
    if (options === void 0) {
      options = {};
    }
    this.getCartSummary(options, function (err, response) {
      if (err) {
        return callback(err);
      }
      var quantity = 0;
      if (response && response.status !== 204 && response.total_quantity) {
        quantity = response.total_quantity;
      }
      callback(null, quantity);
    });
  }

  /**
   * Enhance with Big Open Data Layer events
   *
   * @param {FormData} formData
   * @param {Function} callback
   */;
  _proto.itemAdd = function itemAdd(formData, callback) {
    var _this2 = this;
    this.handleItemAdd(formData, function (err, response) {
      if (!err) {
        _this2.getBodlEventsCart().emitAddItem(response);
      }
      callback(err, response);
    });
  }

  /**
   * Add item to cart with options (variants)
   *
   * @param {FormData} formData
   * @param {Function} callback
   */;
  _proto.handleItemAdd = function handleItemAdd(formData, callback) {
    this.remoteRequest('/cart/add', 'POST', {
      formData: formData
    }, function (err, response) {
      var emitData = {
        err: err,
        response: response
      };
      _hooks__WEBPACK_IMPORTED_MODULE_2__["default"].emit('cart-item-add-remote', emitData);
      callback(err, response);
    });
  }

  /**
   * Update cart item quantity
   *
   * @param {String|Object} itemId
   * @param {Number|Function} qty
   * @param {Function|null} callback
   */;
  _proto.itemUpdate = function itemUpdate(itemId, qty, callback) {
    var _this3 = this;
    var callbackArg = callback;
    var items;
    if (Array.isArray(itemId) && typeof qty === 'function') {
      callbackArg = qty;
      items = itemId;
    } else {
      items = [{
        id: itemId,
        quantity: qty
      }];
    }
    this.update(items, function (err, response) {
      var emitData = {
        items: items,
        err: err,
        response: response
      };
      if (qty === 0 && !err) {
        _this3.getBodlEventsCart().emitRemoveItem(response);
      }
      _hooks__WEBPACK_IMPORTED_MODULE_2__["default"].emit('cart-item-update-remote', emitData);
      callbackArg(err, response);
    });
  }

  /**
   * Enhance with Big Open Data Layer events
   *
   * @param {String} itemId
   * @param {Function} callback
   */;
  _proto.itemRemove = function itemRemove(itemId, callback) {
    var _this4 = this;
    this.handleItemRemove(itemId, function (err, response) {
      if (!err) {
        _this4.getBodlEventsCart().emitRemoveItem(response);
      }
      callback(err, response);
    });
  }

  /**
   * Remove cart items
   *
   * Calls the internal update function with quantity: 0
   *
   * @param {String} itemId
   * @param {Function} callback
   */;
  _proto.handleItemRemove = function handleItemRemove(itemId, callback) {
    var items = [{
      id: itemId,
      quantity: 0
    }];
    this.update(items, function (err, response) {
      var emitData = {
        items: items,
        err: err,
        response: response
      };
      _hooks__WEBPACK_IMPORTED_MODULE_2__["default"].emit('cart-item-remove-remote', emitData);
      callback(err, response);
    });
  }

  /**
   * Get giftwrapping options
   * @param {String} itemId
   * @param {Object|Function} options
   * @param {Function|null} callback
   */;
  _proto.getItemGiftWrappingOptions = function getItemGiftWrappingOptions(itemId, options, callback) {
    var opts = options || {};
    var callbackArg = callback;
    if (typeof opts === 'function') {
      callbackArg = opts;
      opts = {};
    }
    this.remoteRequest("/gift-wrapping/" + itemId, 'GET', opts, callbackArg);
  }

  /**
   * Submit giftwrapping options
   *
   * @param {String} itemId
   * @param {Function} callback
   */;
  _proto.submitItemGiftWrappingOption = function submitItemGiftWrappingOption(itemId, params, callback) {
    this.remoteRequest("/gift-wrapping/" + itemId, 'POST', {
      params: params
    }, callback);
  }

  /**
   * Update cart items
   *
   * @param {Array} items
   * @param {Function} callback
   */;
  _proto.update = function update(items, callback) {
    var payload = {
      items: items
    };
    this.remoteRequest('/cart/update', 'POST', {
      params: payload
    }, callback);
  }

  /**
   * Get cart content
   *
   * @param {Object} options
   * @param {Function} callback
   */;
  _proto.getContent = function getContent(options, callback) {
    var opts = options || {};
    var callbackArg = callback;
    if (typeof opts === 'function') {
      callbackArg = opts;
      opts = {};
    }
    this.makeRequest('/cart.php', 'GET', opts, false, callbackArg);
  }

  /**
   * Get cart shipping quote
   *
   * @param {Object} params
   * @param {String|Array|Object} renderWith
   * @param {Function} callback
   */;
  _proto.getShippingQuotes = function getShippingQuotes(params, renderWith, callback) {
    var options = {
      params: params
    };
    var callbackArg = callback;
    var renderWithArg = renderWith;
    if (typeof callbackArg !== 'function') {
      callbackArg = renderWithArg;
      renderWithArg = null;
    }
    if (renderWithArg) {
      options.template = renderWithArg;
    }
    this.remoteRequest('/shipping-quote', 'GET', options, callbackArg);
  }

  /**
   * Submit shipping quote based on quoteId
   *
   * @param {Number} quoteId
   * @param {Function} callback
   */;
  _proto.submitShippingQuote = function submitShippingQuote(quoteId, callback) {
    var options = {
      params: {
        shipping_method: quoteId
      }
    };
    this.remoteRequest('/shipping-quote', 'POST', options, callback);
  }

  /**
   * Apply a coupon code or gift certificate to the cart
   *
   * @param {String} code
   * @param {Function} callback
   */;
  _proto.applyCode = function applyCode(code, callback) {
    var options = {
      params: {
        code: code
      }
    };
    this.remoteRequest('/apply-code', 'POST', options, callback);
  }

  /**
   * Apply a coupon code or gift certificate to the cart
   *
   * @param {Number} code
   * @param {Function} callback
   */;
  _proto.applyGiftCertificate = function applyGiftCertificate(code, callback) {
    var options = {
      params: {
        code: code
      }
    };
    this.remoteRequest('/gift-certificates', 'POST', options, callback);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/countries.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/countries.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_Base) {
  /**
   * @Constructor
   */
  function _default(version) {
    var _this;
    // call parent
    _this = _Base.call(this, version) || this;

    // set up class variables
    _this.endpoint = '/country-states/';
    return _this;
  }

  /**
   *
   * Get country data by id wrapper
   *
   * @param {Number} id
   * @param {Function} callback
   */
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.getById = function getById(id, callback) {
    var url = this.endpoint + id;
    this.remoteRequest(url, 'GET', {}, callback);
  }

  /**
   * Get country data by country name
   * @param name
   * @param callback
   */;
  _proto.getByName = function getByName(name, callback) {
    var url = this.endpoint + name;
    this.remoteRequest(url, 'GET', {}, callback);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/request */ "./node_modules/@bigcommerce/stencil-utils/src/lib/request.js");
/* harmony import */ var _countries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countries */ "./node_modules/@bigcommerce/stencil-utils/src/api/countries.js");
/* harmony import */ var _product__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./product */ "./node_modules/@bigcommerce/stencil-utils/src/api/product.js");
/* harmony import */ var _product_attributes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./product-attributes */ "./node_modules/@bigcommerce/stencil-utils/src/api/product-attributes.js");
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./search */ "./node_modules/@bigcommerce/stencil-utils/src/api/search.js");
/* harmony import */ var _cart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cart */ "./node_modules/@bigcommerce/stencil-utils/src/api/cart.js");
/* harmony import */ var _wishlist__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wishlist */ "./node_modules/@bigcommerce/stencil-utils/src/api/wishlist.js");







var internals = {};

/**
 * Convenience function to request a page via ajax
 *
 * @param url
 * @param options
 * @param callback
 */
internals.getPage = function (url, options, callback) {
  (0,_lib_request__WEBPACK_IMPORTED_MODULE_0__["default"])(url, {
    method: 'GET',
    requestOptions: options
  }, callback);
};
internals.getPageByGQL = function (page, callback) {
  (0,_lib_request__WEBPACK_IMPORTED_MODULE_0__["default"])('/graphql-render', {
    method: 'GET',
    requestOptions: {
      params: {
        template_name: page
      }
    }
  }, callback);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  country: new _countries__WEBPACK_IMPORTED_MODULE_1__["default"](),
  productAttributes: new _product_attributes__WEBPACK_IMPORTED_MODULE_3__["default"](),
  product: new _product__WEBPACK_IMPORTED_MODULE_2__["default"](),
  search: new _search__WEBPACK_IMPORTED_MODULE_4__["default"](),
  cart: new _cart__WEBPACK_IMPORTED_MODULE_5__["default"](),
  wishlist: new _wishlist__WEBPACK_IMPORTED_MODULE_6__["default"](),
  getPage: internals.getPage,
  getPageByGQL: internals.getPageByGQL
});

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/product-attributes.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/product-attributes.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js");
/* harmony import */ var _lib_query_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/query-string */ "./node_modules/@bigcommerce/stencil-utils/src/lib/query-string.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }



var _default = /*#__PURE__*/function (_Base) {
  /**
   * @Constructor
   */
  function _default(version) {
    var _this;
    // call parent
    _this = _Base.call(this, version) || this;

    // set up class variables
    _this.endpoint = '/product-attributes/';
    _this.inCartEndpoint = '/configure-options/';
    return _this;
  }

  /**
   * @param {Number} productId
   * @param {Object} params
   * @param callback
   */
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.optionChange = function optionChange(productId, params, template, callback) {
    if (template === void 0) {
      template = null;
    }
    var templateArg = template;
    var callbackArg = callback;
    if (typeof templateArg === 'function') {
      callbackArg = templateArg;
      templateArg = null;
    }
    this.remoteRequest(this.endpoint + productId, 'POST', {
      params: (0,_lib_query_string__WEBPACK_IMPORTED_MODULE_2__.parse)(params),
      template: templateArg
    }, function (err, response) {
      var emitData = {
        err: err,
        response: response
      };
      _hooks__WEBPACK_IMPORTED_MODULE_1__["default"].emit('product-options-change-remote', emitData);
      callbackArg(err, response);
    });
  }

  /**
   * @param {Number} itemId
   * @param {Object} params
   * @param callback
   */;
  _proto.configureInCart = function configureInCart(itemId, params, callback) {
    this.remoteRequest(this.inCartEndpoint + itemId, 'GET', params, function (err, response) {
      callback(err, response);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/product.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/product.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_Base) {
  /**
   * @Constructor
   */
  function _default(version) {
    var _this;
    // call parent
    _this = _Base.call(this, version) || this;

    // set up class variables
    _this.endpoint = '/products.php?productId=';
    return _this;
  }

  /**
   *
   * @param {Number} productId
   * @param {Object} params
   * @param {Function} callback
   */
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.getById = function getById(productId, params, callback) {
    var url = this.endpoint + productId;
    var paramsArg = params;
    var callbackArg = callback;
    if (typeof paramsArg === 'function') {
      callbackArg = paramsArg;
      paramsArg = {};
    }
    this.makeRequest(url, 'GET', paramsArg, false, callbackArg);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/search.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/search.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hooks */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


var _default = /*#__PURE__*/function (_Base) {
  /**
   * @Constructor
   */
  function _default(version) {
    var _this;
    // call parent
    _this = _Base.call(this, version) || this;

    // set up class variables
    _this.endpoint = '/search.php?search_query=';
    return _this;
  }

  /**
   * Get search results
   * @param {String} query
   * @param {Object} params
   * @param {Function} callback
   */
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.search = function search(query, params, callback) {
    var url = this.endpoint + encodeURIComponent(query);
    var paramsArg = params;
    var callbackArg = callback;
    if (typeof paramsArg === 'function') {
      callbackArg = paramsArg;
      paramsArg = {};
    }
    _hooks__WEBPACK_IMPORTED_MODULE_0__["default"].emit('search-quick-remote', query);
    this.makeRequest(url, 'GET', paramsArg, false, callbackArg);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/api/wishlist.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/api/wishlist.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/api/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_Base) {
  function _default() {
    return _Base.apply(this, arguments) || this;
  }
  _inheritsLoose(_default, _Base);
  var _proto = _default.prototype;
  _proto.itemAdd = function itemAdd(wishlistId, productId, options, callback) {
    var url = "/wishlist.php?action=add&wishlistid=" + wishlistId + "&product_id=" + productId;
    var opts = options;
    var callbackFn = callback;
    if (typeof opts === 'function') {
      callbackFn = opts;
      opts = {};
    }
    this.makeRequest(url, 'POST', opts, false, callbackFn);
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/base.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/base.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./node_modules/@bigcommerce/stencil-utils/src/bodl/helpers.js");

var _default = function _default() {
  this.bodlEvents = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getBODLEvents)();
};


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/cart.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/cart.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./node_modules/@bigcommerce/stencil-utils/src/bodl/helpers.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/bodl/emitters/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }


var Cart = /*#__PURE__*/function (_Base) {
  function Cart() {
    return _Base.apply(this, arguments) || this;
  }
  _inheritsLoose(Cart, _Base);
  var _proto = Cart.prototype;
  _proto.emitAddItem = function emitAddItem(response) {
    this.emit(this.bodlEvents.AddCartItemEvent.CREATE, response);
  };
  _proto.emitRemoveItem = function emitRemoveItem(response) {
    if (this.shouldEmitRemoveItem(response)) {
      this.emit(this.bodlEvents.RemoveCartItemEvent.CREATE, response);
    }
  };
  _proto.shouldEmitRemoveItem = function shouldEmitRemoveItem(response) {
    var _response$data$line_i;
    return ((_response$data$line_i = response.data.line_items) == null ? void 0 : _response$data$line_i.length) > 0;
  };
  _proto.emit = function emit(eventName, response) {
    var payload = this.preparePayload(response);
    this.bodlEvents.cart.emit(eventName, payload);
  };
  _proto.preparePayload = function preparePayload(response) {
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBODLEnabled)() && !response.data.error) {
      return {
        event_id: (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getEventId)(),
        channel_id: response.data.channel_id,
        currency: response.data.currency,
        product_value: response.data.product_value,
        line_items: response.data.line_items.map(function (item) {
          return Object.assign({}, item, {
            product_id: String(item.product_id)
          });
        })
      };
    }
    return {};
  };
  return Cart;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Cart);

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/bodl/helpers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/bodl/helpers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FakeBODLEvents: () => (/* binding */ FakeBODLEvents),
/* harmony export */   getBODLEvents: () => (/* binding */ getBODLEvents),
/* harmony export */   getEventId: () => (/* binding */ getEventId),
/* harmony export */   isBODLEnabled: () => (/* binding */ isBODLEnabled)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");

var isBODLEnabled = function isBODLEnabled() {
  return typeof window.bodlEvents !== 'undefined';
};
var FakeBODLEvents = {
  cart: {
    addItem: function addItem() {},
    removeItem: function removeItem() {},
    emit: function emit() {}
  },
  AddCartItemEvent: {
    CREATE: 'create_add_cart_item'
  },
  RemoveCartItemEvent: {
    CREATE: 'create_remove_cart_item'
  }
};
var getEventId = function getEventId() {
  return (0,uuid__WEBPACK_IMPORTED_MODULE_0__["default"])();
};
var getBODLEvents = function getBODLEvents() {
  if (isBODLEnabled()) {
    return window.bodlEvents;
  }
  return FakeBODLEvents;
};

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_EventEmitter) {
  function _default() {
    return _EventEmitter.apply(this, arguments) || this;
  }
  _inheritsLoose(_default, _EventEmitter);
  var _proto = _default.prototype;
  _proto.subscribe = function subscribe(eventName, elementSelector, handler) {
    document.addEventListener(eventName, function (e) {
      for (var target = e.target; target && target !== this; target = target.parentNode) {
        if (target.matches(elementSelector)) {
          handler.call(target, e, target);
          break;
        }
      }
    }, false);
  };
  return _default;
}((eventemitter3__WEBPACK_IMPORTED_MODULE_0___default()));


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/cart.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/cart.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.itemAdd();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.itemAdd = function itemAdd() {
    var _this2 = this;
    this.subscribe('submit', '[data-cart-item-add]', function (event, target) {
      _this2.emit('cart-item-add', event, target);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/cookie.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/cookie.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  function _default() {
    return _BaseHooks.apply(this, arguments) || this;
  }
  _inheritsLoose(_default, _BaseHooks);
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/currency-selector.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/currency-selector.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.currencySelector();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.currencySelector = function currencySelector() {
    var _this2 = this;
    this.subscribe('input', '[data-currency-selector-toggle]', function (event) {
      _this2.emit('currencySelector-toggle', event);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/faceted-search.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/faceted-search.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.searchEvents();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.searchEvents = function searchEvents() {
    var _this2 = this;
    this.subscribe('click', '[data-faceted-search-facet]', function (event, target) {
      _this2.emit('facetedSearch-facet-clicked', event, target);
    });
    this.subscribe('submit', '[data-faceted-search-range]', function (event, target) {
      _this2.emit('facetedSearch-range-submitted', event, target);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cart */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/cart.js");
/* harmony import */ var _cookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cookie */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/cookie.js");
/* harmony import */ var _currency_selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./currency-selector */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/currency-selector.js");
/* harmony import */ var _product__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./product */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/product.js");
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./search */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/search.js");
/* harmony import */ var _faceted_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./faceted-search */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/faceted-search.js");
/* harmony import */ var _sort_by__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort-by */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/sort-by.js");







var internals = {};
internals.classes = {
  cart: new _cart__WEBPACK_IMPORTED_MODULE_0__["default"](),
  cookie: new _cookie__WEBPACK_IMPORTED_MODULE_1__["default"](),
  currencySelector: new _currency_selector__WEBPACK_IMPORTED_MODULE_2__["default"](),
  product: new _product__WEBPACK_IMPORTED_MODULE_3__["default"](),
  search: new _search__WEBPACK_IMPORTED_MODULE_4__["default"](),
  facetedSearch: new _faceted_search__WEBPACK_IMPORTED_MODULE_5__["default"](),
  sortBy: new _sort_by__WEBPACK_IMPORTED_MODULE_6__["default"]()
};
internals.parseHooks = function (hookName) {
  var hookType = hookName.split('-')[0];
  if (internals.classes[hookType] === undefined) {
    throw new Error(hookType + " is not a valid hookType");
  }
  return internals.classes[hookType];
};
var Hooks = /*#__PURE__*/function () {
  function Hooks() {}
  var _proto = Hooks.prototype;
  _proto.on = function on(hookName, callback) {
    var hook = internals.parseHooks(hookName);
    return hook.on(hookName, callback);
  };
  _proto.off = function off(hookName, callback) {
    var hook = internals.parseHooks(hookName);
    return hook.off(hookName, callback);
  };
  _proto.emit = function emit(hookName) {
    var hook = internals.parseHooks(hookName);
    return hook.emit.apply(hook, arguments);
  };
  return Hooks;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Hooks());

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/product.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/product.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.optionsChange();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.optionsChange = function optionsChange() {
    var _this2 = this;
    this.subscribe('change', '[data-product-option-change]', function (event, target) {
      _this2.emit('product-option-change', event, target);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/search.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/search.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.quickSearch();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.quickSearch = function quickSearch() {
    var _this2 = this;
    this.subscribe('input', '[data-search-quick]', function (event, target) {
      _this2.emit('search-quick', event, target);
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/hooks/sort-by.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/hooks/sort-by.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/base.js");
/* harmony import */ var _lib_closest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/closest */ "./node_modules/@bigcommerce/stencil-utils/src/lib/closest.js");
function _inheritsLoose(t, o) { t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }



// ie 11 does not support native closest
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
if (!Element.prototype.closest) {
  Element.prototype.closest = _lib_closest__WEBPACK_IMPORTED_MODULE_1__["default"];
}
var _default = /*#__PURE__*/function (_BaseHooks) {
  /**
   * @Constructor
   */
  function _default() {
    var _this;
    // call parent
    _this = _BaseHooks.call(this) || this;
    _this.sortByEvents();
    return _this;
  }
  _inheritsLoose(_default, _BaseHooks);
  var _proto = _default.prototype;
  _proto.sortByEvents = function sortByEvents() {
    var _this2 = this;
    this.subscribe('submit', '[data-sort-by]', function (event, target) {
      _this2.emit('sortBy-submitted', event, target);
    });
    this.subscribe('change', '[data-sort-by] select', function (event, target) {
      _this2.emit('sortBy-select-changed', event, target);
      if (!event.defaultPrevented) {
        _this2.emit('sortBy-submitted', event, target);
      }
    });
  };
  return _default;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/lib/closest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/lib/closest.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ closest)
/* harmony export */ });
/**
 * ie 11 does not support native closest so use this polyfill function instead to find closest matching selector starting from el.
 * @param {string} params
 * @returns {any} matching selector or null
 */
function closest(s) {
  var el = this;
  do {
    if (el.matches(s)) return el;
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/lib/query-string.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/lib/query-string.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   stringify: () => (/* binding */ stringify)
/* harmony export */ });
/**
 * Encodes string by stricter rules
 * see https://github.com/kevva/strict-uri-encode
 *
 * @param {String} string
 */
var encode = function encode(string) {
  return encodeURIComponent(string).replace(/[!'()*]/g, function (x) {
    return "%" + x.charCodeAt(0).toString(16).toUpperCase();
  });
};

/**
 * Returns an array, where first element is the slice till separator and the second is the rest.
 *
 * @param {String} string
 * @param {String} separator
 */
var splitOnFirst = function splitOnFirst(string, separator) {
  var separatorIndex = string.indexOf(separator);
  if (separatorIndex === -1) {
    return [string];
  }
  return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
};

/**
 * Sorts array or object by keys
 *
 * @param {Array|Object} input
 */
var _sortByKeys = function sortByKeys(input) {
  if (Array.isArray(input)) {
    return input.sort();
  }
  if (typeof input === 'object') {
    return _sortByKeys(Object.keys(input)).sort(function (a, b) {
      return Number(a) - Number(b);
    }).map(function (key) {
      return input[key];
    });
  }
  return input;
};

/**
 * Returns an array if the key exists in the object or the value if doen't
 *
 * @param {String} key
 * @param {String} value
 * @param {Object} accumulator
 */
var getParsedValue = function getParsedValue(key, value, accumulator) {
  if (accumulator[key] === undefined) {
    return value;
  }
  return [].concat(accumulator[key], value);
};

/**
 * Reducer that formats and combines key-value pair
 *
 * @param {String} options
 */
var reduceByKey = function reduceByKey(options) {
  return function (key) {
    return function (result, value) {
      if (value === undefined) {
        return result;
      }
      if (value === null) {
        return [].concat(result, [encode(key)]);
      }
      if (options.includeArrayIndex) {
        if (typeof value === 'object') {
          var _index = result.length / Object.keys(value).length;
          return result.concat(Object.keys(value).map(function (keyOfValue) {
            return [encode(key), '[', encode(_index), ']', '[', encode(keyOfValue), ']=', encode(value[keyOfValue])].join('');
          }));
        }
        var index = result.length;
        return [].concat(result, [[encode(key), '[', encode(index), ']=', encode(value)].join('')]);
      }
      return [].concat(result, [[encode(key), '=', encode(value)].join('')]);
    };
  };
};

/**
 * Converts query string into object
 *
 * @param {String} input
 */
function parse(input) {
  var ret = Object.create(null);
  if (typeof input !== 'string') {
    return ret;
  }
  var inputParsed = input.trim().replace(/^[?#&]/, '');
  if (!inputParsed) {
    return ret;
  }
  inputParsed.split('&').forEach(function (param) {
    /* eslint-disable prefer-const */
    var _splitOnFirst = splitOnFirst(param.replace(/\+/g, ' '), '='),
      key = _splitOnFirst[0],
      value = _splitOnFirst[1];
    key = decodeURIComponent(key);
    value = value === undefined ? null : decodeURIComponent(value);
    ret[key] = getParsedValue(key, value, ret);
  });
  return Object.keys(ret).sort().reduce(function (result, key) {
    var value = ret[key];
    if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
      /* eslint-disable no-param-reassign */
      result[key] = _sortByKeys(value);
    } else {
      /* eslint-disable no-param-reassign */
      result[key] = value;
    }
    return result;
  }, Object.create(null));
}

/**
 * Converts an object to query string
 *
 * @param {Object} object
 * @param {Object} options
 * @param {Boolean} [options.filterValues] - filters empty string or undefineds
 * @param {Boolean} [options.includeArrayIndex] - includes array index in the query string
 */
function stringify(object, options) {
  if (options === void 0) {
    options = {
      filterValues: false,
      arrayIndex: false
    };
  }
  if (!object) {
    return '';
  }
  var objectCopy = {};
  var shouldFilter = function shouldFilter(key) {
    return options.filterValues && (object[key] === '' || object[key] === undefined);
  };
  Object.keys(object).forEach(function (key) {
    if (!shouldFilter(key)) {
      objectCopy[key] = object[key];
    }
  });
  var keys = Object.keys(objectCopy);
  keys.sort();
  return keys.map(function (key) {
    var value = object[key];
    if (value === undefined) {
      return '';
    }
    if (value === null) {
      return encode(key);
    }
    if (Array.isArray(value)) {
      return value.reduce(reduceByKey(options)(key), []).join('&');
    }
    return encode(key) + "=" + encode(value);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&');
}

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/lib/request.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/lib/request.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var whatwg_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! whatwg-fetch */ "./node_modules/whatwg-fetch/fetch.js");
/* harmony import */ var _query_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./query-string */ "./node_modules/@bigcommerce/stencil-utils/src/lib/query-string.js");


/**
 * Checks whether or not the current method passed in is valid
 *
 * @param {String} method
 * @returns {Boolean}
 */
var isValidHTTPMethod = function isValidHTTPMethod(method) {
  return ['GET', 'POST', 'PUT', 'DELETE'].indexOf(method) !== -1;
};

/**
 * Checks if requested template is using sections
 *
 * @param {Object|Array|String} requestedTemplate
 */
var isUsingSections = function isUsingSections(requestedTemplate) {
  return requestedTemplate !== null && typeof requestedTemplate === 'object' && !Array.isArray(requestedTemplate);
};

/**
 * Returns templates array
 *
 * @param {Object|Array|String} requestedTemplate
 * @returns {Array}
 */
var getTemplates = function getTemplates(requestedTemplate) {
  var templates = [];
  if (isUsingSections(requestedTemplate)) {
    templates = Object.values(requestedTemplate);
  } else if (typeof requestedTemplate === 'string') {
    templates = [requestedTemplate];
  } else if (Array.isArray(requestedTemplate) && requestedTemplate.length > 0) {
    templates = requestedTemplate;
  }
  return templates;
};
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(relativeUrl, opts, callback) {
  var defaultOptions = {
    method: 'GET',
    remote: false,
    requestOptions: {
      baseUrl: null,
      formData: null,
      params: {},
      config: {},
      template: []
    }
  };
  var options = Object.assign({}, defaultOptions, opts);
  var data = options.requestOptions.formData ? options.requestOptions.formData : options.requestOptions.params;
  var headers = {
    'stencil-config': options.requestOptions.config ? JSON.stringify(options.requestOptions.config) : '{}',
    'stencil-options': '{}',
    'x-xsrf-token': window.BCData && window.BCData.csrf_token ? window.BCData.csrf_token : '',
    'x-requested-with': 'stencil-utils'
  };
  if (!isValidHTTPMethod(options.method)) {
    return callback(new Error('Not a valid HTTP method'));
  }
  var templates = getTemplates(options.requestOptions.template);
  var usingSections = isUsingSections(options.requestOptions.template);
  var usingTemplates = templates.length > 0;
  if (!options.requestOptions.formData) {
    headers['content-type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
  }
  if (usingTemplates) {
    headers['stencil-options'] = JSON.stringify({
      render_with: templates.join(',')
    });
  }
  var config = {
    method: options.method,
    headers: headers,
    credentials: 'include'
  };
  var url = options.requestOptions.baseUrl ? "" + options.requestOptions.baseUrl + relativeUrl : relativeUrl;
  if (['GET', 'HEAD'].indexOf(config.method) === -1) {
    config.body = !options.requestOptions.formData ? (0,_query_string__WEBPACK_IMPORTED_MODULE_1__.stringify)(data, {
      includeArrayIndex: true
    }) : data;
  } else if (data) {
    var delimiter = !url.includes('?') ? '?' : '&';
    url += "" + delimiter + (0,_query_string__WEBPACK_IMPORTED_MODULE_1__.stringify)(data);
  }
  return fetch(url, config).then(function (response) {
    if (response.headers.get('content-type').indexOf('application/json') !== -1) {
      return response.json();
    }
    return response.text();
  }).then(function (response) {
    var content = options.remote ? response.content : response;
    var ret = response;
    if (usingTemplates) {
      // Remove the `components` prefix from the response if it's an object
      if (typeof content === 'object') {
        Object.keys(content).forEach(function (key) {
          var cleanKey = key.replace(/^components\//, '');
          content[cleanKey] = content[key];
          delete content[key];
        });
      }

      // If using "sections", morph the content into the arbitrary keys => content object.
      if (usingSections) {
        var requestedTemplate = options.requestOptions.template;
        Object.keys(requestedTemplate).forEach(function (templateVariable) {
          content[templateVariable] = content[requestedTemplate[templateVariable]];
          delete content[requestedTemplate[templateVariable]];
        });
      }
      if (!options.remote) {
        ret = content;
      }
    }
    callback(null, ret);
  }).catch(function (err) {
    return callback(err);
  });
}

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/main.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   api: () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   hooks: () => (/* reexport safe */ _hooks__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   tools: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hooks */ "./node_modules/@bigcommerce/stencil-utils/src/hooks/index.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api */ "./node_modules/@bigcommerce/stencil-utils/src/api/index.js");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tools */ "./node_modules/@bigcommerce/stencil-utils/src/tools/index.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var StencilUtils = {
  hooks: _hooks__WEBPACK_IMPORTED_MODULE_0__["default"],
  api: _api__WEBPACK_IMPORTED_MODULE_1__["default"],
  tools: _tools__WEBPACK_IMPORTED_MODULE_2__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StencilUtils);

/* global define */
(function (root) {
  if (typeof define === 'function' && __webpack_require__.amdO && root) {
    // Ignores below for https://github.com/eslint/eslint/issues/5150
    define(function () {
      // eslint-disable-line prefer-arrow-callback
      root.stencilUtils = StencilUtils; // eslint-disable-line no-param-reassign
    });
  } else if ( true && module.exports) {
    module.exports = StencilUtils;
  } else {
    window.stencilUtils = StencilUtils;
  }
})(undefined);

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/tools/image.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/tools/image.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
var _default = /*#__PURE__*/function () {
  function _default() {}
  var _proto = _default.prototype;
  _proto.getSrc = function getSrc(path, dimensions) {
    // Regex to test size string is of the form 123x123 or 100w
    var sizeRegex = /(^\d+w$)|(^(\d+?)x(\d+?)$)/g;
    var size;
    if (typeof dimensions === 'object') {
      var width = dimensions.width || 100;
      var height = dimensions.height || 100;
      size = width + "x" + height;
    } else if (typeof dimensions === 'string' && sizeRegex.test(dimensions)) {
      // If dimensions is a string and match the NNNxNNN or NNNw format
      size = dimensions;
    } else {
      // Use the original image size
      size = 'original';
    }
    return path.replace('{:size}', size);
  };
  return _default;
}();


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/tools/imageSrcset.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/tools/imageSrcset.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
var _default = /*#__PURE__*/function () {
  function _default() {}
  var _proto = _default.prototype;
  _proto.getSrcset = function getSrcset(url, sizes) {
    // Regex to test size string is of the form 123x123 or 100w
    var sizeRegex = /(^\d+w$)|(^(\d+?)x(\d+?)$)/;
    // Regex to test to that srcset descriptor is of the form 1x 1.5x 2x OR 123w
    var descriptorRegex = /(^\d+w$)|(^([0-9](\.[0-9]+)?)x)$/;
    var srcsets = {};
    if (!sizes) {
      // Use default srcsets if none are provided
      srcsets = {
        '80w': '80w',
        '160w': '160w',
        '320w': '320w',
        '640w': '640w',
        '960w': '960w',
        '1280w': '1280w',
        '1920w': '1920w',
        '2560w': '2560w'
      };
    } else if (sizes === Object(sizes) && !Object.keys(sizes).some(function (descriptor) {
      return !(descriptorRegex.test(descriptor) && sizeRegex.test(sizes[descriptor]));
    })) {
      // If object consists of valid srcsets, use it instead
      srcsets = sizes;
      // If there's only one argument, return a `src` only (also works for `srcset`)
      if (Object.keys(srcsets).length === 1) {
        return url.replace('{:size}', srcsets[Object.keys(srcsets)[0]]);
      }
    } else {
      throw new Error('Invalid srcset descriptor or size');
    }

    // eslint-disable-next-line new-cap
    return Object.keys(srcsets).map(function (descriptor) {
      return [url.replace('{:size}', srcsets[descriptor]), descriptor].join(' ');
    }).join(', ');
  };
  return _default;
}();


/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/tools/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/tools/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image */ "./node_modules/@bigcommerce/stencil-utils/src/tools/image.js");
/* harmony import */ var _imageSrcset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imageSrcset */ "./node_modules/@bigcommerce/stencil-utils/src/tools/imageSrcset.js");
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storage */ "./node_modules/@bigcommerce/stencil-utils/src/tools/storage.js");



var tools = {
  image: new _image__WEBPACK_IMPORTED_MODULE_0__["default"](),
  imageSrcset: new _imageSrcset__WEBPACK_IMPORTED_MODULE_1__["default"](),
  storage: new _storage__WEBPACK_IMPORTED_MODULE_2__["default"]()
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tools);

/***/ }),

/***/ "./node_modules/@bigcommerce/stencil-utils/src/tools/storage.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bigcommerce/stencil-utils/src/tools/storage.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
var _default = /*#__PURE__*/function () {
  function _default() {}
  var _proto = _default.prototype;
  /**
   * Check if a storage type (like localStorage or sessionStorage) is available for use
   * https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Testing_for_availability
   * @param type
   * @returns boolean
   */
  _proto.storageAvailable = function storageAvailable(type) {
    var storage = window[type];
    try {
      var x = '__storage_test__';
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && (
      // everything except Firefox
      e.code === 22
      // Firefox
      || e.code === 1014
      // test name field too, because code might not be present
      // everything except Firefox
      || e.name === 'QuotaExceededError'
      // Firefox
      || e.name === 'NS_ERROR_DOM_QUOTA_REACHED')
      // acknowledge QuotaExceededError only if there's something already stored
      && storage.length !== 0;
    }
  };
  _proto.localStorageAvailable = function localStorageAvailable() {
    return this.storageAvailable('localStorage');
  };
  return _default;
}();


/***/ }),

/***/ "./node_modules/baguettebox.js/dist/baguetteBox.min.js":
/*!*************************************************************!*\
  !*** ./node_modules/baguettebox.js/dist/baguetteBox.min.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * baguetteBox.js
 * @author  feimosi
 * @version 1.12.0
 * @url https://github.com/feimosi/baguetteBox.js
 */
!function(e,t){"use strict"; true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (t),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0}(this,function(){"use strict";var s,l,u,c,d,f='<svg width="44" height="60"><polyline points="30 10 10 30 30 50" stroke="rgba(255,255,255,0.5)" stroke-width="4"stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg>',g='<svg width="44" height="60"><polyline points="14 10 34 30 14 50" stroke="rgba(255,255,255,0.5)" stroke-width="4"stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg>',p='<svg width="30" height="30"><g stroke="rgb(160,160,160)" stroke-width="4"><line x1="5" y1="5" x2="25" y2="25"/><line x1="5" y1="25" x2="25" y2="5"/></g></svg>',b={},v={captions:!0,buttons:"auto",fullScreen:!1,noScrollbars:!1,bodyClass:"baguetteBox-open",titleTag:!1,async:!1,preload:2,animation:"slideIn",afterShow:null,afterHide:null,onChange:null,overlayBackgroundColor:"rgba(0,0,0,.8)",closeX:p,leftArrow:f,rightArrow:g},m={},h=[],o=0,n=!1,i={},a=!1,y=/.+\.(gif|jpe?g|png|webp)/i,w={},k=[],r=null,x=function(e){-1!==e.target.id.indexOf("baguette-img")&&X()},E=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,q()},C=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,j()},B=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,X()},T=function(e){i.count++,1<i.count&&(i.multitouch=!0),i.startX=e.changedTouches[0].pageX,i.startY=e.changedTouches[0].pageY},A=function(e){if(!a&&!i.multitouch){e.preventDefault?e.preventDefault():e.returnValue=!1;var t=e.touches[0]||e.changedTouches[0];40<t.pageX-i.startX?(a=!0,q()):t.pageX-i.startX<-40?(a=!0,j()):100<i.startY-t.pageY&&X()}},L=function(){i.count--,i.count<=0&&(i.multitouch=!1),a=!1},N=function(){L()},H=function(e){"block"===s.style.display&&s.contains&&!s.contains(e.target)&&(e.stopPropagation(),M())};function P(e){if(w.hasOwnProperty(e)){var t=w[e].galleries;[].forEach.call(t,function(e){[].forEach.call(e,function(e){W(e.imageElement,"click",e.eventHandler)}),h===e&&(h=[])}),delete w[e]}}function S(e){switch(e.keyCode){case 37:q();break;case 39:j();break;case 27:X();break;case 36:!function t(e){e&&e.preventDefault();return D(0)}(e);break;case 35:!function n(e){e&&e.preventDefault();return D(h.length-1)}(e)}}function F(e,t){if(h!==e){for(h=e,function r(e){e=e||{};for(var t in v)b[t]=v[t],"undefined"!=typeof e[t]&&(b[t]=e[t]);l.style.transition=l.style.webkitTransition="fadeIn"===b.animation?"opacity .4s ease":"slideIn"===b.animation?"":"none","auto"===b.buttons&&("ontouchstart"in window||1===h.length)&&(b.buttons=!1);u.style.display=c.style.display=b.buttons?"":"none",d.innerHTML=b.closeX,b.buttons&&(u.innerHTML=b.leftArrow,c.innerHTML=b.rightArrow);try{s.style.backgroundColor=b.overlayBackgroundColor}catch(n){}}(t);l.firstChild;)l.removeChild(l.firstChild);for(var n,o=[],i=[],a=k.length=0;a<e.length;a++)(n=J("div")).className="full-image",n.id="baguette-img-"+a,k.push(n),o.push("baguetteBox-figure-"+a),i.push("baguetteBox-figcaption-"+a),l.appendChild(k[a]);s.setAttribute("aria-labelledby",o.join(" ")),s.setAttribute("aria-describedby",i.join(" "))}}function I(e){b.noScrollbars&&(document.documentElement.style.overflowY="hidden",document.body.style.overflowY="scroll"),"block"!==s.style.display&&(U(document,"keydown",S),i={count:0,startX:null,startY:null},Y(o=e,function(){z(o),V(o)}),R(),s.style.display="block",b.fullScreen&&function t(){s.requestFullscreen?s.requestFullscreen():s.webkitRequestFullscreen?s.webkitRequestFullscreen():s.mozRequestFullScreen&&s.mozRequestFullScreen()}(),setTimeout(function(){s.className="visible",b.bodyClass&&document.body.classList&&document.body.classList.add(b.bodyClass),b.afterShow&&b.afterShow()},50),b.onChange&&b.onChange(o,k.length),r=document.activeElement,M(),n=!0)}function M(){b.buttons?u.focus():d.focus()}function X(){b.noScrollbars&&(document.documentElement.style.overflowY="auto",document.body.style.overflowY="auto"),"none"!==s.style.display&&(W(document,"keydown",S),s.className="",setTimeout(function(){s.style.display="none",document.fullscreen&&function e(){document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen()}(),b.bodyClass&&document.body.classList&&document.body.classList.remove(b.bodyClass),b.afterHide&&b.afterHide(),r&&r.focus(),n=!1},500))}function Y(t,n){var e=k[t],o=h[t];if(void 0!==e&&void 0!==o)if(e.getElementsByTagName("img")[0])n&&n();else{var i=o.imageElement,a=i.getElementsByTagName("img")[0],r="function"==typeof b.captions?b.captions.call(h,i):i.getAttribute("data-caption")||i.title,s=function d(e){var t=e.href;if(e.dataset){var n=[];for(var o in e.dataset)"at-"!==o.substring(0,3)||isNaN(o.substring(3))||(n[o.replace("at-","")]=e.dataset[o]);for(var i=Object.keys(n).sort(function(e,t){return parseInt(e,10)<parseInt(t,10)?-1:1}),a=window.innerWidth*window.devicePixelRatio,r=0;r<i.length-1&&i[r]<a;)r++;t=n[i[r]]||t}return t}(i),l=J("figure");if(l.id="baguetteBox-figure-"+t,l.innerHTML='<div class="baguetteBox-spinner"><div class="baguetteBox-double-bounce1"></div><div class="baguetteBox-double-bounce2"></div></div>',b.captions&&r){var u=J("figcaption");u.id="baguetteBox-figcaption-"+t,u.innerHTML=r,l.appendChild(u)}e.appendChild(l);var c=J("img");c.onload=function(){var e=document.querySelector("#baguette-img-"+t+" .baguetteBox-spinner");l.removeChild(e),!b.async&&n&&n()},c.setAttribute("src",s),c.alt=a&&a.alt||"",b.titleTag&&r&&(c.title=r),l.appendChild(c),b.async&&n&&n()}}function j(){return D(o+1)}function q(){return D(o-1)}function D(e,t){return!n&&0<=e&&e<t.length?(F(t,b),I(e),!0):e<0?(b.animation&&O("left"),!1):e>=k.length?(b.animation&&O("right"),!1):(Y(o=e,function(){z(o),V(o)}),R(),b.onChange&&b.onChange(o,k.length),!0)}function O(e){l.className="bounce-from-"+e,setTimeout(function(){l.className=""},400)}function R(){var e=100*-o+"%";"fadeIn"===b.animation?(l.style.opacity=0,setTimeout(function(){m.transforms?l.style.transform=l.style.webkitTransform="translate3d("+e+",0,0)":l.style.left=e,l.style.opacity=1},400)):m.transforms?l.style.transform=l.style.webkitTransform="translate3d("+e+",0,0)":l.style.left=e}function z(e){e-o>=b.preload||Y(e+1,function(){z(e+1)})}function V(e){o-e>=b.preload||Y(e-1,function(){V(e-1)})}function U(e,t,n,o){e.addEventListener?e.addEventListener(t,n,o):e.attachEvent("on"+t,function(e){(e=e||window.event).target=e.target||e.srcElement,n(e)})}function W(e,t,n,o){e.removeEventListener?e.removeEventListener(t,n,o):e.detachEvent("on"+t,n)}function G(e){return document.getElementById(e)}function J(e){return document.createElement(e)}return[].forEach||(Array.prototype.forEach=function(e,t){for(var n=0;n<this.length;n++)e.call(t,this[n],n,this)}),[].filter||(Array.prototype.filter=function(e,t,n,o,i){for(n=this,o=[],i=0;i<n.length;i++)e.call(t,n[i],i,n)&&o.push(n[i]);return o}),{run:function K(e,t){return m.transforms=function n(){var e=J("div");return"undefined"!=typeof e.style.perspective||"undefined"!=typeof e.style.webkitPerspective}(),m.svg=function o(){var e=J("div");return e.innerHTML="<svg/>","http://www.w3.org/2000/svg"===(e.firstChild&&e.firstChild.namespaceURI)}(),m.passiveEvents=function i(){var e=!1;try{var t=Object.defineProperty({},"passive",{get:function(){e=!0}});window.addEventListener("test",null,t)}catch(n){}return e}(),function a(){if(s=G("baguetteBox-overlay"))return l=G("baguetteBox-slider"),u=G("previous-button"),c=G("next-button"),void(d=G("close-button"));(s=J("div")).setAttribute("role","dialog"),s.id="baguetteBox-overlay",document.getElementsByTagName("body")[0].appendChild(s),(l=J("div")).id="baguetteBox-slider",s.appendChild(l),(u=J("button")).setAttribute("type","button"),u.id="previous-button",u.setAttribute("aria-label","Previous"),u.innerHTML=m.svg?f:"&lt;",s.appendChild(u),(c=J("button")).setAttribute("type","button"),c.id="next-button",c.setAttribute("aria-label","Next"),c.innerHTML=m.svg?g:"&gt;",s.appendChild(c),(d=J("button")).setAttribute("type","button"),d.id="close-button",d.setAttribute("aria-label","Close"),d.innerHTML=m.svg?p:"&times;",s.appendChild(d),u.className=c.className=d.className="baguetteBox-button",function n(){var e=m.passiveEvents?{passive:!1}:null,t=m.passiveEvents?{passive:!0}:null;U(s,"click",x),U(u,"click",E),U(c,"click",C),U(d,"click",B),U(l,"contextmenu",N),U(s,"touchstart",T,t),U(s,"touchmove",A,e),U(s,"touchend",L),U(document,"focus",H,!0)}()}(),P(e),function r(e,a){var t=document.querySelectorAll(e),n={galleries:[],nodeList:t};return w[e]=n,[].forEach.call(t,function(e){a&&a.filter&&(y=a.filter);var t=[];if(t="A"===e.tagName?[e]:e.getElementsByTagName("a"),0!==(t=[].filter.call(t,function(e){if(-1===e.className.indexOf(a&&a.ignoreClass))return y.test(e.href)})).length){var i=[];[].forEach.call(t,function(e,t){var n=function(e){e.preventDefault?e.preventDefault():e.returnValue=!1,F(i,a),I(t)},o={eventHandler:n,imageElement:e};U(e,"click",n),i.push(o)}),n.galleries.push(i)}}),n.galleries}(e,t)},show:D,showNext:j,showPrevious:q,hide:X,destroy:function e(){!function n(){var e=m.passiveEvents?{passive:!1}:null,t=m.passiveEvents?{passive:!0}:null;W(s,"click",x),W(u,"click",E),W(c,"click",C),W(d,"click",B),W(l,"contextmenu",N),W(s,"touchstart",T,t),W(s,"touchmove",A,e),W(s,"touchend",L),W(document,"focus",H,!0)}(),function t(){for(var e in w)w.hasOwnProperty(e)&&P(e)}(),W(document,"keydown",S),document.getElementsByTagName("body")[0].removeChild(document.getElementById("baguetteBox-overlay")),w={},h=[],o=0}}});

/***/ }),

/***/ "./node_modules/bc-compare/dist/js/ProductCompare.js":
/*!***********************************************************!*\
  !*** ./node_modules/bc-compare/dist/js/ProductCompare.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

var _lodash = __webpack_require__(/*! lodash.template */ "./node_modules/lodash.template/index.js");

var _lodash2 = _interopRequireDefault(_lodash);

var _jqueryTrend = __webpack_require__(/*! jquery-trend */ "./node_modules/bc-compare/node_modules/jquery-trend/jquery.trend.js");

var _jqueryTrend2 = _interopRequireDefault(_jqueryTrend);

var _jqueryRevealer = __webpack_require__(/*! jquery-revealer */ "./node_modules/bc-compare/node_modules/jquery-revealer/jquery.revealer.js");

var _jqueryRevealer2 = _interopRequireDefault(_jqueryRevealer);

var _eventemitter = __webpack_require__(/*! eventemitter2 */ "./node_modules/eventemitter2/lib/eventemitter2.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Product Comparison Widget
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ProductCompare = function (_EventEmitter) {
  _inherits(ProductCompare, _EventEmitter);

  function ProductCompare() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ProductCompare);

    var _this = _possibleConstructorReturn(this, (ProductCompare.__proto__ || Object.getPrototypeOf(ProductCompare)).call(this));

    _this.options = _jquery2.default.extend({
      scope: '[data-product-compare]',
      maxItems: 4,
      itemTemplate: (0, _lodash2.default)('\n        <div class="compare-item" data-compare-item>\n          <a href="<%= url %>">\n            <img class="compare-item-thumbnail" src="<%= thumbnail %>"/>\n            <div class="compare-item-price"><%= price %></div>\n            <div class="compare-item-title"><%= title %></div>\n          </a>\n          <button class="compare-item-remove" data-compare-item-remove="<%= id %>">&times;</button>\n        </div>\n      ')
    }, options);

    _this.$scope = (0, _jquery2.default)(_this.options.scope);
    _this.$compareItems = (0, _jquery2.default)('[data-compare-items]');
    _this.$compareLink = (0, _jquery2.default)('[data-compare-link]');

    _this.checkbox = '[data-compare-checkbox]';
    _this.compareItem = '[data-compare-item]';
    _this.compareRemove = 'data-compare-item-remove';

    _this._init();
    _this._bindEvents();
    return _this;
  }

  /**
   *
   * Set up the compare list Map
   *
   */

  _createClass(ProductCompare, [{
    key: '_init',
    value: function _init() {
      if (sessionStorage.getItem('compare')) {
        this.compareList = new Map(JSON.parse(sessionStorage.getItem('compare')));
        this._initWidget();
      } else {
        this.compareList = new Map();
      }
    }

    /**
     *
     * Bind event handlers for the compare widget
     *
     */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$scope.on('change', this.checkbox, function (event) {
        _this2._toggleItem(event.target);
      });

      (0, _jquery2.default)('body').on('click', '[' + this.compareRemove + ']', function (event) {
        var id = parseInt((0, _jquery2.default)(event.target).attr(_this2.compareRemove), 10);
        _this2._removeItem(id);

        return false;
      });
    }

    /**
     *
     * Sets the inital state of widget if loading from sessionStorage
     *
     */

  }, {
    key: '_initWidget',
    value: function _initWidget() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.compareList.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var id = _step.value;

          this._checkCheckbox(id);

          this._populateWidget(id);

          this._updateWidgetState();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     *
     * Updates a checkbox state to "checked"
     *
     * @param {id} number The ID of the item / checkbox to target
     *
     */

  }, {
    key: '_checkCheckbox',
    value: function _checkCheckbox(id) {
      (0, _jquery2.default)('[data-compare-id="' + id + '"]').prop('checked', true);
    }

    /**
     *
     * Adds an item to the widget
     *
     * @param {id} number The ID of the item it add
     *
     */

  }, {
    key: '_populateWidget',
    value: function _populateWidget(id) {
      (0, _jquery2.default)(this.options.itemTemplate(this.compareList.get(id))).appendTo(this.$compareItems).revealer('show');
    }

    /**
     *
     * Controls whether to add or remove a product from the compare list
     *
     * @param {string} checkbox The checkbox (dom element)
     *
     */

  }, {
    key: '_toggleItem',
    value: function _toggleItem(checkbox) {
      var $checkbox = (0, _jquery2.default)(checkbox);
      var id = parseInt($checkbox.data('compare-id'), 10);
      var productData = {
        id: id,
        title: $checkbox.data('compare-title'),
        url: $checkbox.data('compare-url'),
        price: $checkbox.data('compare-price'),
        thumbnail: $checkbox.data('compare-thumbnail')
      };

      // Add / remove item from compare list
      if (checkbox.checked) {
        this._addItem(id, productData);

        // Generate an array of the compare IDs so we can target the first item
        var compareIds = [].concat(_toConsumableArray(this.compareList.keys()));

        // Remove the first item from the list if > maxItems
        if (this.compareList.size > this.options.maxItems) {
          var firstItem = compareIds[0];
          this._removeItem(firstItem);
        }
      } else {
        this._removeItem(id);
      }
    }

    /**
     *
     * Adds an item to the compare list
     *
     * @param {number} id The ID of the item to add
     * @param {object} productData Object containing the data of a compare item
     *
     */

  }, {
    key: '_addItem',
    value: function _addItem(id, productData) {
      this.emit('beforeadd', id);

      this.compareList.set(id, productData);

      this._populateWidget(id);

      this._updateWidgetState();

      this.emit('afteradd', id);
    }

    /**
     *
     * Removes an item from the compare list
     *
     * @param {number} id The ID of the item to remove
     *
     */

  }, {
    key: '_removeItem',
    value: function _removeItem(id) {
      this.emit('beforeremove', id);

      this.compareList.delete(id);

      this.$compareItems.find('[' + this.compareRemove + '=' + id + ']').closest(this.compareItem).revealer('hide');

      (0, _jquery2.default)(this.compareItem).on('revealer-hide', function (event) {
        (0, _jquery2.default)(event.currentTarget).remove();
      });

      // Uncheck the checkbox if removed via button
      (0, _jquery2.default)('[data-compare-id="' + id + '"]').prop('checked', false);

      this._updateWidgetState();

      this.emit('afterremove', id);
    }

    /**
     *
     * Public method to clear the list and widget items
     *
     */

  }, {
    key: 'removeAll',
    value: function removeAll() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.compareList.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var id = _step2.value;

          this._removeItem(id);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    /**
     *
     * Sets each checkbox in the compare list to "checked".
     * Useful if products are loaded dynamically and the widget is already initialized.
     *
     */

  }, {
    key: 'updateCheckboxes',
    value: function updateCheckboxes() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.compareList.keys()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var id = _step3.value;

          this._checkCheckbox(id);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    /**
     *
     * Updates the compare widget state
     *
     */

  }, {
    key: '_updateWidgetState',
    value: function _updateWidgetState() {
      var compareLength = this.compareList.size;

      // Toggle widget state class
      (0, _jquery2.default)('[data-compare-widget]').toggleClass('is-enabled', !!compareLength);

      // Toggle compare link class
      this.$compareLink.toggleClass('is-disabled', compareLength <= 1);

      // Set compare link href
      this.$compareLink.attr('href', this.$compareLink.data('compare-link') + '/' + [].concat(_toConsumableArray(this.compareList.keys())).join('/'));

      // Save the compare data for later
      sessionStorage.setItem('compare', JSON.stringify([].concat(_toConsumableArray(this.compareList))));

      this.emit('updated');
    }

    /**
     *
     * Over-ride EventEmitter's "on" method so that events can be fired immediately after they're bound
     *
     */

  }, {
    key: 'on',
    value: function on(eventName, handler) {
      var fireOnBind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _get(ProductCompare.prototype.__proto__ || Object.getPrototypeOf(ProductCompare.prototype), 'on', this).call(this, eventName, handler);
      if (fireOnBind) {
        this.emit(eventName);
      }
    }
  }]);

  return ProductCompare;
}(_eventemitter2.default);

exports["default"] = ProductCompare;

/***/ }),

/***/ "./node_modules/bc-compare/node_modules/jquery-revealer/jquery.revealer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/bc-compare/node_modules/jquery-revealer/jquery.revealer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Revealer 3.0.0
 *
 * Copyright 2021, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
(function($){
  // check for trend event (make sure jquery.trend is included)
  if (typeof $.event.special.trend !== "object") {
    console.warn("Please make sure jquery.trend is included! Otherwise revealer won't work.");
  }

  // Simple requestAnimationFrame polyfill
  var raf = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function(fn) { window.setTimeout(fn, 1000/60); }


  // Public API
  var methods = {
    isVisible: function(el) {
      return !!el.data("revealer-visible");
    },

    show: function(el, force) {
      // Check state
      if (methods.isVisible(el)) {
        el.removeClass("animating animating-in");
        el.off("revealer-animating revealer-show");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", true);
      el.off("trend");

      if (force) {
        el.addClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-show");
        });
        return;
      }

      raf(function(){
        // Start animation state transition
        el.addClass("animating animating-in");
        el.trigger("revealer-animating");

        raf(function(){
          el.addClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in");
            el.trigger("revealer-show");
          });
        });
      });
    },

    hide: function(el, force) {
      // Check state
      if (!methods.isVisible(el)) {
        el.removeClass("animating animating-out visible");
        el.off("revealer-animating revealer-hide");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", false);
      el.off("trend");

      if (force) {
        el.removeClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-hide");
        });
        return;
      }

      raf(function(){
        el.addClass("animating animating-out");
        el.trigger("revealer-animating");

        raf(function(){
          el.removeClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in animating-out");
            el.trigger("revealer-hide");
          });
        });
      });
    },

    toggle: function(el, force) {
      if (methods.isVisible(el)) {
        methods.hide(el, force);
      } else {
        methods.show(el, force);
      }
    }
  };

  // jQuery plugin
  $.fn.revealer = function(method, force) {
    // Get action
    var action = methods[method || "toggle"];
    if (!action) return this;

    // Run action
    if (method === "isVisible") {
      return action(this);
    }

    return this.each(function(){
      action($(this), force);
    });
  };
})(jQuery);


/***/ }),

/***/ "./node_modules/bc-compare/node_modules/jquery-trend/jquery.trend.js":
/*!***************************************************************************!*\
  !*** ./node_modules/bc-compare/node_modules/jquery-trend/jquery.trend.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Trend 0.1.0
 *
 * Fail-safe TransitionEnd event for jQuery.
 *
 * Adds a new "trend" event that can be used in browsers that don't
 * support "transitionend".
 *
 * NOTE: Only supports being bound with "jQuery.one".
 *
 * Copyright 2014, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
;(function($){

  // Prefixed transitionend event names
  var transitionEndEvents =
    "webkitTransitionEnd " +
    "otransitionend " +
    "oTransitionEnd " +
    "msTransitionEnd " +
    "transitionend";

  // Prefixed transition duration property names
  var transitionDurationProperties = [
    "transition-duration",
    "-moz-transition-duration",
    "-webkit-transition-duration",
    "-ms-transition-duration",
    "-o-transition-duration",
    "-khtml-transition-duration"
  ];

  // Parses a CSS duration value into milliseconds.
  var parseDuration = function(s) {
    s = s.replace(/\s/, "");
    var v = window.parseFloat(s);

    return s.match(/[^m]s$/i)
      ? v * 1000
      : v;
  };

  // Get the transition duration for an element, as specified by CSS.
  // Returns a value in milliseconds.
  var getTransitionDuration = function(el) {
    var duration = 0;

    for (var i = 0; i < transitionDurationProperties.length; i++) {
      // Get raw CSS value
      var value = el.css(transitionDurationProperties[i]);
      if (!value) continue;

      // Multiple transitions--pick the longest
      if (value.indexOf(",") !== -1) {
        var values = value.split(",");
        var durations = (function(){
          var results = [];
          for (var i = 0; i < values.length; i++) {
            var duration = parseDuration(values[i]);
            results.push(duration);
          }
          return results;
        })();

        duration = Math.max.apply(Math, durations);
      }

      // Single transition
      else {
        duration = parseDuration(value);
      }

      // Accept first vaue
      break;
    }

    return duration;
  };

  $.event.special.trend = {
    // Triggers an event handler when an element is done transitioning.
    //
    // Handles browsers that don't support transitionend by adding a
    // timeout with the transition duration.
    add: function(handleObj) {
      var el = $(this);
      var fired = false;

      // Mark element as being in transition
      el.data("trend", true);

      // Calculate a fallback duration. + 20 because some browsers fire
      // timeouts faster than transitionend.
      var duration = getTransitionDuration(el) + 20;

      var cb = function(e) {
        // transitionend events can be sent for each property. Let's just
        // skip all but the first. Also handles the timeout callback.
        if (fired) return;

        // Child elements that also have transitions can be fired before we
        // complete. This will catch and ignore those. Unfortunately, we'll
        // have to rely on the timeout in these cases.
        if (e && e.srcElement !== el[0]) return;

        // Mark element has not being in transition
        el.data("trend", false);

        // Callback
        fired = true;
        if (handleObj.handler) handleObj.handler();
      };

      el.one(transitionEndEvents, cb);
      el.data("trend-timeout", window.setTimeout(cb, duration));
    },

    remove: function(handleObj) {
      var el = $(this);
      el.off(transitionEndEvents);
      window.clearTimeout(el.data("trend-timeout"));
    }
  };

})(jQuery);


/***/ }),

/***/ "./node_modules/bc-loading/dist/loading.js":
/*!*************************************************!*\
  !*** ./node_modules/bc-loading/dist/loading.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

var _jqueryTrend = __webpack_require__(/*! jquery-trend */ "./node_modules/bc-loading/node_modules/jquery-trend/jquery.trend.js");

var _jqueryTrend2 = _interopRequireDefault(_jqueryTrend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LoadingUtils = function () {
  function LoadingUtils(options, scrollLock, el) {
    _classCallCheck(this, LoadingUtils);

    this.scrollLock = scrollLock;
    this.$body = (0, _jquery2.default)(document.body);
    this.$el = el ? (0, _jquery2.default)(el) : this.$body;

    this.options = _jquery2.default.extend({
      loadingMarkup: '<div class="loading"><span class="loading-spinner"></span></div>',
      visibleClass: 'visible',
      scrollLockClass: 'scroll-locked'
    }, options);

    this.$loading = (0, _jquery2.default)(this.options.loadingMarkup);
  }

  _createClass(LoadingUtils, [{
    key: 'show',
    value: function show() {
      var _this = this;

      if (this.scrollLock) {
        this.$body.addClass(this.options.scrollLockClass);
      }

      var elementPositioning = this.$el.css('position');

      if (elementPositioning === 'static') {
        this.$el.css('position', 'relative');
      }

      this.$el.prepend(this.$loading);

      setTimeout(function () {
        _this.$loading.addClass(_this.options.visibleClass);
      }, 10);
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this2 = this;

      if (this.scrollLock) {
        this.$body.removeClass(this.options.scrollLockClass);
      }

      this.$loading.removeClass(this.options.visibleClass).one('trend', function () {
        _this2.$loading.remove();
      });
    }
  }]);

  return LoadingUtils;
}();

exports["default"] = LoadingUtils;

/***/ }),

/***/ "./node_modules/bc-loading/node_modules/jquery-trend/jquery.trend.js":
/*!***************************************************************************!*\
  !*** ./node_modules/bc-loading/node_modules/jquery-trend/jquery.trend.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Trend 0.1.0
 *
 * Fail-safe TransitionEnd event for jQuery.
 *
 * Adds a new "trend" event that can be used in browsers that don't
 * support "transitionend".
 *
 * NOTE: Only supports being bound with "jQuery.one".
 *
 * Copyright 2014, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
;(function($){

  // Prefixed transitionend event names
  var transitionEndEvents =
    "webkitTransitionEnd " +
    "otransitionend " +
    "oTransitionEnd " +
    "msTransitionEnd " +
    "transitionend";

  // Prefixed transition duration property names
  var transitionDurationProperties = [
    "transition-duration",
    "-moz-transition-duration",
    "-webkit-transition-duration",
    "-ms-transition-duration",
    "-o-transition-duration",
    "-khtml-transition-duration"
  ];

  // Parses a CSS duration value into milliseconds.
  var parseDuration = function(s) {
    s = s.replace(/\s/, "");
    var v = window.parseFloat(s);

    return s.match(/[^m]s$/i)
      ? v * 1000
      : v;
  };

  // Get the transition duration for an element, as specified by CSS.
  // Returns a value in milliseconds.
  var getTransitionDuration = function(el) {
    var duration = 0;

    for (var i = 0; i < transitionDurationProperties.length; i++) {
      // Get raw CSS value
      var value = el.css(transitionDurationProperties[i]);
      if (!value) continue;

      // Multiple transitions--pick the longest
      if (value.indexOf(",") !== -1) {
        var values = value.split(",");
        var durations = (function(){
          var results = [];
          for (var i = 0; i < values.length; i++) {
            var duration = parseDuration(values[i]);
            results.push(duration);
          }
          return results;
        })();

        duration = Math.max.apply(Math, durations);
      }

      // Single transition
      else {
        duration = parseDuration(value);
      }

      // Accept first vaue
      break;
    }

    return duration;
  };

  $.event.special.trend = {
    // Triggers an event handler when an element is done transitioning.
    //
    // Handles browsers that don't support transitionend by adding a
    // timeout with the transition duration.
    add: function(handleObj) {
      var el = $(this);
      var fired = false;

      // Mark element as being in transition
      el.data("trend", true);

      // Calculate a fallback duration. + 20 because some browsers fire
      // timeouts faster than transitionend.
      var duration = getTransitionDuration(el) + 20;

      var cb = function(e) {
        // transitionend events can be sent for each property. Let's just
        // skip all but the first. Also handles the timeout callback.
        if (fired) return;

        // Child elements that also have transitions can be fired before we
        // complete. This will catch and ignore those. Unfortunately, we'll
        // have to rely on the timeout in these cases.
        if (e && e.srcElement !== el[0]) return;

        // Mark element has not being in transition
        el.data("trend", false);

        // Callback
        fired = true;
        if (handleObj.handler) handleObj.handler();
      };

      el.one(transitionEndEvents, cb);
      el.data("trend-timeout", window.setTimeout(cb, duration));
    },

    remove: function(handleObj) {
      var el = $(this);
      el.off(transitionEndEvents);
      window.clearTimeout(el.data("trend-timeout"));
    }
  };

})(jQuery);


/***/ }),

/***/ "./node_modules/bc-modal/dist/js/modal.js":
/*!************************************************!*\
  !*** ./node_modules/bc-modal/dist/js/modal.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

var _jqueryTrend = __webpack_require__(/*! jquery-trend */ "./node_modules/bc-modal/node_modules/jquery-trend/jquery.trend.js");

var _jqueryTrend2 = _interopRequireDefault(_jqueryTrend);

var _jqueryRevealer = __webpack_require__(/*! jquery-revealer */ "./node_modules/bc-modal/node_modules/jquery-revealer/jquery.revealer.js");

var _jqueryRevealer2 = _interopRequireDefault(_jqueryRevealer);

var _justDebounce = __webpack_require__(/*! just-debounce */ "./node_modules/just-debounce/index.js");

var _justDebounce2 = _interopRequireDefault(_justDebounce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Modal = function () {
  function Modal(options) {
    _classCallCheck(this, Modal);

    this.$modal;
    this.$modalContent;
    this.$dialog;
    this.$body = (0, _jquery2.default)('body');
    this.$el = (0, _jquery2.default)(options.el);
    this.$backdrop = (0, _jquery2.default)('<div class="modal-overlay">');

    this.options = _jquery2.default.extend({
      modalId: 'modal',
      modalClass: '',
      bodyOverflowClass: 'scroll-locked',
      centerVertically: true,
      closeSelector: '.modal-close',
      afterShow: function afterShow() {},
      afterHide: function afterHide() {}
    }, options);

    this.wrapperHtml = '<div id="' + this.options.modalId + '" class="modal-wrapper" tabindex="-1" role="dialog"><div class="' + this.options.modalClass + ' modal" role="document"><div class="modal-content">';
  }

  /**
   * set up our fresh modal element
   */


  _createClass(Modal, [{
    key: '_init',
    value: function _init() {
      // get the contents
      this.$modalContent = this.$el.children().detach();
      // create a new wrapping element
      this.$modal = (0, _jquery2.default)(this.wrapperHtml);
      // pop our content in there
      this.$modal.find('.modal-content').append(this.$modalContent);
      // add backdrop
      this.$backdrop.appendTo(this.$body);
    }

    /**
     * Put everything back where they used to be
     */

  }, {
    key: '_reset',
    value: function _reset() {
      this.$modal.detach();
      this.$el.append(this.$modalContent);
    }

    /**
     * Show both the modal and backdrop
     */

  }, {
    key: '_open',
    value: function _open() {
      var _this = this;

      this._init();
      this._bindOverlayClick();
      this._bindCloseClick();
      this._bindCloseEsc();

      this.$body.addClass(this.options.bodyOverflowClass).append(this.$modal);

      if (this.options.centerVertically) {
        this.$dialog = this.$modal.find('.modal');
        this._bindResize();

        // position modal for the first time just after it's been unhidden
        this.$modal.one('revealer-animating', function () {
          _this._reposition();
        });
      }

      // bind callback function
      this.$modal.one('revealer-show', function (event) {
        _this.options.afterShow((0, _jquery2.default)(event.currentTarget));
      });

      // show both modal & backdrop
      this.$modal.add(this.$backdrop).revealer('show');

      // set up backdrop removal on hide
      this.$backdrop.on('revealer-hide', function () {
        _this.$backdrop.remove();
        _this.options.afterHide();
      });
    }

    /**
     * Hide  both the modal and backdrop
     */

  }, {
    key: '_close',
    value: function _close() {
      this.$modal.add(this.$backdrop).revealer('hide');

      this.$body.removeClass(this.options.bodyOverflowClass);

      this._unbindResize();
      this._reset();
    }

    /**
     * close modal if we click only on backdrop
     */

  }, {
    key: '_bindOverlayClick',
    value: function _bindOverlayClick() {
      var _this2 = this;

      this.$modal.on('click', function (event) {
        if (event.target === event.currentTarget) {
          _this2._close();
        }
      });
    }

    /**
     * close modal if we click on a close button
     */

  }, {
    key: '_bindCloseClick',
    value: function _bindCloseClick() {
      var _this3 = this;

      this.$modal.on('click', this.options.closeSelector, function (event) {
        event.preventDefault();
        _this3._close();
      });
    }

    /**
     * close modal if we press the escape button when it's visible
     */

  }, {
    key: '_bindCloseEsc',
    value: function _bindCloseEsc() {
      var _this4 = this;

      (0, _jquery2.default)(document).on('keyup', function (event) {
        if (event.keyCode === 27 && _this4.$modal.revealer('isVisible')) {
          event.preventDefault();
          _this4._close();
        }
      });
    }

    // -------------------------- Positioning -------------------------- //

    /**
     * calculate margin-top for element
     */

  }, {
    key: '_reposition',
    value: function _reposition() {
      if (!this.$dialog || !this.options.centerVertically) {
        return;
      }

      var elHeight = this.$dialog.outerHeight();
      var windowHeight = (0, _jquery2.default)(window).height();
      var diff = (windowHeight - elHeight) / 2;

      diff = diff < 0 ? 0 : diff;

      this.$dialog.css('margin-top', diff);
    }
  }, {
    key: '_bindResize',
    value: function _bindResize() {
      var _this5 = this;

      (0, _jquery2.default)(window).on('resize.modal', (0, _justDebounce2.default)(function () {
        _this5._reposition.bind(_this5);
      }, 100));
    }
  }, {
    key: '_unbindResize',
    value: function _unbindResize() {
      (0, _jquery2.default)(window).off('resize.modal');
    }

    // -------------------------- Expose Public Methods -------------------------- //

  }, {
    key: 'open',
    value: function open() {
      this._open();
    }
  }, {
    key: 'close',
    value: function close() {
      this._close();
    }
  }, {
    key: 'position',
    value: function position() {
      this._reposition();
    }
  }]);

  return Modal;
}();

exports["default"] = Modal;

/***/ }),

/***/ "./node_modules/bc-modal/node_modules/jquery-revealer/jquery.revealer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/bc-modal/node_modules/jquery-revealer/jquery.revealer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Revealer 3.0.0
 *
 * Copyright 2021, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
(function($){
  // check for trend event (make sure jquery.trend is included)
  if (typeof $.event.special.trend !== "object") {
    console.warn("Please make sure jquery.trend is included! Otherwise revealer won't work.");
  }

  // Simple requestAnimationFrame polyfill
  var raf = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function(fn) { window.setTimeout(fn, 1000/60); }


  // Public API
  var methods = {
    isVisible: function(el) {
      return !!el.data("revealer-visible");
    },

    show: function(el, force) {
      // Check state
      if (methods.isVisible(el)) {
        el.removeClass("animating animating-in");
        el.off("revealer-animating revealer-show");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", true);
      el.off("trend");

      if (force) {
        el.addClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-show");
        });
        return;
      }

      raf(function(){
        // Start animation state transition
        el.addClass("animating animating-in");
        el.trigger("revealer-animating");

        raf(function(){
          el.addClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in");
            el.trigger("revealer-show");
          });
        });
      });
    },

    hide: function(el, force) {
      // Check state
      if (!methods.isVisible(el)) {
        el.removeClass("animating animating-out visible");
        el.off("revealer-animating revealer-hide");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", false);
      el.off("trend");

      if (force) {
        el.removeClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-hide");
        });
        return;
      }

      raf(function(){
        el.addClass("animating animating-out");
        el.trigger("revealer-animating");

        raf(function(){
          el.removeClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in animating-out");
            el.trigger("revealer-hide");
          });
        });
      });
    },

    toggle: function(el, force) {
      if (methods.isVisible(el)) {
        methods.hide(el, force);
      } else {
        methods.show(el, force);
      }
    }
  };

  // jQuery plugin
  $.fn.revealer = function(method, force) {
    // Get action
    var action = methods[method || "toggle"];
    if (!action) return this;

    // Run action
    if (method === "isVisible") {
      return action(this);
    }

    return this.each(function(){
      action($(this), force);
    });
  };
})(jQuery);


/***/ }),

/***/ "./node_modules/bc-modal/node_modules/jquery-trend/jquery.trend.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bc-modal/node_modules/jquery-trend/jquery.trend.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Trend 0.1.0
 *
 * Fail-safe TransitionEnd event for jQuery.
 *
 * Adds a new "trend" event that can be used in browsers that don't
 * support "transitionend".
 *
 * NOTE: Only supports being bound with "jQuery.one".
 *
 * Copyright 2014, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
;(function($){

  // Prefixed transitionend event names
  var transitionEndEvents =
    "webkitTransitionEnd " +
    "otransitionend " +
    "oTransitionEnd " +
    "msTransitionEnd " +
    "transitionend";

  // Prefixed transition duration property names
  var transitionDurationProperties = [
    "transition-duration",
    "-moz-transition-duration",
    "-webkit-transition-duration",
    "-ms-transition-duration",
    "-o-transition-duration",
    "-khtml-transition-duration"
  ];

  // Parses a CSS duration value into milliseconds.
  var parseDuration = function(s) {
    s = s.replace(/\s/, "");
    var v = window.parseFloat(s);

    return s.match(/[^m]s$/i)
      ? v * 1000
      : v;
  };

  // Get the transition duration for an element, as specified by CSS.
  // Returns a value in milliseconds.
  var getTransitionDuration = function(el) {
    var duration = 0;

    for (var i = 0; i < transitionDurationProperties.length; i++) {
      // Get raw CSS value
      var value = el.css(transitionDurationProperties[i]);
      if (!value) continue;

      // Multiple transitions--pick the longest
      if (value.indexOf(",") !== -1) {
        var values = value.split(",");
        var durations = (function(){
          var results = [];
          for (var i = 0; i < values.length; i++) {
            var duration = parseDuration(values[i]);
            results.push(duration);
          }
          return results;
        })();

        duration = Math.max.apply(Math, durations);
      }

      // Single transition
      else {
        duration = parseDuration(value);
      }

      // Accept first vaue
      break;
    }

    return duration;
  };

  $.event.special.trend = {
    // Triggers an event handler when an element is done transitioning.
    //
    // Handles browsers that don't support transitionend by adding a
    // timeout with the transition duration.
    add: function(handleObj) {
      var el = $(this);
      var fired = false;

      // Mark element as being in transition
      el.data("trend", true);

      // Calculate a fallback duration. + 20 because some browsers fire
      // timeouts faster than transitionend.
      var duration = getTransitionDuration(el) + 20;

      var cb = function(e) {
        // transitionend events can be sent for each property. Let's just
        // skip all but the first. Also handles the timeout callback.
        if (fired) return;

        // Child elements that also have transitions can be fired before we
        // complete. This will catch and ignore those. Unfortunately, we'll
        // have to rely on the timeout in these cases.
        if (e && e.srcElement !== el[0]) return;

        // Mark element has not being in transition
        el.data("trend", false);

        // Callback
        fired = true;
        if (handleObj.handler) handleObj.handler();
      };

      el.one(transitionEndEvents, cb);
      el.data("trend-timeout", window.setTimeout(cb, duration));
    },

    remove: function(handleObj) {
      var el = $(this);
      el.off(transitionEndEvents);
      window.clearTimeout(el.data("trend-timeout"));
    }
  };

})(jQuery);


/***/ }),

/***/ "./node_modules/bc-scroll-link/dist/scroll-link.js":
/*!*********************************************************!*\
  !*** ./node_modules/bc-scroll-link/dist/scroll-link.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ScrollLink = function () {
  function ScrollLink(options) {
    _classCallCheck(this, ScrollLink);

    this.options = _jquery2.default.extend({
      selector: '[data-scroll]',
      duration: 1000,
      easing: 'swing',
      delay: 0,
      offset: 0,
      updateHash: true
    }, options);

    this._bindEvents();
  }

  _createClass(ScrollLink, [{
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this = this;

      (0, _jquery2.default)(this.options.selector).on('click', function (e) {
        e.preventDefault();
        setTimeout(function () {
          _this._scrollToContent((0, _jquery2.default)(e.currentTarget));
        }, _this.options.delay);
      });
    }
  }, {
    key: '_scrollToContent',
    value: function _scrollToContent(target) {
      var duration = this.options.duration;
      var easing = this.options.easing;
      var scrollTarget = (0, _jquery2.default)(target).data('scroll') || target;

      if (scrollTarget === '#') {
        scrollTarget = 'body';
      }

      (0, _jquery2.default)('html, body').animate({
        scrollTop: (0, _jquery2.default)(scrollTarget).offset().top + this.options.offset
      }, duration, easing);

      if (this.options.updateHash) {
        if (history.replaceState) {
          history.replaceState({}, scrollTarget, scrollTarget);
        } else {
          window.location.hash = scrollTarget;
        }
      }
    }
  }, {
    key: 'scrollToContent',
    value: function scrollToContent(target) {
      var _this2 = this;

      setTimeout(function () {
        _this2._scrollToContent(target);
      }, this.options.delay);
    }
  }]);

  return ScrollLink;
}();

exports["default"] = ScrollLink;

/***/ }),

/***/ "./node_modules/bc-tabs/dist/tabs.js":
/*!*******************************************!*\
  !*** ./node_modules/bc-tabs/dist/tabs.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");

var _jquery2 = _interopRequireDefault(_jquery);

var _justDebounce = __webpack_require__(/*! just-debounce */ "./node_modules/just-debounce/index.js");

var _justDebounce2 = _interopRequireDefault(_justDebounce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tabs = function () {
  function Tabs(options) {
    _classCallCheck(this, Tabs);

    this.options = _jquery2.default.extend({

      // Scoping the tabs (event binding), link class, and content
      tabScope: '[data-tabs]',
      tabToggle: '[data-tab-link]',
      tabContent: '[data-tab-content]',
      toggleTab: this._defaultToggleTab,
      keepTabsOpen: this.keepTabsOpen,
      activeClass: 'active',
      defaultTab: '',
      afterSetup: function afterSetup() {},
      afterChange: function afterChange($element) {},
      tabHistory: false
    }, options);

    this.$scope = (0, _jquery2.default)(this.options.tabScope);
    this.$tabToggles = (0, _jquery2.default)(this.options.tabToggle);
    this.$tabContents = (0, _jquery2.default)(this.options.tabContent);

    this.defaultTab = this.options.defaultTab || this.$tabContents.get(0);

    this.currentTab = this._defaultTab();
    this.previousStyle = this._getTabStyle();

    this._bindEvents();
    this._init();
    this.options.afterSetup();
  }

  /* ----------------------------------------------------------------------- /
   Default functions: can be overridden by passing callbacks into constructor
   */

  // Find out the default tab (if none selected in options)


  _createClass(Tabs, [{
    key: '_defaultTab',
    value: function _defaultTab() {
      return this.$tabContents.first().attr('id');
    }

    // Default function to toggle a tab between active / inactive

  }, {
    key: '_defaultToggleTab',
    value: function _defaultToggleTab(element, active) {
      var $element = (0, _jquery2.default)(element);

      $element.toggleClass(this.activeClass, active);
    }
  }, {
    key: '_getTabStyle',
    value: function _getTabStyle() {
      var pseudoElem = window.getComputedStyle(this.$scope.get(0), ':before').content.replace(/"/g, '');
      return pseudoElem;
    }

    // Default function to toggle some content on or off

  }, {
    key: '_defaultToggleContent',
    value: function _defaultToggleContent(element, active) {
      var _this = this;

      var $element = (0, _jquery2.default)(element);

      if (active) {
        // Set the tab to active
        if (this.previousStyle === 'slide') {
          // show with a slidetoggle
          $element.slideDown('fast', function () {
            _this.options.afterChange($element);
          });
        } else {
          // Show simply via display
          $element.show();
          this.options.afterChange($element);
        }
      } else {
        // Set the tab to inactive
        if (this.previousStyle === 'slide') {
          // Remove via a slideToggle
          $element.slideUp('fast', function () {
            _this.options.afterChange($element);
          });
        } else {
          // Remove via a simple hide
          $element.hide();
          this.options.afterChange($element);
        }
      }
    }

    // Determine if we should target all tabs or individual tabs
    // (Swap between tab and accordion functionality.)

  }, {
    key: 'keepTabsOpen',
    value: function keepTabsOpen() {
      return window.innerWidth < 800;
    }

    /* ----------------------------------------------------------------------- /
     Activation functions: Trigger the callbacks for showing / hiding tab
     components and links
     */

    // Set a particular tab as active (and optionally disable others)
    // This function is a wrapper for activating both the tab-link and
    // tab-content at the same time.

  }, {
    key: 'activateTab',
    value: function activateTab(hash, closeOthers) {

      // necessary to check for links that link to tabs that aren't available:
      if (!(0, _jquery2.default)(hash).length) {
        console.log('tab doesn\'t exist!');
        return;
      }

      var isSticky = closeOthers || this.options.keepTabsOpen();
      this.activateTabToggle(hash, isSticky);
      this.activateTabContent(hash, isSticky);
    }

    // Remove bc-tabs if content with tabs is updated, refreshed or replaced

  }, {
    key: 'unload',
    value: function unload() {
      this.$scope.off('.bc-tabs');
      (0, _jquery2.default)(window).off('.bc-tabs');
    }

    // Set a particular [data-tab-toggle] link as active,
    // and (optionally) deactivate others

  }, {
    key: 'activateTabToggle',
    value: function activateTabToggle(hash) {
      var isSticky = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


      var $thisTab = (0, _jquery2.default)(hash);

      // Find tablinks that point to this hash
      var $tabLinks = this.$tabToggles.filter(function () {
        return (0, _jquery2.default)(this).attr('href') === hash;
      });

      if (!isSticky) {
        // Tab stickyness not active, target all other tabs in group

        if ($thisTab.is(':visible')) return;
        // Grab all the groups these links belong to
        var tabsGroups = [];
        $tabLinks.each(function () {
          var thisTabGroup = (0, _jquery2.default)(this).data('tabs-group');
          if (tabsGroups.indexOf(thisTabGroup) === -1) {
            tabsGroups.push(thisTabGroup);
          }
        });

        // Filter all the tabs to only those belonging to these groups
        var $tabsGroup = this.$tabToggles.filter(function () {
          return tabsGroups.indexOf((0, _jquery2.default)(this).data('tabs-group')) > -1;
        });

        // Disable all the tab links
        for (var i = 0; i < $tabsGroup.length; i++) {
          this.options.toggleTab($tabsGroup[i], false);
        }

        // Enable just the tab links associated with this hash
        for (var _i = 0; _i < $tabLinks.length; _i++) {
          this.options.toggleTab($tabLinks[_i], true);
        }
      } else {
        // Tabs are sticky, so we should only toggle items matching this hash
        if ($thisTab.is(':visible')) {
          // Enable just the tab links associated with this hash
          for (var _i2 = 0; _i2 < $tabLinks.length; _i2++) {
            this.options.toggleTab($tabLinks[_i2], false);
          }
        } else {
          for (var _i3 = 0; _i3 < $tabLinks.length; _i3++) {
            this.options.toggleTab($tabLinks[_i3], true);
          }
        }
      }
    }

    // Activate a content-element with the corresponding hash, and
    // (optionally) hide others in group

  }, {
    key: 'activateTabContent',
    value: function activateTabContent(hash) {
      var isSticky = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var $thisTab = (0, _jquery2.default)(hash);

      if (!isSticky) {

        if ($thisTab.is(':visible')) return;

        // Locate other tabs that share the same 'tabs-group'
        var tabsGroup = $thisTab.data('tabs-group');
        var $tabsGroup = this.$tabContents.filter(function () {
          return (0, _jquery2.default)(this).data('tabs-group') === tabsGroup;
        });

        // Disable other tabs in this group
        for (var i = 0; i < $tabsGroup.length; i++) {
          this._defaultToggleContent($tabsGroup[i], false);
        }
        // Enable this tab content
        this._defaultToggleContent($thisTab, true);
      } else {
        // Tabs are sticky, so we only toggle the individual item
        if ($thisTab.is(':visible')) {
          this._defaultToggleContent($thisTab, false);
        } else {
          this._defaultToggleContent($thisTab, true);
        }
      }
    }

    /* ----------------------------------------------------------------------- /
     Miscellaneous: deal with initing the base tab state (say after resizing
     the viewport or on page load) and event binding.
     */

    // Function to run when tabs are first init (sets one active over others)

  }, {
    key: '_init',
    value: function _init(checkStyleMatch) {
      if (checkStyleMatch) {
        var currentStyle = this._getTabStyle();

        if (this.previousStyle == currentStyle) {
          return;
        }

        this.previousStyle = currentStyle;
      }

      var hash = window.location.hash || '#' + this.defaultTab.id;
      var currentTab = hash ? 'a[href="' + hash + '"]' : '[data-tab-link]:first';

      // Disable all the tabs
      for (var i = 0; i < this.$tabToggles.length; i++) {
        this.options.toggleTab(this.$tabToggles.get(i), false);
      }

      for (var _i4 = 0; _i4 < this.$tabContents.length; _i4++) {
        this._defaultToggleContent(this.$tabContents.get(_i4), false);
      }

      this._defaultToggleContent(hash, true);
      this.options.toggleTab(currentTab, true);
    }

    // Bind event handlers to the scope target.

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$scope.on('click.bc-tabs', this.options.tabToggle, function (event) {
        event.preventDefault();
        var hash = (0, _jquery2.default)(event.target).attr('href');

        _this2.activateTab(hash);

        if (_this2.options.tabHistory) {
          history.pushState({}, hash, hash);
        } else {
          history.replaceState({}, hash, hash);
        }
      });

      (0, _jquery2.default)(window).on('hashchange.bc-tabs', function () {
        _this2.activateTab(window.location.hash);
      });

      (0, _jquery2.default)(window).on('resize.bc-tabs', (0, _justDebounce2.default)(function () {
        _this2._init(true);
      }, 300));
    }
  }]);

  return Tabs;
}();

exports["default"] = Tabs;


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/set-function-length/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");
var $max = GetIntrinsic('%Math.max%');

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/creditcards-types/index.js":
/*!*************************************************!*\
  !*** ./node_modules/creditcards-types/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./types */ "./node_modules/creditcards-types/types/index.js")


/***/ }),

/***/ "./node_modules/creditcards-types/type.js":
/*!************************************************!*\
  !*** ./node_modules/creditcards-types/type.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = CardType

function CardType (data) {
  if (!(this instanceof CardType)) return new CardType(data)
  Object.assign(this, data)
}

CardType.prototype.digits = 16
CardType.prototype.cvcLength = 3
CardType.prototype.luhn = true
CardType.prototype.groupPattern = /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?/

CardType.prototype.group = function (number) {
  return (number.match(this.groupPattern) || [])
    .slice(1)
    .filter(Boolean)
}

CardType.prototype.test = function (number, eager) {
  return this[eager ? 'eagerPattern' : 'pattern'].test(number)
}


/***/ }),

/***/ "./node_modules/creditcards-types/types/american-express.js":
/*!******************************************************************!*\
  !*** ./node_modules/creditcards-types/types/american-express.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'American Express',
  digits: 15,
  pattern: /^3[47]\d{13}$/,
  eagerPattern: /^3[47]/,
  groupPattern: /(\d{1,4})(\d{1,6})?(\d{1,5})?/,
  cvcLength: 4
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/dankort.js":
/*!*********************************************************!*\
  !*** ./node_modules/creditcards-types/types/dankort.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Dankort',
  pattern: /^5019\d{12}$/,
  eagerPattern: /^5019/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/diners-club.js":
/*!*************************************************************!*\
  !*** ./node_modules/creditcards-types/types/diners-club.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Diners Club',
  digits: [14, 19],
  pattern: /^3(0[0-5]|[68]\d)\d{11,16}$/,
  eagerPattern: /^3(0|[68])/,
  groupPattern: /(\d{1,4})?(\d{1,6})?(\d{1,9})?/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/discover.js":
/*!**********************************************************!*\
  !*** ./node_modules/creditcards-types/types/discover.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Discover',
  pattern: /^6(011(0[0-9]|[2-4]\d|74|7[7-9]|8[6-9]|9[0-9])|4[4-9]\d{3}|5\d{4})\d{10}$/,
  eagerPattern: /^6(011(0[0-9]|[2-4]|74|7[7-9]|8[6-9]|9[0-9])|4[4-9]|5)/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/elo.js":
/*!*****************************************************!*\
  !*** ./node_modules/creditcards-types/types/elo.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Elo',
  pattern: /^(4[035]|5[0]|6[235])(6[7263]|9[90]|1[2416]|7[736]|8[9]|0[04579]|5[0])([0-9])([0-9])\d{10}$/,
  eagerPattern: /^(4[035]|5[0]|6[235])(6[7263]|9[90]|1[2416]|7[736]|8[9]|0[04579]|5[0])([0-9])([0-9])/,
  groupPattern: /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?(\d{1,3})?/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/forbrugsforeningen.js":
/*!********************************************************************!*\
  !*** ./node_modules/creditcards-types/types/forbrugsforeningen.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Forbrugsforeningen',
  pattern: /^600722\d{10}$/,
  eagerPattern: /^600/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/creditcards-types/types/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = [
  __webpack_require__(/*! ./visa */ "./node_modules/creditcards-types/types/visa.js"),
  __webpack_require__(/*! ./maestro */ "./node_modules/creditcards-types/types/maestro.js"),
  __webpack_require__(/*! ./forbrugsforeningen */ "./node_modules/creditcards-types/types/forbrugsforeningen.js"),
  __webpack_require__(/*! ./dankort */ "./node_modules/creditcards-types/types/dankort.js"),
  __webpack_require__(/*! ./mastercard */ "./node_modules/creditcards-types/types/mastercard.js"),
  __webpack_require__(/*! ./american-express */ "./node_modules/creditcards-types/types/american-express.js"),
  __webpack_require__(/*! ./diners-club */ "./node_modules/creditcards-types/types/diners-club.js"),
  __webpack_require__(/*! ./discover */ "./node_modules/creditcards-types/types/discover.js"),
  __webpack_require__(/*! ./jcb */ "./node_modules/creditcards-types/types/jcb.js"),
  __webpack_require__(/*! ./unionpay */ "./node_modules/creditcards-types/types/unionpay.js"),
  __webpack_require__(/*! ./troy */ "./node_modules/creditcards-types/types/troy.js"),
  __webpack_require__(/*! ./elo */ "./node_modules/creditcards-types/types/elo.js"),
  __webpack_require__(/*! ./uatp */ "./node_modules/creditcards-types/types/uatp.js")
]


/***/ }),

/***/ "./node_modules/creditcards-types/types/jcb.js":
/*!*****************************************************!*\
  !*** ./node_modules/creditcards-types/types/jcb.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'JCB',
  pattern: /^35\d{14}$/,
  eagerPattern: /^35/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/maestro.js":
/*!*********************************************************!*\
  !*** ./node_modules/creditcards-types/types/maestro.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Maestro',
  digits: [12, 19],
  pattern: /^(?:5[06789]\d\d|(?!6011[0234])(?!60117[4789])(?!60118[6789])(?!60119)(?!64[456789])(?!65)6\d{3})\d{8,15}$/,
  eagerPattern: /^(5(018|0[23]|[68])|6[37]|60111|60115|60117([56]|7[56])|60118[0-5]|64[0-3]|66)/,
  groupPattern: /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?(\d{1,3})?/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/mastercard.js":
/*!************************************************************!*\
  !*** ./node_modules/creditcards-types/types/mastercard.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Mastercard',
  pattern: /^(5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)\d{12}$/,
  eagerPattern: /^(2[3-7]|22[2-9]|5[1-5])/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/troy.js":
/*!******************************************************!*\
  !*** ./node_modules/creditcards-types/types/troy.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Troy',
  pattern: /^9792\d{12}$/,
  eagerPattern: /^9792/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/uatp.js":
/*!******************************************************!*\
  !*** ./node_modules/creditcards-types/types/uatp.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'UATP',
  digits: 15,
  pattern: /^1\d{14}$/,
  eagerPattern: /^1/,
  groupPattern: /(\d{1,4})(\d{1,5})?(\d{1,6})?/
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/unionpay.js":
/*!**********************************************************!*\
  !*** ./node_modules/creditcards-types/types/unionpay.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'UnionPay',
  pattern: /^62[0-5]\d{13,16}$/,
  eagerPattern: /^62/,
  groupPattern: /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?(\d{1,3})?/,
  luhn: false
})


/***/ }),

/***/ "./node_modules/creditcards-types/types/visa.js":
/*!******************************************************!*\
  !*** ./node_modules/creditcards-types/types/visa.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Type = __webpack_require__(/*! ../type */ "./node_modules/creditcards-types/type.js")

module.exports = Type({
  name: 'Visa',
  digits: [13, 19],
  pattern: /^4\d{12}(\d{3}|\d{6})?$/,
  eagerPattern: /^4/,
  groupPattern: /(\d{1,4})(\d{1,4})?(\d{1,4})?(\d{1,4})?(\d{1,3})?/
})


/***/ }),

/***/ "./node_modules/creditcards/card.js":
/*!******************************************!*\
  !*** ./node_modules/creditcards/card.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const luhn = __webpack_require__(/*! fast-luhn */ "./node_modules/fast-luhn/index.js")
const Types = __webpack_require__(/*! ./types */ "./node_modules/creditcards/types.js")

module.exports = Card

function Card (data) {
  const types = Types(data)

  return {
    types: data,
    parse: parseCard,
    format: formatCard,
    type: cardType,
    luhn: luhn,
    isValid: isCardValid
  }

  function parseCard (number) {
    if (typeof number !== 'string') return ''
    return number.replace(/[^\d]/g, '')
  }

  function formatCard (number, separator) {
    const type = getType(number, true)
    if (!type) return number
    return type.group(number).join(separator || ' ')
  }

  function cardType (number, eager) {
    const type = getType(number, eager)
    return type ? type.name : undefined
  }

  function isCardValid (number, type) {
    if (type) {
      type = types.get(type)
    } else {
      type = getType(number)
    }
    if (!type) return false
    return (!type.luhn || luhn(number)) && type.test(number)
  }

  function getType (number, eager) {
    return types.find(function (type) {
      return type.test(number, eager)
    })
  }
}


/***/ }),

/***/ "./node_modules/creditcards/cvc.js":
/*!*****************************************!*\
  !*** ./node_modules/creditcards/cvc.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Types = __webpack_require__(/*! ./types */ "./node_modules/creditcards/types.js")
const cvcRegex = /^\d{3,4}$/

module.exports = Cvc

function Cvc (data) {
  const types = Types(data)

  return {
    isValid: cvcIsValid
  }

  function cvcIsValid (cvc, type) {
    if (typeof cvc !== 'string') return false
    if (!cvcRegex.test(cvc)) return false

    if (!type) {
      return types.some(function (type) {
        return type.cvcLength === cvc.length
      })
    }

    return types.get(type).cvcLength === cvc.length
  }
}


/***/ }),

/***/ "./node_modules/creditcards/expiration.js":
/*!************************************************!*\
  !*** ./node_modules/creditcards/expiration.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const isValidMonth = __webpack_require__(/*! is-valid-month */ "./node_modules/is-valid-month/index.js")
const parseIntStrict = __webpack_require__(/*! parse-int */ "./node_modules/parse-int/index.js")
const parseYear = __webpack_require__(/*! parse-year */ "./node_modules/parse-year/index.js")

module.exports = {
  isPast: isPast,
  month: {
    parse: parseMonth,
    isValid: isValidMonth
  },
  year: {
    parse: parseYear,
    format: formatExpYear,
    isValid: isExpYearValid,
    isPast: isExpYearPast
  }
}

function isPast (month, year) {
  return Date.now() >= new Date(year, month)
}

function parseMonth (month) {
  return parseIntStrict(month)
}

function formatExpYear (year, strip) {
  year = year.toString()
  return strip ? year.substr(2, 4) : year
}

function isExpYearValid (year) {
  if (typeof year !== 'number') return false
  year = parseIntStrict(year)
  return year > 0
}

function isExpYearPast (year) {
  return new Date().getFullYear() > year
}


/***/ }),

/***/ "./node_modules/creditcards/index.js":
/*!*******************************************!*\
  !*** ./node_modules/creditcards/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const types = __webpack_require__(/*! creditcards-types */ "./node_modules/creditcards-types/index.js")
const Card = __webpack_require__(/*! ./card */ "./node_modules/creditcards/card.js")
const Cvc = __webpack_require__(/*! ./cvc */ "./node_modules/creditcards/cvc.js")
const expiration = __webpack_require__(/*! ./expiration */ "./node_modules/creditcards/expiration.js")

module.exports = withTypes(types)
module.exports.withTypes = withTypes

function withTypes (types) {
  return {
    card: Card(types),
    cvc: Cvc(types),
    expiration: expiration
  }
}


/***/ }),

/***/ "./node_modules/creditcards/types.js":
/*!*******************************************!*\
  !*** ./node_modules/creditcards/types.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const defaults = __webpack_require__(/*! creditcards-types */ "./node_modules/creditcards-types/index.js")

module.exports = CardTypes
module.exports.defaults = defaults

function CardTypes (types) {
  const map = types.reduce(function (acc, type) {
    acc[type.name] = type
    return acc
  }, {})

  return {
    find: types.find.bind(types),
    some: types.some.bind(types),
    get: get
  }

  function get (name) {
    const type = map[name]

    if (!type) {
      throw new Error('No type found for name: ' + name)
    }

    return type
  }
}


/***/ }),

/***/ "./node_modules/define-data-property/index.js":
/*!****************************************************!*\
  !*** ./node_modules/define-data-property/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");

var gopd = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ "./node_modules/es-define-property/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-define-property/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ "./node_modules/es-errors/eval.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/eval.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ "./node_modules/es-errors/index.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ "./node_modules/es-errors/range.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/range.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ "./node_modules/es-errors/ref.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/ref.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ "./node_modules/es-errors/syntax.js":
/*!******************************************!*\
  !*** ./node_modules/es-errors/syntax.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ "./node_modules/es-errors/type.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/type.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ "./node_modules/es-errors/uri.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/uri.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ "./node_modules/ev-emitter/ev-emitter.js":
/*!***********************************************!*\
  !*** ./node_modules/ev-emitter/ev-emitter.js ***!
  \***********************************************/
/***/ (function(module) {

/**
 * EvEmitter v2.1.1
 * Lil' event emitter
 * MIT License
 */

( function( global, factory ) {
  // universal module definition
  if (  true && module.exports ) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }

}( typeof window != 'undefined' ? window : this, function() {

function EvEmitter() {}

let proto = EvEmitter.prototype;

proto.on = function( eventName, listener ) {
  if ( !eventName || !listener ) return this;

  // set events hash
  let events = this._events = this._events || {};
  // set listeners array
  let listeners = events[ eventName ] = events[ eventName ] || [];
  // only add once
  if ( !listeners.includes( listener ) ) {
    listeners.push( listener );
  }

  return this;
};

proto.once = function( eventName, listener ) {
  if ( !eventName || !listener ) return this;

  // add event
  this.on( eventName, listener );
  // set once flag
  // set onceEvents hash
  let onceEvents = this._onceEvents = this._onceEvents || {};
  // set onceListeners object
  let onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
  // set flag
  onceListeners[ listener ] = true;

  return this;
};

proto.off = function( eventName, listener ) {
  let listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) return this;

  let index = listeners.indexOf( listener );
  if ( index != -1 ) {
    listeners.splice( index, 1 );
  }

  return this;
};

proto.emitEvent = function( eventName, args ) {
  let listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) return this;

  // copy over to avoid interference if .off() in listener
  listeners = listeners.slice( 0 );
  args = args || [];
  // once stuff
  let onceListeners = this._onceEvents && this._onceEvents[ eventName ];

  for ( let listener of listeners ) {
    let isOnce = onceListeners && onceListeners[ listener ];
    if ( isOnce ) {
      // remove listener
      // remove before trigger to prevent recursion
      this.off( eventName, listener );
      // unset once flag
      delete onceListeners[ listener ];
    }
    // trigger listener
    listener.apply( this, args );
  }

  return this;
};

proto.allOff = function() {
  delete this._events;
  delete this._onceEvents;
  return this;
};

return EvEmitter;

} ) );


/***/ }),

/***/ "./node_modules/eventemitter2/lib/eventemitter2.js":
/*!*********************************************************!*\
  !*** ./node_modules/eventemitter2/lib/eventemitter2.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
;!function(undefined) {
  var hasOwnProperty= Object.hasOwnProperty;
  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;
  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';
  var symbolsSupported= typeof Symbol==='function';
  var reflectSupported= typeof Reflect === 'object';
  var setImmediateSupported= typeof setImmediate === 'function';
  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;
  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){
    var arr= Object.getOwnPropertyNames(obj);
    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
    return arr;
  }) : Object.keys;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {
      this._conf = conf;

      conf.delimiter && (this.delimiter = conf.delimiter);

      if(conf.maxListeners!==undefined){
          this._maxListeners= conf.maxListeners;
      }

      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this._newListener = conf.newListener);
      conf.removeListener && (this._removeListener = conf.removeListener);
      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    }
  }

  function logPossibleMemoryLeak(count, eventName) {
    var errorMsg = '(node) warning: possible EventEmitter memory ' +
        'leak detected. ' + count + ' listeners added. ' +
        'Use emitter.setMaxListeners() to increase limit.';

    if(this.verboseMemoryLeak){
      errorMsg += ' Event name: ' + eventName + '.';
    }

    if(typeof process !== 'undefined' && process.emitWarning){
      var e = new Error(errorMsg);
      e.name = 'MaxListenersExceededWarning';
      e.emitter = this;
      e.count = count;
      process.emitWarning(e);
    } else {
      console.error(errorMsg);

      if (console.trace){
        console.trace();
      }
    }
  }

  var toArray = function (a, b, c) {
    var n = arguments.length;
    switch (n) {
      case 0:
        return [];
      case 1:
        return [a];
      case 2:
        return [a, b];
      case 3:
        return [a, b, c];
      default:
        var arr = new Array(n);
        while (n--) {
          arr[n] = arguments[n];
        }
        return arr;
    }
  };

  function toObject(keys, values) {
    var obj = {};
    var key;
    var len = keys.length;
    var valuesCount = values ? values.length : 0;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = i < valuesCount ? values[i] : undefined;
    }
    return obj;
  }

  function TargetObserver(emitter, target, options) {
    this._emitter = emitter;
    this._target = target;
    this._listeners = {};
    this._listenersCount = 0;

    var on, off;

    if (options.on || options.off) {
      on = options.on;
      off = options.off;
    }

    if (target.addEventListener) {
      on = target.addEventListener;
      off = target.removeEventListener;
    } else if (target.addListener) {
      on = target.addListener;
      off = target.removeListener;
    } else if (target.on) {
      on = target.on;
      off = target.off;
    }

    if (!on && !off) {
      throw Error('target does not implement any known event API');
    }

    if (typeof on !== 'function') {
      throw TypeError('on method must be a function');
    }

    if (typeof off !== 'function') {
      throw TypeError('off method must be a function');
    }

    this._on = on;
    this._off = off;

    var _observers= emitter._observers;
    if(_observers){
      _observers.push(this);
    }else{
      emitter._observers= [this];
    }
  }

  Object.assign(TargetObserver.prototype, {
    subscribe: function(event, localEvent, reducer){
      var observer= this;
      var target= this._target;
      var emitter= this._emitter;
      var listeners= this._listeners;
      var handler= function(){
        var args= toArray.apply(null, arguments);
        var eventObj= {
          data: args,
          name: localEvent,
          original: event
        };
        if(reducer){
          var result= reducer.call(target, eventObj);
          if(result!==false){
            emitter.emit.apply(emitter, [eventObj.name].concat(args))
          }
          return;
        }
        emitter.emit.apply(emitter, [localEvent].concat(args));
      };


      if(listeners[event]){
        throw Error('Event \'' + event + '\' is already listening');
      }

      this._listenersCount++;

      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){

        this._onNewListener = function (_event) {
          if (_event === localEvent && listeners[event] === null) {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        };

        emitter.on('newListener', this._onNewListener);

        this._onRemoveListener= function(_event){
          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){
            listeners[event]= null;
            observer._off.call(target, event, handler);
          }
        };

        listeners[event]= null;

        emitter.on('removeListener', this._onRemoveListener);
      }else{
        listeners[event]= handler;
        observer._on.call(target, event, handler);
      }
    },

    unsubscribe: function(event){
      var observer= this;
      var listeners= this._listeners;
      var emitter= this._emitter;
      var handler;
      var events;
      var off= this._off;
      var target= this._target;
      var i;

      if(event && typeof event!=='string'){
        throw TypeError('event must be a string');
      }

      function clearRefs(){
        if(observer._onNewListener){
          emitter.off('newListener', observer._onNewListener);
          emitter.off('removeListener', observer._onRemoveListener);
          observer._onNewListener= null;
          observer._onRemoveListener= null;
        }
        var index= findTargetIndex.call(emitter, observer);
        emitter._observers.splice(index, 1);
      }

      if(event){
        handler= listeners[event];
        if(!handler) return;
        off.call(target, event, handler);
        delete listeners[event];
        if(!--this._listenersCount){
          clearRefs();
        }
      }else{
        events= ownKeys(listeners);
        i= events.length;
        while(i-->0){
          event= events[i];
          off.call(target, event, listeners[event]);
        }
        this._listeners= {};
        this._listenersCount= 0;
        clearRefs();
      }
    }
  });

  function resolveOptions(options, schema, reducers, allowUnknown) {
    var computedOptions = Object.assign({}, schema);

    if (!options) return computedOptions;

    if (typeof options !== 'object') {
      throw TypeError('options must be an object')
    }

    var keys = Object.keys(options);
    var length = keys.length;
    var option, value;
    var reducer;

    function reject(reason) {
      throw Error('Invalid "' + option + '" option value' + (reason ? '. Reason: ' + reason : ''))
    }

    for (var i = 0; i < length; i++) {
      option = keys[i];
      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
        throw Error('Unknown "' + option + '" option');
      }
      value = options[option];
      if (value !== undefined) {
        reducer = reducers[option];
        computedOptions[option] = reducer ? reducer(value, reject) : value;
      }
    }
    return computedOptions;
  }

  function constructorReducer(value, reject) {
    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {
      reject('value must be a constructor');
    }
    return value;
  }

  function makeTypeReducer(types) {
    var message= 'value must be type of ' + types.join('|');
    var len= types.length;
    var firstType= types[0];
    var secondType= types[1];

    if (len === 1) {
      return function (v, reject) {
        if (typeof v === firstType) {
          return v;
        }
        reject(message);
      }
    }

    if (len === 2) {
      return function (v, reject) {
        var kind= typeof v;
        if (kind === firstType || kind === secondType) return v;
        reject(message);
      }
    }

    return function (v, reject) {
      var kind = typeof v;
      var i = len;
      while (i-- > 0) {
        if (kind === types[i]) return v;
      }
      reject(message);
    }
  }

  var functionReducer= makeTypeReducer(['function']);

  var objectFunctionReducer= makeTypeReducer(['object', 'function']);

  function makeCancelablePromise(Promise, executor, options) {
    var isCancelable;
    var callbacks;
    var timer= 0;
    var subscriptionClosed;

    var promise = new Promise(function (resolve, reject, onCancel) {
      options= resolveOptions(options, {
        timeout: 0,
        overload: false
      }, {
        timeout: function(value, reject){
          value*= 1;
          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {
            reject('timeout must be a positive number');
          }
          return value;
        }
      });

      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';

      function cleanup() {
        if (callbacks) {
          callbacks = null;
        }
        if (timer) {
          clearTimeout(timer);
          timer = 0;
        }
      }

      var _resolve= function(value){
        cleanup();
        resolve(value);
      };

      var _reject= function(err){
        cleanup();
        reject(err);
      };

      if (isCancelable) {
        executor(_resolve, _reject, onCancel);
      } else {
        callbacks = [function(reason){
          _reject(reason || Error('canceled'));
        }];
        executor(_resolve, _reject, function (cb) {
          if (subscriptionClosed) {
            throw Error('Unable to subscribe on cancel event asynchronously')
          }
          if (typeof cb !== 'function') {
            throw TypeError('onCancel callback must be a function');
          }
          callbacks.push(cb);
        });
        subscriptionClosed= true;
      }

      if (options.timeout > 0) {
        timer= setTimeout(function(){
          var reason= Error('timeout');
          reason.code = 'ETIMEDOUT'
          timer= 0;
          promise.cancel(reason);
          reject(reason);
        }, options.timeout);
      }
    });

    if (!isCancelable) {
      promise.cancel = function (reason) {
        if (!callbacks) {
          return;
        }
        var length = callbacks.length;
        for (var i = 1; i < length; i++) {
          callbacks[i](reason);
        }
        // internal callback to reject the promise
        callbacks[0](reason);
        callbacks = null;
      };
    }

    return promise;
  }

  function findTargetIndex(observer) {
    var observers = this._observers;
    if(!observers){
      return -1;
    }
    var len = observers.length;
    for (var i = 0; i < len; i++) {
      if (observers[i]._target === observer) return i;
    }
    return -1;
  }

  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i, typeLength) {
    if (!tree) {
      return null;
    }

    if (i === 0) {
      var kind = typeof type;
      if (kind === 'string') {
        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
        if ((n = type.indexOf(delimiter)) !== -1) {
          ns = new Array(5);
          do {
            ns[l++] = type.slice(j, n);
            j = n + dl;
          } while ((n = type.indexOf(delimiter, j)) !== -1);

          ns[l++] = type.slice(j);
          type = ns;
          typeLength = l;
        } else {
          type = [type];
          typeLength = 1;
        }
      } else if (kind === 'object') {
        typeLength = type.length;
      } else {
        type = [type];
        typeLength = 1;
      }
    }

    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],
        nextType = type[i + 1], branches, _listeners;

    if (i === typeLength) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //

      if(tree._listeners) {
        if (typeof tree._listeners === 'function') {
          handlers && handlers.push(tree._listeners);
          listeners = [tree];
        } else {
          handlers && handlers.push.apply(handlers, tree._listeners);
          listeners = [tree];
        }
      }
    } else {

      if (currentType === '*') {
        //
        // If the event emitted is '*' at this part
        // or there is a concrete match at this patch
        //
        branches = ownKeys(tree);
        n = branches.length;
        while (n-- > 0) {
          branch = branches[n];
          if (branch !== '_listeners') {
            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
            if (_listeners) {
              if (listeners) {
                listeners.push.apply(listeners, _listeners);
              } else {
                listeners = _listeners;
              }
            }
          }
        }
        return listeners;
      } else if (currentType === '**') {
        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));
        if (endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
        }

        branches = ownKeys(tree);
        n = branches.length;
        while (n-- > 0) {
          branch = branches[n];
          if (branch !== '_listeners') {
            if (branch === '*' || branch === '**') {
              if (tree[branch]._listeners && !endReached) {
                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
            } else if (branch === nextType) {
              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
            } else {
              // No match on this one, shift into the tree but not in the type array.
              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
            }
            if (_listeners) {
              if (listeners) {
                listeners.push.apply(listeners, _listeners);
              } else {
                listeners = _listeners;
              }
            }
          }
        }
        return listeners;
      } else if (tree[currentType]) {
        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
      }
    }

      xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i + 1, typeLength);
    }

    xxTree = tree['**'];
    if (xxTree) {
      if (i < typeLength) {
        if (xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
        }

        // Build arrays of matching next branches and others.
        branches= ownKeys(xxTree);
        n= branches.length;
        while(n-->0){
          branch= branches[n];
          if (branch !== '_listeners') {
            if (branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
            } else if (branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);
            }
          }
        }
      } else if (xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
      } else if (xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener, prepend) {
    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;

    if(typeof type==='string') {
      if ((i = type.indexOf(delimiter)) !== -1) {
        ns = new Array(5);
        do {
          ns[len++] = type.slice(j, i);
          j = i + dl;
        } while ((i = type.indexOf(delimiter, j)) !== -1);

        ns[len++] = type.slice(j);
      }else{
        ns= [type];
        len= 1;
      }
    }else{
      ns= type;
      len= type.length;
    }

    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    if (len > 1) {
      for (i = 0; i + 1 < len; i++) {
        if (ns[i] === '**' && ns[i + 1] === '**') {
          return;
        }
      }
    }



    var tree = this.listenerTree, name;

    for (i = 0; i < len; i++) {
      name = ns[i];

      tree = tree[name] || (tree[name] = {});

      if (i === len - 1) {
        if (!tree._listeners) {
          tree._listeners = listener;
        } else {
          if (typeof tree._listeners === 'function') {
            tree._listeners = [tree._listeners];
          }

          if (prepend) {
            tree._listeners.unshift(listener);
          } else {
            tree._listeners.push(listener);
          }

          if (
              !tree._listeners.warned &&
              this._maxListeners > 0 &&
              tree._listeners.length > this._maxListeners
          ) {
            tree._listeners.warned = true;
            logPossibleMemoryLeak.call(this, tree._listeners.length, name);
          }
        }
        return true;
      }
    }

    return true;
  }

  function collectTreeEvents(tree, events, root, asArray){
     var branches= ownKeys(tree);
     var i= branches.length;
     var branch, branchName, path;
     var hasListeners= tree['_listeners'];
     var isArrayPath;

     while(i-->0){
         branchName= branches[i];

         branch= tree[branchName];

         if(branchName==='_listeners'){
             path= root;
         }else {
             path = root ? root.concat(branchName) : [branchName];
         }

         isArrayPath= asArray || typeof branchName==='symbol';

         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));

         if(typeof branch==='object'){
             collectTreeEvents.call(this, branch, events, path, isArrayPath);
         }
     }

     return events;
  }

  function recursivelyGarbageCollect(root) {
    var keys = ownKeys(root);
    var i= keys.length;
    var obj, key, flag;
    while(i-->0){
      key = keys[i];
      obj = root[key];

      if(obj){
          flag= true;
          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){
             delete root[key];
          }
      }
    }

    return flag;
  }

  function Listener(emitter, event, listener){
    this.emitter= emitter;
    this.event= event;
    this.listener= listener;
  }

  Listener.prototype.off= function(){
    this.emitter.off(this.event, this.listener);
    return this;
  };

  function setupListener(event, listener, options){
      if (options === true) {
        promisify = true;
      } else if (options === false) {
        async = true;
      } else {
        if (!options || typeof options !== 'object') {
          throw TypeError('options should be an object or true');
        }
        var async = options.async;
        var promisify = options.promisify;
        var nextTick = options.nextTick;
        var objectify = options.objectify;
      }

      if (async || nextTick || promisify) {
        var _listener = listener;
        var _origin = listener._origin || listener;

        if (nextTick && !nextTickSupported) {
          throw Error('process.nextTick is not supported');
        }

        if (promisify === undefined) {
          promisify = listener.constructor.name === 'AsyncFunction';
        }

        listener = function () {
          var args = arguments;
          var context = this;
          var event = this.event;

          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {
            _setImmediate(resolve);
          }).then(function () {
            context.event = event;
            return _listener.apply(context, args)
          })) : (nextTick ? process.nextTick : _setImmediate)(function () {
            context.event = event;
            _listener.apply(context, args)
          });
        };

        listener._async = true;
        listener._origin = _origin;
      }

    return [listener, objectify? new Listener(this, event, listener): this];
  }

  function EventEmitter(conf) {
    this._events = {};
    this._newListener = false;
    this._removeListener = false;
    this.verboseMemoryLeak = false;
    configure.call(this, conf);
  }

  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

  EventEmitter.prototype.listenTo= function(target, events, options){
    if(typeof target!=='object'){
      throw TypeError('target musts be an object');
    }

    var emitter= this;

    options = resolveOptions(options, {
      on: undefined,
      off: undefined,
      reducers: undefined
    }, {
      on: functionReducer,
      off: functionReducer,
      reducers: objectFunctionReducer
    });

    function listen(events){
      if(typeof events!=='object'){
        throw TypeError('events must be an object');
      }

      var reducers= options.reducers;
      var index= findTargetIndex.call(emitter, target);
      var observer;

      if(index===-1){
        observer= new TargetObserver(emitter, target, options);
      }else{
        observer= emitter._observers[index];
      }

      var keys= ownKeys(events);
      var len= keys.length;
      var event;
      var isSingleReducer= typeof reducers==='function';

      for(var i=0; i<len; i++){
        event= keys[i];
        observer.subscribe(
            event,
            events[event] || event,
            isSingleReducer ? reducers : reducers && reducers[event]
        );
      }
    }

    isArray(events)?
        listen(toObject(events)) :
        (typeof events==='string'? listen(toObject(events.split(/\s+/))): listen(events));

    return this;
  };

  EventEmitter.prototype.stopListeningTo = function (target, event) {
    var observers = this._observers;

    if(!observers){
      return false;
    }

    var i = observers.length;
    var observer;
    var matched= false;

    if(target && typeof target!=='object'){
      throw TypeError('target should be an object');
    }

    while (i-- > 0) {
      observer = observers[i];
      if (!target || observer._target === target) {
        observer.unsubscribe(event);
        matched= true;
      }
    }

    return matched;
  };

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    if (n !== undefined) {
      this._maxListeners = n;
      if (!this._conf) this._conf = {};
      this._conf.maxListeners = n;
    }
  };

  EventEmitter.prototype.getMaxListeners = function() {
    return this._maxListeners;
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn, options) {
    return this._once(event, fn, false, options);
  };

  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
    return this._once(event, fn, true, options);
  };

  EventEmitter.prototype._once = function(event, fn, prepend, options) {
    return this._many(event, 1, fn, prepend, options);
  };

  EventEmitter.prototype.many = function(event, ttl, fn, options) {
    return this._many(event, ttl, fn, false, options);
  };

  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
    return this._many(event, ttl, fn, true, options);
  };

  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      return fn.apply(this, arguments);
    }

    listener._origin = fn;

    return this._on(event, listener, prepend, options);
  };

  EventEmitter.prototype.emit = function() {
    if (!this._events && !this._all) {
      return false;
    }

    this._events || init.call(this);

    var type = arguments[0], ns, wildcard= this.wildcard;
    var args,l,i,j, containsSymbol;

    if (type === 'newListener' && !this._newListener) {
      if (!this._events.newListener) {
        return false;
      }
    }

    if (wildcard) {
      ns= type;
      if(type!=='newListener' && type!=='removeListener'){
        if (typeof type === 'object') {
          l = type.length;
          if (symbolsSupported) {
            for (i = 0; i < l; i++) {
              if (typeof type[i] === 'symbol') {
                containsSymbol = true;
                break;
              }
            }
          }
          if (!containsSymbol) {
            type = type.join(this.delimiter);
          }
        }
      }
    }

    var al = arguments.length;
    var handler;

    if (this._all && this._all.length) {
      handler = this._all.slice();

      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this, type);
          break;
        case 2:
          handler[i].call(this, type, arguments[1]);
          break;
        case 3:
          handler[i].call(this, type, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, arguments);
        }
      }
    }

    if (wildcard) {
      handler = [];
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
    } else {
      handler = this._events[type];
      if (typeof handler === 'function') {
        this.event = type;
        switch (al) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          args = new Array(al - 1);
          for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          handler.apply(this, args);
        }
        return true;
      } else if (handler) {
        // need to make copy of handlers because list can change in the middle
        // of emit call
        handler = handler.slice();
      }
    }

    if (handler && handler.length) {
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this);
          break;
        case 2:
          handler[i].call(this, arguments[1]);
          break;
        case 3:
          handler[i].call(this, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, args);
        }
      }
      return true;
    } else if (!this.ignoreErrors && !this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
    }

    return !!this._all;
  };

  EventEmitter.prototype.emitAsync = function() {
    if (!this._events && !this._all) {
      return false;
    }

    this._events || init.call(this);

    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;
    var args,l,i,j;

    if (type === 'newListener' && !this._newListener) {
        if (!this._events.newListener) { return Promise.resolve([false]); }
    }

    if (wildcard) {
      ns= type;
      if(type!=='newListener' && type!=='removeListener'){
        if (typeof type === 'object') {
          l = type.length;
          if (symbolsSupported) {
            for (i = 0; i < l; i++) {
              if (typeof type[i] === 'symbol') {
                containsSymbol = true;
                break;
              }
            }
          }
          if (!containsSymbol) {
            type = type.join(this.delimiter);
          }
        }
      }
    }

    var promises= [];

    var al = arguments.length;
    var handler;

    if (this._all) {
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(this._all[i].call(this, type));
          break;
        case 2:
          promises.push(this._all[i].call(this, type, arguments[1]));
          break;
        case 3:
          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
          break;
        default:
          promises.push(this._all[i].apply(this, arguments));
        }
      }
    }

    if (wildcard) {
      handler = [];
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    } else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      switch (al) {
      case 1:
        promises.push(handler.call(this));
        break;
      case 2:
        promises.push(handler.call(this, arguments[1]));
        break;
      case 3:
        promises.push(handler.call(this, arguments[1], arguments[2]));
        break;
      default:
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
        promises.push(handler.apply(this, args));
      }
    } else if (handler && handler.length) {
      handler = handler.slice();
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(handler[i].call(this));
          break;
        case 2:
          promises.push(handler[i].call(this, arguments[1]));
          break;
        case 3:
          promises.push(handler[i].call(this, arguments[1], arguments[2]));
          break;
        default:
          promises.push(handler[i].apply(this, args));
        }
      }
    } else if (!this.ignoreErrors && !this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        return Promise.reject(arguments[1]); // Unhandled 'error' event
      } else {
        return Promise.reject("Uncaught, unspecified 'error' event.");
      }
    }

    return Promise.all(promises);
  };

  EventEmitter.prototype.on = function(type, listener, options) {
    return this._on(type, listener, false, options);
  };

  EventEmitter.prototype.prependListener = function(type, listener, options) {
    return this._on(type, listener, true, options);
  };

  EventEmitter.prototype.onAny = function(fn) {
    return this._onAny(fn, false);
  };

  EventEmitter.prototype.prependAny = function(fn) {
    return this._onAny(fn, true);
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype._onAny = function(fn, prepend){
    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    if (!this._all) {
      this._all = [];
    }

    // Add the function to the event listener collection.
    if(prepend){
      this._all.unshift(fn);
    }else{
      this._all.push(fn);
    }

    return this;
  };

  EventEmitter.prototype._on = function(type, listener, prepend, options) {
    if (typeof type === 'function') {
      this._onAny(type, listener);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    var returnValue= this, temp;

    if (options !== undefined) {
      temp = setupListener.call(this, type, listener, options);
      listener = temp[0];
      returnValue = temp[1];
    }

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    if (this._newListener) {
      this.emit('newListener', type, listener);
    }

    if (this.wildcard) {
      growListenerTree.call(this, type, listener, prepend);
      return returnValue;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    } else {
      if (typeof this._events[type] === 'function') {
        // Change to array.
        this._events[type] = [this._events[type]];
      }

      // If we've already got an array, just add
      if(prepend){
        this._events[type].unshift(listener);
      }else{
        this._events[type].push(listener);
      }

      // Check for listener leak
      if (
        !this._events[type].warned &&
        this._maxListeners > 0 &&
        this._events[type].length > this._maxListeners
      ) {
        this._events[type].warned = true;
        logPossibleMemoryLeak.call(this, this._events[type].length, type);
      }
    }

    return returnValue;
  };

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
      if(!leafs) return this;
    } else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          continue;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1);
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }
        if (this._removeListener)
          this.emit("removeListener", type, listener);

        return this;
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
        if (this._removeListener)
          this.emit("removeListener", type, listener);
      }
    }

    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          if (this._removeListener)
            this.emit("removeListenerAny", fn);
          return this;
        }
      }
    } else {
      fns = this._all;
      if (this._removeListener) {
        for(i = 0, l = fns.length; i < l; i++)
          this.emit("removeListenerAny", fns[i]);
      }
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function (type) {
    if (type === undefined) {
      !this._events || init.call(this);
      return this;
    }

    if (this.wildcard) {
      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
      if (!leafs) return this;
      for (i = 0; i < leafs.length; i++) {
        leaf = leafs[i];
        leaf._listeners = null;
      }
      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
    } else if (this._events) {
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function (type) {
    var _events = this._events;
    var keys, listeners, allListeners;
    var i;
    var listenerTree;

    if (type === undefined) {
      if (this.wildcard) {
        throw Error('event name required for wildcard emitter');
      }

      if (!_events) {
        return [];
      }

      keys = ownKeys(_events);
      i = keys.length;
      allListeners = [];
      while (i-- > 0) {
        listeners = _events[keys[i]];
        if (typeof listeners === 'function') {
          allListeners.push(listeners);
        } else {
          allListeners.push.apply(allListeners, listeners);
        }
      }
      return allListeners;
    } else {
      if (this.wildcard) {
        listenerTree= this.listenerTree;
        if(!listenerTree) return [];
        var handlers = [];
        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
        searchListenerTree.call(this, handlers, ns, listenerTree, 0);
        return handlers;
      }

      if (!_events) {
        return [];
      }

      listeners = _events[type];

      if (!listeners) {
        return [];
      }
      return typeof listeners === 'function' ? [listeners] : listeners;
    }
  };

  EventEmitter.prototype.eventNames = function(nsAsArray){
    var _events= this._events;
    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);
  };

  EventEmitter.prototype.listenerCount = function(type) {
    return this.listeners(type).length;
  };

  EventEmitter.prototype.hasListeners = function (type) {
    if (this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers.length > 0;
    }

    var _events = this._events;
    var _all = this._all;

    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  EventEmitter.prototype.waitFor = function (event, options) {
    var self = this;
    var type = typeof options;
    if (type === 'number') {
      options = {timeout: options};
    } else if (type === 'function') {
      options = {filter: options};
    }

    options= resolveOptions(options, {
      timeout: 0,
      filter: undefined,
      handleError: false,
      Promise: Promise,
      overload: false
    }, {
      filter: functionReducer,
      Promise: constructorReducer
    });

    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {
      function listener() {
        var filter= options.filter;
        if (filter && !filter.apply(self, arguments)) {
          return;
        }
        self.off(event, listener);
        if (options.handleError) {
          var err = arguments[0];
          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
        } else {
          resolve(toArray.apply(null, arguments));
        }
      }

      onCancel(function(){
        self.off(event, listener);
      });

      self._on(event, listener, false);
    }, {
      timeout: options.timeout,
      overload: options.overload
    })
  };

  function once(emitter, name, options) {
    options= resolveOptions(options, {
      Promise: Promise,
      timeout: 0,
      overload: false
    }, {
      Promise: constructorReducer
    });

    var _Promise= options.Promise;

    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){
      var handler;
      if (typeof emitter.addEventListener === 'function') {
        handler=  function () {
          resolve(toArray.apply(null, arguments));
        };

        onCancel(function(){
          emitter.removeEventListener(name, handler);
        });

        emitter.addEventListener(
            name,
            handler,
            {once: true}
        );
        return;
      }

      var eventListener = function(){
        errorListener && emitter.removeListener('error', errorListener);
        resolve(toArray.apply(null, arguments));
      };

      var errorListener;

      if (name !== 'error') {
        errorListener = function (err){
          emitter.removeListener(name, eventListener);
          reject(err);
        };

        emitter.once('error', errorListener);
      }

      onCancel(function(){
        errorListener && emitter.removeListener('error', errorListener);
        emitter.removeListener(name, eventListener);
      });

      emitter.once(name, eventListener);
    }, {
      timeout: options.timeout,
      overload: options.overload
    });
  }

  var prototype= EventEmitter.prototype;

  Object.defineProperties(EventEmitter, {
    defaultMaxListeners: {
      get: function () {
        return prototype._maxListeners;
      },
      set: function (n) {
        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {
          throw TypeError('n must be a non-negative number')
        }
        prototype._maxListeners = n;
      },
      enumerable: true
    },
    once: {
      value: once,
      writable: true,
      configurable: true
    }
  });

  Object.defineProperties(prototype, {
      _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
      },
      _observers: {value: null, writable: true, configurable: true}
  });

  if (true) {
     // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return EventEmitter;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var _global; }
}();


/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/expand-year/index.js":
/*!*******************************************!*\
  !*** ./node_modules/expand-year/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var zeroFill = __webpack_require__(/*! zero-fill */ "./node_modules/zero-fill/index.js")
var parseIntStrict = __webpack_require__(/*! parse-int */ "./node_modules/parse-int/index.js")

var pad = zeroFill(2)

module.exports = function expandYear (year, now) {
  now = now || new Date()
  var base = now.getFullYear().toString().substr(0, 2)
  year = parseIntStrict(year)
  return parseIntStrict(base + pad(year))
}


/***/ }),

/***/ "./node_modules/fast-luhn/index.js":
/*!*****************************************!*\
  !*** ./node_modules/fast-luhn/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


const lookup = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]

module.exports = function luhn (number) {
  if (typeof number !== 'string') throw new TypeError('Expected string input')
  if (!number) return false

  let index = number.length
  let x2 = true
  let sum = 0

  while (index) {
    const value = number.charCodeAt(--index) - 48
    if (value < 0 || value > 9) return false

    x2 = !x2
    sum += x2 ? lookup[value] : value
  }

  return sum % 10 === 0
}


/***/ }),

/***/ "./node_modules/fitvids/index.js":
/*!***************************************!*\
  !*** ./node_modules/fitvids/index.js ***!
  \***************************************/
/***/ ((module) => {

var selectors = [
  'iframe[src*="player.vimeo.com"]',
  'iframe[src*="youtube.com"]',
  'iframe[src*="youtube-nocookie.com"]',
  'iframe[src*="kickstarter.com"][src*="video.html"]',
  "object"
];

var css =
  ".fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}";

module.exports = function(parentSelector, opts) {
  parentSelector = parentSelector || "body";
  opts = opts || {};

  if (isObject(parentSelector)) {
    opts = parentSelector;
    parentSelector = "body";
  }

  opts.ignore = opts.ignore || "";
  opts.players = opts.players || "";

  var containers = queryAll(parentSelector);
  if (!hasLength(containers)) return;

  if (!document.getElementById("fit-vids-style")) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(styles());
  }

  var custom = toSelectorArray(opts.players);
  var ignored = toSelectorArray(opts.ignore);
  var ignoredSelector = ignored.length > 0 ? ignored.join() : null;
  var selector = selectors.concat(custom).join();

  if (!hasLength(selector)) {
    return;
  }

  containers.forEach(function(container) {
    var videos = queryAll(container, selector);

    videos.forEach(function(video) {
      if (ignoredSelector && video.matches(ignoredSelector)) {
        return;
      }
      wrap(video);
    });
  });
}

function queryAll(el, selector) {
  if (typeof el === "string") {
    selector = el;
    el = document;
  }
  return Array.prototype.slice.call(el.querySelectorAll(selector));
}

function toSelectorArray(input) {
  if (typeof input === "string") {
    return input
      .split(",")
      .map(trim)
      .filter(hasLength);
  } else if (isArray(input)) {
    return flatten(input.map(toSelectorArray).filter(hasLength));
  }
  return input || [];
}

function wrap(el) {
  if (/fluid-width-video-wrapper/.test(el.parentNode.className)) {
    return;
  }

  var widthAttr = parseInt(el.getAttribute("width"), 10);
  var heightAttr = parseInt(el.getAttribute("height"), 10);

  var width = !isNaN(widthAttr) ? widthAttr : el.clientWidth;
  var height = !isNaN(heightAttr) ? heightAttr : el.clientHeight;
  var aspect = height / width;

  el.removeAttribute("width");
  el.removeAttribute("height");

  var wrapper = document.createElement("div");
  el.parentNode.insertBefore(wrapper, el);
  wrapper.className = "fluid-width-video-wrapper";
  wrapper.style.paddingTop = aspect * 100 + "%";
  wrapper.appendChild(el);
}

function styles() {
  var div = document.createElement("div");
  div.innerHTML = '<p>x</p><style id="fit-vids-style">' + css + "</style>";
  return div.childNodes[1];
}

function hasLength(input) {
  return input.length > 0;
}

function trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}

function flatten(input) {
  return [].concat.apply([], input);
}

function isObject(input) {
  return Object.prototype.toString.call(input) === "[object Object]";
}

function isArray(input) {
  return Object.prototype.toString.call(input) === "[object Array]";
}


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Error = __webpack_require__(/*! es-errors */ "./node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/es-errors/uri.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasProto = __webpack_require__(/*! has-proto */ "./node_modules/has-proto/index.js")();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/has-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/has-proto/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


var test = {
	__proto__: null,
	foo: {}
};

var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
	// @ts-expect-error: TS errors on an inherited property for some reason
	return { __proto__: test }.foo === test.foo
		&& !(test instanceof $Object);
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/hasown/index.js":
/*!**************************************!*\
  !*** ./node_modules/hasown/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/history.js/scripts/bundled-uncompressed/html4+html5/jquery.history.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/history.js/scripts/bundled-uncompressed/html4+html5/jquery.history.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var __webpack_provided_window_dot_jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*
    json2.js
    2012-10-08

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== 'object') {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());/**
 * History.js jQuery Adapter
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

// Closure
(function(window,undefined){
	"use strict";

	// Localise Globals
	var
		History = window.History = window.History||{},
		jQuery = __webpack_provided_window_dot_jQuery;

	// Check Existence
	if ( typeof History.Adapter !== 'undefined' ) {
		throw new Error('History.js Adapter has already been loaded...');
	}

	// Add the Adapter
	History.Adapter = {
		/**
		 * History.Adapter.bind(el,event,callback)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {function} callback
		 * @return {void}
		 */
		bind: function(el,event,callback){
			jQuery(el).bind(event,callback);
		},

		/**
		 * History.Adapter.trigger(el,event)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {void}
		 */
		trigger: function(el,event,extra){
			jQuery(el).trigger(event,extra);
		},

		/**
		 * History.Adapter.extractEventData(key,event,extra)
		 * @param {string} key - key for the event data to extract
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {mixed}
		 */
		extractEventData: function(key,event,extra){
			// jQuery Native then jQuery Custom
			var result = (event && event.originalEvent && event.originalEvent[key]) || (extra && extra[key]) || undefined;

			// Return
			return result;
		},

		/**
		 * History.Adapter.onDomLoad(callback)
		 * @param {function} callback
		 * @return {void}
		 */
		onDomLoad: function(callback) {
			jQuery(callback);
		}
	};

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);

/**
 * History.js HTML4 Support
 * Depends on the HTML5 Support
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		document = window.document, // Make sure we are using the correct document
		setTimeout = window.setTimeout||setTimeout,
		clearTimeout = window.clearTimeout||clearTimeout,
		setInterval = window.setInterval||setInterval,
		History = window.History = window.History||{}; // Public History Object

	// Check Existence
	if ( typeof History.initHtml4 !== 'undefined' ) {
		throw new Error('History.js HTML4 Support has already been loaded...');
	}


	// ========================================================================
	// Initialise HTML4 Support

	// Initialise HTML4 Support
	History.initHtml4 = function(){
		// Initialise
		if ( typeof History.initHtml4.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initHtml4.initialized = true;
		}


		// ====================================================================
		// Properties

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = true;


		// ====================================================================
		// Hash Storage

		/**
		 * History.savedHashes
		 * Store the hashes in an array
		 */
		History.savedHashes = [];

		/**
		 * History.isLastHash(newHash)
		 * Checks if the hash is the last hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.isLastHash = function(newHash){
			// Prepare
			var oldHash = History.getHashByIndex(),
				isLast;

			// Check
			isLast = newHash === oldHash;

			// Return isLast
			return isLast;
		};

		/**
		 * History.isHashEqual(newHash, oldHash)
		 * Checks to see if two hashes are functionally equal
		 * @param {string} newHash
		 * @param {string} oldHash
		 * @return {boolean} true
		 */
		History.isHashEqual = function(newHash, oldHash){
			newHash = encodeURIComponent(newHash).replace(/%25/g, "%");
			oldHash = encodeURIComponent(oldHash).replace(/%25/g, "%");
			return newHash === oldHash;
		};

		/**
		 * History.saveHash(newHash)
		 * Push a Hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.saveHash = function(newHash){
			// Check Hash
			if ( History.isLastHash(newHash) ) {
				return false;
			}

			// Push the Hash
			History.savedHashes.push(newHash);

			// Return true
			return true;
		};

		/**
		 * History.getHashByIndex()
		 * Gets a hash by the index
		 * @param {integer} index
		 * @return {string}
		 */
		History.getHashByIndex = function(index){
			// Prepare
			var hash = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				hash = History.savedHashes[History.savedHashes.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				hash = History.savedHashes[History.savedHashes.length+index];
			}
			else {
				// Get from the beginning
				hash = History.savedHashes[index];
			}

			// Return hash
			return hash;
		};


		// ====================================================================
		// Discarded States

		/**
		 * History.discardedHashes
		 * A hashed array of discarded hashes
		 */
		History.discardedHashes = {};

		/**
		 * History.discardedStates
		 * A hashed array of discarded states
		 */
		History.discardedStates = {};

		/**
		 * History.discardState(State)
		 * Discards the state by ignoring it through History
		 * @param {object} State
		 * @return {true}
		 */
		History.discardState = function(discardedState,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Prepare
			var discardedStateHash = History.getHashByState(discardedState),
				discardObject;

			// Create Discard Object
			discardObject = {
				'discardedState': discardedState,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to DiscardedStates
			History.discardedStates[discardedStateHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardHash(hash)
		 * Discards the hash by ignoring it through History
		 * @param {string} hash
		 * @return {true}
		 */
		History.discardHash = function(discardedHash,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Create Discard Object
			var discardObject = {
				'discardedHash': discardedHash,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to discardedHash
			History.discardedHashes[discardedHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardedState(State)
		 * Checks to see if the state is discarded
		 * @param {object} State
		 * @return {bool}
		 */
		History.discardedState = function(State){
			// Prepare
			var StateHash = History.getHashByState(State),
				discarded;

			// Check
			discarded = History.discardedStates[StateHash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.discardedHash(hash)
		 * Checks to see if the state is discarded
		 * @param {string} State
		 * @return {bool}
		 */
		History.discardedHash = function(hash){
			// Check
			var discarded = History.discardedHashes[hash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.recycleState(State)
		 * Allows a discarded state to be used again
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {true}
		 */
		History.recycleState = function(State){
			//History.debug('History.recycleState', arguments);
			// Prepare
			var StateHash = History.getHashByState(State);

			// Remove from DiscardedStates
			if ( History.discardedState(State) ) {
				delete History.discardedStates[StateHash];
			}

			// Return true
			return true;
		};


		// ====================================================================
		// HTML4 HashChange Support

		if ( History.emulated.hashChange ) {
			/*
			 * We must emulate the HTML4 HashChange Support by manually checking for hash changes
			 */

			/**
			 * History.hashChangeInit()
			 * Init the HashChange Emulation
			 */
			History.hashChangeInit = function(){
				// Define our Checker Function
				History.checkerFunction = null;

				// Define some variables that will help in our checker function
				var lastDocumentHash = '',
					iframeId, iframe,
					lastIframeHash, checkerRunning,
					startedWithHash = Boolean(History.getHash());

				// Handle depending on the browser
				if ( History.isInternetExplorer() ) {
					// IE6 and IE7
					// We need to use an iframe to emulate the back and forward buttons

					// Create iFrame
					iframeId = 'historyjs-iframe';
					iframe = document.createElement('iframe');

					// Adjust iFarme
					// IE 6 requires iframe to have a src on HTTPS pages, otherwise it will throw a
					// "This page contains both secure and nonsecure items" warning.
					iframe.setAttribute('id', iframeId);
					iframe.setAttribute('src', '#');
					iframe.style.display = 'none';

					// Append iFrame
					document.body.appendChild(iframe);

					// Create initial history entry
					iframe.contentWindow.document.open();
					iframe.contentWindow.document.close();

					// Define some variables that will help in our checker function
					lastIframeHash = '';
					checkerRunning = false;

					// Define the checker function
					History.checkerFunction = function(){
						// Check Running
						if ( checkerRunning ) {
							return false;
						}

						// Update Running
						checkerRunning = true;

						// Fetch
						var
							documentHash = History.getHash(),
							iframeHash = History.getHash(iframe.contentWindow.document);

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Create a history entry in the iframe
							if ( iframeHash !== documentHash ) {
								//History.debug('hashchange.checker: iframe hash change', 'documentHash (new):', documentHash, 'iframeHash (old):', iframeHash);

								// Equalise
								lastIframeHash = iframeHash = documentHash;

								// Create History Entry
								iframe.contentWindow.document.open();
								iframe.contentWindow.document.close();

								// Update the iframe's hash
								iframe.contentWindow.document.location.hash = History.escapeHash(documentHash);
							}

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// The iFrame Hash has changed (back button caused)
						else if ( iframeHash !== lastIframeHash ) {
							//History.debug('hashchange.checker: iframe hash out of sync', 'iframeHash (new):', iframeHash, 'documentHash (old):', documentHash);

							// Equalise
							lastIframeHash = iframeHash;
							
							// If there is no iframe hash that means we're at the original
							// iframe state.
							// And if there was a hash on the original request, the original
							// iframe state was replaced instantly, so skip this state and take
							// the user back to where they came from.
							if (startedWithHash && iframeHash === '') {
								History.back();
							}
							else {
								// Update the Hash
								History.setHash(iframeHash,false);
							}
						}

						// Reset Running
						checkerRunning = false;

						// Return true
						return true;
					};
				}
				else {
					// We are not IE
					// Firefox 1 or 2, Opera

					// Define the checker function
					History.checkerFunction = function(){
						// Prepare
						var documentHash = History.getHash()||'';

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// Return true
						return true;
					};
				}

				// Apply the checker function
				History.intervalList.push(setInterval(History.checkerFunction, History.options.hashChangeInterval));

				// Done
				return true;
			}; // History.hashChangeInit

			// Bind hashChangeInit
			History.Adapter.onDomLoad(History.hashChangeInit);

		} // History.emulated.hashChange


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * We must emulate the HTML5 State Management by using HTML4 HashChange
			 */

			/**
			 * History.onHashChange(event)
			 * Trigger HTML5's window.onpopstate via HTML4 HashChange Support
			 */
			History.onHashChange = function(event){
				//History.debug('History.onHashChange', arguments);

				// Prepare
				var currentUrl = ((event && event.newURL) || History.getLocationHref()),
					currentHash = History.getHashByUrl(currentUrl),
					currentState = null,
					currentStateHash = null,
					currentStateHashExits = null,
					discardObject;

				// Check if we are the same state
				if ( History.isLastHash(currentHash) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onHashChange: no change');
					History.busy(false);
					return false;
				}

				// Reset the double check
				History.doubleCheckComplete();

				// Store our location for use in detecting back/forward direction
				History.saveHash(currentHash);

				// Expand Hash
				if ( currentHash && History.isTraditionalAnchor(currentHash) ) {
					//History.debug('History.onHashChange: traditional anchor', currentHash);
					// Traditional Anchor Hash
					History.Adapter.trigger(window,'anchorchange');
					History.busy(false);
					return false;
				}

				// Create State
				currentState = History.extractState(History.getFullUrl(currentHash||History.getLocationHref()),true);

				// Check if we are the same state
				if ( History.isLastSavedState(currentState) ) {
					//History.debug('History.onHashChange: no change');
					// There has been no change (just the page's hash has finally propagated)
					History.busy(false);
					return false;
				}

				// Create the state Hash
				currentStateHash = History.getHashByState(currentState);

				// Check if we are DiscardedState
				discardObject = History.discardedState(currentState);
				if ( discardObject ) {
					// Ignore this state as it has been discarded and go back to the state before it
					if ( History.getHashByIndex(-2) === History.getHashByState(discardObject.forwardState) ) {
						// We are going backwards
						//History.debug('History.onHashChange: go backwards');
						History.back(false);
					} else {
						// We are going forwards
						//History.debug('History.onHashChange: go forwards');
						History.forward(false);
					}
					return false;
				}

				// Push the new HTML5 State
				//History.debug('History.onHashChange: success hashchange');
				History.pushState(currentState.data,currentState.title,encodeURI(currentState.url),false);

				// End onHashChange closure
				return true;
			};
			History.Adapter.bind(window,'hashchange',History.onHashChange);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// We assume that the URL passed in is URI-encoded, but this makes
				// sure that it's fully URI encoded; any '%'s that are encoded are
				// converted back into '%'s
				url = encodeURI(url).replace(/%25/g, "%");

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Object
				var newState = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					html4Hash = History.getHash(),
					wasExpected = History.expectedStateId == newState.id;

				// Store the newState
				History.storeState(newState);
				History.expectedStateId = newState.id;

				// Recycle the State
				History.recycleState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Check if we are the same State
				if ( newStateHash === oldStateHash ) {
					//History.debug('History.pushState: no change', newStateHash);
					History.busy(false);
					return false;
				}

				// Update HTML5 State
				History.saveState(newState);

				// Fire HTML5 Event
				if(!wasExpected)
					History.Adapter.trigger(window,'statechange');

				// Update HTML4 Hash
				if ( !History.isHashEqual(newStateHash, html4Hash) && !History.isHashEqual(newStateHash, History.getShortUrl(History.getLocationHref())) ) {
					History.setHash(newStateHash,false);
				}
				
				History.busy(false);

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// We assume that the URL passed in is URI-encoded, but this makes
				// sure that it's fully URI encoded; any '%'s that are encoded are
				// converted back into '%'s
				url = encodeURI(url).replace(/%25/g, "%");

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Objects
				var newState        = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState        = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					previousState   = History.getStateByIndex(-2);

				// Discard Old State
				History.discardState(oldState,newState,previousState);

				// If the url hasn't changed, just store and save the state
				// and fire a statechange event to be consistent with the
				// html 5 api
				if ( newStateHash === oldStateHash ) {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;
	
					// Recycle the State
					History.recycleState(newState);
	
					// Force update of the title
					History.setTitle(newState);
					
					// Update HTML5 State
					History.saveState(newState);

					// Fire HTML5 Event
					//History.debug('History.pushState: trigger popstate');
					History.Adapter.trigger(window,'statechange');
					History.busy(false);
				}
				else {
					// Alias to PushState
					History.pushState(newState.data,newState.title,newState.url,false);
				}

				// End replaceState closure
				return true;
			};

		} // History.emulated.pushState



		// ====================================================================
		// Initialise

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/**
			 * Ensure initial state is handled correctly
			 */
			if ( History.getHash() && !History.emulated.hashChange ) {
				History.Adapter.onDomLoad(function(){
					History.Adapter.trigger(window,'hashchange');
				});
			}

		} // History.emulated.pushState

	}; // History.initHtml4

	// Try to Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);
/**
 * History.js Core
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		console = window.console||undefined, // Prevent a JSLint complain
		document = window.document, // Make sure we are using the correct document
		navigator = window.navigator, // Make sure we are using the correct navigator
		sessionStorage = false, // sessionStorage
		setTimeout = window.setTimeout,
		clearTimeout = window.clearTimeout,
		setInterval = window.setInterval,
		clearInterval = window.clearInterval,
		JSON = window.JSON,
		alert = window.alert,
		History = window.History = window.History||{}, // Public History Object
		history = window.history; // Old History Object

	try {
		sessionStorage = window.sessionStorage; // This will throw an exception in some browsers when cookies/localStorage are explicitly disabled (i.e. Chrome)
		sessionStorage.setItem('TEST', '1');
		sessionStorage.removeItem('TEST');
	} catch(e) {
		sessionStorage = false;
	}

	// MooTools Compatibility
	JSON.stringify = JSON.stringify||JSON.encode;
	JSON.parse = JSON.parse||JSON.decode;

	// Check Existence
	if ( typeof History.init !== 'undefined' ) {
		throw new Error('History.js Core has already been loaded...');
	}

	// Initialise History
	History.init = function(options){
		// Check Load Status of Adapter
		if ( typeof History.Adapter === 'undefined' ) {
			return false;
		}

		// Check Load Status of Core
		if ( typeof History.initCore !== 'undefined' ) {
			History.initCore();
		}

		// Check Load Status of HTML4 Support
		if ( typeof History.initHtml4 !== 'undefined' ) {
			History.initHtml4();
		}

		// Return true
		return true;
	};


	// ========================================================================
	// Initialise Core

	// Initialise Core
	History.initCore = function(options){
		// Initialise
		if ( typeof History.initCore.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initCore.initialized = true;
		}


		// ====================================================================
		// Options

		/**
		 * History.options
		 * Configurable options
		 */
		History.options = History.options||{};

		/**
		 * History.options.hashChangeInterval
		 * How long should the interval be before hashchange checks
		 */
		History.options.hashChangeInterval = History.options.hashChangeInterval || 100;

		/**
		 * History.options.safariPollInterval
		 * How long should the interval be before safari poll checks
		 */
		History.options.safariPollInterval = History.options.safariPollInterval || 500;

		/**
		 * History.options.doubleCheckInterval
		 * How long should the interval be before we perform a double check
		 */
		History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;

		/**
		 * History.options.disableSuid
		 * Force History not to append suid
		 */
		History.options.disableSuid = History.options.disableSuid || false;

		/**
		 * History.options.storeInterval
		 * How long should we wait between store calls
		 */
		History.options.storeInterval = History.options.storeInterval || 1000;

		/**
		 * History.options.busyDelay
		 * How long should we wait between busy events
		 */
		History.options.busyDelay = History.options.busyDelay || 250;

		/**
		 * History.options.debug
		 * If true will enable debug messages to be logged
		 */
		History.options.debug = History.options.debug || false;

		/**
		 * History.options.initialTitle
		 * What is the title of the initial state
		 */
		History.options.initialTitle = History.options.initialTitle || document.title;

		/**
		 * History.options.html4Mode
		 * If true, will force HTMl4 mode (hashtags)
		 */
		History.options.html4Mode = History.options.html4Mode || false;

		/**
		 * History.options.delayInit
		 * Want to override default options and call init manually.
		 */
		History.options.delayInit = History.options.delayInit || false;


		// ====================================================================
		// Interval record

		/**
		 * History.intervalList
		 * List of intervals set, to be cleared when document is unloaded.
		 */
		History.intervalList = [];

		/**
		 * History.clearAllIntervals
		 * Clears all setInterval instances.
		 */
		History.clearAllIntervals = function(){
			var i, il = History.intervalList;
			if (typeof il !== "undefined" && il !== null) {
				for (i = 0; i < il.length; i++) {
					clearInterval(il[i]);
				}
				History.intervalList = null;
			}
		};


		// ====================================================================
		// Debug

		/**
		 * History.debug(message,...)
		 * Logs the passed arguments if debug enabled
		 */
		History.debug = function(){
			if ( (History.options.debug||false) ) {
				History.log.apply(History,arguments);
			}
		};

		/**
		 * History.log(message,...)
		 * Logs the passed arguments
		 */
		History.log = function(){
			// Prepare
			var
				consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
				textarea = document.getElementById('log'),
				message,
				i,n,
				args,arg
				;

			// Write to Console
			if ( consoleExists ) {
				args = Array.prototype.slice.call(arguments);
				message = args.shift();
				if ( typeof console.debug !== 'undefined' ) {
					console.debug.apply(console,[message,args]);
				}
				else {
					console.log.apply(console,[message,args]);
				}
			}
			else {
				message = ("\n"+arguments[0]+"\n");
			}

			// Write to log
			for ( i=1,n=arguments.length; i<n; ++i ) {
				arg = arguments[i];
				if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
					try {
						arg = JSON.stringify(arg);
					}
					catch ( Exception ) {
						// Recursive Object
					}
				}
				message += "\n"+arg+"\n";
			}

			// Textarea
			if ( textarea ) {
				textarea.value += message+"\n-----\n";
				textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
			}
			// No Textarea, No Console
			else if ( !consoleExists ) {
				alert(message);
			}

			// Return true
			return true;
		};


		// ====================================================================
		// Emulated Status

		/**
		 * History.getInternetExplorerMajorVersion()
		 * Get's the major version of Internet Explorer
		 * @return {integer}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 * @author James Padolsey <https://gist.github.com/527683>
		 */
		History.getInternetExplorerMajorVersion = function(){
			var result = History.getInternetExplorerMajorVersion.cached =
					(typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
				?	History.getInternetExplorerMajorVersion.cached
				:	(function(){
						var v = 3,
								div = document.createElement('div'),
								all = div.getElementsByTagName('i');
						while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
						return (v > 4) ? v : false;
					})()
				;
			return result;
		};

		/**
		 * History.isInternetExplorer()
		 * Are we using Internet Explorer?
		 * @return {boolean}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 */
		History.isInternetExplorer = function(){
			var result =
				History.isInternetExplorer.cached =
				(typeof History.isInternetExplorer.cached !== 'undefined')
					?	History.isInternetExplorer.cached
					:	Boolean(History.getInternetExplorerMajorVersion())
				;
			return result;
		};

		/**
		 * History.emulated
		 * Which features require emulating?
		 */

		if (History.options.html4Mode) {
			History.emulated = {
				pushState : true,
				hashChange: true
			};
		}

		else {

			History.emulated = {
				pushState: !Boolean(
					window.history && window.history.pushState && window.history.replaceState
					&& !(
						(/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
						|| (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
					)
				),
				hashChange: Boolean(
					!(('onhashchange' in window) || ('onhashchange' in document))
					||
					(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
				)
			};
		}

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = !History.emulated.pushState;

		/**
		 * History.bugs
		 * Which bugs are present
		 */
		History.bugs = {
			/**
			 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
			 * https://bugs.webkit.org/show_bug.cgi?id=56249
			 */
			setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
			 * https://bugs.webkit.org/show_bug.cgi?id=42940
			 */
			safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
			 */
			ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),

			/**
			 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
			 */
			hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
		};

		/**
		 * History.isEmptyObject(obj)
		 * Checks to see if the Object is Empty
		 * @param {Object} obj
		 * @return {boolean}
		 */
		History.isEmptyObject = function(obj) {
			for ( var name in obj ) {
				if ( obj.hasOwnProperty(name) ) {
					return false;
				}
			}
			return true;
		};

		/**
		 * History.cloneObject(obj)
		 * Clones a object and eliminate all references to the original contexts
		 * @param {Object} obj
		 * @return {Object}
		 */
		History.cloneObject = function(obj) {
			var hash,newObj;
			if ( obj ) {
				hash = JSON.stringify(obj);
				newObj = JSON.parse(hash);
			}
			else {
				newObj = {};
			}
			return newObj;
		};


		// ====================================================================
		// URL Helpers

		/**
		 * History.getRootUrl()
		 * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
		 * @return {String} rootUrl
		 */
		History.getRootUrl = function(){
			// Create
			var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
			if ( document.location.port||false ) {
				rootUrl += ':'+document.location.port;
			}
			rootUrl += '/';

			// Return
			return rootUrl;
		};

		/**
		 * History.getBaseHref()
		 * Fetches the `href` attribute of the `<base href="...">` element if it exists
		 * @return {String} baseHref
		 */
		History.getBaseHref = function(){
			// Create
			var
				baseElements = document.getElementsByTagName('base'),
				baseElement = null,
				baseHref = '';

			// Test for Base Element
			if ( baseElements.length === 1 ) {
				// Prepare for Base Element
				baseElement = baseElements[0];
				baseHref = baseElement.href.replace(/[^\/]+$/,'');
			}

			// Adjust trailing slash
			baseHref = baseHref.replace(/\/+$/,'');
			if ( baseHref ) baseHref += '/';

			// Return
			return baseHref;
		};

		/**
		 * History.getBaseUrl()
		 * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
		 * @return {String} baseUrl
		 */
		History.getBaseUrl = function(){
			// Create
			var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();

			// Return
			return baseUrl;
		};

		/**
		 * History.getPageUrl()
		 * Fetches the URL of the current page
		 * @return {String} pageUrl
		 */
		History.getPageUrl = function(){
			// Fetch
			var
				State = History.getState(false,false),
				stateUrl = (State||{}).url||History.getLocationHref(),
				pageUrl;

			// Create
			pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/\./).test(part) ? part : part+'/';
			});

			// Return
			return pageUrl;
		};

		/**
		 * History.getBasePageUrl()
		 * Fetches the Url of the directory of the current page
		 * @return {String} basePageUrl
		 */
		History.getBasePageUrl = function(){
			// Create
			var basePageUrl = (History.getLocationHref()).replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/[^\/]$/).test(part) ? '' : part;
			}).replace(/\/+$/,'')+'/';

			// Return
			return basePageUrl;
		};

		/**
		 * History.getFullUrl(url)
		 * Ensures that we have an absolute URL and not a relative URL
		 * @param {string} url
		 * @param {Boolean} allowBaseHref
		 * @return {string} fullUrl
		 */
		History.getFullUrl = function(url,allowBaseHref){
			// Prepare
			var fullUrl = url, firstChar = url.substring(0,1);
			allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;

			// Check
			if ( /[a-z]+\:\/\//.test(url) ) {
				// Full URL
			}
			else if ( firstChar === '/' ) {
				// Root URL
				fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
			}
			else if ( firstChar === '#' ) {
				// Anchor URL
				fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
			}
			else if ( firstChar === '?' ) {
				// Query URL
				fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
			}
			else {
				// Relative URL
				if ( allowBaseHref ) {
					fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
				} else {
					fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
				}
				// We have an if condition above as we do not want hashes
				// which are relative to the baseHref in our URLs
				// as if the baseHref changes, then all our bookmarks
				// would now point to different locations
				// whereas the basePageUrl will always stay the same
			}

			// Return
			return fullUrl.replace(/\#$/,'');
		};

		/**
		 * History.getShortUrl(url)
		 * Ensures that we have a relative URL and not a absolute URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getShortUrl = function(url){
			// Prepare
			var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();

			// Trim baseUrl
			if ( History.emulated.pushState ) {
				// We are in a if statement as when pushState is not emulated
				// The actual url these short urls are relative to can change
				// So within the same session, we the url may end up somewhere different
				shortUrl = shortUrl.replace(baseUrl,'');
			}

			// Trim rootUrl
			shortUrl = shortUrl.replace(rootUrl,'/');

			// Ensure we can still detect it as a state
			if ( History.isTraditionalAnchor(shortUrl) ) {
				shortUrl = './'+shortUrl;
			}

			// Clean It
			shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');

			// Return
			return shortUrl;
		};

		/**
		 * History.getLocationHref(document)
		 * Returns a normalized version of document.location.href
		 * accounting for browser inconsistencies, etc.
		 *
		 * This URL will be URI-encoded and will include the hash
		 *
		 * @param {object} document
		 * @return {string} url
		 */
		History.getLocationHref = function(doc) {
			doc = doc || document;

			// most of the time, this will be true
			if (doc.URL === doc.location.href)
				return doc.location.href;

			// some versions of webkit URI-decode document.location.href
			// but they leave document.URL in an encoded state
			if (doc.location.href === decodeURIComponent(doc.URL))
				return doc.URL;

			// FF 3.6 only updates document.URL when a page is reloaded
			// document.location.href is updated correctly
			if (doc.location.hash && decodeURIComponent(doc.location.href.replace(/^[^#]+/, "")) === doc.location.hash)
				return doc.location.href;

			if (doc.URL.indexOf('#') == -1 && doc.location.href.indexOf('#') != -1)
				return doc.location.href;
			
			return doc.URL || doc.location.href;
		};


		// ====================================================================
		// State Storage

		/**
		 * History.store
		 * The store for all session specific data
		 */
		History.store = {};

		/**
		 * History.idToState
		 * 1-1: State ID to State Object
		 */
		History.idToState = History.idToState||{};

		/**
		 * History.stateToId
		 * 1-1: State String to State ID
		 */
		History.stateToId = History.stateToId||{};

		/**
		 * History.urlToId
		 * 1-1: State URL to State ID
		 */
		History.urlToId = History.urlToId||{};

		/**
		 * History.storedStates
		 * Store the states in an array
		 */
		History.storedStates = History.storedStates||[];

		/**
		 * History.savedStates
		 * Saved the states in an array
		 */
		History.savedStates = History.savedStates||[];

		/**
		 * History.noramlizeStore()
		 * Noramlize the store by adding necessary values
		 */
		History.normalizeStore = function(){
			History.store.idToState = History.store.idToState||{};
			History.store.urlToId = History.store.urlToId||{};
			History.store.stateToId = History.store.stateToId||{};
		};

		/**
		 * History.getState()
		 * Get an object containing the data, title and url of the current state
		 * @param {Boolean} friendly
		 * @param {Boolean} create
		 * @return {Object} State
		 */
		History.getState = function(friendly,create){
			// Prepare
			if ( typeof friendly === 'undefined' ) { friendly = true; }
			if ( typeof create === 'undefined' ) { create = true; }

			// Fetch
			var State = History.getLastSavedState();

			// Create
			if ( !State && create ) {
				State = History.createStateObject();
			}

			// Adjust
			if ( friendly ) {
				State = History.cloneObject(State);
				State.url = State.cleanUrl||State.url;
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByState(State)
		 * Gets a ID for a State
		 * @param {State} newState
		 * @return {String} id
		 */
		History.getIdByState = function(newState){

			// Fetch ID
			var id = History.extractId(newState.url),
				str;

			if ( !id ) {
				// Find ID via State String
				str = History.getStateString(newState);
				if ( typeof History.stateToId[str] !== 'undefined' ) {
					id = History.stateToId[str];
				}
				else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
					id = History.store.stateToId[str];
				}
				else {
					// Generate a new ID
					while ( true ) {
						id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
						if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
							break;
						}
					}

					// Apply the new State to the ID
					History.stateToId[str] = id;
					History.idToState[id] = newState;
				}
			}

			// Return ID
			return id;
		};

		/**
		 * History.normalizeState(State)
		 * Expands a State Object
		 * @param {object} State
		 * @return {object}
		 */
		History.normalizeState = function(oldState){
			// Variables
			var newState, dataNotEmpty;

			// Prepare
			if ( !oldState || (typeof oldState !== 'object') ) {
				oldState = {};
			}

			// Check
			if ( typeof oldState.normalized !== 'undefined' ) {
				return oldState;
			}

			// Adjust
			if ( !oldState.data || (typeof oldState.data !== 'object') ) {
				oldState.data = {};
			}

			// ----------------------------------------------------------------

			// Create
			newState = {};
			newState.normalized = true;
			newState.title = oldState.title||'';
			newState.url = History.getFullUrl(oldState.url?oldState.url:(History.getLocationHref()));
			newState.hash = History.getShortUrl(newState.url);
			newState.data = History.cloneObject(oldState.data);

			// Fetch ID
			newState.id = History.getIdByState(newState);

			// ----------------------------------------------------------------

			// Clean the URL
			newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
			newState.url = newState.cleanUrl;

			// Check to see if we have more than just a url
			dataNotEmpty = !History.isEmptyObject(newState.data);

			// Apply
			if ( (newState.title || dataNotEmpty) && History.options.disableSuid !== true ) {
				// Add ID to Hash
				newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
				if ( !/\?/.test(newState.hash) ) {
					newState.hash += '?';
				}
				newState.hash += '&_suid='+newState.id;
			}

			// Create the Hashed URL
			newState.hashedUrl = History.getFullUrl(newState.hash);

			// ----------------------------------------------------------------

			// Update the URL if we have a duplicate
			if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
				newState.url = newState.hashedUrl;
			}

			// ----------------------------------------------------------------

			// Return
			return newState;
		};

		/**
		 * History.createStateObject(data,title,url)
		 * Creates a object based on the data, title and url state params
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {object}
		 */
		History.createStateObject = function(data,title,url){
			// Hashify
			var State = {
				'data': data,
				'title': title,
				'url': url
			};

			// Expand the State
			State = History.normalizeState(State);

			// Return object
			return State;
		};

		/**
		 * History.getStateById(id)
		 * Get a state by it's UID
		 * @param {String} id
		 */
		History.getStateById = function(id){
			// Prepare
			id = String(id);

			// Retrieve
			var State = History.idToState[id] || History.store.idToState[id] || undefined;

			// Return State
			return State;
		};

		/**
		 * Get a State's String
		 * @param {State} passedState
		 */
		History.getStateString = function(passedState){
			// Prepare
			var State, cleanedState, str;

			// Fetch
			State = History.normalizeState(passedState);

			// Clean
			cleanedState = {
				data: State.data,
				title: passedState.title,
				url: passedState.url
			};

			// Fetch
			str = JSON.stringify(cleanedState);

			// Return
			return str;
		};

		/**
		 * Get a State's ID
		 * @param {State} passedState
		 * @return {String} id
		 */
		History.getStateId = function(passedState){
			// Prepare
			var State, id;

			// Fetch
			State = History.normalizeState(passedState);

			// Fetch
			id = State.id;

			// Return
			return id;
		};

		/**
		 * History.getHashByState(State)
		 * Creates a Hash for the State Object
		 * @param {State} passedState
		 * @return {String} hash
		 */
		History.getHashByState = function(passedState){
			// Prepare
			var State, hash;

			// Fetch
			State = History.normalizeState(passedState);

			// Hash
			hash = State.hash;

			// Return
			return hash;
		};

		/**
		 * History.extractId(url_or_hash)
		 * Get a State ID by it's URL or Hash
		 * @param {string} url_or_hash
		 * @return {string} id
		 */
		History.extractId = function ( url_or_hash ) {
			// Prepare
			var id,parts,url, tmp;

			// Extract
			
			// If the URL has a #, use the id from before the #
			if (url_or_hash.indexOf('#') != -1)
			{
				tmp = url_or_hash.split("#")[0];
			}
			else
			{
				tmp = url_or_hash;
			}
			
			parts = /(.*)\&_suid=([0-9]+)$/.exec(tmp);
			url = parts ? (parts[1]||url_or_hash) : url_or_hash;
			id = parts ? String(parts[2]||'') : '';

			// Return
			return id||false;
		};

		/**
		 * History.isTraditionalAnchor
		 * Checks to see if the url is a traditional anchor or not
		 * @param {String} url_or_hash
		 * @return {Boolean}
		 */
		History.isTraditionalAnchor = function(url_or_hash){
			// Check
			var isTraditional = !(/[\/\?\.]/.test(url_or_hash));

			// Return
			return isTraditional;
		};

		/**
		 * History.extractState
		 * Get a State by it's URL or Hash
		 * @param {String} url_or_hash
		 * @return {State|null}
		 */
		History.extractState = function(url_or_hash,create){
			// Prepare
			var State = null, id, url;
			create = create||false;

			// Fetch SUID
			id = History.extractId(url_or_hash);
			if ( id ) {
				State = History.getStateById(id);
			}

			// Fetch SUID returned no State
			if ( !State ) {
				// Fetch URL
				url = History.getFullUrl(url_or_hash);

				// Check URL
				id = History.getIdByUrl(url)||false;
				if ( id ) {
					State = History.getStateById(id);
				}

				// Create State
				if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
					State = History.createStateObject(null,null,url);
				}
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByUrl()
		 * Get a State ID by a State URL
		 */
		History.getIdByUrl = function(url){
			// Fetch
			var id = History.urlToId[url] || History.store.urlToId[url] || undefined;

			// Return
			return id;
		};

		/**
		 * History.getLastSavedState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastSavedState = function(){
			return History.savedStates[History.savedStates.length-1]||undefined;
		};

		/**
		 * History.getLastStoredState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastStoredState = function(){
			return History.storedStates[History.storedStates.length-1]||undefined;
		};

		/**
		 * History.hasUrlDuplicate
		 * Checks if a Url will have a url conflict
		 * @param {Object} newState
		 * @return {Boolean} hasDuplicate
		 */
		History.hasUrlDuplicate = function(newState) {
			// Prepare
			var hasDuplicate = false,
				oldState;

			// Fetch
			oldState = History.extractState(newState.url);

			// Check
			hasDuplicate = oldState && oldState.id !== newState.id;

			// Return
			return hasDuplicate;
		};

		/**
		 * History.storeState
		 * Store a State
		 * @param {Object} newState
		 * @return {Object} newState
		 */
		History.storeState = function(newState){
			// Store the State
			History.urlToId[newState.url] = newState.id;

			// Push the State
			History.storedStates.push(History.cloneObject(newState));

			// Return newState
			return newState;
		};

		/**
		 * History.isLastSavedState(newState)
		 * Tests to see if the state is the last state
		 * @param {Object} newState
		 * @return {boolean} isLast
		 */
		History.isLastSavedState = function(newState){
			// Prepare
			var isLast = false,
				newId, oldState, oldId;

			// Check
			if ( History.savedStates.length ) {
				newId = newState.id;
				oldState = History.getLastSavedState();
				oldId = oldState.id;

				// Check
				isLast = (newId === oldId);
			}

			// Return
			return isLast;
		};

		/**
		 * History.saveState
		 * Push a State
		 * @param {Object} newState
		 * @return {boolean} changed
		 */
		History.saveState = function(newState){
			// Check Hash
			if ( History.isLastSavedState(newState) ) {
				return false;
			}

			// Push the State
			History.savedStates.push(History.cloneObject(newState));

			// Return true
			return true;
		};

		/**
		 * History.getStateByIndex()
		 * Gets a state by the index
		 * @param {integer} index
		 * @return {Object}
		 */
		History.getStateByIndex = function(index){
			// Prepare
			var State = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				State = History.savedStates[History.savedStates.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				State = History.savedStates[History.savedStates.length+index];
			}
			else {
				// Get from the beginning
				State = History.savedStates[index];
			}

			// Return State
			return State;
		};
		
		/**
		 * History.getCurrentIndex()
		 * Gets the current index
		 * @return (integer)
		*/
		History.getCurrentIndex = function(){
			// Prepare
			var index = null;
			
			// No states saved
			if(History.savedStates.length < 1) {
				index = 0;
			}
			else {
				index = History.savedStates.length-1;
			}
			return index;
		};

		// ====================================================================
		// Hash Helpers

		/**
		 * History.getHash()
		 * @param {Location=} location
		 * Gets the current document hash
		 * Note: unlike location.hash, this is guaranteed to return the escaped hash in all browsers
		 * @return {string}
		 */
		History.getHash = function(doc){
			var url = History.getLocationHref(doc),
				hash;
			hash = History.getHashByUrl(url);
			return hash;
		};

		/**
		 * History.unescapeHash()
		 * normalize and Unescape a Hash
		 * @param {String} hash
		 * @return {string}
		 */
		History.unescapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Unescape hash
			result = decodeURIComponent(result);

			// Return result
			return result;
		};

		/**
		 * History.normalizeHash()
		 * normalize a hash across browsers
		 * @return {string}
		 */
		History.normalizeHash = function(hash){
			// Prepare
			var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');

			// Return result
			return result;
		};

		/**
		 * History.setHash(hash)
		 * Sets the document hash
		 * @param {string} hash
		 * @return {History}
		 */
		History.setHash = function(hash,queue){
			// Prepare
			var State, pageUrl;

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.setHash: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.setHash,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Log
			//History.debug('History.setHash: called',hash);

			// Make Busy + Continue
			History.busy(true);

			// Check if hash is a state
			State = History.extractState(hash,true);
			if ( State && !History.emulated.pushState ) {
				// Hash is a state so skip the setHash
				//History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);

				// PushState
				History.pushState(State.data,State.title,State.url,false);
			}
			else if ( History.getHash() !== hash ) {
				// Hash is a proper hash, so apply it

				// Handle browser bugs
				if ( History.bugs.setHash ) {
					// Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249

					// Fetch the base page
					pageUrl = History.getPageUrl();

					// Safari hash apply
					History.pushState(null,null,pageUrl+'#'+hash,false);
				}
				else {
					// Normal hash apply
					document.location.hash = hash;
				}
			}

			// Chain
			return History;
		};

		/**
		 * History.escape()
		 * normalize and Escape a Hash
		 * @return {string}
		 */
		History.escapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Escape hash
			result = window.encodeURIComponent(result);

			// IE6 Escape Bug
			if ( !History.bugs.hashEscape ) {
				// Restore common parts
				result = result
					.replace(/\%21/g,'!')
					.replace(/\%26/g,'&')
					.replace(/\%3D/g,'=')
					.replace(/\%3F/g,'?');
			}

			// Return result
			return result;
		};

		/**
		 * History.getHashByUrl(url)
		 * Extracts the Hash from a URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getHashByUrl = function(url){
			// Extract the hash
			var hash = String(url)
				.replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
				;

			// Unescape hash
			hash = History.unescapeHash(hash);

			// Return hash
			return hash;
		};

		/**
		 * History.setTitle(title)
		 * Applies the title to the document
		 * @param {State} newState
		 * @return {Boolean}
		 */
		History.setTitle = function(newState){
			// Prepare
			var title = newState.title,
				firstState;

			// Initial
			if ( !title ) {
				firstState = History.getStateByIndex(0);
				if ( firstState && firstState.url === newState.url ) {
					title = firstState.title||History.options.initialTitle;
				}
			}

			// Apply
			try {
				document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
			}
			catch ( Exception ) { }
			document.title = title;

			// Chain
			return History;
		};


		// ====================================================================
		// Queueing

		/**
		 * History.queues
		 * The list of queues to use
		 * First In, First Out
		 */
		History.queues = [];

		/**
		 * History.busy(value)
		 * @param {boolean} value [optional]
		 * @return {boolean} busy
		 */
		History.busy = function(value){
			// Apply
			if ( typeof value !== 'undefined' ) {
				//History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
				History.busy.flag = value;
			}
			// Default
			else if ( typeof History.busy.flag === 'undefined' ) {
				History.busy.flag = false;
			}

			// Queue
			if ( !History.busy.flag ) {
				// Execute the next item in the queue
				clearTimeout(History.busy.timeout);
				var fireNext = function(){
					var i, queue, item;
					if ( History.busy.flag ) return;
					for ( i=History.queues.length-1; i >= 0; --i ) {
						queue = History.queues[i];
						if ( queue.length === 0 ) continue;
						item = queue.shift();
						History.fireQueueItem(item);
						History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
					}
				};
				History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
			}

			// Return
			return History.busy.flag;
		};

		/**
		 * History.busy.flag
		 */
		History.busy.flag = false;

		/**
		 * History.fireQueueItem(item)
		 * Fire a Queue Item
		 * @param {Object} item
		 * @return {Mixed} result
		 */
		History.fireQueueItem = function(item){
			return item.callback.apply(item.scope||History,item.args||[]);
		};

		/**
		 * History.pushQueue(callback,args)
		 * Add an item to the queue
		 * @param {Object} item [scope,callback,args,queue]
		 */
		History.pushQueue = function(item){
			// Prepare the queue
			History.queues[item.queue||0] = History.queues[item.queue||0]||[];

			// Add to the queue
			History.queues[item.queue||0].push(item);

			// Chain
			return History;
		};

		/**
		 * History.queue (item,queue), (func,queue), (func), (item)
		 * Either firs the item now if not busy, or adds it to the queue
		 */
		History.queue = function(item,queue){
			// Prepare
			if ( typeof item === 'function' ) {
				item = {
					callback: item
				};
			}
			if ( typeof queue !== 'undefined' ) {
				item.queue = queue;
			}

			// Handle
			if ( History.busy() ) {
				History.pushQueue(item);
			} else {
				History.fireQueueItem(item);
			}

			// Chain
			return History;
		};

		/**
		 * History.clearQueue()
		 * Clears the Queue
		 */
		History.clearQueue = function(){
			History.busy.flag = false;
			History.queues = [];
			return History;
		};


		// ====================================================================
		// IE Bug Fix

		/**
		 * History.stateChanged
		 * States whether or not the state has changed since the last double check was initialised
		 */
		History.stateChanged = false;

		/**
		 * History.doubleChecker
		 * Contains the timeout used for the double checks
		 */
		History.doubleChecker = false;

		/**
		 * History.doubleCheckComplete()
		 * Complete a double check
		 * @return {History}
		 */
		History.doubleCheckComplete = function(){
			// Update
			History.stateChanged = true;

			// Clear
			History.doubleCheckClear();

			// Chain
			return History;
		};

		/**
		 * History.doubleCheckClear()
		 * Clear a double check
		 * @return {History}
		 */
		History.doubleCheckClear = function(){
			// Clear
			if ( History.doubleChecker ) {
				clearTimeout(History.doubleChecker);
				History.doubleChecker = false;
			}

			// Chain
			return History;
		};

		/**
		 * History.doubleCheck()
		 * Create a double check
		 * @return {History}
		 */
		History.doubleCheck = function(tryAgain){
			// Reset
			History.stateChanged = false;
			History.doubleCheckClear();

			// Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
			// Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
			if ( History.bugs.ieDoubleCheck ) {
				// Apply Check
				History.doubleChecker = setTimeout(
					function(){
						History.doubleCheckClear();
						if ( !History.stateChanged ) {
							//History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
							// Re-Attempt
							tryAgain();
						}
						return true;
					},
					History.options.doubleCheckInterval
				);
			}

			// Chain
			return History;
		};


		// ====================================================================
		// Safari Bug Fix

		/**
		 * History.safariStatePoll()
		 * Poll the current state
		 * @return {History}
		 */
		History.safariStatePoll = function(){
			// Poll the URL

			// Get the Last State which has the new URL
			var
				urlState = History.extractState(History.getLocationHref()),
				newState;

			// Check for a difference
			if ( !History.isLastSavedState(urlState) ) {
				newState = urlState;
			}
			else {
				return;
			}

			// Check if we have a state with that url
			// If not create it
			if ( !newState ) {
				//History.debug('History.safariStatePoll: new');
				newState = History.createStateObject();
			}

			// Apply the New State
			//History.debug('History.safariStatePoll: trigger');
			History.Adapter.trigger(window,'popstate');

			// Chain
			return History;
		};


		// ====================================================================
		// State Aliases

		/**
		 * History.back(queue)
		 * Send the browser history back one item
		 * @param {Integer} queue [optional]
		 */
		History.back = function(queue){
			//History.debug('History.back: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.back: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.back,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.back(false);
			});

			// Go back
			history.go(-1);

			// End back closure
			return true;
		};

		/**
		 * History.forward(queue)
		 * Send the browser history forward one item
		 * @param {Integer} queue [optional]
		 */
		History.forward = function(queue){
			//History.debug('History.forward: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.forward: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.forward,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.forward(false);
			});

			// Go forward
			history.go(1);

			// End forward closure
			return true;
		};

		/**
		 * History.go(index,queue)
		 * Send the browser history back or forward index times
		 * @param {Integer} queue [optional]
		 */
		History.go = function(index,queue){
			//History.debug('History.go: called', arguments);

			// Prepare
			var i;

			// Handle
			if ( index > 0 ) {
				// Forward
				for ( i=1; i<=index; ++i ) {
					History.forward(queue);
				}
			}
			else if ( index < 0 ) {
				// Backward
				for ( i=-1; i>=index; --i ) {
					History.back(queue);
				}
			}
			else {
				throw new Error('History.go: History.go requires a positive or negative integer passed.');
			}

			// Chain
			return History;
		};


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * Provide Skeleton for HTML4 Browsers
			 */

			// Prepare
			var emptyFunction = function(){};
			History.pushState = History.pushState||emptyFunction;
			History.replaceState = History.replaceState||emptyFunction;
		} // History.emulated.pushState

		// Native pushState Implementation
		else {
			/*
			 * Use native HTML5 History API Implementation
			 */

			/**
			 * History.onPopState(event,extra)
			 * Refresh the Current State
			 */
			History.onPopState = function(event,extra){
				// Prepare
				var stateId = false, newState = false, currentHash, currentState;

				// Reset the double check
				History.doubleCheckComplete();

				// Check for a Hash, and handle apporiatly
				currentHash = History.getHash();
				if ( currentHash ) {
					// Expand Hash
					currentState = History.extractState(currentHash||History.getLocationHref(),true);
					if ( currentState ) {
						// We were able to parse it, it must be a State!
						// Let's forward to replaceState
						//History.debug('History.onPopState: state anchor', currentHash, currentState);
						History.replaceState(currentState.data, currentState.title, currentState.url, false);
					}
					else {
						// Traditional Anchor
						//History.debug('History.onPopState: traditional anchor', currentHash);
						History.Adapter.trigger(window,'anchorchange');
						History.busy(false);
					}

					// We don't care for hashes
					History.expectedStateId = false;
					return false;
				}

				// Ensure
				stateId = History.Adapter.extractEventData('state',event,extra) || false;

				// Fetch State
				if ( stateId ) {
					// Vanilla: Back/forward button was used
					newState = History.getStateById(stateId);
				}
				else if ( History.expectedStateId ) {
					// Vanilla: A new state was pushed, and popstate was called manually
					newState = History.getStateById(History.expectedStateId);
				}
				else {
					// Initial State
					newState = History.extractState(History.getLocationHref());
				}

				// The State did not exist in our store
				if ( !newState ) {
					// Regenerate the State
					newState = History.createStateObject(null,null,History.getLocationHref());
				}

				// Clean
				History.expectedStateId = false;

				// Check if we are the same state
				if ( History.isLastSavedState(newState) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onPopState: no change', newState, History.savedStates);
					History.busy(false);
					return false;
				}

				// Store the State
				History.storeState(newState);
				History.saveState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Fire Our Event
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// Return true
				return true;
			};
			History.Adapter.bind(window,'popstate',History.onPopState);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.pushState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.replaceState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End replaceState closure
				return true;
			};

		} // !History.emulated.pushState


		// ====================================================================
		// Initialise

		/**
		 * Load the Store
		 */
		if ( sessionStorage ) {
			// Fetch
			try {
				History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
			}
			catch ( err ) {
				History.store = {};
			}

			// Normalize
			History.normalizeStore();
		}
		else {
			// Default Load
			History.store = {};
			History.normalizeStore();
		}

		/**
		 * Clear Intervals on exit to prevent memory leaks
		 */
		History.Adapter.bind(window,"unload",History.clearAllIntervals);

		/**
		 * Create the initial State
		 */
		History.saveState(History.storeState(History.extractState(History.getLocationHref(),true)));

		/**
		 * Bind for Saving Store
		 */
		if ( sessionStorage ) {
			// When the page is closed
			History.onUnload = function(){
				// Prepare
				var	currentStore, item, currentStoreString;

				// Fetch
				try {
					currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
				}
				catch ( err ) {
					currentStore = {};
				}

				// Ensure
				currentStore.idToState = currentStore.idToState || {};
				currentStore.urlToId = currentStore.urlToId || {};
				currentStore.stateToId = currentStore.stateToId || {};

				// Sync
				for ( item in History.idToState ) {
					if ( !History.idToState.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.idToState[item] = History.idToState[item];
				}
				for ( item in History.urlToId ) {
					if ( !History.urlToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.urlToId[item] = History.urlToId[item];
				}
				for ( item in History.stateToId ) {
					if ( !History.stateToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.stateToId[item] = History.stateToId[item];
				}

				// Update
				History.store = currentStore;
				History.normalizeStore();

				// In Safari, going into Private Browsing mode causes the
				// Session Storage object to still exist but if you try and use
				// or set any property/function of it it throws the exception
				// "QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to
				// add something to storage that exceeded the quota." infinitely
				// every second.
				currentStoreString = JSON.stringify(currentStore);
				try {
					// Store
					sessionStorage.setItem('History.store', currentStoreString);
				}
				catch (e) {
					if (e.code === DOMException.QUOTA_EXCEEDED_ERR) {
						if (sessionStorage.length) {
							// Workaround for a bug seen on iPads. Sometimes the quota exceeded error comes up and simply
							// removing/resetting the storage can work.
							sessionStorage.removeItem('History.store');
							sessionStorage.setItem('History.store', currentStoreString);
						} else {
							// Otherwise, we're probably private browsing in Safari, so we'll ignore the exception.
						}
					} else {
						throw e;
					}
				}
			};

			// For Internet Explorer
			History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));

			// For Other Browsers
			History.Adapter.bind(window,'beforeunload',History.onUnload);
			History.Adapter.bind(window,'unload',History.onUnload);

			// Both are enabled for consistency
		}

		// Non-Native pushState Implementation
		if ( !History.emulated.pushState ) {
			// Be aware, the following is only for native pushState implementations
			// If you are wanting to include something for all browsers
			// Then include it above this if block

			/**
			 * Setup Safari Fix
			 */
			if ( History.bugs.safariPoll ) {
				History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
			}

			/**
			 * Ensure Cross Browser Compatibility
			 */
			if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
				/**
				 * Fix Safari HashChange Issue
				 */

				// Setup Alias
				History.Adapter.bind(window,'hashchange',function(){
					History.Adapter.trigger(window,'popstate');
				});

				// Initialise Alias
				if ( History.getHash() ) {
					History.Adapter.onDomLoad(function(){
						History.Adapter.trigger(window,'hashchange');
					});
				}
			}

		} // !History.emulated.pushState


	}; // History.initCore

	// Try to Initialise History
	if (!History.options || !History.options.delayInit) {
		History.init();
	}

})(window);


/***/ }),

/***/ "./node_modules/imagesloaded/imagesloaded.js":
/*!***************************************************!*\
  !*** ./node_modules/imagesloaded/imagesloaded.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*!
 * imagesLoaded v5.0.0
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

( function( window, factory ) {
  // universal module definition
  if (  true && module.exports ) {
    // CommonJS
    module.exports = factory( window, __webpack_require__(/*! ev-emitter */ "./node_modules/ev-emitter/ev-emitter.js") );
  } else {
    // browser global
    window.imagesLoaded = factory( window, window.EvEmitter );
  }

} )( typeof window !== 'undefined' ? window : this,
    function factory( window, EvEmitter ) {

let $ = window.jQuery;
let console = window.console;

// -------------------------- helpers -------------------------- //

// turn element or nodeList into an array
function makeArray( obj ) {
  // use object if already an array
  if ( Array.isArray( obj ) ) return obj;

  let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
  // convert nodeList to array
  if ( isArrayLike ) return [ ...obj ];

  // array of single index
  return [ obj ];
}

// -------------------------- imagesLoaded -------------------------- //

/**
 * @param {[Array, Element, NodeList, String]} elem
 * @param {[Object, Function]} options - if function, use as callback
 * @param {Function} onAlways - callback function
 * @returns {ImagesLoaded}
 */
function ImagesLoaded( elem, options, onAlways ) {
  // coerce ImagesLoaded() without new, to be new ImagesLoaded()
  if ( !( this instanceof ImagesLoaded ) ) {
    return new ImagesLoaded( elem, options, onAlways );
  }
  // use elem as selector string
  let queryElem = elem;
  if ( typeof elem == 'string' ) {
    queryElem = document.querySelectorAll( elem );
  }
  // bail if bad element
  if ( !queryElem ) {
    console.error(`Bad element for imagesLoaded ${queryElem || elem}`);
    return;
  }

  this.elements = makeArray( queryElem );
  this.options = {};
  // shift arguments if no options set
  if ( typeof options == 'function' ) {
    onAlways = options;
  } else {
    Object.assign( this.options, options );
  }

  if ( onAlways ) this.on( 'always', onAlways );

  this.getImages();
  // add jQuery Deferred object
  if ( $ ) this.jqDeferred = new $.Deferred();

  // HACK check async to allow time to bind listeners
  setTimeout( this.check.bind( this ) );
}

ImagesLoaded.prototype = Object.create( EvEmitter.prototype );

ImagesLoaded.prototype.getImages = function() {
  this.images = [];

  // filter & find items if we have an item selector
  this.elements.forEach( this.addElementImages, this );
};

const elementNodeTypes = [ 1, 9, 11 ];

/**
 * @param {Node} elem
 */
ImagesLoaded.prototype.addElementImages = function( elem ) {
  // filter siblings
  if ( elem.nodeName === 'IMG' ) {
    this.addImage( elem );
  }
  // get background image on element
  if ( this.options.background === true ) {
    this.addElementBackgroundImages( elem );
  }

  // find children
  // no non-element nodes, #143
  let { nodeType } = elem;
  if ( !nodeType || !elementNodeTypes.includes( nodeType ) ) return;

  let childImgs = elem.querySelectorAll('img');
  // concat childElems to filterFound array
  for ( let img of childImgs ) {
    this.addImage( img );
  }

  // get child background images
  if ( typeof this.options.background == 'string' ) {
    let children = elem.querySelectorAll( this.options.background );
    for ( let child of children ) {
      this.addElementBackgroundImages( child );
    }
  }
};

const reURL = /url\((['"])?(.*?)\1\)/gi;

ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
  let style = getComputedStyle( elem );
  // Firefox returns null if in a hidden iframe https://bugzil.la/548397
  if ( !style ) return;

  // get url inside url("...")
  let matches = reURL.exec( style.backgroundImage );
  while ( matches !== null ) {
    let url = matches && matches[2];
    if ( url ) {
      this.addBackground( url, elem );
    }
    matches = reURL.exec( style.backgroundImage );
  }
};

/**
 * @param {Image} img
 */
ImagesLoaded.prototype.addImage = function( img ) {
  let loadingImage = new LoadingImage( img );
  this.images.push( loadingImage );
};

ImagesLoaded.prototype.addBackground = function( url, elem ) {
  let background = new Background( url, elem );
  this.images.push( background );
};

ImagesLoaded.prototype.check = function() {
  this.progressedCount = 0;
  this.hasAnyBroken = false;
  // complete if no images
  if ( !this.images.length ) {
    this.complete();
    return;
  }

  /* eslint-disable-next-line func-style */
  let onProgress = ( image, elem, message ) => {
    // HACK - Chrome triggers event before object properties have changed. #83
    setTimeout( () => {
      this.progress( image, elem, message );
    } );
  };

  this.images.forEach( function( loadingImage ) {
    loadingImage.once( 'progress', onProgress );
    loadingImage.check();
  } );
};

ImagesLoaded.prototype.progress = function( image, elem, message ) {
  this.progressedCount++;
  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
  // progress event
  this.emitEvent( 'progress', [ this, image, elem ] );
  if ( this.jqDeferred && this.jqDeferred.notify ) {
    this.jqDeferred.notify( this, image );
  }
  // check if completed
  if ( this.progressedCount === this.images.length ) {
    this.complete();
  }

  if ( this.options.debug && console ) {
    console.log( `progress: ${message}`, image, elem );
  }
};

ImagesLoaded.prototype.complete = function() {
  let eventName = this.hasAnyBroken ? 'fail' : 'done';
  this.isComplete = true;
  this.emitEvent( eventName, [ this ] );
  this.emitEvent( 'always', [ this ] );
  if ( this.jqDeferred ) {
    let jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
    this.jqDeferred[ jqMethod ]( this );
  }
};

// --------------------------  -------------------------- //

function LoadingImage( img ) {
  this.img = img;
}

LoadingImage.prototype = Object.create( EvEmitter.prototype );

LoadingImage.prototype.check = function() {
  // If complete is true and browser supports natural sizes,
  // try to check for image status manually.
  let isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    // report based on naturalWidth
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    return;
  }

  // If none of the checks above matched, simulate loading on detached element.
  this.proxyImage = new Image();
  // add crossOrigin attribute. #204
  if ( this.img.crossOrigin ) {
    this.proxyImage.crossOrigin = this.img.crossOrigin;
  }
  this.proxyImage.addEventListener( 'load', this );
  this.proxyImage.addEventListener( 'error', this );
  // bind to image as well for Firefox. #191
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.proxyImage.src = this.img.currentSrc || this.img.src;
};

LoadingImage.prototype.getIsImageComplete = function() {
  // check for non-zero, non-undefined naturalWidth
  // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
  return this.img.complete && this.img.naturalWidth;
};

LoadingImage.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  let { parentNode } = this.img;
  // emit progress with parent <picture> or self <img>
  let elem = parentNode.nodeName === 'PICTURE' ? parentNode : this.img;
  this.emitEvent( 'progress', [ this, elem, message ] );
};

// ----- events ----- //

// trigger specified handler for event type
LoadingImage.prototype.handleEvent = function( event ) {
  let method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

LoadingImage.prototype.onload = function() {
  this.confirm( true, 'onload' );
  this.unbindEvents();
};

LoadingImage.prototype.onerror = function() {
  this.confirm( false, 'onerror' );
  this.unbindEvents();
};

LoadingImage.prototype.unbindEvents = function() {
  this.proxyImage.removeEventListener( 'load', this );
  this.proxyImage.removeEventListener( 'error', this );
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

// -------------------------- Background -------------------------- //

function Background( url, element ) {
  this.url = url;
  this.element = element;
  this.img = new Image();
}

// inherit LoadingImage prototype
Background.prototype = Object.create( LoadingImage.prototype );

Background.prototype.check = function() {
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.img.src = this.url;
  // check if image is already complete
  let isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    this.unbindEvents();
  }
};

Background.prototype.unbindEvents = function() {
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

Background.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  this.emitEvent( 'progress', [ this, this.element, message ] );
};

// -------------------------- jQuery -------------------------- //

ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
  jQuery = jQuery || window.jQuery;
  if ( !jQuery ) return;

  // set local variable
  $ = jQuery;
  // $().imagesLoaded()
  $.fn.imagesLoaded = function( options, onAlways ) {
    let instance = new ImagesLoaded( this, options, onAlways );
    return instance.jqDeferred.promise( $( this ) );
  };
};
// try making plugin
ImagesLoaded.makeJQueryPlugin();

// --------------------------  -------------------------- //

return ImagesLoaded;

} );


/***/ }),

/***/ "./node_modules/is-finite/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-finite/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


module.exports = Number.isFinite || function (value) {
	return !(typeof value !== 'number' || value !== value || value === Infinity || value === -Infinity);
};


/***/ }),

/***/ "./node_modules/is-integer/index.js":
/*!******************************************!*\
  !*** ./node_modules/is-integer/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/paulmillr/es6-shim
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isinteger
var isFinite = __webpack_require__(/*! is-finite */ "./node_modules/is-finite/index.js");
module.exports = Number.isInteger || function(val) {
  return typeof val === "number" &&
    isFinite(val) &&
    Math.floor(val) === val;
};


/***/ }),

/***/ "./node_modules/is-valid-month/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-valid-month/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isInteger = __webpack_require__(/*! is-integer */ "./node_modules/is-integer/index.js")

module.exports = function isValidMonth (month) {
  if (typeof month !== 'number' || !isInteger(month)) return false
  return month >= 1 && month <= 12
}


/***/ }),

/***/ "./node_modules/jquery-revealer/jquery.revealer.js":
/*!*********************************************************!*\
  !*** ./node_modules/jquery-revealer/jquery.revealer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Revealer 3.0.0
 *
 * Copyright 2021, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
(function($){
  // check for trend event (make sure jquery.trend is included)
  if (typeof $.event.special.trend !== "object") {
    console.warn("Please make sure jquery.trend is included! Otherwise revealer won't work.");
  }

  // Simple requestAnimationFrame polyfill
  var raf = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function(fn) { window.setTimeout(fn, 1000/60); }


  // Public API
  var methods = {
    isVisible: function(el) {
      return !!el.data("revealer-visible");
    },

    show: function(el, force) {
      // Check state
      if (methods.isVisible(el)) {
        el.removeClass("animating animating-in");
        el.off("revealer-animating revealer-show");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", true);
      el.off("trend");

      if (force) {
        el.addClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-show");
        });
        return;
      }

      raf(function(){
        // Start animation state transition
        el.addClass("animating animating-in");
        el.trigger("revealer-animating");

        raf(function(){
          el.addClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in");
            el.trigger("revealer-show");
          });
        });
      });
    },

    hide: function(el, force) {
      // Check state
      if (!methods.isVisible(el)) {
        el.removeClass("animating animating-out visible");
        el.off("revealer-animating revealer-hide");
        return;
      }

      // Remove previous event listeners
      el.data("revealer-visible", false);
      el.off("trend");

      if (force) {
        el.removeClass("visible");
        raf(function(){
          el.trigger("revealer-animating");
          el.trigger("revealer-hide");
        });
        return;
      }

      raf(function(){
        el.addClass("animating animating-out");
        el.trigger("revealer-animating");

        raf(function(){
          el.removeClass("visible");

          el.one("trend", function(){
            el.removeClass("animating animating-in animating-out");
            el.trigger("revealer-hide");
          });
        });
      });
    },

    toggle: function(el, force) {
      if (methods.isVisible(el)) {
        methods.hide(el, force);
      } else {
        methods.show(el, force);
      }
    }
  };

  // jQuery plugin
  $.fn.revealer = function(method, force) {
    // Get action
    var action = methods[method || "toggle"];
    if (!action) return this;

    // Run action
    if (method === "isVisible") {
      return action(this);
    }

    return this.each(function(){
      action($(this), force);
    });
  };
})(jQuery);


/***/ }),

/***/ "./node_modules/jquery-trend/jquery.trend.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery-trend/jquery.trend.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Trend 1.0.0
 *
 * Fail-safe TransitionEnd event for jQuery.
 *
 * Adds a new "trend" event that can be used in browsers that don't
 * support "transitionend".
 *
 * NOTE: Only supports being bound with "jQuery.one".
 *
 * Copyright 2021, Pixel Union - http://pixelunion.net
 * Released under the MIT license
 */
;(function($){

  // Prefixed transitionend event names
  var transitionEndEvents =
    "webkitTransitionEnd " +
    "otransitionend " +
    "oTransitionEnd " +
    "msTransitionEnd " +
    "transitionend";

  // Prefixed transition duration property names
  var transitionDurationProperties = [
    "transition-duration",
    "-moz-transition-duration",
    "-webkit-transition-duration",
    "-ms-transition-duration",
    "-o-transition-duration",
    "-khtml-transition-duration"
  ];

  // Prefixed transition delay property names
  var transitionDelayProperties = [
    "transition-delay",
    "-moz-transition-delay",
    "-webkit-transition-delay",
    "-ms-transition-delay",
    "-o-transition-delay",
    "-khtml-transition-delay"
  ];

  // Parses a CSS time value into milliseconds.
  var parseTime = function(s) {
    s = s.replace(/\s/, "");
    var v = window.parseFloat(s);

    return s.match(/[^m]s$/i)
      ? v * 1000
      : v;
  };

  // Parses the longest time unit found in a series of CSS properties.
  // Returns a value in milliseconds.
  var parseProperties = function(el, properties) {
    var duration = 0;

    for (var i = 0; i < properties.length; i++) {
      // Get raw CSS value
      var value = el.css(properties[i]);
      if (!value) continue;

      // Multiple transitions--pick the longest
      if (value.indexOf(",") !== -1) {
        var values = value.split(",");
        var durations = (function(){
          var results = [];
          for (var i = 0; i < values.length; i++) {
            var duration = parseTime(values[i]);
            results.push(duration);
          }
          return results;
        })();

        duration = Math.max.apply(Math, durations);
      }

      // Single transition
      else {
        duration = parseTime(value);
      }

      // Accept first vaue
      break;
    }

    return duration;
  };

  $.event.special.trend = {
    // Triggers an event handler when an element is done transitioning.
    //
    // Handles browsers that don't support transitionend by adding a
    // timeout with the transition duration.
    add: function(handleObj) {
      var el = $(this);
      var fired = false;

      // Mark element as being in transition
      el.data("trend", true);

      // Calculate a fallback duration. + 20 because some browsers fire
      // timeouts faster than transitionend.
      var time =
        parseProperties(el, transitionDurationProperties) +
        parseProperties(el, transitionDelayProperties) +
        20;

      var cb = function(e) {
        // transitionend events can be sent for each property. Let's just
        // skip all but the first. Also handles the timeout callback.
        if (fired) return;

        // Child elements that also have transitions can be fired before we
        // complete. This will catch and ignore those. Unfortunately, we'll
        // have to rely on the timeout in these cases.
        if (e && e.srcElement !== el[0]) return;

        // Mark element has not being in transition
        el.data("trend", false);

        // Callback
        fired = true;
        if (handleObj.handler) handleObj.handler();
      };

      el.one(transitionEndEvents, cb);
      el.data("trend-timeout", window.setTimeout(cb, time));
    },

    remove: function(handleObj) {
      var el = $(this);
      el.off(transitionEndEvents);
      window.clearTimeout(el.data("trend-timeout"));
    }
  };

})(jQuery);


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.min.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/dist/jquery.min.js ***!
  \************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery v3.7.1 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict"; true&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(ie,e){"use strict";var oe=[],r=Object.getPrototypeOf,ae=oe.slice,g=oe.flat?function(e){return oe.flat.call(e)}:function(e){return oe.concat.apply([],e)},s=oe.push,se=oe.indexOf,n={},i=n.toString,ue=n.hasOwnProperty,o=ue.toString,a=o.call(Object),le={},v=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType&&"function"!=typeof e.item},y=function(e){return null!=e&&e===e.window},C=ie.document,u={type:!0,src:!0,nonce:!0,noModule:!0};function m(e,t,n){var r,i,o=(n=n||C).createElement("script");if(o.text=e,t)for(r in u)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[i.call(e)]||"object":typeof e}var t="3.7.1",l=/HTML$/i,ce=function(e,t){return new ce.fn.init(e,t)};function c(e){var t=!!e&&"length"in e&&e.length,n=x(e);return!v(e)&&!y(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}function fe(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}ce.fn=ce.prototype={jquery:t,constructor:ce,length:0,toArray:function(){return ae.call(this)},get:function(e){return null==e?ae.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=ce.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return ce.each(this,e)},map:function(n){return this.pushStack(ce.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(ae.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(ce.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(ce.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:s,sort:oe.sort,splice:oe.splice},ce.extend=ce.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||v(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(ce.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||ce.isPlainObject(n)?n:{},i=!1,a[t]=ce.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},ce.extend({expando:"jQuery"+(t+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==i.call(e))&&(!(t=r(e))||"function"==typeof(n=ue.call(t,"constructor")&&t.constructor)&&o.call(n)===a)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){m(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(c(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},text:function(e){var t,n="",r=0,i=e.nodeType;if(!i)while(t=e[r++])n+=ce.text(t);return 1===i||11===i?e.textContent:9===i?e.documentElement.textContent:3===i||4===i?e.nodeValue:n},makeArray:function(e,t){var n=t||[];return null!=e&&(c(Object(e))?ce.merge(n,"string"==typeof e?[e]:e):s.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:se.call(t,e,n)},isXMLDoc:function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!l.test(t||n&&n.nodeName||"HTML")},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(c(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:le}),"function"==typeof Symbol&&(ce.fn[Symbol.iterator]=oe[Symbol.iterator]),ce.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var pe=oe.pop,de=oe.sort,he=oe.splice,ge="[\\x20\\t\\r\\n\\f]",ve=new RegExp("^"+ge+"+|((?:^|[^\\\\])(?:\\\\.)*)"+ge+"+$","g");ce.contains=function(e,t){var n=t&&t.parentNode;return e===n||!(!n||1!==n.nodeType||!(e.contains?e.contains(n):e.compareDocumentPosition&&16&e.compareDocumentPosition(n)))};var f=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;function p(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e}ce.escapeSelector=function(e){return(e+"").replace(f,p)};var ye=C,me=s;!function(){var e,b,w,o,a,T,r,C,d,i,k=me,S=ce.expando,E=0,n=0,s=W(),c=W(),u=W(),h=W(),l=function(e,t){return e===t&&(a=!0),0},f="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",t="(?:\\\\[\\da-fA-F]{1,6}"+ge+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",p="\\["+ge+"*("+t+")(?:"+ge+"*([*^$|!~]?=)"+ge+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+t+"))|)"+ge+"*\\]",g=":("+t+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+p+")*)|.*)\\)|)",v=new RegExp(ge+"+","g"),y=new RegExp("^"+ge+"*,"+ge+"*"),m=new RegExp("^"+ge+"*([>+~]|"+ge+")"+ge+"*"),x=new RegExp(ge+"|>"),j=new RegExp(g),A=new RegExp("^"+t+"$"),D={ID:new RegExp("^#("+t+")"),CLASS:new RegExp("^\\.("+t+")"),TAG:new RegExp("^("+t+"|[*])"),ATTR:new RegExp("^"+p),PSEUDO:new RegExp("^"+g),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+ge+"*(even|odd|(([+-]|)(\\d*)n|)"+ge+"*(?:([+-]|)"+ge+"*(\\d+)|))"+ge+"*\\)|)","i"),bool:new RegExp("^(?:"+f+")$","i"),needsContext:new RegExp("^"+ge+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+ge+"*((?:-\\d)?\\d*)"+ge+"*\\)|)(?=[^-]|$)","i")},N=/^(?:input|select|textarea|button)$/i,q=/^h\d$/i,L=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,H=/[+~]/,O=new RegExp("\\\\[\\da-fA-F]{1,6}"+ge+"?|\\\\([^\\r\\n\\f])","g"),P=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},M=function(){V()},R=J(function(e){return!0===e.disabled&&fe(e,"fieldset")},{dir:"parentNode",next:"legend"});try{k.apply(oe=ae.call(ye.childNodes),ye.childNodes),oe[ye.childNodes.length].nodeType}catch(e){k={apply:function(e,t){me.apply(e,ae.call(t))},call:function(e){me.apply(e,ae.call(arguments,1))}}}function I(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(V(e),e=e||T,C)){if(11!==p&&(u=L.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return k.call(n,a),n}else if(f&&(a=f.getElementById(i))&&I.contains(e,a)&&a.id===i)return k.call(n,a),n}else{if(u[2])return k.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&e.getElementsByClassName)return k.apply(n,e.getElementsByClassName(i)),n}if(!(h[t+" "]||d&&d.test(t))){if(c=t,f=e,1===p&&(x.test(t)||m.test(t))){(f=H.test(t)&&U(e.parentNode)||e)==e&&le.scope||((s=e.getAttribute("id"))?s=ce.escapeSelector(s):e.setAttribute("id",s=S)),o=(l=Y(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+Q(l[o]);c=l.join(",")}try{return k.apply(n,f.querySelectorAll(c)),n}catch(e){h(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return re(t.replace(ve,"$1"),e,n,r)}function W(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function F(e){return e[S]=!0,e}function $(e){var t=T.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function B(t){return function(e){return fe(e,"input")&&e.type===t}}function _(t){return function(e){return(fe(e,"input")||fe(e,"button"))&&e.type===t}}function z(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&R(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function X(a){return F(function(o){return o=+o,F(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function U(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}function V(e){var t,n=e?e.ownerDocument||e:ye;return n!=T&&9===n.nodeType&&n.documentElement&&(r=(T=n).documentElement,C=!ce.isXMLDoc(T),i=r.matches||r.webkitMatchesSelector||r.msMatchesSelector,r.msMatchesSelector&&ye!=T&&(t=T.defaultView)&&t.top!==t&&t.addEventListener("unload",M),le.getById=$(function(e){return r.appendChild(e).id=ce.expando,!T.getElementsByName||!T.getElementsByName(ce.expando).length}),le.disconnectedMatch=$(function(e){return i.call(e,"*")}),le.scope=$(function(){return T.querySelectorAll(":scope")}),le.cssHas=$(function(){try{return T.querySelector(":has(*,:jqfake)"),!1}catch(e){return!0}}),le.getById?(b.filter.ID=function(e){var t=e.replace(O,P);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&C){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(O,P);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&C){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):t.querySelectorAll(e)},b.find.CLASS=function(e,t){if("undefined"!=typeof t.getElementsByClassName&&C)return t.getElementsByClassName(e)},d=[],$(function(e){var t;r.appendChild(e).innerHTML="<a id='"+S+"' href='' disabled='disabled'></a><select id='"+S+"-\r\\' disabled='disabled'><option selected=''></option></select>",e.querySelectorAll("[selected]").length||d.push("\\["+ge+"*(?:value|"+f+")"),e.querySelectorAll("[id~="+S+"-]").length||d.push("~="),e.querySelectorAll("a#"+S+"+*").length||d.push(".#.+[+~]"),e.querySelectorAll(":checked").length||d.push(":checked"),(t=T.createElement("input")).setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),r.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&d.push(":enabled",":disabled"),(t=T.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||d.push("\\["+ge+"*name"+ge+"*="+ge+"*(?:''|\"\")")}),le.cssHas||d.push(":has"),d=d.length&&new RegExp(d.join("|")),l=function(e,t){if(e===t)return a=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!le.sortDetached&&t.compareDocumentPosition(e)===n?e===T||e.ownerDocument==ye&&I.contains(ye,e)?-1:t===T||t.ownerDocument==ye&&I.contains(ye,t)?1:o?se.call(o,e)-se.call(o,t):0:4&n?-1:1)}),T}for(e in I.matches=function(e,t){return I(e,null,null,t)},I.matchesSelector=function(e,t){if(V(e),C&&!h[t+" "]&&(!d||!d.test(t)))try{var n=i.call(e,t);if(n||le.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){h(t,!0)}return 0<I(t,T,null,[e]).length},I.contains=function(e,t){return(e.ownerDocument||e)!=T&&V(e),ce.contains(e,t)},I.attr=function(e,t){(e.ownerDocument||e)!=T&&V(e);var n=b.attrHandle[t.toLowerCase()],r=n&&ue.call(b.attrHandle,t.toLowerCase())?n(e,t,!C):void 0;return void 0!==r?r:e.getAttribute(t)},I.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},ce.uniqueSort=function(e){var t,n=[],r=0,i=0;if(a=!le.sortStable,o=!le.sortStable&&ae.call(e,0),de.call(e,l),a){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)he.call(e,n[r],1)}return o=null,e},ce.fn.uniqueSort=function(){return this.pushStack(ce.uniqueSort(ae.apply(this)))},(b=ce.expr={cacheLength:50,createPseudo:F,match:D,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(O,P),e[3]=(e[3]||e[4]||e[5]||"").replace(O,P),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||I.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&I.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return D.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&j.test(n)&&(t=Y(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(O,P).toLowerCase();return"*"===e?function(){return!0}:function(e){return fe(e,t)}},CLASS:function(e){var t=s[e+" "];return t||(t=new RegExp("(^|"+ge+")"+e+"("+ge+"|$)"))&&s(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=I.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(v," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(d,e,t,h,g){var v="nth"!==d.slice(0,3),y="last"!==d.slice(-4),m="of-type"===e;return 1===h&&0===g?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u=v!==y?"nextSibling":"previousSibling",l=e.parentNode,c=m&&e.nodeName.toLowerCase(),f=!n&&!m,p=!1;if(l){if(v){while(u){o=e;while(o=o[u])if(m?fe(o,c):1===o.nodeType)return!1;s=u="only"===d&&!s&&"nextSibling"}return!0}if(s=[y?l.firstChild:l.lastChild],y&&f){p=(a=(r=(i=l[S]||(l[S]={}))[d]||[])[0]===E&&r[1])&&r[2],o=a&&l.childNodes[a];while(o=++a&&o&&o[u]||(p=a=0)||s.pop())if(1===o.nodeType&&++p&&o===e){i[d]=[E,a,p];break}}else if(f&&(p=a=(r=(i=e[S]||(e[S]={}))[d]||[])[0]===E&&r[1]),!1===p)while(o=++a&&o&&o[u]||(p=a=0)||s.pop())if((m?fe(o,c):1===o.nodeType)&&++p&&(f&&((i=o[S]||(o[S]={}))[d]=[E,p]),o===e))break;return(p-=g)===h||p%h==0&&0<=p/h}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||I.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?F(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=se.call(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:F(function(e){var r=[],i=[],s=ne(e.replace(ve,"$1"));return s[S]?F(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:F(function(t){return function(e){return 0<I(t,e).length}}),contains:F(function(t){return t=t.replace(O,P),function(e){return-1<(e.textContent||ce.text(e)).indexOf(t)}}),lang:F(function(n){return A.test(n||"")||I.error("unsupported lang: "+n),n=n.replace(O,P).toLowerCase(),function(e){var t;do{if(t=C?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=ie.location&&ie.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===r},focus:function(e){return e===function(){try{return T.activeElement}catch(e){}}()&&T.hasFocus()&&!!(e.type||e.href||~e.tabIndex)},enabled:z(!1),disabled:z(!0),checked:function(e){return fe(e,"input")&&!!e.checked||fe(e,"option")&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return q.test(e.nodeName)},input:function(e){return N.test(e.nodeName)},button:function(e){return fe(e,"input")&&"button"===e.type||fe(e,"button")},text:function(e){var t;return fe(e,"input")&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:X(function(){return[0]}),last:X(function(e,t){return[t-1]}),eq:X(function(e,t,n){return[n<0?n+t:n]}),even:X(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:X(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:X(function(e,t,n){var r;for(r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:X(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=B(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=_(e);function G(){}function Y(e,t){var n,r,i,o,a,s,u,l=c[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=y.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=m.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(ve," ")}),a=a.slice(n.length)),b.filter)!(r=D[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?I.error(e):c(e,s).slice(0)}function Q(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function J(a,e,t){var s=e.dir,u=e.next,l=u||s,c=t&&"parentNode"===l,f=n++;return e.first?function(e,t,n){while(e=e[s])if(1===e.nodeType||c)return a(e,t,n);return!1}:function(e,t,n){var r,i,o=[E,f];if(n){while(e=e[s])if((1===e.nodeType||c)&&a(e,t,n))return!0}else while(e=e[s])if(1===e.nodeType||c)if(i=e[S]||(e[S]={}),u&&fe(e,u))e=e[s]||e;else{if((r=i[l])&&r[0]===E&&r[1]===f)return o[2]=r[2];if((i[l]=o)[2]=a(e,t,n))return!0}return!1}}function K(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Z(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function ee(d,h,g,v,y,e){return v&&!v[S]&&(v=ee(v)),y&&!y[S]&&(y=ee(y,e)),F(function(e,t,n,r){var i,o,a,s,u=[],l=[],c=t.length,f=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)I(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),p=!d||!e&&h?f:Z(f,u,d,n,r);if(g?g(p,s=y||(e?d:c||v)?[]:t,n,r):s=p,v){i=Z(s,l),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(s[l[o]]=!(p[l[o]]=a))}if(e){if(y||d){if(y){i=[],o=s.length;while(o--)(a=s[o])&&i.push(p[o]=a);y(null,s=[],i,r)}o=s.length;while(o--)(a=s[o])&&-1<(i=y?se.call(e,a):u[o])&&(e[i]=!(t[i]=a))}}else s=Z(s===t?s.splice(c,s.length):s),y?y(null,t,s,r):k.apply(t,s)})}function te(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=J(function(e){return e===i},a,!0),l=J(function(e){return-1<se.call(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!=w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[J(K(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return ee(1<s&&K(c),1<s&&Q(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(ve,"$1"),t,s<n&&te(e.slice(s,n)),n<r&&te(e=e.slice(n)),n<r&&Q(e))}c.push(t)}return K(c)}function ne(e,t){var n,v,y,m,x,r,i=[],o=[],a=u[e+" "];if(!a){t||(t=Y(e)),n=t.length;while(n--)(a=te(t[n]))[S]?i.push(a):o.push(a);(a=u(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=E+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==T||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==T||(V(o),n=!C);while(s=v[a++])if(s(o,t||T,n)){k.call(r,o);break}i&&(E=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=pe.call(r));f=Z(f)}k.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&ce.uniqueSort(r)}return i&&(E=h,w=p),c},m?F(r):r))).selector=e}return a}function re(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&Y(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&C&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(O,P),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=D.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(O,P),H.test(o[0].type)&&U(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&Q(o)))return k.apply(n,r),n;break}}}return(l||ne(e,c))(r,t,!C,n,!t||H.test(e)&&U(t.parentNode)||t),n}G.prototype=b.filters=b.pseudos,b.setFilters=new G,le.sortStable=S.split("").sort(l).join("")===S,V(),le.sortDetached=$(function(e){return 1&e.compareDocumentPosition(T.createElement("fieldset"))}),ce.find=I,ce.expr[":"]=ce.expr.pseudos,ce.unique=ce.uniqueSort,I.compile=ne,I.select=re,I.setDocument=V,I.tokenize=Y,I.escape=ce.escapeSelector,I.getText=ce.text,I.isXML=ce.isXMLDoc,I.selectors=ce.expr,I.support=ce.support,I.uniqueSort=ce.uniqueSort}();var d=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&ce(e).is(n))break;r.push(e)}return r},h=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},b=ce.expr.match.needsContext,w=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function T(e,n,r){return v(n)?ce.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?ce.grep(e,function(e){return e===n!==r}):"string"!=typeof n?ce.grep(e,function(e){return-1<se.call(n,e)!==r}):ce.filter(n,e,r)}ce.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?ce.find.matchesSelector(r,e)?[r]:[]:ce.find.matches(e,ce.grep(t,function(e){return 1===e.nodeType}))},ce.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(ce(e).filter(function(){for(t=0;t<r;t++)if(ce.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)ce.find(e,i[t],n);return 1<r?ce.uniqueSort(n):n},filter:function(e){return this.pushStack(T(this,e||[],!1))},not:function(e){return this.pushStack(T(this,e||[],!0))},is:function(e){return!!T(this,"string"==typeof e&&b.test(e)?ce(e):e||[],!1).length}});var k,S=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(ce.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||k,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:S.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof ce?t[0]:t,ce.merge(this,ce.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:C,!0)),w.test(r[1])&&ce.isPlainObject(t))for(r in t)v(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=C.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):v(e)?void 0!==n.ready?n.ready(e):e(ce):ce.makeArray(e,this)}).prototype=ce.fn,k=ce(C);var E=/^(?:parents|prev(?:Until|All))/,j={children:!0,contents:!0,next:!0,prev:!0};function A(e,t){while((e=e[t])&&1!==e.nodeType);return e}ce.fn.extend({has:function(e){var t=ce(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(ce.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&ce(e);if(!b.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&ce.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?ce.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?se.call(ce(e),this[0]):se.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(ce.uniqueSort(ce.merge(this.get(),ce(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),ce.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return d(e,"parentNode")},parentsUntil:function(e,t,n){return d(e,"parentNode",n)},next:function(e){return A(e,"nextSibling")},prev:function(e){return A(e,"previousSibling")},nextAll:function(e){return d(e,"nextSibling")},prevAll:function(e){return d(e,"previousSibling")},nextUntil:function(e,t,n){return d(e,"nextSibling",n)},prevUntil:function(e,t,n){return d(e,"previousSibling",n)},siblings:function(e){return h((e.parentNode||{}).firstChild,e)},children:function(e){return h(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(fe(e,"template")&&(e=e.content||e),ce.merge([],e.childNodes))}},function(r,i){ce.fn[r]=function(e,t){var n=ce.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=ce.filter(t,n)),1<this.length&&(j[r]||ce.uniqueSort(n),E.test(r)&&n.reverse()),this.pushStack(n)}});var D=/[^\x20\t\r\n\f]+/g;function N(e){return e}function q(e){throw e}function L(e,t,n,r){var i;try{e&&v(i=e.promise)?i.call(e).done(t).fail(n):e&&v(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}ce.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},ce.each(e.match(D)||[],function(e,t){n[t]=!0}),n):ce.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){ce.each(e,function(e,t){v(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==x(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return ce.each(arguments,function(e,t){var n;while(-1<(n=ce.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<ce.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},ce.extend({Deferred:function(e){var o=[["notify","progress",ce.Callbacks("memory"),ce.Callbacks("memory"),2],["resolve","done",ce.Callbacks("once memory"),ce.Callbacks("once memory"),0,"resolved"],["reject","fail",ce.Callbacks("once memory"),ce.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return ce.Deferred(function(r){ce.each(o,function(e,t){var n=v(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&v(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,v(t)?s?t.call(e,l(u,o,N,s),l(u,o,q,s)):(u++,t.call(e,l(u,o,N,s),l(u,o,q,s),l(u,o,N,o.notifyWith))):(a!==N&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){ce.Deferred.exceptionHook&&ce.Deferred.exceptionHook(e,t.error),u<=i+1&&(a!==q&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(ce.Deferred.getErrorHook?t.error=ce.Deferred.getErrorHook():ce.Deferred.getStackHook&&(t.error=ce.Deferred.getStackHook()),ie.setTimeout(t))}}return ce.Deferred(function(e){o[0][3].add(l(0,e,v(r)?r:N,e.notifyWith)),o[1][3].add(l(0,e,v(t)?t:N)),o[2][3].add(l(0,e,v(n)?n:q))}).promise()},promise:function(e){return null!=e?ce.extend(e,a):a}},s={};return ce.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=ae.call(arguments),o=ce.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?ae.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(L(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||v(i[t]&&i[t].then)))return o.then();while(t--)L(i[t],a(t),o.reject);return o.promise()}});var H=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;ce.Deferred.exceptionHook=function(e,t){ie.console&&ie.console.warn&&e&&H.test(e.name)&&ie.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},ce.readyException=function(e){ie.setTimeout(function(){throw e})};var O=ce.Deferred();function P(){C.removeEventListener("DOMContentLoaded",P),ie.removeEventListener("load",P),ce.ready()}ce.fn.ready=function(e){return O.then(e)["catch"](function(e){ce.readyException(e)}),this},ce.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--ce.readyWait:ce.isReady)||(ce.isReady=!0)!==e&&0<--ce.readyWait||O.resolveWith(C,[ce])}}),ce.ready.then=O.then,"complete"===C.readyState||"loading"!==C.readyState&&!C.documentElement.doScroll?ie.setTimeout(ce.ready):(C.addEventListener("DOMContentLoaded",P),ie.addEventListener("load",P));var M=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===x(n))for(s in i=!0,n)M(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,v(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(ce(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},R=/^-ms-/,I=/-([a-z])/g;function W(e,t){return t.toUpperCase()}function F(e){return e.replace(R,"ms-").replace(I,W)}var $=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function B(){this.expando=ce.expando+B.uid++}B.uid=1,B.prototype={cache:function(e){var t=e[this.expando];return t||(t={},$(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[F(t)]=n;else for(r in t)i[F(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][F(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(F):(t=F(t))in r?[t]:t.match(D)||[]).length;while(n--)delete r[t[n]]}(void 0===t||ce.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!ce.isEmptyObject(t)}};var _=new B,z=new B,X=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,U=/[A-Z]/g;function V(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(U,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:X.test(i)?JSON.parse(i):i)}catch(e){}z.set(e,t,n)}else n=void 0;return n}ce.extend({hasData:function(e){return z.hasData(e)||_.hasData(e)},data:function(e,t,n){return z.access(e,t,n)},removeData:function(e,t){z.remove(e,t)},_data:function(e,t,n){return _.access(e,t,n)},_removeData:function(e,t){_.remove(e,t)}}),ce.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=z.get(o),1===o.nodeType&&!_.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=F(r.slice(5)),V(o,r,i[r]));_.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){z.set(this,n)}):M(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=z.get(o,n))?t:void 0!==(t=V(o,n))?t:void 0;this.each(function(){z.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){z.remove(this,e)})}}),ce.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=_.get(e,t),n&&(!r||Array.isArray(n)?r=_.access(e,t,ce.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=ce.queue(e,t),r=n.length,i=n.shift(),o=ce._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){ce.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return _.get(e,n)||_.access(e,n,{empty:ce.Callbacks("once memory").add(function(){_.remove(e,[t+"queue",n])})})}}),ce.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?ce.queue(this[0],t):void 0===n?this:this.each(function(){var e=ce.queue(this,t,n);ce._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&ce.dequeue(this,t)})},dequeue:function(e){return this.each(function(){ce.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=ce.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=_.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var G=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,Y=new RegExp("^(?:([+-])=|)("+G+")([a-z%]*)$","i"),Q=["Top","Right","Bottom","Left"],J=C.documentElement,K=function(e){return ce.contains(e.ownerDocument,e)},Z={composed:!0};J.getRootNode&&(K=function(e){return ce.contains(e.ownerDocument,e)||e.getRootNode(Z)===e.ownerDocument});var ee=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&K(e)&&"none"===ce.css(e,"display")};function te(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return ce.css(e,t,"")},u=s(),l=n&&n[3]||(ce.cssNumber[t]?"":"px"),c=e.nodeType&&(ce.cssNumber[t]||"px"!==l&&+u)&&Y.exec(ce.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)ce.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,ce.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ne={};function re(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=_.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ee(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ne[s])||(o=a.body.appendChild(a.createElement(s)),u=ce.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ne[s]=u)))):"none"!==n&&(l[c]="none",_.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}ce.fn.extend({show:function(){return re(this,!0)},hide:function(){return re(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ee(this)?ce(this).show():ce(this).hide()})}});var xe,be,we=/^(?:checkbox|radio)$/i,Te=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,Ce=/^$|^module$|\/(?:java|ecma)script/i;xe=C.createDocumentFragment().appendChild(C.createElement("div")),(be=C.createElement("input")).setAttribute("type","radio"),be.setAttribute("checked","checked"),be.setAttribute("name","t"),xe.appendChild(be),le.checkClone=xe.cloneNode(!0).cloneNode(!0).lastChild.checked,xe.innerHTML="<textarea>x</textarea>",le.noCloneChecked=!!xe.cloneNode(!0).lastChild.defaultValue,xe.innerHTML="<option></option>",le.option=!!xe.lastChild;var ke={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function Se(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&fe(e,t)?ce.merge([e],n):n}function Ee(e,t){for(var n=0,r=e.length;n<r;n++)_.set(e[n],"globalEval",!t||_.get(t[n],"globalEval"))}ke.tbody=ke.tfoot=ke.colgroup=ke.caption=ke.thead,ke.th=ke.td,le.option||(ke.optgroup=ke.option=[1,"<select multiple='multiple'>","</select>"]);var je=/<|&#?\w+;/;function Ae(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===x(o))ce.merge(p,o.nodeType?[o]:o);else if(je.test(o)){a=a||f.appendChild(t.createElement("div")),s=(Te.exec(o)||["",""])[1].toLowerCase(),u=ke[s]||ke._default,a.innerHTML=u[1]+ce.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;ce.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<ce.inArray(o,r))i&&i.push(o);else if(l=K(o),a=Se(f.appendChild(o),"script"),l&&Ee(a),n){c=0;while(o=a[c++])Ce.test(o.type||"")&&n.push(o)}return f}var De=/^([^.]*)(?:\.(.+)|)/;function Ne(){return!0}function qe(){return!1}function Le(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Le(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=qe;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return ce().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=ce.guid++)),e.each(function(){ce.event.add(this,t,i,r,n)})}function He(e,r,t){t?(_.set(e,r,!1),ce.event.add(e,r,{namespace:!1,handler:function(e){var t,n=_.get(this,r);if(1&e.isTrigger&&this[r]){if(n)(ce.event.special[r]||{}).delegateType&&e.stopPropagation();else if(n=ae.call(arguments),_.set(this,r,n),this[r](),t=_.get(this,r),_.set(this,r,!1),n!==t)return e.stopImmediatePropagation(),e.preventDefault(),t}else n&&(_.set(this,r,ce.event.trigger(n[0],n.slice(1),this)),e.stopPropagation(),e.isImmediatePropagationStopped=Ne)}})):void 0===_.get(e,r)&&ce.event.add(e,r,Ne)}ce.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=_.get(t);if($(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&ce.find.matchesSelector(J,i),n.guid||(n.guid=ce.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof ce&&ce.event.triggered!==e.type?ce.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(D)||[""]).length;while(l--)d=g=(s=De.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=ce.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=ce.event.special[d]||{},c=ce.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&ce.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),ce.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=_.hasData(e)&&_.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(D)||[""]).length;while(l--)if(d=g=(s=De.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=ce.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||ce.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)ce.event.remove(e,d+t[l],n,r,!0);ce.isEmptyObject(u)&&_.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=ce.event.fix(e),l=(_.get(this,"events")||Object.create(null))[u.type]||[],c=ce.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=ce.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((ce.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<ce(i,this).index(l):ce.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(ce.Event.prototype,t,{enumerable:!0,configurable:!0,get:v(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[ce.expando]?e:new ce.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return we.test(t.type)&&t.click&&fe(t,"input")&&He(t,"click",!0),!1},trigger:function(e){var t=this||e;return we.test(t.type)&&t.click&&fe(t,"input")&&He(t,"click"),!0},_default:function(e){var t=e.target;return we.test(t.type)&&t.click&&fe(t,"input")&&_.get(t,"click")||fe(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},ce.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},ce.Event=function(e,t){if(!(this instanceof ce.Event))return new ce.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ne:qe,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&ce.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[ce.expando]=!0},ce.Event.prototype={constructor:ce.Event,isDefaultPrevented:qe,isPropagationStopped:qe,isImmediatePropagationStopped:qe,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ne,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ne,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ne,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},ce.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},ce.event.addProp),ce.each({focus:"focusin",blur:"focusout"},function(r,i){function o(e){if(C.documentMode){var t=_.get(this,"handle"),n=ce.event.fix(e);n.type="focusin"===e.type?"focus":"blur",n.isSimulated=!0,t(e),n.target===n.currentTarget&&t(n)}else ce.event.simulate(i,e.target,ce.event.fix(e))}ce.event.special[r]={setup:function(){var e;if(He(this,r,!0),!C.documentMode)return!1;(e=_.get(this,i))||this.addEventListener(i,o),_.set(this,i,(e||0)+1)},trigger:function(){return He(this,r),!0},teardown:function(){var e;if(!C.documentMode)return!1;(e=_.get(this,i)-1)?_.set(this,i,e):(this.removeEventListener(i,o),_.remove(this,i))},_default:function(e){return _.get(e.target,r)},delegateType:i},ce.event.special[i]={setup:function(){var e=this.ownerDocument||this.document||this,t=C.documentMode?this:e,n=_.get(t,i);n||(C.documentMode?this.addEventListener(i,o):e.addEventListener(r,o,!0)),_.set(t,i,(n||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=C.documentMode?this:e,n=_.get(t,i)-1;n?_.set(t,i,n):(C.documentMode?this.removeEventListener(i,o):e.removeEventListener(r,o,!0),_.remove(t,i))}}}),ce.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){ce.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||ce.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),ce.fn.extend({on:function(e,t,n,r){return Le(this,e,t,n,r)},one:function(e,t,n,r){return Le(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,ce(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=qe),this.each(function(){ce.event.remove(this,e,n,t)})}});var Oe=/<script|<style|<link/i,Pe=/checked\s*(?:[^=]|=\s*.checked.)/i,Me=/^\s*<!\[CDATA\[|\]\]>\s*$/g;function Re(e,t){return fe(e,"table")&&fe(11!==t.nodeType?t:t.firstChild,"tr")&&ce(e).children("tbody")[0]||e}function Ie(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function We(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Fe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(_.hasData(e)&&(s=_.get(e).events))for(i in _.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)ce.event.add(t,i,s[i][n]);z.hasData(e)&&(o=z.access(e),a=ce.extend({},o),z.set(t,a))}}function $e(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=v(d);if(h||1<f&&"string"==typeof d&&!le.checkClone&&Pe.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),$e(t,r,i,o)});if(f&&(t=(e=Ae(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=ce.map(Se(e,"script"),Ie)).length;c<f;c++)u=e,c!==p&&(u=ce.clone(u,!0,!0),s&&ce.merge(a,Se(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,ce.map(a,We),c=0;c<s;c++)u=a[c],Ce.test(u.type||"")&&!_.access(u,"globalEval")&&ce.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?ce._evalUrl&&!u.noModule&&ce._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):m(u.textContent.replace(Me,""),u,l))}return n}function Be(e,t,n){for(var r,i=t?ce.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||ce.cleanData(Se(r)),r.parentNode&&(n&&K(r)&&Ee(Se(r,"script")),r.parentNode.removeChild(r));return e}ce.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=K(e);if(!(le.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||ce.isXMLDoc(e)))for(a=Se(c),r=0,i=(o=Se(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&we.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||Se(e),a=a||Se(c),r=0,i=o.length;r<i;r++)Fe(o[r],a[r]);else Fe(e,c);return 0<(a=Se(c,"script")).length&&Ee(a,!f&&Se(e,"script")),c},cleanData:function(e){for(var t,n,r,i=ce.event.special,o=0;void 0!==(n=e[o]);o++)if($(n)){if(t=n[_.expando]){if(t.events)for(r in t.events)i[r]?ce.event.remove(n,r):ce.removeEvent(n,r,t.handle);n[_.expando]=void 0}n[z.expando]&&(n[z.expando]=void 0)}}}),ce.fn.extend({detach:function(e){return Be(this,e,!0)},remove:function(e){return Be(this,e)},text:function(e){return M(this,function(e){return void 0===e?ce.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return $e(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Re(this,e).appendChild(e)})},prepend:function(){return $e(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Re(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return $e(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return $e(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(ce.cleanData(Se(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return ce.clone(this,e,t)})},html:function(e){return M(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Oe.test(e)&&!ke[(Te.exec(e)||["",""])[1].toLowerCase()]){e=ce.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(ce.cleanData(Se(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return $e(this,arguments,function(e){var t=this.parentNode;ce.inArray(this,n)<0&&(ce.cleanData(Se(this)),t&&t.replaceChild(e,this))},n)}}),ce.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){ce.fn[e]=function(e){for(var t,n=[],r=ce(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),ce(r[o])[a](t),s.apply(n,t.get());return this.pushStack(n)}});var _e=new RegExp("^("+G+")(?!px)[a-z%]+$","i"),ze=/^--/,Xe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=ie),t.getComputedStyle(e)},Ue=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Ve=new RegExp(Q.join("|"),"i");function Ge(e,t,n){var r,i,o,a,s=ze.test(t),u=e.style;return(n=n||Xe(e))&&(a=n.getPropertyValue(t)||n[t],s&&a&&(a=a.replace(ve,"$1")||void 0),""!==a||K(e)||(a=ce.style(e,t)),!le.pixelBoxStyles()&&_e.test(a)&&Ve.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=n.width,u.width=r,u.minWidth=i,u.maxWidth=o)),void 0!==a?a+"":a}function Ye(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",J.appendChild(u).appendChild(l);var e=ie.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),J.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=C.createElement("div"),l=C.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",le.clearCloneStyle="content-box"===l.style.backgroundClip,ce.extend(le,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=C.createElement("table"),t=C.createElement("tr"),n=C.createElement("div"),e.style.cssText="position:absolute;left:-11111px;border-collapse:separate",t.style.cssText="box-sizing:content-box;border:1px solid",t.style.height="1px",n.style.height="9px",n.style.display="block",J.appendChild(e).appendChild(t).appendChild(n),r=ie.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,J.removeChild(e)),a}}))}();var Qe=["Webkit","Moz","ms"],Je=C.createElement("div").style,Ke={};function Ze(e){var t=ce.cssProps[e]||Ke[e];return t||(e in Je?e:Ke[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Qe.length;while(n--)if((e=Qe[n]+t)in Je)return e}(e)||e)}var et=/^(none|table(?!-c[ea]).+)/,tt={position:"absolute",visibility:"hidden",display:"block"},nt={letterSpacing:"0",fontWeight:"400"};function rt(e,t,n){var r=Y.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function it(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0,l=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(l+=ce.css(e,n+Q[a],!0,i)),r?("content"===n&&(u-=ce.css(e,"padding"+Q[a],!0,i)),"margin"!==n&&(u-=ce.css(e,"border"+Q[a]+"Width",!0,i))):(u+=ce.css(e,"padding"+Q[a],!0,i),"padding"!==n?u+=ce.css(e,"border"+Q[a]+"Width",!0,i):s+=ce.css(e,"border"+Q[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u+l}function ot(e,t,n){var r=Xe(e),i=(!le.boxSizingReliable()||n)&&"border-box"===ce.css(e,"boxSizing",!1,r),o=i,a=Ge(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(_e.test(a)){if(!n)return a;a="auto"}return(!le.boxSizingReliable()&&i||!le.reliableTrDimensions()&&fe(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===ce.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===ce.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+it(e,t,n||(i?"border":"content"),o,r,a)+"px"}function at(e,t,n,r,i){return new at.prototype.init(e,t,n,r,i)}ce.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Ge(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,aspectRatio:!0,borderImageSlice:!0,columnCount:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,scale:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeMiterlimit:!0,strokeOpacity:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=F(t),u=ze.test(t),l=e.style;if(u||(t=Ze(s)),a=ce.cssHooks[t]||ce.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=Y.exec(n))&&i[1]&&(n=te(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(ce.cssNumber[s]?"":"px")),le.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=F(t);return ze.test(t)||(t=Ze(s)),(a=ce.cssHooks[t]||ce.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Ge(e,t,r)),"normal"===i&&t in nt&&(i=nt[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),ce.each(["height","width"],function(e,u){ce.cssHooks[u]={get:function(e,t,n){if(t)return!et.test(ce.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?ot(e,u,n):Ue(e,tt,function(){return ot(e,u,n)})},set:function(e,t,n){var r,i=Xe(e),o=!le.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===ce.css(e,"boxSizing",!1,i),s=n?it(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-it(e,u,"border",!1,i)-.5)),s&&(r=Y.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=ce.css(e,u)),rt(0,t,s)}}}),ce.cssHooks.marginLeft=Ye(le.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Ge(e,"marginLeft"))||e.getBoundingClientRect().left-Ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),ce.each({margin:"",padding:"",border:"Width"},function(i,o){ce.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+Q[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(ce.cssHooks[i+o].set=rt)}),ce.fn.extend({css:function(e,t){return M(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Xe(e),i=t.length;a<i;a++)o[t[a]]=ce.css(e,t[a],!1,r);return o}return void 0!==n?ce.style(e,t,n):ce.css(e,t)},e,t,1<arguments.length)}}),((ce.Tween=at).prototype={constructor:at,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||ce.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(ce.cssNumber[n]?"":"px")},cur:function(){var e=at.propHooks[this.prop];return e&&e.get?e.get(this):at.propHooks._default.get(this)},run:function(e){var t,n=at.propHooks[this.prop];return this.options.duration?this.pos=t=ce.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):at.propHooks._default.set(this),this}}).init.prototype=at.prototype,(at.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=ce.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){ce.fx.step[e.prop]?ce.fx.step[e.prop](e):1!==e.elem.nodeType||!ce.cssHooks[e.prop]&&null==e.elem.style[Ze(e.prop)]?e.elem[e.prop]=e.now:ce.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=at.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},ce.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},ce.fx=at.prototype.init,ce.fx.step={};var st,ut,lt,ct,ft=/^(?:toggle|show|hide)$/,pt=/queueHooks$/;function dt(){ut&&(!1===C.hidden&&ie.requestAnimationFrame?ie.requestAnimationFrame(dt):ie.setTimeout(dt,ce.fx.interval),ce.fx.tick())}function ht(){return ie.setTimeout(function(){st=void 0}),st=Date.now()}function gt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=Q[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function vt(e,t,n){for(var r,i=(yt.tweeners[t]||[]).concat(yt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function yt(o,e,t){var n,a,r=0,i=yt.prefilters.length,s=ce.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=st||ht(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:ce.extend({},e),opts:ce.extend(!0,{specialEasing:{},easing:ce.easing._default},t),originalProperties:e,originalOptions:t,startTime:st||ht(),duration:t.duration,tweens:[],createTween:function(e,t){var n=ce.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=F(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=ce.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=yt.prefilters[r].call(l,o,c,l.opts))return v(n.stop)&&(ce._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return ce.map(c,vt,l),v(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),ce.fx.timer(ce.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}ce.Animation=ce.extend(yt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return te(n.elem,e,Y.exec(t),n),n}]},tweener:function(e,t){v(e)?(t=e,e=["*"]):e=e.match(D);for(var n,r=0,i=e.length;r<i;r++)n=e[r],yt.tweeners[n]=yt.tweeners[n]||[],yt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ee(e),v=_.get(e,"fxshow");for(r in n.queue||(null==(a=ce._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,ce.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ft.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||ce.style(e,r)}if((u=!ce.isEmptyObject(t))||!ce.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=_.get(e,"display")),"none"===(c=ce.css(e,"display"))&&(l?c=l:(re([e],!0),l=e.style.display||l,c=ce.css(e,"display"),re([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===ce.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=_.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&re([e],!0),p.done(function(){for(r in g||re([e]),_.remove(e,"fxshow"),d)ce.style(e,r,d[r])})),u=vt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?yt.prefilters.unshift(e):yt.prefilters.push(e)}}),ce.speed=function(e,t,n){var r=e&&"object"==typeof e?ce.extend({},e):{complete:n||!n&&t||v(e)&&e,duration:e,easing:n&&t||t&&!v(t)&&t};return ce.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in ce.fx.speeds?r.duration=ce.fx.speeds[r.duration]:r.duration=ce.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){v(r.old)&&r.old.call(this),r.queue&&ce.dequeue(this,r.queue)},r},ce.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ee).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=ce.isEmptyObject(t),o=ce.speed(e,n,r),a=function(){var e=yt(this,ce.extend({},t),o);(i||_.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=ce.timers,r=_.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&pt.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||ce.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=_.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=ce.timers,o=n?n.length:0;for(t.finish=!0,ce.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),ce.each(["toggle","show","hide"],function(e,r){var i=ce.fn[r];ce.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(gt(r,!0),e,t,n)}}),ce.each({slideDown:gt("show"),slideUp:gt("hide"),slideToggle:gt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){ce.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),ce.timers=[],ce.fx.tick=function(){var e,t=0,n=ce.timers;for(st=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||ce.fx.stop(),st=void 0},ce.fx.timer=function(e){ce.timers.push(e),ce.fx.start()},ce.fx.interval=13,ce.fx.start=function(){ut||(ut=!0,dt())},ce.fx.stop=function(){ut=null},ce.fx.speeds={slow:600,fast:200,_default:400},ce.fn.delay=function(r,e){return r=ce.fx&&ce.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=ie.setTimeout(e,r);t.stop=function(){ie.clearTimeout(n)}})},lt=C.createElement("input"),ct=C.createElement("select").appendChild(C.createElement("option")),lt.type="checkbox",le.checkOn=""!==lt.value,le.optSelected=ct.selected,(lt=C.createElement("input")).value="t",lt.type="radio",le.radioValue="t"===lt.value;var mt,xt=ce.expr.attrHandle;ce.fn.extend({attr:function(e,t){return M(this,ce.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){ce.removeAttr(this,e)})}}),ce.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?ce.prop(e,t,n):(1===o&&ce.isXMLDoc(e)||(i=ce.attrHooks[t.toLowerCase()]||(ce.expr.match.bool.test(t)?mt:void 0)),void 0!==n?null===n?void ce.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=ce.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!le.radioValue&&"radio"===t&&fe(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(D);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),mt={set:function(e,t,n){return!1===t?ce.removeAttr(e,n):e.setAttribute(n,n),n}},ce.each(ce.expr.match.bool.source.match(/\w+/g),function(e,t){var a=xt[t]||ce.find.attr;xt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=xt[o],xt[o]=r,r=null!=a(e,t,n)?o:null,xt[o]=i),r}});var bt=/^(?:input|select|textarea|button)$/i,wt=/^(?:a|area)$/i;function Tt(e){return(e.match(D)||[]).join(" ")}function Ct(e){return e.getAttribute&&e.getAttribute("class")||""}function kt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(D)||[]}ce.fn.extend({prop:function(e,t){return M(this,ce.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[ce.propFix[e]||e]})}}),ce.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&ce.isXMLDoc(e)||(t=ce.propFix[t]||t,i=ce.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=ce.find.attr(e,"tabindex");return t?parseInt(t,10):bt.test(e.nodeName)||wt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),le.optSelected||(ce.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),ce.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){ce.propFix[this.toLowerCase()]=this}),ce.fn.extend({addClass:function(t){var e,n,r,i,o,a;return v(t)?this.each(function(e){ce(this).addClass(t.call(this,e,Ct(this)))}):(e=kt(t)).length?this.each(function(){if(r=Ct(this),n=1===this.nodeType&&" "+Tt(r)+" "){for(o=0;o<e.length;o++)i=e[o],n.indexOf(" "+i+" ")<0&&(n+=i+" ");a=Tt(n),r!==a&&this.setAttribute("class",a)}}):this},removeClass:function(t){var e,n,r,i,o,a;return v(t)?this.each(function(e){ce(this).removeClass(t.call(this,e,Ct(this)))}):arguments.length?(e=kt(t)).length?this.each(function(){if(r=Ct(this),n=1===this.nodeType&&" "+Tt(r)+" "){for(o=0;o<e.length;o++){i=e[o];while(-1<n.indexOf(" "+i+" "))n=n.replace(" "+i+" "," ")}a=Tt(n),r!==a&&this.setAttribute("class",a)}}):this:this.attr("class","")},toggleClass:function(t,n){var e,r,i,o,a=typeof t,s="string"===a||Array.isArray(t);return v(t)?this.each(function(e){ce(this).toggleClass(t.call(this,e,Ct(this),n),n)}):"boolean"==typeof n&&s?n?this.addClass(t):this.removeClass(t):(e=kt(t),this.each(function(){if(s)for(o=ce(this),i=0;i<e.length;i++)r=e[i],o.hasClass(r)?o.removeClass(r):o.addClass(r);else void 0!==t&&"boolean"!==a||((r=Ct(this))&&_.set(this,"__className__",r),this.setAttribute&&this.setAttribute("class",r||!1===t?"":_.get(this,"__className__")||""))}))},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+Tt(Ct(n))+" ").indexOf(t))return!0;return!1}});var St=/\r/g;ce.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=v(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,ce(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=ce.map(t,function(e){return null==e?"":e+""})),(r=ce.valHooks[this.type]||ce.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=ce.valHooks[t.type]||ce.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(St,""):null==e?"":e:void 0}}),ce.extend({valHooks:{option:{get:function(e){var t=ce.find.attr(e,"value");return null!=t?t:Tt(ce.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!fe(n.parentNode,"optgroup"))){if(t=ce(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=ce.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<ce.inArray(ce.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),ce.each(["radio","checkbox"],function(){ce.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<ce.inArray(ce(e).val(),t)}},le.checkOn||(ce.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Et=ie.location,jt={guid:Date.now()},At=/\?/;ce.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{t=(new ie.DOMParser).parseFromString(e,"text/xml")}catch(e){}return n=t&&t.getElementsByTagName("parsererror")[0],t&&!n||ce.error("Invalid XML: "+(n?ce.map(n.childNodes,function(e){return e.textContent}).join("\n"):e)),t};var Dt=/^(?:focusinfocus|focusoutblur)$/,Nt=function(e){e.stopPropagation()};ce.extend(ce.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||C],d=ue.call(e,"type")?e.type:e,h=ue.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||C,3!==n.nodeType&&8!==n.nodeType&&!Dt.test(d+ce.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[ce.expando]?e:new ce.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:ce.makeArray(t,[e]),c=ce.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!y(n)){for(s=c.delegateType||d,Dt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||C)&&p.push(a.defaultView||a.parentWindow||ie)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(_.get(o,"events")||Object.create(null))[e.type]&&_.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&$(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!$(n)||u&&v(n[d])&&!y(n)&&((a=n[u])&&(n[u]=null),ce.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Nt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Nt),ce.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=ce.extend(new ce.Event,n,{type:e,isSimulated:!0});ce.event.trigger(r,null,t)}}),ce.fn.extend({trigger:function(e,t){return this.each(function(){ce.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return ce.event.trigger(e,t,n,!0)}});var qt=/\[\]$/,Lt=/\r?\n/g,Ht=/^(?:submit|button|image|reset|file)$/i,Ot=/^(?:input|select|textarea|keygen)/i;function Pt(n,e,r,i){var t;if(Array.isArray(e))ce.each(e,function(e,t){r||qt.test(n)?i(n,t):Pt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==x(e))i(n,e);else for(t in e)Pt(n+"["+t+"]",e[t],r,i)}ce.param=function(e,t){var n,r=[],i=function(e,t){var n=v(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!ce.isPlainObject(e))ce.each(e,function(){i(this.name,this.value)});else for(n in e)Pt(n,e[n],t,i);return r.join("&")},ce.fn.extend({serialize:function(){return ce.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=ce.prop(this,"elements");return e?ce.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!ce(this).is(":disabled")&&Ot.test(this.nodeName)&&!Ht.test(e)&&(this.checked||!we.test(e))}).map(function(e,t){var n=ce(this).val();return null==n?null:Array.isArray(n)?ce.map(n,function(e){return{name:t.name,value:e.replace(Lt,"\r\n")}}):{name:t.name,value:n.replace(Lt,"\r\n")}}).get()}});var Mt=/%20/g,Rt=/#.*$/,It=/([?&])_=[^&]*/,Wt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ft=/^(?:GET|HEAD)$/,$t=/^\/\//,Bt={},_t={},zt="*/".concat("*"),Xt=C.createElement("a");function Ut(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(D)||[];if(v(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Vt(t,i,o,a){var s={},u=t===_t;function l(e){var r;return s[e]=!0,ce.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function Gt(e,t){var n,r,i=ce.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&ce.extend(!0,e,r),e}Xt.href=Et.href,ce.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":zt,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":ce.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Gt(Gt(e,ce.ajaxSettings),t):Gt(ce.ajaxSettings,e)},ajaxPrefilter:Ut(Bt),ajaxTransport:Ut(_t),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=ce.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?ce(y):ce.event,x=ce.Deferred(),b=ce.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Wt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace($t,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(D)||[""],null==v.crossDomain){r=C.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Xt.protocol+"//"+Xt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=ce.param(v.data,v.traditional)),Vt(Bt,v,t,T),h)return T;for(i in(g=ce.event&&v.global)&&0==ce.active++&&ce.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Ft.test(v.type),f=v.url.replace(Rt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Mt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(At.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(It,"$1"),o=(At.test(f)?"&":"?")+"_="+jt.guid+++o),v.url=f+o),v.ifModified&&(ce.lastModified[f]&&T.setRequestHeader("If-Modified-Since",ce.lastModified[f]),ce.etag[f]&&T.setRequestHeader("If-None-Match",ce.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+zt+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Vt(_t,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=ie.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&ie.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<ce.inArray("script",v.dataTypes)&&ce.inArray("json",v.dataTypes)<0&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(ce.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(ce.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--ce.active||ce.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return ce.get(e,t,n,"json")},getScript:function(e,t){return ce.get(e,void 0,t,"script")}}),ce.each(["get","post"],function(e,i){ce[i]=function(e,t,n,r){return v(t)&&(r=r||n,n=t,t=void 0),ce.ajax(ce.extend({url:e,type:i,dataType:r,data:t,success:n},ce.isPlainObject(e)&&e))}}),ce.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),ce._evalUrl=function(e,t,n){return ce.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){ce.globalEval(e,t,n)}})},ce.fn.extend({wrapAll:function(e){var t;return this[0]&&(v(e)&&(e=e.call(this[0])),t=ce(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return v(n)?this.each(function(e){ce(this).wrapInner(n.call(this,e))}):this.each(function(){var e=ce(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=v(t);return this.each(function(e){ce(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){ce(this).replaceWith(this.childNodes)}),this}}),ce.expr.pseudos.hidden=function(e){return!ce.expr.pseudos.visible(e)},ce.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},ce.ajaxSettings.xhr=function(){try{return new ie.XMLHttpRequest}catch(e){}};var Yt={0:200,1223:204},Qt=ce.ajaxSettings.xhr();le.cors=!!Qt&&"withCredentials"in Qt,le.ajax=Qt=!!Qt,ce.ajaxTransport(function(i){var o,a;if(le.cors||Qt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Yt[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&ie.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),ce.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),ce.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return ce.globalEval(e),e}}}),ce.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),ce.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=ce("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),C.head.appendChild(r[0])},abort:function(){i&&i()}}});var Jt,Kt=[],Zt=/(=)\?(?=&|$)|\?\?/;ce.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Kt.pop()||ce.expando+"_"+jt.guid++;return this[e]=!0,e}}),ce.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Zt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Zt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=v(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Zt,"$1"+r):!1!==e.jsonp&&(e.url+=(At.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||ce.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=ie[r],ie[r]=function(){o=arguments},n.always(function(){void 0===i?ce(ie).removeProp(r):ie[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Kt.push(r)),o&&v(i)&&i(o[0]),o=i=void 0}),"script"}),le.createHTMLDocument=((Jt=C.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Jt.childNodes.length),ce.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(le.createHTMLDocument?((r=(t=C.implementation.createHTMLDocument("")).createElement("base")).href=C.location.href,t.head.appendChild(r)):t=C),o=!n&&[],(i=w.exec(e))?[t.createElement(i[1])]:(i=Ae([e],t,o),o&&o.length&&ce(o).remove(),ce.merge([],i.childNodes)));var r,i,o},ce.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=Tt(e.slice(s)),e=e.slice(0,s)),v(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&ce.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?ce("<div>").append(ce.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},ce.expr.pseudos.animated=function(t){return ce.grep(ce.timers,function(e){return t===e.elem}).length},ce.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=ce.css(e,"position"),c=ce(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=ce.css(e,"top"),u=ce.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),v(t)&&(t=t.call(e,n,ce.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},ce.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){ce.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===ce.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===ce.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=ce(e).offset()).top+=ce.css(e,"borderTopWidth",!0),i.left+=ce.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-ce.css(r,"marginTop",!0),left:t.left-i.left-ce.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===ce.css(e,"position"))e=e.offsetParent;return e||J})}}),ce.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;ce.fn[t]=function(e){return M(this,function(e,t,n){var r;if(y(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),ce.each(["top","left"],function(e,n){ce.cssHooks[n]=Ye(le.pixelPosition,function(e,t){if(t)return t=Ge(e,n),_e.test(t)?ce(e).position()[n]+"px":t})}),ce.each({Height:"height",Width:"width"},function(a,s){ce.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){ce.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return M(this,function(e,t,n){var r;return y(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?ce.css(e,t,i):ce.style(e,t,n,i)},s,n?e:void 0,n)}})}),ce.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){ce.fn[t]=function(e){return this.on(t,e)}}),ce.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.on("mouseenter",e).on("mouseleave",t||e)}}),ce.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){ce.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var en=/^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;ce.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),v(e))return r=ae.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(ae.call(arguments)))}).guid=e.guid=e.guid||ce.guid++,i},ce.holdReady=function(e){e?ce.readyWait++:ce.ready(!0)},ce.isArray=Array.isArray,ce.parseJSON=JSON.parse,ce.nodeName=fe,ce.isFunction=v,ce.isWindow=y,ce.camelCase=F,ce.type=x,ce.now=Date.now,ce.isNumeric=function(e){var t=ce.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},ce.trim=function(e){return null==e?"":(e+"").replace(en,"$1")}, true&&!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return ce}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));var tn=ie.jQuery,nn=ie.$;return ce.noConflict=function(e){return ie.$===ce&&(ie.$=nn),e&&ie.jQuery===ce&&(ie.jQuery=tn),ce},"undefined"==typeof e&&(ie.jQuery=ie.$=ce),ce});


/***/ }),

/***/ "./node_modules/just-debounce/index.js":
/*!*********************************************!*\
  !*** ./node_modules/just-debounce/index.js ***!
  \*********************************************/
/***/ ((module) => {

module.exports = debounce;

function debounce(fn, delay, atStart, guarantee) {
  var timeout;
  var args;
  var self;

  return function debounced() {
    self = this;
    args = Array.prototype.slice.call(arguments);

    if (timeout && (atStart || guarantee)) {
      return;
    } else if (!atStart) {
      clear();

      timeout = setTimeout(run, delay);
      return timeout;
    }

    timeout = setTimeout(clear, delay);
    fn.apply(self, args);

    function run() {
      clear();
      fn.apply(self, args);
    }

    function clear() {
      clearTimeout(timeout);
      timeout = null;
    }
  };
}


/***/ }),

/***/ "./node_modules/lodash._reinterpolate/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash._reinterpolate/index.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

module.exports = reInterpolate;


/***/ }),

/***/ "./node_modules/lodash.template/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.template/index.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = __webpack_require__(/*! lodash._reinterpolate */ "./node_modules/lodash._reinterpolate/index.js"),
    templateSettings = __webpack_require__(/*! lodash.templatesettings */ "./node_modules/lodash.templatesettings/index.js");

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    domExcTag = '[object DOMException]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max,
    nativeNow = Date.now;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);

  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
  // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
  var sourceURL = hasOwnProperty.call(options, 'sourceURL')
    ? ('//# sourceURL=' +
       (options.sourceURL + '').replace(/[\r\n]/g, ' ') +
       '\n')
    : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  // Like with sourceURL, we take care to not check the option's prototype,
  // as this configuration is a code injection vector.
  var variable = hasOwnProperty.call(options, 'variable') && options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = template;


/***/ }),

/***/ "./node_modules/lodash.templatesettings/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/lodash.templatesettings/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = __webpack_require__(/*! lodash._reinterpolate */ "./node_modules/lodash._reinterpolate/index.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]';

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g,
    reEvaluate = /<%([\s\S]+?)%>/g;

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = templateSettings;


/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyOf.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_basePropertyOf.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "./node_modules/lodash/_baseValues.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseValues.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js");

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_createAssigner.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createAssigner.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "./node_modules/lodash/_createCtor.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createCtor.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtor(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

module.exports = createCtor;


/***/ }),

/***/ "./node_modules/lodash/_createFind.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createFind.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),

/***/ "./node_modules/lodash/_createWrap.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createWrap.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js"),
    createCtor = __webpack_require__(/*! ./_createCtor */ "./node_modules/lodash/_createCtor.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG,
      Ctor = createCtor(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

module.exports = createPartial;


/***/ }),

/***/ "./node_modules/lodash/_customDefaultsAssignIn.js":
/*!********************************************************!*\
  !*** ./node_modules/lodash/_customDefaultsAssignIn.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

module.exports = customDefaultsAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_escapeHtmlChar.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_escapeHtmlChar.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePropertyOf = __webpack_require__(/*! ./_basePropertyOf */ "./node_modules/lodash/_basePropertyOf.js");

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

module.exports = escapeHtmlChar;


/***/ }),

/***/ "./node_modules/lodash/_escapeStringChar.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_escapeStringChar.js ***!
  \**************************************************/
/***/ ((module) => {

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

module.exports = escapeStringChar;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "./node_modules/lodash/_getHolder.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getHolder.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "./node_modules/lodash/_reEscape.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_reEscape.js ***!
  \******************************************/
/***/ ((module) => {

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

module.exports = reEscape;


/***/ }),

/***/ "./node_modules/lodash/_reEvaluate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_reEvaluate.js ***!
  \********************************************/
/***/ ((module) => {

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

module.exports = reEvaluate;


/***/ }),

/***/ "./node_modules/lodash/_reInterpolate.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_reInterpolate.js ***!
  \***********************************************/
/***/ ((module) => {

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

module.exports = reInterpolate;


/***/ }),

/***/ "./node_modules/lodash/_replaceHolders.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_replaceHolders.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/assignInWith.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/assignInWith.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

module.exports = assignInWith;


/***/ }),

/***/ "./node_modules/lodash/attempt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/attempt.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isError = __webpack_require__(/*! ./isError */ "./node_modules/lodash/isError.js");

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

module.exports = attempt;


/***/ }),

/***/ "./node_modules/lodash/bind.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/bind.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    createWrap = __webpack_require__(/*! ./_createWrap */ "./node_modules/lodash/_createWrap.js"),
    getHolder = __webpack_require__(/*! ./_getHolder */ "./node_modules/lodash/_getHolder.js"),
    replaceHolders = __webpack_require__(/*! ./_replaceHolders */ "./node_modules/lodash/_replaceHolders.js");

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_PARTIAL_FLAG = 32;

/**
 * Creates a function that invokes `func` with the `this` binding of `thisArg`
 * and `partials` prepended to the arguments it receives.
 *
 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for partially applied arguments.
 *
 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
 * property of bound functions.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new bound function.
 * @example
 *
 * function greet(greeting, punctuation) {
 *   return greeting + ' ' + this.user + punctuation;
 * }
 *
 * var object = { 'user': 'fred' };
 *
 * var bound = _.bind(greet, object, 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * // Bound with placeholders.
 * var bound = _.bind(greet, object, _, '!');
 * bound('hi');
 * // => 'hi fred!'
 */
var bind = baseRest(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bind));
    bitmask |= WRAP_PARTIAL_FLAG;
  }
  return createWrap(func, bitmask, thisArg, partials, holders);
});

// Assign default placeholders.
bind.placeholder = {};

module.exports = bind;


/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "./node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/escape.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/escape.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escapeHtmlChar = __webpack_require__(/*! ./_escapeHtmlChar */ "./node_modules/lodash/_escapeHtmlChar.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;


/***/ }),

/***/ "./node_modules/lodash/find.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/find.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createFind = __webpack_require__(/*! ./_createFind */ "./node_modules/lodash/_createFind.js"),
    findIndex = __webpack_require__(/*! ./findIndex */ "./node_modules/lodash/findIndex.js");

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),

/***/ "./node_modules/lodash/findIndex.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/findIndex.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    toInteger = __webpack_require__(/*! ./toInteger */ "./node_modules/lodash/toInteger.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),

/***/ "./node_modules/lodash/isError.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isError.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js");

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}

module.exports = isError;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),

/***/ "./node_modules/lodash/template.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/template.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignInWith = __webpack_require__(/*! ./assignInWith */ "./node_modules/lodash/assignInWith.js"),
    attempt = __webpack_require__(/*! ./attempt */ "./node_modules/lodash/attempt.js"),
    baseValues = __webpack_require__(/*! ./_baseValues */ "./node_modules/lodash/_baseValues.js"),
    customDefaultsAssignIn = __webpack_require__(/*! ./_customDefaultsAssignIn */ "./node_modules/lodash/_customDefaultsAssignIn.js"),
    escapeStringChar = __webpack_require__(/*! ./_escapeStringChar */ "./node_modules/lodash/_escapeStringChar.js"),
    isError = __webpack_require__(/*! ./isError */ "./node_modules/lodash/isError.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js"),
    reInterpolate = __webpack_require__(/*! ./_reInterpolate */ "./node_modules/lodash/_reInterpolate.js"),
    templateSettings = __webpack_require__(/*! ./templateSettings */ "./node_modules/lodash/templateSettings.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/** Error message constants. */
var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to validate the `validate` option in `_.template` variable.
 *
 * Forbids characters which could potentially change the meaning of the function argument definition:
 * - "()," (modification of function parameters)
 * - "=" (default value)
 * - "[]{}" (destructuring of function parameters)
 * - "/" (beginning of a comment)
 * - whitespace
 */
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);

  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.
  var sourceURL = hasOwnProperty.call(options, 'sourceURL')
    ? ('//# sourceURL=' +
       (options.sourceURL + '').replace(/\s/g, ' ') +
       '\n')
    : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = hasOwnProperty.call(options, 'variable') && options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }

  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

module.exports = template;


/***/ }),

/***/ "./node_modules/lodash/templateSettings.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/templateSettings.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escape = __webpack_require__(/*! ./escape */ "./node_modules/lodash/escape.js"),
    reEscape = __webpack_require__(/*! ./_reEscape */ "./node_modules/lodash/_reEscape.js"),
    reEvaluate = __webpack_require__(/*! ./_reEvaluate */ "./node_modules/lodash/_reEvaluate.js"),
    reInterpolate = __webpack_require__(/*! ./_reInterpolate */ "./node_modules/lodash/_reInterpolate.js");

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

module.exports = templateSettings;


/***/ }),

/***/ "./node_modules/lodash/toInteger.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/toInteger.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(/*! ./util.inspect */ "?4f7e");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof __webpack_require__.g !== 'undefined' && obj === __webpack_require__.g)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ "./node_modules/parse-int/index.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-int/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isInteger = __webpack_require__(/*! is-integer */ "./node_modules/is-integer/index.js")
var isIntegerRegex = /^-?\d+$/

module.exports = function parseIntStrict (integer) {
  if (typeof integer === 'number') {
    return isInteger(integer) ? integer : undefined
  }
  if (typeof integer === 'string') {
    return isIntegerRegex.test(integer) ? parseInt(integer, 10) : undefined
  }
}


/***/ }),

/***/ "./node_modules/parse-year/index.js":
/*!******************************************!*\
  !*** ./node_modules/parse-year/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var parseIntStrict = __webpack_require__(/*! parse-int */ "./node_modules/parse-int/index.js")
var expandYear = __webpack_require__(/*! expand-year */ "./node_modules/expand-year/index.js")

module.exports = function parseYear (year, expand, now) {
  year = parseIntStrict(year)
  if (year == null) return
  if (!expand) return year
  return expandYear(year, now)
}


/***/ }),

/***/ "./node_modules/punycode/punycode.js":
/*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ "./node_modules/set-function-length/index.js":
/*!***************************************************!*\
  !*** ./node_modules/set-function-length/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var define = __webpack_require__(/*! define-data-property */ "./node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('.').listGetNode} */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	for (; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			// eslint-disable-next-line no-extra-parens
			curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

/** @type {import('.').listGet} */
var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('.').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('.').ListNode<typeof value>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('.').listHas} */
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @type {WeakMap<object, unknown>} */ var $wm;
	/** @type {Map<object, unknown>} */ var $m;
	/** @type {import('.').RootNode<unknown>} */ var $o;

	/** @type {import('.').Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ "./node_modules/slick-carousel/slick/slick.js":
/*!****************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.1
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
;(function(factory) {
    'use strict';
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}

}(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this, dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function(slider, i) {
                    return $('<button type="button" />').text(i + 1);
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                focusOnChange: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnFocus: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                useTransform: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                scrolling: false,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                swiping: false,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.focussed = false;
            _.interrupted = false;
            _.hidden = 'hidden';
            _.paused = true;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, settings, dataSettings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


            _.registerBreakpoints();
            _.init(true);

        }

        return Slick;

    }());

    Slick.prototype.activateADA = function() {
        var _ = this;

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });

    };

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof(index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function(targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -(_.currentLeft);
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' +
                                now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' +
                                now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function() {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function() {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    };

    Slick.prototype.getNavTarget = function() {

        var _ = this,
            asNavFor = _.options.asNavFor;

        if ( asNavFor && asNavFor !== null ) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        return asNavFor;

    };

    Slick.prototype.asNavFor = function(index) {

        var _ = this,
            asNavFor = _.getNavTarget();

        if ( asNavFor !== null && typeof asNavFor === 'object' ) {
            asNavFor.each(function() {
                var target = $(this).slick('getSlick');
                if(!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }

    };

    Slick.prototype.applyTransition = function(slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.autoPlay = function() {

        var _ = this;

        _.autoPlayClear();

        if ( _.slideCount > _.options.slidesToShow ) {
            _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );
        }

    };

    Slick.prototype.autoPlayClear = function() {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    };

    Slick.prototype.autoPlayIterator = function() {

        var _ = this,
            slideTo = _.currentSlide + _.options.slidesToScroll;

        if ( !_.paused && !_.interrupted && !_.focussed ) {

            if ( _.options.infinite === false ) {

                if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {
                    _.direction = 0;
                }

                else if ( _.direction === 0 ) {

                    slideTo = _.currentSlide - _.options.slidesToScroll;

                    if ( _.currentSlide - 1 === 0 ) {
                        _.direction = 1;
                    }

                }

            }

            _.slideHandler( slideTo );

        }

    };

    Slick.prototype.buildArrows = function() {

        var _ = this;

        if (_.options.arrows === true ) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if( _.slideCount > _.options.slidesToShow ) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow
                        .addClass('slick-disabled')
                        .attr('aria-disabled', 'true');
                }

            } else {

                _.$prevArrow.add( _.$nextArrow )

                    .addClass('slick-hidden')
                    .attr({
                        'aria-disabled': 'true',
                        'tabindex': '-1'
                    });

            }

        }

    };

    Slick.prototype.buildDots = function() {

        var _ = this,
            i, dot;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$slider.addClass('slick-dotted');

            dot = $('<ul />').addClass(_.options.dotsClass);

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
            }

            _.$dots = dot.appendTo(_.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active');

        }

    };

    Slick.prototype.buildOut = function() {

        var _ = this;

        _.$slides =
            _.$slider
                .children( _.options.slide + ':not(.slick-cloned)')
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function(index, element) {
            $(element)
                .attr('data-slick-index', index)
                .data('originalStyling', $(element).attr('style') || '');
        });

        _.$slider.addClass('slick-slider');

        _.$slideTrack = (_.slideCount === 0) ?
            $('<div class="slick-track"/>').appendTo(_.$slider) :
            _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap(
            '<div class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();


        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    };

    Slick.prototype.buildRows = function() {

        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if(_.options.rows > 0) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(
                originalSlides.length / slidesPerSection
            );

            for(a = 0; a < numOfSlides; a++){
                var slide = document.createElement('div');
                for(b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for(c = 0; c < _.options.slidesPerRow; c++) {
                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children()
                .css({
                    'width':(100 / _.options.slidesPerRow) + '%',
                    'display': 'inline-block'
                });

        }

    };

    Slick.prototype.checkResponsive = function(initial, forceUpdate) {

        var _ = this,
            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if ( _.options.responsive &&
            _.options.responsive.length &&
            _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint =
                            targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings,
                                _.breakpointSettings[
                                    targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings,
                            _.breakpointSettings[
                                targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if( !initial && triggerBreakpoint !== false ) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }

    };

    Slick.prototype.changeSlide = function(event, dontAnimate) {

        var _ = this,
            $target = $(event.currentTarget),
            indexOffset, slideOffset, unevenOffset;

        // If target is a link, prevent default action.
        if($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if(!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 :
                    event.data.index || $target.index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                $target.children().trigger('focus');
                break;

            default:
                return;
        }

    };

    Slick.prototype.checkNavigable = function(index) {

        var _ = this,
            navigables, prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function() {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots)
                .off('click.slick', _.changeSlide)
                .off('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .off('mouseleave.slick', $.proxy(_.interrupt, _, false));

            if (_.options.accessibility === true) {
                _.$dots.off('keydown.slick', _.keyHandler);
            }
        }

        _.$slider.off('focus.slick blur.slick');

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
                _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
            }
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.cleanUpSlideEvents();

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.cleanUpSlideEvents = function() {

        var _ = this;

        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

    };

    Slick.prototype.cleanUpRows = function() {

        var _ = this, originalSlides;

        if(_.options.rows > 0) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.empty().append(originalSlides);
        }

    };

    Slick.prototype.clickHandler = function(event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }

    };

    Slick.prototype.destroy = function(refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }

        if ( _.$prevArrow && _.$prevArrow.length ) {

            _.$prevArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.prevArrow )) {
                _.$prevArrow.remove();
            }
        }

        if ( _.$nextArrow && _.$nextArrow.length ) {

            _.$nextArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.nextArrow )) {
                _.$nextArrow.remove();
            }
        }


        if (_.$slides) {

            _.$slides
                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
                .removeAttr('aria-hidden')
                .removeAttr('data-slick-index')
                .each(function(){
                    $(this).attr('style', $(this).data('originalStyling'));
                });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');
        _.$slider.removeClass('slick-dotted');

        _.unslicked = true;

        if(!refresh) {
            _.$slider.trigger('destroy', [_]);
        }

    };

    Slick.prototype.disableTransition = function(slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function() {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    };

    Slick.prototype.fadeSlideOut = function(slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });

        }

    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

        var _ = this;

        if (filter !== null) {

            _.$slidesCache = _.$slides;

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.focusHandler = function() {

        var _ = this;

        _.$slider
            .off('focus.slick blur.slick')
            .on('focus.slick blur.slick', '*', function(event) {

            event.stopImmediatePropagation();
            var $sf = $(this);

            setTimeout(function() {

                if( _.options.pauseOnFocus ) {
                    _.focussed = $sf.is(':focus');
                    _.autoPlay();
                }

            }, 0);

        });
    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

        var _ = this;
        return _.currentSlide;

    };

    Slick.prototype.getDotCount = function() {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            if (_.slideCount <= _.options.slidesToShow) {
                 ++pagerQty;
            } else {
                while (breakPoint < _.slideCount) {
                    ++pagerQty;
                    breakPoint = counter + _.options.slidesToScroll;
                    counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                }
            }
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else if(!_.options.asNavFor) {
            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        }else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;

    };

    Slick.prototype.getLeft = function(slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide,
            coef;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                coef = -1

                if (_.options.vertical === true && _.options.centerMode === true) {
                    if (_.options.slidesToShow === 2) {
                        coef = -1.5;
                    } else if (_.options.slidesToShow === 1) {
                        coef = -2
                    }
                }
                verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                    } else {
                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
            _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);
        } else if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            if (_.options.rtl === true) {
                if (targetSlide[0]) {
                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                } else {
                    targetLeft =  0;
                }
            } else {
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            }

            if (_.options.centerMode === true) {
                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }

                if (_.options.rtl === true) {
                    if (targetSlide[0]) {
                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                    } else {
                        targetLeft =  0;
                    }
                } else {
                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                }

                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;

    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

        var _ = this;

        return _.options[option];

    };

    Slick.prototype.getNavigableIndexes = function() {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;

    };

    Slick.prototype.getSlick = function() {

        return this;

    };

    Slick.prototype.getSlideCount = function() {

        var _ = this,
            slidesTraversed, swipedSlide, centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;

        } else {
            return _.options.slidesToScroll;
        }

    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);

    };

    Slick.prototype.init = function(creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(true);
            _.focusHandler();

        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

        if ( _.options.autoplay ) {

            _.paused = false;
            _.autoPlay();

        }

    };

    Slick.prototype.initADA = function() {
        var _ = this,
                numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
                tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
                    return (val >= 0) && (val < _.slideCount);
                });

        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        if (_.$dots !== null) {
            _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
                var slideControlIndex = tabControlIndexes.indexOf(i);

                $(this).attr({
                    'role': 'tabpanel',
                    'id': 'slick-slide' + _.instanceUid + i,
                    'tabindex': -1
                });

                if (slideControlIndex !== -1) {
                   var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex
                   if ($('#' + ariaButtonControl).length) {
                     $(this).attr({
                         'aria-describedby': ariaButtonControl
                     });
                   }
                }
            });

            _.$dots.attr('role', 'tablist').find('li').each(function(i) {
                var mappedSlideIndex = tabControlIndexes[i];

                $(this).attr({
                    'role': 'presentation'
                });

                $(this).find('button').first().attr({
                    'role': 'tab',
                    'id': 'slick-slide-control' + _.instanceUid + i,
                    'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
                    'aria-label': (i + 1) + ' of ' + numDotGroups,
                    'aria-selected': null,
                    'tabindex': '-1'
                });

            }).eq(_.currentSlide).find('button').attr({
                'aria-selected': 'true',
                'tabindex': '0'
            }).end();
        }

        for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {
          if (_.options.focusOnChange) {
            _.$slides.eq(i).attr({'tabindex': '0'});
          } else {
            _.$slides.eq(i).removeAttr('tabindex');
          }
        }

        _.activateADA();

    };

    Slick.prototype.initArrowEvents = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow
               .off('click.slick')
               .on('click.slick', {
                    message: 'previous'
               }, _.changeSlide);
            _.$nextArrow
               .off('click.slick')
               .on('click.slick', {
                    message: 'next'
               }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow.on('keydown.slick', _.keyHandler);
                _.$nextArrow.on('keydown.slick', _.keyHandler);
            }
        }

    };

    Slick.prototype.initDotEvents = function() {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$dots.on('keydown.slick', _.keyHandler);
            }
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {

            $('li', _.$dots)
                .on('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initSlideEvents = function() {

        var _ = this;

        if ( _.options.pauseOnHover ) {

            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initializeEvents = function() {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();
        _.initSlideEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(_.setPosition);

    };

    Slick.prototype.initUI = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();

        }

    };

    Slick.prototype.keyHandler = function(event) {

        var _ = this;
         //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'next' :  'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'previous' : 'next'
                    }
                });
            }
        }

    };

    Slick.prototype.lazyLoad = function() {

        var _ = this,
            loadRange, cloneRange, rangeStart, rangeEnd;

        function loadImages(imagesScope) {

            $('img[data-lazy]', imagesScope).each(function() {

                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageSrcSet = $(this).attr('data-srcset'),
                    imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function() {

                    image
                        .animate({ opacity: 0 }, 100, function() {

                            if (imageSrcSet) {
                                image
                                    .attr('srcset', imageSrcSet );

                                if (imageSizes) {
                                    image
                                        .attr('sizes', imageSizes );
                                }
                            }

                            image
                                .attr('src', imageSource)
                                .animate({ opacity: 1 }, 200, function() {
                                    image
                                        .removeAttr('data-lazy data-srcset data-sizes')
                                        .removeClass('slick-loading');
                                });
                            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                        });

                };

                imageToLoad.onerror = function() {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                };

                imageToLoad.src = imageSource;

            });

        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

        if (_.options.lazyLoad === 'anticipated') {
            var prevSlide = rangeStart - 1,
                nextSlide = rangeEnd,
                $slides = _.$slider.find('.slick-slide');

            for (var i = 0; i < _.options.slidesToScroll; i++) {
                if (prevSlide < 0) prevSlide = _.slideCount - 1;
                loadRange = loadRange.add($slides.eq(prevSlide));
                loadRange = loadRange.add($slides.eq(nextSlide));
                prevSlide--;
                nextSlide++;
            }
        }

        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else
        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }

    };

    Slick.prototype.loadSlider = function() {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    };

    Slick.prototype.next = Slick.prototype.slickNext = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });

    };

    Slick.prototype.orientationChange = function() {

        var _ = this;

        _.checkResponsive();
        _.setPosition();

    };

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;

    };

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

        var _ = this;

        _.autoPlay();
        _.options.autoplay = true;
        _.paused = false;
        _.focussed = false;
        _.interrupted = false;

    };

    Slick.prototype.postSlide = function(index) {

        var _ = this;

        if( !_.unslicked ) {

            _.$slider.trigger('afterChange', [_, index]);

            _.animating = false;

            if (_.slideCount > _.options.slidesToShow) {
                _.setPosition();
            }

            _.swipeLeft = null;

            if ( _.options.autoplay ) {
                _.autoPlay();
            }

            if (_.options.accessibility === true) {
                _.initADA();

                if (_.options.focusOnChange) {
                    var $currentSlide = $(_.$slides.get(_.currentSlide));
                    $currentSlide.attr('tabindex', 0).focus();
                }
            }

        }

    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });

    };

    Slick.prototype.preventDefault = function(event) {

        event.preventDefault();

    };

    Slick.prototype.progressiveLazyLoad = function( tryCount ) {

        tryCount = tryCount || 1;

        var _ = this,
            $imgsToLoad = $( 'img[data-lazy]', _.$slider ),
            image,
            imageSource,
            imageSrcSet,
            imageSizes,
            imageToLoad;

        if ( $imgsToLoad.length ) {

            image = $imgsToLoad.first();
            imageSource = image.attr('data-lazy');
            imageSrcSet = image.attr('data-srcset');
            imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');
            imageToLoad = document.createElement('img');

            imageToLoad.onload = function() {

                if (imageSrcSet) {
                    image
                        .attr('srcset', imageSrcSet );

                    if (imageSizes) {
                        image
                            .attr('sizes', imageSizes );
                    }
                }

                image
                    .attr( 'src', imageSource )
                    .removeAttr('data-lazy data-srcset data-sizes')
                    .removeClass('slick-loading');

                if ( _.options.adaptiveHeight === true ) {
                    _.setPosition();
                }

                _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);
                _.progressiveLazyLoad();

            };

            imageToLoad.onerror = function() {

                if ( tryCount < 3 ) {

                    /**
                     * try to load the image 3 times,
                     * leave a slight delay so we don't get
                     * servers blocking the request.
                     */
                    setTimeout( function() {
                        _.progressiveLazyLoad( tryCount + 1 );
                    }, 500 );

                } else {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                    _.progressiveLazyLoad();

                }

            };

            imageToLoad.src = imageSource;

        } else {

            _.$slider.trigger('allImagesLoaded', [ _ ]);

        }

    };

    Slick.prototype.refresh = function( initializing ) {

        var _ = this, currentSlide, lastVisibleIndex;

        lastVisibleIndex = _.slideCount - _.options.slidesToShow;

        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {
            _.currentSlide = lastVisibleIndex;
        }

        // if less slides than to show, go to start.
        if ( _.slideCount <= _.options.slidesToShow ) {
            _.currentSlide = 0;

        }

        currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, { currentSlide: currentSlide });

        _.init();

        if( !initializing ) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);

        }

    };

    Slick.prototype.registerBreakpoints = function() {

        var _ = this, breakpoint, currentBreakpoint, l,
            responsiveSettings = _.options.responsive || null;

        if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {

            _.respondTo = _.options.respondTo || 'window';

            for ( breakpoint in responsiveSettings ) {

                l = _.breakpoints.length-1;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {
                    currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while( l >= 0 ) {
                        if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
                            _.breakpoints.splice(l,1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

                }

            }

            _.breakpoints.sort(function(a, b) {
                return ( _.options.mobileFirst ) ? a-b : b-a;
            });

        }

    };

    Slick.prototype.reinit = function() {

        var _ = this;

        _.$slides =
            _.$slideTrack
                .children(_.options.slide)
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        _.setPosition();
        _.focusHandler();

        _.paused = !_.options.autoplay;
        _.autoPlay();

        _.$slider.trigger('reInit', [_]);

    };

    Slick.prototype.resize = function() {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if( !_.unslicked ) { _.setPosition(); }
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.setCSS = function(position) {

        var _ = this,
            positionProps = {},
            x, y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    };

    Slick.prototype.setDimensions = function() {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();


        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

    };

    Slick.prototype.setFade = function() {

        var _ = this,
            targetLeft;

        _.$slides.each(function(index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });

    };

    Slick.prototype.setHeight = function() {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }

    };

    Slick.prototype.setOption =
    Slick.prototype.slickSetOption = function() {

        /**
         * accepts arguments in format of:
         *
         *  - for changing a single option's value:
         *     .slick("setOption", option, value, refresh )
         *
         *  - for changing a set of responsive options:
         *     .slick("setOption", 'responsive', [{}, ...], refresh )
         *
         *  - for updating multiple values at once (not responsive)
         *     .slick("setOption", { 'option': value, ... }, refresh )
         */

        var _ = this, l, item, option, value, refresh = false, type;

        if( $.type( arguments[0] ) === 'object' ) {

            option =  arguments[0];
            refresh = arguments[1];
            type = 'multiple';

        } else if ( $.type( arguments[0] ) === 'string' ) {

            option =  arguments[0];
            value = arguments[1];
            refresh = arguments[2];

            if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {

                type = 'responsive';

            } else if ( typeof arguments[1] !== 'undefined' ) {

                type = 'single';

            }

        }

        if ( type === 'single' ) {

            _.options[option] = value;


        } else if ( type === 'multiple' ) {

            $.each( option , function( opt, val ) {

                _.options[opt] = val;

            });


        } else if ( type === 'responsive' ) {

            for ( item in value ) {

                if( $.type( _.options.responsive ) !== 'array' ) {

                    _.options.responsive = [ value[item] ];

                } else {

                    l = _.options.responsive.length-1;

                    // loop through the responsive object and splice out duplicates.
                    while( l >= 0 ) {

                        if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {

                            _.options.responsive.splice(l,1);

                        }

                        l--;

                    }

                    _.options.responsive.push( value[item] );

                }

            }

        }

        if ( refresh ) {

            _.unload();
            _.reinit();

        }

    };

    Slick.prototype.setPosition = function() {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);

    };

    Slick.prototype.setProps = function() {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined ||
            bodyStyle.MozTransition !== undefined ||
            bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if ( _.options.fade ) {
            if ( typeof _.options.zIndex === 'number' ) {
                if( _.options.zIndex < 3 ) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
    };


    Slick.prototype.setSlideClasses = function(index) {

        var _ = this,
            centerOffset, allSlides, indexOffset, remainder;

        allSlides = _.$slider
            .find('.slick-slide')
            .removeClass('slick-active slick-center slick-current')
            .attr('aria-hidden', 'true');

        _.$slides
            .eq(index)
            .addClass('slick-current');

        if (_.options.centerMode === true) {

            var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
                    _.$slides
                        .slice(index - centerOffset + evenCoef, index + centerOffset + 1)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides
                        .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

                if (index === 0) {

                    allSlides
                        .eq(allSlides.length - 1 - _.options.slidesToShow)
                        .addClass('slick-center');

                } else if (index === _.slideCount - 1) {

                    allSlides
                        .eq(_.options.slidesToShow)
                        .addClass('slick-center');

                }

            }

            _.$slides
                .eq(index)
                .addClass('slick-center');

        } else {

            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

                _.$slides
                    .slice(index, index + _.options.slidesToShow)
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                    allSlides
                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    allSlides
                        .slice(indexOffset, indexOffset + _.options.slidesToShow)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

            }

        }

        if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
            _.lazyLoad();
        }
    };

    Slick.prototype.setupInfinite = function() {

        var _ = this,
            i, slideIndex, infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > (_.slideCount -
                        infiniteCount); i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex - _.slideCount)
                        .prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex + _.slideCount)
                        .appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                    $(this).attr('id', '');
                });

            }

        }

    };

    Slick.prototype.interrupt = function( toggle ) {

        var _ = this;

        if( !toggle ) {
            _.autoPlay();
        }
        _.interrupted = toggle;

    };

    Slick.prototype.selectHandler = function(event) {

        var _ = this;

        var targetElement =
            $(event.target).is('.slick-slide') ?
                $(event.target) :
                $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.slideHandler(index, false, true);
            return;

        }

        _.slideHandler(index);

    };

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
            _ = this, navTarget;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if ( _.options.autoplay ) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        if ( _.options.asNavFor ) {

            navTarget = _.getNavTarget();
            navTarget = navTarget.slick('getSlick');

            if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {
                navTarget.setSlideClasses(_.currentSlide);
            }

        }

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function() {
                    _.postSlide(animSlide);
                });

            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
            _.animateSlide(targetLeft, function() {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }

    };

    Slick.prototype.startLoad = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();

        }

        _.$slider.addClass('slick-loading');

    };

    Slick.prototype.swipeDirection = function() {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return (_.options.rtl === false ? 'right' : 'left');
        }
        if (_.options.verticalSwiping === true) {
            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                return 'down';
            } else {
                return 'up';
            }
        }

        return 'vertical';

    };

    Slick.prototype.swipeEnd = function(event) {

        var _ = this,
            slideCount,
            direction;

        _.dragging = false;
        _.swiping = false;

        if (_.scrolling) {
            _.scrolling = false;
            return false;
        }

        _.interrupted = false;
        _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;

        if ( _.touchObject.curX === undefined ) {
            return false;
        }

        if ( _.touchObject.edgeHit === true ) {
            _.$slider.trigger('edge', [_, _.swipeDirection() ]);
        }

        if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {

            direction = _.swipeDirection();

            switch ( direction ) {

                case 'left':
                case 'down':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide + _.getSlideCount() ) :
                            _.currentSlide + _.getSlideCount();

                    _.currentDirection = 0;

                    break;

                case 'right':
                case 'up':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide - _.getSlideCount() ) :
                            _.currentSlide - _.getSlideCount();

                    _.currentDirection = 1;

                    break;

                default:


            }

            if( direction != 'vertical' ) {

                _.slideHandler( slideCount );
                _.touchObject = {};
                _.$slider.trigger('swipe', [_, direction ]);

            }

        } else {

            if ( _.touchObject.startX !== _.touchObject.curX ) {

                _.slideHandler( _.currentSlide );
                _.touchObject = {};

            }

        }

    };

    Slick.prototype.swipeHandler = function(event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
            event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options
            .touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options
                .touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }

    };

    Slick.prototype.swipeMove = function(event) {

        var _ = this,
            edgeWasHit = false,
            curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        verticalSwipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

        if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
            _.scrolling = true;
            return false;
        }

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = verticalSwipeLength;
        }

        swipeDirection = _.swipeDirection();

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            _.swiping = true;
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }


        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function(event) {

        var _ = this,
            touches;

        _.interrupted = true;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;

    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.unload = function() {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides
            .removeClass('slick-slide slick-active slick-visible slick-current')
            .attr('aria-hidden', 'true')
            .css('width', '');

    };

    Slick.prototype.unslick = function(fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();

    };

    Slick.prototype.updateArrows = function() {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if ( _.options.arrows === true &&
            _.slideCount > _.options.slidesToShow &&
            !_.options.infinite ) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            }

        }

    };

    Slick.prototype.updateDots = function() {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots
                .find('li')
                    .removeClass('slick-active')
                    .end();

            _.$dots
                .find('li')
                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
                .addClass('slick-active');

        }

    };

    Slick.prototype.visibility = function() {

        var _ = this;

        if ( _.options.autoplay ) {

            if ( document[_.hidden] ) {

                _.interrupted = true;

            } else {

                _.interrupted = false;

            }

        }

    };

    $.fn.slick = function() {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i,
            ret;
        for (i = 0; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined')
                _[i].slick = new Slick(_[i], opt);
            else
                ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };

}));


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



var punycode = __webpack_require__(/*! punycode/ */ "./node_modules/punycode/punycode.js");

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  randomUUID
});

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/esm-browser/native.js");
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");




function v4(options, buf, offset) {
  if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
    return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./node_modules/validetta/dist/validetta.js":
/*!**************************************************!*\
  !*** ./node_modules/validetta/dist/validetta.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
/*!
 * Validetta (https://github.com/PixelUnion/validetta)
 * Version 2.0.3
 * Licensed under MIT (https://github.com/hsnayd/validetta/blob/master/LICENCE)
 * Copyright 2013-2017 Hasan Aydoğdu - http://www.hasanaydogdu.com 
 */
/*eslint-env es6:false*/

(function($) {
  'use strict';
  /**
   *  Declare variables
   */
  var FIELDS = {}; // Current fields/fields
  // RegExp for input validation rules
  var RRULE = new RegExp(/^(minChecked|maxChecked|minSelected|maxSelected|minLength|maxLength|equalTo|different|regExp|remote|callback)\[(\w{1,15})\]/i);
  // RegExp for mail control method
  // @from (http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#e-mail-state-%28type=email%29)
  var RMAIL = new RegExp(/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/);
  //RegExp for input number control method
  var RNUMBER = new RegExp(/^[\-\+]?(\d+|\d+\.?\d+)$/);

  /**
   *  Form validate error messages
   */
  var messages = {
    required  : 'This field is required.',
    email     : 'Your E-mail address appears to be invalid.',
    number    : 'You can enter only numbers in this field.',
    numMax    : 'Please enter a number less than {max}.',
    numMin    : 'Please enter a number greater than {min}.',
    numRange  : 'Please enter a number greater than {min} and less than {max}.',
    maxLength : 'Maximum {count} characters allowed.',
    minLength : 'Minimum {count} characters allowed.',
    maxChecked  : 'Maximum {count} options allowed.',
    minChecked  : 'Please select minimum {count} options.',
    maxSelected : 'Maximum {count} selection allowed.',
    minSelected : 'Minimum {count} selection allowed.',
    notEqual    : 'Fields do not match.',
    different   : 'Fields cannot be the same as each other',
    creditCard  : 'Invalid credit card number.',
  };

  /**
   *  Plugin defaults
   */
  var defaults = {
    showErrorMessage : true, // If you dont want to display error messages set this options false
    showMultiple: false, // whether or not to show all errors on an input at once
    disableNative: true, // whether or not to show all errors on an input at once
    validationClass: 'form-input', // Class of elements to be validated
    inputWrapperClass : 'form-field', // Class of the parent container we want to append the error message to
    errorTemplateClass : 'form-inline-message', // Class of the error message string
    errorClass : 'form-field-invalid', // Class added to parent of each failing validation field
    validClass : 'form-field-valid', // Same for valid validation
    realTime: false, // To enable real-time form control, set this option true.
    onValid: function(){}, // This function to be called when the user submits the form and there is no error.
    onError: function(){}, // This function to be called when the user submits the form and there are some errors
    validators: {}, // Custom validators stored in this variable
  };

  /**
   * Clears the left and right spaces of given parameter.
   * This is the function for string parameter!
   * If parameter is an array, function will return the untrimmed parameter
   *
   * @param {string} value
   * @return {mixed}
   */
  var trim = function(value) {
    return typeof value === 'string' ? value.replace(/^\s+|\s+$/g, '') : value;
  };

  /**
   * Validator
   * {count} which used below is the specified maximum or minimum value
   * e.g if method is minLength and  rule is 2 (minLength[2])
   * Output error messages text will be : 'Please select minimum 2 options.'
   *
   * @namespace
   * @param {object} tmp = this.tmp Tmp object for store current field and its value
   * @param {String} val: field value
   */
  var Validator = {
    required: function(tmp, self) {
      switch (tmp.el.type) {
        case 'checkbox' : return tmp.el.checked || messages.required;
        case 'radio' : return this.radio.call(self, tmp.el) || messages.required;
        case 'select-multiple' : return tmp.val !== null || messages.required;
        case 'select-one' : return tmp.val !== null || messages.required;
        default : return tmp.val !== '' || messages.required;
      }
    },

    //  Mail check - it checks the value if it's a valid email address or not
    email: function(tmp) {
      return RMAIL.test(tmp.val) || messages.email;
    },

    // Number check
    number: function(tmp, self) {
      if (RNUMBER.test(tmp.val)) {
        var message;
        var val = parseInt(tmp.val, 10);
        var max = tmp.el.max ? parseInt(tmp.el.max, 10) : Infinity;
        var min = tmp.el.min ? parseInt(tmp.el.min, 10) : -Infinity;

        // check attributes and assign error messages, auto-validate if neither is applied to element
        if (tmp.el.max && tmp.el.min) {
          message = messages.numRange;
        } else if (tmp.el.max) {
          message = messages.numMax;
        } else if (tmp.el.min) {
          message = messages.numMin;
        } else {
          return true;
        }

        if (val >= min && val <= max) {
          return true;
        } else {
          return self.processNumberMessage(message, tmp.el.min, tmp.el.max);
        }
      } else {
        return messages.number;
      }
    },

    // Minimum length check
    minLength: function(tmp) {
      var _length = tmp.val.length;
      return _length === 0 || _length >= tmp.arg || messages.minLength.replace('{count}', tmp.arg);
    },

    // Maximum lenght check
    maxLength: function(tmp) {
      return tmp.val.length <= tmp.arg || messages.maxLength.replace('{count}', tmp.arg);
    },

    // equalTo check
    equalTo: function(tmp, self) {
      return self.form.querySelector('input[name="' + tmp.arg + '"]').value === tmp.val || messages.notEqual;
    },

    different: function(tmp, self) {
      return self.form.querySelector('input[name="' + tmp.arg + '"]').value !== tmp.val || messages.different;
    },

    /**
     * Credit Card Control
     * @from : http://af-design.com/blog/2010/08/18/validating-credit-card-numbers
     */
    creditCard: function(tmp) {
      if (tmp.val === '') return true; // allow empty because empty check does by required metheod
      var reg;
      var cardNumber;
      var pos;
      var digit;
      var i;
      var subTotal;
      var sum = 0;
      var strlen;
      reg = new RegExp(/[^0-9]+/g);
      cardNumber = tmp.val.replace(reg, '');
      strlen = cardNumber.length;
      if (strlen < 16) return messages.creditCard;
      for (i = 0 ; i < strlen ; i++) {
        pos = strlen - i;
        digit = parseInt(cardNumber.substring(pos - 1, pos), 10);
        if (i % 2 === 1) {
          subTotal = digit * 2 ;
          if (subTotal > 9) {
            subTotal = 1 + (subTotal - 10);
          }
        } else {
          subTotal = digit ;
        }
        sum += subTotal ;
      }
      if (sum > 0 && sum % 10 === 0) return true;
      return messages.creditCard;
    },

    //Checkbox check
    maxChecked: function(tmp, self) {
      var cont = $(self.form.querySelectorAll('input[type=checkbox][name="' + tmp.el.name + '"]'));
      var count =  cont.filter(':checked').length;
      if (count === 0) return;
      return count <= tmp.arg || messages.maxChecked.replace('{count}', tmp.arg);
    },

    minChecked: function(tmp, self) {
      var cont = $(self.form.querySelectorAll('input[type=checkbox][name="' + tmp.el.name + '"]'));
      var count =  cont.filter(':checked').length;
      return count >= tmp.arg || messages.minChecked.replace('{count}', tmp.arg);
    },

    //Selectbox check
    maxSelected: function(tmp) {
      if (tmp.val === null) return;
      return tmp.val.length <= tmp.arg || messages.maxSelected.replace('{count}', tmp.arg);
    },

    minSelected: function(tmp) {
      return (tmp.val !== null && tmp.val.length >= tmp.arg) || messages.minSelected.replace('{count}', tmp.arg);
    },

    // Radio
    radio: function(el) {
      var count = this.form.querySelectorAll('input[type=radio][name="' + el.name + '"]:checked').length;
      return count === 1;
    },

    // Custom reg check
    regExp: function(tmp, self) {
      var _arg = self.options.validators.regExp[tmp.arg];
      var _reg = new RegExp(_arg.pattern);
      return _reg.test(tmp.val) || _arg.errorMessage;
    },

    // Remote
    remote: function(tmp) {
      tmp.remote = tmp.arg;
      return;
    },

    // Callback
    callback: function(tmp, self) {
      var _cb = self.options.validators.callback[tmp.arg];
      return _cb.callback(tmp.el, tmp.val) || _cb.errorMessage;
    },
  };

  /**
   * Plugin Class
   *
   * @constructor
   * @param {object} form : <form> element which being controlled
   * @param {object} options : User-specified settings
   * @return {method} events
   */
  var Validetta = function(form, options) {
    /**
     *  Public  Properties
     *  @property {mixed} handler It is used to stop or resume submit event handler
     *  @property {object} options Property is stored in plugin options
     *  @property {object} xhr Stores xhr requests
     *  @property {object} form Property is stored in <form> element
     */
    this.handler = false;
    this.options = $.extend(true, {}, defaults, options);
    this.form = form;
    this.xhr = {};
    this.initializeForm();
    this.events();
  };

  Validetta.prototype = {

    constructor : Validetta,

    /**
     * Remove native browser validation from target form if applicable
     */
    initializeForm: function() {
      if (this.options.disableNative) {
        this.form.setAttribute('novalidate', true);
      }
    },

    /**
     * This is the method of handling events
     *
     * @return {mixed}
     */
    events: function() {
      var self = this; // stored this
      // Handle submit event
      $(this.form).submit(function(event) {
        // fields to be controlled transferred to global variable
        FIELDS = event.currentTarget.getElementsByClassName(self.options.validationClass);
        return self.init(event);
      });
      // real-time option control
      if (this.options.realTime === true) {
        // handle change event for form elements (without checkbox)
        $(this.form).find('.' + this.options.validationClass).not('[type=checkbox]').on('change', function(event) {
          // field to be controlled transferred to global variable
          FIELDS = $(self);
          return self.init(event);
        });
        // handle click event for checkboxes
        $(this.form).find('.' + this.options.validationClass + '[type=checkbox]').on('click', function(event) {
          // fields to be controlled transferred to global variable
          FIELDS = self.form.querySelectorAll('.' + self.options.validationClass + '[type=checkbox][name="' + self.name + '"]');
          return self.init(event);
        });
      }
      // handle <form> reset button to clear error messages
      $(this.form).on('reset', function() {
        $(self.form.querySelectorAll('.' + self.options.errorClass + ' , .' + self.options.validClass))
          .removeClass(self.options.errorClass + ' ' + self.options.validClass);
        return self.reset();
      });
    },

    /**
     * In this method, fields are validated
     *
     * @params {object} e : event object
     * @return {mixed}
     */
    init: function(event) {
      // Reset error messages from all elements
      this.reset(FIELDS);
      // Start control each elements
      this.checkFields(event);
      if (event.type !== 'submit') return; // if event type is not submit, break
      // This is for when running remote request, return false and wait request response
      else if (this.handler === 'pending') return false;
      // if event type is submit and handler is true, break submit and call onError() function
      else if (this.handler === true) { this.options.onError.call(this, event); return false; }
      else return this.options.onValid.call(this, event); // if form is valid call onValid() function
    },

    /**
     * Checks Fields
     *
     * @param  {object} e event object
     * @return {void}
     */
    checkFields: function(event) {
      var self = this; // stored this
      var invalidFields = [];

      // Make invalidFields accessible
      this.getInvalidFields = function(){
        return invalidFields;
      };

      for (var i = 0, _lengthFields = FIELDS.length; i < _lengthFields; i++) {
        // if field is disabled, do not check
        if (FIELDS[i].disabled) continue;
        var el = FIELDS[i]; //current field
        var errorMessages = ''; //current field's errors
        var val = trim($(el).val()); //current field's value
        var methods = self.getInputValidators(el); //current field's control methods
        var state; // Validation state
        // Create tmp
        this.tmp = {};
        // store el and val variables in tmp
        this.tmp = { el : el, val : val, parent : this.parents(el) };
        // Start to check fields
        // Validator : Fields Control Object
        for (var j = 0, _lengthMethods = methods.length; j < _lengthMethods; j++) {
          // Check Rule
          var rule = methods[j].match(RRULE);
          var method;
          // Does it have rule?
          if (rule !== null) {
            // Does it have any argument ?
            if (typeof rule[2] !== 'undefined') this.tmp.arg = rule[2];
            // Set method name
            method = rule[1];
          } else { method = methods[j]; }
          // prevent empty validation if method is not required
          if (val === '' && method !== 'required' && method !== 'equalTo') continue;
          // Is there a method in Validator ?
          if (Validator.hasOwnProperty(method)) {
            // Validator returns error message if method invalid
            state = Validator[method](self.tmp, self);
            if (typeof state !== 'undefined' && state !== true) {
              var _dataMsg = el.getAttribute('data-vd-message-' + method);
              // is there a custom message?
              if (_dataMsg !== null) {
                state = _dataMsg;
                // add our min and max values if it's a number input
                if (method === 'number') {
                  state = this.processNumberMessage(state, this.tmp.el.min, this.tmp.el.max);
                }
              }
              if (this.options.showMultiple) {
                // show all states that return invalid
                errorMessages += state + '<br>';
              } else {
                // just show the last one
                errorMessages = state;
              }
            }
          }
        }

        // Check the errors
        if (errorMessages !== '') {
          invalidFields.push({
            field: el,
            errors: errorMessages,
          });
          // if parent element has valid class, remove and add error class
          this.addErrorClass(this.tmp.parent);
          // show error message
          this.notify.show.call(this , el, errorMessages);
        // Check remote validation
        } else if (typeof this.tmp.remote !== 'undefined') {
          this.checkRemote(el, event);
        } else { // Nice, there are no error
          if (typeof state !== 'undefined') this.addValidClass(this.tmp.parent);
          else $(this.tmp.parent).removeClass(this.options.errorClass + ' ' + this.options.validClass);
          state = undefined; // Reset state variable
        }
      }
    },

    /**
     * Determines what validators to run per input
     *
     * @param  {object} el current field
     * @return {array} a list of all validators to run against the input's value
     */
    getInputValidators: function(el) {
      // validators defined outside of native html5 attrs
      var validators = el.hasAttribute('data-validates') ? el.getAttribute('data-validates').split(',') : [];

      if (el.required && validators.indexOf('required') === -1) validators.push('required');
      if (el.type === 'number' && validators.indexOf('number') === -1) validators.push('number');
      if (el.type === 'email' && validators.indexOf('email') === -1) validators.push('email');

      return validators;
    },

    /**
     * Checks remote validations
     *
     * @param  {object} el current field
     * @param  {object} e event object
     * @throws {error} If previous remote request for same value has rejected
     * @return {void}
     */
    checkRemote: function(el, event) {
      var ajaxOptions = {};
      var data = {};
      var fieldName = el.name || el.id;

      if (typeof this.remoteCache === 'undefined') this.remoteCache = {};

      data[fieldName] = this.tmp.val; // Set data
      // exends ajax options
      ajaxOptions = $.extend(true, {}, {
        data: data,
      }, this.options.validators.remote[this.tmp.remote] || {});

      // use $.param() function for generate specific cache key
      var cacheKey = $.param(ajaxOptions);

      // Check cache
      var cache = this.remoteCache[cacheKey];

      if (typeof cache !== 'undefined') {
        switch(cache.state) {
          case 'pending' : // pending means remote request not finished yet
            this.handler = 'pending'; // update handler and cache event type
            cache.event = event.type;
            break;
          case 'rejected' : // rejected means remote request could not be performed
            event.preventDefault(); // we have to break submit because of throw error
            throw new Error(cache.result.message);
          case 'resolved' : // resolved means remote request has done
            // Check to cache, if result is invalid, show an error message
            if (cache.result.valid === false) {
              this.addErrorClass(this.tmp.parent);
              this.notify.show.call(this, el, cache.result.message);
            } else {
              this.addValidClass(this.tmp.parent);
            }
        }
      } else {
        // Abort if previous ajax request still running
        var _xhr = this.xhr[fieldName];
        if (typeof _xhr !== 'undefined' && _xhr.state() === 'pending') _xhr.abort();
        // Start caching
        cache = this.remoteCache[cacheKey] = { state : 'pending', event : event.type };
        // make a remote request
        this.remoteRequest(ajaxOptions, cache, el, fieldName);
      }
    },

    /**
     * Calls ajax request for remote validations
     *
     * @param  {object} ajaxOptions Ajax options
     * @param  {object} cache Cache object
     * @param  {object} el processing element
     * @param  {string} fieldName Field name for make specific caching
     * @param  {object} event Event object
     */
    remoteRequest: function(ajaxOptions, cache, el, fieldName) {
      var self = this;

      $(this.tmp.parent).addClass('validetta-pending');

      // cache xhr
      this.xhr[fieldName] = $.ajax(ajaxOptions)
        .done(function(result) {
          if (typeof result !== 'object') result = JSON.parse(result);
          cache.state = 'resolved';
          cache.result = result;
          if (cache.event === 'submit') {
            self.handler = false;
            $(self.form).trigger('submit');
          } else if (result.valid === false) {
            self.addErrorClass(self.tmp.parent);
            self.notify.show.call(self, el, result.message);
          } else {
            self.addValidClass(self.tmp.parent);
          }
        })
        .fail(function(jqXHR, textStatus) {
          if (textStatus !== 'abort') { // Dont throw error if request is aborted
            var _msg = 'Ajax request failed for field (' + fieldName + ') : ' + jqXHR.status + ' ' + jqXHR.statusText;
            cache.state = 'rejected';
            cache.result = { valid: false, message : _msg };
            throw new Error(_msg);
          }
        })
        .always(function() { $(self.tmp.parent).removeClass('validetta-pending'); });

      this.handler = 'pending';
    },

    /**
     * Showing or hiding error messages
     *
     * @namespace
     */
    notify: {
      /**
       * Error message shows
       *
       * @params {object} el : element which has an error (it can be native element or jQuery object)
       * @params {string} error : error messages
       */
      show: function(el, error) {
        // We want display errors ?
        if (!this.options.showErrorMessage) {
          // because of form not valid, set handler true for break submit
          this.handler = true;
          return;
        }
        var elParent = this.parents(el);
        // If the parent element undefined, that means el is an object. So we need to transform to the element
        if (typeof elParent === 'undefined') elParent = el[0].parentNode;
        // if there is an error message which previously shown for el, return
        if (elParent.querySelectorAll('.' + this.options.errorTemplateClass).length) return;
        // Create the error message object
        var errorObject = document.createElement('span');
        errorObject.className = this.options.errorTemplateClass;
        elParent.appendChild(errorObject);
        errorObject.innerHTML = error ;

        // we have an error so we need to break submit
        // set to handler true
        this.handler = true;
      },
      /**
       * Error message hides
       *
       * @params el : the error message which will be disappear
       */
      hide: function(el) {
        el.parentNode.removeChild(el);
      },
    },


    /**
     * Removes all error messages
     *
     * @param {object} or {void} el : form elements which have an error message
     */
    reset: function(el) {
      var _errorMessages = {};
      // if el is undefined (This is the process of resetting all <form>)
      // or el is an object that has element more than one
      // and these elements are not checkbox
      if (typeof el === 'undefined' || (el.length > 1 && el[0].type !== 'checkbox')) {
        _errorMessages = this.form.querySelectorAll('.' + this.options.errorTemplateClass);
      } else {
        _errorMessages = this.parents(el[0]).querySelectorAll('.' + this.options.errorTemplateClass);
      }
      for (var i = 0, _lengthErrorMessages = _errorMessages.length; i < _lengthErrorMessages; i++) {
        this.notify.hide.call(this, _errorMessages[i]);
      }
      // set to handler false
      // otherwise at the next validation attempt, submit will not continue even the validation is successful
      this.handler = false;
    },

    /**
     * Adds error class and removes valid class if exist
     *
     * @param {object} el element
     */
    addErrorClass: function(el) {
      $(el).removeClass(this.options.validClass).addClass(this.options.errorClass);
    },

    /**
     * Adds valid class and removes error class if exist
     * if error class not exist, do not add valid class
     *
     * @param {object} el element
     */
    addValidClass: function(el) {
      $(el).removeClass(this.options.errorClass).addClass(this.options.validClass);
    },

    /**
     * Finds parent element
     *
     * @param  {object} el element
     * @return {object} el parent element
     */
    parents: function(el) {
      return $(el).parents('.' + this.options.inputWrapperClass)[0];
    },

    /**
     * Replaces min & ma placeholders in number inputs
     *
     * @param {string} message - raw error message
     * @param {string} min - the input's min range (can be null)
     * @param {string} max - the input's max range (can be null)
     * @return {string} message - processed message
     */
    processNumberMessage: function(message, min, max) {
      if (min) message = message.replace('{min}', min);
      if (max) message = message.replace('{max}', max);
      return message;
    },
  };

  /**
   * Plugin Validetta
   *
   * @param {object} options : User-specified settings
   * @return {object} this
   */
  $.fn.validetta = function(options, _messages) {
    if (typeof _messages !== 'undefined') {
      messages = $.extend(true, {}, messages, _messages);
    }
    return this.each(function() {
      new Validetta(this, options);
    });
  };
})(jQuery);


/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DOMException: () => (/* binding */ DOMException),
/* harmony export */   Headers: () => (/* binding */ Headers),
/* harmony export */   Request: () => (/* binding */ Request),
/* harmony export */   Response: () => (/* binding */ Response),
/* harmony export */   fetch: () => (/* binding */ fetch)
/* harmony export */ });
/* eslint-disable no-prototype-builtins */
var g =
  (typeof globalThis !== 'undefined' && globalThis) ||
  (typeof self !== 'undefined' && self) ||
  // eslint-disable-next-line no-undef
  (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g) ||
  {}

var support = {
  searchParams: 'URLSearchParams' in g,
  iterable: 'Symbol' in g && 'iterator' in Symbol,
  blob:
    'FileReader' in g &&
    'Blob' in g &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in g,
  arrayBuffer: 'ArrayBuffer' in g
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length)
      }
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body._noBody) return
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type)
  var encoding = match ? match[1] : 'utf-8'
  reader.readAsText(blob, encoding)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    // eslint-disable-next-line no-self-assign
    this.bodyUsed = this.bodyUsed
    this._bodyInit = body
    if (!body) {
      this._noBody = true;
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }
  }

  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this)
      if (isConsumed) {
        return isConsumed
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        )
      } else {
        return Promise.resolve(this._bodyArrayBuffer)
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer)
    } else {
      throw new Error('could not read as ArrayBuffer')
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }

  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal || (function () {
    if ('AbortController' in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }());
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
      }
    }
  }
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders
    .split('\r')
    .map(function(header) {
      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
    })
    .forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        try {
          headers.append(key, value)
        } catch (error) {
          console.warn('Response ' + error.message)
        }
      }
    })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].")
  }
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 200, statusText: ''})
  response.ok = false
  response.status = 0
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = g.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      // This check if specifically for when a user fetches a file locally from the file system
      // Only if the status is out of a normal range
      if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      setTimeout(function() {
        resolve(new Response(body, options))
      }, 0)
    }

    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError('Network request timed out'))
      }, 0)
    }

    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException('Aborted', 'AbortError'))
      }, 0)
    }

    function fixUrl(url) {
      try {
        return url === '' && g.location.href ? g.location.href : url
      } catch (e) {
        return url
      }
    }

    xhr.open(request.method, fixUrl(request.url), true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob'
      } else if (
        support.arrayBuffer
      ) {
        xhr.responseType = 'arraybuffer'
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name))
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))
      })
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value)
        }
      })
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!g.fetch) {
  g.fetch = fetch
  g.Headers = Headers
  g.Request = Request
  g.Response = Response
}


/***/ }),

/***/ "./node_modules/zero-fill/index.js":
/*!*****************************************!*\
  !*** ./node_modules/zero-fill/index.js ***!
  \*****************************************/
/***/ ((module) => {

/*! zero-fill. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Given a number, return a zero-filled string.
 * From http://stackoverflow.com/questions/1267283/
 * @param  {number} width
 * @param  {number} number
 * @return {string}
 */
module.exports = function zeroFill (width, number, pad) {
  if (number === undefined) {
    return function (number, pad) {
      return zeroFill(width, number, pad)
    }
  }
  if (pad === undefined) pad = '0'
  width -= number.toString().length
  if (width > 0) return new Array(width + (/\./.test(number) ? 2 : 1)).join(pad) + number
  return number + ''
}


/***/ }),

/***/ "?4f7e":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/async/dist/async.mjs":
/*!*******************************************!*\
  !*** ./node_modules/async/dist/async.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* binding */ every$1),
/* harmony export */   allLimit: () => (/* binding */ everyLimit$1),
/* harmony export */   allSeries: () => (/* binding */ everySeries$1),
/* harmony export */   any: () => (/* binding */ some$1),
/* harmony export */   anyLimit: () => (/* binding */ someLimit$1),
/* harmony export */   anySeries: () => (/* binding */ someSeries$1),
/* harmony export */   apply: () => (/* binding */ apply),
/* harmony export */   applyEach: () => (/* binding */ applyEach),
/* harmony export */   applyEachSeries: () => (/* binding */ applyEachSeries),
/* harmony export */   asyncify: () => (/* binding */ asyncify),
/* harmony export */   auto: () => (/* binding */ auto),
/* harmony export */   autoInject: () => (/* binding */ autoInject),
/* harmony export */   cargo: () => (/* binding */ cargo$1),
/* harmony export */   cargoQueue: () => (/* binding */ cargo),
/* harmony export */   compose: () => (/* binding */ compose),
/* harmony export */   concat: () => (/* binding */ concat$1),
/* harmony export */   concatLimit: () => (/* binding */ concatLimit$1),
/* harmony export */   concatSeries: () => (/* binding */ concatSeries$1),
/* harmony export */   constant: () => (/* binding */ constant$1),
/* harmony export */   "default": () => (/* binding */ index),
/* harmony export */   detect: () => (/* binding */ detect$1),
/* harmony export */   detectLimit: () => (/* binding */ detectLimit$1),
/* harmony export */   detectSeries: () => (/* binding */ detectSeries$1),
/* harmony export */   dir: () => (/* binding */ dir),
/* harmony export */   doDuring: () => (/* binding */ doWhilst$1),
/* harmony export */   doUntil: () => (/* binding */ doUntil),
/* harmony export */   doWhilst: () => (/* binding */ doWhilst$1),
/* harmony export */   during: () => (/* binding */ whilst$1),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   eachLimit: () => (/* binding */ eachLimit$1),
/* harmony export */   eachOf: () => (/* binding */ eachOf$1),
/* harmony export */   eachOfLimit: () => (/* binding */ eachOfLimit$1),
/* harmony export */   eachOfSeries: () => (/* binding */ eachOfSeries$1),
/* harmony export */   eachSeries: () => (/* binding */ eachSeries$1),
/* harmony export */   ensureAsync: () => (/* binding */ ensureAsync),
/* harmony export */   every: () => (/* binding */ every$1),
/* harmony export */   everyLimit: () => (/* binding */ everyLimit$1),
/* harmony export */   everySeries: () => (/* binding */ everySeries$1),
/* harmony export */   filter: () => (/* binding */ filter$1),
/* harmony export */   filterLimit: () => (/* binding */ filterLimit$1),
/* harmony export */   filterSeries: () => (/* binding */ filterSeries$1),
/* harmony export */   find: () => (/* binding */ detect$1),
/* harmony export */   findLimit: () => (/* binding */ detectLimit$1),
/* harmony export */   findSeries: () => (/* binding */ detectSeries$1),
/* harmony export */   flatMap: () => (/* binding */ concat$1),
/* harmony export */   flatMapLimit: () => (/* binding */ concatLimit$1),
/* harmony export */   flatMapSeries: () => (/* binding */ concatSeries$1),
/* harmony export */   foldl: () => (/* binding */ reduce$1),
/* harmony export */   foldr: () => (/* binding */ reduceRight),
/* harmony export */   forEach: () => (/* binding */ each),
/* harmony export */   forEachLimit: () => (/* binding */ eachLimit$1),
/* harmony export */   forEachOf: () => (/* binding */ eachOf$1),
/* harmony export */   forEachOfLimit: () => (/* binding */ eachOfLimit$1),
/* harmony export */   forEachOfSeries: () => (/* binding */ eachOfSeries$1),
/* harmony export */   forEachSeries: () => (/* binding */ eachSeries$1),
/* harmony export */   forever: () => (/* binding */ forever$1),
/* harmony export */   groupBy: () => (/* binding */ groupBy),
/* harmony export */   groupByLimit: () => (/* binding */ groupByLimit$1),
/* harmony export */   groupBySeries: () => (/* binding */ groupBySeries),
/* harmony export */   inject: () => (/* binding */ reduce$1),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   map: () => (/* binding */ map$1),
/* harmony export */   mapLimit: () => (/* binding */ mapLimit$1),
/* harmony export */   mapSeries: () => (/* binding */ mapSeries$1),
/* harmony export */   mapValues: () => (/* binding */ mapValues),
/* harmony export */   mapValuesLimit: () => (/* binding */ mapValuesLimit$1),
/* harmony export */   mapValuesSeries: () => (/* binding */ mapValuesSeries),
/* harmony export */   memoize: () => (/* binding */ memoize),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   parallel: () => (/* binding */ parallel),
/* harmony export */   parallelLimit: () => (/* binding */ parallelLimit),
/* harmony export */   priorityQueue: () => (/* binding */ priorityQueue),
/* harmony export */   queue: () => (/* binding */ queue),
/* harmony export */   race: () => (/* binding */ race$1),
/* harmony export */   reduce: () => (/* binding */ reduce$1),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   reflect: () => (/* binding */ reflect),
/* harmony export */   reflectAll: () => (/* binding */ reflectAll),
/* harmony export */   reject: () => (/* binding */ reject$1),
/* harmony export */   rejectLimit: () => (/* binding */ rejectLimit$1),
/* harmony export */   rejectSeries: () => (/* binding */ rejectSeries$1),
/* harmony export */   retry: () => (/* binding */ retry),
/* harmony export */   retryable: () => (/* binding */ retryable),
/* harmony export */   select: () => (/* binding */ filter$1),
/* harmony export */   selectLimit: () => (/* binding */ filterLimit$1),
/* harmony export */   selectSeries: () => (/* binding */ filterSeries$1),
/* harmony export */   seq: () => (/* binding */ seq),
/* harmony export */   series: () => (/* binding */ series),
/* harmony export */   setImmediate: () => (/* binding */ setImmediate$1),
/* harmony export */   some: () => (/* binding */ some$1),
/* harmony export */   someLimit: () => (/* binding */ someLimit$1),
/* harmony export */   someSeries: () => (/* binding */ someSeries$1),
/* harmony export */   sortBy: () => (/* binding */ sortBy$1),
/* harmony export */   timeout: () => (/* binding */ timeout),
/* harmony export */   times: () => (/* binding */ times),
/* harmony export */   timesLimit: () => (/* binding */ timesLimit),
/* harmony export */   timesSeries: () => (/* binding */ timesSeries),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   tryEach: () => (/* binding */ tryEach$1),
/* harmony export */   unmemoize: () => (/* binding */ unmemoize),
/* harmony export */   until: () => (/* binding */ until),
/* harmony export */   waterfall: () => (/* binding */ waterfall$1),
/* harmony export */   whilst: () => (/* binding */ whilst$1),
/* harmony export */   wrapSync: () => (/* binding */ asyncify)
/* harmony export */ });
/**
 * Creates a continuation function with some arguments already applied.
 *
 * Useful as a shorthand when combined with other control flow functions. Any
 * arguments passed to the returned function are added to the arguments
 * originally passed to apply.
 *
 * @name apply
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {Function} fn - The function you want to eventually apply all
 * arguments to. Invokes with (arguments...).
 * @param {...*} arguments... - Any number of arguments to automatically apply
 * when the continuation is called.
 * @returns {Function} the partially-applied function
 * @example
 *
 * // using apply
 * async.parallel([
 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
 *     async.apply(fs.writeFile, 'testfile2', 'test2')
 * ]);
 *
 *
 * // the same process without using apply
 * async.parallel([
 *     function(callback) {
 *         fs.writeFile('testfile1', 'test1', callback);
 *     },
 *     function(callback) {
 *         fs.writeFile('testfile2', 'test2', callback);
 *     }
 * ]);
 *
 * // It's possible to pass any number of additional arguments when calling the
 * // continuation:
 *
 * node> var fn = async.apply(sys.puts, 'one');
 * node> fn('two', 'three');
 * one
 * two
 * three
 */
function apply(fn, ...args) {
    return (...callArgs) => fn(...args,...callArgs);
}

function initialParams (fn) {
    return function (...args/*, callback*/) {
        var callback = args.pop();
        return fn.call(this, args, callback);
    };
}

/* istanbul ignore file */

var hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;
var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
}

var _defer$1;

if (hasQueueMicrotask) {
    _defer$1 = queueMicrotask;
} else if (hasSetImmediate) {
    _defer$1 = setImmediate;
} else if (hasNextTick) {
    _defer$1 = process.nextTick;
} else {
    _defer$1 = fallback;
}

var setImmediate$1 = wrap(_defer$1);

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    if (isAsync(func)) {
        return function (...args/*, callback*/) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback)
        }
    }

    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (result && typeof result.then === 'function') {
            return handlePromise(result, callback)
        } else {
            callback(null, result);
        }
    });
}

function handlePromise(promise, callback) {
    return promise.then(value => {
        invokeCallback(callback, null, value);
    }, err => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (err) {
        setImmediate$1(e => { throw e }, err);
    }
}

function isAsync(fn) {
    return fn[Symbol.toStringTag] === 'AsyncFunction';
}

function isAsyncGenerator(fn) {
    return fn[Symbol.toStringTag] === 'AsyncGenerator';
}

function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === 'function';
}

function wrapAsync(asyncFn) {
    if (typeof asyncFn !== 'function') throw new Error('expected a function')
    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}

// conditionally promisify a function.
// only return a promise if a callback is omitted
function awaitify (asyncFn, arity) {
    if (!arity) arity = asyncFn.length;
    if (!arity) throw new Error('arity is undefined')
    function awaitable (...args) {
        if (typeof args[arity - 1] === 'function') {
            return asyncFn.apply(this, args)
        }

        return new Promise((resolve, reject) => {
            args[arity - 1] = (err, ...cbArgs) => {
                if (err) return reject(err)
                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
        })
    }

    return awaitable
}

function applyEach$1 (eachfn) {
    return function applyEach(fns, ...callArgs) {
        const go = awaitify(function (callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
                wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
        });
        return go;
    };
}

function _asyncMap(eachfn, arr, iteratee, callback) {
    arr = arr || [];
    var results = [];
    var counter = 0;
    var _iteratee = wrapAsync(iteratee);

    return eachfn(arr, (value, _, iterCb) => {
        var index = counter++;
        _iteratee(value, (err, v) => {
            results[index] = v;
            iterCb(err);
        });
    }, err => {
        callback(err, results);
    });
}

function isArrayLike(value) {
    return value &&
        typeof value.length === 'number' &&
        value.length >= 0 &&
        value.length % 1 === 0;
}

// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
const breakLoop = {};

function once(fn) {
    function wrapper (...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper
}

function getIterator (coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
}

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? {value: coll[i], key: i} : null;
    }
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done)
            return null;
        i++;
        return {value: item.value, key: i};
    }
}

function createObjectIterator(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        if (key === '__proto__') {
            return next();
        }
        return i < len ? {value: obj[key], key} : null;
    };
}

function createIterator(coll) {
    if (isArrayLike(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = getIterator(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}

function onlyOnce(fn) {
    return function (...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    };
}

// for async generators
function asyncEachOfLimit(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;

    function replenish() {
        //console.log('replenish')
        if (running >= limit || awaiting || done) return
        //console.log('replenish awaiting')
        awaiting = true;
        generator.next().then(({value, done: iterDone}) => {
            //console.log('got value', value)
            if (canceled || done) return
            awaiting = false;
            if (iterDone) {
                done = true;
                if (running <= 0) {
                    //console.log('done nextCb')
                    callback(null);
                }
                return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
        }).catch(handleError);
    }

    function iterateeCallback(err, result) {
        //console.log('iterateeCallback')
        running -= 1;
        if (canceled) return
        if (err) return handleError(err)

        if (err === false) {
            done = true;
            canceled = true;
            return
        }

        if (result === breakLoop || (done && running <= 0)) {
            done = true;
            //console.log('done iterCb')
            return callback(null);
        }
        replenish();
    }

    function handleError(err) {
        if (canceled) return
        awaiting = false;
        done = true;
        callback(err);
    }

    replenish();
}

var eachOfLimit$2 = (limit) => {
    return (obj, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
            throw new RangeError('concurrency limit cannot be less than 1')
        }
        if (!obj) {
            return callback(null);
        }
        if (isAsyncGenerator(obj)) {
            return asyncEachOfLimit(obj, limit, iteratee, callback)
        }
        if (isAsyncIterable(obj)) {
            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)
        }
        var nextElem = createIterator(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;

        function iterateeCallback(err, value) {
            if (canceled) return
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            }
            else if (err === false) {
                done = true;
                canceled = true;
            }
            else if (value === breakLoop || (done && running <= 0)) {
                done = true;
                return callback(null);
            }
            else if (!looping) {
                replenish();
            }
        }

        function replenish () {
            looping = true;
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
        }

        replenish();
    };
};

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfLimit(coll, limit, iteratee, callback) {
    return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
}

var eachOfLimit$1 = awaitify(eachOfLimit, 4);

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = once(callback);
    var index = 0,
        completed = 0,
        {length} = coll,
        canceled = false;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err === false) {
            canceled = true;
        }
        if (canceled === true) return
        if (err) {
            callback(err);
        } else if ((++completed === length) || value === breakLoop) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, onlyOnce(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
function eachOfGeneric (coll, iteratee, callback) {
    return eachOfLimit$1(coll, Infinity, iteratee, callback);
}

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dev.json is a file containing a valid json object config for dev environment
 * // dev.json is a file containing a valid json object config for test environment
 * // prod.json is a file containing a valid json object config for prod environment
 * // invalid.json is a file with a malformed json object
 *
 * let configs = {}; //global variable
 * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};
 * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};
 *
 * // asynchronous function that reads a json file and parses the contents as json object
 * function parseFile(file, key, callback) {
 *     fs.readFile(file, "utf8", function(err, data) {
 *         if (err) return calback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }
 *
 * // Using callbacks
 * async.forEachOf(validConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *     } else {
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *         // JSON parse error exception
 *     } else {
 *         console.log(configs);
 *     }
 * });
 *
 * // Using Promises
 * async.forEachOf(validConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 *     // configs is now a map of JSON data, e.g.
 *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 * }).catch( err => {
 *     console.error(err);
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 * }).catch( err => {
 *     console.error(err);
 *     // JSON parse error exception
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.forEachOf(validConfigFileMap, parseFile);
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * //Error handing
 * async () => {
 *     try {
 *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);
 *         console.log(configs);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // JSON parse error exception
 *     }
 * }
 *
 */
function eachOf(coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, wrapAsync(iteratee), callback);
}

var eachOf$1 = awaitify(eachOf, 3);

/**
 * Produces a new collection of values by mapping each value in `coll` through
 * the `iteratee` function. The `iteratee` is called with an item from `coll`
 * and a callback for when it has finished processing. Each of these callbacks
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
 * `iteratee` passes an error to its callback, the main `callback` (for the
 * `map` function) is immediately called with the error.
 *
 * Note, that since this function applies the `iteratee` to each item in
 * parallel, there is no guarantee that the `iteratee` functions will complete
 * in order. However, the results array will be in the same order as the
 * original `coll`.
 *
 * If `map` is passed an Object, the results will be an Array.  The results
 * will roughly be in the order of the original Objects' keys (but this can
 * vary across JavaScript engines).
 *
 * @name map
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an Array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 * // file4.txt does not exist
 *
 * const fileList = ['file1.txt','file2.txt','file3.txt'];
 * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
 *
 * // asynchronous function that returns the file size in bytes
 * function getFileSizeInBytes(file, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         callback(null, stat.size);
 *     });
 * }
 *
 * // Using callbacks
 * async.map(fileList, getFileSizeInBytes, function(err, results) {
 *     if (err) {
 *         console.log(err);
 *     } else {
 *         console.log(results);
 *         // results is now an array of the file size in bytes for each file, e.g.
 *         // [ 1000, 2000, 3000]
 *     }
 * });
 *
 * // Error Handling
 * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {
 *     if (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     } else {
 *         console.log(results);
 *     }
 * });
 *
 * // Using Promises
 * async.map(fileList, getFileSizeInBytes)
 * .then( results => {
 *     console.log(results);
 *     // results is now an array of the file size in bytes for each file, e.g.
 *     // [ 1000, 2000, 3000]
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.map(withMissingFileList, getFileSizeInBytes)
 * .then( results => {
 *     console.log(results);
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let results = await async.map(fileList, getFileSizeInBytes);
 *         console.log(results);
 *         // results is now an array of the file size in bytes for each file, e.g.
 *         // [ 1000, 2000, 3000]
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         let results = await async.map(withMissingFileList, getFileSizeInBytes);
 *         console.log(results);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     }
 * }
 *
 */
function map (coll, iteratee, callback) {
    return _asyncMap(eachOf$1, coll, iteratee, callback)
}
var map$1 = awaitify(map, 3);

/**
 * Applies the provided arguments to each function in the array, calling
 * `callback` after all functions have completed. If you only provide the first
 * argument, `fns`, then it will return a function which lets you pass in the
 * arguments as if it were a single function call. If more arguments are
 * provided, `callback` is required while `args` is still optional. The results
 * for each of the applied async functions are passed to the final callback
 * as an array.
 *
 * @name applyEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s
 * to all call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {AsyncFunction} - Returns a function that takes no args other than
 * an optional callback, that is the result of applying the `args` to each
 * of the functions.
 * @example
 *
 * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')
 *
 * appliedFn((err, results) => {
 *     // results[0] is the results for `enableSearch`
 *     // results[1] is the results for `updateSchema`
 * });
 *
 * // partial application example:
 * async.each(
 *     buckets,
 *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),
 *     callback
 * );
 */
var applyEach = applyEach$1(map$1);

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfSeries(coll, iteratee, callback) {
    return eachOfLimit$1(coll, 1, iteratee, callback)
}
var eachOfSeries$1 = awaitify(eachOfSeries, 3);

/**
 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
 *
 * @name mapSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 */
function mapSeries (coll, iteratee, callback) {
    return _asyncMap(eachOfSeries$1, coll, iteratee, callback)
}
var mapSeries$1 = awaitify(mapSeries, 3);

/**
 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
 *
 * @name applyEachSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all
 * call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {AsyncFunction} - A function, that when called, is the result of
 * appling the `args` to the list of functions.  It takes no args, other than
 * a callback.
 */
var applyEachSeries = applyEach$1(mapSeries$1);

const PROMISE_SYMBOL = Symbol('promiseCallback');

function promiseCallback () {
    let resolve, reject;
    function callback (err, ...args) {
        if (err) return reject(err)
        resolve(args.length > 1 ? args : args[0]);
    }

    callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res,
        reject = rej;
    });

    return callback
}

/**
 * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
 * their requirements. Each function can optionally depend on other functions
 * being completed first, and each function is run as soon as its requirements
 * are satisfied.
 *
 * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
 * will stop. Further tasks will not execute (so any other functions depending
 * on it will not run), and the main `callback` is immediately called with the
 * error.
 *
 * {@link AsyncFunction}s also receive an object containing the results of functions which
 * have completed so far as the first argument, if they have dependencies. If a
 * task function has no dependencies, it will only be passed a callback.
 *
 * @name auto
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Object} tasks - An object. Each of its properties is either a
 * function or an array of requirements, with the {@link AsyncFunction} itself the last item
 * in the array. The object's key of a property serves as the name of the task
 * defined by that property, i.e. can be used when specifying requirements for
 * other tasks. The function receives one or two arguments:
 * * a `results` object, containing the results of the previously executed
 *   functions, only passed if the task has any dependencies,
 * * a `callback(err, result)` function, which must be called when finished,
 *   passing an `error` (which can be `null`) and the result of the function's
 *   execution.
 * @param {number} [concurrency=Infinity] - An optional `integer` for
 * determining the maximum number of tasks that can be run in parallel. By
 * default, as many as possible.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback. Results are always returned; however, if an
 * error occurs, no further `tasks` will be performed, and the results object
 * will only contain partial results. Invoked with (err, results).
 * @returns {Promise} a promise, if a callback is not passed
 * @example
 *
 * //Using Callbacks
 * async.auto({
 *     get_data: function(callback) {
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: ['get_data', 'make_folder', function(results, callback) {
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(results, callback) {
 *         // once the file is written let's email a link to it...
 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
 *     }]
 * }, function(err, results) {
 *     if (err) {
 *         console.log('err = ', err);
 *     }
 *     console.log('results = ', results);
 *     // results = {
 *     //     get_data: ['data', 'converted to array']
 *     //     make_folder; 'folder',
 *     //     write_file: 'filename'
 *     //     email_link: { file: 'filename', email: 'user@example.com' }
 *     // }
 * });
 *
 * //Using Promises
 * async.auto({
 *     get_data: function(callback) {
 *         console.log('in get_data');
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         console.log('in make_folder');
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: ['get_data', 'make_folder', function(results, callback) {
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(results, callback) {
 *         // once the file is written let's email a link to it...
 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
 *     }]
 * }).then(results => {
 *     console.log('results = ', results);
 *     // results = {
 *     //     get_data: ['data', 'converted to array']
 *     //     make_folder; 'folder',
 *     //     write_file: 'filename'
 *     //     email_link: { file: 'filename', email: 'user@example.com' }
 *     // }
 * }).catch(err => {
 *     console.log('err = ', err);
 * });
 *
 * //Using async/await
 * async () => {
 *     try {
 *         let results = await async.auto({
 *             get_data: function(callback) {
 *                 // async code to get some data
 *                 callback(null, 'data', 'converted to array');
 *             },
 *             make_folder: function(callback) {
 *                 // async code to create a directory to store a file in
 *                 // this is run at the same time as getting the data
 *                 callback(null, 'folder');
 *             },
 *             write_file: ['get_data', 'make_folder', function(results, callback) {
 *                 // once there is some data and the directory exists,
 *                 // write the data to a file in the directory
 *                 callback(null, 'filename');
 *             }],
 *             email_link: ['write_file', function(results, callback) {
 *                 // once the file is written let's email a link to it...
 *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});
 *             }]
 *         });
 *         console.log('results = ', results);
 *         // results = {
 *         //     get_data: ['data', 'converted to array']
 *         //     make_folder; 'folder',
 *         //     write_file: 'filename'
 *         //     email_link: { file: 'filename', email: 'user@example.com' }
 *         // }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function auto(tasks, concurrency, callback) {
    if (typeof concurrency !== 'number') {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || promiseCallback());
    var numTasks = Object.keys(tasks).length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var canceled = false;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    Object.keys(tasks).forEach(key => {
        var task = tasks[key];
        if (!Array.isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        dependencies.forEach(dependencyName => {
            if (!tasks[dependencyName]) {
                throw new Error('async.auto task `' + key +
                    '` has a non-existent dependency `' +
                    dependencyName + '` in ' +
                    dependencies.join(', '));
            }
            addListener(dependencyName, () => {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(() => runTask(key, task));
    }

    function processQueue() {
        if (canceled) return
        if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
        }
        while(readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
        }

    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        taskListeners.forEach(fn => fn());
        processQueue();
    }


    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce((err, ...result) => {
            runningTasks--;
            if (err === false) {
                canceled = true;
                return
            }
            if (result.length < 2) {
                [result] = result;
            }
            if (err) {
                var safeResults = {};
                Object.keys(results).forEach(rkey => {
                    safeResults[rkey] = results[rkey];
                });
                safeResults[key] = result;
                hasError = true;
                listeners = Object.create(null);
                if (canceled) return
                callback(err, safeResults);
            } else {
                results[key] = result;
                taskComplete(key);
            }
        });

        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach(dependent => {
                if (--uncheckedDependencies[dependent] === 0) {
                    readyToCheck.push(dependent);
                }
            });
        }

        if (counter !== numTasks) {
            throw new Error(
                'async.auto cannot execute tasks due to a recursive dependency'
            );
        }
    }

    function getDependents(taskName) {
        var result = [];
        Object.keys(tasks).forEach(key => {
            const task = tasks[key];
            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
                result.push(key);
            }
        });
        return result;
    }

    return callback[PROMISE_SYMBOL]
}

var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /(=.+)?(\s*)$/;

function stripComments(string) {
    let stripped = '';
    let index = 0;
    let endBlockComment = string.indexOf('*/');
    while (index < string.length) {
        if (string[index] === '/' && string[index+1] === '/') {
            // inline comment
            let endIndex = string.indexOf('\n', index);
            index = (endIndex === -1) ? string.length : endIndex;
        } else if ((endBlockComment !== -1) && (string[index] === '/') && (string[index+1] === '*')) {
            // block comment
            let endIndex = string.indexOf('*/', index);
            if (endIndex !== -1) {
                index = endIndex + 2;
                endBlockComment = string.indexOf('*/', index);
            } else {
                stripped += string[index];
                index++;
            }
        } else {
            stripped += string[index];
            index++;
        }
    }
    return stripped;
}

function parseParams(func) {
    const src = stripComments(func.toString());
    let match = src.match(FN_ARGS);
    if (!match) {
        match = src.match(ARROW_FN_ARGS);
    }
    if (!match) throw new Error('could not parse args in autoInject\nSource:\n' + src)
    let [, args] = match;
    return args
        .replace(/\s/g, '')
        .split(FN_ARG_SPLIT)
        .map((arg) => arg.replace(FN_ARG, '').trim());
}

/**
 * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
 * tasks are specified as parameters to the function, after the usual callback
 * parameter, with the parameter names matching the names of the tasks it
 * depends on. This can provide even more readable task graphs which can be
 * easier to maintain.
 *
 * If a final callback is specified, the task results are similarly injected,
 * specified as named parameters after the initial error parameter.
 *
 * The autoInject function is purely syntactic sugar and its semantics are
 * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
 *
 * @name autoInject
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.auto]{@link module:ControlFlow.auto}
 * @category Control Flow
 * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
 * the form 'func([dependencies...], callback). The object's key of a property
 * serves as the name of the task defined by that property, i.e. can be used
 * when specifying requirements for other tasks.
 * * The `callback` parameter is a `callback(err, result)` which must be called
 *   when finished, passing an `error` (which can be `null`) and the result of
 *   the function's execution. The remaining parameters name other tasks on
 *   which the task is dependent, and the results from those tasks are the
 *   arguments of those parameters.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback, and a `results` object with any completed
 * task results, similar to `auto`.
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * //  The example from `auto` can be rewritten as follows:
 * async.autoInject({
 *     get_data: function(callback) {
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: function(get_data, make_folder, callback) {
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     },
 *     email_link: function(write_file, callback) {
 *         // once the file is written let's email a link to it...
 *         // write_file contains the filename returned by write_file.
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 *
 * // If you are using a JS minifier that mangles parameter names, `autoInject`
 * // will not work with plain functions, since the parameter names will be
 * // collapsed to a single letter identifier.  To work around this, you can
 * // explicitly specify the names of the parameters your task function needs
 * // in an array, similar to Angular.js dependency injection.
 *
 * // This still has an advantage over plain `auto`, since the results a task
 * // depends on are still spread into arguments.
 * async.autoInject({
 *     //...
 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(write_file, callback) {
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }]
 *     //...
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 */
function autoInject(tasks, callback) {
    var newTasks = {};

    Object.keys(tasks).forEach(key => {
        var taskFn = tasks[key];
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps =
            (!fnIsAsync && taskFn.length === 1) ||
            (fnIsAsync && taskFn.length === 0);

        if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();

            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = params.map(name => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
        }
    });

    return auto(newTasks, callback);
}

// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.
class DLL {
    constructor() {
        this.head = this.tail = null;
        this.length = 0;
    }

    removeLink(node) {
        if (node.prev) node.prev.next = node.next;
        else this.head = node.next;
        if (node.next) node.next.prev = node.prev;
        else this.tail = node.prev;

        node.prev = node.next = null;
        this.length -= 1;
        return node;
    }

    empty () {
        while(this.head) this.shift();
        return this;
    }

    insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next) node.next.prev = newNode;
        else this.tail = newNode;
        node.next = newNode;
        this.length += 1;
    }

    insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev) node.prev.next = newNode;
        else this.head = newNode;
        node.prev = newNode;
        this.length += 1;
    }

    unshift(node) {
        if (this.head) this.insertBefore(this.head, node);
        else setInitial(this, node);
    }

    push(node) {
        if (this.tail) this.insertAfter(this.tail, node);
        else setInitial(this, node);
    }

    shift() {
        return this.head && this.removeLink(this.head);
    }

    pop() {
        return this.tail && this.removeLink(this.tail);
    }

    toArray() {
        return [...this]
    }

    *[Symbol.iterator] () {
        var cur = this.head;
        while (cur) {
            yield cur.data;
            cur = cur.next;
        }
    }

    remove (testFn) {
        var curr = this.head;
        while(curr) {
            var {next} = curr;
            if (testFn(curr)) {
                this.removeLink(curr);
            }
            curr = next;
        }
        return this;
    }
}

function setInitial(dll, node) {
    dll.length = 1;
    dll.head = dll.tail = node;
}

function queue$1(worker, concurrency, payload) {
    if (concurrency == null) {
        concurrency = 1;
    }
    else if(concurrency === 0) {
        throw new RangeError('Concurrency must not be zero');
    }

    var _worker = wrapAsync(worker);
    var numRunning = 0;
    var workersList = [];
    const events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
    };

    function on (event, handler) {
        events[event].push(handler);
    }

    function once (event, handler) {
        const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler(...args);
        };
        events[event].push(handleAndRemove);
    }

    function off (event, handler) {
        if (!event) return Object.keys(events).forEach(ev => events[ev] = [])
        if (!handler) return events[event] = []
        events[event] = events[event].filter(ev => ev !== handler);
    }

    function trigger (event, ...args) {
        events[event].forEach(handler => handler(...args));
    }

    var processingScheduled = false;
    function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;

        var res, rej;
        function promiseCallback (err, ...args) {
            // we don't care about the error, let the global error handler
            // deal with it
            if (err) return rejectOnError ? rej(err) : res()
            if (args.length <= 1) return res(args[0])
            res(args);
        }

        var item = q._createTaskItem(
            data,
            rejectOnError ? promiseCallback :
                (callback || promiseCallback)
        );

        if (insertAtFront) {
            q._tasks.unshift(item);
        } else {
            q._tasks.push(item);
        }

        if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
                processingScheduled = false;
                q.process();
            });
        }

        if (rejectOnError || !callback) {
            return new Promise((resolve, reject) => {
                res = resolve;
                rej = reject;
            })
        }
    }

    function _createCB(tasks) {
        return function (err, ...args) {
            numRunning -= 1;

            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];

                var index = workersList.indexOf(task);
                if (index === 0) {
                    workersList.shift();
                } else if (index > 0) {
                    workersList.splice(index, 1);
                }

                task.callback(err, ...args);

                if (err != null) {
                    trigger('error', err, task.data);
                }
            }

            if (numRunning <= (q.concurrency - q.buffer) ) {
                trigger('unsaturated');
            }

            if (q.idle()) {
                trigger('drain');
            }
            q.process();
        };
    }

    function _maybeDrain(data) {
        if (data.length === 0 && q.idle()) {
            // call drain immediately if there are no tasks
            setImmediate$1(() => trigger('drain'));
            return true
        }
        return false
    }

    const eventMethod = (name) => (handler) => {
        if (!handler) {
            return new Promise((resolve, reject) => {
                once(name, (err, data) => {
                    if (err) return reject(err)
                    resolve(data);
                });
            })
        }
        off(name);
        on(name, handler);

    };

    var isProcessing = false;
    var q = {
        _tasks: new DLL(),
        _createTaskItem (data, callback) {
            return {
                data,
                callback
            };
        },
        *[Symbol.iterator] () {
            yield* q._tasks[Symbol.iterator]();
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: false,
        paused: false,
        push (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, false, false, callback))
            }
            return _insert(data, false, false, callback);
        },
        pushAsync (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, false, true, callback))
            }
            return _insert(data, false, true, callback);
        },
        kill () {
            off();
            q._tasks.empty();
        },
        unshift (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, true, false, callback))
            }
            return _insert(data, true, false, callback);
        },
        unshiftAsync (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, true, true, callback))
            }
            return _insert(data, true, true, callback);
        },
        remove (testFn) {
            q._tasks.remove(testFn);
        },
        process () {
            // Avoid trying to start too many processing operations. This can occur
            // when callbacks resolve synchronously (#1267).
            if (isProcessing) {
                return;
            }
            isProcessing = true;
            while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload) l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                    var node = q._tasks.shift();
                    tasks.push(node);
                    workersList.push(node);
                    data.push(node.data);
                }

                numRunning += 1;

                if (q._tasks.length === 0) {
                    trigger('empty');
                }

                if (numRunning === q.concurrency) {
                    trigger('saturated');
                }

                var cb = onlyOnce(_createCB(tasks));
                _worker(data, cb);
            }
            isProcessing = false;
        },
        length () {
            return q._tasks.length;
        },
        running () {
            return numRunning;
        },
        workersList () {
            return workersList;
        },
        idle() {
            return q._tasks.length + numRunning === 0;
        },
        pause () {
            q.paused = true;
        },
        resume () {
            if (q.paused === false) { return; }
            q.paused = false;
            setImmediate$1(q.process);
        }
    };
    // define these as fixed properties, so people get useful errors when updating
    Object.defineProperties(q, {
        saturated: {
            writable: false,
            value: eventMethod('saturated')
        },
        unsaturated: {
            writable: false,
            value: eventMethod('unsaturated')
        },
        empty: {
            writable: false,
            value: eventMethod('empty')
        },
        drain: {
            writable: false,
            value: eventMethod('drain')
        },
        error: {
            writable: false,
            value: eventMethod('error')
        },
    });
    return q;
}

/**
 * Creates a `cargo` object with the specified payload. Tasks added to the
 * cargo will be processed altogether (up to the `payload` limit). If the
 * `worker` is in progress, the task is queued until it becomes available. Once
 * the `worker` has completed some tasks, each callback of those tasks is
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
 * for how `cargo` and `queue` work.
 *
 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
 * at a time, cargo passes an array of tasks to a single worker, repeating
 * when the worker is finished.
 *
 * @name cargo
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An asynchronous function for processing an array
 * of queued tasks. Invoked with `(tasks, callback)`.
 * @param {number} [payload=Infinity] - An optional `integer` for determining
 * how many tasks should be processed per round; if omitted, the default is
 * unlimited.
 * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the cargo and inner queue.
 * @example
 *
 * // create a cargo object with payload 2
 * var cargo = async.cargo(function(tasks, callback) {
 *     for (var i=0; i<tasks.length; i++) {
 *         console.log('hello ' + tasks[i].name);
 *     }
 *     callback();
 * }, 2);
 *
 * // add some items
 * cargo.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * cargo.push({name: 'bar'}, function(err) {
 *     console.log('finished processing bar');
 * });
 * await cargo.push({name: 'baz'});
 * console.log('finished processing baz');
 */
function cargo$1(worker, payload) {
    return queue$1(worker, 1, payload);
}

/**
 * Creates a `cargoQueue` object with the specified payload. Tasks added to the
 * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.
 * If the all `workers` are in progress, the task is queued until one becomes available. Once
 * a `worker` has completed some tasks, each callback of those tasks is
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
 * for how `cargo` and `queue` work.
 *
 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
 * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,
 * the cargoQueue passes an array of tasks to multiple parallel workers.
 *
 * @name cargoQueue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @see [async.cargo]{@link module:ControlFLow.cargo}
 * @category Control Flow
 * @param {AsyncFunction} worker - An asynchronous function for processing an array
 * of queued tasks. Invoked with `(tasks, callback)`.
 * @param {number} [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @param {number} [payload=Infinity] - An optional `integer` for determining
 * how many tasks should be processed per round; if omitted, the default is
 * unlimited.
 * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the cargoQueue and inner queue.
 * @example
 *
 * // create a cargoQueue object with payload 2 and concurrency 2
 * var cargoQueue = async.cargoQueue(function(tasks, callback) {
 *     for (var i=0; i<tasks.length; i++) {
 *         console.log('hello ' + tasks[i].name);
 *     }
 *     callback();
 * }, 2, 2);
 *
 * // add some items
 * cargoQueue.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * cargoQueue.push({name: 'bar'}, function(err) {
 *     console.log('finished processing bar');
 * });
 * cargoQueue.push({name: 'baz'}, function(err) {
 *     console.log('finished processing baz');
 * });
 * cargoQueue.push({name: 'boo'}, function(err) {
 *     console.log('finished processing boo');
 * });
 */
function cargo(worker, concurrency, payload) {
    return queue$1(worker, concurrency, payload);
}

/**
 * Reduces `coll` into a single value using an async `iteratee` to return each
 * successive step. `memo` is the initial state of the reduction. This function
 * only operates in series.
 *
 * For performance reasons, it may make sense to split a call to this function
 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
 * results. This function is for situations where each step in the reduction
 * needs to be async; if you can get the data before reducing it, then it's
 * probably a good idea to do so.
 *
 * @name reduce
 * @static
 * @memberOf module:Collections
 * @method
 * @alias inject
 * @alias foldl
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee completes with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 * // file4.txt does not exist
 *
 * const fileList = ['file1.txt','file2.txt','file3.txt'];
 * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];
 *
 * // asynchronous function that computes the file size in bytes
 * // file size is added to the memoized value, then returned
 * function getFileSizeInBytes(memo, file, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         callback(null, memo + stat.size);
 *     });
 * }
 *
 * // Using callbacks
 * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {
 *     if (err) {
 *         console.log(err);
 *     } else {
 *         console.log(result);
 *         // 6000
 *         // which is the sum of the file sizes of the three files
 *     }
 * });
 *
 * // Error Handling
 * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {
 *     if (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     } else {
 *         console.log(result);
 *     }
 * });
 *
 * // Using Promises
 * async.reduce(fileList, 0, getFileSizeInBytes)
 * .then( result => {
 *     console.log(result);
 *     // 6000
 *     // which is the sum of the file sizes of the three files
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.reduce(withMissingFileList, 0, getFileSizeInBytes)
 * .then( result => {
 *     console.log(result);
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);
 *         console.log(result);
 *         // 6000
 *         // which is the sum of the file sizes of the three files
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);
 *         console.log(result);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     }
 * }
 *
 */
function reduce(coll, memo, iteratee, callback) {
    callback = once(callback);
    var _iteratee = wrapAsync(iteratee);
    return eachOfSeries$1(coll, (x, i, iterCb) => {
        _iteratee(memo, x, (err, v) => {
            memo = v;
            iterCb(err);
        });
    }, err => callback(err, memo));
}
var reduce$1 = awaitify(reduce, 4);

/**
 * Version of the compose function that is more natural to read. Each function
 * consumes the return value of the previous function. It is the equivalent of
 * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name seq
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.compose]{@link module:ControlFlow.compose}
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} a function that composes the `functions` in order
 * @example
 *
 * // Requires lodash (or underscore), express3 and dresende's orm2.
 * // Part of an app, that fetches cats of the logged user.
 * // This example uses `seq` function to avoid overnesting and error
 * // handling clutter.
 * app.get('/cats', function(request, response) {
 *     var User = request.models.User;
 *     async.seq(
 *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))
 *         function(user, fn) {
 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
 *         }
 *     )(req.session.user_id, function (err, cats) {
 *         if (err) {
 *             console.error(err);
 *             response.json({ status: 'error', message: err.message });
 *         } else {
 *             response.json({ status: 'ok', message: 'Cats found', data: cats });
 *         }
 *     });
 * });
 */
function seq(...functions) {
    var _functions = functions.map(wrapAsync);
    return function (...args) {
        var that = this;

        var cb = args[args.length - 1];
        if (typeof cb == 'function') {
            args.pop();
        } else {
            cb = promiseCallback();
        }

        reduce$1(_functions, args, (newargs, fn, iterCb) => {
            fn.apply(that, newargs.concat((err, ...nextargs) => {
                iterCb(err, nextargs);
            }));
        },
        (err, results) => cb(err, ...results));

        return cb[PROMISE_SYMBOL]
    };
}

/**
 * Creates a function which is a composition of the passed asynchronous
 * functions. Each function consumes the return value of the function that
 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
 *
 * If the last argument to the composed function is not a function, a promise
 * is returned when you call it.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name compose
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} an asynchronous function that is the composed
 * asynchronous `functions`
 * @example
 *
 * function add1(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n + 1);
 *     }, 10);
 * }
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.compose(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
function compose(...args) {
    return seq(...args.reverse());
}

/**
 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
 *
 * @name mapLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 */
function mapLimit (coll, limit, iteratee, callback) {
    return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback)
}
var mapLimit$1 = awaitify(mapLimit, 4);

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
 *
 * @name concatLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @alias flatMapLimit
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @returns A Promise, if no callback is passed
 */
function concatLimit(coll, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, ...args) => {
            if (err) return iterCb(err);
            return iterCb(err, args);
        });
    }, (err, mapResults) => {
        var result = [];
        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                result = result.concat(...mapResults[i]);
            }
        }

        return callback(err, result);
    });
}
var concatLimit$1 = awaitify(concatLimit, 4);

/**
 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
 * the concatenated list. The `iteratee`s are called in parallel, and the
 * results are concatenated as they return. The results array will be returned in
 * the original order of `coll` passed to the `iteratee` function.
 *
 * @name concat
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @alias flatMap
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @returns A Promise, if no callback is passed
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * let directoryList = ['dir1','dir2','dir3'];
 * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];
 *
 * // Using callbacks
 * async.concat(directoryList, fs.readdir, function(err, results) {
 *    if (err) {
 *        console.log(err);
 *    } else {
 *        console.log(results);
 *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
 *    }
 * });
 *
 * // Error Handling
 * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {
 *    if (err) {
 *        console.log(err);
 *        // [ Error: ENOENT: no such file or directory ]
 *        // since dir4 does not exist
 *    } else {
 *        console.log(results);
 *    }
 * });
 *
 * // Using Promises
 * async.concat(directoryList, fs.readdir)
 * .then(results => {
 *     console.log(results);
 *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
 * }).catch(err => {
 *      console.log(err);
 * });
 *
 * // Error Handling
 * async.concat(withMissingDirectoryList, fs.readdir)
 * .then(results => {
 *     console.log(results);
 * }).catch(err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4 does not exist
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let results = await async.concat(directoryList, fs.readdir);
 *         console.log(results);
 *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
 *     } catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         let results = await async.concat(withMissingDirectoryList, fs.readdir);
 *         console.log(results);
 *     } catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *         // since dir4 does not exist
 *     }
 * }
 *
 */
function concat(coll, iteratee, callback) {
    return concatLimit$1(coll, Infinity, iteratee, callback)
}
var concat$1 = awaitify(concat, 3);

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
 *
 * @name concatSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @alias flatMapSeries
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
 * The iteratee should complete with an array an array of results.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @returns A Promise, if no callback is passed
 */
function concatSeries(coll, iteratee, callback) {
    return concatLimit$1(coll, 1, iteratee, callback)
}
var concatSeries$1 = awaitify(concatSeries, 3);

/**
 * Returns a function that when called, calls-back with the values provided.
 * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
 * [`auto`]{@link module:ControlFlow.auto}.
 *
 * @name constant
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {...*} arguments... - Any number of arguments to automatically invoke
 * callback with.
 * @returns {AsyncFunction} Returns a function that when invoked, automatically
 * invokes the callback with the previous given arguments.
 * @example
 *
 * async.waterfall([
 *     async.constant(42),
 *     function (value, next) {
 *         // value === 42
 *     },
 *     //...
 * ], callback);
 *
 * async.waterfall([
 *     async.constant(filename, "utf8"),
 *     fs.readFile,
 *     function (fileData, next) {
 *         //...
 *     }
 *     //...
 * ], callback);
 *
 * async.auto({
 *     hostname: async.constant("https://server.net/"),
 *     port: findFreePort,
 *     launchServer: ["hostname", "port", function (options, cb) {
 *         startServer(options, cb);
 *     }],
 *     //...
 * }, callback);
 */
function constant$1(...args) {
    return function (...ignoredArgs/*, callback*/) {
        var callback = ignoredArgs.pop();
        return callback(null, ...args);
    };
}

function _createTester(check, getResult) {
    return (eachfn, arr, _iteratee, cb) => {
        var testPassed = false;
        var testResult;
        const iteratee = wrapAsync(_iteratee);
        eachfn(arr, (value, _, callback) => {
            iteratee(value, (err, result) => {
                if (err || err === false) return callback(err);

                if (check(result) && !testResult) {
                    testPassed = true;
                    testResult = getResult(true, value);
                    return callback(null, breakLoop);
                }
                callback();
            });
        }, err => {
            if (err) return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
        });
    };
}

/**
 * Returns the first value in `coll` that passes an async truth test. The
 * `iteratee` is applied in parallel, meaning the first iteratee to return
 * `true` will fire the detect `callback` with that result. That means the
 * result might not be the first item in the original `coll` (in terms of order)
 * that passes the test.

 * If order within the original `coll` is important, then look at
 * [`detectSeries`]{@link module:Collections.detectSeries}.
 *
 * @name detect
 * @static
 * @memberOf module:Collections
 * @method
 * @alias find
 * @category Collections
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,
 *    function(err, result) {
 *        console.log(result);
 *        // dir1/file1.txt
 *        // result now equals the first file in the list that exists
 *    }
 *);
 *
 * // Using Promises
 * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)
 * .then(result => {
 *     console.log(result);
 *     // dir1/file1.txt
 *     // result now equals the first file in the list that exists
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);
 *         console.log(result);
 *         // dir1/file1.txt
 *         // result now equals the file in the list that exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function detect(coll, iteratee, callback) {
    return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)
}
var detect$1 = awaitify(detect, 3);

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name detectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findLimit
 * @category Collections
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if a callback is omitted
 */
function detectLimit(coll, limit, iteratee, callback) {
    return _createTester(bool => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback)
}
var detectLimit$1 = awaitify(detectLimit, 4);

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
 *
 * @name detectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findSeries
 * @category Collections
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if a callback is omitted
 */
function detectSeries(coll, iteratee, callback) {
    return _createTester(bool => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback)
}

var detectSeries$1 = awaitify(detectSeries, 3);

function consoleFunc(name) {
    return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
        /* istanbul ignore else */
        if (typeof console === 'object') {
            /* istanbul ignore else */
            if (err) {
                /* istanbul ignore else */
                if (console.error) {
                    console.error(err);
                }
            } else if (console[name]) { /* istanbul ignore else */
                resultArgs.forEach(x => console[name](x));
            }
        }
    })
}

/**
 * Logs the result of an [`async` function]{@link AsyncFunction} to the
 * `console` using `console.dir` to display the properties of the resulting object.
 * Only works in Node.js or in browsers that support `console.dir` and
 * `console.error` (such as FF and Chrome).
 * If multiple arguments are returned from the async function,
 * `console.dir` is called on each argument in order.
 *
 * @name dir
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.dir(hello, 'world');
 * {hello: 'world'}
 */
var dir = consoleFunc('dir');

/**
 * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
 * the order of operations, the arguments `test` and `iteratee` are switched.
 *
 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
 *
 * @name doWhilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - A function which is called each time `test`
 * passes. Invoked with (callback).
 * @param {AsyncFunction} test - asynchronous truth test to perform after each
 * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
 * non-error args from the previous callback of `iteratee`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped.
 * `callback` will be passed an error and any arguments passed to the final
 * `iteratee`'s callback. Invoked with (err, [results]);
 * @returns {Promise} a promise, if no callback is passed
 */
function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback);
    var _fn = wrapAsync(iteratee);
    var _test = wrapAsync(test);
    var results;

    function next(err, ...args) {
        if (err) return callback(err);
        if (err === false) return;
        results = args;
        _test(...args, check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (err === false) return;
        if (!truth) return callback(null, ...results);
        _fn(next);
    }

    return check(null, true);
}

var doWhilst$1 = awaitify(doWhilst, 3);

/**
 * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
 * argument ordering differs from `until`.
 *
 * @name doUntil
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {AsyncFunction} test - asynchronous truth test to perform after each
 * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
 * non-error args from the previous callback of `iteratee`
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns {Promise} a promise, if no callback is passed
 */
function doUntil(iteratee, test, callback) {
    const _test = wrapAsync(test);
    return doWhilst$1(iteratee, (...args) => {
        const cb = args.pop();
        _test(...args, (err, truth) => cb (err, !truth));
    }, callback);
}

function _withoutIndex(iteratee) {
    return (value, index, callback) => iteratee(value, callback);
}

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];
 * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];
 *
 * // asynchronous function that deletes a file
 * const deleteFile = function(file, callback) {
 *     fs.unlink(file, callback);
 * };
 *
 * // Using callbacks
 * async.each(fileList, deleteFile, function(err) {
 *     if( err ) {
 *         console.log(err);
 *     } else {
 *         console.log('All files have been deleted successfully');
 *     }
 * });
 *
 * // Error Handling
 * async.each(withMissingFileList, deleteFile, function(err){
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using Promises
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         await async.each(files, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         await async.each(withMissingFileList, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *         // since dir4/file2.txt does not exist
 *         // dir1/file1.txt could have been deleted
 *     }
 * }
 *
 */
function eachLimit$2(coll, iteratee, callback) {
    return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}

var each = awaitify(eachLimit$2, 3);

/**
 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
 *
 * @name eachLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfLimit`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachLimit(coll, limit, iteratee, callback) {
    return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
var eachLimit$1 = awaitify(eachLimit, 4);

/**
 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
 *
 * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item
 * in series and therefore the iteratee functions will complete in order.

 * @name eachSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfSeries`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachSeries(coll, iteratee, callback) {
    return eachLimit$1(coll, 1, iteratee, callback)
}
var eachSeries$1 = awaitify(eachSeries, 3);

/**
 * Wrap an async function and ensure it calls its callback on a later tick of
 * the event loop.  If the function already calls its callback on a next tick,
 * no extra deferral is added. This is useful for preventing stack overflows
 * (`RangeError: Maximum call stack size exceeded`) and generally keeping
 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
 * contained. ES2017 `async` functions are returned as-is -- they are immune
 * to Zalgo's corrupting influences, as they always resolve on a later tick.
 *
 * @name ensureAsync
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - an async function, one that expects a node-style
 * callback as its last argument.
 * @returns {AsyncFunction} Returns a wrapped function with the exact same call
 * signature as the function passed in.
 * @example
 *
 * function sometimesAsync(arg, callback) {
 *     if (cache[arg]) {
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.mapSeries(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return function (...args/*, callback*/) {
        var callback = args.pop();
        var sync = true;
        args.push((...innerArgs) => {
            if (sync) {
                setImmediate$1(() => callback(...innerArgs));
            } else {
                callback(...innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    };
}

/**
 * Returns `true` if every element in `coll` satisfies an async test. If any
 * iteratee call returns `false`, the main `callback` is immediately called.
 *
 * @name every
 * @static
 * @memberOf module:Collections
 * @method
 * @alias all
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];
 * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * // Using callbacks
 * async.every(fileList, fileExists, function(err, result) {
 *     console.log(result);
 *     // true
 *     // result is true since every file exists
 * });
 *
 * async.every(withMissingFileList, fileExists, function(err, result) {
 *     console.log(result);
 *     // false
 *     // result is false since NOT every file exists
 * });
 *
 * // Using Promises
 * async.every(fileList, fileExists)
 * .then( result => {
 *     console.log(result);
 *     // true
 *     // result is true since every file exists
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * async.every(withMissingFileList, fileExists)
 * .then( result => {
 *     console.log(result);
 *     // false
 *     // result is false since NOT every file exists
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.every(fileList, fileExists);
 *         console.log(result);
 *         // true
 *         // result is true since every file exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * async () => {
 *     try {
 *         let result = await async.every(withMissingFileList, fileExists);
 *         console.log(result);
 *         // false
 *         // result is false since NOT every file exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function every(coll, iteratee, callback) {
    return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)
}
var every$1 = awaitify(every, 3);

/**
 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
 *
 * @name everyLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 */
function everyLimit(coll, limit, iteratee, callback) {
    return _createTester(bool => !bool, res => !res)(eachOfLimit$2(limit), coll, iteratee, callback)
}
var everyLimit$1 = awaitify(everyLimit, 4);

/**
 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
 *
 * @name everySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in series.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 */
function everySeries(coll, iteratee, callback) {
    return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)
}
var everySeries$1 = awaitify(everySeries, 3);

function filterArray(eachfn, arr, iteratee, callback) {
    var truthValues = new Array(arr.length);
    eachfn(arr, (x, index, iterCb) => {
        iteratee(x, (err, v) => {
            truthValues[index] = !!v;
            iterCb(err);
        });
    }, err => {
        if (err) return callback(err);
        var results = [];
        for (var i = 0; i < arr.length; i++) {
            if (truthValues[i]) results.push(arr[i]);
        }
        callback(null, results);
    });
}

function filterGeneric(eachfn, coll, iteratee, callback) {
    var results = [];
    eachfn(coll, (x, index, iterCb) => {
        iteratee(x, (err, v) => {
            if (err) return iterCb(err);
            if (v) {
                results.push({index, value: x});
            }
            iterCb(err);
        });
    }, err => {
        if (err) return callback(err);
        callback(null, results
            .sort((a, b) => a.index - b.index)
            .map(v => v.value));
    });
}

function _filter(eachfn, coll, iteratee, callback) {
    var filter = isArrayLike(coll) ? filterArray : filterGeneric;
    return filter(eachfn, coll, wrapAsync(iteratee), callback);
}

/**
 * Returns a new array of all the values in `coll` which pass an async truth
 * test. This operation is performed in parallel, but the results array will be
 * in the same order as the original.
 *
 * @name filter
 * @static
 * @memberOf module:Collections
 * @method
 * @alias select
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback provided
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 *
 * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * // Using callbacks
 * async.filter(files, fileExists, function(err, results) {
 *    if(err) {
 *        console.log(err);
 *    } else {
 *        console.log(results);
 *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
 *        // results is now an array of the existing files
 *    }
 * });
 *
 * // Using Promises
 * async.filter(files, fileExists)
 * .then(results => {
 *     console.log(results);
 *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
 *     // results is now an array of the existing files
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let results = await async.filter(files, fileExists);
 *         console.log(results);
 *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
 *         // results is now an array of the existing files
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function filter (coll, iteratee, callback) {
    return _filter(eachOf$1, coll, iteratee, callback)
}
var filter$1 = awaitify(filter, 3);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name filterLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback provided
 */
function filterLimit (coll, limit, iteratee, callback) {
    return _filter(eachOfLimit$2(limit), coll, iteratee, callback)
}
var filterLimit$1 = awaitify(filterLimit, 4);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
 *
 * @name filterSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results)
 * @returns {Promise} a promise, if no callback provided
 */
function filterSeries (coll, iteratee, callback) {
    return _filter(eachOfSeries$1, coll, iteratee, callback)
}
var filterSeries$1 = awaitify(filterSeries, 3);

/**
 * Calls the asynchronous function `fn` with a callback parameter that allows it
 * to call itself again, in series, indefinitely.

 * If an error is passed to the callback then `errback` is called with the
 * error, and execution stops, otherwise it will never be called.
 *
 * @name forever
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} fn - an async function to call repeatedly.
 * Invoked with (next).
 * @param {Function} [errback] - when `fn` passes an error to it's callback,
 * this function will be called, and execution stops. Invoked with (err).
 * @returns {Promise} a promise that rejects if an error occurs and an errback
 * is not passed
 * @example
 *
 * async.forever(
 *     function(next) {
 *         // next is suitable for passing to things that need a callback(err [, whatever]);
 *         // it will result in this function being called again.
 *     },
 *     function(err) {
 *         // if next is called with a value in its first parameter, it will appear
 *         // in here as 'err', and execution will stop.
 *     }
 * );
 */
function forever(fn, errback) {
    var done = onlyOnce(errback);
    var task = wrapAsync(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        if (err === false) return;
        task(next);
    }
    return next();
}
var forever$1 = awaitify(forever, 2);

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
 *
 * @name groupByLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 * @returns {Promise} a promise, if no callback is passed
 */
function groupByLimit(coll, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, key) => {
            if (err) return iterCb(err);
            return iterCb(err, {key, val});
        });
    }, (err, mapResults) => {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var {hasOwnProperty} = Object.prototype;

        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                var {key} = mapResults[i];
                var {val} = mapResults[i];

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
}

var groupByLimit$1 = awaitify(groupByLimit, 4);

/**
 * Returns a new object, where each value corresponds to an array of items, from
 * `coll`, that returned the corresponding key. That is, the keys of the object
 * correspond to the values passed to the `iteratee` callback.
 *
 * Note: Since this function applies the `iteratee` to each item in parallel,
 * there is no guarantee that the `iteratee` functions will complete in order.
 * However, the values for each key in the `result` will be in the same order as
 * the original `coll`. For Objects, the values will roughly be in the order of
 * the original Objects' keys (but this can vary across JavaScript engines).
 *
 * @name groupBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * const files = ['dir1/file1.txt','dir2','dir4']
 *
 * // asynchronous function that detects file type as none, file, or directory
 * function detectFile(file, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(null, 'none');
 *         }
 *         callback(null, stat.isDirectory() ? 'directory' : 'file');
 *     });
 * }
 *
 * //Using callbacks
 * async.groupBy(files, detectFile, function(err, result) {
 *     if(err) {
 *         console.log(err);
 *     } else {
 *	       console.log(result);
 *         // {
 *         //     file: [ 'dir1/file1.txt' ],
 *         //     none: [ 'dir4' ],
 *         //     directory: [ 'dir2']
 *         // }
 *         // result is object containing the files grouped by type
 *     }
 * });
 *
 * // Using Promises
 * async.groupBy(files, detectFile)
 * .then( result => {
 *     console.log(result);
 *     // {
 *     //     file: [ 'dir1/file1.txt' ],
 *     //     none: [ 'dir4' ],
 *     //     directory: [ 'dir2']
 *     // }
 *     // result is object containing the files grouped by type
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.groupBy(files, detectFile);
 *         console.log(result);
 *         // {
 *         //     file: [ 'dir1/file1.txt' ],
 *         //     none: [ 'dir4' ],
 *         //     directory: [ 'dir2']
 *         // }
 *         // result is object containing the files grouped by type
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function groupBy (coll, iteratee, callback) {
    return groupByLimit$1(coll, Infinity, iteratee, callback)
}

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
 *
 * @name groupBySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whose
 * properties are arrays of values which returned the corresponding key.
 * @returns {Promise} a promise, if no callback is passed
 */
function groupBySeries (coll, iteratee, callback) {
    return groupByLimit$1(coll, 1, iteratee, callback)
}

/**
 * Logs the result of an `async` function to the `console`. Only works in
 * Node.js or in browsers that support `console.log` and `console.error` (such
 * as FF and Chrome). If multiple arguments are returned from the async
 * function, `console.log` is called on each argument in order.
 *
 * @name log
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, 'hello ' + name);
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.log(hello, 'world');
 * 'hello world'
 */
var log = consoleFunc('log');

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name mapValuesLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @returns {Promise} a promise, if no callback is passed
 */
function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback);
    var newObj = {};
    var _iteratee = wrapAsync(iteratee);
    return eachOfLimit$2(limit)(obj, (val, key, next) => {
        _iteratee(val, key, (err, result) => {
            if (err) return next(err);
            newObj[key] = result;
            next(err);
        });
    }, err => callback(err, newObj));
}

var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);

/**
 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
 *
 * Produces a new Object by mapping each value of `obj` through the `iteratee`
 * function. The `iteratee` is called each `value` and `key` from `obj` and a
 * callback for when it has finished processing. Each of these callbacks takes
 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
 * passes an error to its callback, the main `callback` (for the `mapValues`
 * function) is immediately called with the error.
 *
 * Note, the order of the keys in the result is not guaranteed.  The keys will
 * be roughly in the order they complete, (but this is very engine-specific)
 *
 * @name mapValues
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 * // file4.txt does not exist
 *
 * const fileMap = {
 *     f1: 'file1.txt',
 *     f2: 'file2.txt',
 *     f3: 'file3.txt'
 * };
 *
 * const withMissingFileMap = {
 *     f1: 'file1.txt',
 *     f2: 'file2.txt',
 *     f3: 'file4.txt'
 * };
 *
 * // asynchronous function that returns the file size in bytes
 * function getFileSizeInBytes(file, key, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         callback(null, stat.size);
 *     });
 * }
 *
 * // Using callbacks
 * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {
 *     if (err) {
 *         console.log(err);
 *     } else {
 *         console.log(result);
 *         // result is now a map of file size in bytes for each file, e.g.
 *         // {
 *         //     f1: 1000,
 *         //     f2: 2000,
 *         //     f3: 3000
 *         // }
 *     }
 * });
 *
 * // Error handling
 * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {
 *     if (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     } else {
 *         console.log(result);
 *     }
 * });
 *
 * // Using Promises
 * async.mapValues(fileMap, getFileSizeInBytes)
 * .then( result => {
 *     console.log(result);
 *     // result is now a map of file size in bytes for each file, e.g.
 *     // {
 *     //     f1: 1000,
 *     //     f2: 2000,
 *     //     f3: 3000
 *     // }
 * }).catch (err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.mapValues(withMissingFileMap, getFileSizeInBytes)
 * .then( result => {
 *     console.log(result);
 * }).catch (err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.mapValues(fileMap, getFileSizeInBytes);
 *         console.log(result);
 *         // result is now a map of file size in bytes for each file, e.g.
 *         // {
 *         //     f1: 1000,
 *         //     f2: 2000,
 *         //     f3: 3000
 *         // }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);
 *         console.log(result);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     }
 * }
 *
 */
function mapValues(obj, iteratee, callback) {
    return mapValuesLimit$1(obj, Infinity, iteratee, callback)
}

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
 *
 * @name mapValuesSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @returns {Promise} a promise, if no callback is passed
 */
function mapValuesSeries(obj, iteratee, callback) {
    return mapValuesLimit$1(obj, 1, iteratee, callback)
}

/**
 * Caches the results of an async function. When creating a hash to store
 * function results against, the callback is omitted from the hash and an
 * optional hash function can be used.
 *
 * **Note: if the async function errs, the result will not be cached and
 * subsequent calls will call the wrapped function.**
 *
 * If no hash function is specified, the first argument is used as a hash key,
 * which may work reasonably if it is a string or a data type that converts to a
 * distinct string. Note that objects and arrays will not behave reasonably.
 * Neither will cases where the other arguments are significant. In such cases,
 * specify your own hash function.
 *
 * The cache of results is exposed as the `memo` property of the function
 * returned by `memoize`.
 *
 * @name memoize
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function to proxy and cache results from.
 * @param {Function} hasher - An optional function for generating a custom hash
 * for storing results. It has all the arguments applied to it apart from the
 * callback, and must be synchronous.
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.memoize(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() {
 *     // callback
 * });
 */
function memoize(fn, hasher = v => v) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    var _fn = wrapAsync(fn);
    var memoized = initialParams((args, callback) => {
        var key = hasher(...args);
        if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
        } else if (key in queues) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
                // #1465 don't memoize if an error occurred
                if (!err) {
                    memo[key] = resultArgs;
                }
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                    q[i](err, ...resultArgs);
                }
            });
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}

/* istanbul ignore file */

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `process.nextTick`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name nextTick
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.setImmediate]{@link module:Utils.setImmediate}
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer;

if (hasNextTick) {
    _defer = process.nextTick;
} else if (hasSetImmediate) {
    _defer = setImmediate;
} else {
    _defer = fallback;
}

var nextTick = wrap(_defer);

var _parallel = awaitify((eachfn, tasks, callback) => {
    var results = isArrayLike(tasks) ? [] : {};

    eachfn(tasks, (task, key, taskCb) => {
        wrapAsync(task)((err, ...result) => {
            if (result.length < 2) {
                [result] = result;
            }
            results[key] = result;
            taskCb(err);
        });
    }, err => callback(err, results));
}, 3);

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
 * execution of other tasks when a task fails.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @returns {Promise} a promise, if a callback is not passed
 *
 * @example
 *
 * //Using Callbacks
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ], function(err, results) {
 *     console.log(results);
 *     // results is equal to ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * });
 *
 * //Using Promises
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ]).then(results => {
 *     console.log(results);
 *     // results is equal to ['one','two'] even though
 *     // the second function had a shorter timeout.
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }).then(results => {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * //Using async/await
 * async () => {
 *     try {
 *         let results = await async.parallel([
 *             function(callback) {
 *                 setTimeout(function() {
 *                     callback(null, 'one');
 *                 }, 200);
 *             },
 *             function(callback) {
 *                 setTimeout(function() {
 *                     callback(null, 'two');
 *                 }, 100);
 *             }
 *         ]);
 *         console.log(results);
 *         // results is equal to ['one','two'] even though
 *         // the second function had a shorter timeout.
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // an example using an object instead of an array
 * async () => {
 *     try {
 *         let results = await async.parallel({
 *             one: function(callback) {
 *                 setTimeout(function() {
 *                     callback(null, 1);
 *                 }, 200);
 *             },
 *            two: function(callback) {
 *                 setTimeout(function() {
 *                     callback(null, 2);
 *                 }, 100);
 *            }
 *         });
 *         console.log(results);
 *         // results is equal to: { one: 1, two: 2 }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function parallel(tasks, callback) {
    return _parallel(eachOf$1, tasks, callback);
}

/**
 * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name parallelLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.parallel]{@link module:ControlFlow.parallel}
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @returns {Promise} a promise, if a callback is not passed
 */
function parallelLimit(tasks, limit, callback) {
    return _parallel(eachOfLimit$2(limit), tasks, callback);
}

/**
 * A queue of tasks for the worker function to complete.
 * @typedef {Iterable} QueueObject
 * @memberOf module:ControlFlow
 * @property {Function} length - a function returning the number of items
 * waiting to be processed. Invoke with `queue.length()`.
 * @property {boolean} started - a boolean indicating whether or not any
 * items have been pushed and processed by the queue.
 * @property {Function} running - a function returning the number of items
 * currently being processed. Invoke with `queue.running()`.
 * @property {Function} workersList - a function returning the array of items
 * currently being processed. Invoke with `queue.workersList()`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
 * @property {number} concurrency - an integer for determining how many `worker`
 * functions should be run in parallel. This property can be changed after a
 * `queue` is created to alter the concurrency on-the-fly.
 * @property {number} payload - an integer that specifies how many items are
 * passed to the worker function at a time. only applies if this is a
 * [cargo]{@link module:ControlFlow.cargo} object
 * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`
 * once the `worker` has finished processing the task. Instead of a single task,
 * a `tasks` array can be submitted. The respective callback is used for every
 * task in the list. Invoke with `queue.push(task, [callback])`,
 * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.
 * Invoke with `queue.unshift(task, [callback])`.
 * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns
 * a promise that rejects if an error occurs.
 * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns
 * a promise that rejects if an error occurs.
 * @property {Function} remove - remove items from the queue that match a test
 * function.  The test function will be passed an object with a `data` property,
 * and a `priority` property, if this is a
 * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
 * `function ({data, priority}) {}` and returns a Boolean.
 * @property {Function} saturated - a function that sets a callback that is
 * called when the number of running workers hits the `concurrency` limit, and
 * further tasks will be queued.  If the callback is omitted, `q.saturated()`
 * returns a promise for the next occurrence.
 * @property {Function} unsaturated - a function that sets a callback that is
 * called when the number of running workers is less than the `concurrency` &
 * `buffer` limits, and further tasks will not be queued. If the callback is
 * omitted, `q.unsaturated()` returns a promise for the next occurrence.
 * @property {number} buffer - A minimum threshold buffer in order to say that
 * the `queue` is `unsaturated`.
 * @property {Function} empty - a function that sets a callback that is called
 * when the last item from the `queue` is given to a `worker`. If the callback
 * is omitted, `q.empty()` returns a promise for the next occurrence.
 * @property {Function} drain - a function that sets a callback that is called
 * when the last item from the `queue` has returned from the `worker`. If the
 * callback is omitted, `q.drain()` returns a promise for the next occurrence.
 * @property {Function} error - a function that sets a callback that is called
 * when a task errors. Has the signature `function(error, task)`. If the
 * callback is omitted, `error()` returns a promise that rejects on the next
 * error.
 * @property {boolean} paused - a boolean for determining whether the queue is
 * in a paused state.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke with `queue.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. No more tasks
 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
 *
 * @example
 * const q = async.queue(worker, 2)
 * q.push(item1)
 * q.push(item2)
 * q.push(item3)
 * // queues are iterable, spread into an array to inspect
 * const items = [...q] // [item1, item2, item3]
 * // or use for of
 * for (let item of q) {
 *     console.log(item)
 * }
 *
 * q.drain(() => {
 *     console.log('all done')
 * })
 * // or
 * await q.drain()
 */

/**
 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
 * `queue` are processed in parallel (up to the `concurrency` limit). If all
 * `worker`s are in progress, the task is queued until one becomes available.
 * Once a `worker` completes a `task`, that `task`'s callback is called.
 *
 * @name queue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`. Invoked with (task, callback).
 * @param {number} [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be
 * attached as certain properties to listen for specific events during the
 * lifecycle of the queue.
 * @example
 *
 * // create a queue object with concurrency 2
 * var q = async.queue(function(task, callback) {
 *     console.log('hello ' + task.name);
 *     callback();
 * }, 2);
 *
 * // assign a callback
 * q.drain(function() {
 *     console.log('all items have been processed');
 * });
 * // or await the end
 * await q.drain()
 *
 * // assign an error callback
 * q.error(function(err, task) {
 *     console.error('task experienced an error');
 * });
 *
 * // add some items to the queue
 * q.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * // callback is optional
 * q.push({name: 'bar'});
 *
 * // add some items to the queue (batch-wise)
 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
 *     console.log('finished processing item');
 * });
 *
 * // add some items to the front of the queue
 * q.unshift({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 */
function queue (worker, concurrency) {
    var _worker = wrapAsync(worker);
    return queue$1((items, cb) => {
        _worker(items[0], cb);
    }, concurrency, 1);
}

// Binary min-heap implementation used for priority queue.
// Implementation is stable, i.e. push time is considered for equal priorities
class Heap {
    constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
    }

    get length() {
        return this.heap.length;
    }

    empty () {
        this.heap = [];
        return this;
    }

    percUp(index) {
        let p;

        while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {
            let t = this.heap[index];
            this.heap[index] = this.heap[p];
            this.heap[p] = t;

            index = p;
        }
    }

    percDown(index) {
        let l;

        while ((l=leftChi(index)) < this.heap.length) {
            if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {
                l = l+1;
            }

            if (smaller(this.heap[index], this.heap[l])) {
                break;
            }

            let t = this.heap[index];
            this.heap[index] = this.heap[l];
            this.heap[l] = t;

            index = l;
        }
    }

    push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length-1);
    }

    unshift(node) {
        return this.heap.push(node);
    }

    shift() {
        let [top] = this.heap;

        this.heap[0] = this.heap[this.heap.length-1];
        this.heap.pop();
        this.percDown(0);

        return top;
    }

    toArray() {
        return [...this];
    }

    *[Symbol.iterator] () {
        for (let i = 0; i < this.heap.length; i++) {
            yield this.heap[i].data;
        }
    }

    remove (testFn) {
        let j = 0;
        for (let i = 0; i < this.heap.length; i++) {
            if (!testFn(this.heap[i])) {
                this.heap[j] = this.heap[i];
                j++;
            }
        }

        this.heap.splice(j);

        for (let i = parent(this.heap.length-1); i >= 0; i--) {
            this.percDown(i);
        }

        return this;
    }
}

function leftChi(i) {
    return (i<<1)+1;
}

function parent(i) {
    return ((i+1)>>1)-1;
}

function smaller(x, y) {
    if (x.priority !== y.priority) {
        return x.priority < y.priority;
    }
    else {
        return x.pushCount < y.pushCount;
    }
}

/**
 * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
 * completed in ascending priority order.
 *
 * @name priorityQueue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`.
 * Invoked with (task, callback).
 * @param {number} concurrency - An `integer` for determining how many `worker`
 * functions should be run in parallel.  If omitted, the concurrency defaults to
 * `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three
 * differences between `queue` and `priorityQueue` objects:
 * * `push(task, priority, [callback])` - `priority` should be a number. If an
 *   array of `tasks` is given, all tasks will be assigned the same priority.
 * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,
 *   except this returns a promise that rejects if an error occurs.
 * * The `unshift` and `unshiftAsync` methods were removed.
 */
function priorityQueue(worker, concurrency) {
    // Start with a normal queue
    var q = queue(worker, concurrency);

    var {
        push,
        pushAsync
    } = q;

    q._tasks = new Heap();
    q._createTaskItem = ({data, priority}, callback) => {
        return {
            data,
            priority,
            callback
        };
    };

    function createDataItems(tasks, priority) {
        if (!Array.isArray(tasks)) {
            return {data: tasks, priority};
        }
        return tasks.map(data => { return {data, priority}; });
    }

    // Override push to accept second parameter representing priority
    q.push = function(data, priority = 0, callback) {
        return push(createDataItems(data, priority), callback);
    };

    q.pushAsync = function(data, priority = 0, callback) {
        return pushAsync(createDataItems(data, priority), callback);
    };

    // Remove unshift functions
    delete q.unshift;
    delete q.unshiftAsync;

    return q;
}

/**
 * Runs the `tasks` array of functions in parallel, without waiting until the
 * previous function has completed. Once any of the `tasks` complete or pass an
 * error to its callback, the main `callback` is immediately called. It's
 * equivalent to `Promise.race()`.
 *
 * @name race
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
 * to run. Each function can complete with an optional `result` value.
 * @param {Function} callback - A callback to run once any of the functions have
 * completed. This function gets an error or result from the first function that
 * completed. Invoked with (err, result).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * async.race([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // main callback
 * function(err, result) {
 *     // the result will be equal to 'two' as it finishes earlier
 * });
 */
function race(tasks, callback) {
    callback = once(callback);
    if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i < l; i++) {
        wrapAsync(tasks[i])(callback);
    }
}

var race$1 = awaitify(race, 2);

/**
 * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
 *
 * @name reduceRight
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reduce]{@link module:Collections.reduce}
 * @alias foldr
 * @category Collection
 * @param {Array} array - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee completes with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @returns {Promise} a promise, if no callback is passed
 */
function reduceRight (array, memo, iteratee, callback) {
    var reversed = [...array].reverse();
    return reduce$1(reversed, memo, iteratee, callback);
}

/**
 * Wraps the async function in another function that always completes with a
 * result object, even when it errors.
 *
 * The result object has either the property `error` or `value`.
 *
 * @name reflect
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function you want to wrap
 * @returns {Function} - A function that always passes null to it's callback as
 * the error. The second argument to the callback will be an `object` with
 * either an `error` or a `value` property.
 * @example
 *
 * async.parallel([
 *     async.reflect(function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff but error ...
 *         callback('bad stuff happened');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     })
 * ],
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = 'bad stuff happened'
 *     // results[2].value = 'two'
 * });
 */
function reflect(fn) {
    var _fn = wrapAsync(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error) {
                retVal.error = error;
            }
            if (cbArgs.length > 0){
                var value = cbArgs;
                if (cbArgs.length <= 1) {
                    [value] = cbArgs;
                }
                retVal.value = value;
            }
            reflectCallback(null, retVal);
        });

        return _fn.apply(this, args);
    });
}

/**
 * A helper function that wraps an array or an object of functions with `reflect`.
 *
 * @name reflectAll
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.reflect]{@link module:Utils.reflect}
 * @category Util
 * @param {Array|Object|Iterable} tasks - The collection of
 * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
 * @returns {Array} Returns an array of async functions, each wrapped in
 * `async.reflect`
 * @example
 *
 * let tasks = [
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         // do some more stuff but error ...
 *         callback(new Error('bad stuff happened'));
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ];
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = Error('bad stuff happened')
 *     // results[2].value = 'two'
 * });
 *
 * // an example using an object instead of an array
 * let tasks = {
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         callback('two');
 *     },
 *     three: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'three');
 *         }, 100);
 *     }
 * };
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results.one.value = 'one'
 *     // results.two.error = 'two'
 *     // results.three.value = 'three'
 * });
 */
function reflectAll(tasks) {
    var results;
    if (Array.isArray(tasks)) {
        results = tasks.map(reflect);
    } else {
        results = {};
        Object.keys(tasks).forEach(key => {
            results[key] = reflect.call(this, tasks[key]);
        });
    }
    return results;
}

function reject$2(eachfn, arr, _iteratee, callback) {
    const iteratee = wrapAsync(_iteratee);
    return _filter(eachfn, arr, (value, cb) => {
        iteratee(value, (err, v) => {
            cb(err, !v);
        });
    }, callback);
}

/**
 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
 *
 * @name reject
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 *
 * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * // Using callbacks
 * async.reject(fileList, fileExists, function(err, results) {
 *    // [ 'dir3/file6.txt' ]
 *    // results now equals an array of the non-existing files
 * });
 *
 * // Using Promises
 * async.reject(fileList, fileExists)
 * .then( results => {
 *     console.log(results);
 *     // [ 'dir3/file6.txt' ]
 *     // results now equals an array of the non-existing files
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let results = await async.reject(fileList, fileExists);
 *         console.log(results);
 *         // [ 'dir3/file6.txt' ]
 *         // results now equals an array of the non-existing files
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function reject (coll, iteratee, callback) {
    return reject$2(eachOf$1, coll, iteratee, callback)
}
var reject$1 = awaitify(reject, 3);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name rejectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 */
function rejectLimit (coll, limit, iteratee, callback) {
    return reject$2(eachOfLimit$2(limit), coll, iteratee, callback)
}
var rejectLimit$1 = awaitify(rejectLimit, 4);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
 *
 * @name rejectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 */
function rejectSeries (coll, iteratee, callback) {
    return reject$2(eachOfSeries$1, coll, iteratee, callback)
}
var rejectSeries$1 = awaitify(rejectSeries, 3);

function constant(value) {
    return function () {
        return value;
    }
}

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @see [async.retryable]{@link module:ControlFlow.retryable}
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param {AsyncFunction} task - An async function to retry.
 * Invoked with (callback).
 * @param {Function} [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 * @returns {Promise} a promise if no callback provided
 *
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry({
 *   times: 10,
 *   interval: function(retryCount) {
 *     return 50 * Math.pow(2, retryCount);
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry({
 *   errorFilter: function(err) {
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // to retry individual methods that are not as reliable within other
 * // control flow functions, use the `retryable` wrapper:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.retryable(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
const DEFAULT_TIMES = 5;
const DEFAULT_INTERVAL = 0;

function retry(opts, task, callback) {
    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant(DEFAULT_INTERVAL)
    };

    if (arguments.length < 3 && typeof opts === 'function') {
        callback = task || promiseCallback();
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || promiseCallback();
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = wrapAsync(task);

    var attempt = 1;
    function retryAttempt() {
        _task((err, ...args) => {
            if (err === false) return
            if (err && attempt++ < options.times &&
                (typeof options.errorFilter != 'function' ||
                    options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
                callback(err, ...args);
            }
        });
    }

    retryAttempt();
    return callback[PROMISE_SYMBOL]
}

function parseTimes(acc, t) {
    if (typeof t === 'object') {
        acc.times = +t.times || DEFAULT_TIMES;

        acc.intervalFunc = typeof t.interval === 'function' ?
            t.interval :
            constant(+t.interval || DEFAULT_INTERVAL);

        acc.errorFilter = t.errorFilter;
    } else if (typeof t === 'number' || typeof t === 'string') {
        acc.times = +t || DEFAULT_TIMES;
    } else {
        throw new Error("Invalid arguments for async.retry");
    }
}

/**
 * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
 * wraps a task and makes it retryable, rather than immediately calling it
 * with retries.
 *
 * @name retryable
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.retry]{@link module:ControlFlow.retry}
 * @category Control Flow
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
 * options, exactly the same as from `retry`, except for a `opts.arity` that
 * is the arity of the `task` function, defaulting to `task.length`
 * @param {AsyncFunction} task - the asynchronous function to wrap.
 * This function will be passed any arguments passed to the returned wrapper.
 * Invoked with (...args, callback).
 * @returns {AsyncFunction} The wrapped function, which when invoked, will
 * retry on an error, based on the parameters specified in `opts`.
 * This function will accept the same parameters as `task`.
 * @example
 *
 * async.auto({
 *     dep1: async.retryable(3, getFromFlakyService),
 *     process: ["dep1", async.retryable(3, function (results, cb) {
 *         maybeProcessData(results.dep1, cb);
 *     })]
 * }, callback);
 */
function retryable (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    let arity = (opts && opts.arity) || task.length;
    if (isAsync(task)) {
        arity += 1;
    }
    var _task = wrapAsync(task);
    return initialParams((args, callback) => {
        if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
        }
        function taskFn(cb) {
            _task(...args, cb);
        }

        if (opts) retry(opts, taskFn, callback);
        else retry(taskFn, callback);

        return callback[PROMISE_SYMBOL]
    });
}

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
 * [async functions]{@link AsyncFunction} to run in series.
 * Each function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @return {Promise} a promise, if no callback is passed
 * @example
 *
 * //Using Callbacks
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ], function(err, results) {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * });
 *
 * // an example using objects instead of arrays
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * });
 *
 * //Using Promises
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ]).then(results => {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // an example using an object instead of an array
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }).then(results => {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * //Using async/await
 * async () => {
 *     try {
 *         let results = await async.series([
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 'one');
 *                 }, 200);
 *             },
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 'two');
 *                 }, 100);
 *             }
 *         ]);
 *         console.log(results);
 *         // results is equal to ['one','two']
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // an example using an object instead of an array
 * async () => {
 *     try {
 *         let results = await async.parallel({
 *             one: function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 1);
 *                 }, 200);
 *             },
 *            two: function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 2);
 *                 }, 100);
 *            }
 *         });
 *         console.log(results);
 *         // results is equal to: { one: 1, two: 2 }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function series(tasks, callback) {
    return _parallel(eachOfSeries$1, tasks, callback);
}

/**
 * Returns `true` if at least one element in the `coll` satisfies an async test.
 * If any iteratee call returns `true`, the main `callback` is immediately
 * called.
 *
 * @name some
 * @static
 * @memberOf module:Collections
 * @method
 * @alias any
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * // asynchronous function that checks if a file exists
 * function fileExists(file, callback) {
 *    fs.access(file, fs.constants.F_OK, (err) => {
 *        callback(null, !err);
 *    });
 * }
 *
 * // Using callbacks
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,
 *    function(err, result) {
 *        console.log(result);
 *        // true
 *        // result is true since some file in the list exists
 *    }
 *);
 *
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,
 *    function(err, result) {
 *        console.log(result);
 *        // false
 *        // result is false since none of the files exists
 *    }
 *);
 *
 * // Using Promises
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)
 * .then( result => {
 *     console.log(result);
 *     // true
 *     // result is true since some file in the list exists
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)
 * .then( result => {
 *     console.log(result);
 *     // false
 *     // result is false since none of the files exists
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);
 *         console.log(result);
 *         // true
 *         // result is true since some file in the list exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * async () => {
 *     try {
 *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);
 *         console.log(result);
 *         // false
 *         // result is false since none of the files exists
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function some(coll, iteratee, callback) {
    return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)
}
var some$1 = awaitify(some, 3);

/**
 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
 *
 * @name someLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anyLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 */
function someLimit(coll, limit, iteratee, callback) {
    return _createTester(Boolean, res => res)(eachOfLimit$2(limit), coll, iteratee, callback)
}
var someLimit$1 = awaitify(someLimit, 4);

/**
 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
 *
 * @name someSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anySeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in series.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 */
function someSeries(coll, iteratee, callback) {
    return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)
}
var someSeries$1 = awaitify(someSeries, 3);

/**
 * Sorts a list by the results of running each `coll` value through an async
 * `iteratee`.
 *
 * @name sortBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a value to use as the sort criteria as
 * its `result`.
 * Invoked with (item, callback).
 * @param {Function} callback - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is the items
 * from the original `coll` sorted by the values returned by the `iteratee`
 * calls. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback passed
 * @example
 *
 * // bigfile.txt is a file that is 251100 bytes in size
 * // mediumfile.txt is a file that is 11000 bytes in size
 * // smallfile.txt is a file that is 121 bytes in size
 *
 * // asynchronous function that returns the file size in bytes
 * function getFileSizeInBytes(file, callback) {
 *     fs.stat(file, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         callback(null, stat.size);
 *     });
 * }
 *
 * // Using callbacks
 * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,
 *     function(err, results) {
 *         if (err) {
 *             console.log(err);
 *         } else {
 *             console.log(results);
 *             // results is now the original array of files sorted by
 *             // file size (ascending by default), e.g.
 *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
 *         }
 *     }
 * );
 *
 * // By modifying the callback parameter the
 * // sorting order can be influenced:
 *
 * // ascending order
 * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {
 *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
 *         if (getFileSizeErr) return callback(getFileSizeErr);
 *         callback(null, fileSize);
 *     });
 * }, function(err, results) {
 *         if (err) {
 *             console.log(err);
 *         } else {
 *             console.log(results);
 *             // results is now the original array of files sorted by
 *             // file size (ascending by default), e.g.
 *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
 *         }
 *     }
 * );
 *
 * // descending order
 * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {
 *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
 *         if (getFileSizeErr) {
 *             return callback(getFileSizeErr);
 *         }
 *         callback(null, fileSize * -1);
 *     });
 * }, function(err, results) {
 *         if (err) {
 *             console.log(err);
 *         } else {
 *             console.log(results);
 *             // results is now the original array of files sorted by
 *             // file size (ascending by default), e.g.
 *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']
 *         }
 *     }
 * );
 *
 * // Error handling
 * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,
 *     function(err, results) {
 *         if (err) {
 *             console.log(err);
 *             // [ Error: ENOENT: no such file or directory ]
 *         } else {
 *             console.log(results);
 *         }
 *     }
 * );
 *
 * // Using Promises
 * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)
 * .then( results => {
 *     console.log(results);
 *     // results is now the original array of files sorted by
 *     // file size (ascending by default), e.g.
 *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error handling
 * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)
 * .then( results => {
 *     console.log(results);
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 * });
 *
 * // Using async/await
 * (async () => {
 *     try {
 *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
 *         console.log(results);
 *         // results is now the original array of files sorted by
 *         // file size (ascending by default), e.g.
 *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * })();
 *
 * // Error handling
 * async () => {
 *     try {
 *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
 *         console.log(results);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *     }
 * }
 *
 */
function sortBy (coll, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    return map$1(coll, (x, iterCb) => {
        _iteratee(x, (err, criteria) => {
            if (err) return iterCb(err);
            iterCb(err, {value: x, criteria});
        });
    }, (err, results) => {
        if (err) return callback(err);
        callback(null, results.sort(comparator).map(v => v.value));
    });

    function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
    }
}
var sortBy$1 = awaitify(sortBy, 3);

/**
 * Sets a time limit on an asynchronous function. If the function does not call
 * its callback within the specified milliseconds, it will be called with a
 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
 *
 * @name timeout
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} asyncFn - The async function to limit in time.
 * @param {number} milliseconds - The specified time limit.
 * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
 * to timeout Error for more information..
 * @returns {AsyncFunction} Returns a wrapped function that can be used with any
 * of the control flow functions.
 * Invoke this function with the same parameters as you would `asyncFunc`.
 * @example
 *
 * function myFunction(foo, callback) {
 *     doAsyncTask(foo, function(err, data) {
 *         // handle errors
 *         if (err) return callback(err);
 *
 *         // do some stuff ...
 *
 *         // return processed data
 *         return callback(null, data);
 *     });
 * }
 *
 * var wrapped = async.timeout(myFunction, 1000);
 *
 * // call `wrapped` as you would `myFunction`
 * wrapped({ bar: 'bar' }, function(err, data) {
 *     // if `myFunction` takes < 1000 ms to execute, `err`
 *     // and `data` will have their expected values
 *
 *     // else `err` will be an Error with the code 'ETIMEDOUT'
 * });
 */
function timeout(asyncFn, milliseconds, info) {
    var fn = wrapAsync(asyncFn);

    return initialParams((args, callback) => {
        var timedOut = false;
        var timer;

        function timeoutCallback() {
            var name = asyncFn.name || 'anonymous';
            var error  = new Error('Callback function "' + name + '" timed out.');
            error.code = 'ETIMEDOUT';
            if (info) {
                error.info = info;
            }
            timedOut = true;
            callback(error);
        }

        args.push((...cbArgs) => {
            if (!timedOut) {
                callback(...cbArgs);
                clearTimeout(timer);
            }
        });

        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn(...args);
    });
}

function range(size) {
    var result = Array(size);
    while (size--) {
        result[size] = size;
    }
    return result;
}

/**
 * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name timesLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} count - The number of times to run the function.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see [async.map]{@link module:Collections.map}.
 * @returns {Promise} a promise, if no callback is provided
 */
function timesLimit(count, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    return mapLimit$1(range(count), limit, _iteratee, callback);
}

/**
 * Calls the `iteratee` function `n` times, and accumulates results in the same
 * manner you would use with [map]{@link module:Collections.map}.
 *
 * @name times
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 * @returns {Promise} a promise, if no callback is provided
 * @example
 *
 * // Pretend this is some complicated async factory
 * var createUser = function(id, callback) {
 *     callback(null, {
 *         id: 'user' + id
 *     });
 * };
 *
 * // generate 5 users
 * async.times(5, function(n, next) {
 *     createUser(n, function(err, user) {
 *         next(err, user);
 *     });
 * }, function(err, users) {
 *     // we should now have 5 users
 * });
 */
function times (n, iteratee, callback) {
    return timesLimit(n, Infinity, iteratee, callback)
}

/**
 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
 *
 * @name timesSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 * @returns {Promise} a promise, if no callback is provided
 */
function timesSeries (n, iteratee, callback) {
    return timesLimit(n, 1, iteratee, callback)
}

/**
 * A relative of `reduce`.  Takes an Object or Array, and iterates over each
 * element in parallel, each step potentially mutating an `accumulator` value.
 * The type of the accumulator defaults to the type of collection passed in.
 *
 * @name transform
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {*} [accumulator] - The initial state of the transform.  If omitted,
 * it will default to an empty Object or Array, depending on the type of `coll`
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * collection that potentially modifies the accumulator.
 * Invoked with (accumulator, item, key, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the transformed accumulator.
 * Invoked with (err, result).
 * @returns {Promise} a promise, if no callback provided
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 *
 * // helper function that returns human-readable size format from bytes
 * function formatBytes(bytes, decimals = 2) {
 *   // implementation not included for brevity
 *   return humanReadbleFilesize;
 * }
 *
 * const fileList = ['file1.txt','file2.txt','file3.txt'];
 *
 * // asynchronous function that returns the file size, transformed to human-readable format
 * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
 * function transformFileSize(acc, value, key, callback) {
 *     fs.stat(value, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         acc[key] = formatBytes(stat.size);
 *         callback(null);
 *     });
 * }
 *
 * // Using callbacks
 * async.transform(fileList, transformFileSize, function(err, result) {
 *     if(err) {
 *         console.log(err);
 *     } else {
 *         console.log(result);
 *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
 *     }
 * });
 *
 * // Using Promises
 * async.transform(fileList, transformFileSize)
 * .then(result => {
 *     console.log(result);
 *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * (async () => {
 *     try {
 *         let result = await async.transform(fileList, transformFileSize);
 *         console.log(result);
 *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * })();
 *
 * @example
 *
 * // file1.txt is a file that is 1000 bytes in size
 * // file2.txt is a file that is 2000 bytes in size
 * // file3.txt is a file that is 3000 bytes in size
 *
 * // helper function that returns human-readable size format from bytes
 * function formatBytes(bytes, decimals = 2) {
 *   // implementation not included for brevity
 *   return humanReadbleFilesize;
 * }
 *
 * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };
 *
 * // asynchronous function that returns the file size, transformed to human-readable format
 * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
 * function transformFileSize(acc, value, key, callback) {
 *     fs.stat(value, function(err, stat) {
 *         if (err) {
 *             return callback(err);
 *         }
 *         acc[key] = formatBytes(stat.size);
 *         callback(null);
 *     });
 * }
 *
 * // Using callbacks
 * async.transform(fileMap, transformFileSize, function(err, result) {
 *     if(err) {
 *         console.log(err);
 *     } else {
 *         console.log(result);
 *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
 *     }
 * });
 *
 * // Using Promises
 * async.transform(fileMap, transformFileSize)
 * .then(result => {
 *     console.log(result);
 *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.transform(fileMap, transformFileSize);
 *         console.log(result);
 *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function transform (coll, accumulator, iteratee, callback) {
    if (arguments.length <= 3 && typeof accumulator === 'function') {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = Array.isArray(coll) ? [] : {};
    }
    callback = once(callback || promiseCallback());
    var _iteratee = wrapAsync(iteratee);

    eachOf$1(coll, (v, k, cb) => {
        _iteratee(accumulator, v, k, cb);
    }, err => callback(err, accumulator));
    return callback[PROMISE_SYMBOL]
}

/**
 * It runs each task in series but stops whenever any of the functions were
 * successful. If one of the tasks were successful, the `callback` will be
 * passed the result of the successful task. If all tasks fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name tryEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to
 * run, each function is passed a `callback(err, result)` it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback which is called when one
 * of the tasks has succeeded, or all have failed. It receives the `err` and
 * `result` arguments of the last attempt at completing the `task`. Invoked with
 * (err, results).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 * async.tryEach([
 *     function getDataFromFirstWebsite(callback) {
 *         // Try getting the data from the first website
 *         callback(err, data);
 *     },
 *     function getDataFromSecondWebsite(callback) {
 *         // First website failed,
 *         // Try getting the data from the backup website
 *         callback(err, data);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     Now do something with the data.
 * });
 *
 */
function tryEach(tasks, callback) {
    var error = null;
    var result;
    return eachSeries$1(tasks, (task, taskCb) => {
        wrapAsync(task)((err, ...args) => {
            if (err === false) return taskCb(err);

            if (args.length < 2) {
                [result] = args;
            } else {
                result = args;
            }
            error = err;
            taskCb(err ? null : {});
        });
    }, () => callback(error, result));
}

var tryEach$1 = awaitify(tryEach);

/**
 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
 * unmemoized form. Handy for testing.
 *
 * @name unmemoize
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.memoize]{@link module:Utils.memoize}
 * @category Util
 * @param {AsyncFunction} fn - the memoized function
 * @returns {AsyncFunction} a function that calls the original unmemoized function
 */
function unmemoize(fn) {
    return (...args) => {
        return (fn.unmemoized || fn)(...args);
    };
}

/**
 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs.
 *
 * @name whilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `iteratee`. Invoked with (callback).
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * var count = 0;
 * async.whilst(
 *     function test(cb) { cb(null, count < 5); },
 *     function iter(callback) {
 *         count++;
 *         setTimeout(function() {
 *             callback(null, count);
 *         }, 1000);
 *     },
 *     function (err, n) {
 *         // 5 seconds have passed, n = 5
 *     }
 * );
 */
function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback);
    var _fn = wrapAsync(iteratee);
    var _test = wrapAsync(test);
    var results = [];

    function next(err, ...rest) {
        if (err) return callback(err);
        results = rest;
        if (err === false) return;
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (err === false) return;
        if (!truth) return callback(null, ...results);
        _fn(next);
    }

    return _test(check);
}
var whilst$1 = awaitify(whilst, 3);

/**
 * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs. `callback` will be passed an error and any
 * arguments passed to the final `iteratee`'s callback.
 *
 * The inverse of [whilst]{@link module:ControlFlow.whilst}.
 *
 * @name until
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `iteratee`. Invoked with (callback).
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns {Promise} a promise, if a callback is not passed
 *
 * @example
 * const results = []
 * let finished = false
 * async.until(function test(cb) {
 *     cb(null, finished)
 * }, function iter(next) {
 *     fetchPage(url, (err, body) => {
 *         if (err) return next(err)
 *         results = results.concat(body.objects)
 *         finished = !!body.next
 *         next(err)
 *     })
 * }, function done (err) {
 *     // all pages have been fetched
 * })
 */
function until(test, iteratee, callback) {
    const _test = wrapAsync(test);
    return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);
}

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
 * to run.
 * Each function should complete with any number of `result` values.
 * The `result` values will be passed as arguments, in order, to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
function waterfall (tasks, callback) {
    callback = once(callback);
    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        task(...args, onlyOnce(next));
    }

    function next(err, ...args) {
        if (err === false) return
        if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
        }
        nextTask(args);
    }

    nextTask([]);
}

var waterfall$1 = awaitify(waterfall);

/**
 * An "async function" in the context of Async is an asynchronous function with
 * a variable number of parameters, with the final parameter being a callback.
 * (`function (arg1, arg2, ..., callback) {}`)
 * The final callback is of the form `callback(err, results...)`, which must be
 * called once the function is completed.  The callback should be called with a
 * Error as its first argument to signal that an error occurred.
 * Otherwise, if no error occurred, it should be called with `null` as the first
 * argument, and any additional `result` arguments that may apply, to signal
 * successful completion.
 * The callback must be called exactly once, ideally on a later tick of the
 * JavaScript event loop.
 *
 * This type of function is also referred to as a "Node-style async function",
 * or a "continuation passing-style function" (CPS). Most of the methods of this
 * library are themselves CPS/Node-style async functions, or functions that
 * return CPS/Node-style async functions.
 *
 * Wherever we accept a Node-style async function, we also directly accept an
 * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
 * In this case, the `async` function will not be passed a final callback
 * argument, and any thrown error will be used as the `err` argument of the
 * implicit callback, and the return value will be used as the `result` value.
 * (i.e. a `rejected` of the returned Promise becomes the `err` callback
 * argument, and a `resolved` value becomes the `result`.)
 *
 * Note, due to JavaScript limitations, we can only detect native `async`
 * functions and not transpilied implementations.
 * Your environment must have `async`/`await` support for this to work.
 * (e.g. Node > v7.6, or a recent version of a modern browser).
 * If you are using `async` functions through a transpiler (e.g. Babel), you
 * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
 * because the `async function` will be compiled to an ordinary function that
 * returns a promise.
 *
 * @typedef {Function} AsyncFunction
 * @static
 */


var index = {
    apply,
    applyEach,
    applyEachSeries,
    asyncify,
    auto,
    autoInject,
    cargo: cargo$1,
    cargoQueue: cargo,
    compose,
    concat: concat$1,
    concatLimit: concatLimit$1,
    concatSeries: concatSeries$1,
    constant: constant$1,
    detect: detect$1,
    detectLimit: detectLimit$1,
    detectSeries: detectSeries$1,
    dir,
    doUntil,
    doWhilst: doWhilst$1,
    each,
    eachLimit: eachLimit$1,
    eachOf: eachOf$1,
    eachOfLimit: eachOfLimit$1,
    eachOfSeries: eachOfSeries$1,
    eachSeries: eachSeries$1,
    ensureAsync,
    every: every$1,
    everyLimit: everyLimit$1,
    everySeries: everySeries$1,
    filter: filter$1,
    filterLimit: filterLimit$1,
    filterSeries: filterSeries$1,
    forever: forever$1,
    groupBy,
    groupByLimit: groupByLimit$1,
    groupBySeries,
    log,
    map: map$1,
    mapLimit: mapLimit$1,
    mapSeries: mapSeries$1,
    mapValues,
    mapValuesLimit: mapValuesLimit$1,
    mapValuesSeries,
    memoize,
    nextTick,
    parallel,
    parallelLimit,
    priorityQueue,
    queue,
    race: race$1,
    reduce: reduce$1,
    reduceRight,
    reflect,
    reflectAll,
    reject: reject$1,
    rejectLimit: rejectLimit$1,
    rejectSeries: rejectSeries$1,
    retry,
    retryable,
    seq,
    series,
    setImmediate: setImmediate$1,
    some: some$1,
    someLimit: someLimit$1,
    someSeries: someSeries$1,
    sortBy: sortBy$1,
    timeout,
    times,
    timesLimit,
    timesSeries,
    transform,
    tryEach: tryEach$1,
    unmemoize,
    until,
    waterfall: waterfall$1,
    whilst: whilst$1,

    // aliases
    all: every$1,
    allLimit: everyLimit$1,
    allSeries: everySeries$1,
    any: some$1,
    anyLimit: someLimit$1,
    anySeries: someSeries$1,
    find: detect$1,
    findLimit: detectLimit$1,
    findSeries: detectSeries$1,
    flatMap: concat$1,
    flatMapLimit: concatLimit$1,
    flatMapSeries: concatSeries$1,
    forEach: each,
    forEachSeries: eachSeries$1,
    forEachLimit: eachLimit$1,
    forEachOf: eachOf$1,
    forEachOfSeries: eachOfSeries$1,
    forEachOfLimit: eachOfLimit$1,
    inject: reduce$1,
    foldl: reduce$1,
    foldr: reduceRight,
    select: filter$1,
    selectLimit: filterLimit$1,
    selectSeries: filterSeries$1,
    wrapSync: asyncify,
    during: whilst$1,
    doDuring: doWhilst$1
};




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**************************!*\
  !*** ./assets/js/app.js ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery-trend */ "./node_modules/jquery-trend/jquery.trend.js");
/* harmony import */ var jquery_trend__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery_trend__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery_revealer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-revealer */ "./node_modules/jquery-revealer/jquery.revealer.js");
/* harmony import */ var jquery_revealer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_revealer__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var validetta__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! validetta */ "./node_modules/validetta/dist/validetta.js");
/* harmony import */ var validetta__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(validetta__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _bigcommerce_stencil_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @bigcommerce/stencil-utils */ "./node_modules/@bigcommerce/stencil-utils/src/main.js");
/* harmony import */ var async__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! async */ "./node_modules/async/dist/async.mjs");
/* harmony import */ var _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./theme/core/Account */ "./assets/js/theme/core/Account.js");
/* harmony import */ var _theme_Auth__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./theme/Auth */ "./assets/js/theme/Auth.js");
/* harmony import */ var _theme_Blog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./theme/Blog */ "./assets/js/theme/Blog.js");
/* harmony import */ var _theme_Brand__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./theme/Brand */ "./assets/js/theme/Brand.js");
/* harmony import */ var _theme_Brands__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./theme/Brands */ "./assets/js/theme/Brands.js");
/* harmony import */ var _theme_Cart__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./theme/Cart */ "./assets/js/theme/Cart.js");
/* harmony import */ var _theme_Category__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./theme/Category */ "./assets/js/theme/Category.js");
/* harmony import */ var _theme_Compare__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./theme/Compare */ "./assets/js/theme/Compare.js");
/* harmony import */ var _theme_ContactUs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./theme/ContactUs */ "./assets/js/theme/ContactUs.js");
/* harmony import */ var _theme_Errors__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./theme/Errors */ "./assets/js/theme/Errors.js");
/* harmony import */ var _theme_404_error__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./theme/404-error */ "./assets/js/theme/404-error.js");
/* harmony import */ var _theme_core_GiftCertificate__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./theme/core/GiftCertificate */ "./assets/js/theme/core/GiftCertificate.js");
/* harmony import */ var _theme_Global__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./theme/Global */ "./assets/js/theme/Global.js");
/* harmony import */ var _theme_Home__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./theme/Home */ "./assets/js/theme/Home.js");
/* harmony import */ var _theme_OrderComplete__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./theme/OrderComplete */ "./assets/js/theme/OrderComplete.js");
/* harmony import */ var _theme_Page__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./theme/Page */ "./assets/js/theme/Page.js");
/* harmony import */ var _theme_Product__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./theme/Product */ "./assets/js/theme/Product.js");
/* harmony import */ var _theme_AmpProduct__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./theme/AmpProduct */ "./assets/js/theme/AmpProduct.js");
/* harmony import */ var _theme_Search__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./theme/Search */ "./assets/js/theme/Search.js");
/* harmony import */ var _theme_Sitemap__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./theme/Sitemap */ "./assets/js/theme/Sitemap.js");
/* harmony import */ var _theme_Subscribe__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./theme/Subscribe */ "./assets/js/theme/Subscribe.js");
/* harmony import */ var _theme_Wishlist__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./theme/Wishlist */ "./assets/js/theme/Wishlist.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.min.js");
// Load plugins



























var PageClasses = {
  mapping: {
    'pages/account/orders/all': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/orders/details': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/addresses': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/add-address': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/add-return': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/add-wishlist': _theme_Wishlist__WEBPACK_IMPORTED_MODULE_26__["default"],
    'pages/account/download-item': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/edit': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/inbox': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/add-payment-method': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/edit-payment-method': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/payment-methods': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/recent-items': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/return-saved': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/account/returns': _theme_core_Account__WEBPACK_IMPORTED_MODULE_5__["default"],
    'pages/auth/login': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/auth/account-created': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/auth/create-account': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/auth/new-password': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/auth/forgot-password': _theme_Auth__WEBPACK_IMPORTED_MODULE_6__["default"],
    'pages/blog': _theme_Blog__WEBPACK_IMPORTED_MODULE_7__["default"],
    'pages/blog-post': _theme_Blog__WEBPACK_IMPORTED_MODULE_7__["default"],
    'pages/brand': _theme_Brand__WEBPACK_IMPORTED_MODULE_8__["default"],
    'pages/brands': _theme_Brand__WEBPACK_IMPORTED_MODULE_8__["default"],
    'pages/cart': _theme_Cart__WEBPACK_IMPORTED_MODULE_10__["default"],
    'pages/category': _theme_Category__WEBPACK_IMPORTED_MODULE_11__["default"],
    'pages/compare': _theme_Compare__WEBPACK_IMPORTED_MODULE_12__["default"],
    'pages/contact-us': _theme_ContactUs__WEBPACK_IMPORTED_MODULE_13__["default"],
    'pages/errors': _theme_Errors__WEBPACK_IMPORTED_MODULE_14__["default"],
    'pages/errors/404': _theme_404_error__WEBPACK_IMPORTED_MODULE_15__["default"],
    'pages/gift-certificate/purchase': _theme_core_GiftCertificate__WEBPACK_IMPORTED_MODULE_16__["default"],
    'pages/gift-certificate/balance': _theme_core_GiftCertificate__WEBPACK_IMPORTED_MODULE_16__["default"],
    'pages/gift-certificate/redeem': _theme_core_GiftCertificate__WEBPACK_IMPORTED_MODULE_16__["default"],
    'global': _theme_Global__WEBPACK_IMPORTED_MODULE_17__["default"],
    'pages/home': _theme_Home__WEBPACK_IMPORTED_MODULE_18__["default"],
    'pages/order-complete': _theme_OrderComplete__WEBPACK_IMPORTED_MODULE_19__["default"],
    'pages/page': _theme_Page__WEBPACK_IMPORTED_MODULE_20__["default"],
    'pages/product': _theme_Product__WEBPACK_IMPORTED_MODULE_21__["default"],
    'pages/search': _theme_Search__WEBPACK_IMPORTED_MODULE_23__["default"],
    'pages/sitemap': _theme_Sitemap__WEBPACK_IMPORTED_MODULE_24__["default"],
    'pages/subscribed': _theme_Subscribe__WEBPACK_IMPORTED_MODULE_25__["default"],
    'pages/account/wishlist-details': _theme_Wishlist__WEBPACK_IMPORTED_MODULE_26__["default"],
    'pages/account/wishlists': _theme_Wishlist__WEBPACK_IMPORTED_MODULE_26__["default"],
    'pages/amp/product-options': _theme_AmpProduct__WEBPACK_IMPORTED_MODULE_22__["default"]
  },
  /**
   * Getter method to ensure a good page type is accessed.
   * @param page
   * @returns {*}
   */
  get: function get(page) {
    if (this.mapping[page]) {
      return this.mapping[page];
    }
    return false;
  }
};

/**
 *
 * @param {Object} pageObj
 */
function series(pageObj) {
  async__WEBPACK_IMPORTED_MODULE_4__["default"].series([pageObj.before.bind(pageObj),
  // Executed first after constructor()
  pageObj.loaded.bind(pageObj),
  // Main module logic
  pageObj.after.bind(pageObj) // Clean up method that can be overridden for cleanup.
  ], function (err) {
    if (err) {
      throw new Error(err);
    }
  });
}

/**
 * Loads the global module that gets executed on every page load.
 * Code that you want to run on every page goes in the global module.
 * @param {object} pages
 * @returns {*}
 */
function loadGlobal(pages) {
  var Global = pages.get('global');
  return new Global();
}

/**
 *
 * @param {function} pageFunc
 * @param {} pages
 */
function loader(pageFunc, pages) {
  if (pages.get('global')) {
    var globalPageManager = loadGlobal(pages);
    globalPageManager.context = pageFunc.context;
    series(globalPageManager);
  }
  series(pageFunc);
}

/**
 * This function gets added to the global window and then called
 * on page load with the current template loaded and JS Context passed in
 * @param templateFile String
 * @param context
 * @returns {*}
 */
window.stencilBootstrap = function stencilBootstrap(templateFile, context) {
  var pages = PageClasses;
  context = context || '{}';
  context = JSON.parse(context);
  return {
    load: function load() {
      $(function () {
        var PageTypeFn = pages.get(templateFile); // Finds the appropriate module from the pageType object and store the result as a function.

        if (PageTypeFn) {
          var pageType = new PageTypeFn();
          pageType.context = context;
          return loader(pageType, pages);
        }
        throw new Error(templateFile + ' Module not found');
      });
    }
  };
};
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELGtCQUFlOzs7Ozs7Ozs7OztBQ25QZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUM3Qjs7Ozs7Ozs7Ozs7O0FDSGE7O0FBRWIsV0FBVyxpQkFBaUI7QUFDNUI7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxLQUF5QjtBQUNoQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOzs7Ozs7Ozs7OztBQ25HRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQ0FBMEM7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6Qjs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0QkFBNEI7QUFDNUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDZDQUE2QztBQUM3QyxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7O0FBRUEsc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixNQUFNO0FBQ04saUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQkFBbUI7QUFDbkIsR0FBRzs7QUFFSCxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxtQ0FBTztBQUNYO0FBQ0EsS0FBSztBQUFBLGtHQUFDO0FBQ04sSUFBSSxLQUFLLGdCQVFOO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7O0FDNWxEWTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBELE9BQU87QUFDakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGdCQUFnQixZQUFZO0FBQzVCOztBQUVBO0FBQ0EsNERBQTREO0FBQzVELGdFQUFnRTtBQUNoRSxvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBNkI7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7O0FDL1VZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQyxxQkFBcUIsbUJBQU8sQ0FBQyxvREFBVzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNaWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsV0FBVyxrQkFBa0IsV0FBVyxzR0FBc0csa0JBQWtCLE1BQU0sT0FBTyxXQUFXLGFBQWE7O0FBRW5PO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdEhhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQSxpRkFBaUYsc0NBQXNDOztBQUV2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkZhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLHdFQUFrQjs7QUFFL0M7Ozs7Ozs7Ozs7OztBQ0phOztBQUViOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxvREFBVztBQUNoQyxpQkFBaUIsbUJBQU8sQ0FBQyx3REFBZ0I7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsMERBQWlCO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLHNEQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDREQUFrQjtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyx3REFBZ0I7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0RBQWU7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4Q0FBOEM7QUFDaEYsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixHQUFHO0FBQ0gsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyx3REFBYTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsb0RBQVc7O0FBRWxDO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELEdBQUc7QUFDSCxnREFBZ0Q7QUFDaEQsR0FBRztBQUNILHNEQUFzRDtBQUN0RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsNERBQWU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDhDQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0V2E7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsNERBQWU7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDZmE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsc0VBQW9COztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNyQmE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOzs7Ozs7Ozs7Ozs7QUNkYTs7QUFFYjtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG9EQUFTOztBQUVyQztBQUNBLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFDckMsOENBQThDO0FBQzlDLDBDQUEwQzs7QUFFMUM7QUFDQTs7Ozs7Ozs7Ozs7O0FDWmE7O0FBRWI7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRiw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEMsa0VBQWtFO0FBQ2xFLHFFQUFxRTs7QUFFckU7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx1Q0FBdUM7O0FBRXZDLDJEQUEyRDtBQUMzRCwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLDJFQUEyRTs7QUFFM0UseUdBQXlHOztBQUV6RztBQUNBLDZDQUE2Qzs7QUFFN0MsOERBQThEOztBQUU5RDtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pDYTs7QUFFYjtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLDREQUFlOztBQUVsQyxXQUFXLGFBQWE7QUFDeEI7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsaUJBQWlCO0FBQzFELDhCQUE4QixrQkFBa0I7OztBQUdoRCx5Q0FBeUMsaUJBQWlCO0FBQzFELHNDQUFzQyw2QkFBNkI7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQkFBb0Isd0RBQXdEO0FBQzVFLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPOztBQUUxQix5QkFBeUI7QUFDekIsdUVBQXVFLEVBQUU7QUFDekU7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsV0FBVyxvQ0FBYTs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUEsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7OztBQUlKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxJQUFJOztBQUVKLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLDRCQUE0Qjs7QUFFNUI7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRkFBaUYsb0JBQW9CLHlCQUF5QjtBQUM5SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLElBQUk7OztBQUdKLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7QUMzdEdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sS0FBeUI7QUFDaEM7QUFDQSxzQ0FBc0MsbUJBQU8sQ0FBQywyREFBWTtBQUMxRCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLG9DQUFvQztBQUMvQyxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7Ozs7Ozs7Ozs7O0FDOVVXOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG9EQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1BZOztBQUVaLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFZOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7O0FBR25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMsRUFBRSxNQUFNOzs7Ozs7Ozs7Ozs7QUMxSFQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsTUFBTTs7Ozs7Ozs7Ozs7QUMxSVQ7QUFDQSxlQUFlLGFBQWEsS0FBdUIsZ0ZB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDdlNhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLDBEQUFjO0FBQzNDLFlBQVksbUJBQU8sQ0FBQywrQ0FBUztBQUM3QixjQUFjLG1CQUFPLENBQUMsbURBQVc7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdFQUFnRTtBQUNyRixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5VmE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLG1EQUFXOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPLFVBQVUsYUFBYTtBQUNqRDs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4UWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsNERBQWU7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLDBFQUFzQjtBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxrRkFBMEI7QUFDdkQsV0FBVyxtQkFBTyxDQUFDLDBDQUFNOztBQUV6QixpQkFBaUIsbUJBQU8sQ0FBQyx3REFBZ0I7QUFDekM7O0FBRUEsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUMsSUFBSTtBQUNKLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pDYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyw0REFBZTtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBcUI7QUFDN0MsY0FBYyxtQkFBTyxDQUFDLDhEQUFnQjs7QUFFdEMsaUJBQWlCLG1CQUFPLENBQUMsd0RBQWdCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyx5Q0FBeUM7QUFDekMsWUFBWSxrREFBa0Q7QUFDOUQ7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBLFFBQVEsNkJBQTZCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQkFBK0I7QUFDekQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw0QkFBNEIsb0NBQW9DLE1BQU07QUFDdEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUEsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEMsWUFBWSxzQkFBc0I7QUFDbEMsWUFBWSwrQkFBK0I7O0FBRTNDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsaUNBQU8sQ0FBQyw2RUFBUSxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDbkMsTUFBTSxLQUFLLEVBSU47O0FBRUwsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1DQUFtQzs7QUFFbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakIsY0FBYzs7QUFFZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWIsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixVQUFVOztBQUVWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYixTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7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QTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVTs7QUFFVjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0MsNEJBQTRCOztBQUU5RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztB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RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYzs7QUFFZDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7O0FDbDhGRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0RBQVc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBSztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUiw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQThDO0FBQ3pFO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwyQkFBMkIsOENBQThDO0FBQ3pFLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtB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LE1BQU0sSUFBSTNqQixLQUFLLENBQUMrakIsWUFBWSxHQUFHLG1CQUFtQixDQUFDO01BQ3JELENBQUMsQ0FBQztJQUNKO0VBQ0YsQ0FBQztBQUNILENBQUMsQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvUGFnZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS80MDQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9BbXBQcm9kdWN0LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvQXV0aC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL0Jsb2cuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9CcmFuZC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL0JyYW5kcy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL0NhcnQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9DYXRlZ29yeS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL0NvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9Db250YWN0VXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9FcnJvcnMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9HbG9iYWwuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9Ib21lLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvT3JkZXJDb21wbGV0ZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL1BhZ2UuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9Qcm9kdWN0LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvU2VhcmNoLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvU2l0ZW1hcC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL1N1YnNjcmliZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL1dpc2hsaXN0LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY2FydC9DYXJ0VXRpbHMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jYXJ0L0NvdXBvbkNvZGVzLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY2FydC9FZGl0T3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NhcnQvR2lmdENlcnRpZmljYXRlcy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NhcnQvR2lmdFdyYXBwaW5nLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY2FydC9TaGlwcGluZ0NhbGN1bGF0b3IuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jYXJ0L3JlZnJlc2hDb250ZW50LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29tcG9uZW50cy9BbGVydC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NvbXBvbmVudHMvUXVhbnRpdHlXaWRnZXQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb21wb25lbnRzL1NlbGVjdFdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb3JlL0FjY291bnQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb3JlL0F1dGguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb3JlL0dpZnRDZXJ0aWZpY2F0ZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NvcmUvYWNjb3VudC9wYXltZW50TWV0aG9kLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29yZS9hbGVydERpc21pc3NhYmxlLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29yZS9hbXAvQW1wQWxlcnQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb3JlL2FtcC9BbXBQcm9kdWN0VXRpbHMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9jb3JlL2FtcC9BbXBRdWFudGl0eVdpZGdldC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NvcmUvZG93bmxvYWRHYWxsZXJ5LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29yZS9mb3JtU2VsZWN0ZWRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2NvcmUvc2VsZWN0T3B0aW9uLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvY29yZS91cGRhdGVTdGF0ZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC9Ecm9wZG93bi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC9GYWNldGVkU2VhcmNoLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvZ2xvYmFsL0hlYWRlci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC9NZWdhTmF2LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvZ2xvYmFsL01pbmlDYXJ0LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvZ2xvYmFsL01vYmlsZU5hdi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC9maWxsRmFjZXRSYXRpbmdTdGFycy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC9pbml0Q29tcGFyZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC9xdWljay1zZWFyY2guanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9nbG9iYWwvc3ZnSWNvbi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL2dsb2JhbC90b2dnbGVGYWNldC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3Byb2R1Y3QvQXR0cmlidXRlc0hlbHBlci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3Byb2R1Y3QvQ29sb3JTd2F0Y2guanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9wcm9kdWN0L0ltYWdlWm9vbS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3Byb2R1Y3QvUHJvZHVjdEltYWdlcy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3Byb2R1Y3QvUHJvZHVjdFJldmlld3MuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL2Fzc2V0cy9qcy90aGVtZS9wcm9kdWN0L1Byb2R1Y3RVdGlscy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3Byb2R1Y3QvUXVpY2tTaG9wLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvcHJvZHVjdC9wcm9kdWN0Vmlld1RlbXBsYXRlcy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3Byb2R1Y3QvcmVzZXRQcm9kdWN0SW1hZ2VzLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvcHJvZHVjdC92YXJpYXRpb25JbWdQcmV2aWV3LmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvcHJvZHVjdC93aXNobGlzdERyb3Bkb3duLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvdXRpbHMvRm9ybVZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3V0aWxzL1Byb2dyZXNzQnV0dG9uLmpzIiwid2VicGFjazovL3BlYWsvLi9hc3NldHMvanMvdGhlbWUvdXRpbHMvcGFnaW5hdGlvbi11dGlscy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL3RoZW1lL3V0aWxzL3Njcm9sbFRvVG9wLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2FwaS9iYXNlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2FwaS9jYXJ0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2FwaS9jb3VudHJpZXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvYXBpL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2FwaS9wcm9kdWN0LWF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvYXBpL3Byb2R1Y3QuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvYXBpL3NlYXJjaC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9hcGkvd2lzaGxpc3QuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvYm9kbC9lbWl0dGVycy9iYXNlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2JvZGwvZW1pdHRlcnMvY2FydC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ib2RsL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvaG9va3MvYmFzZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ob29rcy9jYXJ0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2hvb2tzL2Nvb2tpZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ob29rcy9jdXJyZW5jeS1zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ob29rcy9mYWNldGVkLXNlYXJjaC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ob29rcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ob29rcy9wcm9kdWN0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2hvb2tzL3NlYXJjaC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy9ob29rcy9zb3J0LWJ5LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2xpYi9jbG9zZXN0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMvc3JjL2xpYi9xdWVyeS1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvbGliL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9AYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscy9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy90b29scy9pbWFnZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy90b29scy9pbWFnZVNyY3NldC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy90b29scy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzL3NyYy90b29scy9zdG9yYWdlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvYmFndWV0dGVib3guanMvZGlzdC9iYWd1ZXR0ZUJveC5taW4uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9iYy1jb21wYXJlL2Rpc3QvanMvUHJvZHVjdENvbXBhcmUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9iYy1jb21wYXJlL25vZGVfbW9kdWxlcy9qcXVlcnktcmV2ZWFsZXIvanF1ZXJ5LnJldmVhbGVyLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvYmMtY29tcGFyZS9ub2RlX21vZHVsZXMvanF1ZXJ5LXRyZW5kL2pxdWVyeS50cmVuZC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2JjLWxvYWRpbmcvZGlzdC9sb2FkaW5nLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvYmMtbG9hZGluZy9ub2RlX21vZHVsZXMvanF1ZXJ5LXRyZW5kL2pxdWVyeS50cmVuZC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2JjLW1vZGFsL2Rpc3QvanMvbW9kYWwuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9iYy1tb2RhbC9ub2RlX21vZHVsZXMvanF1ZXJ5LXJldmVhbGVyL2pxdWVyeS5yZXZlYWxlci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2JjLW1vZGFsL25vZGVfbW9kdWxlcy9qcXVlcnktdHJlbmQvanF1ZXJ5LnRyZW5kLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvYmMtc2Nyb2xsLWxpbmsvZGlzdC9zY3JvbGwtbGluay5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2JjLXRhYnMvZGlzdC90YWJzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMtdHlwZXMvdHlwZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL2FtZXJpY2FuLWV4cHJlc3MuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy90eXBlcy9kYW5rb3J0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMtdHlwZXMvdHlwZXMvZGluZXJzLWNsdWIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy90eXBlcy9kaXNjb3Zlci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL2Vsby5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL2ZvcmJydWdzZm9yZW5pbmdlbi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMtdHlwZXMvdHlwZXMvamNiLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMtdHlwZXMvdHlwZXMvbWFlc3Ryby5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL21hc3RlcmNhcmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy10eXBlcy90eXBlcy90cm95LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMtdHlwZXMvdHlwZXMvdWF0cC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzLXR5cGVzL3R5cGVzL3VuaW9ucGF5LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMtdHlwZXMvdHlwZXMvdmlzYS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2NyZWRpdGNhcmRzL2NhcmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy9jdmMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy9leHBpcmF0aW9uLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvY3JlZGl0Y2FyZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9jcmVkaXRjYXJkcy90eXBlcy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2RlZmluZS1kYXRhLXByb3BlcnR5L2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZXMtZGVmaW5lLXByb3BlcnR5L2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL2V2YWwuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvcmVmLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3N5bnRheC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy90eXBlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3VyaS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2V2LWVtaXR0ZXIvZXYtZW1pdHRlci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjIvbGliL2V2ZW50ZW1pdHRlcjIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZXhwYW5kLXllYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9mYXN0LWx1aG4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9maXR2aWRzL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvZ29wZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2hhcy1wcm90by9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9oYXNvd24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9oaXN0b3J5LmpzL3NjcmlwdHMvYnVuZGxlZC11bmNvbXByZXNzZWQvaHRtbDQraHRtbDUvanF1ZXJ5Lmhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9pbWFnZXNsb2FkZWQvaW1hZ2VzbG9hZGVkLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvaXMtZmluaXRlL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvaXMtaW50ZWdlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2lzLXZhbGlkLW1vbnRoL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXJldmVhbGVyL2pxdWVyeS5yZXZlYWxlci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS10cmVuZC9qcXVlcnkudHJlbmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvanVzdC1kZWJvdW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5fcmVpbnRlcnBvbGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC50ZW1wbGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC50ZW1wbGF0ZXNldHRpbmdzL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eU9mLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUN0b3IuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUZpbmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVdyYXAuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2N1c3RvbURlZmF1bHRzQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lc2NhcGVIdG1sQ2hhci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0SG9sZGVyLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yZUVzY2FwZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcmVFdmFsdWF0ZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcmVJbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcmVwbGFjZUhvbGRlcnMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Fzc2lnbkluV2l0aC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9hdHRlbXB0LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2JpbmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXNjYXBlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZEluZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Vycm9yLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdGVtcGxhdGVTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWludC9pbmRleC5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3BhcnNlLXllYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9mb3JtYXRzLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvcXMvbGliL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3NldC1mdW5jdGlvbi1sZW5ndGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9zaWRlLWNoYW5uZWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzIiwid2VicGFjazovL3BlYWsvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcyIsIndlYnBhY2s6Ly9wZWFrLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy92YWxpZGV0dGEvZGlzdC92YWxpZGV0dGEuanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy96ZXJvLWZpbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGVhay9pZ25vcmVkfEM6XFxVc2Vyc1xcTXkgUENcXERvd25sb2Fkc1xcdW5pY2F0ZXJcXG5vZGVfbW9kdWxlc1xcb2JqZWN0LWluc3BlY3R8Li91dGlsLmluc3BlY3QiLCJ3ZWJwYWNrOi8vcGVhay8uL25vZGVfbW9kdWxlcy9hc3luYy9kaXN0L2FzeW5jLm1qcyIsIndlYnBhY2s6Ly9wZWFrL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3BlYWsvd2VicGFjay9ydW50aW1lL2FtZCBvcHRpb25zIiwid2VicGFjazovL3BlYWsvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vcGVhay93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcGVhay93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3BlYWsvd2VicGFjay9ydW50aW1lL2hhcm1vbnkgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly9wZWFrL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcGVhay93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3BlYWsvd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly9wZWFrLy4vYXNzZXRzL2pzL2FwcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgYmVmb3JlKG5leHQpIHtcbiAgICBuZXh0KCk7XG4gIH1cblxuICBsb2FkZWQobmV4dCkge1xuICAgIG5leHQoKTtcbiAgfVxuXG4gIGFmdGVyKG5leHQpIHtcbiAgICBuZXh0KCk7XG4gIH1cblxuICB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVycm9yczQwNCBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuXG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xyXG5pbXBvcnQgQW1wUHJvZHVjdFV0aWxzIGZyb20gJy4vY29yZS9hbXAvQW1wUHJvZHVjdFV0aWxzJztcclxuaW1wb3J0IEFtcFF1YW50aXR5V2lkZ2V0IGZyb20gJy4vY29yZS9hbXAvQW1wUXVhbnRpdHlXaWRnZXQnO1xyXG5pbXBvcnQgaW5pdEZvcm1Td2F0Y2hGaWVsZHMgZnJvbSAnLi9jb3JlL2Zvcm1TZWxlY3RlZFZhbHVlJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFtcFByb2R1Y3QgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XHJcbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuZWwgPSAnW2RhdGEtcHJvZHVjdC1jb250YWluZXJdJztcclxuICB9XHJcblxyXG4gIGxvYWRlZCgpIHtcclxuICAgIGluaXRGb3JtU3dhdGNoRmllbGRzKCk7XHJcblxyXG4gICAgLy8gUXR5IENvbnRyb2xcclxuICAgIG5ldyBBbXBRdWFudGl0eVdpZGdldCh7c2NvcGU6ICdbZGF0YS1jYXJ0LWl0ZW0tYWRkXSd9KTtcclxuXHJcbiAgICB0aGlzLlByb2R1Y3RVdGlscyA9IG5ldyBBbXBQcm9kdWN0VXRpbHModGhpcy5lbCwge1xyXG4gICAgICBjYWxsYmFja3M6IHt9LFxyXG4gICAgICB0ZW1wbGF0ZTogJ3Byb2R1Y3RzL2FkZC10by1jYXJ0LWZvcm0nLFxyXG4gICAgfSkuaW5pdCh0aGlzLmNvbnRleHQpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQ29yZUF1dGggZnJvbSAnLi9jb3JlL0F1dGgnO1xuaW1wb3J0IFNlbGVjdFdyYXBwZXIgZnJvbSAnLi9jb21wb25lbnRzL1NlbGVjdFdyYXBwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRoIGV4dGVuZHMgQ29yZUF1dGgge1xuICBzZWxlY3RXcmFwQ2FsbGJhY2soJHNlbGVjdEVsKSB7XG4gICAgbmV3IFNlbGVjdFdyYXBwZXIoJHNlbGVjdEVsKTtcbiAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmxvZyBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG59XG5cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5pbXBvcnQgRmFjZXRlZFNlYXJjaCBmcm9tICcuL2dsb2JhbC9GYWNldGVkU2VhcmNoJztcbmltcG9ydCB7aW5pdENvbXBhcmUsIHVwZGF0ZUNvbXBhcmV9IGZyb20gJy4vZ2xvYmFsL2luaXRDb21wYXJlJztcbmltcG9ydCBMb2FkaW5nIGZyb20gJ2JjLWxvYWRpbmcnO1xuaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi9nbG9iYWwvc3ZnSWNvbic7XG5pbXBvcnQgZmlsbEZhY2V0UmF0aW5nU3RhcnMgZnJvbSAnLi9nbG9iYWwvZmlsbEZhY2V0UmF0aW5nU3RhcnMnO1xuaW1wb3J0IHRvZ2dsZUZhY2V0IGZyb20gJy4vZ2xvYmFsL3RvZ2dsZUZhY2V0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJhbmQgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLiRib2R5ID0gJChkb2N1bWVudC5ib2R5KTtcblxuICAgIGlmICgkKCdbZGF0YS1wcm9kdWN0LWNvbXBhcmVdJykubGVuZ3RoKSB7XG4gICAgICBpbml0Q29tcGFyZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgIGZpbGxGYWNldFJhdGluZ1N0YXJzKCk7XG4gIH1cblxuICBsb2FkZWQobmV4dCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVGYWNldGVkU2VhcmNoKHRoaXMuY29udGV4dC5saXN0aW5nUHJvZHVjdENvdW50KTtcblxuICAgIG5leHQoKTtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJ1tkYXRhLWxpc3Rpbmctdmlld10nLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZVZpZXcoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnW2RhdGEtZmFjZXRlZC1zZWFyY2gtdG9nZ2xlXScsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkudG9nZ2xlQ2xhc3MoJ2lzLW9wZW4nKS5uZXh0KCkudG9nZ2xlQ2xhc3MoJ3Zpc2libGUnKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9pbml0aWFsaXplRmFjZXRlZFNlYXJjaChwcm9kdWN0Q291bnQpIHtcbiAgICBjb25zdCBsb2FkaW5nT3B0aW9ucyA9IHtcbiAgICAgIGxvYWRpbmdNYXJrdXA6IGA8ZGl2IGNsYXNzPVwibG9hZGluZy1vdmVybGF5XCI+JHtzdmdJY29uKCdzcGlubmVyJyl9PC9kaXY+YCxcbiAgICB9O1xuXG4gICAgY29uc3QgZmFjZXRlZFNlYXJjaE92ZXJsYXkgPSBuZXcgTG9hZGluZyhsb2FkaW5nT3B0aW9ucywgZmFsc2UsICcucHJvZHVjdC1saXN0aW5nJyk7XG5cbiAgICBjb25zdCBmYWNldGVkU2VhcmNoT3B0aW9ucyA9IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBicmFuZDoge1xuICAgICAgICAgIHNob3BfYnlfcHJpY2U6IHRydWUsXG4gICAgICAgICAgcHJvZHVjdHM6IHtcbiAgICAgICAgICAgIGxpbWl0OiBwcm9kdWN0Q291bnQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZToge1xuICAgICAgICBwcm9kdWN0TGlzdGluZzogJ2JyYW5kL3Byb2R1Y3QtbGlzdGluZycsXG4gICAgICAgIHNpZGViYXI6ICdicmFuZC9zaWRlYmFyJ1xuICAgICAgfSxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIHByb2R1Y3RMaXN0aW5nOiAnW2RhdGEtYnJhbmRdJyxcbiAgICAgICAgc2lkZWJhcjogJ1tkYXRhLWJyYW5kLXNpZGViYXJdJyxcbiAgICAgIH0sXG4gICAgICBzaG93TW9yZTogJ2JyYW5kL3Nob3ctbW9yZScsXG4gICAgICB0b2dnbGVGYWNldDogKGV2ZW50KSA9PiB0b2dnbGVGYWNldChldmVudCksXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgd2lsbFVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGZhY2V0ZWRTZWFyY2hPdmVybGF5LnNob3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlkVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgZmFjZXRlZFNlYXJjaE92ZXJsYXkuaGlkZSgpO1xuXG4gICAgICAgICAgaWYgKCQoJ1tkYXRhLXByb2R1Y3QtY29tcGFyZV0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNvbXBhcmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWxsRmFjZXRSYXRpbmdTdGFycygpO1xuICAgICAgICB9LFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDaGFuZ2UgdGVwbGF0ZSBvcHRpb24gaWYgdmlldyBtb2RlIHRoZW1lIHNldHRpbmcgaXMgXCJsaXN0XCJcbiAgICBpZiAodGhpcy5jb250ZXh0Lmxpc3RpbmdWaWV3TW9kZSA9PT0gJ2xpc3QnKSB7XG4gICAgICBmYWNldGVkU2VhcmNoT3B0aW9ucy50ZW1wbGF0ZSA9IHtcbiAgICAgICAgcHJvZHVjdExpc3Rpbmc6ICdicmFuZC9wcm9kdWN0LWxpc3RpbmctbGlzdCcsXG4gICAgICAgIHNpZGViYXI6ICdicmFuZC9zaWRlYmFyJyxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLkZhY2V0ZWRTZWFyY2ggPSBuZXcgRmFjZXRlZFNlYXJjaChmYWNldGVkU2VhcmNoT3B0aW9ucyk7XG4gIH1cblxuICBfdG9nZ2xlVmlldyhldmVudCkge1xuICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gJHRhcmdldC5kYXRhKCdsaXN0aW5nLXZpZXcnKSA9PT0gJ2dyaWQnID8gJ2JyYW5kL3Byb2R1Y3QtbGlzdGluZycgOiAnYnJhbmQvcHJvZHVjdC1saXN0aW5nLWxpc3QnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICB0ZW1wbGF0ZToge1xuICAgICAgICBwcm9kdWN0TGlzdGluZzogdGVtcGxhdGVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmUtaW5pdCBmYWNldGVkIHNlYXJjaCB3aXRoIG5ldyB0ZW1wbGF0ZSBvcHRpb25cbiAgICB0aGlzLkZhY2V0ZWRTZWFyY2guaW5pdChvcHRpb25zKTtcblxuICAgIC8vIHRvZ2dsZSBidXR0b24gY2xhc3Nlc1xuICAgICR0YXJnZXQuYWRkQ2xhc3MoJ2FjdGl2ZScpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICB9XG59XG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcmFuZHMgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcclxuaW1wb3J0IHV0aWxzIGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcclxuaW1wb3J0IENhcnRVdGlscyBmcm9tICcuL2NhcnQvQ2FydFV0aWxzJztcclxuaW1wb3J0IFNoaXBwaW5nQ2FsY3VsYXRvciBmcm9tICcuL2NhcnQvU2hpcHBpbmdDYWxjdWxhdG9yJztcclxuaW1wb3J0IENvdXBvbkNvZGVzIGZyb20gJy4vY2FydC9Db3Vwb25Db2Rlcyc7XHJcbmltcG9ydCBHaWZ0Q2VydGlmaWNhdGVzIGZyb20gJy4vY2FydC9HaWZ0Q2VydGlmaWNhdGVzJztcclxuaW1wb3J0IEdpZnRXcmFwcGluZyBmcm9tICcuL2NhcnQvR2lmdFdyYXBwaW5nJztcclxuaW1wb3J0IExvYWRpbmcgZnJvbSAnYmMtbG9hZGluZyc7XHJcbmltcG9ydCBRdWFudGl0eVdpZGdldCBmcm9tICcuL2NvbXBvbmVudHMvUXVhbnRpdHlXaWRnZXQnO1xyXG5pbXBvcnQgc3ZnSWNvbiBmcm9tICcuL2dsb2JhbC9zdmdJY29uJztcclxuaW1wb3J0IEVkaXRPcHRpb25zIGZyb20gJy4vY2FydC9FZGl0T3B0aW9ucyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJ0IGV4dGVuZHMgUGFnZU1hbmFnZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLiRjYXJ0Q29udGVudCA9ICQoJ1tkYXRhLWNhcnQtY29udGVudF0nKTtcclxuXHJcbiAgICAvLyBicnV0ZS1mb3JjZSBhcHBsZS1wYXkgYm9keWNsYXNzIGluIGxvY2FsIGVudmlyb25tZW50XHJcbiAgICBpZiAod2luZG93LkFwcGxlUGF5U2Vzc2lvbiAmJiAkKCcuZGV2LWVudmlyb25tZW50JykubGVuZ3RoKSB7XHJcbiAgICAgICQoZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3MoJ2FwcGxlLXBheS1zdXBwb3J0ZWQnKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2JpbmRFdmVudHMoKXtcclxuICAgICQoJ2JvZHknKS5vbignY2xpY2snLCAnLmFkZC10by1jYXJ0LWJ1dHRvbicsIChldmVudCkgPT4gdGhpcy5fYWRkVG9DYXJ0KGV2ZW50KSk7XHJcblxyXG4gIH1cclxuXHJcbiAgbG9hZGVkKG5leHQpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcblxyXG4gICAgbmV3IFF1YW50aXR5V2lkZ2V0KHtzY29wZTogJ1tkYXRhLWNhcnQtY29udGVudF0nfSk7XHJcblxyXG4gICAgY29uc3QgbG9hZGluZ09wdGlvbnMgPSB7XHJcbiAgICAgIGxvYWRpbmdNYXJrdXA6IGA8ZGl2IGNsYXNzPVwibG9hZGluZy1vdmVybGF5XCI+JHtzdmdJY29uKCdzcGlubmVyJyl9PC9kaXY+YCxcclxuICAgIH07XHJcblxyXG4gICAgbmV3IEdpZnRXcmFwcGluZyh7c2NvcGU6ICdbZGF0YS1jYXJ0LWNvbnRlbnRdJywgY29udGV4dH0pO1xyXG4gICAgY29uc3QgY2FydENvbnRlbnRPdmVybGF5ID0gbmV3IExvYWRpbmcobG9hZGluZ09wdGlvbnMsIHRydWUsICcucHJvZHVjdC1saXN0aW5nJyk7XHJcbiAgICBjb25zdCBjYXJ0VG90YWxzT3ZlcmxheSA9IG5ldyBMb2FkaW5nKGxvYWRpbmdPcHRpb25zLCB0cnVlLCAnW2RhdGEtY2FydC10b3RhbHNdJyk7XHJcblxyXG4gICAgdGhpcy5TaGlwcGluZ0NhbGN1bGF0b3IgPSBuZXcgU2hpcHBpbmdDYWxjdWxhdG9yKCdbZGF0YS1zaGlwcGluZy1jYWxjdWxhdG9yXScsIHtcclxuICAgICAgY29udGV4dCxcclxuICAgICAgdmlzaWJsZUNsYXNzOiAndmlzaWJsZScsXHJcbiAgICAgIGNhbGxiYWNrczoge1xyXG4gICAgICAgIHdpbGxVcGRhdGU6ICgpID0+IGNhcnRUb3RhbHNPdmVybGF5LnNob3coKSxcclxuICAgICAgICBkaWRVcGRhdGU6ICgpID0+IGNhcnRUb3RhbHNPdmVybGF5LmhpZGUoKSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuQ291cG9uQ29kZXMgPSBuZXcgQ291cG9uQ29kZXMoJ1tkYXRhLWNvdXBvbi1jb2Rlc10nLCB7XHJcbiAgICAgIGNvbnRleHQsXHJcbiAgICAgIHZpc2libGVDbGFzczogJ3Zpc2libGUnLFxyXG4gICAgICBjYWxsYmFja3M6IHtcclxuICAgICAgICB3aWxsVXBkYXRlOiAoKSA9PiBjYXJ0VG90YWxzT3ZlcmxheS5zaG93KCksXHJcbiAgICAgICAgZGlkVXBkYXRlOiAoKSA9PiBjYXJ0VG90YWxzT3ZlcmxheS5oaWRlKCksXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLkdpZnRDZXJ0aWZpY2F0ZXMgPSBuZXcgR2lmdENlcnRpZmljYXRlcygnW2RhdGEtZ2lmdC1jZXJ0aWZpY2F0ZXNdJywge1xyXG4gICAgICBjb250ZXh0LFxyXG4gICAgICB2aXNpYmxlQ2xhc3M6ICd2aXNpYmxlJyxcclxuICAgICAgY2FsbGJhY2tzOiB7XHJcbiAgICAgICAgd2lsbFVwZGF0ZTogKCkgPT4gY2FydFRvdGFsc092ZXJsYXkuc2hvdygpLFxyXG4gICAgICAgIGRpZFVwZGF0ZTogKCkgPT4gY2FydFRvdGFsc092ZXJsYXkuaGlkZSgpLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5DYXJ0VXRpbHMgPSBuZXcgQ2FydFV0aWxzKHtcclxuICAgICAgU2hpcHBpbmdDYWxjdWxhdG9yOiB0aGlzLlNoaXBwaW5nQ2FsY3VsYXRvcixcclxuICAgICAgQ291cG9uQ29kZXM6IHRoaXMuQ291cG9uQ29kZXMsXHJcbiAgICAgIEdpZnRDZXJ0aWZpY2F0ZXM6IHRoaXMuR2lmdENlcnRpZmljYXRlcyxcclxuICB9LCB7XHJcbiAgICAgIGNhbGxiYWNrczoge1xyXG4gICAgICAgICAgd2lsbFVwZGF0ZTogKCkgPT4gY2FydENvbnRlbnRPdmVybGF5LnNob3coKSxcclxuICAgICAgICAgIGRpZFVwZGF0ZTogKCkgPT4gY2FydENvbnRlbnRPdmVybGF5LmhpZGUoKSxcclxuICAgICAgfSxcclxuICB9KS5pbml0KCk7XHJcbiAgXHJcblxyXG4gICAgdGhpcy5jYXJ0RWRpdE9wdGlvbnMgPSBuZXcgRWRpdE9wdGlvbnModGhpcy5jb250ZXh0LCB7XHJcbiAgICAgIHdpbGxVcGRhdGU6ICgpID0+IGNhcnRDb250ZW50T3ZlcmxheS5zaG93KCksXHJcbiAgICAgIGRpZFVwZGF0ZTogKCkgPT4gY2FydENvbnRlbnRPdmVybGF5LmhpZGUoKSxcclxuICAgIH0pO1xyXG5cclxuICAgIG5leHQoKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcbmltcG9ydCBGYWNldGVkU2VhcmNoIGZyb20gJy4vZ2xvYmFsL0ZhY2V0ZWRTZWFyY2gnO1xuaW1wb3J0IHtpbml0Q29tcGFyZSwgdXBkYXRlQ29tcGFyZX0gZnJvbSAnLi9nbG9iYWwvaW5pdENvbXBhcmUnO1xuaW1wb3J0IExvYWRpbmcgZnJvbSAnYmMtbG9hZGluZyc7XG5pbXBvcnQgc3ZnSWNvbiBmcm9tICcuL2dsb2JhbC9zdmdJY29uJztcbmltcG9ydCBmaWxsRmFjZXRSYXRpbmdTdGFycyBmcm9tICcuL2dsb2JhbC9maWxsRmFjZXRSYXRpbmdTdGFycyc7XG5pbXBvcnQgdG9nZ2xlRmFjZXQgZnJvbSAnLi9nbG9iYWwvdG9nZ2xlRmFjZXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXRlZ29yeSBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuJGJvZHkgPSAkKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgaWYgKCQoJ1tkYXRhLXByb2R1Y3QtY29tcGFyZV0nKS5sZW5ndGgpIHtcbiAgICAgIGluaXRDb21wYXJlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuXG4gICAgZmlsbEZhY2V0UmF0aW5nU3RhcnMoKTtcbiAgfVxuXG4gIGxvYWRlZChuZXh0KSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZUZhY2V0ZWRTZWFyY2godGhpcy5jb250ZXh0Lmxpc3RpbmdQcm9kdWN0Q291bnQpO1xuXG4gICAgbmV4dCgpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnW2RhdGEtbGlzdGluZy12aWV3XScsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlVmlldyhldmVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsICdbZGF0YS1mYWNldGVkLXNlYXJjaC10b2dnbGVdJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS50b2dnbGVDbGFzcygnaXMtb3BlbicpLm5leHQoKS50b2dnbGVDbGFzcygndmlzaWJsZScpO1xuICAgIH0pO1xuICB9XG5cbiAgX2luaXRpYWxpemVGYWNldGVkU2VhcmNoKHByb2R1Y3RDb3VudCkge1xuICAgIGNvbnN0IGxvYWRpbmdPcHRpb25zID0ge1xuICAgICAgbG9hZGluZ01hcmt1cDogYDxkaXYgY2xhc3M9XCJsb2FkaW5nLW92ZXJsYXlcIj4ke3N2Z0ljb24oJ3NwaW5uZXInKX08L2Rpdj5gLFxuICAgIH07XG5cbiAgICBjb25zdCBmYWNldGVkU2VhcmNoT3ZlcmxheSA9IG5ldyBMb2FkaW5nKGxvYWRpbmdPcHRpb25zLCBmYWxzZSwgJy5wcm9kdWN0LWxpc3RpbmcnKTtcblxuICAgIGNvbnN0IGZhY2V0ZWRTZWFyY2hPcHRpb25zID0ge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGNhdGVnb3J5OiB7XG4gICAgICAgICAgc2hvcF9ieV9wcmljZTogdHJ1ZSxcbiAgICAgICAgICBwcm9kdWN0czoge1xuICAgICAgICAgICAgbGltaXQ6IHByb2R1Y3RDb3VudCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUZhY2V0OiAoZXZlbnQpID0+IHRvZ2dsZUZhY2V0KGV2ZW50KSxcbiAgICAgIHNob3dNb3JlOiAnY2F0ZWdvcnkvc2hvdy1tb3JlJyxcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB3aWxsVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgZmFjZXRlZFNlYXJjaE92ZXJsYXkuc2hvdygpO1xuICAgICAgICB9LFxuICAgICAgICBkaWRVcGRhdGU6ICgpID0+IHtcbiAgICAgICAgICBmYWNldGVkU2VhcmNoT3ZlcmxheS5oaWRlKCk7XG5cbiAgICAgICAgICBpZiAoJCgnW2RhdGEtcHJvZHVjdC1jb21wYXJlXScpLmxlbmd0aCkge1xuICAgICAgICAgICAgdXBkYXRlQ29tcGFyZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpbGxGYWNldFJhdGluZ1N0YXJzKCk7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFkZCB0ZXBsYXRlIG9wdGlvbiBpZiB2aWV3IG1vZGUgdGhlbWUgc2V0dGluZyBpcyBcImxpc3RcIlxuICAgIGlmICh0aGlzLmNvbnRleHQubGlzdGluZ1ZpZXdNb2RlID09PSAnbGlzdCcpIHtcbiAgICAgIGZhY2V0ZWRTZWFyY2hPcHRpb25zLnRlbXBsYXRlID0ge1xuICAgICAgICBwcm9kdWN0TGlzdGluZzogJ2NhdGVnb3J5L3Byb2R1Y3QtbGlzdGluZy1saXN0JyxcbiAgICAgICAgc2lkZWJhcjogJ2NhdGVnb3J5L3NpZGViYXInLFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuRmFjZXRlZFNlYXJjaCA9IG5ldyBGYWNldGVkU2VhcmNoKGZhY2V0ZWRTZWFyY2hPcHRpb25zKTtcbiAgfVxuXG4gIF90b2dnbGVWaWV3KGV2ZW50KSB7XG4gICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgY29uc3QgdGVtcGxhdGUgPSAkdGFyZ2V0LmRhdGEoJ2xpc3RpbmctdmlldycpID09PSAnZ3JpZCcgPyAnY2F0ZWdvcnkvcHJvZHVjdC1saXN0aW5nJyA6ICdjYXRlZ29yeS9wcm9kdWN0LWxpc3RpbmctbGlzdCc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgIHByb2R1Y3RMaXN0aW5nOiB0ZW1wbGF0ZVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByZS1pbml0IGZhY2V0ZWQgc2VhcmNoIHdpdGggbmV3IHRlbXBsYXRlIG9wdGlvblxuICAgIHRoaXMuRmFjZXRlZFNlYXJjaC5pbml0KG9wdGlvbnMpO1xuXG4gICAgLy8gdG9nZ2xlIGJ1dHRvbiBjbGFzc2VzXG4gICAgJHRhcmdldC5hZGRDbGFzcygnYWN0aXZlJykuc2libGluZ3MoKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cbiAgICAvLyBUT0RPIC0gcG9zc2libHkgYWRkIHRoaXMgYmFjayBhZnRlciB0ZXN0aW5nIGluIGxpdmUgZW52aXJvblxuICAgIC8vIGlmICh0eXBlb2YoU3RvcmFnZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbGlzdGluZ1ZpZXcnLCAkdGFyZ2V0LmRhdGEoJ2xpc3RpbmctdmlldycpKTtcbiAgICAvLyB9XG4gIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBhcmUgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGFjdFVzIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvcnMgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcbmltcG9ydCBTY3JvbGxMaW5rIGZyb20gJ2JjLXNjcm9sbC1saW5rJztcbmltcG9ydCBGb3JtVmFsaWRhdG9yIGZyb20gJy4vdXRpbHMvRm9ybVZhbGlkYXRvcic7XG5pbXBvcnQgRHJvcGRvd24gZnJvbSAnLi9nbG9iYWwvRHJvcGRvd24nO1xuaW1wb3J0IEhlYWRlciBmcm9tICcuL2dsb2JhbC9IZWFkZXInO1xuaW1wb3J0IFF1aWNrU2VhcmNoIGZyb20gJy4vZ2xvYmFsL3F1aWNrLXNlYXJjaCc7IC8vIEltcG9ydCBRdWlja1NlYXJjaFxuaW1wb3J0IE1pbmlDYXJ0IGZyb20gJy4vZ2xvYmFsL01pbmlDYXJ0JztcbmltcG9ydCBRdWlja1Nob3AgZnJvbSAnLi9wcm9kdWN0L1F1aWNrU2hvcCc7XG5pbXBvcnQgd2lzaGxpc3REcm9wZG93biBmcm9tICcuL3Byb2R1Y3Qvd2lzaGxpc3REcm9wZG93bic7XG5pbXBvcnQgTWVnYU5hdiBmcm9tICcuL2dsb2JhbC9NZWdhTmF2JztcbmltcG9ydCBNb2JpbGVOYXYgZnJvbSAnLi9nbG9iYWwvTW9iaWxlTmF2JztcbmltcG9ydCAnLi9jb3JlL3NlbGVjdE9wdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdsb2JhbCBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBuZXcgRHJvcGRvd24oJCgnLmRyb3Bkb3duJykpO1xuICAgICAgICBuZXcgSGVhZGVyKCQoJy5zaXRlLWhlYWRlcicpKTtcbiAgICAgICAgbmV3IFNjcm9sbExpbmsoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICcuYnV0dG9uLXRvcCdcbiAgICAgICAgfSk7XG4gICAgICAgIG5ldyBNZWdhTmF2KCQoJy5tZWdhLW5hdi12YXJpYW50LWNvbnRhaW5lcicpKTtcbiAgICAgICAgbmV3IE1vYmlsZU5hdigpO1xuICAgICAgICBuZXcgTWluaUNhcnQoKTtcbiAgICAgICAgbmV3IHdpc2hsaXN0RHJvcGRvd24oKTtcblxuICAgICAgICB0aGlzLl90b2dnbGVTY3JvbGxMaW5rKCk7XG4gICAgICAgIHRoaXMuX2luaXRBbmNob3JzKCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVRdWlja1NlYXJjaCgpOyAgLy8gSW5pdGlhbGl6ZSBxdWljayBzZWFyY2hcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIHdyYXAgdGhlIGV4ZWN1dGlvbiBpbiB0aGlzIG1ldGhvZCB3aXRoIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBtYXAgdXNpbmcgdGhlIGFzeW5jIGxpYnJhcnlcbiAgICAgKiBpZiB5b3VyIGdsb2JhbCBtb2R1bGVzIG5lZWQgYXN5bmMgY2FsbGJhY2sgaGFuZGxpbmcuXG4gICAgICogQHBhcmFtIG5leHRcbiAgICAgKi9cbiAgICBsb2FkZWQobmV4dCkge1xuICAgICAgICAvLyBnbG9iYWwgZm9ybSB2YWxpZGF0aW9uXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gbmV3IEZvcm1WYWxpZGF0b3IodGhpcy5jb250ZXh0KTtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IuaW5pdEdsb2JhbCgpO1xuXG4gICAgICAgIC8vIFF1aWNrU2hvcFxuICAgICAgICBpZiAoJCgnW2RhdGEtcXVpY2stc2hvcF0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5ldyBRdWlja1Nob3AodGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBfaW5pdEFuY2hvcnMoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvclNlbGVjdG9yID0gJy5jbXMtcGFnZSBbaHJlZl49XCIjXCJdJztcblxuICAgICAgICAkKGFuY2hvclNlbGVjdG9yKS5lYWNoKChpbmRleCwgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSAkKGVsZW1lbnQpLmF0dHIoJ2hyZWYnKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldElkLnN1YnN0cmluZygxKTtcblxuICAgICAgICAgICAgJChlbGVtZW50KS5hdHRyKCdkYXRhLXNjcm9sbCcsIHRhcmdldElkKTtcbiAgICAgICAgICAgICQoYFtuYW1lPScke3RhcmdldH0nXWApLmF0dHIoJ2lkJywgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNjcm9sbExpbmsoe1xuICAgICAgICAgICAgc2VsZWN0b3I6IGFuY2hvclNlbGVjdG9yLFxuICAgICAgICAgICAgb2Zmc2V0OiAtMTUwLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfdG9nZ2xlU2Nyb2xsTGluaygpIHtcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdzY3JvbGwnLCAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2luU2Nyb2xsVG9wID0gJChlLmN1cnJlbnRUYXJnZXQpLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgY29uc3Qgd2luSGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuXG4gICAgICAgICAgICBpZiAod2luU2Nyb2xsVG9wID4gd2luSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgJCgnLmJ1dHRvbi10b3AnKS5hZGRDbGFzcygnc2hvdycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKCcuYnV0dG9uLXRvcCcpLnJlbW92ZUNsYXNzKCdzaG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9pbml0aWFsaXplUXVpY2tTZWFyY2goKSB7XG4gICAgICAgIG5ldyBRdWlja1NlYXJjaCgpOyAvLyBJbml0aWFsaXplIHF1aWNrIHNlYXJjaFxuICAgIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5pbXBvcnQgUHJvZHVjdFV0aWxzIGZyb20gJy4vcHJvZHVjdC9Qcm9kdWN0VXRpbHMnO1xuaW1wb3J0IFRhYnMgZnJvbSAnYmMtdGFicyc7XG5pbXBvcnQgc2xpY2sgZnJvbSAnc2xpY2stY2Fyb3VzZWwnO1xuaW1wb3J0IGltYWdlc0xvYWRlZCBmcm9tICdpbWFnZXNsb2FkZWQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIb21lIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgbG9hZGVkKG5leHQpIHtcbiAgICB0aGlzLl9pbml0U2xpY2soKTtcblxuICAgIHRoaXMuX2luaXRUYWJzKCk7XG5cbiAgICBuZXh0KCk7XG4gIH1cblxuICBfaW5pdFRhYnMoKSB7XG4gICAgdGhpcy50YWJzID0gbmV3IFRhYnMoe1xuICAgICAgYWZ0ZXJTZXR1cDogKCkgPT4ge1xuICAgICAgICAkKCcucHJvZHVjdC1jYXJvdXNlbCcpLnNsaWNrKCdzZXRQb3NpdGlvbicpO1xuICAgICAgfSxcbiAgICAgIGFmdGVyQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgICQoJy5wcm9kdWN0LWNhcm91c2VsJykuc2xpY2soJ3NldFBvc2l0aW9uJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfaW5pdFNsaWNrKCkge1xuICAgIC8vIEhlcm8gY2Fyb3VzZWxcbiAgICBjb25zdCAkY2Fyb3VzZWwgPSAkKCcuY2Fyb3VzZWwnKTtcbiAgICBjb25zdCBpc05hdHVyYWxBc3BlY3RSYXRpbyA9ICRjYXJvdXNlbC5oYXNDbGFzcygncmF0aW8tbmF0dXJhbCcpO1xuICAgIGNvbnN0IHNwZWVkID0gJGNhcm91c2VsLmRhdGEoJ3N3YXAtZnJlcXVlbmN5Jyk7XG5cbiAgICAkY2Fyb3VzZWxcbiAgICAgIC5vbignaW5pdCcsIChldmVudCwgc2xpY2spID0+IHtcbiAgICAgICAgJCgnLnNsaWNrLWFjdGl2ZSAuY2Fyb3VzZWwtaXRlbS1pbmZvOmhhcygqKScpLmFkZENsYXNzKCdzaG93Jyk7XG4gICAgICAgIC8vIEZpeCBtaXNhbGlnbm1lbnQgYmVjYXVzZSBubyBzY3JvbGxiYXIgb24gbG9hZFxuICAgICAgICAkKHdpbmRvdykudHJpZ2dlcigncmVzaXplJyk7XG4gICAgICB9KVxuICAgICAgLnNsaWNrKHtcbiAgICAgICAgZG90czogdHJ1ZSxcbiAgICAgICAgZmFkZTogdHJ1ZSxcbiAgICAgICAgYXV0b3BsYXk6IHRydWUsXG4gICAgICAgIGF1dG9wbGF5U3BlZWQ6IHNwZWVkLFxuICAgICAgICBsYXp5TG9hZDogJ3Byb2dyZXNzaXZlJyxcbiAgICAgICAgYWRhcHRpdmVIZWlnaHQ6IHRydWUsXG4gICAgICAgIHByZXZBcnJvdzogJzxzcGFuIGNsYXNzPVwiY2Fyb3VzZWwtbmF2aWdhdGlvbi1pdGVtIHByZXZpb3VzXCI+PHN2ZyBjbGFzcz1cImljb24gaWNvbi1hcnJvdy1sZWZ0XCI+PHVzZSB4bGluazpocmVmPVwiI2ljb24tYXJyb3ctbGVmdFwiIC8+PC9zdmc+PC9zcGFuPicsXG4gICAgICAgIG5leHRBcnJvdzogJzxzcGFuIGNsYXNzPVwiY2Fyb3VzZWwtbmF2aWdhdGlvbi1pdGVtIG5leHRcIj48c3ZnIGNsYXNzPVwiaWNvbiBpY29uLWFycm93LXJpZ2h0XCI+PHVzZSB4bGluazpocmVmPVwiI2ljb24tYXJyb3ctcmlnaHRcIiAvPjwvc3ZnPjwvc3Bhbj4nXG4gICAgICB9KVxuICAgICAgLm9uKCdiZWZvcmVDaGFuZ2UnLCAoZXZlbnQsIHNsaWNrLCBjdXJyZW50U2xpZGUsIG5leHRTbGlkZSkgPT4ge1xuICAgICAgICAkKCcuc2xpY2stYWN0aXZlIC5jYXJvdXNlbC1pdGVtLWluZm86aGFzKCopJykucmVtb3ZlQ2xhc3MoJ3Nob3cnKTtcbiAgICAgIH0pLm9uKCdhZnRlckNoYW5nZScsIChldmVudCwgc2xpY2ssIGN1cnJlbnRTbGlkZSkgPT4ge1xuICAgICAgICAkKCcuc2xpY2stYWN0aXZlIC5jYXJvdXNlbC1pdGVtLWluZm86aGFzKCopJykuYWRkQ2xhc3MoJ3Nob3cnKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgICAgaW5maW5pdGU6IHRydWUsXG4gICAgICAgIHNsaWRlc1RvU2hvdzogNCxcbiAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDQsXG4gICAgICAgIGF1dG9wbGF5U3BlZWQ6IDMwMDAsIC8vIEF1dG9wbGF5IHNwZWVkIGluIG1pbGxpc2Vjb25kcyAoMyBzZWNvbmRzKVxuICAgICAgICBhdXRvcGxheTogdHJ1ZSwgLy8gRW5hYmxlIGF1dG9wbGF5XG4gICAgICAgIGxhenlMb2FkOiAncHJvZ3Jlc3NpdmUnLFxuICAgICAgICBzcGVlZDogODAwLFxuICAgICAgICBwcmV2QXJyb3c6ICc8c3BhbiBjbGFzcz1cImNhcm91c2VsLW5hdmlnYXRpb24taXRlbSBwcmV2aW91c1wiPjxzdmcgY2xhc3M9XCJpY29uIGljb24tYXJyb3ctbGVmdFwiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uLWFycm93LWxlZnRcIiAvPjwvc3ZnPjwvc3Bhbj4nLFxuICAgICAgICBuZXh0QXJyb3c6ICc8c3BhbiBjbGFzcz1cImNhcm91c2VsLW5hdmlnYXRpb24taXRlbSBuZXh0XCI+PHN2ZyBjbGFzcz1cImljb24gaWNvbi1hcnJvdy1yaWdodFwiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uLWFycm93LXJpZ2h0XCIgLz48L3N2Zz48L3NwYW4+JyxcbiAgICAgICAgcmVzcG9uc2l2ZTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQ6IDEwMjQsXG4gICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICBzbGlkZXNUb1Nob3c6IDMsXG4gICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAzLFxuICAgICAgICAgICAgICBhdXRvcGxheTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQ6IDc2OCxcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIHNsaWRlc1RvU2hvdzogMixcbiAgICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDIsXG4gICAgICAgICAgICAgIGF1dG9wbGF5OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVha3BvaW50OiA0ODAsXG4gICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICBzbGlkZXNUb1Nob3c6IDIsXG4gICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAyLFxuICAgICAgICAgICAgICBhdXRvcGxheTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfTtcblxuICAgIGNvbnN0ICRwcm9kdWN0Q2Fyb3VzZWwgPSAkKCcucHJvZHVjdC1jYXJvdXNlbCcpO1xuICAgICRwcm9kdWN0Q2Fyb3VzZWwuc2xpY2soc2V0dGluZ3MpO1xuXG4gICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLndpZHRoKCkgPiA0MjAgJiYgISRwcm9kdWN0Q2Fyb3VzZWwuaGFzQ2xhc3MoJ3NsaWNrLWluaXRpYWxpemVkJykpIHtcbiAgICAgICAgICAkcHJvZHVjdENhcm91c2VsLnNsaWNrKHNldHRpbmdzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3JkZXJDb21wbGV0ZSBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vUGFnZU1hbmFnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNyZWF0ZVdyYXBwZXJGb3JUYWJsZSgpO1xuICAgIH1cblxuICAgIGNyZWF0ZVdyYXBwZXJGb3JUYWJsZSgpIHtcbiAgICAgICAgJCgndGFibGUnLCAnLnBhZ2UtY29udGVudCcpLmVhY2goKGluZGV4LCB0YWJsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgJHBhcmVudCA9ICQodGFibGUpLnBhcmVudCgpO1xuICAgICAgICAgICAgY29uc3QgJHByZXZTaWJsaW5nID0gJCh0YWJsZSkucHJldigpO1xuXG4gICAgICAgICAgICBjb25zdCAkZGl2ID0gJCgnPGRpdi8+JylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2hvcml6b250YWwtc2Nyb2xsYmFyJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRhYmxlKTtcblxuICAgICAgICAgICAgaWYgKCRwcmV2U2libGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAkZGl2Lmluc2VydEFmdGVyKCRwcmV2U2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRwYXJlbnQucHJlcGVuZCgkZGl2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcbmltcG9ydCBBbGVydCBmcm9tICcuL2NvbXBvbmVudHMvQWxlcnQnO1xuaW1wb3J0IFByb2R1Y3RVdGlscyBmcm9tICcuL3Byb2R1Y3QvUHJvZHVjdFV0aWxzJztcbmltcG9ydCBQcm9kdWN0SW1hZ2VzIGZyb20gJy4vcHJvZHVjdC9Qcm9kdWN0SW1hZ2VzJztcbmltcG9ydCBQcm9kdWN0UmV2aWV3cyBmcm9tICcuL3Byb2R1Y3QvUHJvZHVjdFJldmlld3MnO1xuaW1wb3J0IENvbG9yU3dhdGNoIGZyb20gJy4vcHJvZHVjdC9Db2xvclN3YXRjaCc7XG5pbXBvcnQgcHJvZHVjdFZpZXdUZW1wbGF0ZXMgZnJvbSAnLi9wcm9kdWN0L3Byb2R1Y3RWaWV3VGVtcGxhdGVzJztcbmltcG9ydCB2YXJpYXRpb25JbWdQcmV2aWV3IGZyb20gJy4vcHJvZHVjdC92YXJpYXRpb25JbWdQcmV2aWV3JztcbmltcG9ydCBUYWJzIGZyb20gJ2JjLXRhYnMnO1xuaW1wb3J0IGZpdFZpZHMgZnJvbSAnZml0dmlkcyc7XG5pbXBvcnQgU2Nyb2xsTGluayBmcm9tICdiYy1zY3JvbGwtbGluayc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2R1Y3QgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmVsID0gJ1tkYXRhLXByb2R1Y3QtY29udGFpbmVyXSc7XG4gICAgdGhpcy4kZWwgPSAkKHRoaXMuZWwpO1xuICAgIHRoaXMucHJvZHVjdEltZ3MgPSAnLnByb2R1Y3Qtc2xpZGVzLXdyYXAnO1xuXG4gICAgdGhpcy5maXRWaWRzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIG5ldyBBbGVydCgkKCdbZGF0YS1hbGVydHNdJykpO1xuXG4gICAgbmV3IFNjcm9sbExpbmsoe1xuICAgICAgc2VsZWN0b3I6ICcuYWNjb3JkaW9uLXRpdGxlIGEnLFxuICAgICAgb2Zmc2V0OiAtMTE3XG4gICAgfSk7XG5cbiAgICBuZXcgU2Nyb2xsTGluayh7XG4gICAgICBzZWxlY3RvcjogJy5yZXZpZXdzLWp1bXBsaW5rJ1xuICAgIH0pO1xuICB9XG5cbiAgbG9hZGVkKG5leHQpIHtcbiAgICAvLyBQcm9kdWN0IFV0aWxzXG4gICAgdGhpcy5Qcm9kdWN0VXRpbHMgPSBuZXcgUHJvZHVjdFV0aWxzKHRoaXMuZWwsIHtcbiAgICAgIHByaWNlV2l0aG91dFRheFRlbXBsYXRlOiBwcm9kdWN0Vmlld1RlbXBsYXRlcy5wcmljZVdpdGhvdXRUYXgsXG4gICAgICBwcmljZVdpdGhUYXhUZW1wbGF0ZTogcHJvZHVjdFZpZXdUZW1wbGF0ZXMucHJpY2VXaXRoVGF4LFxuICAgICAgcHJpY2VTYXZlZFRlbXBsYXRlOiBwcm9kdWN0Vmlld1RlbXBsYXRlcy5wcmljZVNhdmVkLFxuICAgICAgdmFyaWF0aW9uUHJldmlld0ltYWdlVGVtcGxhdGU6IHByb2R1Y3RWaWV3VGVtcGxhdGVzLnZhcmlhdGlvblByZXZpZXdJbWFnZSxcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICBzd2l0Y2hJbWFnZTogdmFyaWF0aW9uSW1nUHJldmlld1xuICAgICAgfVxuICAgIH0pLmluaXQodGhpcy5jb250ZXh0KTtcblxuICAgIC8vIFByb2R1Y3QgSW1hZ2VzXG4gICAgbmV3IFByb2R1Y3RJbWFnZXModGhpcy5wcm9kdWN0SW1ncyk7XG5cbiAgICAvLyBQcm9kdWN0IFN3YXRjaGVzXG4gICAgdGhpcy5zd2F0Y2hlcyA9IG5ldyBDb2xvclN3YXRjaCgpOyAvLyBJbml0IG91ciBjb2xvciBzd2F0Y2hlc1xuXG4gICAgLy8gUmV2aWV3c1xuICAgIG5ldyBQcm9kdWN0UmV2aWV3cyh0aGlzLmNvbnRleHQpO1xuXG4gICAgLy8gUHJvZHVjdCBVSVxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICB0aGlzLl9pbml0VGFicygpO1xuICAgIHRoaXMuX2luaXRTbGljaygpO1xuXG4gICAgbmV4dCgpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgLy8gQWN0aXZhdGUgdGhlIHJldmlld3MgdGFiIHdoZW4gd2UganVtcCBkb3duIHRvIGl0XG4gICAgJCgnLnByb2R1Y3QtcmV2aWV3cy1saW5rJykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy50YWJzLmFjdGl2YXRlVGFiKCcjcHJvZHVjdC1yZXZpZXdzJyk7XG4gICAgICAkKCcuYWNjb3JkaW9uLXRpdGxlJykucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKTtcbiAgICAgICQoJ1tocmVmPVwiI3Byb2R1Y3QtcmV2aWV3c1wiXScpLnBhcmVudCgnLmFjY29yZGlvbi10aXRsZScpLmFkZENsYXNzKCdpcy1vcGVuJyk7XG4gICAgfSk7XG5cbiAgICAvLyBTaG93IGFsbCB0aGUgcmV2aWV3c1xuICAgICQoJy5yZXZpZXdzLXNob3ctbW9yZS1saW5rJykub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAkKCcucmV2aWV3LWl0ZW0uaGlkZGVuJykuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICQoZWwpLnJldmVhbGVyKCdzaG93Jyk7XG4gICAgICAgIH0sIGluZGV4ICogMjUwKTtcbiAgICAgIH0pO1xuXG4gICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmhpZGUoKTtcbiAgICB9KTtcblxuICAgICQoJy5hY2NvcmRpb24tdGl0bGUnKS5vbignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9hY2NvcmRpb25UYWJUb2dnbGUoZXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgX2luaXRUYWJzKCkge1xuICAgIGlmICgkKCdbZGF0YS10YWItbGlua10nKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMudGFicyA9IG5ldyBUYWJzKFxuICAgICAgICB7XG4gICAgICAgICAgYWZ0ZXJTZXR1cDogKHRhYklkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9pbml0Vmlkcyh0YWJJZCk7XG4gICAgICAgICAgICAkKCcudGFiLWNvbnRlbnQtcGFuZWwuYWN0aXZlJykucHJldignLmFjY29yZGlvbi10aXRsZScpLmFkZENsYXNzKCdpcy1vcGVuJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZnRlckNoYW5nZTogKHRhYklkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9pbml0Vmlkcyh0YWJJZCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZWVwVGFic09wZW46ICgpID0+IGZhbHNlLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKCcucHJvZHVjdC10YWJzJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYWNjb3JkaW9uIHN0eWxlIGJ1dHRvbnMgdG8gdG9nZ2xlIHRhYiBwYW5lbHNcbiAgX2FjY29yZGlvblRhYlRvZ2dsZShldmVudCkge1xuICAgIGNvbnN0IHRhYiA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZmluZCgnYScpLmF0dHIoJ2hyZWYnKTtcbiAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmFkZENsYXNzKCdpcy1vcGVuJykuc2libGluZ3MoJy5hY2NvcmRpb24tdGl0bGUnKS5yZW1vdmVDbGFzcygnaXMtb3BlbicpO1xuICAgIHRoaXMudGFicy5kaXNwbGF5VGFiQ29udGVudCh0YWIpO1xuICB9XG5cbiAgLy8gaWYgcGFnZSBsb2FkcyB3aXRoIHRhYnMgaGlkZGVuLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgdGhlIHByb3BlciB0YWIgaXMgY2xpY2tlZCBiZWZvcmUgcnVubmluZyBmaXRWaWRzLlxuICBfaW5pdFZpZHModGFiSWQpIHtcbiAgICBpZiAodGFiSWQgPT0gJyNwcm9kdWN0LXZpZGVvcycgJiYgIXRoaXMuZml0Vmlkc0luaXRpYWxpemVkKSB7XG4gICAgICBmaXRWaWRzKCcucHJvZHVjdC12aWRlb3MtbGlzdCcpO1xuICAgICAgdGhpcy5maXRWaWRzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIF9pbml0U2xpY2soKSB7XG4gICAgLy8gUmVsYXRlZCBQcm9kdWN0IGNhcm91c2Vsc1xuICAgICQoJy5wcm9kdWN0LWNhcm91c2VsJykuc2xpY2soe1xuICAgICAgICBpbmZpbml0ZTogdHJ1ZSxcbiAgICAgICAgc2xpZGVzVG9TaG93OiA0LFxuICAgICAgICBzbGlkZXNUb1Njcm9sbDogNCxcbiAgICAgICAgYXV0b3BsYXlTcGVlZDogNDAwMCxcbiAgICAgICAgc3BlZWQ6IDgwMCxcbiAgICAgICAgcHJldkFycm93OiAnPHNwYW4gY2xhc3M9XCJjYXJvdXNlbC1uYXZpZ2F0aW9uLWl0ZW0gcHJldmlvdXNcIj48c3ZnIGNsYXNzPVwiaWNvbiBpY29uLWFycm93LWxlZnRcIj48dXNlIHhsaW5rOmhyZWY9XCIjaWNvbi1hcnJvdy1sZWZ0XCIgLz48L3N2Zz48L3NwYW4+JyxcbiAgICAgICAgbmV4dEFycm93OiAnPHNwYW4gY2xhc3M9XCJjYXJvdXNlbC1uYXZpZ2F0aW9uLWl0ZW0gbmV4dFwiPjxzdmcgY2xhc3M9XCJpY29uIGljb24tYXJyb3ctcmlnaHRcIj48dXNlIHhsaW5rOmhyZWY9XCIjaWNvbi1hcnJvdy1yaWdodFwiIC8+PC9zdmc+PC9zcGFuPicsXG4gICAgICAgIHJlc3BvbnNpdmU6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVha3BvaW50OiAxMDI0LFxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgc2xpZGVzVG9TaG93OiAzLFxuICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbDogMyxcbiAgICAgICAgICAgICAgYXV0b3BsYXk6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVha3BvaW50OiA3NjgsXG4gICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICBzbGlkZXNUb1Nob3c6IDIsXG4gICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAyLFxuICAgICAgICAgICAgICBhdXRvcGxheTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgYnJlYWtwb2ludDogNDgwLFxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgc2xpZGVzVG9TaG93OiAxLFxuICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbDogMSxcbiAgICAgICAgICAgICAgYXV0b3BsYXk6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcbmltcG9ydCBGYWNldGVkU2VhcmNoIGZyb20gJy4vZ2xvYmFsL0ZhY2V0ZWRTZWFyY2gnO1xuaW1wb3J0IHsgaW5pdENvbXBhcmUsIHVwZGF0ZUNvbXBhcmUgfSBmcm9tICcuL2dsb2JhbC9pbml0Q29tcGFyZSc7XG5pbXBvcnQgTG9hZGluZyBmcm9tICdiYy1sb2FkaW5nJztcbmltcG9ydCBUYWJzIGZyb20gJ2JjLXRhYnMnO1xuaW1wb3J0IE1pbmlDYXJ0IGZyb20gJy4vZ2xvYmFsL01pbmlDYXJ0JztcbmltcG9ydCBRdWlja1NlYXJjaCBmcm9tICcuL2dsb2JhbC9xdWljay1zZWFyY2gnOyAvLyBJbXBvcnQgUXVpY2tTZWFyY2hcbmltcG9ydCBEcm9wZG93biBmcm9tICcuL2dsb2JhbC9Ecm9wZG93bic7XG5pbXBvcnQgc3ZnSWNvbiBmcm9tICcuL2dsb2JhbC9zdmdJY29uJztcbmltcG9ydCBmaWxsRmFjZXRSYXRpbmdTdGFycyBmcm9tICcuL2dsb2JhbC9maWxsRmFjZXRSYXRpbmdTdGFycyc7XG5pbXBvcnQgdG9nZ2xlRmFjZXQgZnJvbSAnLi9nbG9iYWwvdG9nZ2xlRmFjZXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgbmV3IERyb3Bkb3duKCQoJy5kcm9wZG93bicpKTtcbiAgICBuZXcgTWluaUNhcnQoKTtcbiAgICB0aGlzLiRib2R5ID0gJChkb2N1bWVudC5ib2R5KTtcblxuICAgIGlmICgkKCdbZGF0YS1wcm9kdWN0LWNvbXBhcmVdJykubGVuZ3RoKSB7XG4gICAgICBpbml0Q29tcGFyZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICB0aGlzLl9pbml0VGFicygpO1xuICAgIHRoaXMuX2luaXRpYWxpemVRdWlja1NlYXJjaCgpO1xuICAgIFxuICAgIGZpbGxGYWNldFJhdGluZ1N0YXJzKCk7XG4gIH1cblxuICBsb2FkZWQobmV4dCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVGYWNldGVkU2VhcmNoKHRoaXMuY29udGV4dC5saXN0aW5nUHJvZHVjdENvdW50KTtcblxuICAgIG5leHQoKTtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJ1tkYXRhLWxpc3Rpbmctdmlld10nLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZVZpZXcoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnW2RhdGEtZmFjZXRlZC1zZWFyY2gtdG9nZ2xlXScsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkudG9nZ2xlQ2xhc3MoJ2lzLW9wZW4nKS5uZXh0KCkudG9nZ2xlQ2xhc3MoJ3Zpc2libGUnKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9pbml0VGFicygpIHtcbiAgICB0aGlzLnRhYnMgPSBuZXcgVGFicyh7XG4gICAgICBhZnRlckNoYW5nZTogKCkgPT4ge30sXG4gICAgICBrZWVwVGFic09wZW46ICgpID0+IHt9LFxuICAgIH0pO1xuXG4gICAgaWYgKCEkKCcjcHJvZHVjdC1yZXN1bHRzIC5wcm9kdWN0LWJsb2NrJykubGVuZ3RoIHx8ICh3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluZGV4T2YoJ3NlY3Rpb249Y29udGVudCcpID4gLTEpKSB7XG4gICAgICB0aGlzLnRhYnMuZGlzcGxheVRhYkNvbnRlbnQoJyNjb250ZW50LXJlc3VsdHMnKTtcbiAgICB9XG4gIH1cbiAgX2luaXRpYWxpemVRdWlja1NlYXJjaCgpIHtcbiAgICBuZXcgUXVpY2tTZWFyY2goKTsgLy8gSW5pdGlhbGl6ZSBxdWljayBzZWFyY2hcbn1cbiAgX2luaXRpYWxpemVGYWNldGVkU2VhcmNoKHByb2R1Y3RDb3VudCkge1xuICAgIGNvbnN0IGxvYWRpbmdPcHRpb25zID0ge1xuICAgICAgbG9hZGluZ01hcmt1cDogYDxkaXYgY2xhc3M9XCJsb2FkaW5nLW92ZXJsYXlcIj4ke3N2Z0ljb24oJ3NwaW5uZXInKX08L2Rpdj5gLFxuICAgIH07XG5cbiAgICBjb25zdCBmYWNldGVkU2VhcmNoT3ZlcmxheSA9IG5ldyBMb2FkaW5nKGxvYWRpbmdPcHRpb25zLCBmYWxzZSwgJy5wcm9kdWN0LWxpc3RpbmcnKTtcblxuICAgIGNvbnN0IGZhY2V0ZWRTZWFyY2hPcHRpb25zID0ge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIHByb2R1Y3RfcmVzdWx0czoge1xuICAgICAgICAgIGxpbWl0OiBwcm9kdWN0Q291bnQsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdGVtcGxhdGU6IHtcbiAgICAgICAgcHJvZHVjdExpc3Rpbmc6ICdzZWFyY2gvcHJvZHVjdC1saXN0aW5nJyxcbiAgICAgICAgc2lkZWJhcjogJ3NlYXJjaC9zaWRlYmFyJ1xuICAgICAgfSxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIHByb2R1Y3RMaXN0aW5nOiAnW2RhdGEtc2VhcmNoXScsXG4gICAgICAgIHNpZGViYXI6ICdbZGF0YS1zZWFyY2gtc2lkZWJhcl0nLFxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUZhY2V0OiAoZXZlbnQpID0+IHRvZ2dsZUZhY2V0KGV2ZW50KSxcbiAgICAgIHNob3dNb3JlOiAnc2VhcmNoL3Nob3ctbW9yZScsXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgd2lsbFVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGZhY2V0ZWRTZWFyY2hPdmVybGF5LnNob3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlkVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgZmFjZXRlZFNlYXJjaE92ZXJsYXkuaGlkZSgpO1xuXG4gICAgICAgICAgaWYgKCQoJ1tkYXRhLXByb2R1Y3QtY29tcGFyZV0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNvbXBhcmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWxsRmFjZXRSYXRpbmdTdGFycygpO1xuICAgICAgICB9LFxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb250ZXh0Lmxpc3RpbmdWaWV3TW9kZSA9PT0gJ2xpc3QnKSB7XG4gICAgICBmYWNldGVkU2VhcmNoT3B0aW9ucy50ZW1wbGF0ZSA9IHtcbiAgICAgICAgcHJvZHVjdExpc3Rpbmc6ICdzZWFyY2gvcHJvZHVjdC1saXN0aW5nLWxpc3QnLFxuICAgICAgICBzaWRlYmFyOiAnc2VhcmNoL3NpZGViYXInLFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuRmFjZXRlZFNlYXJjaCA9IG5ldyBGYWNldGVkU2VhcmNoKGZhY2V0ZWRTZWFyY2hPcHRpb25zKTtcbiAgfVxuXG4gIF90b2dnbGVWaWV3KGV2ZW50KSB7XG4gICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgY29uc3QgdGVtcGxhdGUgPSAkdGFyZ2V0LmRhdGEoJ2xpc3RpbmctdmlldycpID09PSAnZ3JpZCcgPyAnc2VhcmNoL3Byb2R1Y3QtbGlzdGluZycgOiAnc2VhcmNoL3Byb2R1Y3QtbGlzdGluZy1saXN0JztcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgdGVtcGxhdGU6IHtcbiAgICAgICAgcHJvZHVjdExpc3Rpbmc6IHRlbXBsYXRlXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuRmFjZXRlZFNlYXJjaC5pbml0KG9wdGlvbnMpO1xuXG4gICAgJHRhcmdldC5hZGRDbGFzcygnYWN0aXZlJykuc2libGluZ3MoKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpdGVNYXAgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFBhZ2VNYW5hZ2VyIGZyb20gJy4uL1BhZ2VNYW5hZ2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3Vic2NyaWJlIGV4dGVuZHMgUGFnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbiIsImltcG9ydCBQYWdlTWFuYWdlciBmcm9tICcuLi9QYWdlTWFuYWdlcic7XG5pbXBvcnQgeyB3aXNobGlzdFBhZ2luYXRpb25IZWxwZXIgfSBmcm9tICcuL3V0aWxzL3BhZ2luYXRpb24tdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXNoTGlzdCBleHRlbmRzIFBhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vblJlYWR5KCk7XG4gICAgfVxuXG4gICAgb25SZWFkeSgpIHtcbiAgICAgICAgaWYgKCQoJ1tkYXRhLXBhZ2luYXRpb24td2lzaGxpc3RdJykubGVuZ3RoKSB7XG4gICAgICAgICAgICB3aXNobGlzdFBhZ2luYXRpb25IZWxwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB1dGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XHJcbmltcG9ydCBBbGVydCBmcm9tICcuLi9jb21wb25lbnRzL0FsZXJ0JztcclxuaW1wb3J0IHJlZnJlc2hDb250ZW50IGZyb20gJy4vcmVmcmVzaENvbnRlbnQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FydFV0aWxzIHtcclxuICBjb25zdHJ1Y3Rvcihtb2R1bGVzLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLm1vZHVsZXMgPSBtb2R1bGVzO1xyXG4gICAgdGhpcy4kY2FydENvbnRlbnQgPSAkKCdbZGF0YS1jYXJ0LWNvbnRlbnRdJyk7XHJcbiAgICB0aGlzLiRhZGRUb0NhcnQgPSAkKCdbZGF0YS1idXR0b24tcHVyY2hhc2VdJyk7IC8vIEluaXRpYWxpemUgJGFkZFRvQ2FydFxyXG4gICAgdGhpcy5xdWFudGl0eUlucHV0ID0gJ1tkYXRhLXF1YW50aXR5LWNvbnRyb2wtaW5wdXRdJztcclxuICAgIHRoaXMuY2FydEFsZXJ0cyA9IG5ldyBBbGVydCgkKCdbZGF0YS1hbGVydHNdJykpO1xyXG4gICAgdGhpcy5jYXJ0UHJvbW9zID0gJCgnW2RhdGEtY2FydC1wcm9tb3NdJyk7XHJcbiAgICB0aGlzLnByb2R1Y3REYXRhID0ge307XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XHJcbiAgICAgICAgd2lsbFVwZGF0ZTogKCkgPT4gY29uc29sZS5sb2coJ1VwZGF0ZSByZXF1ZXN0ZWQuJyksXHJcbiAgICAgICAgZGlkVXBkYXRlOiAoKSA9PiBjb25zb2xlLmxvZygnVXBkYXRlIGV4ZWN1dGVkLicpLFxyXG4gICAgfSwgb3B0aW9ucy5jYWxsYmFja3MpO1xyXG59XHJcblxyXG4gIGluaXQoKSB7XHJcbiAgICB0aGlzLl9jYWNoZUluaXRpYWxRdWFudGl0aWVzKCk7XHJcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XHJcbiAgfVxyXG5cclxuICBfYWRkVG9DYXJ0KGV2ZW50KSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgXHJcbiAgICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgIGNvbnN0ICRmb3JtID0gJHRhcmdldC5jbG9zZXN0KCdmb3JtJyk7XHJcbiAgICBjb25zdCBmb3JtRGF0YSA9ICRmb3JtLnNlcmlhbGl6ZSgpOyBcclxuXHJcbiAgICBjb25zb2xlLmxvZygnRm9ybSBkYXRhIGJlaW5nIHNlbnQgdG8gQVBJOicsIGZvcm1EYXRhKTsgLy8gRGVidWcgbGluZVxyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzLndpbGxVcGRhdGUoKTtcclxuXHJcbiAgICAvLyBVc2UgdGhlIEJpZ0NvbW1lcmNlIFN0ZW5jaWwgdXRpbGl0eSB0byBhZGQgdGhlIGl0ZW0gdG8gdGhlIGNhcnRcclxuICAgIHV0aWxzLmFwaS5jYXJ0Lml0ZW1BZGQoZm9ybURhdGEsIChlcnIsIHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5zdGF0dXMgPT09ICdzdWNjZWVkJykge1xyXG4gICAgICAgICAgICByZWZyZXNoQ29udGVudCh0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLmRhdGEuZXJyb3JzLmpvaW4oJ1xcbicpIHx8IFwiVW5mb3J0dW5hdGVseSwgdGhpcyBwcm9kdWN0IGlzIG5vdCBhdmFpbGFibGUgZm9yIHB1cmNoYXNlLlwiO1xyXG4gICAgICAgICAgICB0aGlzLmNhcnRBbGVydHMuZXJyb3IoZXJyb3JNZXNzYWdlLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuX2JpbmRFdmVudHMoKSB7XHJcbiAgdGhpcy4kY2FydENvbnRlbnQub24oJ2NoYW5nZScsIHRoaXMucXVhbnRpdHlJbnB1dCwgXy5iaW5kKF8uZGVib3VuY2UodGhpcy5fdXBkYXRlQ2FydEl0ZW0sIDc1MCksIHRoaXMpKTtcclxuXHJcbiAgLy8gQXR0YWNoIGV2ZW50IGhhbmRsZXIgZm9yIGFkZC10by1jYXJ0IGJ1dHRvbnNcclxuICAkKCdib2R5Jykub24oJ2NsaWNrJywgJ1tkYXRhLWJ1dHRvbi1wdXJjaGFzZV0nLCAoZXZlbnQpID0+IHRoaXMuX2FkZFRvQ2FydChldmVudCkpO1xyXG5cclxuICB0aGlzLiRjYXJ0Q29udGVudC5vbignY2hhbmdlJywgJ1tkYXRhLXF1YW50aXR5LWNvbnRyb2wtaW5wdXRdJywgKGV2dCkgPT4ge1xyXG4gICAgICBjb25zdCAkdGFyZ2V0ID0gJChldnQudGFyZ2V0KTtcclxuICAgICAgY29uc3QgaXRlbUlkID0gJHRhcmdldC5jbG9zZXN0KCdbZGF0YS1xdWFudGl0eS1jb250cm9sXScpLmRhdGEoJ3F1YW50aXR5LWNvbnRyb2wnKTtcclxuXHJcbiAgICAgIHRoaXMucHJvZHVjdERhdGFbaXRlbUlkXS5xdWFudGl0eUFsdGVyZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLnByb2R1Y3REYXRhW2l0ZW1JZF0ubmV3UXVhbnRpdHkgPSBwYXJzZUludCgkdGFyZ2V0LnZhbCgpLCAxMCk7XHJcbiAgfSk7XHJcblxyXG4gIHRoaXMuJGNhcnRDb250ZW50Lm9uKCdjbGljaycsICdbZGF0YS1jYXJ0LWl0ZW0tcmVtb3ZlXScsIChldmVudCkgPT4ge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB0aGlzLl9yZW1vdmVDYXJ0SXRlbShldmVudCk7XHJcbiAgfSk7XHJcblxyXG4gICQoJ2JvZHknKS5vbignY2xpY2snLCAnLm1pbmktY2FydCBbZGF0YS1jYXJ0LWl0ZW0tcmVtb3ZlXScsICgpID0+IHtcclxuICAgICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgpO1xyXG4gIH0pO1xyXG5cclxuICB1dGlscy5ob29rcy5vbignY2FydC1pdGVtLXJlbW92ZS1yZW1vdGUnLCAoKSA9PiB7XHJcbiAgICAgIHJlZnJlc2hDb250ZW50KHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSwgdHJ1ZSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEVuc3VyZSB0aGUgQ2FydFV0aWxzIGlzIGluaXRpYWxpemVkIGFmdGVyIGRvY3VtZW50IGlzIHJlYWR5XHJcbiAgJChkb2N1bWVudCkucmVhZHkoKCkgPT4ge1xyXG4gICAgICBjb25zdCBjYXJ0VXRpbHMgPSBuZXcgQ2FydFV0aWxzKCk7XHJcbiAgICAgIGNhcnRVdGlscy5pbml0KCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuICBfY2FjaGVJbml0aWFsUXVhbnRpdGllcygpIHtcclxuICAgICQoJ1tkYXRhLWNhcnQtaXRlbV0nKS5lYWNoKChpLCBlbCkgPT4ge1xyXG4gICAgICBjb25zdCAkY2FydEl0ZW0gPSAkKGVsKTtcclxuICAgICAgY29uc3QgaXRlbUlkID0gJGNhcnRJdGVtLmRhdGEoJ2l0ZW0taWQnKTtcclxuICAgICAgdGhpcy5wcm9kdWN0RGF0YVtpdGVtSWRdID0ge1xyXG4gICAgICAgIG9sZFF1YW50aXR5OiBwYXJzZUludCgkY2FydEl0ZW0uZmluZCgnW2RhdGEtcXVhbnRpdHktY29udHJvbC1pbnB1dF0nKS5hdHRyKCd2YWx1ZScpLCAxMCksXHJcbiAgICAgICAgcXVhbnRpdHlBbHRlcmVkOiBmYWxzZSxcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZUNhcnRJdGVtKGV2ZW50KSB7XHJcbiAgICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgIGNvbnN0ICRjYXJ0SXRlbSA9ICR0YXJnZXQuY2xvc2VzdCgnW2RhdGEtY2FydC1pdGVtXScpO1xyXG4gICAgY29uc3QgaXRlbUlkID0gJGNhcnRJdGVtLmRhdGEoJ2l0ZW0taWQnKTtcclxuXHJcbiAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCk7XHJcblxyXG4gICAgaWYgKHRoaXMucHJvZHVjdERhdGFbaXRlbUlkXS5xdWFudGl0eUFsdGVyZWQpIHtcclxuICAgICAgY29uc3QgJHF1YW50aXR5SW5wdXQgPSAkY2FydEl0ZW0uZmluZCgnW2RhdGEtY2FydC1pdGVtLXF1YW50aXR5LWlucHV0XScpO1xyXG4gICAgICBjb25zdCBuZXdRdWFudGl0eSA9IHRoaXMucHJvZHVjdERhdGFbaXRlbUlkXS5uZXdRdWFudGl0eTtcclxuXHJcbiAgICAgIHV0aWxzLmFwaS5jYXJ0Lml0ZW1VcGRhdGUoaXRlbUlkLCBuZXdRdWFudGl0eSwgKGVyciwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5zdGF0dXMgPT09ICdzdWNjZWVkJykge1xyXG4gICAgICAgICAgY29uc3QgcmVtb3ZlID0gKG5ld1F1YW50aXR5ID09PSAwKTtcclxuXHJcbiAgICAgICAgICB0aGlzLnByb2R1Y3REYXRhW2l0ZW1JZF0ub2xkUXVhbnRpdHkgPSBuZXdRdWFudGl0eTtcclxuICAgICAgICAgIHJlZnJlc2hDb250ZW50KHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSwgcmVtb3ZlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJHF1YW50aXR5SW5wdXQudmFsKHRoaXMucHJvZHVjdERhdGFbaXRlbUlkXS5vbGRRdWFudGl0eSk7XHJcbiAgICAgICAgICB0aGlzLmNhcnRBbGVydHMuZXJyb3IocmVzcG9uc2UuZGF0YS5lcnJvcnMuam9pbignXFxuJyksIHRydWUpO1xyXG5cclxuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGhpcy5jYXJ0UHJvbW9zLmVtcHR5KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3JlbW92ZUNhcnRJdGVtKGV2ZW50KSB7XHJcbiAgICBjb25zdCBpdGVtSWQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoJ1tkYXRhLWNhcnQtaXRlbV0nKS5kYXRhKCdpdGVtLWlkJyk7XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgpO1xyXG5cclxuICAgIHV0aWxzLmFwaS5jYXJ0Lml0ZW1SZW1vdmUoaXRlbUlkLCAoZXJyLCByZXNwb25zZSkgPT4ge1xyXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YS5zdGF0dXMgPT09ICdzdWNjZWVkJykge1xyXG4gICAgICAgIHJlZnJlc2hDb250ZW50KHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSwgdHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jYXJ0QWxlcnRzLmVycm9yKHJlc3BvbnNlLmRhdGEuZXJyb3JzLmpvaW4oJ1xcbicpLCB0cnVlKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcbmltcG9ydCBBbGVydCBmcm9tICcuLi9jb21wb25lbnRzL0FsZXJ0JztcbmltcG9ydCByZWZyZXNoQ29udGVudCBmcm9tICcuL3JlZnJlc2hDb250ZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ291cG9uQ29kZXMge1xuICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsID0gJChlbCk7XG4gICAgdGhpcy5jb3Vwb25BbGVydHMgPSBuZXcgQWxlcnQoJCgnW2RhdGEtYWxlcnRzXScpKTtcblxuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgIGNvbnRleHQ6IHt9LFxuICAgICAgJHNjb3BlOiAkKCdbZGF0YS1jYXJ0LXRvdGFsc10nKSxcbiAgICAgIHZpc2libGVDbGFzczogJ3Zpc2libGUnLFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiBjb25zb2xlLmxvZygnVXBkYXRlIHJlcXVlc3RlZC4nKSxcbiAgICAgIGRpZFVwZGF0ZTogKCkgPT4gY29uc29sZS5sb2coJ1VwZGF0ZSBleGVjdXRlZC4nKSxcbiAgICB9LCBvcHRpb25zLmNhbGxiYWNrcyk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLm9wdGlvbnMuJHNjb3BlLm9uKCdzdWJtaXQnLCAnW2RhdGEtY291cG9uLWNvZGUtZm9ybV0nLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9hZGRDb2RlKCk7XG4gICAgfSk7XG4gIH1cblxuICBfYWRkQ29kZSgpIHtcbiAgICBjb25zdCAkaW5wdXQgPSAkKCdbZGF0YS1jb3Vwb24tY29kZS1pbnB1dF0nLCB0aGlzLm9wdGlvbnMuJHNjb3BlKTtcbiAgICBjb25zdCBjb2RlID0gJGlucHV0LnZhbCgpO1xuXG4gICAgdGhpcy5jb3Vwb25BbGVydHMuY2xlYXIoKTtcbiAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCk7XG5cbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgIHRoaXMuY291cG9uQWxlcnRzLmVycm9yKHRoaXMub3B0aW9ucy5jb250ZXh0LmNvdXBvbkNvZGVFbXB0eUlucHV0LCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICB1dGlscy5hcGkuY2FydC5hcHBseUNvZGUoY29kZSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgIHJlZnJlc2hDb250ZW50KHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdXBvbkFsZXJ0cy5lcnJvcihyZXNwb25zZS5kYXRhLmVycm9ycy5qb2luKCdcXG4nKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmRpZFVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xuaW1wb3J0IE1vZGFsIGZyb20gJ2JjLW1vZGFsJztcbmltcG9ydCBBdHRyaWJ1dGVzSGVscGVyIGZyb20gJy4uL3Byb2R1Y3QvQXR0cmlidXRlc0hlbHBlcic7XG5pbXBvcnQgU2VsZWN0V3JhcHBlciBmcm9tICcuLi9jb21wb25lbnRzL1NlbGVjdFdyYXBwZXInO1xuaW1wb3J0IENvbG9yU3dhdGNoIGZyb20gJy4uL3Byb2R1Y3QvQ29sb3JTd2F0Y2gnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJ0RWRpdE9wdGlvbnMge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYWxsYmFja3MpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuZWwgPSAnPGRpdiBpZD1cImNhcnQtb3B0aW9ucy1tb2RhbFwiPic7XG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICB0aGlzLmNhcnRPcHRpb25zTW9kYWwgPSBuZXcgTW9kYWwoe1xuICAgICAgZWw6IHRoaXMuZWwsXG4gICAgICBtb2RhbENsYXNzOiAnY2FydC1vcHRpb25zLW1vZGFsJyxcbiAgICAgIGFmdGVyU2hvdzogKCRtb2RhbCkgPT4ge1xuICAgICAgICB0aGlzLl9mZXRjaFByb2R1Y3QoJG1vZGFsLCB0aGlzLmlkKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmNhbGxiYWNrcyA9ICQuZXh0ZW5kKHtcbiAgICAgIHdpbGxVcGRhdGU6ICgpID0+IGNvbnNvbGUubG9nKCdVcGRhdGUgcmVxdWVzdGVkLicpLFxuICAgICAgZGlkVXBkYXRlOiAoKSA9PiBjb25zb2xlLmxvZygnVXBkYXRlIGV4ZWN1dGVkLicpLFxuICAgIH0sIGNhbGxiYWNrcyk7XG5cbiAgICAvLyBBYnN0cmFjdGVkIGF0dHJpYnV0ZXMgZnVuY3Rpb25hbGl0eVxuICAgIHRoaXMuYXR0cmlidXRlc0hlbHBlciA9IG5ldyBBdHRyaWJ1dGVzSGVscGVyKCcjQ2FydEVkaXRQcm9kdWN0RmllbGRzRm9ybScpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgJCgnYm9keScpLm9uKCdjbGljaycsICdbZGF0YS1pdGVtLWVkaXRdJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLmlkID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKCdpdGVtLWVkaXQnKTtcblxuICAgICAgaWYgKCF0aGlzLmlkKSB7IHJldHVybjsgfVxuXG4gICAgICB0aGlzLmNhcnRPcHRpb25zTW9kYWwub3BlbigpO1xuICAgIH0pO1xuXG4gICAgJCgnYm9keScpLm9uKCdzdWJtaXQnLCAnI0NhcnRFZGl0UHJvZHVjdEZpZWxkc0Zvcm0nLCAoKSA9PiB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGFqYXggZmV0Y2ggb2YgcHJvZHVjdCBhbmQgYWRkIHRvIG1vZGFsLiBCaW5kIHByb2R1Y3QgZnVuY3Rpb25hbGl0eSBhbmQgc2hvdyB0aGUgbW9kYWxcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRtb2RhbCAtIHRoZSByb290IChhcHBlbmRlZCkgbW9kYWwgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICRpdGVtSWQgLSBwcm9kdWN0IGlkXG4gICAqL1xuICBfZmV0Y2hQcm9kdWN0KCRtb2RhbCwgJGl0ZW1JRCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICB0ZW1wbGF0ZTogJ2NhcnQvZWRpdC1vcHRpb25zJyxcbiAgICB9O1xuXG4gICAgdXRpbHMuYXBpLnByb2R1Y3RBdHRyaWJ1dGVzLmNvbmZpZ3VyZUluQ2FydCgkaXRlbUlELCBvcHRpb25zLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgJG1vZGFsXG4gICAgICAgIC5maW5kKCcubW9kYWwtY29udGVudCcpXG4gICAgICAgIC5hcHBlbmQocmVzcG9uc2UuY29udGVudClcbiAgICAgICAgLmZpbmQoJy5jYXJ0LWVkaXQtb3B0aW9ucycpXG4gICAgICAgIC5hZGRDbGFzcygnY2FydC1lZGl0LW9wdGlvbnMtdmlzaWJsZScpO1xuXG4gICAgICB0aGlzLmNhcnRPcHRpb25zTW9kYWwucG9zaXRpb24oKTtcbiAgICAgICRtb2RhbC5hZGRDbGFzcygnbG9hZGVkJyk7XG5cbiAgICAgIGNvbnN0ICRzZWxlY3QgPSAkbW9kYWwuZmluZCgnc2VsZWN0Jyk7XG4gICAgICBpZiAoJHNlbGVjdC5sZW5ndGgpIHtcbiAgICAgICAgJHNlbGVjdC5lYWNoKChpLCBlbCkgPT4ge1xuICAgICAgICAgIG5ldyBTZWxlY3RXcmFwcGVyKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3dhdGNoZXMgPSBuZXcgQ29sb3JTd2F0Y2goKTsgLy8gSW5pdCBvdXIgY29sb3Igc3dhdGNoZXNcblxuICAgICAgdXRpbHMuaG9va3Mub24oJ3Byb2R1Y3Qtb3B0aW9uLWNoYW5nZScsIChldmVudCwgb3B0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLndpbGxVcGRhdGUoKTtcbiAgICAgICAgY29uc3QgJGNoYW5nZWRPcHRpb24gPSAkKG9wdGlvbik7XG4gICAgICAgIGNvbnN0ICRmb3JtID0gJCgnI0NhcnRFZGl0UHJvZHVjdEZpZWxkc0Zvcm0nKTtcbiAgICAgICAgY29uc3QgJHN1Ym1pdCA9ICQoJ2lucHV0W3R5cGU9XCJzdWJtaXRcIl0nLCAkZm9ybSk7XG4gICAgICAgIGNvbnN0ICRtZXNzYWdlQm94ID0gJCgnW2RhdGEtcmVjb25maWd1cmUtZXJyb3JzXScpO1xuICAgICAgICBjb25zdCBpdGVtID0gJCgnW25hbWU9XCJpdGVtX2lkXCJdJywgJGZvcm0pLmF0dHIoJ3ZhbHVlJyk7XG5cbiAgICAgICAgdXRpbHMuYXBpLnByb2R1Y3RBdHRyaWJ1dGVzLm9wdGlvbkNoYW5nZShpdGVtLCAkZm9ybS5zZXJpYWxpemUoKSwgJ2NhcnQvZWRpdC1vcHRpb25zJywgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHJlc3VsdC5kYXRhIHx8IHt9O1xuXG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzSGVscGVyLnVwZGF0ZUF0dHJpYnV0ZXMoZGF0YSk7XG5cbiAgICAgICAgICBpZiAoZGF0YS5wdXJjaGFzaW5nX21lc3NhZ2UpIHtcbiAgICAgICAgICAgICQoJG1lc3NhZ2VCb3gpLmh0bWwoZGF0YS5wdXJjaGFzaW5nX21lc3NhZ2UpO1xuICAgICAgICAgICAgJHN1Ym1pdC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgJG1lc3NhZ2VCb3guc2hvdygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc3VibWl0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgJG1lc3NhZ2VCb3guaGlkZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZGF0YS5wdXJjaGFzYWJsZSB8fCAhZGF0YS5pbnN0b2NrKSB7XG4gICAgICAgICAgICAkc3VibWl0LnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzdWJtaXQucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUoKTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICB1dGlscy5ob29rcy5lbWl0KCdwcm9kdWN0LW9wdGlvbi1jaGFuZ2UnKTtcbiAgICB9KVxuICB9XG59XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xuaW1wb3J0IEFsZXJ0IGZyb20gJy4uL2NvbXBvbmVudHMvQWxlcnQnO1xuaW1wb3J0IHJlZnJlc2hDb250ZW50IGZyb20gJy4vcmVmcmVzaENvbnRlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHaWZ0Q2VydGlmaWNhdGVzIHtcbiAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbCA9ICQoZWwpO1xuICAgIHRoaXMuY2VydGlmaWNhdGVBbGVydHMgPSBuZXcgQWxlcnQoJCgnW2RhdGEtYWxlcnRzXScpKTtcblxuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgIGNvbnRleHQ6IHt9LFxuICAgICAgJHNjb3BlOiAkKCdbZGF0YS1jYXJ0LXRvdGFsc10nKSxcbiAgICAgIHZpc2libGVDbGFzczogJ3Zpc2libGUnLFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiBjb25zb2xlLmxvZygnVXBkYXRlIHJlcXVlc3RlZC4nKSxcbiAgICAgIGRpZFVwZGF0ZTogKCkgPT4gY29uc29sZS5sb2coJ1VwZGF0ZSBleGVjdXRlZC4nKSxcbiAgICB9LCBvcHRpb25zLmNhbGxiYWNrcyk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLm9wdGlvbnMuJHNjb3BlLm9uKCdjbGljaycsICdbZGF0YS1naWZ0LWNlcnRpZmljYXRlLXRvZ2dsZV0nLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl90b2dnbGUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMub3B0aW9ucy4kc2NvcGUub24oJ3N1Ym1pdCcsICdbZGF0YS1naWZ0LWNlcnRpZmljYXRlLWZvcm1dJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fYWRkQ29kZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX3RvZ2dsZSgpIHtcbiAgICAkKCdbZGF0YS1naWZ0LWNlcnRpZmljYXRlLWZvcm1dJywgdGhpcy5vcHRpb25zLiRzY29wZSkudG9nZ2xlQ2xhc3ModGhpcy5vcHRpb25zLnZpc2libGVDbGFzcyk7XG4gIH1cblxuICBfYWRkQ29kZSgpIHtcbiAgICBjb25zdCAkaW5wdXQgPSAkKCdbZGF0YS1naWZ0LWNlcnRpZmljYXRlLWlucHV0XScsIHRoaXMub3B0aW9ucy4kc2NvcGUpO1xuICAgIGNvbnN0IGNvZGUgPSAkaW5wdXQudmFsKCk7XG5cbiAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCk7XG5cbiAgICBpZiAoISB0aGlzLl9pc1ZhbGlkQ29kZShjb2RlKSkge1xuICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUFsZXJ0cy5lcnJvcih0aGlzLm9wdGlvbnMuY29udGV4dC5naWZ0Q2VydGlmaWNhdGVJbnB1dEVtcHR5LCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICB1dGlscy5hcGkuY2FydC5hcHBseUdpZnRDZXJ0aWZpY2F0ZShjb2RlLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSAnc3VjY2VzcycpIHtcbiAgICAgICAgcmVmcmVzaENvbnRlbnQodGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVBbGVydHMuZXJyb3IocmVzcG9uc2UuZGF0YS5lcnJvcnMuam9pbignXFxuJyksIHRydWUpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9pc1ZhbGlkQ29kZShjb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xuaW1wb3J0IE1vZGFsIGZyb20gJ2JjLW1vZGFsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2lmdFdyYXBwaW5nIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgc2NvcGU6ICdbZGF0YS1jYXJ0LWNvbnRlbnRdJyxcbiAgICAgIHRyaWdnZXI6ICdbZGF0YS1pdGVtLWdpZnR3cmFwXScsXG4gICAgICByZW1vdmU6ICdbZGF0YS1naWZ0d3JhcC1yZW1vdmVdJyxcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuJGNhcnRDb250ZW50ID0gJCh0aGlzLm9wdGlvbnMuc2NvcGUpO1xuICAgIHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgfVxuXG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuaXRlbUlkOyAvLyBsYXRlciBhc3NpZ25lZCB0aGUgaWQgb2YgdGhlIGN1cnJlbnQgcHJvZHVjdFxuXG4gICAgdGhpcy5HaWZ0V3JhcE1vZGFsID0gbmV3IE1vZGFsKHtcbiAgICAgIG1vZGFsQ2xhc3M6ICdnaWZ0d3JhcC1tb2RhbCcsXG4gICAgICBhZnRlclNob3c6ICgkbW9kYWwpID0+IHtcbiAgICAgICAgdGhpcy5fZ2V0Rm9ybSgkbW9kYWwpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuX2JpbmRQYWdlRXZlbnRzKCk7XG4gIH1cblxuICAvLyBCaW5kIGZ1bmN0aW9uYWxpdHkgdG8gZ2lmdHdyYXAgbGlua3MuXG4gIF9iaW5kUGFnZUV2ZW50cygpIHtcbiAgICB0aGlzLiRjYXJ0Q29udGVudC5vbignY2xpY2snLCB0aGlzLm9wdGlvbnMudHJpZ2dlciwgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICB0aGlzLml0ZW1JZCA9ICR0YXJnZXQuZGF0YSgnaXRlbS1naWZ0d3JhcCcpO1xuXG4gICAgICB0aGlzLkdpZnRXcmFwTW9kYWwub3BlbigpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kY2FydENvbnRlbnQub24oJ2NsaWNrJywgdGhpcy5vcHRpb25zLnJlbW92ZSwgKGV2ZW50KSA9PiB7XG4gICAgICBpZighY29uZmlybSh0aGlzLmNvbnRleHQucmVtb3ZlR2lmdFdyYXApKSB7ZXZlbnQucHJldmVudERlZmF1bHQoKX07XG4gICAgfSk7XG5cbiAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5idXR0b24tY2FuY2VsLWdpZnR3cmFwJywgKCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgdGhpcy5HaWZ0V3JhcE1vZGFsLmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBSdW4gb25jZSB0aGUgbW9kYWwgaGFzIGJlZW4gb3BlbmVkLi5cbiAgX2dldEZvcm0oJG1vZGFsKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgdGVtcGxhdGU6ICdjYXJ0L2dpZnR3cmFwLWZvcm0nIH07XG5cbiAgICB1dGlscy5hcGkuY2FydC5nZXRJdGVtR2lmdFdyYXBwaW5nT3B0aW9ucyh0aGlzLml0ZW1JZCwgb3B0aW9ucywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAkbW9kYWwuZmluZCgnLm1vZGFsLWNvbnRlbnQnKS5hcHBlbmQocmVzcG9uc2UuY29udGVudCk7XG4gICAgICAgIHRoaXMuX2JpbmRNb2RhbEV2ZW50cygkbW9kYWwpO1xuXG4gICAgICAgIC8vIHJlcG9zaXRpb24gbW9kYWwgd2l0aCBjb250ZW50XG4gICAgICAgIHRoaXMuR2lmdFdyYXBNb2RhbC5wb3NpdGlvbigpO1xuXG4gICAgICAgIC8vIENsYXNzIGFkZGVkIHRvIGRpc3BsYXkgdGhlIG1vZGFsIG9uY2UgY29udGVudCBpcyBhdmFpbGFibGVcbiAgICAgICAgJG1vZGFsLmFkZENsYXNzKCd2aXNpYmxlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLkdpZnRXcmFwTW9kYWwuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9iaW5kTW9kYWxFdmVudHMoJG1vZGFsKSB7XG4gICAgJG1vZGFsLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICB0aGlzLkdpZnRXcmFwTW9kYWwucG9zaXRpb24oKTtcbiAgICB9KTtcblxuICAgIC8vIFNlbGVjdCBnaWZ0d3JhcHBpbmcgaW5kaXZpZHVhbGx5IG9yIHRvZ2V0aGVyXG4gICAgJG1vZGFsLmZpbmQoJ1tkYXRhLWdpZnR3cmFwLXR5cGVdJykub24oJ2NoYW5nZScsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlU2luZ2xlTXVsdGlwbGUoJG1vZGFsLCBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8vIFNlbGVjdCB0aGUgdHlwZSBvZiBnaWZ0IHdyYXBwaW5nIGZvciBhIHBhcnRpY3VsYXIgaXRlbVxuICAgICQoJ1tkYXRhLWdpZnR3cmFwLXNlbGVjdF0nKS5jaGFuZ2UoKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCAkc2VsZWN0ID0gJChldmVudC50YXJnZXQpO1xuICAgICAgY29uc3QgaW5kZXggPSAkc2VsZWN0LmRhdGEoJ2luZGV4Jyk7XG4gICAgICBjb25zdCBpZCA9ICRzZWxlY3QudmFsKCk7XG5cbiAgICAgIGlmICghaWQpIHsgcmV0dXJuOyB9XG4gICAgICBjb25zdCBhbGxvd01lc3NhZ2UgPSAkc2VsZWN0LmZpbmQoYG9wdGlvblt2YWx1ZT0ke2lkfV1gKS5kYXRhKCdhbGxvdy1tZXNzYWdlJyk7XG5cbiAgICAgICQoYFtkYXRhLWdpZnR3cmFwLWltYWdlLSR7aW5kZXh9XWApLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICQoYFtkYXRhLWdpZnR3cmFwLWltYWdlLSR7aW5kZXh9PVwiJHtpZH1cIl1gKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG5cbiAgICAgIGlmIChhbGxvd01lc3NhZ2UpIHtcbiAgICAgICAgJChgW2RhdGEtZ2lmdHdyYXAtbWVzc2FnZS0ke2luZGV4fV1gKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKGBbZGF0YS1naWZ0d3JhcC1tZXNzYWdlLSR7aW5kZXh9XWApLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgICQoJ1tkYXRhLWdpZnR3cmFwLXNlbGVjdF0nKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgfVxuXG4gIC8vIFRvZ2dsZXMgZGlzcGxheWluZyBzaW5nbGUgLyBtdWx0aXBsZSB3cmFwIG9wdGlvbnNcbiAgX3RvZ2dsZVNpbmdsZU11bHRpcGxlKCRtb2RhbCwgdmFsdWUpIHtcbiAgICBjb25zdCAkc2luZ2xlRm9ybSA9ICRtb2RhbC5maW5kKCdbZGF0YS1naWZ0d3JhcC1zaW5nbGVdJyk7XG4gICAgY29uc3QgJG11bHRpRm9ybSAgPSAkbW9kYWwuZmluZCgnW2RhdGEtZ2lmdHdyYXAtbXVsdGlwbGVdJyk7XG5cbiAgICBpZiAodmFsdWUgPT09ICdkaWZmZXJlbnQnKSB7XG4gICAgICAkc2luZ2xlRm9ybS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAkbXVsdGlGb3JtLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICB9ICBlbHNlIHtcbiAgICAgICRzaW5nbGVGb3JtLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICRtdWx0aUZvcm0uYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHV0aWxzIGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcbmltcG9ydCBBbGVydCBmcm9tICcuLi9jb21wb25lbnRzL0FsZXJ0JztcbmltcG9ydCByZWZyZXNoQ29udGVudCBmcm9tICcuL3JlZnJlc2hDb250ZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hpcHBpbmdDYWxjdWxhdG9yIHtcbiAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbCA9ICQoZWwpO1xuICAgIHRoaXMuc2hpcHBpbmdBbGVydHMgPSBuZXcgQWxlcnQoJCgnW2RhdGEtYWxlcnRzXScpKTtcblxuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgIGNvbnRleHQ6IHt9LFxuICAgICAgJHNjb3BlOiAkKCdbZGF0YS1jYXJ0LXRvdGFsc10nKSxcbiAgICAgIHZpc2libGVDbGFzczogJ3Zpc2libGUnLFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XG4gICAgICB3aWxsVXBkYXRlOiAoKSA9PiBjb25zb2xlLmxvZygnVXBkYXRlIHJlcXVlc3RlZC4nKSxcbiAgICAgIGRpZFVwZGF0ZTogKCkgPT4gY29uc29sZS5sb2coJ1VwZGF0ZSBleGVjdXRlZC4nKSxcbiAgICB9LCBvcHRpb25zLmNhbGxiYWNrcyk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLm9wdGlvbnMuJHNjb3BlLm9uKCdjbGljaycsICdbZGF0YS1zaGlwcGluZy1jYWxjdWxhdG9yLXRvZ2dsZV0nLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl90b2dnbGUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMub3B0aW9ucy4kc2NvcGUub24oJ3N1Ym1pdCcsICdbZGF0YS1zaGlwcGluZy1jYWxjdWxhdG9yXSBmb3JtJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fY2FsY3VsYXRlU2hpcHBpbmcoKTtcbiAgICB9KTtcblxuICAgIHRoaXMub3B0aW9ucy4kc2NvcGUub24oJ2NoYW5nZScsICdzZWxlY3RbbmFtZT1cInNoaXBwaW5nLWNvdW50cnlcIl0nLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlcyhldmVudCk7XG4gICAgICB0aGlzLm9wdGlvbnMuJHNjb3BlLmZpbmQoJ1tuYW1lPVwic2hpcHBpbmctemlwXCJdJykudmFsKCcnKTtcbiAgICB9KTtcbiAgfVxuXG4gIF90b2dnbGUoKSB7XG4gICAgJCgnW2RhdGEtc2hpcHBpbmctY2FsY3VsYXRvcl0nLCB0aGlzLm9wdGlvbnMuJHNjb3BlKS50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMudmlzaWJsZUNsYXNzKTtcbiAgfVxuXG4gIF91cGRhdGVTdGF0ZXMoZXZlbnQpIHtcbiAgICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICBjb25zdCBjb3VudHJ5ID0gJHRhcmdldC52YWwoKTtcbiAgICBjb25zdCAkc3RhdGVFbGVtZW50ID0gJCgnW25hbWU9XCJzaGlwcGluZy1zdGF0ZVwiXScpO1xuXG4gICAgdXRpbHMuYXBpLmNvdW50cnkuZ2V0QnlOYW1lKGNvdW50cnksIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UuZGF0YS5zdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlQXJyYXkgPSBbXTtcbiAgICAgICAgc3RhdGVBcnJheS5wdXNoKGA8b3B0aW9uIHZhbHVlPVwiXCI+JHtyZXNwb25zZS5kYXRhLnByZWZpeH08L29wdGlvbj5gKTtcbiAgICAgICAgJC5lYWNoKHJlc3BvbnNlLmRhdGEuc3RhdGVzLCAoaSwgc3RhdGUpID0+IHtcbiAgICAgICAgICBzdGF0ZUFycmF5LnB1c2goYDxvcHRpb24gdmFsdWU9XCIke3N0YXRlLmlkfVwiPiR7c3RhdGUubmFtZX08L29wdGlvbj5gKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRzdGF0ZUVsZW1lbnQucGFyZW50KCkuYWRkQ2xhc3MoJ2Zvcm0tc2VsZWN0LXdyYXBwZXInKTtcbiAgICAgICAgJHN0YXRlRWxlbWVudC5yZXBsYWNlV2l0aChgPHNlbGVjdCBjbGFzcz1cImZvcm0tc2VsZWN0IGZvcm0taW5wdXQgZm9ybS1pbnB1dC1zaG9ydFwiIGlkPVwic2hpcHBpbmctc3RhdGVcIiBuYW1lPVwic2hpcHBpbmctc3RhdGVcIiBkYXRhLWZpZWxkLXR5cGU9XCJTdGF0ZVwiPiR7c3RhdGVBcnJheS5qb2luKCcgJyl9PC9zZWxlY3Q+YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc3RhdGVFbGVtZW50LnBhcmVudCgpLnJlbW92ZUNsYXNzKCdmb3JtLXNlbGVjdC13cmFwcGVyJyk7XG4gICAgICAgICRzdGF0ZUVsZW1lbnQucmVwbGFjZVdpdGgoYDxpbnB1dCBjbGFzcz1cImZvcm0taW5wdXQgZm9ybS1pbnB1dC1zaG9ydFwiIHR5cGU9XCJ0ZXh0XCIgaWQ9XCJzaGlwcGluZy1zdGF0ZVwiIG5hbWU9XCJzaGlwcGluZy1zdGF0ZVwiIGRhdGEtZmllbGQtdHlwZT1cIlN0YXRlXCIgcGxhY2Vob2xkZXI9XCIke3RoaXMub3B0aW9ucy5jb250ZXh0LnNoaXBwaW5nU3RhdGV9XCI+YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfY2FsY3VsYXRlU2hpcHBpbmcoKSB7XG4gICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgpO1xuXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgY291bnRyeV9pZDogJCgnW25hbWU9XCJzaGlwcGluZy1jb3VudHJ5XCJdJywgdGhpcy4kY2FsY3VsYXRvckZvcm0pLnZhbCgpLFxuICAgICAgc3RhdGVfaWQ6ICQoJ1tuYW1lPVwic2hpcHBpbmctc3RhdGVcIl0nLCB0aGlzLiRjYWxjdWxhdG9yRm9ybSkudmFsKCksXG4gICAgICB6aXBfY29kZTogJCgnW25hbWU9XCJzaGlwcGluZy16aXBcIl0nLCB0aGlzLiRjYWxjdWxhdG9yRm9ybSkudmFsKClcbiAgICB9O1xuXG4gICAgdXRpbHMuYXBpLmNhcnQuZ2V0U2hpcHBpbmdRdW90ZXMocGFyYW1zLCAnY2FydC9zaGlwcGluZy1xdW90ZXMnLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgJHNoaXBwaW5nUXVvdGVzID0gJCgnW2RhdGEtc2hpcHBpbmctcXVvdGVzXScsIHRoaXMub3B0aW9ucy4kc2NvcGUpO1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEucXVvdGVzKSB7XG4gICAgICAgIHRoaXMuc2hpcHBpbmdBbGVydHMuY2xlYXIoKTtcbiAgICAgICAgJHNoaXBwaW5nUXVvdGVzLmh0bWwocmVzcG9uc2UuY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNoaXBwaW5nQWxlcnRzLmVycm9yKHJlc3BvbnNlLmRhdGEuZXJyb3JzLmpvaW4oJ1xcbicpLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XG5cbiAgICAgIC8vIGJpbmQgdGhlIHNoaXBwaW5nIG1ldGhvZCByYWRpb3NcbiAgICAgICRzaGlwcGluZ1F1b3Rlcy5maW5kKCcuZm9ybScpLm9uKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCk7XG5cbiAgICAgICAgY29uc3QgcXVvdGVJZCA9ICQoJ1tkYXRhLXNoaXBwaW5nLXF1b3RlXTpjaGVja2VkJykudmFsKCk7XG5cbiAgICAgICAgdXRpbHMuYXBpLmNhcnQuc3VibWl0U2hpcHBpbmdRdW90ZShxdW90ZUlkLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICByZWZyZXNoQ29udGVudCh0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkaWRVcGRhdGUsIHJlbW92ZSkge1xuICBjb25zdCAkY2FydFRvdGFscyA9ICQoJ1tkYXRhLWNhcnQtdG90YWxzXScpO1xuICBjb25zdCAkY2FydENvbnRlbnQgPSAkKCdbZGF0YS1jYXJ0LWNvbnRlbnRdJyk7XG4gIGNvbnN0ICRjYXJ0UHJvbW9zID0gJCgnW2RhdGEtY2FydC1wcm9tb3NdJyk7XG4gIGNvbnN0ICRjYXJ0SXRlbSA9ICQoJ1tkYXRhLWNhcnQtaXRlbV0nLCAkY2FydENvbnRlbnQpO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHRlbXBsYXRlOiB7XG4gICAgICBjb250ZW50OiAnY2FydC9jb250ZW50JyxcbiAgICAgIHRvdGFsczogJ2NhcnQvdG90YWxzJyxcbiAgICAgIHByb21vczogJ2hlYWRlci9zaGlwcGluZy1tZXNzYWdlcydcbiAgICB9LFxuICB9O1xuXG4gIC8vIFJlbW92ZSBsYXN0IGl0ZW0gZnJvbSBjYXJ0PyBSZWxvYWRcbiAgaWYgKHJlbW92ZSAmJiAkY2FydEl0ZW0ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxuXG4gIHV0aWxzLmFwaS5jYXJ0LmdldENvbnRlbnQob3B0aW9ucywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAvLyBUT0RPOiBTY29wZSB0aGUgY2FsbCB0byB0aGlzIGZ1bmN0aW9uIGJ5IGFyZWEgdGhhdCBuZWVkcyB1cGRhdGluZ1xuICAgICRjYXJ0Q29udGVudC5odG1sKHJlc3BvbnNlLmNvbnRlbnQpO1xuICAgICRjYXJ0VG90YWxzLmh0bWwocmVzcG9uc2UudG90YWxzKTtcbiAgICAkY2FydFByb21vcy5yZXBsYWNlV2l0aChyZXNwb25zZS5wcm9tb3MpO1xuICAgICRjYXJ0Q29udGVudC50cmlnZ2VyKCdjYXJ0LWluaXRpYWxpemUtbW9kdWxlcycpO1xuXG4gICAgLy8gVE9ETzogSWYgdGhlIGxvYWRpbmcgb3ZlcmxheSBpcyBzY29wZWQgdG8gYW4gYXJlYSB0aGF0IGlzIHJlcGxhY2VkXG4gICAgLy8gaXQgZG9lcyBub3QgZmFkZSBvdXQsIGJ1dCBpcyByZW1vdmVkIGFicnVidGx5IChkdWUgdG8gYmVpbmcgYVxuICAgIC8vIHBhcnQgb2YgdGhhdCBhcmVhJ3MgY29udGVudCkuXG4gICAgZGlkVXBkYXRlKCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFsZXJ0IHtcclxuICBjb25zdHJ1Y3RvcigkZWwsIG9wdGlvbnMgPSB7fSkge1xyXG5cclxuICAgIHRoaXMuJGVsID0gJGVsO1xyXG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xyXG4gICAgICBjbGFzc2VzOiB7XHJcbiAgICAgICAgYmFzZTogJ2FsZXJ0JyxcclxuICAgICAgICBlcnJvcjogJ2FsZXJ0LWVycm9yJyxcclxuICAgICAgICBpbmZvOiAnYWxlcnQtaW5mbycsXHJcbiAgICAgICAgc3VjY2VzczogJ2FsZXJ0LXN1Y2Nlc3MnLFxyXG4gICAgICB9LFxyXG4gICAgICBsaW1pdDogMSxcclxuICAgICAgdGVtcGxhdGU6IHt9LFxyXG4gICAgICBjYWxsYmFja3M6IHt9LFxyXG4gICAgfSwgb3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XHJcbiAgICAgIHdpbGxVcGRhdGU6ICgpID0+IHt9LFxyXG4gICAgICBkaWRVcGRhdGU6ICgpID0+IHt9LFxyXG4gICAgfSwgb3B0aW9ucy5jYWxsYmFja3MpO1xyXG5cclxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcclxuICB9XHJcblxyXG4gIF9iaW5kRXZlbnRzKCkge1xyXG4gICAgaWYgKF8uaXNFbXB0eSh0aGlzLm9wdGlvbnMudGVtcGxhdGUpKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy50ZW1wbGF0ZSA9IF8udGVtcGxhdGUoYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9JyR7dGhpcy5vcHRpb25zLmNsYXNzZXMuYmFzZX0gPCU9IG1lc3NhZ2VUeXBlICU+Jz5cclxuICAgICAgICAgIDwlIGlmIChpc0Rpc21pc3NhYmxlKSB7ICU+XHJcbiAgICAgICAgICAgIDxhIGNsYXNzPVwiYWxlcnQtZGlzbWlzc1wiPiZ0aW1lczs8L2E+XHJcbiAgICAgICAgICA8JSB9ICU+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtbWVzc2FnZVwiPlxyXG4gICAgICAgICAgICA8JT0gbWVzc2FnZVRleHQgJT5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICBgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLiRlbC5vbignY2xpY2snLCAnLmFsZXJ0LWRpc21pc3MnLCAoZXZlbnQpID0+IHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgY29uc3QgJGFsZXJ0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5wYXJlbnQoJy5hbGVydCcpO1xyXG4gICAgICB0aGlzLl9kaXNtaXNzTWVzc2FnZSgkYWxlcnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy4kZWwub24oJ2NsZWFyLW1lc3NhZ2VzJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHJlc2V0IHRoZSBjb250ZW50cyBvZiB0aGlzLiRlbFxyXG4gICAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy4kZWwuZmluZChgLiR7dGhpcy5vcHRpb25zLmNsYXNzZXMuYmFzZX1gKS5lYWNoKChpbmRleCwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgIHRoaXMuX2Rpc21pc3NNZXNzYWdlKCQodGFyZ2V0KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIGJjLWNvcmUgYmVjb21lcyBpbnRlZ3JhdGVkIGludG8gYmMtc2tlbGV0b24sIHRoaXMgbWV0aG9kIHNob3VsZCBkZWxlZ2F0ZSB0byBgZGlzbWlzc2FibGUoKWBcclxuICAgKiBAcGFyYW0gJGFsZXJ0XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfZGlzbWlzc01lc3NhZ2UoJGFsZXJ0KSB7XHJcbiAgICAkYWxlcnQuYWRkQ2xhc3MoJ2Rpc21pc3NlZCcpO1xyXG4gICAgJGFsZXJ0Lm9uZSgndHJlbmQnLCAoKSA9PiB7XHJcbiAgICAgICRhbGVydC5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhwbGljaXQgdXNhZ2UgdG8gY3JlYXRlIGFuIGVycm9yIGFsZXJ0XHJcbiAgICogQHBhcmFtIHRleHRcclxuICAgKiBAcGFyYW0gZGlzbWlzc2FibGVcclxuICAgKi9cclxuICBlcnJvcih0ZXh0LCBkaXNtaXNzYWJsZSA9IGZhbHNlKXtcclxuICAgIHRoaXMubWVzc2FnZSh0ZXh0LCAnZXJyb3InLCBkaXNtaXNzYWJsZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHBsaWNpdCB1c2FnZSB0byBjcmVhdGUgYSBzdWNjZXNzIGFsZXJ0XHJcbiAgICogQHBhcmFtIHRleHRcclxuICAgKiBAcGFyYW0gZGlzbWlzc2FibGVcclxuICAgKi9cclxuICBzdWNjZXNzKHRleHQsIGRpc21pc3NhYmxlID0gZmFsc2Upe1xyXG4gICAgdGhpcy5tZXNzYWdlKHRleHQsICdzdWNjZXNzJywgZGlzbWlzc2FibGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhwbGljaXQgdXNhZ2UgdG8gY3JlYXRlIGFuIGluZm9ybWF0aW9uYWwgYWxlcnRcclxuICAgKiBAcGFyYW0gdGV4dFxyXG4gICAqIEBwYXJhbSBkaXNtaXNzYWJsZVxyXG4gICAqL1xyXG4gIGluZm8odGV4dCwgZGlzbWlzc2FibGUgPSBmYWxzZSl7XHJcbiAgICB0aGlzLm1lc3NhZ2UodGV4dCwgJ2luZm8nLCBkaXNtaXNzYWJsZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqIEBwYXJhbSB0ZXh0XHJcbiAgICogQHBhcmFtIHR5cGVcclxuICAgKiBAcGFyYW0gZGlzbWlzc2FibGVcclxuICAgKi9cclxuICBtZXNzYWdlKHRleHQsIHR5cGUgPSAnaW5mbycsIGRpc21pc3NhYmxlID0gZmFsc2UpIHtcclxuICAgIHRoaXMuY2FsbGJhY2tzLndpbGxVcGRhdGUoKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5saW1pdCA9PT0gJ251bWJlcicgJiYgdGhpcy4kZWwuZmluZChgLiR7dGhpcy5vcHRpb25zLmNsYXNzZXMuYmFzZX1gKS5sZW5ndGggPiB0aGlzLm9wdGlvbnMubGltaXQpIHtcclxuICAgICAgdGhpcy5fZGlzbWlzc01lc3NhZ2UodGhpcy4kZWwuZmluZChgLiR7dGhpcy5vcHRpb25zLmNsYXNzZXMuYmFzZX06bm90KC5kaXNtaXNzZWQpYCkuZXEoMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XHJcbiAgICAgIG1lc3NhZ2VUeXBlOiB0aGlzLm9wdGlvbnMuY2xhc3Nlc1t0eXBlXSxcclxuICAgICAgbWVzc2FnZVRleHQ6IHRleHQsXHJcbiAgICAgIGlzRGlzbWlzc2FibGU6IGRpc21pc3NhYmxlLFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgJG1vZGFsQm9keSA9ICQoJy5tb2RhbC1ib2R5Jyk7XHJcblxyXG4gICAgY29uc3QgYXBwZW5kTWVzc2FnZSA9ICgkZWwpID0+IHtcclxuICAgICAgJGVsLmFwcGVuZCh0aGlzLm9wdGlvbnMudGVtcGxhdGUobWVzc2FnZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgkbW9kYWxCb2R5Lmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBwcm9kdWN0QWxlcnRzID0gJG1vZGFsQm9keS5maW5kKCdbZGF0YS1wcm9kdWN0LWFsZXJ0c10nKTtcclxuICAgICAgYXBwZW5kTWVzc2FnZShwcm9kdWN0QWxlcnRzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGFsZXJ0cyA9ICQoJy5zaXRlLWhlYWRlcicpLmZpbmQoJ1tkYXRhLWFsZXJ0c10nKTtcclxuICAgICAgYXBwZW5kTWVzc2FnZShhbGVydHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUoKTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVhbnRpdHlXaWRnZXQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICBlbDogJ1tkYXRhLXF1YW50aXR5LWNvbnRyb2xdJyxcbiAgICAgIGNudHJsOiAnW2RhdGEtcXVhbnRpdHktY29udHJvbC1hY3Rpb25dJyxcbiAgICAgIHNjb3BlOiAnYm9keScsXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBCaW5kIENvbnRyb2wgQWN0aW9uc1xuICAgICQodGhpcy5vcHRpb25zLnNjb3BlKS5vbignY2xpY2snLCB0aGlzLm9wdGlvbnMuY250cmwsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy9pbiBjYXNlIHdlIHVzZSA8YnV0dG9uPi88YT4gaW5zdGVhZCBvZiA8c3Bhbj4nc1xuICAgICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFjdGlvbiA9ICR0YXJnZXQuZGF0YSgncXVhbnRpdHktY29udHJvbC1hY3Rpb24nKTtcblxuICAgICAgY29uc3QgJHF1YW50aXR5SW5wdXQgPSAkdGFyZ2V0LnNpYmxpbmdzKCdpbnB1dCcpO1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludCgkcXVhbnRpdHlJbnB1dC52YWwoKSwxMCk7XG4gICAgICBjb25zdCBtaW4gPSAkcXVhbnRpdHlJbnB1dC5hdHRyKCdtaW4nKSA/IHBhcnNlSW50KCRxdWFudGl0eUlucHV0LmF0dHIoJ21pbicpLDEwKSA6IDA7XG4gICAgICBjb25zdCBtYXggPSAkcXVhbnRpdHlJbnB1dC5hdHRyKCdtYXgnKSA/IHBhcnNlSW50KCRxdWFudGl0eUlucHV0LmF0dHIoJ21heCcpLDEwKSA6IEluZmluaXR5O1xuXG4gICAgICBpZiAoYWN0aW9uID09PSAnaW5jcmVtZW50JyAmJiB2YWx1ZSA8IG1heCkge1xuICAgICAgICAkcXVhbnRpdHlJbnB1dC52YWwodmFsdWUgKyAxKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSAnZGVjcmVtZW50JyAmJiB2YWx1ZSA+IDAgJiYgdmFsdWUgPiBtaW4pIHtcbiAgICAgICAgJHF1YW50aXR5SW5wdXQudmFsKHZhbHVlIC0gMSkudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaW1wbGUgaW5wdXQgdmFsaWRhdGlvbiAoa2VlcCBpbnB1dCB3aXRoaW4gbWluL21heCByYW5nZSlcbiAgICAvLyBGZWVsIGZyZWUgdG8gcmVtb3ZlIGFuZCByZXBsYWNlIHdpdGggYW5vdGhlciBmb3JtIG9mIHZhbGlkYXRpb25cbiAgICAkKHRoaXMub3B0aW9ucy5zY29wZSkub24oJ2NoYW5nZScsICdpbnB1dCcsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQoJHRhcmdldC52YWwoKSwxMCk7XG4gICAgICBjb25zdCBtaW4gPSAkdGFyZ2V0LmF0dHIoJ21pbicpID8gcGFyc2VJbnQoJHRhcmdldC5hdHRyKCdtaW4nKSwxMCkgOiAwO1xuICAgICAgY29uc3QgbWF4ID0gJHRhcmdldC5hdHRyKCdtYXgnKSA/IHBhcnNlSW50KCR0YXJnZXQuYXR0cignbWF4JyksMTApIDogSW5maW5pdHk7XG5cbiAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAvL1RPRE86IEludGVncmF0ZSBBbGVydCBzeXN0ZW1cbiAgICAgICAgY29uc29sZS5lcnJvcihgUXVhbnRpdHkgXCIke3ZhbHVlfVwiIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gbWF4aW11bSAoJHttYXh9KWApO1xuICAgICAgICAkdGFyZ2V0LnZhbCgkdGFyZ2V0LmF0dHIoJ3ZhbHVlJykpO1xuICAgICAgfSBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgUXVhbnRpdHkgdmFsdWUgXCIke3ZhbHVlfVwiIGNhbm5vdCBiZSBsZXNzIHRoYW4gbWluaW11bSAoJHttaW59KWApO1xuICAgICAgICAkdGFyZ2V0LnZhbCgkdGFyZ2V0LmF0dHIoJ3ZhbHVlJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3RXcmFwcGVyIHtcbiAgY29uc3RydWN0b3IoZWwpIHtcbiAgICB0aGlzLiRlbCA9ICQoZWwpO1xuXG4gICAgaWYgKCF0aGlzLiRlbC5wYXJlbnQoJy5mb3JtLXNlbGVjdC13cmFwcGVyJykubGVuZ3RoKSB7XG4gICAgICB0aGlzLiRlbC53cmFwKCc8ZGl2IGNsYXNzPVwiZm9ybS1zZWxlY3Qtd3JhcHBlclwiIC8+JykucGFyZW50KCkucHJlcGVuZChgPHNwYW4gY2xhc3M9XCJzZWxlY3RlZC10ZXh0XCI+JHt0aGlzLiRlbC5maW5kKCdvcHRpb246c2VsZWN0ZWQnKS50ZXh0KCl9PC9zcGFuPmApO1xuICAgIH1cblxuICAgIC8vIENvbmRpdGlvbmFsIHJlcXVpcmVkIHNvIEkgY2FuIHVzZSB0aGUgY3VycmVuY3kgY29kZSBhcyBvcHBvc2VkIHRvXG4gICAgLy8gdGhlIGZ1bGwgY3VycmVuY3kgbmFtZSBpbiB0aGUgY3VycmVuY3kgc3dpdGNoZXJcbiAgICBpZiAoIXRoaXMuJGVsLmNsb3Nlc3QoJy5jdXJyZW5jeS1zd2l0Y2hlcicpLmxlbmd0aCkge1xuICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGVsLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdFRleHQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVNlbGVjdFRleHQob3B0aW9uKSB7XG4gICAgY29uc3QgbmV3T3B0aW9uID0gb3B0aW9uID8gb3B0aW9uIDogdGhpcy4kZWwuZmluZCgnb3B0aW9uOnNlbGVjdGVkJykudGV4dCgpO1xuICAgIHRoaXMuJGVsLnNpYmxpbmdzKCcuc2VsZWN0ZWQtdGV4dCcpLnRleHQobmV3T3B0aW9uKTtcbiAgfVxufVxuIiwiLyoqXG4gKlxuICogRm9ybVZhbGlkYXRvciBkb2VzIG5vdCBjdXJyZW50bHkgZXhpc3QgaW4gdGhlIGNvcmUgZmlsZXMsIGl0IGlzIGJlaW5nXG4gKiBpbXBvcnRlZCBmcm9tIHRoZSB0aGVtZSBzbyB0aGF0IHRoZSBjcmVkaXQgY2FyZCBmb3JtIGNhbiBiZW5lZml0IGZyb20gYmVpbmdcbiAqIHZhbGlkYXRlZC4gTWFrZSBzdXJlIHRoZSBGb3JtVmFsaWRhdG9yIGZpbGUgZXhpc3RzIGluIHRoZSB0aGVtZSBvciB0aGF0IHRoaXNcbiAqIHBhZ2UgaXMgbm90IGNhbGxlZCBpZiBhZGRpbmcgaXQgdG8gdGhlIHRoZW1lIHlvdSBhcmUgd29ya2luZyBvblxuICpcbiAqL1xuXG5pbXBvcnQgUGFnZU1hbmFnZXIgZnJvbSAnLi4vLi4vUGFnZU1hbmFnZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBpbml0QWxlcnREaXNtaXNzYWJsZSBmcm9tICcuL2FsZXJ0RGlzbWlzc2FibGUnO1xuaW1wb3J0IEFsZXJ0IGZyb20gJy4uL2NvbXBvbmVudHMvQWxlcnQnO1xuaW1wb3J0IEZvcm1WYWxpZGF0b3IgZnJvbSAnLi4vdXRpbHMvRm9ybVZhbGlkYXRvcic7XG5pbXBvcnQgaW5pdERvd25sb2FkR2FsbGVyeSBmcm9tICcuL2Rvd25sb2FkR2FsbGVyeSc7XG5pbXBvcnQgdXBkYXRlU3RhdGUgZnJvbSAnLi91cGRhdGVTdGF0ZSc7XG5pbXBvcnQgeyBjcmVkaXRDYXJkVHlwZSwgc3RvcmVJbnN0cnVtZW50LCBWYWxpZGF0b3JzIGFzIENDVmFsaWRhdG9ycywgRm9ybWF0dGVycyBhcyBDQ0Zvcm1hdHRlcnMgfSBmcm9tICcuL2FjY291bnQvcGF5bWVudE1ldGhvZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjY291bnQgZXh0ZW5kcyBQYWdlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBsb2FkZWQobmV4dCkge1xuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgIGNvbnN0ICRwYXltZW50TWV0aG9kRm9ybSA9ICQoJ2Zvcm1bZGF0YS1wYXltZW50LW1ldGhvZC1mb3JtXScpO1xuXG4gICAgaWYgKCRwYXltZW50TWV0aG9kRm9ybS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaW5pdFBheW1lbnRNZXRob2RGb3JtVmFsaWRhdGlvbigkcGF5bWVudE1ldGhvZEZvcm0pO1xuICAgIH1cblxuICAgIHRoaXMucGFnZUFsZXJ0cyA9IG5ldyBBbGVydCgkKCdbZGF0YS1hbGVydHNdJykpO1xuICAgIHRoaXMuVmFsaWRhdG9yID0gbmV3IEZvcm1WYWxpZGF0b3IodGhpcy5jb250ZXh0KTtcbiAgICB0aGlzLlZhbGlkYXRvci5pbml0U2luZ2xlKCQoZG9jdW1lbnQuYm9keSkuZmluZCgnZm9ybVtkYXRhLXBheW1lbnQtbWV0aG9kLWZvcm1dJykpO1xuICAgIHVwZGF0ZVN0YXRlKGZhbHNlLCB0aGlzLnNlbGVjdFdyYXBDYWxsYmFjayk7XG5cbiAgICBuZXh0KCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICBpbml0QWxlcnREaXNtaXNzYWJsZSgpO1xuICAgIGluaXREb3dubG9hZEdhbGxlcnkoKTtcblxuICAgIHVwZGF0ZVN0YXRlKGZhbHNlLCB0aGlzLnNlbGVjdFdyYXBDYWxsYmFjayk7XG5cbiAgICBjb25zdCAkcmVvcmRlckZvcm0gPSAkKCdbZGF0YS1hY2NvdW50LXJlb3JkZXItZm9ybV0nKTtcblxuICAgIGlmICgkcmVvcmRlckZvcm0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluaXRSZW9yZGVyRm9ybSgkcmVvcmRlckZvcm0pO1xuICAgIH1cblxuICAgIC8vIFRvZ2dsZSAtIGEgc2ltcGxlIHdheSB0byB0b2dnbGUgZWxlbWVudHNcbiAgICAkKGRvY3VtZW50LmJvZHkpLm9uKCdjbGljaycsICdbZGF0YS1hY2NvdW50LXRvZ2dsZV0nLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0ICRlbCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICBjb25zdCAkdGFyZ2V0ID0gJCgkZWwuZGF0YSgnYWNjb3VudC10b2dnbGUnKSk7XG4gICAgICAkdGFyZ2V0LnRvZ2dsZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kRGVsZXRlUGF5bWVudE1ldGhvZCgpO1xuICB9XG5cbiAgaW5pdFJlb3JkZXJGb3JtKCRyZW9yZGVyRm9ybSkge1xuICAgICRyZW9yZGVyRm9ybS5vbignc3VibWl0JywgKGV2ZW50KSA9PiB7XG4gICAgICBsZXQgc3VibWl0Rm9ybSA9IGZhbHNlO1xuICAgICAgbGV0ICRwcm9kdWN0UmVvcmRlckNoZWNrYm94ZXMgPSAkKCcuYWNjb3VudC1pdGVtIC5mb3JtLWNoZWNrYm94OmNoZWNrZWQnKTtcblxuICAgICAgJHJlb3JkZXJGb3JtLmZpbmQoJ1tuYW1lXj1cInJlb3JkZXJpdGVtXCJdJykucmVtb3ZlKCk7XG5cbiAgICAgICRwcm9kdWN0UmVvcmRlckNoZWNrYm94ZXMuZWFjaCgoaW5kZXgsIHByb2R1Y3RDaGVja2JveCkgPT4ge1xuICAgICAgICBsZXQgcHJvZHVjdElkID0gJChwcm9kdWN0Q2hlY2tib3gpLnZhbCgpO1xuICAgICAgICBjb25zdCAkaW5wdXQgPSAkKCc8aW5wdXQ+Jywge1xuICAgICAgICAgIHR5cGU6ICdoaWRkZW4nLFxuICAgICAgICAgIG5hbWU6IGByZW9yZGVyaXRlbVske3Byb2R1Y3RJZH1dYCxcbiAgICAgICAgICB2YWx1ZTogJzEnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1Ym1pdEZvcm0gPSB0cnVlO1xuXG4gICAgICAgICRyZW9yZGVyRm9ybS5hcHBlbmQoJGlucHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXN1Ym1pdEZvcm0pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJCgnLmFjY291bnQtdG9vbGJhciAuYWxlcnQtZXJyb3InKS5zaG93KCk7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNhbGxiYWNrIGZpcmVkIHdoZW4gYSBmcmVzaCBzdGF0ZSA8c2VsZWN0PiBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET01cbiAgICovXG4gIHNlbGVjdFdyYXBDYWxsYmFjaygkc2VsZWN0RWwpIHt9IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAqIEJpbmRzIGEgc3VibWl0IGhvb2sgdG8gZW5zdXJlIHRoZSBjdXN0b21lciByZWNlaXZlcyBhIGNvbmZpcm1hdGlvbiBkaWFsb2cgYmVmb3JlIGRlbGV0aW5nIGEgcGF5bWVudCBtZXRob2RcbiAgKi9cbiAgYmluZERlbGV0ZVBheW1lbnRNZXRob2QoKSB7XG4gICAgJCgnW2RhdGEtZGVsZXRlLXBheW1lbnQtbWV0aG9kXScpLm9uKCdzdWJtaXQnLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKCdkZWxldGVQYXltZW50TWV0aG9kJyk7XG5cbiAgICAgIGlmICghd2luZG93LmNvbmZpcm0obWVzc2FnZSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGluaXRQYXltZW50TWV0aG9kRm9ybVZhbGlkYXRpb24oJHBheW1lbnRNZXRob2RGb3JtKSB7XG4gICAgLy8gSW5qZWN0IHZhbGlkYXRpb25zIGludG8gZm9ybSBmaWVsZHMgYmVmb3JlIHZhbGlkYXRpb24gcnVuc1xuICAgICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcjZmlyc3RfbmFtZS5mb3JtLWZpZWxkJykuYXR0cignZGF0YS12YWxpZGF0aW9uJywgYHsgXCJ0eXBlXCI6IFwic2luZ2xlbGluZVwiLCBcImxhYmVsXCI6IFwiJHt0aGlzLmNvbnRleHQuZmlyc3ROYW1lTGFiZWx9XCIsIFwicmVxdWlyZWRcIjogdHJ1ZSwgXCJtYXhsZW5ndGhcIjogMCB9YCk7XG4gICAgJHBheW1lbnRNZXRob2RGb3JtLmZpbmQoJyNsYXN0X25hbWUuZm9ybS1maWVsZCcpLmF0dHIoJ2RhdGEtdmFsaWRhdGlvbicsIGB7IFwidHlwZVwiOiBcInNpbmdsZWxpbmVcIiwgXCJsYWJlbFwiOiBcIiR7dGhpcy5jb250ZXh0Lmxhc3ROYW1lTGFiZWx9XCIsIFwicmVxdWlyZWRcIjogdHJ1ZSwgXCJtYXhsZW5ndGhcIjogMCB9YCk7XG4gICAgJHBheW1lbnRNZXRob2RGb3JtLmZpbmQoJyNjb21wYW55LmZvcm0tZmllbGQnKS5hdHRyKCdkYXRhLXZhbGlkYXRpb24nLCBgeyBcInR5cGVcIjogXCJzaW5nbGVsaW5lXCIsIFwibGFiZWxcIjogXCIke3RoaXMuY29udGV4dC5jb21wYW55TGFiZWx9XCIsIFwicmVxdWlyZWRcIjogZmFsc2UsIFwibWF4bGVuZ3RoXCI6IDAgfWApO1xuICAgICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcjcGhvbmUuZm9ybS1maWVsZCcpLmF0dHIoJ2RhdGEtdmFsaWRhdGlvbicsIGB7IFwidHlwZVwiOiBcInNpbmdsZWxpbmVcIiwgXCJsYWJlbFwiOiBcIiR7dGhpcy5jb250ZXh0LnBob25lTGFiZWx9XCIsIFwicmVxdWlyZWRcIjogZmFsc2UsIFwibWF4bGVuZ3RoXCI6IDAgfWApO1xuICAgICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcjYWRkcmVzczEuZm9ybS1maWVsZCcpLmF0dHIoJ2RhdGEtdmFsaWRhdGlvbicsIGB7IFwidHlwZVwiOiBcInNpbmdsZWxpbmVcIiwgXCJsYWJlbFwiOiBcIiR7dGhpcy5jb250ZXh0LmFkZHJlc3MxTGFiZWx9XCIsIFwicmVxdWlyZWRcIjogdHJ1ZSwgXCJtYXhsZW5ndGhcIjogMCB9YCk7XG4gICAgJHBheW1lbnRNZXRob2RGb3JtLmZpbmQoJyNhZGRyZXNzMi5mb3JtLWZpZWxkJykuYXR0cignZGF0YS12YWxpZGF0aW9uJywgYHsgXCJ0eXBlXCI6IFwic2luZ2xlbGluZVwiLCBcImxhYmVsXCI6IFwiJHt0aGlzLmNvbnRleHQuYWRkcmVzczJMYWJlbH1cIiwgXCJyZXF1aXJlZFwiOiBmYWxzZSwgXCJtYXhsZW5ndGhcIjogMCB9YCk7XG4gICAgJHBheW1lbnRNZXRob2RGb3JtLmZpbmQoJyNjaXR5LmZvcm0tZmllbGQnKS5hdHRyKCdkYXRhLXZhbGlkYXRpb24nLCBgeyBcInR5cGVcIjogXCJzaW5nbGVsaW5lXCIsIFwibGFiZWxcIjogXCIke3RoaXMuY29udGV4dC5jaXR5TGFiZWx9XCIsIFwicmVxdWlyZWRcIjogdHJ1ZSwgXCJtYXhsZW5ndGhcIjogMCB9YCk7XG4gICAgJHBheW1lbnRNZXRob2RGb3JtLmZpbmQoJyNjb3VudHJ5LmZvcm0tZmllbGQnKS5hdHRyKCdkYXRhLXZhbGlkYXRpb24nLCBgeyBcInR5cGVcIjogXCJzaW5nbGVzZWxlY3RcIiwgXCJsYWJlbFwiOiBcIiR7dGhpcy5jb250ZXh0LmNvdW50cnlMYWJlbH1cIiwgXCJyZXF1aXJlZFwiOiB0cnVlLCBwcmVmaXg6IFwiJHt0aGlzLmNvbnRleHQuY2hvb3NlQ291bnRyeUxhYmVsfVwiIH1gKTtcbiAgICAkcGF5bWVudE1ldGhvZEZvcm0uZmluZCgnI3N0YXRlLmZvcm0tZmllbGQnKS5hdHRyKCdkYXRhLXZhbGlkYXRpb24nLCBgeyBcInR5cGVcIjogXCJzaW5nbGVsaW5lXCIsIFwibGFiZWxcIjogXCIke3RoaXMuY29udGV4dC5zdGF0ZUxhYmVsfVwiLCBcInJlcXVpcmVkXCI6IHRydWUsIFwibWF4bGVuZ3RoXCI6IDAgfWApO1xuICAgICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcjcG9zdGFsX2NvZGUuZm9ybS1maWVsZCcpLmF0dHIoJ2RhdGEtdmFsaWRhdGlvbicsIGB7IFwidHlwZVwiOiBcInNpbmdsZWxpbmVcIiwgXCJsYWJlbFwiOiBcIiR7dGhpcy5jb250ZXh0LnBvc3RhbENvZGVMYWJlbH1cIiwgXCJyZXF1aXJlZFwiOiB0cnVlLCBcIm1heGxlbmd0aFwiOiAwIH1gKTtcblxuICAgIGNvbnN0IHBheW1lbnRNZXRob2RTZWxlY3RvciA9ICdmb3JtW2RhdGEtcGF5bWVudC1tZXRob2QtZm9ybV0nO1xuICAgIGNvbnN0ICRzdGF0ZUVsZW1lbnQgPSAkKGAke3BheW1lbnRNZXRob2RTZWxlY3Rvcn0gW2RhdGEtZmllbGQtdHlwZT1cIlN0YXRlXCJdYCk7XG5cbiAgICBsZXQgJGxhc3Q7XG5cbiAgICAvLyBVc2UgY3JlZGl0IGNhcmQgbnVtYmVyIGlucHV0IGxpc3RlbmVyIHRvIGhpZ2hsaWdodCBjcmVkaXQgY2FyZCB0eXBlXG4gICAgJChgJHtwYXltZW50TWV0aG9kU2VsZWN0b3J9IGlucHV0W25hbWU9XCJjcmVkaXRfY2FyZF9udW1iZXJcIl1gKS5vbigna2V5dXAnLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgY29uc3QgY2FyZFR5cGUgPSBjcmVkaXRDYXJkVHlwZSh0YXJnZXQudmFsdWUpO1xuICAgICAgaWYgKGNhcmRUeXBlKSB7XG4gICAgICAgICQoYCR7cGF5bWVudE1ldGhvZFNlbGVjdG9yfSBpbWdbYWx0PVwiJHtjYXJkVHlwZX1cImApLnNpYmxpbmdzKCkuY3NzKCdvcGFjaXR5JywgJy4yJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKGAke3BheW1lbnRNZXRob2RTZWxlY3Rvcn0gaW1nYCkuY3NzKCdvcGFjaXR5JywgJzEnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNldCBvZiBjcmVkaXQgY2FyZCB2YWxpZGF0aW9uXG4gICAgQ0NWYWxpZGF0b3JzLnNldENyZWRpdENhcmROdW1iZXJWYWxpZGF0aW9uKCRwYXltZW50TWV0aG9kRm9ybSwgYCR7cGF5bWVudE1ldGhvZFNlbGVjdG9yfSBpbnB1dFtuYW1lPVwiY3JlZGl0X2NhcmRfbnVtYmVyXCJdYCwgdGhpcy5jb250ZXh0LmNyZWRpdENhcmROdW1iZXIpO1xuICAgIENDVmFsaWRhdG9ycy5zZXRFeHBpcmF0aW9uVmFsaWRhdGlvbigkcGF5bWVudE1ldGhvZEZvcm0sIGAke3BheW1lbnRNZXRob2RTZWxlY3Rvcn0gaW5wdXRbbmFtZT1cImV4cGlyYXRpb25cIl1gLCB0aGlzLmNvbnRleHQuZXhwaXJhdGlvbik7XG4gICAgQ0NWYWxpZGF0b3JzLnNldE5hbWVPbkNhcmRWYWxpZGF0aW9uKCRwYXltZW50TWV0aG9kRm9ybSwgYCR7cGF5bWVudE1ldGhvZFNlbGVjdG9yfSBpbnB1dFtuYW1lPVwibmFtZV9vbl9jYXJkXCJdYCwgdGhpcy5jb250ZXh0Lm5hbWVPbkNhcmQpO1xuICAgIENDVmFsaWRhdG9ycy5zZXRDdnZWYWxpZGF0aW9uKCRwYXltZW50TWV0aG9kRm9ybSwgYCR7cGF5bWVudE1ldGhvZFNlbGVjdG9yfSBpbnB1dFtuYW1lPVwiY3Z2XCJdYCwgdGhpcy5jb250ZXh0LmN2dik7XG5cbiAgICAvLyBTZXQgb2YgY3JlZGl0IGNhcmQgZm9ybWF0XG4gICAgQ0NGb3JtYXR0ZXJzLnNldENyZWRpdENhcmROdW1iZXJGb3JtYXQoYCR7cGF5bWVudE1ldGhvZFNlbGVjdG9yfSBpbnB1dFtuYW1lPVwiY3JlZGl0X2NhcmRfbnVtYmVyXCJdYCk7XG4gICAgQ0NGb3JtYXR0ZXJzLnNldEV4cGlyYXRpb25Gb3JtYXQoYCR7cGF5bWVudE1ldGhvZFNlbGVjdG9yfSBpbnB1dFtuYW1lPVwiZXhwaXJhdGlvblwiYCk7XG5cbiAgICAvLyBCaWxsaW5nIGFkZHJlc3MgdmFsaWRhdGlvblxuICAgICRwYXltZW50TWV0aG9kRm9ybS5vbignc3VibWl0JywgZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0ICRmb3JtSXNWYWxpZCA9ICRwYXltZW50TWV0aG9kRm9ybS5maW5kKCcuZm9ybS1maWVsZC1pbnZhbGlkJykgPiAwID8gZmFsc2UgOiB0cnVlO1xuXG4gICAgICAvLyBQZXJmb3JtIGZpbmFsIGZvcm0gdmFsaWRhdGlvblxuICAgICAgaWYgKCRmb3JtSXNWYWxpZCkge1xuICAgICAgICAvLyBTZXJpYWxpemUgZm9ybSBkYXRhIGFuZCByZWR1Y2UgaXQgdG8gb2JqZWN0XG4gICAgICAgIGNvbnN0IGRhdGEgPSBfLnJlZHVjZSgkcGF5bWVudE1ldGhvZEZvcm0uc2VyaWFsaXplQXJyYXkoKSwgKG9iaiwgaXRlbSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZk9iaiA9IG9iajtcbiAgICAgICAgICByZWZPYmpbaXRlbS5uYW1lXSA9IGl0ZW0udmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHJlZk9iajtcbiAgICAgICAgfSwge30pO1xuXG4gICAgICAgIC8vIEFzc2lnbiBjb3VudHJ5IGFuZCBzdGF0ZSBjb2RlXG4gICAgICAgIGNvbnN0IGNvdW50cnkgPSBfLmZpbmQodGhpcy5jb250ZXh0LmNvdW50cmllcywgKHsgdmFsdWUgfSkgPT4gdmFsdWUgPT09IGRhdGEuY291bnRyeSk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY291bnRyeSAmJiBfLmZpbmQoY291bnRyeS5zdGF0ZXMsICh7IHZhbHVlIH0pID0+IHZhbHVlID09PSBkYXRhLnN0YXRlKTtcbiAgICAgICAgZGF0YS5jb3VudHJ5X2NvZGUgPSBjb3VudHJ5ID8gY291bnRyeS5jb2RlIDogZGF0YS5jb3VudHJ5O1xuICAgICAgICBkYXRhLnN0YXRlX29yX3Byb3ZpbmNlX2NvZGUgPSBzdGF0ZSA/IHN0YXRlLmNvZGUgOiBkYXRhLnN0YXRlO1xuXG4gICAgICAgIC8vIERlZmF1bHQgSW5zdHJ1bWVudFxuICAgICAgICBkYXRhLmRlZmF1bHRfaW5zdHJ1bWVudCA9ICEhZGF0YS5kZWZhdWx0X2luc3RydW1lbnQ7XG5cbiAgICAgICAgLy8gU3RvcmUgY3JlZGl0IGNhcmRcbiAgICAgICAgc3RvcmVJbnN0cnVtZW50KHRoaXMuY29udGV4dCwgZGF0YSwgKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy5jb250ZXh0LnBheW1lbnRNZXRob2RzVXJsO1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wYWdlQWxlcnRzLmVycm9yKHRoaXMuY29udGV4dC5nZW5lcmljX2Vycm9yLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB1cGRhdGVTdGF0ZSBmcm9tICcuL3VwZGF0ZVN0YXRlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWNjb3VudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHVwZGF0ZVN0YXRlKGZhbHNlLCB0aGlzLnNlbGVjdFdyYXBDYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogT3B0aW9uYWwgY2FsbGJhY2sgZmlyZWQgd2hlbiBhIGZyZXNoIHN0YXRlIDxzZWxlY3Q+IGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTVxuICAgKi9cbiAgc2VsZWN0V3JhcENhbGxiYWNrKCRzZWxlY3RFbCkge30gLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIFBhZ2UgTWFuYWdlclxuICBsb2FkZWQoKSB7fVxuICBiZWZvcmUoKSB7fVxuICBhZnRlcigpIHt9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBHaWZ0Q2VydGlmaWNhdGUge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgdGhpcy4kcHVyY2hhc2VGb3JtID0gJCgnW2RhdGEtZ2lmdGNhcmQtcHVyY2hhc2UtZm9ybV0nKTtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRwdXJjaGFzZUZvcm0ub24oJ2NoYW5nZScsICgpID0+IHtcbiAgICAgIGlmICgkKCcjZ2lmdGNhcmQtYW1vdW50JykudmFsKCkgIT0gXCJcIikge1xuICAgICAgICB0aGlzLl9zaG93UHJldmlldygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy4kcHVyY2hhc2VGb3JtLmZpbmQoJ1tkYXRhLW5vLXJlZnJlc2hdJykub24oJ2NoYW5nZScsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBvciB1cGRhdGUgdGhlIGdpZnRjYXJkIHByZXZpZXcuXG4gICAqL1xuICBfc2hvd1ByZXZpZXcoKSB7XG4gICAgY29uc3QgJHRoZW1lID0gdGhpcy4kcHVyY2hhc2VGb3JtLmZpbmQoJ1tkYXRhLWdpZnRjYXJkLXRoZW1lXScpO1xuXG4gICAgLy8gT25seSBzaG93IGEgcHJldmlldyBpZiBhIHRoZW1lIGlzIHNlbGVjdGVkXG4gICAgaWYgKCEkdGhlbWUuZmluZCgnLmZvcm0taW5wdXQ6Y2hlY2tlZCcpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBwcmV2aWV3IFVSTCBiYXNlZCBvbiBmb3JtIHN0YXRlXG4gICAgY29uc3QgYmFzZVVybCA9ICR0aGVtZS5kYXRhKCdnaWZ0Y2FyZC1wcmV2aWV3LXVybCcpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiRwdXJjaGFzZUZvcm0uc2VyaWFsaXplKCk7XG4gICAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0mJHtkYXRhfWA7XG5cbiAgICAvLyBDcmVhdGUgcHJldmlld1xuICAgIGNvbnN0ICRwcmV2aWV3ID0gJCgnPGlmcmFtZT4nLCB7XG4gICAgICBzcmM6IHVybCxcbiAgICB9KS5vbignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgLy8gQ2FsY3VsYXRlIGlmcmFtZSBoZWlnaHQgYmFzZWQgb24gaXRzIGRvY3VtZW50IGhlaWdodFxuICAgICAgY29uc3QgaGVpZ2h0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0LmNvbnRlbnREb2N1bWVudCkuaGVpZ2h0KCk7XG4gICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmhlaWdodChoZWlnaHQpO1xuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHByZXZpZXdcbiAgICAkdGhlbWUuZmluZCgnLmdpZnRjYXJkLWZvcm0tcHJldmlldycpXG4gICAgICAuYWRkQ2xhc3MoJ2hhcy1wcmV2aWV3JylcbiAgICAgIC5odG1sKCRwcmV2aWV3KTtcbiAgfVxuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBQYWdlIE1hbmFnZXJcbiAgbG9hZGVkKCkge31cbiAgYmVmb3JlKCkge31cbiAgYWZ0ZXIoKSB7fVxufVxuIiwiaW1wb3J0IGNyZWRpdGNhcmRzIGZyb20gJ2NyZWRpdGNhcmRzJztcblxuLyoqXG4gKiBPbWl0IG51bGwgb3IgZW1wdHkgc3RyaW5nIHByb3BlcnRpZXMgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG4gY29uc3Qgb21pdE51bGxTdHJpbmcgPSBvYmogPT4ge1xuICAgY29uc3QgcmVmT2JqID0gb2JqO1xuXG4gICAkLmVhY2gocmVmT2JqLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgZGVsZXRlIHJlZk9ialtrZXldO1xuICAgICB9XG4gICB9KTtcblxuICAgcmV0dXJuIHJlZk9iajtcbiB9O1xuXG4vKipcbiAqIEdldCBjcmVkaXQgY2FyZCB0eXBlIGZyb20gY3JlZGl0IGNhcmQgbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWRpdENhcmRUeXBlID0gdmFsdWUgPT4gY3JlZGl0Y2FyZHMuY2FyZC50eXBlKGNyZWRpdGNhcmRzLmNhcmQucGFyc2UodmFsdWUpLCB0cnVlKTtcblxuLyoqXG4gKiBXcmFwcGVyIGZvciBhamF4IHJlcXVlc3QgdG8gc3RvcmUgYSBuZXcgaW5zdHJ1bWVudCBpbiBiaWdwYXlcbiAqIEBwYXJhbSB7b2JqZWN0fSBSZXByZXNlbnRpbmcgdGhlIGRhdGEgbmVlZGVkIGZvciB0aGUgaGVhZGVyXG4gKiBAcGFyYW0ge29iamVjdH0gUmVwcmVzZW50aW5nIHRoZSBkYXRhIG5lZWRlZCBmb3IgdGhlIGJvZHlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhaWwgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBhIHVuc3VjY2Vzc2Z1bCByZXNwb25zZVxuICovXG5leHBvcnQgY29uc3Qgc3RvcmVJbnN0cnVtZW50ID0gKHtcbiAgLy8gSG9zdG5hbWUsIElkcyAmIFRva2VuXG4gIHBheW1lbnRzVXJsLFxuICBzaG9wcGVySWQsXG4gIHN0b3JlSGFzaCxcbiAgdmF1bHRUb2tlbixcbn0sIHtcbiAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgLy8gUHJvdmlkZXIgSW5mb1xuICBwcm92aWRlcl9pZCxcbiAgY3VycmVuY3lfY29kZSxcbiAgIC8vIEluc3RydW1lbnQgRGV0YWlsc1xuICBjcmVkaXRfY2FyZF9udW1iZXIsXG4gIGV4cGlyYXRpb24sXG4gIG5hbWVfb25fY2FyZCxcbiAgY3Z2LFxuICBkZWZhdWx0X2luc3RydW1lbnQsXG4gICAvLyBCaWxsaW5nIEFkZHJlc3NcbiAgYWRkcmVzczEsXG4gIGFkZHJlc3MyLFxuICBjaXR5LFxuICBwb3N0YWxfY29kZSxcbiAgc3RhdGVfb3JfcHJvdmluY2VfY29kZSxcbiAgY291bnRyeV9jb2RlLFxuICBjb21wYW55LFxuICBmaXJzdF9uYW1lLFxuICBsYXN0X25hbWUsXG4gIGVtYWlsLFxuICBwaG9uZSxcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xufSwgZG9uZSwgZmFpbCkgPT4ge1xuICBjb25zdCBleHBpcnkgPSBleHBpcmF0aW9uLnNwbGl0KCcvJyk7XG5cbiAgJC5hamF4KHtcbiAgICB1cmw6IGAke3BheW1lbnRzVXJsfS9zdG9yZXMvJHtzdG9yZUhhc2h9L2N1c3RvbWVycy8ke3Nob3BwZXJJZH0vc3RvcmVkX2luc3RydW1lbnRzYCxcbiAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGNhY2hlOiBmYWxzZSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBdXRob3JpemF0aW9uOiB2YXVsdFRva2VuLFxuICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vdm5kLmJjLnYxK2pzb24nLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi92bmQuYmMudjEranNvbicsXG4gICAgfSxcbiAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBpbnN0cnVtZW50OiB7XG4gICAgICAgIHR5cGU6ICdjYXJkJyxcbiAgICAgICAgY2FyZGhvbGRlcl9uYW1lOiBuYW1lX29uX2NhcmQsXG4gICAgICAgIG51bWJlcjogY3JlZGl0Y2FyZHMuY2FyZC5wYXJzZShjcmVkaXRfY2FyZF9udW1iZXIpLFxuICAgICAgICBleHBpcnlfbW9udGg6IGNyZWRpdGNhcmRzLmV4cGlyYXRpb24ubW9udGgucGFyc2UoZXhwaXJ5WzBdKSxcbiAgICAgICAgZXhwaXJ5X3llYXI6IGNyZWRpdGNhcmRzLmV4cGlyYXRpb24ueWVhci5wYXJzZShleHBpcnlbMV0sIHRydWUpLFxuICAgICAgICB2ZXJpZmljYXRpb25fdmFsdWU6IGN2dixcbiAgICAgIH0sXG4gICAgICBiaWxsaW5nX2FkZHJlc3M6IG9taXROdWxsU3RyaW5nKHtcbiAgICAgICAgYWRkcmVzczEsXG4gICAgICAgIGFkZHJlc3MyLFxuICAgICAgICBjaXR5LFxuICAgICAgICBwb3N0YWxfY29kZSxcbiAgICAgICAgc3RhdGVfb3JfcHJvdmluY2VfY29kZSxcbiAgICAgICAgY291bnRyeV9jb2RlLFxuICAgICAgICBjb21wYW55LFxuICAgICAgICBmaXJzdF9uYW1lLFxuICAgICAgICBsYXN0X25hbWUsXG4gICAgICAgIGVtYWlsLFxuICAgICAgICBwaG9uZSxcbiAgICAgIH0pLFxuICAgICAgcHJvdmlkZXJfaWQsXG4gICAgICBkZWZhdWx0X2luc3RydW1lbnQsXG4gICAgICBjdXJyZW5jeV9jb2RlLFxuICAgIH0pLFxuICB9KVxuICAgIC5kb25lKGRvbmUpXG4gICAgLmZhaWwoZmFpbCk7XG59O1xuXG5leHBvcnQgY29uc3QgRm9ybWF0dGVycyA9IHtcbiAgLyoqXG4gICAqIFNldHMgdXAgYSBmb3JtYXQgZm9yIGNyZWRpdCBjYXJkIG51bWJlclxuICAgKiBAcGFyYW0gZmllbGRcbiAgICovXG4gIHNldENyZWRpdENhcmROdW1iZXJGb3JtYXQ6IGZpZWxkID0+IHtcbiAgICBpZiAoZmllbGQpIHtcbiAgICAgICQoZmllbGQpLm9uKCdrZXl1cCcsICh7IHRhcmdldCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZlRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgcmVmVGFyZ2V0LnZhbHVlID0gY3JlZGl0Y2FyZHMuY2FyZC5mb3JtYXQoY3JlZGl0Y2FyZHMuY2FyZC5wYXJzZSh0YXJnZXQudmFsdWUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB1cCBhIGZvcm1hdCBmb3IgZXhwaXJhdGlvbiBkYXRlXG4gICAqIEBwYXJhbSBmaWVsZFxuICAgKi9cbiAgc2V0RXhwaXJhdGlvbkZvcm1hdDogZmllbGQgPT4ge1xuICAgIGlmIChmaWVsZCkge1xuICAgICAgJChmaWVsZCkub24oJ2tleXVwJywgKHsgdGFyZ2V0LCB3aGljaCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZlRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgaWYgKHdoaWNoID09PSA4ICYmIC8uKihcXC8pJC8udGVzdCh0YXJnZXQudmFsdWUpKSB7XG4gICAgICAgICAgcmVmVGFyZ2V0LnZhbHVlID0gdGFyZ2V0LnZhbHVlLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQudmFsdWUubGVuZ3RoID4gNCkge1xuICAgICAgICAgIHJlZlRhcmdldC52YWx1ZSA9IHRhcmdldC52YWx1ZS5zbGljZSgwLCA1KTtcbiAgICAgICAgfSBlbHNlIGlmICh3aGljaCAhPT0gOCkge1xuICAgICAgICAgIHJlZlRhcmdldC52YWx1ZSA9IHRhcmdldC52YWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UoL14oWzEtOV1cXC98WzItOV0pJC9nLCAnMCQxLycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXigwWzEtOV18MVswLTJdKSQvZywgJyQxLycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXihbMC0xXSkoWzMtOV0pJC9nLCAnMCQxLyQyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eKDBbMS05XXwxWzAtMl0pKFswLTldezJ9KSQvZywgJyQxLyQyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eKFswXSspXFwvfFswXSskL2csICcwJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxcZFxcL118XltcXC9dKiQvZywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvXFwvL2csICcvJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBWYWxpZGF0b3JzID0ge1xuICAvKipcbiAgICogU2V0cyB1cCBhIHZhbGlkYXRpb24gZm9yIGNyZWRpdCBjYXJkIG51bWJlclxuICAgKiBAcGFyYW0gdmFsaWRhdG9yXG4gICAqIEBwYXJhbSBmaWVsZFxuICAgKi9cbiAgc2V0Q3JlZGl0Q2FyZE51bWJlclZhbGlkYXRpb246ICh2YWxpZGF0b3IsIGZpZWxkLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIHZhbGlkYXRvci5hZGQoe1xuICAgICAgICBzZWxlY3RvcjogZmllbGQsXG4gICAgICAgIHZhbGlkYXRlOiAoY2IsIHZhbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbC5sZW5ndGggJiYgY3JlZGl0Y2FyZHMuY2FyZC5pc1ZhbGlkKGNyZWRpdGNhcmRzLmNhcmQucGFyc2UodmFsKSk7XG5cbiAgICAgICAgICBjYihyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB1cCBhIHZhbGlkYXRpb24gZm9yIGV4cGlyYXRpb24gZGF0ZVxuICAgKiBAcGFyYW0gdmFsaWRhdG9yXG4gICAqIEBwYXJhbSBmaWVsZFxuICAgKi9cbiAgc2V0RXhwaXJhdGlvblZhbGlkYXRpb246ICh2YWxpZGF0b3IsIGZpZWxkLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIHZhbGlkYXRvci5hZGQoe1xuICAgICAgICBzZWxlY3RvcjogZmllbGQsXG4gICAgICAgIHZhbGlkYXRlOiAoY2IsIHZhbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV4cGlyeSA9IHZhbC5zcGxpdCgnLycpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSB2YWwubGVuZ3RoICYmIC9eKDBbMS05XXwxWzAtMl0pXFwvKFswLTldezJ9KSQvLnRlc3QodmFsKTtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgIWNyZWRpdGNhcmRzLmV4cGlyYXRpb24uaXNQYXN0KGNyZWRpdGNhcmRzLmV4cGlyYXRpb24ubW9udGgucGFyc2UoZXhwaXJ5WzBdKSwgY3JlZGl0Y2FyZHMuZXhwaXJhdGlvbi55ZWFyLnBhcnNlKGV4cGlyeVsxXSwgdHJ1ZSkpO1xuXG4gICAgICAgICAgY2IocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgdmFsaWRhdGlvbiBmb3IgbmFtZSBvbiBjYXJkXG4gICAqIEBwYXJhbSB2YWxpZGF0b3JcbiAgICogQHBhcmFtIGZpZWxkXG4gICAqL1xuICBzZXROYW1lT25DYXJkVmFsaWRhdGlvbjogKHZhbGlkYXRvciwgZmllbGQsIGVycm9yTWVzc2FnZSkgPT4ge1xuICAgIGlmIChmaWVsZCkge1xuICAgICAgdmFsaWRhdG9yLmFkZCh7XG4gICAgICAgIHNlbGVjdG9yOiBmaWVsZCxcbiAgICAgICAgdmFsaWRhdGU6IChjYiwgdmFsKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gISF2YWwubGVuZ3RoO1xuXG4gICAgICAgICAgY2IocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgdmFsaWRhdGlvbiBmb3IgY3Z2XG4gICAqIEBwYXJhbSB2YWxpZGF0b3JcbiAgICogQHBhcmFtIGZpZWxkXG4gICAqL1xuICBzZXRDdnZWYWxpZGF0aW9uOiAodmFsaWRhdG9yLCBmaWVsZCwgZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICB2YWxpZGF0b3IuYWRkKHtcbiAgICAgICAgc2VsZWN0b3I6IGZpZWxkLFxuICAgICAgICB2YWxpZGF0ZTogKGNiLCB2YWwpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWwubGVuZ3RoICYmIGNyZWRpdGNhcmRzLmN2Yy5pc1ZhbGlkKHZhbCk7XG5cbiAgICAgICAgICBjYihyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG59O1xuIiwiaW1wb3J0ICdqcXVlcnktdHJlbmQnO1xuXG4vKipcbiAqIENvcmUgQWxlcnQgY29tcG9uZW50cyBjYW4gYmUgbG9hZGVkIHdpdGggYSBgZGlzbWlzc2FibGVgIHBhcmFtLiBJZiB0aGlzXG4gKiBpcyB0cnVlLCBhbiBhbGVydC1kaXNtaXNzIGJ1dHRvbiBpcyBpbmNsdWRlZCBpbiB0aGUgbWFya3VwLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgYWxlcnQgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpc21pc3NhYmxlKCkge1xuICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5hbGVydC1kaXNtaXNzJywgKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0ICRhbGVydCA9ICR0YXJnZXQucGFyZW50KCcuYWxlcnQnKTtcblxuICAgICRhbGVydC5vbmUoJ3RyZW5kJywgKCkgPT4ge1xuICAgICAgJGFsZXJ0LnJlbW92ZSgpO1xuICAgIH0pO1xuXG4gICAgJGFsZXJ0LmFkZENsYXNzKCdkaXNtaXNzZWQnKTtcbiAgfSk7XG59XG4iLCIvKipcbiAqICBBbGVydHNcbiAqXG4gKiAgVXRpbGl0eSBtb2R1bGUgdG8gZGlzcGxheSBzdGF0dXMgbWVzc2FnZXMgZm9yIGNvbXBvbmVudHMuXG4gKiAgSW5zdGFudGlhdGUgQ2xhc3M6IG5ldyBBbGVydCgpXG4gKlxuICogIEBhcmcgJGVsICAgICAgIGpRdWVyeSBvYmplY3RcbiAqICAgIFRoZSBzcGVjaWZpYyBlbGVtZW50IHRoYXQgd2lsbCBob2xkIG5ldyBhbGVydCBtZXNzYWdlcy5cbiAqXG4gKiAgQGFyZyBvcHRpb25zICBPYmplY3RcbiAqICBBbiBvYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBtb2R1bGUuIChzZWUgYmVsb3cpXG4gKi9cblxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB0cmVuZCBmcm9tICdqcXVlcnktdHJlbmQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbGVydCB7XG4gIGNvbnN0cnVjdG9yKCRlbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICB0aGlzLiRlbCA9ICRlbDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgIGJhc2U6ICdhbGVydCcsXG4gICAgICAgIGVycm9yOiAnYWxlcnQtZXJyb3InLFxuICAgICAgICBpbmZvOiAnYWxlcnQtaW5mbycsXG4gICAgICAgIHN1Y2Nlc3M6ICdhbGVydC1zdWNjZXNzJyxcbiAgICAgIH0sXG4gICAgICBsaW1pdDogMSxcbiAgICAgIHRlbXBsYXRlOiB7fSxcbiAgICAgIGNhbGxiYWNrczoge30sXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmNhbGxiYWNrcyA9ICQuZXh0ZW5kKHtcbiAgICAgIHdpbGxVcGRhdGU6ICgpID0+IHt9LFxuICAgICAgZGlkVXBkYXRlOiAoKSA9PiB7fSxcbiAgICB9LCBvcHRpb25zLmNhbGxiYWNrcyk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICBpZiAoXy5pc0VtcHR5KHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZW1wbGF0ZSA9IF8udGVtcGxhdGUoYFxuICAgICAgICA8ZGl2IGNsYXNzPScke3RoaXMub3B0aW9ucy5jbGFzc2VzLmJhc2V9IDwlPSBtZXNzYWdlVHlwZSAlPic+XG4gICAgICAgICAgPCUgaWYgKGlzRGlzbWlzc2FibGUpIHsgJT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiYWxlcnQtZGlzbWlzc1wiPlxuICAgICAgICAgICAgICA8c3ZnIGNsYXNzPVwiaWNvbi14XCIgd2lkdGg9XCIxMVwiIGhlaWdodD1cIjExXCIgdmlld0JveD1cIjAgMCAxMSAxMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZD1cIk0uMzY3LjkzM2w5LjIgOS4yYy4xNTYuMTU2LjQxLjE1Ni41NjYgMCAuMTU2LS4xNTYuMTU2LS40MSAwLS41NjZsLTkuMi05LjJDLjc3Ny4yMS41MjMuMjEuMzY3LjM2Ny4yMS41MjMuMjEuNzc3LjM2Ny45MzN6bTkuMi0uNTY2bC05LjIgOS4yYy0uMTU2LjE1Ni0uMTU2LjQxIDAgLjU2Ni4xNTYuMTU2LjQxLjE1Ni41NjYgMGw5LjItOS4yYy4xNTYtLjE1Ni4xNTYtLjQxIDAtLjU2Ni0uMTU2LS4xNTYtLjQxLS4xNTYtLjU2NiAwelwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIiBmaWxsPVwiY3VycmVudENvbG9yXCIvPlxuICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICA8JSB9ICU+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LW1lc3NhZ2VcIj5cbiAgICAgICAgICAgIDwlPSBtZXNzYWdlVGV4dCAlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGApO1xuICAgIH1cblxuICAgIHRoaXMuJGVsLm9uKCdjbGljaycsICcuYWxlcnQtZGlzbWlzcycsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0ICRhbGVydCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkucGFyZW50KCcuYWxlcnQnKTtcbiAgICAgIHRoaXMuX2Rpc21pc3NNZXNzYWdlKCRhbGVydCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRlbC5vbignY2xlYXItbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gcmVzZXQgdGhlIGNvbnRlbnRzIG9mIHRoaXMuJGVsXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLiRlbC5maW5kKGAuJHt0aGlzLm9wdGlvbnMuY2xhc3Nlcy5iYXNlfWApLmVhY2goKGluZGV4LCB0YXJnZXQpID0+IHtcbiAgICAgIHRoaXMuX2Rpc21pc3NNZXNzYWdlKCQodGFyZ2V0KSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSWYgYmMtY29yZSBiZWNvbWVzIGludGVncmF0ZWQgaW50byBiYy1za2VsZXRvbiwgdGhpcyBtZXRob2Qgc2hvdWxkIGRlbGVnYXRlIHRvIGBkaXNtaXNzYWJsZSgpYFxuICAgKiBAcGFyYW0gJGFsZXJ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGlzbWlzc01lc3NhZ2UoJGFsZXJ0KSB7XG4gICAgJGFsZXJ0LmFkZENsYXNzKCdkaXNtaXNzZWQnKTtcbiAgICAkYWxlcnQub25lKCd0cmVuZCcsICgpID0+IHtcbiAgICAgICRhbGVydC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsaWNpdCB1c2FnZSB0byBjcmVhdGUgYW4gZXJyb3IgYWxlcnRcbiAgICogQHBhcmFtIHRleHRcbiAgICogQHBhcmFtIGRpc21pc3NhYmxlXG4gICAqL1xuICBlcnJvcih0ZXh0LCBkaXNtaXNzYWJsZSA9IGZhbHNlKXtcbiAgICB0aGlzLm1lc3NhZ2UodGV4dCwgJ2Vycm9yJywgZGlzbWlzc2FibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxpY2l0IHVzYWdlIHRvIGNyZWF0ZSBhIHN1Y2Nlc3MgYWxlcnRcbiAgICogQHBhcmFtIHRleHRcbiAgICogQHBhcmFtIGRpc21pc3NhYmxlXG4gICAqL1xuICBzdWNjZXNzKHRleHQsIGRpc21pc3NhYmxlID0gZmFsc2Upe1xuICAgIHRoaXMubWVzc2FnZSh0ZXh0LCAnc3VjY2VzcycsIGRpc21pc3NhYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsaWNpdCB1c2FnZSB0byBjcmVhdGUgYW4gaW5mb3JtYXRpb25hbCBhbGVydFxuICAgKiBAcGFyYW0gdGV4dFxuICAgKiBAcGFyYW0gZGlzbWlzc2FibGVcbiAgICovXG4gIGluZm8odGV4dCwgZGlzbWlzc2FibGUgPSBmYWxzZSl7XG4gICAgdGhpcy5tZXNzYWdlKHRleHQsICdpbmZvJywgZGlzbWlzc2FibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBwYXJhbSB0eXBlXG4gICAqIEBwYXJhbSBkaXNtaXNzYWJsZVxuICAgKi9cbiAgbWVzc2FnZSh0ZXh0LCB0eXBlID0gJ2luZm8nLCBkaXNtaXNzYWJsZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSh0aGlzLiRlbCk7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5saW1pdCA9PT0gJ251bWJlcicgJiYgdGhpcy4kZWwuZmluZChgLiR7dGhpcy5vcHRpb25zLmNsYXNzZXMuYmFzZX1gKS5sZW5ndGggPiB0aGlzLm9wdGlvbnMubGltaXQpIHtcbiAgICAgIHRoaXMuX2Rpc21pc3NNZXNzYWdlKHRoaXMuJGVsLmZpbmQoYC4ke3RoaXMub3B0aW9ucy5jbGFzc2VzLmJhc2V9Om5vdCguZGlzbWlzc2VkKWApLmVxKDApKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgbWVzc2FnZVR5cGU6IHRoaXMub3B0aW9ucy5jbGFzc2VzW3R5cGVdLFxuICAgICAgbWVzc2FnZVRleHQ6IHRleHQsXG4gICAgICBpc0Rpc21pc3NhYmxlOiBkaXNtaXNzYWJsZSxcbiAgICB9O1xuXG4gICAgY29uc3QgJGFsZXJ0ID0gdGhpcy4kZWwuYXBwZW5kKHRoaXMub3B0aW9ucy50ZW1wbGF0ZShtZXNzYWdlKSk7XG5cbiAgICB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUoJGFsZXJ0LCB0aGlzLiRlbCk7XG4gIH1cbn1cbiIsImltcG9ydCB1dGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XG5pbXBvcnQgQW1wQWxlcnQgZnJvbSAnLi9BbXBBbGVydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2R1Y3RVdGlscyB7XG4gIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuJGJvZHkgPSAkKGRvY3VtZW50LmJvZHkpO1xuICAgIHRoaXMucHJvZHVjdElkID0gdGhpcy4kZWwuZmluZCgnW2RhdGEtcHJvZHVjdC1pZF0nKS52YWwoKTtcblxuICAgIC8vIGNsYXNzIHRvIGFkZCBvciByZW1vdmUgZnJvbSBjYXJ0LWFkZCBidXR0b24gZGVwZW5kaW5nIG9uIHZhcmlhdGlvbiBhdmFpbGFiaWxpdHlcbiAgICB0aGlzLmJ1dHRvbkRpc2FibGVkQ2xhc3MgPSAnYnV0dG9uLWRpc2FibGVkJztcblxuICAgIC8vIHR3byBhbGVydCBsb2NhdGlvbnMgYmFzZWQgb24gYWN0aW9uXG4gICAgdGhpcy5jYXJ0QWRkQWxlcnQgPSBuZXcgQW1wQWxlcnQodGhpcy4kYm9keS5maW5kKCdbZGF0YS1wcm9kdWN0LWNhcnQtbWVzc2FnZV0nKSk7XG4gICAgdGhpcy5jYXJ0T3B0aW9uQWxlcnQgPSBuZXcgQW1wQWxlcnQodGhpcy4kZWwuZmluZCgnW2RhdGEtcHJvZHVjdC1vcHRpb24tbWVzc2FnZV0nKSk7XG5cbiAgICB0aGlzLmNhbGxiYWNrcyA9ICQuZXh0ZW5kKHtcbiAgICAgIHdpbGxVcGRhdGU6ICgpID0+IHt9LFxuICAgICAgZGlkVXBkYXRlOiAoKSA9PiB7fSxcbiAgICB9LCBvcHRpb25zLmNhbGxiYWNrcyk7XG4gIH1cblxuICBpbml0KGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX2JpbmRQcm9kdWN0T3B0aW9uQ2hhbmdlKCk7XG5cbiAgICB0aGlzLl9ib3VuZENhcnRDYWxsYmFjayA9IHRoaXMuX2JpbmRDYXJ0QWRkLmJpbmQodGhpcyk7XG4gICAgdXRpbHMuaG9va3Mub24oJ2NhcnQtaXRlbS1hZGQnLCB0aGlzLl9ib3VuZENhcnRDYWxsYmFjayk7XG5cbiAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKHdpbmRvdy5CQ0RhdGEucHJvZHVjdF9hdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWNoZSBhbiBvYmplY3Qgb2YgalF1ZXJ5IGVsZW1lbnRzIGZvciBET00gdXBkYXRpbmdcbiAgICogQHBhcmFtICBqUXVlcnkgJGVsIC0gYSB3cmFwcGluZyBlbGVtZW50IG9mIHRoZSBzY29wZWQgcHJvZHVjdFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gYnVuY2hhIGpRdWVyeSBlbGVtZW50cyB3aGljaCBtYXkgb3IgbWF5IG5vdCBleGlzdCBvbiB0aGUgcGFnZVxuICAgKi9cbiAgX2dldFZpZXdNb2RlbCgkZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJGFkZFRvQ2FydDogJCgnW2RhdGEtYnV0dG9uLXB1cmNoYXNlXScsICRlbCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIHByb2R1Y3Qgb3B0aW9ucyBjaGFuZ2VzLlxuICAgKi9cbiAgX2JpbmRQcm9kdWN0T3B0aW9uQ2hhbmdlKCkge1xuICAgIHV0aWxzLmhvb2tzLm9uKCdwcm9kdWN0LW9wdGlvbi1jaGFuZ2UnLCAoZXZlbnQsIGNoYW5nZWRPcHRpb24pID0+IHtcbiAgICAgIGNvbnN0ICRjaGFuZ2VkT3B0aW9uID0gJChjaGFuZ2VkT3B0aW9uKTtcbiAgICAgIGNvbnN0ICRmb3JtID0gJGNoYW5nZWRPcHRpb24ucGFyZW50cygnZm9ybScpO1xuXG4gICAgICAvLyBEbyBub3QgdHJpZ2dlciBhbiBhamF4IHJlcXVlc3QgaWYgaXQncyBhIGZpbGUgb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IEZvcm1EYXRhXG4gICAgICBpZiAoJGNoYW5nZWRPcHRpb24uYXR0cigndHlwZScpID09PSAnZmlsZScgfHwgd2luZG93LkZvcm1EYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhcnRBZGRBbGVydC5jbGVhcigpO1xuICAgICAgdGhpcy5jYXJ0T3B0aW9uQWxlcnQuY2xlYXIoKTtcblxuICAgICAgLy8gcHJvZHVjdCB0ZW1wbGF0ZSBzaG91bGQgYmUgcGFzc2VkIGFzIGEgc3RyaW5nXG4gICAgICBjb25zdCBwcm9kdWN0VGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy50ZW1wbGF0ZSA9PT0gJ3N0cmluZycgPyB0aGlzLm9wdGlvbnMudGVtcGxhdGUgOiBudWxsO1xuXG4gICAgICB1dGlscy5hcGkucHJvZHVjdEF0dHJpYnV0ZXMub3B0aW9uQ2hhbmdlKHRoaXMucHJvZHVjdElkLCAkZm9ybS5zZXJpYWxpemUoKSwgcHJvZHVjdFRlbXBsYXRlLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCB2aWV3TW9kZWwgPSB0aGlzLl9nZXRWaWV3TW9kZWwodGhpcy4kZWwpO1xuICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UgPyByZXNwb25zZS5kYXRhIDoge307XG5cbiAgICAgICAgLy8gSWYgb3VyIGZvcm0gZGF0YSBkb2Vzbid0IGluY2x1ZGUgdGhlIHByb2R1Y3Qtb3B0aW9ucy1jb3VudCB3aXRoIGEgcG9zaXRpdmUgdmFsdWUsIHJldHVyblxuICAgICAgICBpZiAodGhpcy4kZWwuZmluZCgnW2RhdGEtcHJvZHVjdC1vcHRpb25zLWNvdW50XScpLnZhbCA8IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKGRhdGEpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBzdWJtaXQgYnV0dG9uIHN0YXRlXG4gICAgICAgIGlmICghZGF0YS5wdXJjaGFzYWJsZSB8fCAhZGF0YS5pbnN0b2NrKSB7XG4gICAgICAgICAgdGhpcy5jYXJ0T3B0aW9uQWxlcnQuZXJyb3IoZGF0YS5wdXJjaGFzaW5nX21lc3NhZ2UpO1xuICAgICAgICAgIHZpZXdNb2RlbC4kYWRkVG9DYXJ0XG4gICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5idXR0b25EaXNhYmxlZENsYXNzKVxuICAgICAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlld01vZGVsLiRhZGRUb0NhcnRcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmJ1dHRvbkRpc2FibGVkQ2xhc3MpXG4gICAgICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFuZCB1cGRhdGUgcXVhbnRpdHkgaW5wdXQgdmFsdWVcbiAgICovXG4gIF91cGRhdGVRdWFudGl0eShldmVudCkge1xuICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0ICRxdWFudGl0eSA9ICR0YXJnZXQuY2xvc2VzdCgnW2RhdGEtcHJvZHVjdC1xdWFudGl0eV0nKS5maW5kKCdbZGF0YS1xdWFudGl0eS1jb250cm9sLWlucHV0XScpO1xuICAgIGNvbnN0IG1pbiA9IHBhcnNlSW50KCRxdWFudGl0eS5wcm9wKCdtaW4nKSwgMTApO1xuICAgIGNvbnN0IG1heCA9IHBhcnNlSW50KCRxdWFudGl0eS5wcm9wKCdtYXgnKSwgMTApO1xuICAgIGxldCBuZXdRdWFudGl0eSA9IHBhcnNlSW50KCRxdWFudGl0eS52YWwoKSwgMTApO1xuXG4gICAgaWYgKGlzTmFOKG5ld1F1YW50aXR5KSkge1xuICAgICAgbmV3UXVhbnRpdHkgPSBtaW47XG4gICAgfVxuXG4gICAgaWYgKCR0YXJnZXQuaXMoJ1tkYXRhLXF1YW50aXR5LWluY3JlbWVudF0nKSAmJiAoIW1heCB8fCBuZXdRdWFudGl0eSA8IG1heCkpIHtcbiAgICAgIG5ld1F1YW50aXR5ID0gbmV3UXVhbnRpdHkgKyAxO1xuICAgIH0gZWxzZSBpZiAoJHRhcmdldC5pcygnW2RhdGEtcXVhbnRpdHktZGVjcmVtZW50XScpICYmIG5ld1F1YW50aXR5ID4gbWluKSB7XG4gICAgICBuZXdRdWFudGl0eSA9IG5ld1F1YW50aXR5IC0gMTtcbiAgICB9XG5cbiAgICAkcXVhbnRpdHkudmFsKG5ld1F1YW50aXR5KTtcbiAgfVxuXG4gIF91cGRhdGVBdHRyaWJ1dGVzKGRhdGEpIHtcbiAgICBjb25zdCBiZWhhdmlvciA9IGRhdGEub3V0X29mX3N0b2NrX2JlaGF2aW9yO1xuICAgIGNvbnN0IGluU3RvY2tJZHMgPSBkYXRhLmluX3N0b2NrX2F0dHJpYnV0ZXM7XG4gICAgY29uc3Qgb3V0T2ZTdG9ja01lc3NhZ2UgPSBgICgke2RhdGEub3V0X29mX3N0b2NrX21lc3NhZ2V9KWA7XG5cbiAgICBpZiAoYmVoYXZpb3IgIT09ICdoaWRlX29wdGlvbicgJiYgYmVoYXZpb3IgIT09ICdsYWJlbF9vcHRpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJCgnW2RhdGEtcHJvZHVjdC1hdHRyaWJ1dGUtdmFsdWVdJywgdGhpcy4kZWwpLmVhY2goKGksIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgY29uc3QgJGF0dHJpYnV0ZSA9ICQoYXR0cmlidXRlKTtcbiAgICAgIGNvbnN0IGF0dHJJZCA9IHBhcnNlSW50KCRhdHRyaWJ1dGUuZGF0YSgncHJvZHVjdC1hdHRyaWJ1dGUtdmFsdWUnKSwgMTApO1xuXG4gICAgICBpZiAoaW5TdG9ja0lkcy5pbmRleE9mKGF0dHJJZCkgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZUF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZUF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2Rpc2FibGVBdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX2dldEF0dHJpYnV0ZVR5cGUoJGF0dHJpYnV0ZSkgPT09ICdzZXQtc2VsZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZVNlbGVjdE9wdGlvbkF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpO1xuICAgIH1cblxuICAgIGlmIChiZWhhdmlvciA9PT0gJ2hpZGVfb3B0aW9uJykge1xuICAgICAgJGF0dHJpYnV0ZS5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRhdHRyaWJ1dGUuYWRkQ2xhc3MoJ29wdGlvbi11bmF2YWlsYWJsZScpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGVTZWxlY3RPcHRpb25BdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKSB7XG4gICAgaWYgKGJlaGF2aW9yID09PSAnaGlkZV9vcHRpb24nKSB7XG4gICAgICAkYXR0cmlidXRlLnRvZ2dsZU9wdGlvbihmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRhdHRyaWJ1dGUuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICRhdHRyaWJ1dGUuaHRtbCgkYXR0cmlidXRlLmh0bWwoKS5yZXBsYWNlKG91dE9mU3RvY2tNZXNzYWdlLCAnJykgKyBvdXRPZlN0b2NrTWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgX2VuYWJsZUF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5fZ2V0QXR0cmlidXRlVHlwZSgkYXR0cmlidXRlKSA9PT0gJ3NldC1zZWxlY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmFibGVTZWxlY3RPcHRpb25BdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKGJlaGF2aW9yID09PSAnaGlkZV9vcHRpb24nKSB7XG4gICAgICAkYXR0cmlidXRlLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGF0dHJpYnV0ZS5yZW1vdmVDbGFzcygnb3B0aW9uLXVuYXZhaWxhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgZW5hYmxlU2VsZWN0T3B0aW9uQXR0cmlidXRlKCRhdHRyaWJ1dGUsIGJlaGF2aW9yLCBvdXRPZlN0b2NrTWVzc2FnZSkge1xuICAgIGlmIChiZWhhdmlvciA9PT0gJ2hpZGVfb3B0aW9uJykge1xuICAgICAgJGF0dHJpYnV0ZS50b2dnbGVPcHRpb24odHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRhdHRyaWJ1dGUucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICRhdHRyaWJ1dGUuaHRtbCgkYXR0cmlidXRlLmh0bWwoKS5yZXBsYWNlKG91dE9mU3RvY2tNZXNzYWdlLCAnJykpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRBdHRyaWJ1dGVUeXBlKCRhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCAkcGFyZW50ID0gJGF0dHJpYnV0ZS5jbG9zZXN0KCdbZGF0YS1wcm9kdWN0LWF0dHJpYnV0ZV0nKTtcbiAgICByZXR1cm4gJHBhcmVudCA/ICRwYXJlbnQuZGF0YSgncHJvZHVjdC1hdHRyaWJ1dGUnKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcHJvZHVjdCB0byBjYXJ0XG4gICAqL1xuICBfYmluZENhcnRBZGQoZXZlbnQsIGZvcm0pIHtcbiAgICAvLyBEbyBub3QgZG8gQUpBWCBpZiBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBGb3JtRGF0YVxuICAgIGlmICh3aW5kb3cuRm9ybURhdGEgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSk7XG5cbiAgICB0aGlzLmNhbGxiYWNrcy53aWxsVXBkYXRlKCQoZm9ybSkpO1xuXG4gICAgLy8gUmVtb3ZlIG9sZCBhbHRlcnNcbiAgICB0aGlzLmNhcnRBZGRBbGVydC5jbGVhcigpO1xuICAgIHRoaXMuY2FydE9wdGlvbkFsZXJ0LmNsZWFyKCk7XG5cbiAgICAvLyBBZGQgaXRlbSB0byBjYXJ0XG4gICAgdXRpbHMuYXBpLmNhcnQuaXRlbUFkZChmb3JtRGF0YSwgKGVyciwgcmVzcG9uc2UpID0+IHtcblxuICAgICAgaWYgKGVyciB8fCByZXNwb25zZS5kYXRhLmVycm9yKSB7XG4gICAgICAgIHJlc3BvbnNlID0gZXJyIHx8IHJlc3BvbnNlLmRhdGEuZXJyb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGludGVycHJldCBhbmQgZGlzcGxheSBjYXJ0LWFkZCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAqL1xuICAgICAgICAgdGhpcy5jYXJ0QWRkQWxlcnQubWVzc2FnZShyZXNwb25zZSwgJ2Vycm9yJywgdHJ1ZSk7XG4gICAgICAgICB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUocmVzcG9uc2UsICQoZm9ybSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy50b3AubG9jYXRpb24gPSB0aGlzLmNvbnRleHQudXJsc0NhcnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFtcFF1YW50aXR5V2lkZ2V0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgZWw6ICdbZGF0YS1xdWFudGl0eS1jb250cm9sXScsXG4gICAgICBjbnRybDogJ1tkYXRhLXF1YW50aXR5LWNvbnRyb2wtYWN0aW9uXScsXG4gICAgICBzY29wZTogJ2JvZHknLFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gQmluZCBDb250cm9sIEFjdGlvbnNcbiAgICAkKHRoaXMub3B0aW9ucy5zY29wZSkub24oJ2NsaWNrJywgdGhpcy5vcHRpb25zLmNudHJsLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vaW4gY2FzZSB3ZSB1c2UgPGJ1dHRvbj4vPGE+IGluc3RlYWQgb2YgPHNwYW4+J3NcbiAgICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgY29uc3QgYWN0aW9uID0gJHRhcmdldC5kYXRhKCdxdWFudGl0eS1jb250cm9sLWFjdGlvbicpO1xuXG4gICAgICBjb25zdCAkcXVhbnRpdHlJbnB1dCA9ICR0YXJnZXQuc2libGluZ3MoJ2lucHV0Jyk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KCRxdWFudGl0eUlucHV0LnZhbCgpLDEwKTtcbiAgICAgIGNvbnN0IG1pbiA9ICRxdWFudGl0eUlucHV0LmF0dHIoJ21pbicpID8gcGFyc2VJbnQoJHF1YW50aXR5SW5wdXQuYXR0cignbWluJyksMTApIDogMDtcbiAgICAgIGNvbnN0IG1heCA9ICRxdWFudGl0eUlucHV0LmF0dHIoJ21heCcpID8gcGFyc2VJbnQoJHF1YW50aXR5SW5wdXQuYXR0cignbWF4JyksMTApIDogSW5maW5pdHk7XG5cbiAgICAgIGlmIChhY3Rpb24gPT09ICdpbmNyZW1lbnQnICYmIHZhbHVlIDwgbWF4KSB7XG4gICAgICAgICRxdWFudGl0eUlucHV0LnZhbCh2YWx1ZSArIDEpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09ICdkZWNyZW1lbnQnICYmIHZhbHVlID4gMCAmJiB2YWx1ZSA+IG1pbikge1xuICAgICAgICAkcXVhbnRpdHlJbnB1dC52YWwodmFsdWUgLSAxKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpbXBsZSBpbnB1dCB2YWxpZGF0aW9uIChrZWVwIGlucHV0IHdpdGhpbiBtaW4vbWF4IHJhbmdlKVxuICAgIC8vIEZlZWwgZnJlZSB0byByZW1vdmUgYW5kIHJlcGxhY2Ugd2l0aCBhbm90aGVyIGZvcm0gb2YgdmFsaWRhdGlvblxuICAgICQodGhpcy5vcHRpb25zLnNjb3BlKS5vbignY2hhbmdlJywgJ2lucHV0JywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC50YXJnZXQpO1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludCgkdGFyZ2V0LnZhbCgpLDEwKTtcbiAgICAgIGNvbnN0IG1pbiA9ICR0YXJnZXQuYXR0cignbWluJykgPyBwYXJzZUludCgkdGFyZ2V0LmF0dHIoJ21pbicpLDEwKSA6IDA7XG4gICAgICBjb25zdCBtYXggPSAkdGFyZ2V0LmF0dHIoJ21heCcpID8gcGFyc2VJbnQoJHRhcmdldC5hdHRyKCdtYXgnKSwxMCkgOiBJbmZpbml0eTtcblxuICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFF1YW50aXR5IFwiJHt2YWx1ZX1cIiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG1heGltdW0gKCR7bWF4fSlgKTtcbiAgICAgICAgJHRhcmdldC52YWwoJHRhcmdldC5hdHRyKCd2YWx1ZScpKTtcbiAgICAgIH0gaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFF1YW50aXR5IHZhbHVlIFwiJHt2YWx1ZX1cIiBjYW5ub3QgYmUgbGVzcyB0aGFuIG1pbmltdW0gKCR7bWlufSlgKTtcbiAgICAgICAgJHRhcmdldC52YWwoJHRhcmdldC5hdHRyKCd2YWx1ZScpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBTaW1wbGUgaW1hZ2UgZ2FsbGVyeSBmb3Igb3JkZXJzIHdpdGggZGlnaXRhbCBkb3dubG9hZHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdhbGxlcnkoKSB7XG4gIGNvbnN0ICR0aHVtYnMgPSAkKCdbZGF0YS1hY2NvdW50LWRvd25sb2FkLXRodW1iXScpO1xuICBjb25zdCAkaW1hZ2UgPSAkKCdbZGF0YS1hY2NvdW50LWRvd25sb2FkLWltYWdlXScpO1xuXG4gICR0aHVtYnMub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgJGltYWdlLmF0dHIoJ3NyYycsICR0YXJnZXQuYXR0cignc3JjJykpO1xuICB9KTtcbn1cbiIsImNvbnN0IGZpZWxkU2VsZWN0b3IgPSAnW2RhdGEtc3dhdGNoLXNlbGVjdG9yXSc7XG5jb25zdCB2YWx1ZVNlbGVjdG9yID0gJy5zd2F0Y2gtd3JhcFtkYXRhLXN3YXRjaC12YWx1ZV0nO1xuY29uc3QgbGFiZWxTZWxlY3RvciA9ICcuc3dhdGNoLXZhbHVlW2RhdGEtc3dhdGNoLXZhbHVlXSc7XG5cbi8qKlxuICogU2hvdyBzZWxlY3RlZCB2YWx1ZSBuZXh0IHRvIHRoZSBmb3JtIGZpZWxkIHRpdGxlLlxuICpcbiAqIE9ubHkgYXBwbGllcyB0byBzd2F0Y2ggZm9ybSBmaWVsZHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1TZWxlY3RlZFZhbHVlKCkge1xuICAkKGRvY3VtZW50LmJvZHkpLm9uKCdjbGljaycsIHZhbHVlU2VsZWN0b3IsIChldmVudCkgPT4ge1xuICAgIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0ICRsYWJlbCA9ICR0YXJnZXQucGFyZW50cyhmaWVsZFNlbGVjdG9yKS5maW5kKGxhYmVsU2VsZWN0b3IpO1xuICAgICRsYWJlbC5odG1sKCR0YXJnZXQuZGF0YSgnc3dhdGNoLXZhbHVlJykpO1xuICB9KTtcbn1cbiIsIi8qKlxuICogVmlzdWFsbHkgaGlkZXMgdGhlIG9wdGlvbiBmcm9tIHVzZXIgYnkgbW92aW5nIG9wdGlvbiB0byBhbiBpbnZpc2libGVcbiAqIGFuZCBkaXNhYmxlZCBzZWxlY3QgcGxhY2Vob2xkZXIgZWxlbWVudC5cbiAqXG4gKiBUaGlzIGFwcHJvYWNoIGlzIHJlcXVpcmVkIHJhdGhlciB0aGFuIHNpbXBseSBoaWRpbmcgdGhlIG9wdGlvbiBiZWNhdXNlXG4gKiBoaWRkZW4gb3B0aW9uIGNhbiBzdGlsbCBiZSBpbmNsdWRlZCB3aGVuIHNlcmlhbGl6ZUFycmF5KCkgaXMgY2FsbGVkIGFuZFxuICogY2F1c2Ugd3JvbmcgdmFsdWUgdG8gYmUgc3VibWl0dGVkLlxuICogKGVnLiBpZiB5b3UgaGF2ZSBvcHRpb24gMSwgMiwgMyBhbmQgMiBpcyBoaWRkZW4sIHdoZW4geW91IHNlbGVjdCAzLFxuICogc2VyaWFsaXplQXJyYXkoKSB3aWxsIHVzZSB0aGUgdmFsdWUgb2YgMiBpbnN0ZWFkIG9mIDMpXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZU9wdGlvbihzaG93KSB7XG4gIGNvbnN0IGN1cnJlbnRTZWxlY3RFbGVtZW50ID0gJCh0aGlzKS5jbG9zZXN0KCdzZWxlY3QnKTsgLy8gdGhlIHNlbGVjdCBjb250YWluaW5nIHRoaXNcbiAgbGV0IGRpc2FibGVkU2VsZWN0RWxlbWVudDsgLy8gdGhlIGRpc2FibGVkIHNlbGVjdCBlbGVtZW50XG4gIGxldCBzZWxlY3RFbGVtZW50OyAvLyB0aGUgcmVhbCBzZWxlY3QgZWxlbWVudFxuXG4gIGlmIChjdXJyZW50U2VsZWN0RWxlbWVudC5pcygnOmRpc2FibGVkJykpIHtcbiAgICBkaXNhYmxlZFNlbGVjdEVsZW1lbnQgPSBjdXJyZW50U2VsZWN0RWxlbWVudDtcbiAgICBzZWxlY3RFbGVtZW50ID0gZGlzYWJsZWRTZWxlY3RFbGVtZW50LmRhdGEoJ2xpbmtlZFNlbGVjdEVsZW1lbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3RFbGVtZW50ID0gY3VycmVudFNlbGVjdEVsZW1lbnQ7XG4gICAgZGlzYWJsZWRTZWxlY3RFbGVtZW50ID0gY3VycmVudFNlbGVjdEVsZW1lbnQuZGF0YSgnbGlua2VkU2VsZWN0RWxlbWVudCcpO1xuICAgIGlmICghZGlzYWJsZWRTZWxlY3RFbGVtZW50KSB7XG4gICAgICAvLyBjcmVhdGUgdGhlIGRpc2FibGVkIHBsYWNlaG9sZGVyIHNlbGVjdCBlbGVtZW50XG4gICAgICBkaXNhYmxlZFNlbGVjdEVsZW1lbnQgPSAkKCc8c2VsZWN0PicpXG4gICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpXG4gICAgICAgIC5oaWRlKClcbiAgICAgICAgLmF0dHIoJ25hbWUnLCBjdXJyZW50U2VsZWN0RWxlbWVudC5hdHRyKCduYW1lJykpXG4gICAgICAgIC5hZGRDbGFzcyhjdXJyZW50U2VsZWN0RWxlbWVudC5hdHRyKCdjbGFzcycpKVxuICAgICAgICAuZGF0YSgnbGlua2VkU2VsZWN0RWxlbWVudCcsIHNlbGVjdEVsZW1lbnQpXG4gICAgICAgIC5pbnNlcnRBZnRlcihzZWxlY3RFbGVtZW50KTtcblxuICAgICAgc2VsZWN0RWxlbWVudC5kYXRhKCdsaW5rZWRTZWxlY3RFbGVtZW50JywgZGlzYWJsZWRTZWxlY3RFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBzYXZlIHRoZSBzZWxlY3RlZCBvcHRpb25cbiAgY29uc3Qgc2VsZWN0ZWRPcHRpb24gPSBzZWxlY3RFbGVtZW50LmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpO1xuXG4gIC8vIHVwZGF0ZSAuZm9ybS1zZWxlY3RlZC10ZXh0IGVsZW1lbnRcbiAgY29uc3QgdGV4dCA9IHNlbGVjdEVsZW1lbnQuZmluZChgW3ZhbHVlPVwiJHtzZWxlY3RlZE9wdGlvbi52YWwoKX1cIl1gKS50ZXh0KCk7XG5cbiAgbGV0ICRwcmVmaXggPSBzZWxlY3RFbGVtZW50LnBhcmVudHMoJy5mb3JtLXNlbGVjdC13cmFwcGVyJykuZGF0YSgnc2VsZWN0ZWQtcHJlZml4Jyk7XG4gICRwcmVmaXggPSAoJHByZWZpeCA/IGA8c3BhbiBjbGFzcz1cImZvcm0tc2VsZWN0ZWQtdGV4dC1wcmVmaXhcIj4keyRwcmVmaXh9PC9zcGFuPmAgOiAnJyk7XG5cbiAgc2VsZWN0RWxlbWVudC5zaWJsaW5ncygnLmZvcm0tc2VsZWN0ZWQtdGV4dCcpLmh0bWwoJHByZWZpeCArIHRleHQpO1xuXG4gIC8vIG1vdmUgdGhlIG9wdGlvbiB0byB0aGUgY29ycmVjdCBzZWxlY3QgZWxlbWVudCBpZiByZXF1aXJlZFxuICBpZiAoY3VycmVudFNlbGVjdEVsZW1lbnQuaXMoJzpkaXNhYmxlZCcpICYmIHNob3cpIHtcbiAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5kYXRhKCdpbmRleCcpO1xuXG4gICAgaWYgKHByZXZpb3VzSW5kZXggPiAwKSB7XG4gICAgICAvLyBsb29wIHRocm91Z2ggdG8gcHV0IHRoZSBzZWxlY3QgZWxlbWVudCBpbiBpdCdzIHByb3BlciBwbGFjZVxuICAgICAgZm9yIChsZXQgaSA9IHByZXZpb3VzSW5kZXg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHNlbGVjdEVsZW1lbnQuZmluZChgb3B0aW9uOmVxKCR7aSAtIDF9KWApLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIoc2VsZWN0RWxlbWVudC5maW5kKGBvcHRpb246ZXEoJHtpIC0gMX0pYCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICQodGhpcykuYXBwZW5kVG8oc2VsZWN0RWxlbWVudCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFjdXJyZW50U2VsZWN0RWxlbWVudC5pcygnOmRpc2FibGVkJykgJiYgIXNob3cpIHtcbiAgICB0aGlzLmRhdGEoJ2luZGV4JywgY3VycmVudFNlbGVjdEVsZW1lbnQuZmluZCgnb3B0aW9uJykuaW5kZXgodGhpcykpO1xuICAgICQodGhpcykucHJlcGVuZFRvKGRpc2FibGVkU2VsZWN0RWxlbWVudCk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgdGhlIG9wdGlvbiBpcyBzdGlsbCBzZWxlY3RlZFxuICBzZWxlY3RlZE9wdGlvbi5wcm9wKCdzZWxlY3RlZCcsIHRydWUpO1xufVxuXG4kLmZuLnRvZ2dsZU9wdGlvbiA9IHRvZ2dsZU9wdGlvbjtcbiIsImltcG9ydCB1dGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XG5cbi8qKlxuICogUmV0dXJuIGEgXCJTdGF0ZVwiIHNlbGVjdCBpbnB1dFxuICogQHBhcmFtICB7b2JqfSAgICAgIHJlc3BvbnNlRGF0YSAtIHJlc3BvbnNlIGZyb20gdXRpbHMuYXBpLmNvdW50cnkuZ2V0QnlOYW1lXG4gKiBAcGFyYW0gIHtvYmp9ICAgICAgc3RhdGVBdHRycyAtIG5hbWUgYW5kIElEIG9mIGZpZWxkXG4gKiBAcGFyYW0gIHtib29sfSAgICAgdXNlSWQgLSBzaG91bGQgd2UgdXNlIHRoZSBzdGF0ZSBuYW1lIG9yIElEIGFzIHRoZSB2YWx1ZT9cbiAqIEByZXR1cm4ge2pRdWVyeX0gICBhIHNlbGVjdCBpbnB1dFxuICovXG5mdW5jdGlvbiBzdGF0ZUFzU2VsZWN0KHJlc3BvbnNlRGF0YSwgc3RhdGVBdHRycywgdXNlSWQpIHtcbiAgY29uc3Qgc3RhdGVBcnJheSA9IFtdO1xuICBzdGF0ZUFycmF5LnB1c2goYDxvcHRpb24gdmFsdWU9XCJcIj4ke3Jlc3BvbnNlRGF0YS5wcmVmaXh9PC9vcHRpb24+YCk7XG5cbiAgZm9yIChjb25zdCBzdGF0ZSBvZiByZXNwb25zZURhdGEuc3RhdGVzKSB7XG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSB1c2VJZCA/IHN0YXRlLmlkIDogc3RhdGUubmFtZTtcbiAgICBzdGF0ZUFycmF5LnB1c2goYDxvcHRpb24gdmFsdWU9XCIke29wdGlvblZhbHVlfVwiPiR7c3RhdGUubmFtZX08L29wdGlvbj5gKTtcbiAgfVxuXG4gIGNvbnN0ICRzdGF0ZVNlbGVjdCA9ICQoJzxzZWxlY3Q+Jywge1xuICAgIGNsYXNzOiAnZm9ybS1pbnB1dCBmb3JtLXNlbGVjdCcsXG4gICAgaWQ6IHN0YXRlQXR0cnMuc3RhdGVJZCxcbiAgICBuYW1lOiBzdGF0ZUF0dHJzLnN0YXRlTmFtZSxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAnYXJpYS1yZXF1aXJlZCc6IHRydWUsXG4gICAgJ2RhdGEtZmllbGQtdHlwZSc6ICdTdGF0ZScsXG4gICAgaHRtbDogc3RhdGVBcnJheS5qb2luKCcgJyksXG4gIH0pO1xuXG4gIHJldHVybiAkc3RhdGVTZWxlY3Q7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgXCJTdGF0ZVwiIHRleHQgaW5wdXRcbiAqIEBwYXJhbSAge29ian0gICAgICBzdGF0ZUF0dHJzIC0gbmFtZSBhbmQgSUQgb2YgZmllbGRcbiAqIEByZXR1cm4ge2pRdWVyeX0gICBhbiB0ZXh0IGlucHV0XG4gKi9cbmZ1bmN0aW9uIHN0YXRlQXNJbnB1dChzdGF0ZUF0dHJzKSB7XG4gIGNvbnN0ICRzdGF0ZUlucHV0ID0gJCgnPGlucHV0PicsIHtcbiAgICBjbGFzczogJ2Zvcm0taW5wdXQnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICBpZDogc3RhdGVBdHRycy5zdGF0ZUlkLFxuICAgIG5hbWU6IHN0YXRlQXR0cnMuc3RhdGVOYW1lLFxuICAgICdkYXRhLWZpZWxkLXR5cGUnOiAnU3RhdGUnLFxuICB9KTtcblxuICByZXR1cm4gJHN0YXRlSW5wdXQ7XG59XG5cbi8qKlxuICogVG9nZ2xlIGJldHdlZW4gYSBzdGF0ZSBzZWxlY3QgYW5kIHRleHQgaW5wdXRcbiAqIEBwYXJhbSAge29ian0gICAgICBldmVudCAgICBDb3VudHJ5IHNlbGVjdCBjaGFuZ2UgZXZlbnRcbiAqIEBwYXJhbSAge2Jvb2x9ICAgICB1c2VJZCAgICB3aGV0aGVyIHRvIHVzZSB0aGUgc3RhdGUgaWQgb3IgbmFtZSBmb3Igb3B0aW9uIHZhbHVlXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBmZXRjaEFuZFVwZGF0ZVN0YXRlSW5wdXQoZXZlbnQsIHVzZUlkLCBjYWxsYmFjaykge1xuICBjb25zdCAkdGFyZ2V0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgY29uc3QgY291bnRyeSA9ICR0YXJnZXQudmFsKCk7XG4gIGNvbnN0ICRzdGF0ZUVsZW1lbnQgPSAkKCdbZGF0YS1maWVsZC10eXBlPVwiU3RhdGVcIl0nKTtcbiAgY29uc3Qgc3RhdGVBdHRycyA9IHtcbiAgICBzdGF0ZUlkOiAkc3RhdGVFbGVtZW50LmF0dHIoJ2lkJyksXG4gICAgc3RhdGVOYW1lOiAkc3RhdGVFbGVtZW50LmF0dHIoJ25hbWUnKSxcbiAgfTtcbiAgY29uc3QgJHN0YXRlV3JhcHBlciA9ICQoJyNGb3JtRmllbGRfMTInKTtcblxuICB1dGlscy5hcGkuY291bnRyeS5nZXRCeU5hbWUoY291bnRyeSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICBpZiAocmVzcG9uc2UuZGF0YS5zdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBidWlsZCBhbmQgYXR0YWNoIG91ciBzZWxlY3QgaW5wdXRcbiAgICAgIGNvbnN0ICRzdGF0ZVNlbGVjdCA9IHN0YXRlQXNTZWxlY3QocmVzcG9uc2UuZGF0YSwgc3RhdGVBdHRycywgdXNlSWQpO1xuICAgICAgJHN0YXRlRWxlbWVudC5yZXBsYWNlV2l0aCgkc3RhdGVTZWxlY3QpO1xuICAgICAgJHN0YXRlV3JhcHBlci50b2dnbGVDbGFzcygnZm9ybS1yZXF1aXJlZCcsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBidWlsZCBhbmQgYXR0YWNoIG91ciB0ZXh0IGlucHV0XG4gICAgICBjb25zdCAkc3RhdGVJbnB1dCA9IHN0YXRlQXNJbnB1dChzdGF0ZUF0dHJzKTtcbiAgICAgICRzdGF0ZUVsZW1lbnQucmVwbGFjZVdpdGgoJHN0YXRlSW5wdXQpO1xuICAgICAgJHN0YXRlV3JhcHBlci50b2dnbGVDbGFzcygnZm9ybS1yZXF1aXJlZCcsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCAkbmV3U3RhdGVFbGVtZW50ID0gJCgnW2RhdGEtZmllbGQtdHlwZT1cIlN0YXRlXCJdJyk7XG4gICAgY29uc3QgJG5ld1N0YXRlRWxlbWVudFBhcmVudCA9ICRuZXdTdGF0ZUVsZW1lbnQucGFyZW50KCk7XG4gICAgY29uc3QgJHNlbGVjdGVkVGV4dCA9ICRuZXdTdGF0ZUVsZW1lbnRQYXJlbnQuZmluZCgnLmZvcm0tc2VsZWN0ZWQtdGV4dCcpO1xuXG4gICAgaWYgKHJlc3BvbnNlLmRhdGEuc3RhdGVzLmxlbmd0aCkge1xuICAgICAgJG5ld1N0YXRlRWxlbWVudFBhcmVudC5hZGRDbGFzcygnZm9ybS1zZWxlY3Qtd3JhcHBlcicpO1xuXG4gICAgICBpZiAoJHNlbGVjdGVkVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgJHNlbGVjdGVkVGV4dC50ZXh0KHJlc3BvbnNlLmRhdGEucHJlZml4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRuZXdTdGF0ZUVsZW1lbnRQYXJlbnQucHJlcGVuZChgPHNwYW4gY2xhc3M9XCJmb3JtLXNlbGVjdGVkLXRleHRcIj4ke3Jlc3BvbnNlLmRhdGEucHJlZml4fTwvc3Bhbj5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKCRuZXdTdGF0ZUVsZW1lbnQpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRzZWxlY3RlZFRleHQucmVtb3ZlKCk7XG4gICAgICAkbmV3U3RhdGVFbGVtZW50UGFyZW50LnJlbW92ZUNsYXNzKCdmb3JtLXNlbGVjdC13cmFwcGVyJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBCaW5kIHRoZSB0aGluZyB0byB0aGUgY2hhbmdlIGV2ZW50IGFuZCBleHBvcnQgaXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlU3RhdGUodXNlSWQsIGNhbGxiYWNrKSB7XG4gICQoZG9jdW1lbnQuYm9keSkub24oJ2NoYW5nZScsICdbZGF0YS1maWVsZC10eXBlPVwiQ291bnRyeVwiXScsIChldmVudCkgPT4ge1xuICAgIGZldGNoQW5kVXBkYXRlU3RhdGVJbnB1dChldmVudCwgdXNlSWQsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBEcm9wZG93biB7XHJcbiAgY29uc3RydWN0b3IoZWwpIHtcclxuICAgIHRoaXMuJGVsID0gJChlbCk7XHJcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XHJcbiAgICB0aGlzLnRpbWVvdXRMZWF2ZSA9IG51bGw7XHJcbiAgICB0aGlzLmRlbGF5TGVhdmUgPSAzMDA7IC8vIEFkanVzdCB0aGUgZGVsYXkgdG8gYSB2YWx1ZSB0aGF0IHdvcmtzIGJlc3QgZm9yIHlvdVxyXG5cclxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciBmb3Igc2Nyb2xsXHJcbiAgICAkKHdpbmRvdykub24oJ3Njcm9sbCcsICgpID0+IHtcclxuICAgICAgdGhpcy5faGFuZGxlU2Nyb2xsKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBcHBseSBtYXJnaW4tdG9wIGluaXRpYWxseSBpZiB1c2VyIGlzIGF0IHRoZSB0b3BcclxuICAgIHRoaXMuX2hhbmRsZVNjcm9sbCgpO1xyXG4gIH1cclxuXHJcbiAgX2JpbmRFdmVudHMoKSB7XHJcbiAgICAvLyBVc2luZyBtb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlIGZvciBiZXR0ZXIgY29udHJvbFxyXG4gICAgdGhpcy4kZWwub24oJ21vdXNlZW50ZXInLCAoZXZlbnQpID0+IHRoaXMuX2hhbmRsZU1vdXNlRW50ZXIoZXZlbnQpKTtcclxuICAgIHRoaXMuJGVsLm9uKCdtb3VzZWxlYXZlJywgKGV2ZW50KSA9PiB0aGlzLl9oYW5kbGVNb3VzZUxlYXZlKGV2ZW50KSk7XHJcblxyXG4gICAgLy8gQ2xvc2UgZHJvcGRvd25zIHdoZW4gbW91c2UgbGVhdmVzIHRoZSBuYXZpZ2F0aW9uIGNvbnRhaW5lclxyXG4gICAgJCgnLm5hdmlnYXRpb24tY29udGFpbmVyJykub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX2hpZGVBbGxDaGlsZHJlbih0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciBmb3IgbW91c2VvdmVyIG9uIHJvb3QgbGlzdCBpdGVtc1xyXG4gICAgdGhpcy4kZWwuZmluZCgnLm1lZ2EtbmF2LXJvb3QtaXRlbScpLm9uKCdtb3VzZW92ZXInLCAoZXZlbnQpID0+IHtcclxuICAgICAgdGhpcy5faGFuZGxlUm9vdEl0ZW1Nb3VzZU92ZXIoZXZlbnQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlTW91c2VFbnRlcihldmVudCkge1xyXG4gICAgY29uc3QgJGRyb3Bkb3duID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgIGNvbnN0ICRkcm9wZG93blBhbmVsID0gJGRyb3Bkb3duLmZpbmQoJy5kcm9wZG93bi1wYW5lbCcpO1xyXG5cclxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRMZWF2ZSk7IC8vIENsZWFyIHByZXZpb3VzIGxlYXZlIHRpbWVvdXRcclxuXHJcbiAgICAkKCcuZHJvcGRvd24tb3BlbicpLm5vdCgkZHJvcGRvd24pLnJlbW92ZUNsYXNzKCdkcm9wZG93bi1vcGVuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAuZmluZCgnLmRyb3Bkb3duLXBhbmVsJykucmV2ZWFsZXIoJ2hpZGUnKTtcclxuXHJcbiAgICAvLyBPbmx5IGFwcGx5IG1hcmdpbi10b3Agd2hlbiBhdCB0aGUgdG9wXHJcbiAgICBpZiAoJCh3aW5kb3cpLnNjcm9sbFRvcCgpID09PSAwKSB7XHJcbiAgICAgICRkcm9wZG93blBhbmVsLmNzcygnbWFyZ2luLXRvcCcsICctNXB4Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgJGRyb3Bkb3duLmFkZENsYXNzKCdkcm9wZG93bi1vcGVuJyk7XHJcbiAgICAkZHJvcGRvd24uZmluZCgnLnRvcC1sZXZlbC1uYXYtbGluaycpLmFkZENsYXNzKCdkcm9wZG93bi1vcGVuJyk7XHJcbiAgICAkZHJvcGRvd25QYW5lbC5yZXZlYWxlcignc2hvdycpO1xyXG5cclxuICAgIC8vIFJlc2V0IHZpc2liaWxpdHkgb2YgYWxsIHRpZXIgMyBjYXRlZ29yaWVzXHJcbiAgICAkZHJvcGRvd25QYW5lbC5maW5kKCcubWVnYS1uYXYtY2hpbGQtbGlzdC1jb250YWluZXInKS5yZW1vdmVDbGFzcygndmlzaWJsZScpO1xyXG5cclxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgaG92ZXIgZWZmZWN0XHJcbiAgICAkZHJvcGRvd25QYW5lbC5maW5kKCcubWVnYS1uYXYtcm9vdC1saXN0IC5tZWdhLW5hdi1yb290LWl0ZW0nKS5yZW1vdmVDbGFzcygnaG92ZXJlZCcpO1xyXG4gICAgJGRyb3Bkb3duUGFuZWwuZmluZCgnLm1lZ2EtbmF2LXJvb3QtbGlzdCBhJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgIC8vIFNpbXVsYXRlIGhvdmVyIGZvciB0aGUgZmlyc3QgaW1tZWRpYXRlIHRpZXIgMiBjYXRlZ29yeVxyXG4gICAgY29uc3QgJGZpcnN0VGllcjIgPSAkZHJvcGRvd25QYW5lbC5maW5kKCcubWVnYS1uYXYtcm9vdC1saXN0IC5tZWdhLW5hdi1yb290LWl0ZW0nKS5maXJzdCgpO1xyXG4gICAgaWYgKCRmaXJzdFRpZXIyLmxlbmd0aCA+IDApIHtcclxuICAgICAgJGZpcnN0VGllcjIuYWRkQ2xhc3MoJ2hvdmVyZWQnKTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IGVmZmVjdCB0byB0aGUgPGE+IGVsZW1lbnQgaW5zaWRlIGVsZW1lbnRzIHdpdGggdGhlIGNsYXNzICdob3ZlcmVkJ1xyXG4gICAgICAkZmlyc3RUaWVyMi5maW5kKCdhJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgLy8gU2hvdyB0aWVyIDMgY2F0ZWdvcmllcyBiZWxvbmdpbmcgdG8gdGhlIGhvdmVyZWQgdGllciAyIGNhdGVnb3J5XHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5SWQgPSAkZmlyc3RUaWVyMi5kYXRhKCdjYXRlZ29yeS1pZCcpO1xyXG4gICAgICBjb25zdCAkY2hpbGRMaXN0ID0gJGRyb3Bkb3duUGFuZWwuZmluZCgnW2RhdGEtcm9vdC1jYXRlZ29yeS1pZD1cIicgKyBjYXRlZ29yeUlkICsgJ1wiXScpO1xyXG4gICAgICBpZiAoJGNoaWxkTGlzdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgJGNoaWxkTGlzdC5jbG9zZXN0KCcubWVnYS1uYXYtY2hpbGQtbGlzdC1jb250YWluZXInKS5hZGRDbGFzcygndmlzaWJsZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlTW91c2VMZWF2ZShldmVudCkge1xyXG4gICAgY29uc3QgJGRyb3Bkb3duID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgIGNvbnN0ICRkcm9wZG93blBhbmVsID0gJGRyb3Bkb3duLmZpbmQoJy5kcm9wZG93bi1wYW5lbCcpO1xyXG5cclxuICAgIHRoaXMudGltZW91dExlYXZlID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIC8vIENoZWNrIGlmIG1vdXNlIHBvaW50ZXIgaXMgbm90IG92ZXIgdGhlIGRyb3Bkb3duIG9yIGl0cyBwYW5lbFxyXG4gICAgICBpZiAoISRkcm9wZG93bi5pcygnOmhvdmVyJykgJiYgISRkcm9wZG93blBhbmVsLmlzKCc6aG92ZXInKSkge1xyXG4gICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93blxyXG4gICAgICAgICRkcm9wZG93bi5yZW1vdmVDbGFzcygnZHJvcGRvd24tb3BlbicpO1xyXG4gICAgICAgICRkcm9wZG93blBhbmVsLnJldmVhbGVyKCdoaWRlJyk7XHJcbiAgICAgICAgJGRyb3Bkb3duLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTsgLy8gUmVtb3ZlIGFjdGl2ZSBjbGFzcyB3aGVuIG1vdXNlIGxlYXZlc1xyXG4gICAgICAgICRkcm9wZG93bi5maW5kKCcudG9wLWxldmVsLW5hdi1saW5rJykucmVtb3ZlQ2xhc3MoJ2Ryb3Bkb3duLW9wZW4nKTtcclxuICAgICAgfVxyXG4gICAgfSwgdGhpcy5kZWxheUxlYXZlKTtcclxuICB9XHJcblxyXG4gIF9oYW5kbGVSb290SXRlbU1vdXNlT3ZlcihldmVudCkge1xyXG4gICAgY29uc3QgJHJvb3RJdGVtID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgIGNvbnN0ICRkcm9wZG93blBhbmVsID0gJHJvb3RJdGVtLmNsb3Nlc3QoJy5kcm9wZG93bi1wYW5lbCcpO1xyXG5cclxuICAgIC8vIFJlbW92ZSAnaG92ZXJlZCcgY2xhc3MgZnJvbSBhbGwgcm9vdCBsaXN0IGl0ZW1zXHJcbiAgICAkZHJvcGRvd25QYW5lbC5maW5kKCcubWVnYS1uYXYtcm9vdC1pdGVtJykucmVtb3ZlQ2xhc3MoJ2hvdmVyZWQnKTtcclxuICAgIC8vIEFkZCAnaG92ZXJlZCcgY2xhc3MgdG8gdGhlIGN1cnJlbnQgcm9vdCBsaXN0IGl0ZW1cclxuICAgICRyb290SXRlbS5hZGRDbGFzcygnaG92ZXJlZCcpO1xyXG4gICAgLy8gU2hvdyB0aWVyIDMgY2F0ZWdvcmllcyBiZWxvbmdpbmcgdG8gdGhlIGhvdmVyZWQgdGllciAyIGNhdGVnb3J5XHJcbiAgICBjb25zdCBjYXRlZ29yeUlkID0gJHJvb3RJdGVtLmRhdGEoJ2NhdGVnb3J5LWlkJyk7XHJcbiAgICBjb25zdCAkY2hpbGRMaXN0ID0gJGRyb3Bkb3duUGFuZWwuZmluZCgnW2RhdGEtcm9vdC1jYXRlZ29yeS1pZD1cIicgKyBjYXRlZ29yeUlkICsgJ1wiXScpO1xyXG4gICAgXHJcbiAgICAvLyBIaWRlIGFsbCBjaGlsZCBjb250YWluZXJzXHJcbiAgICAkZHJvcGRvd25QYW5lbC5maW5kKCcubWVnYS1uYXYtY2hpbGQtbGlzdC1jb250YWluZXInKS5yZW1vdmVDbGFzcygndmlzaWJsZScpO1xyXG4gICAgXHJcbiAgICBpZiAoJGNoaWxkTGlzdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICRjaGlsZExpc3QuY2xvc2VzdCgnLm1lZ2EtbmF2LWNoaWxkLWxpc3QtY29udGFpbmVyJykuYWRkQ2xhc3MoJ3Zpc2libGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEhhbmRsZSBzY3JvbGwgZXZlbnQgdG8gcmVtb3ZlIG1hcmdpbi10b3AgcHJvcGVydHkgd2hlbiBzY3JvbGxlZCBkb3duIG1vcmUgdGhhbiA1MHB4XHJcbiAgX2hhbmRsZVNjcm9sbCgpIHtcclxuICAgIGNvbnN0ICRkcm9wZG93blBhbmVsID0gdGhpcy4kZWwuZmluZCgnLmRyb3Bkb3duLXBhbmVsJyk7XHJcbiAgICBpZiAoJCh3aW5kb3cpLnNjcm9sbFRvcCgpID4gNTApIHtcclxuICAgICAgJGRyb3Bkb3duUGFuZWwuY3NzKCdtYXJnaW4tdG9wJywgJycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJGRyb3Bkb3duUGFuZWwuY3NzKCdtYXJnaW4tdG9wJywgJzBweCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2hpZGVBbGxDaGlsZHJlbihyZW1vdmVBY3RpdmUgPSBmYWxzZSkge1xyXG4gICAgaWYgKHJlbW92ZUFjdGl2ZSkge1xyXG4gICAgICB0aGlzLiRlbC5maW5kKCdbZGF0YS1tZWdhLW5hdi1yb290LWl0ZW1dJykucmVtb3ZlQ2xhc3MoJ2hvdmVyZWQgYWN0aXZlJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLiRlbC5maW5kKCcubWVnYS1uYXYtY2hpbGQtbGlzdC1jb250YWluZXInKS5yZW1vdmVDbGFzcygndmlzaWJsZScpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBob29rcywgYXBpIH0gZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xuaW1wb3J0IFVybCBmcm9tICd1cmwnO1xuaW1wb3J0IExvYWRpbmcgZnJvbSAnYmMtbG9hZGluZyc7XG5pbXBvcnQgJ2hpc3RvcnkuanMvc2NyaXB0cy9idW5kbGVkLXVuY29tcHJlc3NlZC9odG1sNCtodG1sNS9qcXVlcnkuaGlzdG9yeSc7XG5pbXBvcnQgc3ZnSWNvbiBmcm9tICcuL3N2Z0ljb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWNldGVkU2VhcmNoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy4kYm9keSA9ICQoZG9jdW1lbnQuYm9keSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgY2F0ZWdvcnk6IHtcbiAgICAgICAgICBzaG9wX2J5X3ByaWNlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZToge1xuICAgICAgICBwcm9kdWN0TGlzdGluZzogJ2NhdGVnb3J5L3Byb2R1Y3QtbGlzdGluZycsXG4gICAgICAgIHNpZGViYXI6ICdjYXRlZ29yeS9zaWRlYmFyJ1xuICAgICAgfSxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIHByb2R1Y3RMaXN0aW5nOiAnW2RhdGEtY2F0ZWdvcnldJyxcbiAgICAgICAgc2lkZWJhcjogJ1tkYXRhLWNhdGVnb3J5LXNpZGViYXJdJyxcbiAgICAgIH0sXG4gICAgICBmYWNldFRvZ2dsZTogJ1tkYXRhLWZhY2V0LXRvZ2dsZV0nLFxuICAgICAgbW9yZVRvZ2dsZTogJ1tkYXRhLWZhY2V0LW1vcmVdJyxcbiAgICAgIG1vcmVGYWNldHM6ICdbZGF0YS1zaG93LW1vcmUtZmFjZXRzXScsXG4gICAgICB0b2dnbGVGYWNldDogKCkgPT4gY29uc29sZS5sb2coJ0ZhY2V0IHRvZ2dsZWQuJyksXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmxvYWRpbmdPcHRpb25zID0ge1xuICAgICAgbG9hZGluZ01hcmt1cDogYDxkaXYgY2xhc3M9XCJsb2FkaW5nLW92ZXJsYXlcIj4ke3N2Z0ljb24oJ3NwaW5uZXInKX08L2Rpdj5gLFxuICAgIH07XG5cbiAgICB0aGlzLmZhY2V0ZWRTZWFyY2hPdmVybGF5ID0gbmV3IExvYWRpbmcodGhpcy5sb2FkaW5nT3B0aW9ucywgZmFsc2UsICcubGlzdGluZy1zaWRlYmFyJyk7XG5cbiAgICB0aGlzLmNhbGxiYWNrcyA9ICQuZXh0ZW5kKHtcbiAgICAgIHdpbGxVcGRhdGU6ICgpID0+IHRoaXMuZmFjZXRlZFNlYXJjaE92ZXJsYXkuc2hvdygpLFxuICAgICAgZGlkVXBkYXRlOiAoKSA9PiB0aGlzLmZhY2V0ZWRTZWFyY2hPdmVybGF5LmhpZGUoKSxcbiAgICB9LCBvcHRpb25zLmNhbGxiYWNrcyk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5fc2FuaXRpemVGYWNldHMoKTtcbiAgfVxuXG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucy50ZW1wbGF0ZSA9ICQuZXh0ZW5kKHtcbiAgICAgIHByb2R1Y3RMaXN0aW5nOiB0aGlzLm9wdGlvbnMudGVtcGxhdGUucHJvZHVjdExpc3RpbmcsXG4gICAgICBzaWRlYmFyOiB0aGlzLm9wdGlvbnMudGVtcGxhdGUuc2lkZWJhcixcbiAgICB9LCBvcHRpb25zLnRlbXBsYXRlKTtcblxuICAgIHRoaXMuX29uU3RhdGVDaGFuZ2UoKTtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgdGhpcy5vcHRpb25zLmZhY2V0VG9nZ2xlLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3RvZ2dsZUZhY2V0KGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgdGhpcy5vcHRpb25zLm1vcmVUb2dnbGUsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fc2hvd0FkZGl0aW9uYWxGaWx0ZXJzKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgdGhpcy5vcHRpb25zLm1vcmVGYWNldHMsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fc2hvd01vcmVGYWNldHMoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgJCh3aW5kb3cpLm9uKCdzdGF0ZWNoYW5nZScsIHRoaXMuX29uU3RhdGVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgaG9va3Mub24oJ2ZhY2V0ZWRTZWFyY2gtZmFjZXQtY2xpY2tlZCcsIHRoaXMuX29uRmFjZXRDbGljay5iaW5kKHRoaXMpKTtcbiAgICBob29rcy5vbignZmFjZXRlZFNlYXJjaC1yYW5nZS1zdWJtaXR0ZWQnLCB0aGlzLl9vblJhbmdlU3VibWl0LmJpbmQodGhpcykpO1xuICAgIGhvb2tzLm9uKCdzb3J0Qnktc3VibWl0dGVkJywgdGhpcy5fb25Tb3J0QnlTdWJtaXQuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvLyBjbGVhbiB1cCB1c2VyIGRlZmluZWQgZmFjZXQgaWRzIC8gc2hvdyBtb3JlIGxpbmtzIGZvciBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgX3Nhbml0aXplRmFjZXRzKCkge1xuICAgICQoJy5mYWNldC1saXN0LWl0ZW1zJykuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IG9sZFRhcmdldElkID0gJChlbGVtZW50KS5hdHRyKCdpZCcpO1xuICAgICAgY29uc3QgbmV3VGFyZ2V0SWQgPSBvbGRUYXJnZXRJZC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05LV0rL2csICctJyk7XG4gICAgICAkKGVsZW1lbnQpLmF0dHIoJ2lkJywgbmV3VGFyZ2V0SWQpO1xuICAgIH0pO1xuXG4gICAgJCgnLmZhY2V0LXRvZ2dsZS1tb3JlJykuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IG9sZEhyZWYgPSAkKGVsZW1lbnQpLmF0dHIoJ2hyZWYnKTtcbiAgICAgIGNvbnN0IG5ld0hyZWYgPSBvbGRIcmVmLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTlcXC0jXSsvZywgJy0nKTtcbiAgICAgICQoZWxlbWVudCkuYXR0cignaHJlZicsIG5ld0hyZWYpO1xuICAgIH0pXG4gIH1cblxuICBfc2hvd01vcmVGYWNldHMoZXZlbnQpIHtcbiAgICAvLyBTaG93L2hpZGUgZXh0cmEgZmFjZXRzIGJhc2VkIG9uIHNldHRpbmdzIGZvciBwcm9kdWN0IGZpbHRlcmluZ1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jYWxsYmFja3Mud2lsbFVwZGF0ZSgpO1xuXG4gICAgY29uc3QgJHRvZ2dsZSA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgY29uc3QgJG5hdkxpc3QgPSAkKCR0b2dnbGUuYXR0cignaHJlZicpKTtcbiAgICBjb25zdCBmYWNldCA9ICRuYXZMaXN0LmRhdGEoJ2ZhY2V0Jyk7XG4gICAgY29uc3QgZmFjZXRVcmwgPSBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufSR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfWA7XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBsaXN0X2FsbDogZmFjZXRcbiAgICB9O1xuXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocXVlcnlTdHJpbmcpO1xuXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB1cmxQYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkdG9nZ2xlLnNpYmxpbmdzKCcuZmFjZXRlZC1zZWFyY2gtb3B0aW9uLWNvbHVtbnMnKS5sZW5ndGggPT0gMCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TW9yZSkge1xuICAgICAgICBhcGkuZ2V0UGFnZShmYWNldFVybCwge1xuICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLm9wdGlvbnMuc2hvd01vcmUsXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9LCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkKHJlc3BvbnNlKS5pbnNlcnRBZnRlcigkbmF2TGlzdCk7XG4gICAgICAgICAgJHRvZ2dsZS5zaWJsaW5ncygnLmZhY2V0ZWQtc2VhcmNoLW9wdGlvbi1jb2x1bW5zJykuYWRkQ2xhc3MoJ3Zpc2libGUnKTtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5kaWRVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICR0b2dnbGUuc2libGluZ3MoJy5mYWNldGVkLXNlYXJjaC1vcHRpb24tY29sdW1ucycpLnRvZ2dsZSgpO1xuICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgJG5hdkxpc3QudG9nZ2xlKCk7XG5cbiAgICAvLyB0b2dnbGUgbW9yZS9sZXNzIGxpbmtcbiAgICAkdG9nZ2xlLmNoaWxkcmVuKCkudG9nZ2xlKCk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfc2hvd0FkZGl0aW9uYWxGaWx0ZXJzKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICQoZXZlbnQuY3VycmVudFRhcmdldClcbiAgICAgIC5hZGRDbGFzcygnaGlkZGVuJylcbiAgICAgIC5wYXJlbnQoJ2xpJylcbiAgICAgIC5zaWJsaW5ncygnbGknKVxuICAgICAgLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgfVxuXG4gIF90b2dnbGVGYWNldChldmVudCkge1xuICAgIHRoaXMub3B0aW9ucy50b2dnbGVGYWNldChldmVudCk7XG4gIH1cblxuICBfb25GYWNldENsaWNrKGV2ZW50LCB0YXJnZXQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgJHRhcmdldCA9ICQodGFyZ2V0KTtcbiAgICBjb25zdCB1cmwgPSAkdGFyZ2V0LmF0dHIoJ2hyZWYnKTtcblxuICAgIHRoaXMuX2dvVG9VcmwodXJsKTtcbiAgfVxuXG4gIF9vblJhbmdlU3VibWl0KGV2ZW50LCB0YXJnZXQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgdXJsID0gVXJsLnBhcnNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICBsZXQgcXVlcnlQYXJhbXMgPSAkKHRhcmdldCkuc2VyaWFsaXplKCk7XG5cbiAgICBpZiAodGhpcy4kYm9keS5oYXNDbGFzcygnc2VhcmNoJykpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTZWFyY2ggPSBgc2VhcmNoX3F1ZXJ5PSR7JCgnW2RhdGEtZmFjZXRlZC1zZWFyY2hdJykuZGF0YSgnc2VhcmNoLXF1ZXJ5Jyl9YCB8fCAnJztcbiAgICAgIHF1ZXJ5UGFyYW1zID0gYCR7Y3VycmVudFNlYXJjaH0mJHtxdWVyeVBhcmFtc31gO1xuICAgIH1cblxuICAgIHRoaXMuX2dvVG9VcmwoVXJsLmZvcm1hdCh7IHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsIHNlYXJjaDogJz8nICsgcXVlcnlQYXJhbXMgfSkpO1xuICB9XG5cbiAgX29uU29ydEJ5U3VibWl0KGV2ZW50LCB0YXJnZXQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgdXJsID0gVXJsLnBhcnNlKGxvY2F0aW9uLmhyZWYsIHRydWUpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gJCh0YXJnZXQpLnNlcmlhbGl6ZSgpLnNwbGl0KCc9Jyk7XG5cbiAgICB1cmwucXVlcnlbcXVlcnlQYXJhbXNbMF1dID0gcXVlcnlQYXJhbXNbMV07XG4gICAgZGVsZXRlIHVybC5xdWVyeVsncGFnZSddO1xuXG4gICAgdGhpcy5fZ29Ub1VybChVcmwuZm9ybWF0KHsgcGF0aG5hbWU6IHVybC5wYXRobmFtZSwgcXVlcnk6IHVybC5xdWVyeSB9KSk7XG4gIH1cblxuICBfb25TdGF0ZUNoYW5nZShldmVudCkge1xuICAgIHRoaXMuY2FsbGJhY2tzLndpbGxVcGRhdGUoKTtcblxuICAgIGFwaS5nZXRQYWdlKEhpc3RvcnkuZ2V0U3RhdGUoKS51cmwsIHRoaXMub3B0aW9ucywgKGVyciwgY29udGVudCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgJCh0aGlzLm9wdGlvbnMuc2NvcGUucHJvZHVjdExpc3RpbmcpLmh0bWwoY29udGVudC5wcm9kdWN0TGlzdGluZyk7XG4gICAgICAgICQodGhpcy5vcHRpb25zLnNjb3BlLnNpZGViYXIpLmh0bWwoY29udGVudC5zaWRlYmFyKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuZGlkVXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX3Nhbml0aXplRmFjZXRzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfZ29Ub1VybCh1cmwpIHtcbiAgICBIaXN0b3J5LnB1c2hTdGF0ZSh7fSwgZG9jdW1lbnQudGl0bGUsIHVybCk7XG4gIH1cbn1cbiIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgc3ZnSWNvbiBmcm9tICcuL3N2Z0ljb24nXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlciB7XG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcbiAgICB0aGlzLiRib2R5ID0gJCgnYm9keScpO1xuICAgIHRoaXMuJHdyYXBwZXIgPSAkKCcuc2l0ZS13cmFwcGVyJyk7XG4gICAgdGhpcy4kc2VhcmNoV3JhcCA9ICQoJy5zZWFyY2gtd3JhcCcpO1xuICAgIHRoaXMuJGhlYWRlciA9ICQoJy5zaXRlLWhlYWRlcicpO1xuXG4gICAgdGhpcy4kdG9wQmFyID0gdGhpcy4kaGVhZGVyLmZpbmQoJy50b3AtYmFyJyk7XG4gICAgdGhpcy4kbmF2QmFyID0gdGhpcy4kaGVhZGVyLmZpbmQoJy5tYWluLW5hdi1iYXInKTtcblxuICAgIHRoaXMuY2FydE9wZW5DbGFzcyA9ICdtaW5pLWNhcnQtb3Blbic7XG4gICAgdGhpcy5zZWFyY2hPcGVuQ2xhc3MgPSAnc2VhcmNoLW9wZW4nO1xuICAgIHRoaXMubmF2T3BlbkNsYXNzID0gJ25hdi1tb2JpbGUtb3BlbiBzY3JvbGwtbG9ja2VkJztcblxuICAgIHRoaXMuJGxvZ2luUmVnaXN0ZXIgPSAkKCcubG9naW4tcmVnaXN0ZXItYmxvY2snKTtcbiAgICB0aGlzLiRmb3Jnb3RQYXNzd29yZCA9ICQoJy5mb3Jnb3QtcGFzc3dvcmQtYmxvY2snKTtcblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICB0aGlzLl9hZGp1c3RIZWlnaHRzKCk7XG4gICAgdGhpcy5faGVhZGVyU2Nyb2xsKCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICAvLyBUb2dnbGUgbWluaSBjYXJ0IHBhbmVsXG4gICAgdGhpcy4kZWwuZmluZCgnLmJ1dHRvbi1jYXJ0LXRvZ2dsZScpLm9uKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlTWluaUNhcnQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2UgbWluaSBjYXJ0IHBhbmVsXG4gICAgJCgnLmJ1dHRvbi1jYXJ0LWNsb3NlJykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlTWluaUNhcnQoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgJCgnLm9uLWNhbnZhcycpLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgIGlmICgkKCcubWluaS1jYXJ0LW9wZW4nKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlTWluaUNhcnQoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2UgVUkgZWxlbWV0cyB3aXRoIGVzYyBrZXlcbiAgICAkKGRvY3VtZW50KS5vbigna2V5dXAnLCAoZSkgPT4ge1xuICAgICAgLy8gTWluaSBjYXJ0XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAyNyAmJiB0aGlzLiRib2R5Lmhhc0NsYXNzKHRoaXMuY2FydE9wZW5DbGFzcykpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlTWluaUNhcnQoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWFyY2hcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3ICYmIHRoaXMuJHNlYXJjaFdyYXAuaGFzQ2xhc3ModGhpcy5zZWFyY2hPcGVuQ2xhc3MpKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVNlYXJjaChmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUb2dnbGUgc2VhcmNoXG4gICAgJCgnLmJ1dHRvbi1zZWFyY2gtdG9nZ2xlJykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlU2VhcmNoKCk7XG5cbiAgICAgIC8vIENsb3NlIGNhcnRcbiAgICAgIGlmICh0aGlzLiR3cmFwcGVyLmhhc0NsYXNzKHRoaXMuY2FydE9wZW5DbGFzcykpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlTWluaUNhcnQoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2UgU2VhcmNoXG4gICAgJCgnLmJ1dHRvbi1zZWFyY2gtY2xvc2UnKS5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLl90b2dnbGVTZWFyY2goZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgLy8gVG9nZ2xlIG1vYmlsZSBuYXZcbiAgICAkKCcuYnV0dG9uLW1vYmlsZS1uYXYtdG9nZ2xlJykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlTW9iaWxlTmF2KCk7XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgcmVzaXplIGV2ZW50cyBhbmQgcHJvdmlkZSBkZWJvdW5jZSB0byBwcmV2ZW50IHRvbyBtdWNoXG4gICAgdGhpcy5faGFuZGxlUmVzaXplID0gXy5kZWJvdW5jZSh0aGlzLl9oYW5kbGVSZXNpemUuYmluZCh0aGlzKSwgMjAwKTtcblxuICAgICQod2luZG93KS5yZXNpemUodGhpcy5faGFuZGxlUmVzaXplKTtcbiAgfVxuXG4gIF9oYW5kbGVSZXNpemUoKSB7XG4gICAgLy8gUmVzZXQgdGhlIG1vYmlsZSBwYW5lbCBpZiB3aW5kb3cgaXMgbWFkZSBsYXJnZXJcbiAgICB0aGlzLl9hZGp1c3RIZWlnaHRzKCk7XG5cbiAgICAvLyBDaGVjayBoZWFkZXIgaGVpZ2h0IG9uIHJlc2l6ZSBmb3IgY2xhc3MgYXBwbGljYXRpb25cbiAgICB0aGlzLl9oZWFkZXJTY3JvbGwoKTtcbiAgfVxuXG4gIF90b2dnbGVNaW5pQ2FydChvcGVuKSB7XG4gICAgLy8gUGFzcyBcImZhbHNlXCIgdG8gcmVtb3ZlIHRoZSBjbGFzcyAvIGNsb3NlIGNhcnRcbiAgICB0aGlzLiRib2R5LnRvZ2dsZUNsYXNzKHRoaXMuY2FydE9wZW5DbGFzcywgb3Blbik7XG4gIH1cblxuICBfdG9nZ2xlU2VhcmNoKG9wZW4pIHtcbiAgICB0aGlzLiRzZWFyY2hXcmFwLnRvZ2dsZUNsYXNzKHRoaXMuc2VhcmNoT3BlbkNsYXNzLCBvcGVuKTtcblxuICAgIGlmICh0aGlzLiRzZWFyY2hXcmFwLmhhc0NsYXNzKHRoaXMuc2VhcmNoT3BlbkNsYXNzKSkge1xuICAgICAgdGhpcy4kc2VhcmNoV3JhcC5maW5kKCcuc2VhcmNoLWlucHV0JykuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBfdG9nZ2xlTW9iaWxlTmF2KG9wZW4pIHtcbiAgICB0aGlzLiRib2R5LnRvZ2dsZUNsYXNzKHRoaXMubmF2T3BlbkNsYXNzLCBvcGVuKTtcblxuICAgIGlmIChvcGVuID09PSBmYWxzZSkge1xuICAgICAgJCgnLm5hdmlnYXRpb24tbW9iaWxlJykucmV2ZWFsZXIoJ2hpZGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCgnLm5hdmlnYXRpb24tbW9iaWxlJykucmV2ZWFsZXIoJ3RvZ2dsZScpO1xuICAgIH1cbiAgfVxuXG4gIF9oZWFkZXJTY3JvbGwoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5hdmlndGlvbiBoYXMgYSBzZWNvbmQgcm93LCBhbmQgZGlzYWxsb3cgXCJjb21wcmVzc2VkXCIgc3RhdGUgaWYgdHJ1ZVxuICAgIGNvbnN0IGRlZmF1bHROYXZiYXJIZWlnaHQgPSAxMDA7XG4gICAgY29uc3QgJGN1cnJlbnROYXZCYXIgPSB0aGlzLiRuYXZCYXIuZmluZCgnLm5hdmlnYXRpb24nKS5maW5kKCd1bDpmaXJzdC1jaGlsZCcpO1xuICAgIHZhciBjdXJyZW50TmF2QmFySGVpZ2h0ID0gJGN1cnJlbnROYXZCYXIub3V0ZXJIZWlnaHQoKTtcblxuICAgIGlmKGN1cnJlbnROYXZCYXJIZWlnaHQgPiBkZWZhdWx0TmF2YmFySGVpZ2h0KSB7XG4gICAgICB0aGlzLiRuYXZCYXIuYWRkQ2xhc3MoJ211bHRpLXJvdycpO1xuICAgICAgJGN1cnJlbnROYXZCYXIuYWRkQ2xhc3MoJ2VuZm9yY2UtbWF4LXdpZHRoJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJG5hdkJhci5yZW1vdmVDbGFzcygnbXVsdGktcm93Jyk7XG4gICAgICAkY3VycmVudE5hdkJhci5yZW1vdmVDbGFzcygnZW5mb3JjZS1tYXgtd2lkdGgnKTtcbiAgICB9XG5cbiAgICBjb25zdCAkd2luID0gJCh3aW5kb3cpO1xuLyogICAgIGNvbnN0IHRocmVzaG9sZCA9IDgwO1xuICAgIGNvbnN0IHNjcm9sbENsYXNzID0gJ2NvbXByZXNzZWQnO1xuXG4gICAgLy8gaWYgd2UgbG9hZCB0aGUgcGFnZSBwYXJ0IHdheSBkb3duXG4gICAgaWYgKCR3aW4uc2Nyb2xsVG9wKCkgPiB0aHJlc2hvbGQpIHtcbiAgICAgIHRoaXMuJGhlYWRlci5hZGRDbGFzcyhzY3JvbGxDbGFzcyk7XG4gICAgfVxuXG4gICAgJHdpbi5yZXNpemUoKCkgPT4ge1xuICAgICAgY29uc3QgY29tcHJlc3NIZWFkZXIgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnROYXZCYXJIZWlnaHQgPSAkY3VycmVudE5hdkJhci5vdXRlckhlaWdodCgpO1xuXG4gICAgICBpZiAoY3VycmVudE5hdkJhckhlaWdodCA+IGRlZmF1bHROYXZiYXJIZWlnaHQpIHtcbiAgICAgICAgdGhpcy4kaGVhZGVyLnRvZ2dsZUNsYXNzKHNjcm9sbENsYXNzLCBjb21wcmVzc0hlYWRlcik7XG4gICAgICB9XG4gICAgfSk7ICovXG5cbiAgICAvKiAkd2luLnNjcm9sbCgoKSA9PiB7XG4gICAgICBjb25zdCBzdCA9ICR3aW4uc2Nyb2xsVG9wKCk7XG4gICAgICBjb25zdCBjb21wcmVzc0hlYWRlciA9IChzdCA+IDApID8gdHJ1ZSA6IGZhbHNlOyAvLyBBbHdheXMgY29tcHJlc3MgaGVhZGVyIG9uIHNjcm9sbFxuICBcbiAgICAgIHRoaXMuJGhlYWRlci50b2dnbGVDbGFzcyhzY3JvbGxDbGFzcywgY29tcHJlc3NIZWFkZXIpO1xuICAgIH0pOyAqL1xuICB9XG5cbiAgX2FkanVzdEhlaWdodHMoKSB7XG4gICAgY29uc3QgJGNhbnZhcyA9IHRoaXMuJGJvZHkuZmluZCgnLnNpdGUtY2FudmFzJyk7XG4gICAgY29uc3QgZGVmYXVsdFRvcEJhckhlaWdodCA9IDU2O1xuICAgIGNvbnN0IHRvcEJhckhlaWdodCA9IHRoaXMuJHRvcEJhci5vdXRlckhlaWdodCgpO1xuICAgIGNvbnN0IGRlZmF1bHRGdWxsSGVhZGVySGVpZ2h0ID0gMTU2O1xuICAgIGNvbnN0IGN1cnJlbnRGdWxsSGVhZGVySGVpZ2h0ID0gdGhpcy4kaGVhZGVyLm91dGVySGVpZ2h0KCk7XG4gIFxuICAgIGlmICh0aGlzLiRoZWFkZXIuaGFzQ2xhc3MoJ2NvbXByZXNzZWQnKSkge1xuICAgICAgJGNhbnZhcy5jc3MoJ3BhZGRpbmctdG9wJywgZGVmYXVsdFRvcEJhckhlaWdodCArICdweCcpOyAvLyBSZW1vdmUgcGFkZGluZyB3aGVuIGhlYWRlciBpcyBjb21wcmVzc2VkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLiRuYXZCYXIuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICBpZiAodG9wQmFySGVpZ2h0ID4gZGVmYXVsdFRvcEJhckhlaWdodCkge1xuICAgICAgICAgICRjYW52YXMuY3NzKCdwYWRkaW5nLXRvcCcsIHRvcEJhckhlaWdodCArICdweCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRjYW52YXMuY3NzKCdwYWRkaW5nLXRvcCcsIGRlZmF1bHRUb3BCYXJIZWlnaHQgKyAncHgnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIHRvcCBiYXIgYW5kIHRoZSBtYWluIG5hdmlnYXRpb24gYmFyXG4gICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gdG9wQmFySGVpZ2h0ICsgdGhpcy4kbmF2QmFyLm91dGVySGVpZ2h0KCk7XG4gIFxuICAgICAgICAvLyBJZiB0aGUgdG90YWwgaGVpZ2h0IGV4Y2VlZHMgdGhlIGRlZmF1bHQgZnVsbCBoZWFkZXIgaGVpZ2h0LCByZWR1Y2UgdGhlIHRvcCBwYWRkaW5nIG9mIHRoZSBjYW52YXNcbiAgICAgICAgaWYgKHRvdGFsSGVpZ2h0ID4gZGVmYXVsdEZ1bGxIZWFkZXJIZWlnaHQpIHtcbiAgICAgICAgICAkY2FudmFzLmNzcygncGFkZGluZy10b3AnLCB0b3RhbEhlaWdodCArICdweCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRjYW52YXMuY3NzKCdwYWRkaW5nLXRvcCcsIGRlZmF1bHRGdWxsSGVhZGVySGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIGlmICh0b3BCYXJIZWlnaHQgPiBkZWZhdWx0VG9wQmFySGVpZ2h0KSB7XG4gICAgICBjb25zdCAkbW9iaWxlTmF2ID0gdGhpcy4kYm9keS5maW5kKCcubmF2aWdhdGlvbi1tb2JpbGUnKTtcbiAgICAgICRtb2JpbGVOYXYuY3NzKHsgJ3RvcCcgOiB0b3BCYXJIZWlnaHQgKyAncHgnIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgXG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBNZWdhTmF2IHtcclxuXHJcbiAgY29uc3RydWN0b3IoZWwpIHtcclxuXHJcbiAgICB0aGlzLiRlbCA9ICQoZWwpO1xyXG5cclxuICAgIHRoaXMuJHJvb3RNZW51ID0gdGhpcy4kZWwuZmluZCgnLm1lZ2EtbmF2LXJvb3QtbGlzdCcpO1xyXG5cclxuICAgIHRoaXMuJGNoaWxkQ29udGFpbmVyID0gdGhpcy4kZWwuZmluZCgnLm1lZ2EtbmF2LWNoaWxkLWNvbnRhaW5lcicpO1xyXG5cclxuICAgIHRoaXMuJGRyb3Bkb3duVG9nZ2xlID0gdGhpcy4kZWwuY2xvc2VzdCgnLmRyb3Bkb3duJykuZmluZCgnLmRyb3Bkb3duLXRvZ2dsZScpO1xyXG5cclxuXHJcblxyXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xyXG5cclxuICAgIHRoaXMuX2hpZGVBbGxDaGlsZHJlbih0cnVlKTtcclxuXHJcbiAgfVxyXG5cclxuXHJcblxyXG4gIF9iaW5kRXZlbnRzKCkge1xyXG4gICAgLy8gQ2hhbmdlIGV2ZW50IGZyb20gJ21vdXNlb3ZlcicgdG8gJ21vdXNlZW50ZXInIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcclxuICAgIHRoaXMuJGVsLm9uKCdtb3VzZWVudGVyJywgJ1tkYXRhLW1lZ2EtbmF2LXJvb3QtaXRlbV0nLCAoZSkgPT4ge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLl9maW5kQ2hpbGRGcm9tUm9vdChlKTtcclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWRkIGV2ZW50IHRvIHJlbW92ZSBob3ZlciBlZmZlY3Qgd2hlbiBtb3VzZSBsZWF2ZXMgdGhlIGVudGlyZSBuYXZpZ2F0aW9uIGFyZWFcclxuICAgIHRoaXMuJGVsLm9uKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xyXG4gICAgICAgIC8vIFJlbW92ZSBob3ZlciBlZmZlY3QgZnJvbSBhbGwgcm9vdCBpdGVtc1xyXG4gICAgICAgIHRoaXMuJGVsLmZpbmQoJ1tkYXRhLW1lZ2EtbmF2LXJvb3QtaXRlbV0nKS5yZW1vdmVDbGFzcygnaG92ZXJlZCcpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuICBfZmluZENoaWxkRnJvbVJvb3QoZSkge1xyXG5cclxuICAgIGlmICh0aGlzLmRyb3Bkb3duT3Blbikge1xyXG5cclxuICAgICAgdGhpcy5faGlkZUFsbENoaWxkcmVuKHRydWUpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIHRoaXMuZHJvcGRvd25PcGVuID0gdHJ1ZTtcclxuXHJcblxyXG5cclxuICAgIGNvbnN0ICRyb290SXRlbSA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHJcbiAgICBjb25zdCBjYXRlZ29yeUlkID0gJHJvb3RJdGVtLmRhdGEoJ2NhdGVnb3J5LWlkJyk7XHJcblxyXG4gICAgY29uc3QgJGNoaWxkTGlzdCA9IHRoaXMuJGVsLmZpbmQoJ1tkYXRhLXJvb3QtY2F0ZWdvcnktaWQ9XCInICsgY2F0ZWdvcnlJZCArICdcIl0nKTtcclxuXHJcblxyXG5cclxuICAgICRyb290SXRlbS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcblxyXG5cclxuXHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jaGlsZFRpbWVyKTtcclxuXHJcbiAgICB0aGlzLmNoaWxkVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuXHJcbiAgICAgICRjaGlsZExpc3QucmV2ZWFsZXIoJ3Nob3cnKTtcclxuXHJcbiAgICB9LCAxMDApO1xyXG5cclxuICB9XHJcblxyXG5cclxuXHJcbiAgX2ZpbmRDaGlsZChlKSB7XHJcblxyXG4gICAgaWYgKHRoaXMuZHJvcGRvd25PcGVuKSB7XHJcblxyXG4gICAgICB0aGlzLl9oaWRlQWxsQ2hpbGRyZW4odHJ1ZSk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgY29uc3QgJHRhcmdldCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHJcbiAgICBjb25zdCBjaGlsZElkID0gJHRhcmdldC5kYXRhKCdtZWdhLW5hdi1jaGlsZC1pZCcpO1xyXG5cclxuICAgIGNvbnN0ICRjaGlsZExpc3QgPSB0aGlzLiRjaGlsZENvbnRhaW5lci5maW5kKCdbZGF0YS1yb290LWNhdGVnb3J5LWlkPVwiJyArIGNoaWxkSWQgKyAnXCJdJyk7XHJcblxyXG5cclxuXHJcbiAgICAvLyBIaWRlIGFsbCBvdGhlciBjaGlsZCBjYXRlZ29yaWVzIGltbWVkaWF0ZWx5XHJcblxyXG4gICAgdGhpcy4kY2hpbGRDb250YWluZXIuZmluZCgnLm1lZ2EtbmF2LWNoaWxkLWxpc3QtY29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ3Zpc2libGUnKTtcclxuXHJcblxyXG5cclxuICAgIGlmICgkY2hpbGRMaXN0Lmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgIC8vIFNob3cgdGhlIHJlbGV2YW50IGNoaWxkIGNhdGVnb3J5IGFmdGVyIGEgc2hvcnQgZGVsYXlcclxuXHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNoaWxkVGltZXIpO1xyXG5cclxuICAgICAgdGhpcy5jaGlsZFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcblxyXG4gICAgICAgICRjaGlsZExpc3QuY2xvc2VzdCgnLm1lZ2EtbmF2LWNoaWxkLWxpc3QtY29udGFpbmVyJykuYWRkQ2xhc3MoJ3Zpc2libGUnKTtcclxuXHJcbiAgICAgIH0sIDEwMCk7IC8vIEFkanVzdCB0aGUgZGVsYXkgYXMgbmVlZGVkXHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgdGhpcy5kcm9wZG93bk9wZW4gPSB0cnVlO1xyXG5cclxuICB9XHJcblxyXG5cclxuXHJcblxyXG5cclxuICBfZmluZENoaWxkKGUpIHtcclxuXHJcbiAgICBjb25zdCAkdGFyZ2V0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xyXG5cclxuICAgIGNvbnN0IGNoaWxkSWQgPSAkdGFyZ2V0LmRhdGEoJ21lZ2EtbmF2LWNoaWxkLWlkJyk7XHJcblxyXG4gICAgY29uc3QgJGNoaWxkTGlzdCA9IHRoaXMuJGNoaWxkQ29udGFpbmVyLmZpbmQoJ1tkYXRhLXJvb3QtY2F0ZWdvcnktaWQ9XCInICsgY2hpbGRJZCArICdcIl0nKTtcclxuXHJcblxyXG5cclxuICAgIGlmICgkY2hpbGRMaXN0Lmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgIHRoaXMuX2hpZGVBbGxDaGlsZHJlbigpO1xyXG5cclxuICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4geyAkY2hpbGRMaXN0LnJldmVhbGVyKCdzaG93Jyk7IH0sIDUwMCk7XHJcblxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG5cclxuXHJcbiAgX2ZpbmRQYXJlbnQoZSkge1xyXG5cclxuICAgIGNvbnN0ICRtaW51cyA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHJcbiAgICBjb25zdCBwYXJlbnRJZCA9ICRtaW51cy5jbG9zZXN0KCcubWVnYS1uYXYtY2hpbGQtbGlzdC1jb250YWluZXInKS5kYXRhKCdyb290LWNhdGVnb3J5LWlkJyk7XHJcblxyXG4gICAgY29uc3QgJHBhcmVudCA9IHRoaXMuJGNoaWxkQ29udGFpbmVyLmZpbmQoJ1tkYXRhLW1lZ2EtbmF2LWNoaWxkLWlkPVwiJyArIHBhcmVudElkICsgJ1wiXScpLmNsb3Nlc3QoJy5tZWdhLW5hdi1jaGlsZC1saXN0LWNvbnRhaW5lcicpO1xyXG5cclxuXHJcblxyXG4gICAgaWYgKCRwYXJlbnQubGVuZ3RoID4gMCkge1xyXG5cclxuICAgICAgdGhpcy5faGlkZUFsbENoaWxkcmVuKCk7XHJcblxyXG4gICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7ICRwYXJlbnQucmV2ZWFsZXIoJ3Nob3cnKTsgfSwgNTAwKTtcclxuXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcblxyXG5cclxuICBfaGlkZUFsbENoaWxkcmVuKHJlbW92ZUFjdGl2ZSA9IGZhbHNlKSB7XHJcblxyXG4gICAgaWYgKHJlbW92ZUFjdGl2ZSkge1xyXG5cclxuICAgICAgdGhpcy4kZWwuZmluZCgnW2RhdGEtbWVnYS1uYXYtcm9vdC1pdGVtXScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy4kZWwuZmluZCgnLm1lZ2EtbmF2LWNoaWxkLWxpc3QtY29udGFpbmVyJykucmV2ZWFsZXIoJ2hpZGUnKTtcclxuXHJcbiAgfVxyXG5cclxuXHJcblxyXG4gIF9hZGp1c3RNZWdhTmF2UGFuZWwoKSB7XHJcblxyXG4gICAgY29uc3QgJGRyb3Bkb3duID0gdGhpcy4kZHJvcGRvd25Ub2dnbGUuY2xvc2VzdCgnLmRyb3Bkb3duJyk7XHJcblxyXG4gICAgY29uc3QgJG1lZ2FOYXZQYW5lbCA9ICRkcm9wZG93blRvZ2dsZS5maW5kKCcubWVnYS1uYXYtcGFuZWwnKTtcclxuXHJcblxyXG5cclxuICAgIGlmICgkZHJvcGRvd24ubGVuZ3RoID4gMCAmJiAkbWVnYU5hdlBhbmVsLmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgIGNvbnN0IG9mZnNldCA9ICRkcm9wZG93bi5vZmZzZXQoKS50b3AgKyAkZHJvcGRvd24ub3V0ZXJIZWlnaHQoKTtcclxuXHJcblxyXG5cclxuICAgICAgJG1lZ2FOYXZQYW5lbC5jc3MoeyAndG9wJzogb2Zmc2V0ICsgJ3B4JyB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbn1cbiIsImltcG9ydCB1dGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XG5pbXBvcnQgc3ZnSWNvbiBmcm9tICcuL3N2Z0ljb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNaW5pQ2FydCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FydENoYW5nZVJlbW90ZUhvb2tzID0gW1xuICAgICAgJ2NhcnQtaXRlbS1hZGQtcmVtb3RlJyxcbiAgICAgICdjYXJ0LWl0ZW0tdXBkYXRlLXJlbW90ZScsXG4gICAgICAnY2FydC1pdGVtLXJlbW92ZS1yZW1vdGUnLFxuICAgIF07XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICAvLyBVcGRhdGUgbWluaWNhcnQgb24gc3VjY2Vzc2Z1bCBhZGQgdG8gY2FydFxuICAgICQoZG9jdW1lbnQpLm9uKCdjYXJ0LWl0ZW0tYWRkLXN1Y2Nlc3MnLCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSBjYXJ0IGl0ZW0gdXNpbmcgbWluaWNhcnQgYnV0dG9uXG4gICAgJCgnYm9keScpLm9uKCdjbGljaycsICcubWluaS1jYXJ0IFtkYXRhLWNhcnQtaXRlbS1yZW1vdmVdJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVQcm9kdWN0TWluaUNhcnQoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3RlIGV2ZW50czogd2hlbiB0aGUgcHJvcGVyIHJlc3BvbnNlIGlzIHNlbnRcbiAgICB0aGlzLmNhcnRDaGFuZ2VSZW1vdGVIb29rcy5mb3JFYWNoKChob29rKSA9PiB7XG4gICAgICB1dGlscy5ob29rcy5vbihob29rLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDdXN0b20gc2Nyb2xsIFVYIGZvciBtaW5pY2FydFxuICAgIHRoaXMuX2JpbmRTY3JvbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG1pbmkgY2FydCBjb250ZW50c1xuICAgKi9cbiAgX3VwZGF0ZShjYWxsYmFjaykge1xuICAgIGNvbnN0ICRtaW5pQ2FydCA9ICQoJy5taW5pLWNhcnQtaW5uZXInKTtcblxuICAgIGNvbnN0ICRtaW5pQ2FydFRvdGFsID0gJCgnLnNpdGUtaGVhZGVyIC5taW5pLWNhcnQtc3VidG90YWwnKTtcbiAgICBjb25zdCAkbWluaUNhcnRDb250ZW50cyA9ICQoJy5taW5pLWNhcnQtY29udGVudHMnKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgbWluaWNhcnQgaXRlbXMgd2hlblxuICAgIC8vIGEgcHJvZHVjdCBpcyBhZGRlZCAvIHJlbW92ZWRcbiAgICB1dGlscy5hcGkuY2FydC5nZXRDb250ZW50KHsgdGVtcGxhdGU6ICdtaW5pLWNhcnQvbWluaS1jYXJ0LWNvbnRlbnRzJyB9LCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgJG1pbmlDYXJ0Q29udGVudHMuaHRtbChyZXNwb25zZSk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgaGVhZGVyIHN1YnRvdGFsXG4gICAgICBjb25zdCBzdWJ0b3RhbCA9ICQocmVzcG9uc2UpLmZpbmQoJ1tkYXRhLWNhcnQtc3VidG90YWxdJykudGV4dCgpO1xuICAgICAgY29uc3Qgc3VidG90YWxSYXcgPSAkKHJlc3BvbnNlKS5maW5kKCcubWluaS1jYXJ0LXN1YnRvdGFsJykuYXR0cignZGF0YS1jYXJ0LXN1YnRvdGFsJyk7XG4gICAgICAkbWluaUNhcnRUb3RhbC5odG1sKHN1YnRvdGFsKS5hdHRyKCdkYXRhLWNhcnQtc3VidG90YWwnLCBzdWJ0b3RhbFJhdyk7XG5cbiAgICAgICRtaW5pQ2FydC5hbmltYXRlKHtcbiAgICAgICAgdG9wOiAwXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgcHJvZHVjdCBmcm9tIHRoZSBtaW5pIGNhcnRcbiAgICovXG4gIF9yZW1vdmVQcm9kdWN0TWluaUNhcnQoZXZlbnQpIHtcbiAgICBjb25zdCAkZWwgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0IGl0ZW1JZCA9ICRlbC5kYXRhKCdwcm9kdWN0LWlkJyk7XG5cbiAgICBpZiAoISBpdGVtSWQpIHsgcmV0dXJuOyB9XG5cbiAgICAkZWxcbiAgICAgIC5jbG9zZXN0KCcubWluaS1jYXJ0LWl0ZW0nKVxuICAgICAgLmFkZENsYXNzKCdyZW1vdmluZycpXG4gICAgICAuYXBwZW5kKGAke3N2Z0ljb24oJ3NwaW5uZXInKX1gKTtcblxuICAgIHV0aWxzLmFwaS5jYXJ0Lml0ZW1SZW1vdmUoaXRlbUlkLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSAnc3VjY2VlZCcpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGVydChyZXNwb25zZS5kYXRhLmVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICRlbFxuICAgICAgICAgIC5jbG9zZXN0KCcubWluaS1jYXJ0LWl0ZW0nKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcygncmVtb3ZpbmcnKVxuICAgICAgICAgIC5maW5kKCcuaWNvbi1zcGlubmVyJylcbiAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3VzdG9tIHNjcm9sbCBiZWhhdmlvciBmb3IgbWluaSBjYXJ0IHBhbmVsXG4gICAqL1xuICBfYmluZFNjcm9sbCgpIHtcbiAgICBjb25zdCAkd2luID0gJCh3aW5kb3cpO1xuICAgIGNvbnN0ICRtaW5pQ2FydCA9ICQoJy5taW5pLWNhcnQtaW5uZXInKTtcbiAgICBsZXQgb2xkU2Nyb2xsVG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXG4gICAgJHdpbi5vbignc2Nyb2xsJywgKCkgPT4ge1xuICAgICAgY29uc3Qgd2luSGVpZ2h0ID0gJHdpbi5oZWlnaHQoKTtcbiAgICAgIGNvbnN0IG1pbmlDYXJ0SGVpZ2h0ID0gJG1pbmlDYXJ0LmhlaWdodCgpO1xuICAgICAgY29uc3QgbWF4U2Nyb2xsID0gbWluaUNhcnRIZWlnaHQgLSB3aW5IZWlnaHQ7XG4gICAgICBjb25zdCBuZXdTY3JvbGxUb3AgPSAkd2luLnNjcm9sbFRvcCgpO1xuXG4gICAgICBsZXQgY2FydFRvcFBvcyA9IHBhcnNlSW50KCRtaW5pQ2FydC5jc3MoJ3RvcCcpKTtcbiAgICAgIGxldCBzY3JvbGxBbW91bnQ7XG5cbiAgICAgIC8vIElmIHRoZSBtZW51IGlzIHRhbGxlciB0aGFuIHRoZSB3aW5kb3cgYW5kIHZpc2libGVcbiAgICAgIGlmICggKG1pbmlDYXJ0SGVpZ2h0ID4gd2luSGVpZ2h0KSAmJiAkKCdib2R5JykuaGFzQ2xhc3MoJ21pbmktY2FydC1vcGVuJykgKSB7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBhbW91bnQgd2UndmUgc2Nyb2xsZWRcbiAgICAgICAgc2Nyb2xsQW1vdW50ID0gb2xkU2Nyb2xsVG9wIC0gbmV3U2Nyb2xsVG9wO1xuXG4gICAgICAgIC8vIE1vdmUgdGhlIG1pbmljYXJ0IHVwL2Rvd24gdGhlIGFtb3VudCB3ZSBzY3JvbGxlZFxuICAgICAgICAkbWluaUNhcnQuY3NzKHtcbiAgICAgICAgICB0b3A6ICcrPScgKyBzY3JvbGxBbW91bnQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEdldCB0aGUgbWluaWNhcnQncyB0b3AgdmFsdWUgYWZ0ZXIgaXQncyB1cGRhdGVkXG4gICAgICAgIGNhcnRUb3BQb3MgPSBwYXJzZUludCgkbWluaUNhcnQuY3NzKCd0b3AnKSk7XG5cbiAgICAgICAgLy8gRG9uJ3Qgc2Nyb2xsIGJleW9uZCB0aGUgYm90dG9tIG9yIHRvcCBsaW1pdHMgb2YgdGhlIG1lbnVcbiAgICAgICAgLy8gVGhlIHNlY29uZCBjb25kaXRvbiBjaGVja3MgZm9yICdvdmVyc2Nyb2xsJyB0aGF0IG9jY3VycyBpbiB3ZWJraXRcbiAgICAgICAgaWYgKCAoY2FydFRvcFBvcyA8IC1tYXhTY3JvbGwpIHx8ICgobmV3U2Nyb2xsVG9wICsgd2luSGVpZ2h0KSA+PSAkKCcuc2l0ZS13cmFwcGVyJykub3V0ZXJIZWlnaHQoKSkgKSB7XG4gICAgICAgICAgLy8gc3RvcCBhdCBib3R0b20gb2YgbWluaWNhcnRcbiAgICAgICAgICAkbWluaUNhcnQuY3NzKHtcbiAgICAgICAgICAgIHRvcDogLW1heFNjcm9sbCArICdweCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICggY2FydFRvcFBvcyA+IDAgfHwgbmV3U2Nyb2xsVG9wIDw9IDAgKSB7XG4gICAgICAgICAgLy8gc3RvcCBhdCB0b3Agb2YgbWluaWNhcnRcbiAgICAgICAgICAkbWluaUNhcnQuY3NzKHtcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBvbGRTY3JvbGxUb3AgYXMgd2Ugc2Nyb2xsXG4gICAgICBvbGRTY3JvbGxUb3AgPSBuZXdTY3JvbGxUb3A7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2JpbGVOYXYge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy4kYm9keSA9ICQoJ2JvZHknKTtcclxuICAgIHRoaXMubmF2VG9nZ2xlID0gJCgnLmJ1dHRvbi1tb2JpbGUtbmF2LXRvZ2dsZScpO1xyXG4gICAgdGhpcy5wYWdlQ292ZXIgPSAkKCcuc2l0ZS13cmFwcGVyJyk7XHJcbiAgICB0aGlzLiRtZW51ID0gJCgnLm5hdmlnYXRpb24nKTtcclxuICAgIHRoaXMuJG5hdkJhY2tCdXR0b24gPSAkKCcuYnV0dG9uLW1vYmlsZS1uYXYtYmFjaycpO1xyXG4gICAgdGhpcy5nZXRNZW51cyA9ICh0YXJnZXRNZW51KSA9PiB7XHJcbiAgICAgIHJldHVybiAkKGBbZGF0YS1tb2JpbGUtbWVudT1cIiR7dGFyZ2V0TWVudX1cIl1gKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5uYXZQYW5lbCA9ICcubmF2LW1vYmlsZS1wYW5lbCc7XHJcbiAgICB0aGlzLmNsYXNzZXMgPSB7XHJcbiAgICAgIGFjdGl2ZTogJ2lzLWFjdGl2ZScsXHJcbiAgICAgIGxlZnQ6ICdpcy1sZWZ0JyxcclxuICAgICAgcmlnaHQ6ICdpcy1yaWdodCcsXHJcbiAgICAgIGZvcmNlU3RhdGU6ICdmb3JjZS1zdGF0ZScsXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMubWVudVN0YXRlID0gW107XHJcblxyXG4gICAgdGhpcy5faW5pdE1vYmlsZSgpO1xyXG4gICAgdGhpcy5fYmluZE1vYmlsZUV2ZW50cygpO1xyXG4gIH1cclxuXHJcbiAgX2luaXRNb2JpbGUoKSB7XHJcbiAgICAkKCcubmF2LW1vYmlsZS1pdGVtLXBhcmVudCcpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XHJcbiAgICAgIGxldCAkY2hpbGRyZW4gPSAkKGVsZW1lbnQpLmNoaWxkcmVuKCcubmF2LW1vYmlsZS1wYW5lbCcpO1xyXG4gICAgICBsZXQgY291bnRlciA9IDE7XHJcblxyXG4gICAgICB3aGlsZSAoJGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICRjaGlsZHJlbi5hdHRyKCdkYXRhLXBhbmVsLWRlcHRoJywgY291bnRlcikuaW5zZXJ0QWZ0ZXIoJCgnLm5hdi1tb2JpbGUtcGFuZWwtcGFyZW50JykpO1xyXG4gICAgICAgICRjaGlsZHJlbiA9ICRjaGlsZHJlbi5jaGlsZHJlbigpLmNoaWxkcmVuKCcubmF2LW1vYmlsZS1wYW5lbCcpO1xyXG4gICAgICAgIGNvdW50ZXIgKz0gMTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfYmluZE1vYmlsZUV2ZW50cygpIHtcclxuICAgICQoJy5uYXYtbW9iaWxlLWl0ZW0uaGFzLWNoaWxkcmVuJykub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHRoaXMuX3RyYXZlcnNlRG93bihldmVudCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLiRuYXZCYWNrQnV0dG9uLm9uKCdjbGljaycsIChldmVudCkgPT4ge1xyXG4gICAgICB0aGlzLl90cmF2ZXJzZUJhY2soKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3RyYXZlcnNlRG93bihldmVudCkge1xyXG4gICAgY29uc3QgdGFyZ2V0TWVudSA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuY2hpbGRyZW4oKS5kYXRhKCd0b2dnbGUtbW9iaWxlJyk7XHJcbiAgICB0aGlzLiRib2R5LmFkZENsYXNzKCdtb2JpbGUtbmF2LW9wZW4nKTtcclxuXHJcbiAgICAvLyBNb3ZlIHByZXZpb3VzIGFjdGl2ZSB0byB0aGUgbGVmdFxyXG4gICAgJChldmVudC5jdXJyZW50VGFyZ2V0KVxyXG4gICAgICAuY2xvc2VzdCh0aGlzLm5hdlBhbmVsKVxyXG4gICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmxlZnQpXHJcbiAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMuYWN0aXZlKTtcclxuXHJcbiAgICAvLyBBY3RpdmUgbmV3IG1lbnUgYW5kIG1vdmUgaW50byBwbGFjZSBmcm9tIHJpZ2h0XHJcbiAgICB0aGlzLmdldE1lbnVzKHRhcmdldE1lbnUpXHJcbiAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMucmlnaHQpXHJcbiAgICAgIC5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuYWN0aXZlKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIGJhY2sgYnV0dG9uIGlkXHJcbiAgICBjb25zdCBwcmV2TWVudSA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkucGFyZW50cygnLm5hdi1tb2JpbGUtcGFuZWwnKS5kYXRhKCdtb2JpbGUtbWVudScpO1xyXG4gICAgdGhpcy5tZW51U3RhdGUucHVzaChwcmV2TWVudSk7XHJcblxyXG4gIH1cclxuXHJcbiAgX3RyYXZlcnNlQmFjaygpIHtcclxuICAgIC8vIE1vdmUgcHJldmlvdXMgYWN0aXZlIHRvIHRoZSByaWdodFxyXG4gICAgJCh0aGlzLm5hdlBhbmVsKVxyXG4gICAgICAuZmlsdGVyKGAuJHt0aGlzLmNsYXNzZXMuYWN0aXZlfWApXHJcbiAgICAgIC5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMuYWN0aXZlKVxyXG4gICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnJpZ2h0KTtcclxuXHJcbiAgICAvLyBQb3NpdGlvbiBuZXcgYWN0aXZlIG1lbnUgZnJvbSB0aGUgbGVmdFxyXG4gICAgY29uc3QgdGFyZ2V0TWVudSA9IHRoaXMubWVudVN0YXRlLnBvcCgpO1xyXG5cclxuICAgIHRoaXMuZ2V0TWVudXModGFyZ2V0TWVudSlcclxuICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy5sZWZ0KVxyXG4gICAgICAuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmFjdGl2ZSk7XHJcblxyXG4gICAgaWYgKHRhcmdldE1lbnUgPT09ICdhbGwnKSB7XHJcbiAgICAgIHRoaXMuJGJvZHkucmVtb3ZlQ2xhc3MoJ21vYmlsZS1uYXYtb3BlbicpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gICQoJy5wcm9kdWN0LWl0ZW0tcmF0aW5nLWZhY2V0LmZ1bGwnKVxuICAgIC5wcmV2QWxsKCcucHJvZHVjdC1pdGVtLXJhdGluZy1mYWNldCcpXG4gICAgLmFkZENsYXNzKCdmdWxsJyk7XG59XG4iLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFByb2R1Y3RDb21wYXJlIGZyb20gJ2JjLWNvbXBhcmUnO1xuaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi9zdmdJY29uJztcblxuY29uc3QgY29tcGFyZSA9IG5ldyBQcm9kdWN0Q29tcGFyZSh7XG4gIG1heEl0ZW1zOiA0LFxuICBpdGVtVGVtcGxhdGU6IF8udGVtcGxhdGUoYFxuICAgIDxsaSBjbGFzcz1cImNvbXBhcmUtdGFiLWl0ZW1cIiBkYXRhLWNvbXBhcmUtaXRlbT5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb21wYXJlLXRhYi1pdGVtLXdyYXBcIj5cbiAgICAgICAgPGEgY2xhc3M9XCJjb21wYXJlLXRhYi1pdGVtLXJlbW92ZVwiIGRhdGEtY29tcGFyZS1pdGVtLXJlbW92ZT1cIjwlPSBpZCAlPlwiPiR7c3ZnSWNvbignY2xvc2UnKX08L2E+XG4gICAgICAgIDxhIGhyZWY9XCI8JT0gdXJsICU+XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbXBhcmUtdGFiLWl0ZW0tdGh1bWJcIiBzdHlsZT1cImJhY2tncm91bmQtaW1hZ2U6IHVybCg8JT0gdGh1bWJuYWlsICU+KVwiPjwvZGl2PlxuICAgICAgICA8L2E+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbXBhcmUtdGFiLWl0ZW0tZGVzY3JpcHRpb25cIj5cbiAgICAgICAgICA8YSBocmVmPVwiPCU9IHVybCAlPlwiIGNsYXNzPVwiY29tcGFyZS10YWItaXRlbS10aXRsZVwiPjwlPSB0aXRsZSAlPjwvYT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29tcGFyZS10YWItaXRlbS1wcmljZVwiPjwlPSBwcmljZSAlPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvbGk+XG4gIGApLFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0Q29tcGFyZSgpIHtcbiAgY29tcGFyZS5vbigndXBkYXRlZCcsICgpID0+IHtcbiAgICAkKCcuY29tcGFyZS1pdGVtcy1jb3VudCcpLnRleHQoY29tcGFyZS5jb21wYXJlTGlzdC5zaXplKTtcblxuICAgIGlmIChjb21wYXJlLmNvbXBhcmVMaXN0LnNpemUgPiAwKSB7XG4gICAgICAkKCdbZGF0YS1jb21wYXJlLXdpZGdldF0sIC5tb2JpbGUtY29tcGFyZS1saW5rJykuYWRkQ2xhc3MoJ2NvbXBhcmUtYWN0aXZlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoJ1tkYXRhLWNvbXBhcmUtd2lkZ2V0XSwgLm1vYmlsZS1jb21wYXJlLWxpbmsnKS5yZW1vdmVDbGFzcygnY29tcGFyZS1hY3RpdmUnKTtcbiAgICB9XG4gIH0sIHRydWUpO1xuXG4gICQoJ1tkYXRhLWNvbXBhcmUtcmVtb3ZlLWFsbF0nKS5vbignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbXBhcmUucmVtb3ZlQWxsKCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ29tcGFyZSgpIHtcbiAgY29tcGFyZS51cGRhdGVDaGVja2JveGVzKCk7XG59XG4iLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgdXRpbHMgZnJvbSAnQGJpZ2NvbW1lcmNlL3N0ZW5jaWwtdXRpbHMnO1xyXG5cclxuY2xhc3MgUXVpY2tTZWFyY2gge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5kZWJvdW5jZVdhaXRUaW1lID0gMzAwOyAvLyBBZGp1c3QgZGVib3VuY2UgdGltZSBhcyBuZWVkZWRcclxuICAgICAgICB0aGlzLiRxdWlja1NlYXJjaFJlc3VsdHMgPSAkKCcucXVpY2tTZWFyY2hSZXN1bHRzJyk7XHJcbiAgICAgICAgdGhpcy4kcXVpY2tTZWFyY2hGb3JtcyA9ICQoJ1tkYXRhLXF1aWNrLXNlYXJjaC1mb3JtXScpO1xyXG4gICAgICAgIHRoaXMuJHNlYXJjaFF1ZXJ5ID0gdGhpcy4kcXVpY2tTZWFyY2hGb3Jtcy5maW5kKCdbZGF0YS1zZWFyY2gtcXVpY2tdJyk7XHJcbiAgICAgICAgdGhpcy4kcXVpY2tTZWFyY2hBcmlhTWVzc2FnZSA9ICQoJy5hcmlhLWRlc2NyaXB0aW9uLS1oaWRkZW4nKTtcclxuICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdHNWaXNpYmxlID0gZmFsc2U7IC8vIFRyYWNrIGlmIHNlYXJjaCByZXN1bHRzIGFyZSB2aXNpYmxlXHJcblxyXG4gICAgICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBfYmluZEV2ZW50cygpIHtcclxuICAgICAgICBjb25zdCBkb1NlYXJjaCA9IF8uZGVib3VuY2UoKHNlYXJjaFF1ZXJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hRdWVyeS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoUmVzdWx0cy5lbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kcXVpY2tTZWFyY2hBcmlhTWVzc2FnZS5lbXB0eSgpOyAvLyBDbGVhciBhcmlhLWxpdmUgcmVnaW9uXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdHNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHV0aWxzLmFwaS5zZWFyY2guc2VhcmNoKHNlYXJjaFF1ZXJ5LCB7IHRlbXBsYXRlOiAnc2VhcmNoL3F1aWNrLXJlc3VsdHMnIH0sIChlcnIsIHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoUmVzdWx0cy5odG1sKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICRxdWlja1NlYXJjaFJlc3VsdHNDdXJyZW50ID0gdGhpcy4kcXVpY2tTZWFyY2hSZXN1bHRzLmZpbHRlcignOnZpc2libGUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCAkbm9SZXN1bHRzTWVzc2FnZSA9ICRxdWlja1NlYXJjaFJlc3VsdHNDdXJyZW50LmZpbmQoJy5xdWlja1NlYXJjaE1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICAgIGlmICgkbm9SZXN1bHRzTWVzc2FnZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAkbm9SZXN1bHRzTWVzc2FnZS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3N0YXR1cycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJyxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRxdWlja1NlYXJjaEFyaWFNZXNzYWdlLmVtcHR5KCk7IC8vIENsZWFyIGFyaWEtbGl2ZSByZWdpb25cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcXVpY2tTZWFyY2hBcmlhTWVzc2FnZS5hZGRDbGFzcygndS1oaWRkZW4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZGVmaW5lZFRleHQgPSB0aGlzLiRxdWlja1NlYXJjaEFyaWFNZXNzYWdlLmRhdGEoJ3NlYXJjaC1hcmlhLW1lc3NhZ2UtcHJlZGVmaW5lZC10ZXh0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbXNGb3VuZENvdW50ID0gJHF1aWNrU2VhcmNoUmVzdWx0c0N1cnJlbnQuZmluZCgnLnByb2R1Y3QnKS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoQXJpYU1lc3NhZ2UudGV4dChgJHtpdGVtc0ZvdW5kQ291bnR9ICR7cHJlZGVmaW5lZFRleHR9ICR7c2VhcmNoUXVlcnl9YCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRxdWlja1NlYXJjaEFyaWFNZXNzYWdlLnJlbW92ZUNsYXNzKCd1LWhpZGRlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdHNWaXNpYmxlID0gdHJ1ZTsgLy8gTWFyayBzZWFyY2ggcmVzdWx0cyBhcyB2aXNpYmxlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIHRoaXMuZGVib3VuY2VXYWl0VGltZSk7XHJcblxyXG4gICAgICAgIHRoaXMuJHNlYXJjaFF1ZXJ5Lm9uKCdpbnB1dCcsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hRdWVyeSA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkudmFsKCk7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hRdWVyeS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoUmVzdWx0cy5lbXB0eSgpOyAvLyBIaWRlIHJlc3VsdHMgaWYgaW5wdXQgaXMgY2xlYXJlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy4kcXVpY2tTZWFyY2hBcmlhTWVzc2FnZS5lbXB0eSgpOyAvLyBDbGVhciBhcmlhLWxpdmUgcmVnaW9uXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdHNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKCdzZWFyY2gtcXVpY2snLCBldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdXRpbHMuaG9va3Mub24oJ3NlYXJjaC1xdWljaycsIChldmVudCwgY3VycmVudFRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hRdWVyeSA9ICQoY3VycmVudFRhcmdldCkudmFsKCk7XHJcbiAgICAgICAgICAgIGRvU2VhcmNoKHNlYXJjaFF1ZXJ5KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gSGlkZSBzZWFyY2ggcmVzdWx0cyB3aGVuIGNsaWNraW5nIG91dHNpZGVcclxuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCEkKGV2ZW50LnRhcmdldCkuY2xvc2VzdCh0aGlzLiRxdWlja1NlYXJjaEZvcm1zKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHF1aWNrU2VhcmNoUmVzdWx0cy5lbXB0eSgpOyAvLyBIaWRlIHJlc3VsdHNcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoUmVzdWx0c1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBTaG93IHNlYXJjaCByZXN1bHRzIHdoZW4gZm9jdXNpbmcgb24gdGhlIHNlYXJjaCBiYXJcclxuICAgICAgICB0aGlzLiRzZWFyY2hRdWVyeS5vbignZm9jdXMnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VhcmNoUmVzdWx0c1Zpc2libGUgJiYgdGhpcy4kc2VhcmNoUXVlcnkudmFsKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoUXVlcnkgPSB0aGlzLiRzZWFyY2hRdWVyeS52YWwoKTtcclxuICAgICAgICAgICAgICAgIGRvU2VhcmNoKHNlYXJjaFF1ZXJ5KTsgLy8gUmUtZmV0Y2ggdGhlIHJlc3VsdHNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBRdWlja1NlYXJjaDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGljb25DbGFzcykge1xuICByZXR1cm4gYDxzdmcgY2xhc3M9XCJpY29uIGljb24tJHtpY29uQ2xhc3N9XCI+PHVzZSB4bGluazpocmVmPVwiI2ljb24tJHtpY29uQ2xhc3N9XCIgLz48L3N2Zz5gXG59O1xuIiwiaW1wb3J0IHN2Z0ljb24gZnJvbSAnLi9zdmdJY29uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGNvbnN0ICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICBjb25zdCAkdHJpZ2dlciA9ICR0YXJnZXQuZmluZCgnLmZhY2V0LWxpc3QtdG9nZ2xlJyk7XG5cbiAgJHRhcmdldFxuICAgIC5wYXJlbnRzKCdbZGF0YS1mYWNldC1maWx0ZXJdJylcbiAgICAuY2hpbGRyZW4oJ1tkYXRhLWZhY2V0LWZpbHRlci13cmFwcGVyXScpXG4gICAgLnRvZ2dsZUNsYXNzKCdpcy1vcGVuJyk7XG5cbiAgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xuICAgICR0cmlnZ2VyLmh0bWwoc3ZnSWNvbignbWludXMnKSk7XG4gIH0gZWxzZSB7XG4gICAgJHRyaWdnZXIuaHRtbChzdmdJY29uKCdwbHVzJykpO1xuICB9XG5cbiAgJHRhcmdldC50b2dnbGVDbGFzcygnaXMtb3BlbicpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlc0hlbHBlciB7XG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlcyhkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGJlaGF2aW9yID0gZGF0YS5vdXRfb2Zfc3RvY2tfYmVoYXZpb3I7XG4gICAgY29uc3QgaW5TdG9ja0lkcyA9IGRhdGEuaW5fc3RvY2tfYXR0cmlidXRlcztcbiAgICBjb25zdCBvdXRPZlN0b2NrTWVzc2FnZSA9IGAgKCR7ZGF0YS5vdXRfb2Zfc3RvY2tfbWVzc2FnZX0pYDtcblxuICAgIGlmIChiZWhhdmlvciAhPT0gJ2hpZGVfb3B0aW9uJyAmJiBiZWhhdmlvciAhPT0gJ2xhYmVsX29wdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAkKCdbZGF0YS1wcm9kdWN0LWF0dHJpYnV0ZS12YWx1ZV0nLCAkKCdib2R5JykuZmluZCh0aGlzLmVsKSkuZWFjaCgoaSwgYXR0cmlidXRlKSA9PiB7XG4gICAgICBjb25zdCAkYXR0cmlidXRlID0gJChhdHRyaWJ1dGUpO1xuICAgICAgY29uc3QgYXR0cklkID0gcGFyc2VJbnQoJGF0dHJpYnV0ZS5kYXRhKCdwcm9kdWN0LWF0dHJpYnV0ZS12YWx1ZScpLCAxMCk7XG5cbiAgICAgIGlmIChpblN0b2NrSWRzLmluZGV4T2YoYXR0cklkKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5lbmFibGVBdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZUF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGlzYWJsZUF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGVUeXBlKCRhdHRyaWJ1dGUpID09PSAnc2V0LXNlbGVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc2FibGVTZWxlY3RPcHRpb25BdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBpZiAoYmVoYXZpb3IgPT09ICdoaWRlX29wdGlvbicpIHtcbiAgICAgICRhdHRyaWJ1dGUuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkYXR0cmlidXRlLmFkZENsYXNzKCdvcHRpb24tdW5hdmFpbGFibGUnKTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlU2VsZWN0T3B0aW9uQXR0cmlidXRlKCRhdHRyaWJ1dGUsIGJlaGF2aW9yLCBvdXRPZlN0b2NrTWVzc2FnZSkge1xuICAgIGlmIChiZWhhdmlvciA9PT0gJ2hpZGVfb3B0aW9uJykge1xuICAgICAgJGF0dHJpYnV0ZS50b2dnbGVPcHRpb24oZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkYXR0cmlidXRlLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAkYXR0cmlidXRlLmh0bWwoJGF0dHJpYnV0ZS5odG1sKCkucmVwbGFjZShvdXRPZlN0b2NrTWVzc2FnZSwgJycpICsgb3V0T2ZTdG9ja01lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGVuYWJsZUF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGVUeXBlKCRhdHRyaWJ1dGUpID09PSAnc2V0LXNlbGVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuYWJsZVNlbGVjdE9wdGlvbkF0dHJpYnV0ZSgkYXR0cmlidXRlLCBiZWhhdmlvciwgb3V0T2ZTdG9ja01lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAoYmVoYXZpb3IgPT09ICdoaWRlX29wdGlvbicpIHtcbiAgICAgICRhdHRyaWJ1dGUuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkYXR0cmlidXRlLnJlbW92ZUNsYXNzKCdvcHRpb24tdW5hdmFpbGFibGUnKTtcbiAgICB9XG4gIH1cblxuICBlbmFibGVTZWxlY3RPcHRpb25BdHRyaWJ1dGUoJGF0dHJpYnV0ZSwgYmVoYXZpb3IsIG91dE9mU3RvY2tNZXNzYWdlKSB7XG4gICAgaWYgKGJlaGF2aW9yID09PSAnaGlkZV9vcHRpb24nKSB7XG4gICAgICAkYXR0cmlidXRlLnRvZ2dsZU9wdGlvbih0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGF0dHJpYnV0ZS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgJGF0dHJpYnV0ZS5odG1sKCRhdHRyaWJ1dGUuaHRtbCgpLnJlcGxhY2Uob3V0T2ZTdG9ja01lc3NhZ2UsICcnKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QXR0cmlidXRlVHlwZSgkYXR0cmlidXRlKSB7XG4gICAgY29uc3QgJHBhcmVudCA9ICRhdHRyaWJ1dGUuY2xvc2VzdCgnW2RhdGEtcHJvZHVjdC1hdHRyaWJ1dGVdJyk7XG4gICAgcmV0dXJuICRwYXJlbnQgPyAkcGFyZW50LmRhdGEoJ3Byb2R1Y3QtYXR0cmlidXRlJykgOiBudWxsO1xuICB9XG59XG5cbiIsIi8qKlxuICogIEF0dGFjaCBmdW5jdGlvbmFsaXR5IHRvIENvbG9yIFN3YXRjaGVzXG4gKlxuICogRXhhbXBsZTogbmV3IENvbG9yU3dhdGNoKCcuY29sb3Itc3dhdGNoLWl0ZW0nKVxuICogICAgICAgICAgKGRlZmF1bHRzIHRvIFtkYXRhLXN3YXRjaC1zZWxlY3Rvcl0pXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yU3dhdGNoIHtcbiAgY29uc3RydWN0b3IoZWwgPSBgW2RhdGEtc3dhdGNoLXNlbGVjdG9yXWApIHtcbiAgICB0aGlzLiRlbCA9ICQoZWwpO1xuXG4gICAgdGhpcy5iaW5kU3dhdGNoRXZlbnQoKTtcbiAgICB0aGlzLiRlbC5maW5kKCdbZGF0YS1kZWZhdWx0XScpLmNsaWNrKCk7XG4gIH1cblxuICAvLyBVcGRhdGUgU3dhdGNoIHRleHQgd2hlbiBjb2xvciBpcyBzZWxlY3RlZFxuICBiaW5kU3dhdGNoRXZlbnQoKSB7XG5cbiAgICB0aGlzLiRlbC5vbignY2xpY2snLCAnbGFiZWwnLCAoZSkgPT4ge1xuICAgICAgY29uc3QgJHRhcmdldCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgIGNvbnN0ICRzd2F0Y2hUZXh0ID0gJHRhcmdldC5jbG9zZXN0KCdbZGF0YS1zd2F0Y2gtc2VsZWN0b3JdJykuZmluZCgnLnN3YXRjaC12YWx1ZScpO1xuICAgICAgY29uc3QgJHN3YXRjaFZhbHVlID0gJHRhcmdldC5kYXRhKCdzd2F0Y2gtdmFsdWUnKTtcblxuICAgICAgJHN3YXRjaFRleHQudGV4dCgkc3dhdGNoVmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlWm9vbSB7XG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcblxuICAgIC8vIGNyZWF0ZSBlbXB0eSBpbWFnZVxuICAgIGNvbnN0IGRlZmF1bHRJbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAvLyBzZXQgc3JjIHNvIHdlIGNhbiBhY2Nlc3MgdGhlIG90aGVyIGF0dHJpYnV0ZSBkYXRhXG4gICAgZGVmYXVsdEltZy5zcmMgPSB0aGlzLiRlbC5maW5kKCdpbWcnKS5hdHRyKCdzcmMnKTtcblxuICAgIHRoaXMuaW1hZ2UgPSB7XG4gICAgICBvZmZzZXQ6IHRoaXMuJGVsLm9mZnNldCgpLFxuICAgICAgd2lkdGg6IHRoaXMuJGVsLndpZHRoKCksXG4gICAgICBoZWlnaHQ6IHRoaXMuJGVsLmhlaWdodCgpLFxuICAgIH1cblxuICAgIC8vIE9ubHkgaW5pdCBpZiBpbWFnZSBpcyB3aWRlIGVub3VnaCB0byB6b29tXG4gICAgaWYgKChkZWZhdWx0SW1nLndpZHRoIC8gdGhpcy5pbWFnZS53aWR0aCkgPiAxLjQpIHtcbiAgICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ25vLXpvb20nKS5oZWlnaHQodGhpcy4kZWwucGFyZW50KCkuaGVpZ2h0KCkpO1xuICAgIH1cbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGVsLm9uKCdtb3VzZW1vdmUnLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3pvb21JbWFnZShldmVudCk7XG4gICAgfSk7XG4gIH1cblxuICBfem9vbUltYWdlKGV2ZW50KSB7XG4gICAgY29uc3QgJHdyYXBwZXIgPSAkKCcucHJvZHVjdC1zbGlkZXMtd3JhcCcpLm9mZnNldCgpXG4gICAgY29uc3QgdG9wT2Zmc2V0ID0gJHdyYXBwZXIudG9wXG4gICAgY29uc3QgbGVmdE9mZnNldCA9ICR3cmFwcGVyLmxlZnRcblxuICAgIGNvbnN0IHRvcCA9IChldmVudC5wYWdlWSAtIHRvcE9mZnNldCkgLyB0aGlzLmltYWdlLmhlaWdodCAqIDEwMDtcbiAgICBjb25zdCBsZWZ0ID0gKGV2ZW50LnBhZ2VYIC0gbGVmdE9mZnNldCkgLyB0aGlzLmltYWdlLndpZHRoICogMTAwO1xuXG4gICAgdGhpcy4kZWwuY3NzKCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgYCR7bGVmdH0lICR7dG9wfSVgKVxuICB9XG59XG4iLCJpbXBvcnQgc2xpY2sgZnJvbSAnc2xpY2stY2Fyb3VzZWwnO1xuaW1wb3J0IGltYWdlc0xvYWRlZCBmcm9tICdpbWFnZXNsb2FkZWQnO1xuaW1wb3J0IEltYWdlWm9vbSBmcm9tICcuL0ltYWdlWm9vbSc7XG5pbXBvcnQgYmFndWV0dGVCb3ggZnJvbSAnYmFndWV0dGVib3guanMnO1xuXG4vLyBEZWZpbmUgY3VzdG9tIGJsYWNrIFNWR3NcbmNvbnN0IGN1c3RvbUxlZnRBcnJvdyA9ICc8c3ZnIHdpZHRoPVwiNDRcIiBoZWlnaHQ9XCI2MFwiPicgK1xuICAgICc8cG9seWxpbmUgcG9pbnRzPVwiMzAgMTAgMTAgMzAgMzAgNTBcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjRcIicgK1xuICAgICdzdHJva2UtbGluZWNhcD1cImJ1dHRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPicgK1xuICAgICc8L3N2Zz4nO1xuXG5jb25zdCBjdXN0b21SaWdodEFycm93ID0gJzxzdmcgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjYwXCI+JyArXG4gICAgJzxwb2x5bGluZSBwb2ludHM9XCIxNCAxMCAzNCAzMCAxNCA1MFwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiNFwiJyArXG4gICAgJ3N0cm9rZS1saW5lY2FwPVwiYnV0dFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIi8+JyArXG4gICAgJzwvc3ZnPic7XG5cbmNvbnN0IGN1c3RvbUNsb3NlWCA9ICc8c3ZnIHdpZHRoPVwiMzBcIiBoZWlnaHQ9XCIzMFwiPicgK1xuICAgICc8ZyBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjRcIj4nICtcbiAgICAnPGxpbmUgeDE9XCI1XCIgeTE9XCI1XCIgeDI9XCIyNVwiIHkyPVwiMjVcIi8+JyArXG4gICAgJzxsaW5lIHgxPVwiNVwiIHkxPVwiMjVcIiB4Mj1cIjI1XCIgeTI9XCI1XCIvPicgK1xuICAgICc8L2c+PC9zdmc+JztcblxuLy8gQ3VzdG9tIEluZmluaXRlIExvb3BpbmcgZm9yIGJhZ3VldHRlQm94XG5iYWd1ZXR0ZUJveC5ydW4oJy5wcm9kdWN0LXNsaWRlcy13cmFwJywge1xuICBsZWZ0QXJyb3c6IGN1c3RvbUxlZnRBcnJvdyxcbiAgcmlnaHRBcnJvdzogY3VzdG9tUmlnaHRBcnJvdyxcbiAgY2xvc2VYOiBjdXN0b21DbG9zZVgsXG4gIHByZWxvYWQ6IDIsIFxuICBidXR0b25zOiAnYXV0bycsXG4gIGFuaW1hdGlvbjogJ3NsaWRlSW4nLFxuICBub1Njcm9sbGJhcnM6IGZhbHNlLFxuICBmdWxsU2NyZWVuOiBmYWxzZSxcbiAgYWZ0ZXJTaG93OiAoKSA9PiB7XG4gICAgICAvLyBSZWJpbmRpbmcgZXZlbnQgbGlzdGVuZXJzIGZvciBuZXh0IGFuZCBwcmV2aW91cyBhcnJvd3NcbiAgICAgIGNvbnN0IHRvdGFsSW1hZ2VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3Qtc2xpZGVzLXdyYXAgYScpLmxlbmd0aDtcblxuICAgICAgLy8gUmVzZXQgYW55IGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgY29uc3QgbmV4dEJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNuZXh0LWJ1dHRvbicpO1xuICAgICAgY29uc3QgcHJldkJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwcmV2aW91cy1idXR0b24nKTtcblxuICAgICAgLy8gUmVtb3ZpbmcgYW55IGV4aXN0aW5nIGxpc3RlbmVycyB0byBhdm9pZCBwaWxpbmcgdXBcbiAgICAgIG5leHRCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBuZXh0SW1hZ2UpO1xuICAgICAgcHJldkJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHByZXZpb3VzSW1hZ2UpO1xuXG4gICAgICAvLyBOZXh0IGltYWdlIGZ1bmN0aW9uIHdpdGggbG9vcFxuICAgICAgY29uc3QgbmV4dEltYWdlID0gKCkgPT4ge1xuICAgICAgICAgIGxldCBjdXJyZW50SW5kZXggPSBiYWd1ZXR0ZUJveC5nZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpICUgdG90YWxJbWFnZXM7IC8vIExvb3AgYmFjayB0byBzdGFydCBhZnRlciB0aGUgbGFzdCBpbWFnZVxuICAgICAgICAgIGJhZ3VldHRlQm94LnNob3cobmV4dEluZGV4KTsgLy8gU2hvdyB0aGUgbmV4dCBpbWFnZVxuICAgICAgfTtcblxuICAgICAgLy8gUHJldmlvdXMgaW1hZ2UgZnVuY3Rpb24gd2l0aCBsb29wXG4gICAgICBjb25zdCBwcmV2aW91c0ltYWdlID0gKCkgPT4ge1xuICAgICAgICAgIGxldCBjdXJyZW50SW5kZXggPSBiYWd1ZXR0ZUJveC5nZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgICBsZXQgcHJldkluZGV4ID0gKGN1cnJlbnRJbmRleCAtIDEgKyB0b3RhbEltYWdlcykgJSB0b3RhbEltYWdlczsgLy8gTG9vcCBiYWNrIHRvIGVuZCBhZnRlciB0aGUgZmlyc3QgaW1hZ2VcbiAgICAgICAgICBiYWd1ZXR0ZUJveC5zaG93KHByZXZJbmRleCk7IC8vIFNob3cgdGhlIHByZXZpb3VzIGltYWdlXG4gICAgICB9O1xuXG4gICAgICAvLyBCaW5kIG5ldyBldmVudCBsaXN0ZW5lcnMgYWZ0ZXIgY2xlYXJpbmcgdGhlIG9sZCBvbmVzXG4gICAgICBuZXh0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgbmV4dEltYWdlKTtcbiAgICAgIHByZXZCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwcmV2aW91c0ltYWdlKTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2R1Y3RJbWFnZXMge1xuICBjb25zdHJ1Y3RvcihlbCkge1xuICAgIHRoaXMuJGVsID0gJChlbCk7XG4gICAgdGhpcy5tYXhTbGlkZXNCZWZvcmVBcnJvd3MgPSA1O1xuXG4gICAgdGhpcy5jbGFzc2VzID0ge1xuICAgICAgY29udGFpbmVyOiAnLnByb2R1Y3QtaW1hZ2VzLWNvbnRhaW5lcicsXG4gICAgICBzbGlkZXNXcmFwOiAnLnByb2R1Y3Qtc2xpZGVzLXdyYXAnLFxuICAgICAgcGFnaW5hdGlvbjogJy5wcm9kdWN0LWltYWdlcy1wYWdpbmF0aW9uJyxcbiAgICAgIHBhZ2luYXRpb25JdGVtOiAnLnBhZ2luYXRpb24taXRlbScsXG4gICAgICBsb2FkZXI6ICcucHJvZHVjdC1pbWFnZXMtbG9hZGVyJyxcbiAgICB9O1xuXG4gICAgdGhpcy4kcGFnaW5hdGlvbiA9IHRoaXMuJGVsXG4gICAgICAuY2xvc2VzdCh0aGlzLmNsYXNzZXMuY29udGFpbmVyKVxuICAgICAgLmZpbmQodGhpcy5jbGFzc2VzLnBhZ2luYXRpb24pO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG5cbiAgX2luaXQoKSB7XG4gICAgaW1hZ2VzTG9hZGVkKHRoaXMuJGVsWzBdLCAoKSA9PiB7XG4gICAgICAvLyBIaWRlIGxvYWRlclxuICAgICAgdGhpcy4kZWxcbiAgICAgICAgLnBhcmVudHModGhpcy5jbGFzc2VzLmNvbnRhaW5lcilcbiAgICAgICAgLmZpbmQodGhpcy5jbGFzc2VzLmxvYWRlcilcbiAgICAgICAgLmFkZENsYXNzKCdpbml0aWFsaXplZCcpO1xuXG4gICAgICAvLyBJbWFnZSB6b29tXG4gICAgICB0aGlzLiRlbC5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuZmluZCgnW2RhdGEtcHJvZHVjdC1pbWFnZV0nKS5lYWNoKChpLCBlbCkgPT4ge1xuICAgICAgICAgIG5ldyBJbWFnZVpvb20oZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJbml0IHNsaWNrIGNhcm91c2VsIHdpdGggaW5maW5pdGUgbG9vcGluZ1xuICAgICAgdGhpcy4kZWwuc2xpY2soe1xuICAgICAgICBpbmZpbml0ZTogdHJ1ZSwgLy8gRW5hYmxlIGluZmluaXRlIGxvb3BpbmdcbiAgICAgICAgYXJyb3dzOiBmYWxzZSxcbiAgICAgICAgZG90czogZmFsc2UsXG4gICAgICAgIGFkYXB0aXZlSGVpZ2h0OiB0cnVlLFxuICAgICAgICBhc05hdkZvcjogdGhpcy5jbGFzc2VzLnBhZ2luYXRpb24sXG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSwgXG4gICAgICAgIHN3aXBlOiB0cnVlLCBcbiAgICAgICAgdG91Y2hUaHJlc2hvbGQ6IDEwLCBcbiAgICAgICAgZWRnZUZyaWN0aW9uOiAwLjE1XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5pbWFnZUNvdW50ID0gdGhpcy4kcGFnaW5hdGlvblxuICAgICAgICAuZmluZCh0aGlzLmNsYXNzZXMucGFnaW5hdGlvbkl0ZW0pXG4gICAgICAgIC5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLmltYWdlQ291bnQgPiB0aGlzLm1heFNsaWRlc0JlZm9yZUFycm93cykge1xuICAgICAgICB0aGlzLiRwYWdpbmF0aW9uLmFkZENsYXNzKCdwYWdpbmF0aW9uLWhhcy1hcnJvd3MnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kcGFnaW5hdGlvbi5vbignc2V0UG9zaXRpb24nLCAoZXZlbnQsIHNsaWNrKSA9PiB7XG4gICAgICAgIGlmIChzbGljay4kc2xpZGVzLmxlbmd0aCA+IHRoaXMubWF4U2xpZGVzQmVmb3JlQXJyb3dzKSB7XG4gICAgICAgICAgdGhpcy4kcGFnaW5hdGlvbi5hZGRDbGFzcygncGFnaW5hdGlvbi1oYXMtYXJyb3dzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kcGFnaW5hdGlvbi5yZW1vdmVDbGFzcygncGFnaW5hdGlvbi1oYXMtYXJyb3dzJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRwYWdpbmF0aW9uXG4gICAgICAgIC5zbGljayh7XG4gICAgICAgICAgaW5maW5pdGU6IHRydWUsIC8vIEVuYWJsZSBpbmZpbml0ZSBsb29waW5nXG4gICAgICAgICAgY2VudGVyTW9kZTogZmFsc2UsXG4gICAgICAgICAgZG90czogZmFsc2UsXG4gICAgICAgICAgc3dpcGU6IHRydWUsXG4gICAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgICBsYXp5TG9hZDogJ3Byb2dyZXNzaXZlJyxcbiAgICAgICAgICBhcnJvd3M6IHRydWUsXG4gICAgICAgICAgcHJldkFycm93OiAnPGRpdiBjbGFzcz1cInByb2R1Y3QtaW1hZ2VzLXBhZ2luYXRpb24taWNvbiBwYWdpbmF0aW9uLXByZXZcIj48c3ZnIHdpZHRoPVwiNDRcIiBoZWlnaHQ9XCI2MFwiPjxwb2x5bGluZSBwb2ludHM9XCIzMCAxMCAxMCAzMCAzMCA1MFwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiNFwiIHN0cm9rZS1saW5lY2FwPVwiYnV0dFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIi8+PC9zdmc+PC9kaXY+JyxcbiAgICAgICAgICBuZXh0QXJyb3c6ICc8ZGl2IGNsYXNzPVwicHJvZHVjdC1pbWFnZXMtcGFnaW5hdGlvbi1pY29uIHBhZ2luYXRpb24tbmV4dFwiPjxzdmcgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjYwXCI+PHBvbHlsaW5lIHBvaW50cz1cIjE0IDEwIDM0IDMwIDE0IDUwXCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCI0XCIgc3Ryb2tlLWxpbmVjYXA9XCJidXR0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiLz48L3N2Zz48L2Rpdj4nLFxuICAgICAgICAgIHNsaWRlc1RvU2hvdzogNSxcbiAgICAgICAgICBzbGlkZXNUb1Njcm9sbDogMSxcbiAgICAgICAgICB2YXJpYWJsZVdpZHRoOiBmYWxzZSxcbiAgICAgICAgICByb3dzOiAwLFxuICAgICAgICAgIGFzTmF2Rm9yOiB0aGlzLmNsYXNzZXMuc2xpZGVzV3JhcCxcbiAgICAgICAgICBmb2N1c09uU2VsZWN0OiB0cnVlLFxuICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSwgXG4gICAgICAgICAgc3dpcGU6IHRydWUgXG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBSZWluaXRpYWxpemUgdGhlIGJhZ3VldHRlQm94IHdpdGggaW5maW5pdGUgbG9vcGluZyBmb3Igem9vbWVkIGltYWdlc1xuICAgICAgYmFndWV0dGVCb3gucnVuKHRoaXMuY2xhc3Nlcy5zbGlkZXNXcmFwLCB7XG4gICAgICAgICAgbGVmdEFycm93OiBjdXN0b21MZWZ0QXJyb3csXG4gICAgICAgICAgcmlnaHRBcnJvdzogY3VzdG9tUmlnaHRBcnJvdyxcbiAgICAgICAgICBjbG9zZVg6IGN1c3RvbUNsb3NlWFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2R1Y3RSZXZpZXdzIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICB0aGlzLl9iaW5kUmF0aW5nKCk7XG4gIH1cblxuICBfYmluZFJhdGluZygpIHtcbiAgICAkKCcjcmF0aW5nLXN0YXJzJykub24oJ2NoYW5nZScsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgcmF0aW5nID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS52YWwoKTtcbiAgICAgIGNvbnN0IHJhdGluZ0xhYmVsID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5maW5kKCdvcHRpb246c2VsZWN0ZWQnKS50ZXh0KCk7XG5cbiAgICAgICQoJy5yZXZpZXctZm9ybScpXG4gICAgICAgIC5maW5kKCcuaWNvbi1zdGFyLXdyYXAnKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2Z1bGwnKVxuICAgICAgICAuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgICAgaWYgKChpbmRleCArIDEpIDw9IHJhdGluZykge1xuICAgICAgICAgICAgJChlbCkuYWRkQ2xhc3MoJ2Z1bGwnKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgJCgnLnJldmlldy1mb3JtJylcbiAgICAgICAgLmZpbmQoJy5yYXRpbmctc3RhcnMtbGFiZWwnKVxuICAgICAgICAuaHRtbChyYXRpbmdMYWJlbCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB1dGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XHJcbmltcG9ydCBBbGVydCBmcm9tICcuLi9jb21wb25lbnRzL0FsZXJ0JztcclxuaW1wb3J0IEZvcm1WYWxpZGF0b3IgZnJvbSAnLi4vdXRpbHMvRm9ybVZhbGlkYXRvcic7XHJcbmltcG9ydCBQcm9ncmVzc0J1dHRvbiBmcm9tICcuLi91dGlscy9Qcm9ncmVzc0J1dHRvbic7XHJcbmltcG9ydCByZXNldFByb2R1Y3RJbWFnZXMgZnJvbSAnLi9yZXNldFByb2R1Y3RJbWFnZXMnO1xyXG5pbXBvcnQgQXR0cmlidXRlc0hlbHBlciBmcm9tICcuL0F0dHJpYnV0ZXNIZWxwZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZHVjdFV0aWxzIHtcclxuICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xyXG4gICAgdGhpcy4kZWwgPSAkKGVsKTtcclxuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHtcclxuICAgICAgb25JbWFnZVN3aXRjaDogKCkgPT4ge30sXHJcbiAgICB9LCBvcHRpb25zKTtcclxuICAgIHRoaXMucHJvZHVjdElkID0gdGhpcy4kZWwuZmluZCgnW2RhdGEtcHJvZHVjdC1pZF0nKS52YWwoKTtcclxuXHJcbiAgICB0aGlzLnBhZ2VBbGVydHMgPSBuZXcgQWxlcnQoJCgnW2RhdGEtYWxlcnRzXScpKTtcclxuICAgIHRoaXMucHJvZHVjdEFsZXJ0cyA9IG5ldyBBbGVydCgkKCdbZGF0YS1wcm9kdWN0LWFsZXJ0c10nKSk7XHJcbiAgICB0aGlzLnByb2R1Y3RUaXRsZSA9ICQoZWwpLmRhdGEoJ3Byb2R1Y3QtdGl0bGUnKTtcclxuICAgIHRoaXMuJHByb2R1Y3RDb250YWluZXIgPSAkKCdbZGF0YS1wcm9kdWN0LWNvbnRhaW5lcl0nKTtcclxuICAgIHRoaXMucHJvZHVjdEF0dHJpYnV0ZXNEYXRhID0gd2luZG93LkJDRGF0YS5wcm9kdWN0X2F0dHJpYnV0ZXM7XHJcbiAgICB0aGlzLiRmb3JtID0gdGhpcy4kZWwuZmluZCgnZm9ybVtkYXRhLWNhcnQtaXRlbS1hZGRdJyk7XHJcbiAgICB0aGlzLiRhZGRUb0NhcnQgPSB0aGlzLiRmb3JtLmZpbmQoJ1tkYXRhLWJ1dHRvbi1wdXJjaGFzZV0nKTtcclxuXHJcbiAgICB0aGlzLmF0dHJpYnV0ZXNIZWxwZXIgPSBuZXcgQXR0cmlidXRlc0hlbHBlcihlbCk7XHJcbiAgICB0aGlzLnByb2dyZXNzQnV0dG9uID0gbmV3IFByb2dyZXNzQnV0dG9uKCk7XHJcblxyXG4gICAgdGhpcy5jYWxsYmFja3MgPSAkLmV4dGVuZCh7XHJcbiAgICAgIHdpbGxVcGRhdGU6ICgpID0+IGNvbnNvbGUubG9nKCdVcGRhdGUgcmVxdWVzdGVkLicpLFxyXG4gICAgICBkaWRVcGRhdGU6ICgpID0+IGNvbnNvbGUubG9nKCdVcGRhdGUgZXhlY3V0ZWQuJyksXHJcbiAgICAgIHN3aXRjaEltYWdlOiAodXJsKSA9PiBjb25zb2xlLmxvZyhgSW1hZ2Ugc3dpdGNoIGF0dGVtcHRlZCBmb3IgJHt1cmx9YCksXHJcbiAgICB9LCBvcHRpb25zLmNhbGxiYWNrcyk7XHJcblxyXG4gICAgdGhpcy5fYm91bmRQcm9kdWN0T3B0aW9uQ2hhbmdlID0gdGhpcy5fYmluZFByb2R1Y3RPcHRpb25DaGFuZ2UuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuYm91bmRDYXJ0Q2FsbGJhY2sgPSB0aGlzLl9iaW5kQWRkVG9DYXJ0LmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XHJcbiAgfVxyXG5cclxuICBfYmluZEV2ZW50cygpIHtcclxuICAgIHRoaXMuJGVsLmZpbmQoJy5wcm9kdWN0LXF1YW50aXR5LXRvZ2dsZScpLm9uKCdjbGljaycsIChldmVudCkgPT4ge1xyXG4gICAgICB0aGlzLl91cGRhdGVRdWFudGl0eShldmVudCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLiRlbC5maW5kKCcucHJvZHVjdC1xdWFudGl0eScpLm9uKCdmb2N1c291dCcsIChldmVudCkgPT4ge1xyXG4gICAgICB0aGlzLl9jaGVja1F1YW50aXR5KGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpbml0KGNvbnRleHQpIHtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCAkcHJvZHVjdE9wdGlvbnNFbGVtZW50ID0gJCgnW2RhdGEtcHJvZHVjdC1vcHRpb24tY2hhbmdlXScsIHRoaXMuJGZvcm0pO1xyXG4gICAgY29uc3QgaGFzT3B0aW9ucyA9ICRwcm9kdWN0T3B0aW9uc0VsZW1lbnQubGVuZ3RoID4gMCA/IHRydWUgOiBmYWxzZTtcclxuICAgIGNvbnN0IGhhc0RlZmF1bHRPcHRpb25zID0gJHByb2R1Y3RPcHRpb25zRWxlbWVudC5maW5kKCdbZGF0YS1kZWZhdWx0XScpLmxlbmd0aDtcclxuICAgIGlmIChoYXNEZWZhdWx0T3B0aW9ucyB8fCAoXy5pc0VtcHR5KHRoaXMucHJvZHVjdEF0dHJpYnV0ZXNEYXRhKSAmJiBoYXNPcHRpb25zKSkge1xyXG4gICAgICBjb25zdCAkcHJvZHVjdElkID0gJCgnW25hbWU9XCJwcm9kdWN0X2lkXCJdJywgdGhpcy4kZm9ybSkudmFsKCk7XHJcbiAgICAgIHV0aWxzLmFwaS5wcm9kdWN0QXR0cmlidXRlcy5vcHRpb25DaGFuZ2UoJHByb2R1Y3RJZCwgdGhpcy4kZm9ybS5zZXJpYWxpemUoKSwgJ3Byb2R1Y3RzL2FkZC10by1jYXJ0LWZvcm0nLCAoZXJyLCByZXNwb25zZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXNEYXRhID0gcmVzcG9uc2UuZGF0YSB8fCB7fTtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzQ29udGVudCA9IHJlc3BvbnNlLmNvbnRlbnQgfHwge307XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzSGVscGVyLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlc0RhdGEpO1xyXG5cclxuICAgICAgICBpZiAoaGFzRGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICAgIHRoaXMuX3VwZGF0ZVZpZXcoYXR0cmlidXRlc0RhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmF0dHJpYnV0ZXNIZWxwZXIudXBkYXRlQXR0cmlidXRlcyh0aGlzLnByb2R1Y3RBdHRyaWJ1dGVzRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXRpbHMuaG9va3Mub24oJ3Byb2R1Y3Qtb3B0aW9uLWNoYW5nZScsIHRoaXMuX2JvdW5kUHJvZHVjdE9wdGlvbkNoYW5nZSk7XHJcbiAgICB0aGlzLl9iaW5kQWRkV2lzaGxpc3QoKTtcclxuXHJcbiAgICB0aGlzLlZhbGlkYXRvciA9IG5ldyBGb3JtVmFsaWRhdG9yKHRoaXMuY29udGV4dCk7XHJcbiAgICB0aGlzLlZhbGlkYXRvci5pbml0U2luZ2xlKHRoaXMuJGVsLmZpbmQoJ2Zvcm1bZGF0YS1jYXJ0LWl0ZW0tYWRkXScpKTtcclxuXHJcbiAgICB1dGlscy5ob29rcy5vbignY2FydC1pdGVtLWFkZCcsIHRoaXMuYm91bmRDYXJ0Q2FsbGJhY2spO1xyXG5cclxuICAgIC8vIFRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgc28gdGhlIHZhbHVlcyBhcmUgY29ycmVjdCBmb3IgcHJlLXNlbGVjdGVkIG9wdGlvbnNcclxuICAgIHRoaXMuJGVsLmZpbmQoJ1tkYXRhLWNhcnQtaXRlbS1hZGRdJykuZmluZCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdLCBpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0sIHNlbGVjdCcpLmZpcnN0KCkuY2hhbmdlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqIENsZWFudXAgLSB1c2VmdWwgZm9yIGNsb3NpbmcgcXVpY2tzaG9wIG1vZGFsc1xyXG4gICAqXHJcbiAgICovXHJcbiAgIGRlc3Ryb3koKSB7XHJcbiAgICAgdXRpbHMuaG9va3Mub2ZmKCdjYXJ0LWl0ZW0tYWRkJywgdGhpcy5ib3VuZENhcnRDYWxsYmFjayk7XHJcbiAgICAgdXRpbHMuaG9va3Mub2ZmKCdwcm9kdWN0LW9wdGlvbi1jaGFuZ2UnLCB0aGlzLl9ib3VuZFByb2R1Y3RPcHRpb25DaGFuZ2UpO1xyXG4gICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhY2hlIGFuIG9iamVjdCBvZiBqUXVlcnkgZWxlbWVudHMgZm9yIERPTSB1cGRhdGluZ1xyXG4gICAqIEBwYXJhbSAgalF1ZXJ5ICRlbCAtIGEgd3JhcHBpbmcgZWxlbWVudCBvZiB0aGUgc2NvcGVkIHByb2R1Y3RcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gYnVuY2hhIGpRdWVyeSBlbGVtZW50cyB3aGljaCBtYXkgb3IgbWF5IG5vdCBleGlzdCBvbiB0aGUgcGFnZVxyXG4gICAqL1xyXG4gIF9nZXRWaWV3TW9kZWwoJGVsKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAkcHJpY2U6ICQoJ1tkYXRhLXByb2R1Y3QtcHJpY2Utd3JhcHBlcj1cIndpdGhvdXQtdGF4XCJdJywgJGVsKSxcclxuICAgICAgJHByaWNlV2l0aFRheDogJCgnW2RhdGEtcHJvZHVjdC1wcmljZS13cmFwcGVyPVwid2l0aC10YXhcIl0nLCAkZWwpLFxyXG4gICAgICAkc2F2ZWQ6ICQoJ1tkYXRhLXByb2R1Y3QtcHJpY2Utc2F2ZWRdJywgJGVsKSxcclxuICAgICAgJHNrdTogJCgnW2RhdGEtcHJvZHVjdC1za3VdJywgJGVsKSxcclxuICAgICAgJHdlaWdodDogJCgnW2RhdGEtcHJvZHVjdC13ZWlnaHRdJywgJGVsKSxcclxuICAgICAgJGFkZFRvQ2FydDogJCgnW2RhdGEtYnV0dG9uLXB1cmNoYXNlXScsICRlbCksXHJcbiAgICAgICRpbWFnZVByZXZpZXc6ICQoJ1tkYXRhLXZhcmlhdGlvbi1wcmV2aWV3XScsICRlbCksXHJcbiAgICAgIHN0b2NrOiB7XHJcbiAgICAgICAgJHNlbGVjdG9yOiAkKCdbZGF0YS1wcm9kdWN0LXN0b2NrXScsICRlbCksXHJcbiAgICAgICAgJGxldmVsOiAkKCdbZGF0YS1wcm9kdWN0LXN0b2NrLWxldmVsXScsICRlbCksXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTY3Mjk5Mi9hamF4LXJlcXVlc3QtZmFpbHMtd2hlbi1zZW5kaW5nLWZvcm1kYXRhLWluY2x1ZGluZy1lbXB0eS1maWxlLWlucHV0LWluLXNhZmFyaVxyXG4gICogU2FmYXJpIGJyb3dzZXIgd2l0aCBqcXVlcnkgMy4zLjEgaGFzIGFuIGlzc3VlIHVwbG9hZGluZyBlbXB0eSBmaWxlIHBhcmFtZXRlcnMuIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyBhbnkgZW1wdHkgZmlsZXMgZnJvbSB0aGUgZm9ybSBwYXJhbXNcclxuICAqIEBwYXJhbSBmb3JtRGF0YTogRm9ybURhdGEgb2JqZWN0XHJcbiAgKiBAcmV0dXJucyBGb3JtRGF0YSBvYmplY3RcclxuICAqL1xyXG4gIGZpbHRlckVtcHR5RmlsZXNGcm9tRm9ybShmb3JtRGF0YSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhKSB7XHJcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEZpbGUgJiYgIXZhbC5uYW1lICYmICF2YWwuc2l6ZSkge1xyXG4gICAgICAgICAgZm9ybURhdGEuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1EYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCBwcm9kdWN0IG9wdGlvbnMgY2hhbmdlcy5cclxuICAgKi9cclxuICBfYmluZFByb2R1Y3RPcHRpb25DaGFuZ2UoeyB0YXJnZXQgfSwgY2hhbmdlZE9wdGlvbikge1xyXG4gICAgY29uc3QgZm9ybVByb2R1Y3RJZCA9IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1wcm9kdWN0LWlkXScpLmRhdGFzZXQucHJvZHVjdElkO1xyXG4gICAgaWYgKGZvcm1Qcm9kdWN0SWQgIT09IHRoaXMucHJvZHVjdElkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCAkY2hhbmdlZE9wdGlvbiA9ICQoY2hhbmdlZE9wdGlvbik7XHJcbiAgICBjb25zdCAkZm9ybSA9ICRjaGFuZ2VkT3B0aW9uLnBhcmVudHMoJ2Zvcm0nKTtcclxuXHJcbiAgICAvLyBEbyBub3QgdHJpZ2dlciBhbiBhamF4IHJlcXVlc3QgaWYgaXQncyBhIGZpbGUgb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IEZvcm1EYXRhXHJcbiAgICBpZiAoJGNoYW5nZWRPcHRpb24uYXR0cigndHlwZScpID09PSAnZmlsZScgfHwgd2luZG93LkZvcm1EYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGFnZUFsZXJ0cy5jbGVhcigpO1xyXG4gICAgdGhpcy5wcm9kdWN0QWxlcnRzLmNsZWFyKCk7XHJcblxyXG4gICAgdXRpbHMuYXBpLnByb2R1Y3RBdHRyaWJ1dGVzLm9wdGlvbkNoYW5nZSh0aGlzLnByb2R1Y3RJZCwgJGZvcm0uc2VyaWFsaXplKCksICdwcm9kdWN0cy9hZGQtdG8tY2FydC1mb3JtJywgKGVyciwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgY29uc3QgcHJvZHVjdEF0dHJpYnV0ZXNEYXRhID0gcmVzcG9uc2UuZGF0YSB8fCB7fTtcclxuICAgICAgY29uc3QgcHJvZHVjdEF0dHJpYnV0ZXNDb250ZW50ID0gcmVzcG9uc2UuY29udGVudCB8fCB7fTtcclxuXHJcbiAgICAgIC8vIElmIG91ciBmb3JtIGRhdGEgZG9lc24ndCBpbmNsdWRlIHRoZSBwcm9kdWN0LW9wdGlvbnMtY291bnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLCByZXR1cm5cclxuICAgICAgaWYgKHRoaXMuJGVsLmZpbmQoJ1tkYXRhLXByb2R1Y3Qtb3B0aW9ucy1jb3VudF0nKS52YWwgPCAxKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmF0dHJpYnV0ZXNIZWxwZXIudXBkYXRlQXR0cmlidXRlcyhwcm9kdWN0QXR0cmlidXRlc0RhdGEpO1xyXG4gICAgICB0aGlzLl91cGRhdGVWaWV3KHByb2R1Y3RBdHRyaWJ1dGVzRGF0YSk7XHJcbiAgICAgIHRoaXMuc2V0UHJvZHVjdFZhcmlhbnQoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZVZpZXcoZGF0YSkge1xyXG4gICAgY29uc3Qgdmlld01vZGVsID0gdGhpcy5fZ2V0Vmlld01vZGVsKHRoaXMuJGVsKTtcclxuXHJcbiAgICAvLyB1cGRhdGluZyBwcmljZVxyXG4gICAgaWYgKHZpZXdNb2RlbC4kcHJpY2UubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IHByaWNlU3RyaW5ncyA9IHtcclxuICAgICAgICBwcmljZTogZGF0YS5wcmljZSxcclxuICAgICAgICBleGNsdWRpbmdUYXg6IHRoaXMuY29udGV4dC5wcm9kdWN0RXhjbHVkaW5nVGF4LFxyXG4gICAgICAgIHNhbGVQcmljZUxhYmVsOiB0aGlzLmNvbnRleHQuc2FsZVByaWNlTGFiZWwsXHJcbiAgICAgICAgbm9uU2FsZVByaWNlTGFiZWw6IHRoaXMuY29udGV4dC5ub25TYWxlUHJpY2VMYWJlbCxcclxuICAgICAgICByZXRhaWxQcmljZUxhYmVsOiB0aGlzLmNvbnRleHQucmV0YWlsUHJpY2VMYWJlbCxcclxuICAgICAgICBwcmljZUxhYmVsOiB0aGlzLmNvbnRleHQucHJpY2VMYWJlbCxcclxuICAgICAgfTtcclxuICAgICAgdmlld01vZGVsLiRwcmljZS5odG1sKHRoaXMub3B0aW9ucy5wcmljZVdpdGhvdXRUYXhUZW1wbGF0ZShwcmljZVN0cmluZ3MpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmlld01vZGVsLiRwcmljZVdpdGhUYXgubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IHByaWNlU3RyaW5ncyA9IHtcclxuICAgICAgICBwcmljZTogZGF0YS5wcmljZSxcclxuICAgICAgICBpbmNsdWRpbmdUYXg6IHRoaXMuY29udGV4dC5wcm9kdWN0SW5jbHVkaW5nVGF4LFxyXG4gICAgICAgIHNhbGVQcmljZUxhYmVsOiB0aGlzLmNvbnRleHQuc2FsZVByaWNlTGFiZWwsXHJcbiAgICAgICAgbm9uU2FsZVByaWNlTGFiZWw6IHRoaXMuY29udGV4dC5ub25TYWxlUHJpY2VMYWJlbCxcclxuICAgICAgICByZXRhaWxQcmljZUxhYmVsOiB0aGlzLmNvbnRleHQucmV0YWlsUHJpY2VMYWJlbCxcclxuICAgICAgICBwcmljZUxhYmVsOiB0aGlzLmNvbnRleHQucHJpY2VMYWJlbCxcclxuICAgICAgfTtcclxuICAgICAgdmlld01vZGVsLiRwcmljZVdpdGhUYXguaHRtbCh0aGlzLm9wdGlvbnMucHJpY2VXaXRoVGF4VGVtcGxhdGUocHJpY2VTdHJpbmdzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZpZXdNb2RlbC4kc2F2ZWQubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IHByaWNlU3RyaW5ncyA9IHtcclxuICAgICAgICBwcmljZTogZGF0YS5wcmljZSxcclxuICAgICAgICBzYXZlZFN0cmluZzogdGhpcy5jb250ZXh0LnByb2R1Y3RZb3VTYXZlLFxyXG4gICAgICB9O1xyXG4gICAgICB2aWV3TW9kZWwuJHNhdmVkLmh0bWwodGhpcy5vcHRpb25zLnByaWNlU2F2ZWRUZW1wbGF0ZShwcmljZVN0cmluZ3MpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBzdG9jayB2aWV3IGlzIG9uIChDUCBzZXR0aW5ncylcclxuICAgIGlmICh2aWV3TW9kZWwuc3RvY2suJHNlbGVjdG9yLmxlbmd0aCAmJiBkYXRhLnN0b2NrICE9PSBudWxsKSB7XHJcbiAgICAgIHZpZXdNb2RlbC5zdG9jay4kc2VsZWN0b3IucmVtb3ZlQ2xhc3MoJ3Byb2R1Y3QtZGV0YWlscy1oaWRkZW4nKTtcclxuICAgICAgdmlld01vZGVsLnN0b2NrLiRsZXZlbC50ZXh0KGRhdGEuc3RvY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmlld01vZGVsLnN0b2NrLiRzZWxlY3Rvci5hZGRDbGFzcygncHJvZHVjdC1kZXRhaWxzLWhpZGRlbicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZSBza3UgaWYgZXhpc3RzXHJcbiAgICBpZiAodmlld01vZGVsLiRza3UubGVuZ3RoKSB7XHJcbiAgICAgIHZpZXdNb2RlbC4kc2t1Lmh0bWwoZGF0YS5za3UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZSB3ZWlnaHQgaWYgZXhpc3RzXHJcbiAgICBpZiAoZGF0YS53ZWlnaHQgJiYgdmlld01vZGVsLiR3ZWlnaHQubGVuZ3RoKSB7XHJcbiAgICAgIHZpZXdNb2RlbC4kd2VpZ2h0Lmh0bWwoZGF0YS53ZWlnaHQuZm9ybWF0dGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBoYW5kbGUgcHJvZHVjdCB2YXJpYW50IGltYWdlIGlmIGV4aXN0c1xyXG4gICAgaWYgKGRhdGEuaW1hZ2UpIHtcclxuICAgICAgY29uc3QgcHJvZHVjdEltYWdlVXJsID0gdXRpbHMudG9vbHMuaW1hZ2UuZ2V0U3JjKFxyXG4gICAgICAgIGRhdGEuaW1hZ2UuZGF0YSxcclxuICAgICAgICB0aGlzLmNvbnRleHQudGhlbWVJbWFnZVNpemVzLnpvb21cclxuICAgICAgKTtcclxuICAgICAgY29uc3Qgem9vbUltYWdlVXJsID0gdXRpbHMudG9vbHMuaW1hZ2UuZ2V0U3JjKFxyXG4gICAgICAgIGRhdGEuaW1hZ2UuZGF0YSxcclxuICAgICAgICB0aGlzLmNvbnRleHQudGhlbWVJbWFnZVNpemVzLnByb2R1Y3RcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIHRvIG1haW50YWluIGEgcmVmZXJlbmNlIGJldHdlZW4gb3B0aW9uIGltYWdlcywgcHVsbCBvdXQgdGhlXHJcbiAgICAgIC8vIGZpbGVuYW1lIGZyb20gdGhlIGltYWdlIFVSTCBhbmQgdXNlIGl0IGFzIGFuIElEXHJcbiAgICAgIGNvbnN0IGltYWdlSWQgPSBkYXRhLmltYWdlLmRhdGEucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xyXG5cclxuICAgICAgdGhpcy5jYWxsYmFja3Muc3dpdGNoSW1hZ2UocHJvZHVjdEltYWdlVXJsLCB6b29tSW1hZ2VVcmwsIGRhdGEuaW1hZ2UuYWx0LCBpbWFnZUlkKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy4kZWwuZmluZCgnW2RhdGEtcHJvZHVjdC1pbWFnZS12YXJpYW50XScpLmxlbmd0aCkge1xyXG4gICAgICByZXNldFByb2R1Y3RJbWFnZXModGhpcy4kZWwuZmluZCgnLnByb2R1Y3Qtc2xpZGVzLXdyYXAnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXBkYXRlIHN1Ym1pdCBidXR0b24gc3RhdGVcclxuICAgIGlmICghZGF0YS5wdXJjaGFzYWJsZSB8fCAhZGF0YS5pbnN0b2NrKSB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBvdXRfb2Zfc3RvY2tfbWVzc2FnZSxcclxuICAgICAgICBzdG9ja19tZXNzYWdlLFxyXG4gICAgICAgIHB1cmNoYXNpbmdfbWVzc2FnZSxcclxuICAgICAgfSA9IGRhdGE7XHJcblxyXG4gICAgICBpZiAoJCgnLm1vZGFsLXF1aWNrLXNob3AnKS5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLnByb2R1Y3RBbGVydHMuZXJyb3Iob3V0X29mX3N0b2NrX21lc3NhZ2UgfHwgc3RvY2tfbWVzc2FnZSB8fCBwdXJjaGFzaW5nX21lc3NhZ2UsIHRydWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5wYWdlQWxlcnRzLmVycm9yKG91dF9vZl9zdG9ja19tZXNzYWdlIHx8IHN0b2NrX21lc3NhZ2UgfHwgcHVyY2hhc2luZ19tZXNzYWdlLCB0cnVlKTtcclxuICAgICAgICB9LCA1MCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZpZXdNb2RlbC4kYWRkVG9DYXJ0XHJcbiAgICAgICAgLmFkZENsYXNzKHRoaXMuYnV0dG9uRGlzYWJsZWRDbGFzcylcclxuICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCB0cnVlKVxyXG4gICAgICAgIC5jaGlsZHJlbignLmJ1dHRvbi10ZXh0JylcclxuICAgICAgICAudGV4dCh0aGlzLmNvbnRleHQuc29sZE91dEJ1dHRvbkxhYmVsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZpZXdNb2RlbC4kYWRkVG9DYXJ0XHJcbiAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuYnV0dG9uRGlzYWJsZWRDbGFzcylcclxuICAgICAgICAucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSlcclxuICAgICAgICAuY2hpbGRyZW4oJy5idXR0b24tdGV4dCcpXHJcbiAgICAgICAgLnRleHQodGhpcy5jb250ZXh0LmFkZFRvQ2FydEJ1dHRvbkxhYmVsKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF91cGRhdGVRdWFudGl0eShldmVudCkge1xyXG4gICAgY29uc3QgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICBjb25zdCAkcXVhbnRpdHkgPSAkdGFyZ2V0LmNsb3Nlc3QoJy5wcm9kdWN0LXF1YW50aXR5LWNvbnRhaW5lcicpLmZpbmQoJy5wcm9kdWN0LXF1YW50aXR5Jyk7XHJcbiAgICBjb25zdCBtaW4gPSBwYXJzZUludCgkcXVhbnRpdHkucHJvcCgnbWluJyksIDEwKTtcclxuICAgIGNvbnN0IG1heCA9IHBhcnNlSW50KCRxdWFudGl0eS5wcm9wKCdtYXgnKSwgMTApO1xyXG4gICAgbGV0IG5ld1F1YW50aXR5ID0gcGFyc2VJbnQoJHF1YW50aXR5LnZhbCgpLCAxMCk7XHJcblxyXG4gICAgaWYgKGlzTmFOKG5ld1F1YW50aXR5KSkge1xyXG4gICAgICBuZXdRdWFudGl0eSA9IG1pbjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJHRhcmdldC5oYXNDbGFzcygncHJvZHVjdC1xdWFudGl0eS1pbmNyZW1lbnQnKSAmJiAoIW1heCB8fCBuZXdRdWFudGl0eSA8IG1heCkpIHtcclxuICAgICAgbmV3UXVhbnRpdHkgPSBuZXdRdWFudGl0eSArIDE7XHJcbiAgICB9IGVsc2UgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoJ3Byb2R1Y3QtcXVhbnRpdHktZGVjcmVtZW50JykgJiYgbmV3UXVhbnRpdHkgPiBtaW4pIHtcclxuICAgICAgbmV3UXVhbnRpdHkgPSBuZXdRdWFudGl0eSAtIDE7XHJcbiAgICB9XHJcblxyXG4gICAgJHF1YW50aXR5LnZhbChuZXdRdWFudGl0eSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgdG8gY2FydFxyXG4gICAqL1xyXG4gIF9iaW5kQWRkVG9DYXJ0KGV2ZW50LCBmb3JtKSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIC8vIFNraXAgdGhpcyBjYWxsYmFjayBpZiB0aGUgcHJvZHVjdCBpc24ndCB0aGUgb25lIHRoaXMgaW5zdGFuY2UgaXMgdHJhY2tpbmdcclxuICAgIGNvbnN0IGZvcm1Qcm9kdWN0SWQgPSBldmVudC50YXJnZXQucXVlcnlTZWxlY3RvcignW25hbWU9cHJvZHVjdF9pZF0nKS52YWx1ZTtcclxuICAgIGlmIChmb3JtUHJvZHVjdElkICE9PSB0aGlzLnByb2R1Y3RJZCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIEJhaWwgb3V0IGlmIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IEZvcm1EYXRhXHJcbiAgICBpZiAod2luZG93LkZvcm1EYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHF1YW50aXR5ID0gdGhpcy4kZWwuZmluZCgnaW5wdXQucHJvZHVjdC1xdWFudGl0eScpLnZhbCgpO1xyXG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBidXR0b24gc3RhdGVcclxuICAgIHRoaXMucHJvZ3Jlc3NCdXR0b24ucHJvZ3Jlc3ModGhpcy4kYWRkVG9DYXJ0KTtcclxuXHJcbiAgICAvLyBSZW1vdmUgb2xkIGFsZXJ0c1xyXG4gICAgdGhpcy5wYWdlQWxlcnRzLmNsZWFyKCk7XHJcbiAgICB0aGlzLnByb2R1Y3RBbGVydHMuY2xlYXIoKTtcclxuXHJcbiAgICAvLyBBamF4IGFkZCBpdGVtIHRvIGNhcnRcclxuICAgIHV0aWxzLmFwaS5jYXJ0Lml0ZW1BZGQodGhpcy5maWx0ZXJFbXB0eUZpbGVzRnJvbUZvcm0oZm9ybURhdGEpLCAoZXJyLCByZXNwb25zZSkgPT4ge1xyXG4gICAgICAvLyBQYXJzZSB0aGUgYWpheCByZXNwb25zZSBzbyB3ZSBjYW4gcGFzcyBpdCB0byB0aGUgbWVzc2FnZS5cclxuICAgICAgcmVzcG9uc2UgPSB0aGlzLl9wYXJzZVJlc3BvbnNlKGVyciwgcmVzcG9uc2UsIHRoaXMucHJvZHVjdFRpdGxlLCBxdWFudGl0eSk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAnc3VjY2VzcycpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHRoaXMucGFnZUFsZXJ0cy5tZXNzYWdlKHJlc3BvbnNlLm1lc3NhZ2UsIHJlc3BvbnNlLnN0YXR1cywgdHJ1ZSk7XHJcbiAgICAgICAgfSwgNTApO1xyXG5cclxuICAgICAgICAvLyBDdXN0b20gc3VjY2VzcyBldmVudCB0byBjbG9zZSB0aGUgcXVpY2sgc2hvcCBhbmQgb3BlbiB0aGUgbWluaSBjYXJ0XHJcbiAgICAgICAgJC5ldmVudC50cmlnZ2VyKCdjYXJ0LWl0ZW0tYWRkLXN1Y2Nlc3MnKTtcclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnBhZ2VBbGVydHMuY2xlYXIoKTtcclxuICAgICAgICB9LCA1MDAwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnByb2R1Y3RBbGVydHMubWVzc2FnZShyZXNwb25zZS5tZXNzYWdlLCByZXNwb25zZS5zdGF0dXMsIHRydWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXNldCB0aGUgYnV0dG9uIHN0YXRlXHJcbiAgICAgIHRoaXMucHJvZ3Jlc3NCdXR0b24uY29tcGxldGUodGhpcy4kYWRkVG9DYXJ0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGQgb3VyIGVycm9yL3N1Y2Nlc3MgbWVzc2FnZXMgYmFzZWQgb24gcmVzcG9uc2UuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGVyciAtIHRoZSAocG90ZW50aWFsKSByZXR1cm5lZCBlcnJvciBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIC0gdGhlIGFqYXggcmVzcG9uc2UgZnJvbSB0aGUgYWRkLXRvLWNhcnQgYWN0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAtIFRoZSBuYW1lIG9mIHRoZSBhZGRlZCBwcm9kdWN0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFudGl0eSAtIFRoZSBhZGRlZCBxdWFudGl0eS5cclxuICAgKi9cclxuICBfcGFyc2VSZXNwb25zZShlcnIsIHJlc3BvbnNlLCB0aXRsZSwgcXVhbnRpdHkpIHtcclxuICAgIGxldCBtZXNzYWdlID0gJyc7XHJcbiAgICBsZXQgc3RhdHVzID0gJyc7XHJcblxyXG4gICAgaWYgKGVyciB8fCByZXNwb25zZS5kYXRhLmVycm9yKSB7XHJcbiAgICAgIHN0YXR1cyA9ICdlcnJvcic7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YS5lcnJvcikge1xyXG4gICAgICAgIG1lc3NhZ2UgPSByZXNwb25zZS5kYXRhLmVycm9yO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnRleHQubWVzc2FnZXNQcm9kdWN0R2VuZXJhbDtcclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXR1cyA9ICdzdWNjZXNzJztcclxuICAgICAgaWYgKHRoaXMuJHByb2R1Y3RDb250YWluZXIuaGFzQ2xhc3MoJ2JhZy1pY29uJykpIHtcclxuICAgICAgICBtZXNzYWdlID0gdGhpcy5jb250ZXh0Lm1lc3NhZ2VzUHJvZHVjdEFkZFN1Y2Nlc3NCYWc7XHJcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcqcHJvZHVjdConLCBgXCIke3RpdGxlfVwiYClcclxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcqYmFnX2xpbmsqJywgYDxhIGhyZWY9JHt0aGlzLmNvbnRleHQudXJsc0NhcnR9PiR7dGhpcy5jb250ZXh0LmJhZ0xpbmt9PC9hPmApXHJcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnKmNoZWNrb3V0X2xpbmsqJywgYDxhIGhyZWY9JHt0aGlzLmNvbnRleHQudXJsc0NoZWNrb3V0fT4ke3RoaXMuY29udGV4dC5jaGVja291dExpbmt9PC9hPmApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnRleHQubWVzc2FnZXNQcm9kdWN0QWRkU3VjY2Vzc0NhcnQ7XHJcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcqcHJvZHVjdConLCBgXCIke3RpdGxlfVwiYClcclxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcqY2FydF9saW5rKicsIGA8YSBocmVmPSR7dGhpcy5jb250ZXh0LnVybHNDYXJ0fT4ke3RoaXMuY29udGV4dC5jYXJ0TGlua308L2E+YClcclxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcqY2hlY2tvdXRfbGluayonLCBgPGEgaHJlZj0ke3RoaXMuY29udGV4dC51cmxzQ2hlY2tvdXR9PiR7dGhpcy5jb250ZXh0LmNoZWNrb3V0TGlua308L2E+YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGF0dXM6IHN0YXR1cyxcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NoZWNrUXVhbnRpdHkoZWwpIHtcclxuICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xyXG4gICAgY29uc3QgcXVhbnRpdHkgPSBwYXJzZUludCgkZWwudmFsKCksIDEwKTtcclxuICAgIGNvbnN0IG1pbiA9IHBhcnNlSW50KCRlbC5wcm9wKCdtaW4nKSlcclxuXHJcbiAgICBpZiAoaXNOYU4ocXVhbnRpdHkpIHx8IHF1YW50aXR5IDwgbWluKSB7XHJcbiAgICAgICRlbC52YWwobWluKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFqYXggYWRkIHRvIHdpc2hsaXN0XHJcbiAgICpcclxuICAgKi9cclxuICBfYmluZEFkZFdpc2hsaXN0KCkge1xyXG4gICAgJCgnW2RhdGEtd2lzaGxpc3RdJykub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0ICRidXR0b24gPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICBjb25zdCBhZGRVcmwgPSAkYnV0dG9uLmF0dHIoJ2hyZWYnKTtcclxuICAgICAgY29uc3Qgdmlld1VybCA9ICRidXR0b24uZGF0YSgnd2lzaGxpc3QnKTtcclxuXHJcbiAgICAgIGlmICgkKCdbZGF0YS1pcy1jdXN0b21lcl0nKS5sZW5ndGgpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICB0aGlzLnByb2dyZXNzQnV0dG9uLnByb2dyZXNzKCRidXR0b24pO1xyXG5cclxuICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgdHlwZTogJ1BPU1QnLFxyXG4gICAgICAgICAgdXJsOiBhZGRVcmwsXHJcbiAgICAgICAgICBzdWNjZXNzOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZHVjdEFsZXJ0cy5zdWNjZXNzKHRoaXMuY29udGV4dC5tZXNzYWdlc1dpc2hsaXN0QWRkU3VjY2Vzcy5yZXBsYWNlKCcqcHJvZHVjdConLCB0aGlzLnByb2R1Y3RUaXRsZSkucmVwbGFjZSgnKnVybConLCB2aWV3VXJsKSwgdHJ1ZSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZXJyb3I6ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9kdWN0QWxlcnRzLmVycm9yKHRoaXMuY29udGV4dC5tZXNzYWdlc1dpc2hsaXN0QWRkRXJyb3IucmVwbGFjZSgnKnByb2R1Y3QqJywgdGhpcy5wcm9kdWN0VGl0bGUpLCB0cnVlKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzQnV0dG9uLmNvbXBsZXRlKCRidXR0b24pO1xyXG5cclxuICAgICAgICAgICAgJGJ1dHRvblxyXG4gICAgICAgICAgICAgIC5jbG9zZXN0KCdbZGF0YS13aXNobGlzdC1kcm9wZG93bl0nKVxyXG4gICAgICAgICAgICAgIC5maW5kKCdbZGF0YS13aXNobGlzdC10b2dnbGVdJylcclxuICAgICAgICAgICAgICAudHJpZ2dlcignY2xpY2snKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2V0UHJvZHVjdFZhcmlhbnQoKSB7XHJcbiAgICBjb25zdCB1bnNhdGlzZmllZFJlcXVpcmVkRmllbGRzID0gW107XHJcbiAgICBjb25zdCBvcHRpb25zID0gW107XHJcblxyXG4gICAgJC5lYWNoKCQoJ1tkYXRhLXByb2R1Y3QtYXR0cmlidXRlXScpLCAoaW5kZXgsIHZhbHVlKSA9PiB7XHJcbiAgICAgIGNvbnN0IG9wdGlvbkxhYmVsID0gdmFsdWUuY2hpbGRyZW5bMF0uaW5uZXJUZXh0O1xyXG4gICAgICBjb25zdCBvcHRpb25UaXRsZSA9IG9wdGlvbkxhYmVsLnNwbGl0KCc6JylbMF0udHJpbSgpO1xyXG4gICAgICBjb25zdCByZXF1aXJlZCA9IG9wdGlvbkxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3JlcXVpcmVkJyk7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcHJvZHVjdC1hdHRyaWJ1dGUnKTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICAodHlwZSA9PT0gJ2lucHV0LWZpbGUnIHx8IHR5cGUgPT09ICdpbnB1dC10ZXh0JyB8fCB0eXBlID09PSAnaW5wdXQtbnVtYmVyJylcclxuICAgICAgICAmJiB2YWx1ZS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnZhbHVlID09PSAnJyAmJiByZXF1aXJlZFxyXG4gICAgICApIHtcclxuICAgICAgICB1bnNhdGlzZmllZFJlcXVpcmVkRmllbGRzLnB1c2godmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gJ3RleHRhcmVhJyAmJiB2YWx1ZS5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpLnZhbHVlID09PSAnJyAmJiByZXF1aXJlZCkge1xyXG4gICAgICAgIHVuc2F0aXNmaWVkUmVxdWlyZWRGaWVsZHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlID09PSAnZGF0ZScpIHtcclxuICAgICAgICBjb25zdCBpc1NhdGlzZmllZCA9IEFycmF5LmZyb20odmFsdWUucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JykpLmV2ZXJ5KChzZWxlY3QpID0+IHNlbGVjdC5zZWxlY3RlZEluZGV4ICE9PSAwKTtcclxuXHJcbiAgICAgICAgaWYgKGlzU2F0aXNmaWVkKSB7XHJcbiAgICAgICAgICBjb25zdCBkYXRlU3RyaW5nID0gQXJyYXkuZnJvbSh2YWx1ZS5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKSkubWFwKCh4KSA9PiB4LnZhbHVlKS5qb2luKCctJyk7XHJcbiAgICAgICAgICBvcHRpb25zLnB1c2goYCR7b3B0aW9uVGl0bGV9OiR7ZGF0ZVN0cmluZ31gKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXF1aXJlZCkge1xyXG4gICAgICAgICAgICB1bnNhdGlzZmllZFJlcXVpcmVkRmllbGRzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGUgPT09ICdzZXQtc2VsZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdCA9IHZhbHVlLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCcpO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBzZWxlY3Quc2VsZWN0ZWRJbmRleDtcclxuXHJcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT09IDApIHtcclxuICAgICAgICAgIG9wdGlvbnMucHVzaChgJHtvcHRpb25UaXRsZX06JHtzZWxlY3Qub3B0aW9uc1tzZWxlY3RlZEluZGV4XS5pbm5lclRleHR9YCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVxdWlyZWQpIHtcclxuICAgICAgICAgIHVuc2F0aXNmaWVkUmVxdWlyZWRGaWVsZHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHlwZSA9PT0gJ3NldC1yZWN0YW5nbGUnXHJcbiAgICAgICAgfHwgdHlwZSA9PT0gJ3NldC1yYWRpbydcclxuICAgICAgICB8fCB0eXBlID09PSAnc3dhdGNoJ1xyXG4gICAgICAgIHx8IHR5cGUgPT09ICdpbnB1dC1jaGVja2JveCdcclxuICAgICAgICB8fCB0eXBlID09PSAncHJvZHVjdC1saXN0J1xyXG4gICAgICApIHtcclxuICAgICAgICBjb25zdCBjaGVja2VkID0gdmFsdWUucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKTtcclxuICAgICAgICBpZiAoY2hlY2tlZCkge1xyXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdzZXQtcmVjdGFuZ2xlJyB8fCB0eXBlID09PSAnc2V0LXJhZGlvJyB8fCB0eXBlID09PSAncHJvZHVjdC1saXN0Jykge1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNoZWNrZWQubGFiZWxzWzBdLmlubmVyVGV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICAgIG9wdGlvbnMucHVzaChgJHtvcHRpb25UaXRsZX06JHtsYWJlbH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICh0eXBlID09PSAnc3dhdGNoJykge1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNoZWNrZWQubGFiZWxzWzBdLmNoaWxkcmVuWzBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKGAke29wdGlvblRpdGxlfToke2xhYmVsLnRpdGxlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdpbnB1dC1jaGVja2JveCcpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKGAke29wdGlvblRpdGxlfTpZZXNgKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2lucHV0LWNoZWNrYm94Jykge1xyXG4gICAgICAgICAgb3B0aW9ucy5wdXNoKGAke29wdGlvblRpdGxlfTpOb2ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgIHVuc2F0aXNmaWVkUmVxdWlyZWRGaWVsZHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgcHJvZHVjdFZhcmlhbnQgPSB1bnNhdGlzZmllZFJlcXVpcmVkRmllbGRzLmxlbmd0aCA9PT0gMCA/IG9wdGlvbnMuc29ydCgpLmpvaW4oJywgJykgOiAndW5zYXRpc2ZpZWQnO1xyXG4gICAgY29uc3QgdmlldyA9ICQoJy5wcm9kdWN0LWRldGFpbHMnKTtcclxuXHJcbiAgICBpZiAocHJvZHVjdFZhcmlhbnQpIHtcclxuICAgICAgcHJvZHVjdFZhcmlhbnQgPSBwcm9kdWN0VmFyaWFudCA9PT0gJ3Vuc2F0aXNmaWVkJyA/ICcnIDogcHJvZHVjdFZhcmlhbnQ7XHJcblxyXG4gICAgICBpZiAodmlldy5hdHRyKCdkYXRhLWV2ZW50LXR5cGUnKSkge1xyXG4gICAgICAgIHZpZXcuYXR0cignZGF0YS1wcm9kdWN0LXZhcmlhbnQnLCBwcm9kdWN0VmFyaWFudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcHJvZHVjdE5hbWUgPSB2aWV3LmZpbmQoJy5wcm9kdWN0LXRpdGxlJylbMF0uaW5uZXJUZXh0O1xyXG4gICAgICAgIGNvbnN0IGNhcmQgPSAkKGBbZGF0YS1uYW1lPVwiJHtwcm9kdWN0TmFtZX1cIl1gKTtcclxuICAgICAgICBjYXJkLmF0dHIoJ2RhdGEtcHJvZHVjdC12YXJpYW50JywgcHJvZHVjdFZhcmlhbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBpbWFnZXNMb2FkZWQgZnJvbSAnaW1hZ2VzbG9hZGVkJztcbmltcG9ydCB1dGlscyBmcm9tICdAYmlnY29tbWVyY2Uvc3RlbmNpbC11dGlscyc7XG5pbXBvcnQgUHJvZHVjdFV0aWxzIGZyb20gJy4vUHJvZHVjdFV0aWxzJztcbmltcG9ydCBQcm9kdWN0SW1hZ2VzIGZyb20gJy4vUHJvZHVjdEltYWdlcyc7XG5pbXBvcnQgcHJvZHVjdFZpZXdUZW1wbGF0ZXMgZnJvbSAnLi9wcm9kdWN0Vmlld1RlbXBsYXRlcyc7XG5pbXBvcnQgdmFyaWF0aW9uSW1nUHJldmlldyBmcm9tICcuL3ZhcmlhdGlvbkltZ1ByZXZpZXcnO1xuaW1wb3J0IENvbG9yU3dhdGNoIGZyb20gJy4uL3Byb2R1Y3QvQ29sb3JTd2F0Y2gnO1xuaW1wb3J0IE1vZGFsIGZyb20gJ2JjLW1vZGFsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVpY2tTaG9wIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5wcm9kdWN0O1xuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gU2V0IHVwIHRoZSBtb2RhbCBvcHRpb25zXG4gICAgdGhpcy5RdWlja1Nob3BNb2RhbCA9IG5ldyBNb2RhbCh7XG4gICAgICBtb2RhbENsYXNzOiAnbW9kYWwtcXVpY2stc2hvcCcsXG4gICAgICBjZW50ZXJWZXJ0aWNhbGx5OiBmYWxzZSxcbiAgICAgIGFmdGVyU2hvdzogKCRtb2RhbCkgPT4ge1xuICAgICAgICB1dGlscy5ob29rcy5vZmYoJ3Byb2R1Y3Qtb3B0aW9uLWNoYW5nZScpO1xuICAgICAgICB0aGlzLl9mZXRjaFByb2R1Y3QoJG1vZGFsLCB0aGlzLmlkKTtcbiAgICAgIH0sXG4gICAgICBhZnRlckhpZGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5Qcm9kdWN0VXRpbHMgPSBuZXcgUHJvZHVjdFV0aWxzKCdbZGF0YS1wcm9kdWN0LWNvbnRhaW5lcl0nLCB7XG4gICAgICAgICAgcHJpY2VXaXRob3V0VGF4VGVtcGxhdGU6IHByb2R1Y3RWaWV3VGVtcGxhdGVzLnByaWNlV2l0aG91dFRheCxcbiAgICAgICAgICBwcmljZVdpdGhUYXhUZW1wbGF0ZTogcHJvZHVjdFZpZXdUZW1wbGF0ZXMucHJpY2VXaXRoVGF4LFxuICAgICAgICAgIHByaWNlU2F2ZWRUZW1wbGF0ZTogcHJvZHVjdFZpZXdUZW1wbGF0ZXMucHJpY2VTYXZlZCxcbiAgICAgICAgICB2YXJpYXRpb25QcmV2aWV3SW1hZ2VUZW1wbGF0ZTogcHJvZHVjdFZpZXdUZW1wbGF0ZXMudmFyaWF0aW9uUHJldmlld0ltYWdlLFxuICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgc3dpdGNoSW1hZ2U6IHZhcmlhdGlvbkltZ1ByZXZpZXdcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmluaXQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgdGhpcy5wcm9kdWN0LmRlc3Ryb3koKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogTGF1bmNoIHF1aWNrc2hvcCBtb2RhbCBvbiBjbGljayBhbmQgc2V0IHVwIGlkIHZhcmlhYmxlXG4gICAqL1xuICBfYmluZEV2ZW50cygpIHtcbiAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJ1tkYXRhLXF1aWNrLXNob3BdJywgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLmlkID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKCdwcm9kdWN0LWlkJyk7XG5cbiAgICAgIGlmICghdGhpcy5pZCkgeyByZXR1cm47IH1cblxuICAgICAgdGhpcy5RdWlja1Nob3BNb2RhbC5vcGVuKCk7XG5cbiAgICAgICQoJy5tb2RhbC1jb250ZW50JykucHJlcGVuZCgnPHN2ZyBjbGFzcz1cImljb24gaWNvbi1zcGlubmVyXCI+PHVzZSB4bGluazpocmVmPVwiI2ljb24tc3Bpbm5lclwiIC8+PC9zdmc+Jyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGFqYXggZmV0Y2ggb2YgcHJvZHVjdCBhbmQgYWRkIHRvIG1vZGFsLiBCaW5kIHByb2R1Y3QgZnVuY3Rpb25hbGl0eSBhbmQgc2hvdyB0aGUgbW9kYWxcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRtb2RhbCAtIHRoZSByb290IChhcHBlbmRlZCkgbW9kYWwgZWxlbWVudC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBpZCAtIHByb2R1Y3QgaWRcbiAgICovXG4gIF9mZXRjaFByb2R1Y3QoJG1vZGFsLCBpZCkge1xuICAgIHV0aWxzLmFwaS5wcm9kdWN0LmdldEJ5SWQoaWQsIHsgdGVtcGxhdGU6ICdxdWljay1zaG9wL3F1aWNrLXNob3AtbW9kYWwnIH0sIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAkbW9kYWwuZmluZCgnLm1vZGFsLWNvbnRlbnQnKS5hcHBlbmQocmVzcG9uc2UpO1xuXG4gICAgICAvLyBJbml0IEZCIGxpa2UgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoJG1vZGFsLmZpbmQoJy5mYWNlYm9vay1saWtlJykubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbihkLCBzLCBpZCkge1xuICAgICAgICAgIHZhciBqcywgZmpzID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZShzKVswXTtcbiAgICAgICAgICBpZiAoZC5nZXRFbGVtZW50QnlJZChpZCkpIHJldHVybjtcbiAgICAgICAgICBqcyA9IGQuY3JlYXRlRWxlbWVudChzKTsganMuaWQgPSBpZDtcbiAgICAgICAgICBqcy5zcmMgPSBcIi8vY29ubmVjdC5mYWNlYm9vay5uZXQvZW5fVVMvc2RrLmpzI3hmYm1sPTEmdmVyc2lvbj12Mi41XCI7XG4gICAgICAgICAgZmpzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGpzLCBmanMpO1xuICAgICAgICB9KGRvY3VtZW50LCAnc2NyaXB0JywgJ2ZhY2Vib29rLWpzc2RrJykpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdXAgcHJvZHVjdCB1dGlscyAoYWRkaW5nIHRvIGNhcnQsIG9wdGlvbnMpXG4gICAgICBjb25zdCAkZWwgPSAkbW9kYWwuZmluZCgnW2RhdGEtcHJvZHVjdC1xdWlja3Nob3AtY29udGFpbmVyXScpO1xuXG4gICAgICB0aGlzLnByb2R1Y3QgPSBuZXcgUHJvZHVjdFV0aWxzKCRlbCwge1xuICAgICAgICBwcmljZVdpdGhvdXRUYXhUZW1wbGF0ZTogcHJvZHVjdFZpZXdUZW1wbGF0ZXMucHJpY2VXaXRob3V0VGF4LFxuICAgICAgICBwcmljZVdpdGhUYXhUZW1wbGF0ZTogcHJvZHVjdFZpZXdUZW1wbGF0ZXMucHJpY2VXaXRoVGF4LFxuICAgICAgICBwcmljZVNhdmVkVGVtcGxhdGU6IHByb2R1Y3RWaWV3VGVtcGxhdGVzLnByaWNlU2F2ZWQsXG4gICAgICAgIHZhcmlhdGlvblByZXZpZXdJbWFnZVRlbXBsYXRlOiBwcm9kdWN0Vmlld1RlbXBsYXRlcy52YXJpYXRpb25QcmV2aWV3SW1hZ2UsXG4gICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgIHN3aXRjaEltYWdlOiB2YXJpYXRpb25JbWdQcmV2aWV3XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMucHJvZHVjdC5pbml0KHRoaXMuY29udGV4dCk7XG5cbiAgICAgIC8vIHNldCB1cCBzaW1wbGUgaW1hZ2Ugc2xpZGVzaG93XG4gICAgICBuZXcgUHJvZHVjdEltYWdlcygnLm1vZGFsLXF1aWNrLXNob3AgLnByb2R1Y3Qtc2xpZGVzLXdyYXAnKTtcblxuICAgICAgdGhpcy5zd2F0Y2hlcyA9IG5ldyBDb2xvclN3YXRjaCgpOyAvLyBJbml0IG91ciBjb2xvciBzd2F0Y2hlc1xuXG4gICAgICAvLyByZXBvc2l0aW9uIG1vZGFsIHdpdGggY29udGVudFxuICAgICAgdGhpcy5RdWlja1Nob3BNb2RhbC5wb3NpdGlvbigpO1xuXG4gICAgICAkbW9kYWwuYWRkQ2xhc3MoJ2xvYWRlZCcpO1xuXG4gICAgICAkKCcubW9kYWwtY29udGVudCcpLmNoaWxkcmVuKCcuaWNvbi1zcGlubmVyJykucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJpY2VXaXRob3V0VGF4OiBfLnRlbXBsYXRlKGBcbiAgICA8JSBpZiAocHJpY2UucnJwX3dpdGhvdXRfdGF4KSB7ICU+XG4gICAgICA8ZGl2IGNsYXNzPVwicHJpY2UtcnJwLXdyYXBwZXJcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwicHJpY2UtcnJwLWxhYmVsXCI+PCU9IHJldGFpbFByaWNlTGFiZWwgJT48L2xhYmVsPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInByaWNlLXJycFwiPjwlPSBwcmljZS5ycnBfd2l0aG91dF90YXguZm9ybWF0dGVkICU+PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgPCUgfSAlPlxuICAgIDwlIGlmIChwcmljZS5ub25fc2FsZV9wcmljZV93aXRob3V0X3RheCkgeyAlPlxuICAgICAgPGRpdiBjbGFzcz1cInByaWNlLW5zLXdyYXBwZXJcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwicHJpY2UtbnMtbGFiZWxcIj48JT0gbm9uU2FsZVByaWNlTGFiZWwgJT48L2xhYmVsPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInByaWNlLW5zXCI+XG4gICAgICAgICAgPCU9IHByaWNlLm5vbl9zYWxlX3ByaWNlX3dpdGhvdXRfdGF4LmZvcm1hdHRlZCAlPlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICA8JSB9ICU+XG4gICAgPGRpdiBjbGFzcz1cInByaWNlLXZhbHVlLXdyYXBwZXJcIj5cbiAgICAgIDwhLS0gSWYgdGhlcmUncyBhbm90aGVyIHByaWNlIHNob3cgXCJub3dcIiBsYWJlbCAtLT5cbiAgICAgIDwlIGlmIChwcmljZS5ub25fc2FsZV9wcmljZV93aXRob3V0X3RheCkgeyAlPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJwcmljZS12YWx1ZS1sYWJlbFwiPjwlPSBzYWxlUHJpY2VMYWJlbCAlPjwvbGFiZWw+XG4gICAgICA8JSB9IGVsc2UgeyAlPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJwcmljZS1sYWJlbFwiPjwlPSBwcmljZUxhYmVsICU+PC9sYWJlbD5cbiAgICAgIDwlIH0gJT5cbiAgICAgIDxzcGFuIGNsYXNzPVwicHJpY2UtdmFsdWVcIiBkYXRhLXByb2R1Y3QtcHJpY2U+XG4gICAgICAgIDwlPSBwcmljZS53aXRob3V0X3RheC5mb3JtYXR0ZWQgJT5cbiAgICAgIDwvc3Bhbj5cbiAgICAgIDwlIGlmIChwcmljZS53aXRoX3RheCAmJiBwcmljZS53aXRob3V0X3RheCkgeyAlPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInByaWNlLXRheC1sYWJlbFwiPjwlPSBleGNsdWRpbmdUYXggJT48L3NwYW4+XG4gICAgICA8JSB9ICU+XG4gICAgPC9kaXY+XG4gIGApLFxuXG4gIHByaWNlV2l0aFRheDogXy50ZW1wbGF0ZShgXG4gICAgPCUgaWYgKHByaWNlLnJycF93aXRoX3RheCkgeyAlPlxuICAgICAgPGRpdiBjbGFzcz1cInByaWNlLXJycC13cmFwcGVyXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cInByaWNlLXJycC1sYWJlbFwiPjwlPSByZXRhaWxQcmljZUxhYmVsICU+PC9sYWJlbD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJwcmljZS1ycnBcIj48JT0gcHJpY2UucnJwX3dpdGhfdGF4LmZvcm1hdHRlZCAlPjwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwlIH0gJT5cbiAgICA8JSBpZiAocHJpY2Uubm9uX3NhbGVfcHJpY2Vfd2l0aG91dF90YXgpIHsgJT5cbiAgICAgIDxkaXYgY2xhc3M9XCJwcmljZS1ucy13cmFwcGVyXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cInByaWNlLW5zLWxhYmVsXCI+PCU9IG5vblNhbGVQcmljZUxhYmVsICU+PC9sYWJlbD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJwcmljZS1uc1wiPlxuICAgICAgICAgIDwlPSBwcmljZS5ub25fc2FsZV9wcmljZV93aXRoX3RheC5mb3JtYXR0ZWQgJT5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgPCUgfSAlPlxuICAgIDxkaXYgY2xhc3M9XCJwcmljZS12YWx1ZS13cmFwcGVyXCI+XG4gICAgICA8IS0tIElmIHRoZXJlJ3MgYW5vdGhlciBwcmljZSBzaG93IFwibm93XCIgbGFiZWwgLS0+XG4gICAgICA8JSBpZiAocHJpY2Uubm9uX3NhbGVfcHJpY2Vfd2l0aF90YXgpIHsgJT5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwicHJpY2UtdmFsdWUtbGFiZWxcIj48JT0gc2FsZVByaWNlTGFiZWwgJT48L2xhYmVsPlxuICAgICAgPCUgfSBlbHNlIHsgJT5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwicHJpY2UtbGFiZWxcIj48JT0gcHJpY2VMYWJlbCAlPjwvbGFiZWw+XG4gICAgICA8JSB9ICU+XG4gICAgICA8c3BhbiBjbGFzcz1cInByaWNlLXZhbHVlXCIgZGF0YS1wcm9kdWN0LXByaWNlPlxuICAgICAgICA8JT0gcHJpY2Uud2l0aF90YXguZm9ybWF0dGVkICU+XG4gICAgICA8L3NwYW4+XG4gICAgICA8JSBpZiAocHJpY2Uud2l0aF90YXggJiYgcHJpY2Uud2l0aG91dF90YXgpIHsgJT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJwcmljZS10YXgtbGFiZWxcIj48JT0gaW5jbHVkaW5nVGF4ICU+PC9zcGFuPlxuICAgICAgPCUgfSAlPlxuICAgIDwvZGl2PlxuICBgKSxcblxuICBwcmljZVNhdmVkOiBfLnRlbXBsYXRlKGBcbiAgICA8JSBpZiAocHJpY2Uuc2F2ZWQpIHsgJT5cbiAgICAgIDwlPSBzYXZlZFN0cmluZyAlPiA8JT0gcHJpY2Uuc2F2ZWQuZm9ybWF0dGVkICU+XG4gICAgPCUgfSAlPlxuICBgKSxcblxuICB2YXJpYXRpb25JbWFnZTogXy50ZW1wbGF0ZShgXG4gICAgPGEgY2xhc3M9XCJwcm9kdWN0LWltYWdlXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWltYWdlOnVybCg8JT0gem9vbUltYWdlU3JjICU+KTtcIiBocmVmPVwiPCU9IHpvb21JbWFnZVNyYyAlPlwiIGRhdGEtcHJvZHVjdC1pbWFnZSBkYXRhLXByb2R1Y3QtaW1hZ2UtdmFyaWFudD5cbiAgICAgIDxpbWcgc3JjPVwiPCU9IHByb2R1Y3RJbWFnZVNyYyAlPlwiPlxuICAgIDwvYT5cbiAgYCksXG5cbiAgdmFyaWF0aW9uSW1hZ2VOYXY6IF8udGVtcGxhdGUoYFxuICAgIDxkaXYgY2xhc3M9XCJwYWdpbmF0aW9uLWl0ZW1cIiBkYXRhLXZhcmlhbnQtaWQ9XCI8JT0gaWQgJT5cIj5cbiAgICAgIDxpbWcgc3JjPVwiPCU9IHByb2R1Y3RJbWFnZVNyYyAlPlwiPlxuICAgIDwvZGl2PlxuICBgKSxcbn07XG4iLCJpbXBvcnQgc2Nyb2xsVG9Ub3AgZnJvbSAnLi4vdXRpbHMvc2Nyb2xsVG9Ub3AnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNldFByb2R1Y3RJbWFnZXMoJGVsKSB7XG4gIGNvbnN0IG51bVNsaWRlcyA9ICRlbC5maW5kKCdbZGF0YS1wcm9kdWN0LWltYWdlXScpLmxlbmd0aCAtIDE7XG4gIGNvbnN0IG1haW5TbGlkZSA9ICRlbC5maW5kKCdbZGF0YS1wcm9kdWN0LWltYWdlXScpLmluZGV4KCdbZGF0YS1wcm9kdWN0LW1haW4taW1hZ2VdJyk7XG5cbiAgJGVsLnNsaWNrKCdzbGlja0dvVG8nLCBtYWluU2xpZGUpO1xuICAkZWwuc2xpY2soJ3NsaWNrUmVtb3ZlJywgbnVtU2xpZGVzKTtcbiAgc2Nyb2xsVG9Ub3AoKTtcbn1cbiIsImltcG9ydCBzbGljayBmcm9tICdzbGljay1jYXJvdXNlbCc7XG5pbXBvcnQgcHJvZHVjdFZpZXdUZW1wbGF0ZXMgZnJvbSAnLi9wcm9kdWN0Vmlld1RlbXBsYXRlcyc7XG5pbXBvcnQgUHJvZHVjdEltYWdlcyBmcm9tICcuL1Byb2R1Y3RJbWFnZXMnO1xuaW1wb3J0IGJhZ3VldHRlQm94IGZyb20gJ2JhZ3VldHRlYm94LmpzJztcbmltcG9ydCBJbWFnZVpvb20gZnJvbSAnLi9JbWFnZVpvb20nO1xuaW1wb3J0IGltYWdlc0xvYWRlZCBmcm9tICdpbWFnZXNsb2FkZWQnO1xuaW1wb3J0IHNjcm9sbFRvVG9wIGZyb20gJy4uL3V0aWxzL3Njcm9sbFRvVG9wJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFyaWF0aW9uSW1nUHJldmlldyhwcm9kdWN0SW1hZ2VVcmwsIHpvb21JbWFnZVVybCwgYWx0LCBpbWFnZUlkKSB7XG4gIGNvbnN0IHByb2R1Y3RJbWdzID0gJy5wcm9kdWN0LXNsaWRlcy13cmFwJztcblxuICAvLyBPbmx5IGFwcGVuZCBpZiBpbWFnZSBkb2Vzbid0IGFscmVhZHkgZXhpc3QuXG4gIC8vIE90aGVyd2lzZSwgc2Nyb2xsIHRvIGl0LlxuICBpZiAoISQoYGltZ1tzcmM9XCIke3Byb2R1Y3RJbWFnZVVybH1cIl1gKS5sZW5ndGgpIHtcbiAgICBjb25zdCBudW1TbGlkZXMgPSAkKCdbZGF0YS1wcm9kdWN0LWltYWdlXScpLmxlbmd0aDtcblxuICAgIGlmICgkKCdbZGF0YS1wcm9kdWN0LWltYWdlLXZhcmlhbnRdJykubGVuZ3RoKSB7XG4gICAgICAkKHByb2R1Y3RJbWdzKS5zbGljaygnc2xpY2tSZW1vdmUnLCBudW1TbGlkZXMgLSAxKTtcbiAgICB9XG5cbiAgICBiYWd1ZXR0ZUJveC5kZXN0cm95KCk7XG5cbiAgICAvLyBBZGQgY2Fyb3VzZWwgaW1hZ2VcbiAgICAkKHByb2R1Y3RJbWdzKS5zbGljaygnc2xpY2tBZGQnLCBwcm9kdWN0Vmlld1RlbXBsYXRlcy52YXJpYXRpb25JbWFnZSh7XG4gICAgICBwcm9kdWN0SW1hZ2VTcmM6IHByb2R1Y3RJbWFnZVVybCxcbiAgICAgIHpvb21JbWFnZVNyYzogem9vbUltYWdlVXJsLFxuICAgICAgYWx0OiBhbHRcbiAgICB9KSk7XG5cbiAgICBpbWFnZXNMb2FkZWQocHJvZHVjdEltZ3MsIHsgYmFja2dyb3VuZDogdHJ1ZSB9LCAoKSA9PiB7XG4gICAgICBiYWd1ZXR0ZUJveC5ydW4oJy5wcm9kdWN0LXNsaWRlcy13cmFwJywge30pO1xuXG4gICAgICAkKHByb2R1Y3RJbWdzKS5zbGljaygnc2xpY2tHb1RvJywgbnVtU2xpZGVzICsgMSk7XG5cbiAgICAgIC8vIEltYWdlIHpvb20gZm9yIG5ld2x5IGFkZGVkIGltYWdlXG4gICAgICAkKHByb2R1Y3RJbWdzKS5maW5kKCdbZGF0YS1wcm9kdWN0LWltYWdlXScpLmVhY2goKGksIGVsKSA9PiB7XG4gICAgICAgIG5ldyBJbWFnZVpvb20oZWwpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyB3aXNobGlzdERyb3Bkb3duIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kcm9wZG93biA9ICdbZGF0YS13aXNobGlzdC1kcm9wZG93bl0nO1xuICAgIHRoaXMudG9nZ2xlID0gJ1tkYXRhLXdpc2hsaXN0LXRvZ2dsZV0nO1xuICAgIHRoaXMucGFuZWwgPSAnW2RhdGEtd2lzaGxpc3QtcGFuZWxdJztcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCB0aGlzLnRvZ2dsZSwgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl90b2dnbGVEcm9wZG93bihldmVudCk7XG4gICAgfSk7XG4gIH1cblxuICBfdG9nZ2xlRHJvcGRvd24oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgJChldmVudC5jdXJyZW50VGFyZ2V0KVxuICAgICAgLmNsb3Nlc3QodGhpcy5kcm9wZG93bilcbiAgICAgIC5maW5kKHRoaXMucGFuZWwpXG4gICAgICAucmV2ZWFsZXIoJ3RvZ2dsZScpO1xuXG4gICAgJCh0aGlzLnRvZ2dsZSlcbiAgICAgIC5maWx0ZXIoJCh0aGlzLnRvZ2dsZSkubm90KCQoZXZlbnQuY3VycmVudFRhcmdldCkpKVxuICAgICAgLmNsb3Nlc3QodGhpcy5kcm9wZG93bilcbiAgICAgIC5maW5kKHRoaXMucGFuZWwpXG4gICAgICAucmV2ZWFsZXIoJ2hpZGUnKTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybVZhbGlkYXRvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuZm9ybVNlbGVjdG9yID0gJ1tkYXRhLXZhbGlkYXRlZC1mb3JtXSc7XG5cbiAgICB0aGlzLnZhbGlkYXRpb25PcHRpb25zID0ge307XG5cbiAgICB0aGlzLnZhbGlkYXRpb25NZXNzYWdlcyA9IHtcbiAgICAgIHJlcXVpcmVkICAgIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGVtYWlsICAgICAgIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25FbWFpbCxcbiAgICAgIG51bWJlciAgICAgIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25OdW1iZXIsXG4gICAgICBudW1NYXggICAgICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uTnVtYmVyTWF4LFxuICAgICAgbnVtTWluICAgICAgOiB0aGlzLmNvbnRleHQudmFsaWRhdGlvbk51bWJlck1pbixcbiAgICAgIG51bVJhbmdlICAgIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25OdW1iZXJSYW5nZSxcbiAgICAgIG1heExlbmd0aCAgIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25NYXhMZW5ndGgsXG4gICAgICBtaW5MZW5ndGggICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uTWluTGVuZ3RoLFxuICAgICAgbWF4Q2hlY2tlZCAgOiB0aGlzLmNvbnRleHQudmFsaWRhdGlvbk1heENoZWNrZWQsXG4gICAgICBtaW5DaGVja2VkICA6IHRoaXMuY29udGV4dC52YWxpZGF0aW9uTWluQ2hlY2tlZCxcbiAgICAgIG1heFNlbGVjdGVkIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25NYXhTZWxlY3RlZCxcbiAgICAgIG1pblNlbGVjdGVkIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25NaW5TZWxlY3RlZCxcbiAgICAgIG5vdEVxdWFsICAgIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25Ob3RFcXVhbCxcbiAgICAgIGRpZmZlcmVudCAgIDogdGhpcy5jb250ZXh0LnZhbGlkYXRpb25EaWZmZXJlbnQsXG4gICAgfTtcbiAgfVxuXG4gIC8qXG4gICAqIEluaXRpYWxpemUgdmFsaWRhdGlvbiBvbiBhbGwgbWF0Y2hpbmcgZm9ybXMgb24gcGFnZSBsb2FkXG4gICAqL1xuICBpbml0R2xvYmFsKCkge1xuICAgICQodGhpcy5mb3JtU2VsZWN0b3IpLnZhbGlkZXR0YSh0aGlzLm9wdGlvbnMsIHRoaXMudmFsaWRhdGlvbk1lc3NhZ2VzKTtcbiAgfVxuXG4gIC8qXG4gICAqIE1hbnVhbGx5IGluaXRpYWxpemUgdmFsaWRhdGlvbiBvbiB0YXJnZXQgZm9ybVxuICAgKlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGZvcm0gLSB0YXJnZXQgZm9ybSB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbG9jYWxPcHRpb25zIC0gYSBzZXQgb2Ygb3B0aW9ucyBzZXBhcmF0ZSBmcm9tIHRoZSBvbmVzIGRlZmluZWQgaGVyZSAob3B0aW9uYWwpXG4gICAqL1xuICBpbml0U2luZ2xlKCRmb3JtLCBsb2NhbE9wdGlvbnMpIHtcbiAgICBjb25zdCBjdXN0b21PcHRpb25zID0gbG9jYWxPcHRpb25zID8gbG9jYWxPcHRpb25zIDogdGhpcy52YWxpZGF0aW9uT3B0aW9ucztcbiAgICAkKCRmb3JtKS52YWxpZGV0dGEoY3VzdG9tT3B0aW9ucywgdGhpcy52YWxpZGF0aW9uTWVzc2FnZXMpO1xuICB9XG59XG4iLCJpbXBvcnQgc3ZnSWNvbiBmcm9tICcuLi9nbG9iYWwvc3ZnSWNvbic7XG5cbi8qKlxuICogVG9nZ2xlIGEgcHJvZ3Jlc3MgYnV0dG9uIHN0YXRlIHdpdGggYWx0ZXJuYXRlIHRleHRcbiAqIHRoZSBidXR0b24gbmVlZHMgYSBjbGFzcyBvZiBidXR0b24tcHJvZ3Jlc3NcbiAqIHRoZSBidXR0b24gdGV4dCBuZWVkcyB0byBiZSB3cmFwcGVkIGluIGFuIGV4dHJhIC5idXR0b24tdGV4dCBlbGVtZW50IHdpdGhpbiB0aGUgYnV0dG9uIGVsZW1lbnQgaXRzZWxmXG4gKiB0aGUgYnV0dG9uIHNob3VsZCBwcm9iYWJseSBoYXZlIGEgZGF0YS1wcm9ncmVzcy10ZXh0IGF0dHJpYnV0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyZXNzQnV0dG9uIHtcbiAgcHJvZ3Jlc3MoJGJ1dHRvbikge1xuICAgIC8vIGNhY2hlIHRoZSBjdXJyZW50IGJ1dHRvbiB0ZXh0XG4gICAgJGJ1dHRvbi5kYXRhKCdkZWZhdWx0VGV4dCcsICRidXR0b24udGV4dCgpKTtcblxuICAgIGNvbnN0IHByb2dyZXNzVGV4dCA9ICRidXR0b24uYXR0cignZGF0YS1wcm9ncmVzcy10ZXh0JykgfHwgJGJ1dHRvbi50ZXh0KCk7XG4gICAgY29uc3Qgc3Bpbm5lciA9ICRidXR0b24uaGFzQ2xhc3MoJ3NwaW5uZXInKSA/IHN2Z0ljb24oJ3NwaW5uZXInKSA6ICcnO1xuXG4gICAgJGJ1dHRvblxuICAgICAgLmFkZENsYXNzKCdwcm9ncmVzcycpXG4gICAgICAuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKVxuICAgICAgLmFwcGVuZChzcGlubmVyKVxuICAgICAgLmZpbmQoJy5idXR0b24tdGV4dCcpXG4gICAgICAuaHRtbChwcm9ncmVzc1RleHQpO1xuICB9XG5cbiAgY29tcGxldGUoJGJ1dHRvbikge1xuICAgIGNvbnN0IGRlZmF1bHRUZXh0ID0gJGJ1dHRvbi5kYXRhKCdkZWZhdWx0VGV4dCcpO1xuXG4gICAgJGJ1dHRvblxuICAgICAgLnJlbW92ZUNsYXNzKCdwcm9ncmVzcycpXG4gICAgICAuYXR0cignZGlzYWJsZWQnLCBmYWxzZSlcbiAgICAgIC5maW5kKCcuYnV0dG9uLXRleHQnKVxuICAgICAgLmh0bWwoZGVmYXVsdFRleHQpXG4gICAgICAubmV4dCgnLmljb24tc3Bpbm5lcicpXG4gICAgICAucmVtb3ZlKCk7XG4gIH1cbn1cbiIsImNvbnN0IGNoYW5nZVdpc2hsaXN0UGFnaW5hdGlvbkxpbmtzID0gKHdpc2hsaXN0VXJsLCAuLi5wYWdpbmF0aW9uSXRlbXMpID0+ICQuZWFjaChwYWdpbmF0aW9uSXRlbXMsIChfLCAkaXRlbSkgPT4ge1xuICAgIGlmICgkaXRlbS5sZW5ndGggJiYgISRpdGVtLmF0dHIoJ2hyZWYnKS5pbmNsdWRlcygncGFnZT0nKSkge1xuICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gJGl0ZW0uYXR0cignaHJlZicpO1xuICAgICAgICAkaXRlbS5hdHRyKCdocmVmJywgYCR7d2lzaGxpc3RVcmx9cGFnZT0ke3BhZ2VOdW1iZXJ9YCk7XG4gICAgfVxufSk7XG5cbi8qKlxuKiBoZWxwcyB0byB3aXRoZHJhdyBkaWZmZXJlbmNlcyBpbiBzdHJ1Y3R1cmVzIGFyb3VuZCB0aGUgc3RlbmNpbCByZXNvdXJjZSBwYWdpbmF0aW9uXG4qL1xuXG5leHBvcnQgY29uc3Qgd2lzaGxpc3RQYWdpbmF0aW9uSGVscGVyID0gKCkgPT4ge1xuICAgIGNvbnN0ICRwYWdpbmF0aW9uID0gJCgnLnBhZ2luYXRpb24nKTtcblxuICAgIGlmICghJHBhZ2luYXRpb24ubGVuZ3RoKSByZXR1cm47XG5cbiAgICBjb25zdCAkbmV4dEl0ZW0gPSAkKCcubmV4dCcsICRwYWdpbmF0aW9uKTtcbiAgICBjb25zdCAkcHJldkl0ZW0gPSAkKCcucHJldmlvdXMnLCAkcGFnaW5hdGlvbik7XG4gICAgY29uc3QgY3VycmVudEhyZWYgPSAkKCdbZGF0YS1wYWdpbmF0aW9uLWN1cnJlbnQtcGFnZS1saW5rXScpLmF0dHIoJ2hyZWYnKTtcbiAgICBjb25zdCBwYXJ0aWFsUGFnaW5hdGlvblVybCA9IGN1cnJlbnRIcmVmLnNwbGl0KCdwYWdlPScpLnNoaWZ0KCk7XG5cbiAgICBjaGFuZ2VXaXNobGlzdFBhZ2luYXRpb25MaW5rcyhwYXJ0aWFsUGFnaW5hdGlvblVybCwgJHByZXZJdGVtLCAkbmV4dEl0ZW0pO1xufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNjcm9sbFRvVG9wKCkge1xuICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XG4gICAgc2Nyb2xsVG9wOiAkKCcuc2l0ZS1jYW52YXMnKS5vZmZzZXQoKS50b3BcbiAgfSk7XG59XG4iLCJpbXBvcnQgcmVxdWVzdCBmcm9tICcuLi9saWIvcmVxdWVzdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgICAvKipcbiAgICAgKiBAQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMucmVtb3RlVmVyc2lvbiA9IHZlcnNpb24gfHwgJ3YxJztcbiAgICAgICAgdGhpcy5yZW1vdGVCYXNlRW5kcG9pbnQgPSAnL3JlbW90ZS8nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgWydHRVQnLCAnUE9TVCcsICdQVVQnLCAnREVMRVRFJ11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3RlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBtYWtlUmVxdWVzdCh1cmwsIG1ldGhvZCwgb3B0aW9ucywgcmVtb3RlLCBjYWxsYmFjaykge1xuICAgICAgICByZXF1ZXN0KHVybCwge1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmRwb2ludFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgWydHRVQnLCAnUE9TVCcsICdQVVQnLCAnREVMRVRFJ11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgcmVtb3RlUmVxdWVzdChlbmRwb2ludCwgbWV0aG9kLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCByZW1vdGVVcmwgPSB0aGlzLnJlbW90ZUJhc2VFbmRwb2ludCArIHRoaXMucmVtb3RlVmVyc2lvbiArIGVuZHBvaW50O1xuXG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3QocmVtb3RlVXJsLCBtZXRob2QsIG9wdGlvbnMsIHRydWUsIGNhbGxiYWNrKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQm9kbEV2ZW50c0NhcnQgZnJvbSAnLi4vYm9kbC9lbWl0dGVycy9jYXJ0JztcbmltcG9ydCBCYXNlIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgSG9va3MgZnJvbSAnLi4vaG9va3MnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcbiAgICAgICAgc3VwZXIodmVyc2lvbik7XG4gICAgICAgIHRoaXMuYm9kbEV2ZW50c0NhcnQgPSBudWxsO1xuICAgIH1cblxuICAgIGdldEJvZGxFdmVudHNDYXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuYm9kbEV2ZW50c0NhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuYm9kbEV2ZW50c0NhcnQgPSBuZXcgQm9kbEV2ZW50c0NhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ib2RsRXZlbnRzQ2FydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjb2xsZWN0aW9uIG9mIENhcnRzLiBGb3Igbm93LCB0aGlzIHdpbGwgb25seSByZXR1cm4gYW4gYXJyYXkgb2YgYSBzaW5nbGUgY2FydCBhcyBtdWx0aXBsZSBjYXJ0cyBwZXIgc2Vzc2lvblxuICAgICAqIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXRDYXJ0cyhvcHRpb25zID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCB1cmwgPSAnL2FwaS9zdG9yZWZyb250L2NhcnRzJztcblxuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlT3B0aW9ucykge1xuICAgICAgICAgICAgdXJsID0gdGhpcy5pbmNsdWRlT3B0aW9ucyh1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWtlUmVxdWVzdCh1cmwsICdHRVQnLCBvcHRpb25zLCB0cnVlLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBDYXJ0J3MgZGV0YWlscywgZWl0aGVyIHdpdGggb3Igd2l0aG91dCBQcm9kdWN0IE9wdGlvbiBzZWxlY3Rpb25zLlxuICAgICAqIENhbiBhbHNvIGJlIHVzZWQgdG8gZ2V0IGEgcGFydGljdWxhciBjYXJ0IHByb3ZpZGVkIGEgY2FydElkIGluIHRoZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGdldENhcnQob3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICAvKiBJZiBubyBjYXJ0IElEIGlzIHByb3ZpZGVkLCBnZXQgdGhlIGNvbGxlY3Rpb24gb2YgY2FydHMgYW5kIHJldHVybiB0aGUgZmlyc3Qgb25lICovXG4gICAgICAgIGlmICghb3B0aW9ucy5jYXJ0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENhcnRzKG9wdGlvbnMsIChlcnIsIHJlc3BvbnNlKSA9PiBjYWxsYmFjayhlcnIsIHJlc3BvbnNlWzBdKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdXJsID0gYC9hcGkvc3RvcmVmcm9udC9jYXJ0cy8ke29wdGlvbnMuY2FydElkfWA7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHVybCA9IHRoaXMuaW5jbHVkZU9wdGlvbnModXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3QodXJsLCAnR0VUJywgb3B0aW9ucywgdHJ1ZSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN1bW1hcnkgZm9yIHRoZSBjdXJyZW50IHByaW1hcnkgY2FydC4gVGhpcyBzdW1tYXJ5IGRvZXMgbm90IGluY2x1ZGUgdGhlIGZ1bGwgZGV0YWlscyBvZiB0aGUgY2FydCwgYnV0XG4gICAgICogdGhlIHJlc3BvbnNlIHRpbWUgaXMgbXVjaCBmYXN0ZXIgYW5kIGl0J3MgYXBwcm9wcmlhdGUgZm9yIHN1bW1hcnkgdXNlIGNhc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGdldENhcnRTdW1tYXJ5KG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdXJsID0gJy9hcGkvc3RvcmVmcm9udC9jYXJ0LXN1bW1hcnknO1xuXG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3QodXJsLCAnR0VUJywgb3B0aW9ucywgdHJ1ZSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHBhcmFtZXRlcnMgdG8gYSBVUkwgbmVlZGVkIHRvIGdldCBwcm9kdWN0IG9wdGlvbiBkZXRhaWxzIG9uIGNhcnQgbGluZSBpdGVtc1xuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKi9cbiAgICBpbmNsdWRlT3B0aW9ucyh1cmwpIHtcbiAgICAgICAgcmV0dXJuIGAke3VybH0/aW5jbHVkZT1saW5lSXRlbXMucGh5c2ljYWxJdGVtcy5vcHRpb25zLGxpbmVJdGVtcy5kaWdpdGFsSXRlbXMub3B0aW9uc2A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3VtIG9mIHRoZSBjYXJ0IGxpbmUgaXRlbSBxdWFudGl0aWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgZ2V0Q2FydFF1YW50aXR5KG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nZXRDYXJ0U3VtbWFyeShvcHRpb25zLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHF1YW50aXR5ID0gMDtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVxuICAgICAgICAgICAgICAgICYmIHJlc3BvbnNlLnN0YXR1cyAhPT0gMjA0XG4gICAgICAgICAgICAgICAgJiYgcmVzcG9uc2UudG90YWxfcXVhbnRpdHkpIHtcbiAgICAgICAgICAgICAgICBxdWFudGl0eSA9IHJlc3BvbnNlLnRvdGFsX3F1YW50aXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcXVhbnRpdHkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlIHdpdGggQmlnIE9wZW4gRGF0YSBMYXllciBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Rm9ybURhdGF9IGZvcm1EYXRhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBpdGVtQWRkKGZvcm1EYXRhLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmhhbmRsZUl0ZW1BZGQoZm9ybURhdGEsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Qm9kbEV2ZW50c0NhcnQoKS5lbWl0QWRkSXRlbShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGl0ZW0gdG8gY2FydCB3aXRoIG9wdGlvbnMgKHZhcmlhbnRzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGb3JtRGF0YX0gZm9ybURhdGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGhhbmRsZUl0ZW1BZGQoZm9ybURhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmVtb3RlUmVxdWVzdCgnL2NhcnQvYWRkJywgJ1BPU1QnLCB7IGZvcm1EYXRhIH0sIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbWl0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBIb29rcy5lbWl0KCdjYXJ0LWl0ZW0tYWRkLXJlbW90ZScsIGVtaXREYXRhKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2FydCBpdGVtIHF1YW50aXR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGl0ZW1JZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfEZ1bmN0aW9ufSBxdHlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IGNhbGxiYWNrXG4gICAgICovXG4gICAgaXRlbVVwZGF0ZShpdGVtSWQsIHF0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGxldCBpdGVtcztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtSWQpICYmIHR5cGVvZiBxdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gcXR5O1xuICAgICAgICAgICAgaXRlbXMgPSBpdGVtSWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtSWQsXG4gICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBxdHksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZShpdGVtcywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVtaXREYXRhID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChxdHkgPT09IDAgJiYgIWVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Qm9kbEV2ZW50c0NhcnQoKS5lbWl0UmVtb3ZlSXRlbShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEhvb2tzLmVtaXQoJ2NhcnQtaXRlbS11cGRhdGUtcmVtb3RlJywgZW1pdERhdGEpO1xuICAgICAgICAgICAgY2FsbGJhY2tBcmcoZXJyLCByZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuaGFuY2Ugd2l0aCBCaWcgT3BlbiBEYXRhIExheWVyIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1JZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgaXRlbVJlbW92ZShpdGVtSWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSXRlbVJlbW92ZShpdGVtSWQsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Qm9kbEV2ZW50c0NhcnQoKS5lbWl0UmVtb3ZlSXRlbShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNhcnQgaXRlbXNcbiAgICAgKlxuICAgICAqIENhbGxzIHRoZSBpbnRlcm5hbCB1cGRhdGUgZnVuY3Rpb24gd2l0aCBxdWFudGl0eTogMFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1JZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgaGFuZGxlSXRlbVJlbW92ZShpdGVtSWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtSWQsXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuXG4gICAgICAgIHRoaXMudXBkYXRlKGl0ZW1zLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW1pdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgSG9va3MuZW1pdCgnY2FydC1pdGVtLXJlbW92ZS1yZW1vdGUnLCBlbWl0RGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGdpZnR3cmFwcGluZyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1JZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBjYWxsYmFja1xuICAgICAqL1xuICAgIGdldEl0ZW1HaWZ0V3JhcHBpbmdPcHRpb25zKGl0ZW1JZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgY2FsbGJhY2tBcmcgPSBjYWxsYmFjaztcblxuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gb3B0cztcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtb3RlUmVxdWVzdChgL2dpZnQtd3JhcHBpbmcvJHtpdGVtSWR9YCwgJ0dFVCcsIG9wdHMsIGNhbGxiYWNrQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJtaXQgZ2lmdHdyYXBwaW5nIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHN1Ym1pdEl0ZW1HaWZ0V3JhcHBpbmdPcHRpb24oaXRlbUlkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmVtb3RlUmVxdWVzdChgL2dpZnQtd3JhcHBpbmcvJHtpdGVtSWR9YCwgJ1BPU1QnLCB7IHBhcmFtcyB9LCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNhcnQgaXRlbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICB1cGRhdGUoaXRlbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlbW90ZVJlcXVlc3QoJy9jYXJ0L3VwZGF0ZScsICdQT1NUJywgeyBwYXJhbXM6IHBheWxvYWQgfSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjYXJ0IGNvbnRlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXRDb250ZW50KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbGV0IGNhbGxiYWNrQXJnID0gY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KCcvY2FydC5waHAnLCAnR0VUJywgb3B0cywgZmFsc2UsIGNhbGxiYWNrQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FydCBzaGlwcGluZyBxdW90ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fE9iamVjdH0gcmVuZGVyV2l0aFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgZ2V0U2hpcHBpbmdRdW90ZXMocGFyYW1zLCByZW5kZXJXaXRoLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbGJhY2tBcmcgPSBjYWxsYmFjaztcbiAgICAgICAgbGV0IHJlbmRlcldpdGhBcmcgPSByZW5kZXJXaXRoO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tBcmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gcmVuZGVyV2l0aEFyZztcbiAgICAgICAgICAgIHJlbmRlcldpdGhBcmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlcldpdGhBcmcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudGVtcGxhdGUgPSByZW5kZXJXaXRoQXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW1vdGVSZXF1ZXN0KCcvc2hpcHBpbmctcXVvdGUnLCAnR0VUJywgb3B0aW9ucywgY2FsbGJhY2tBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCBzaGlwcGluZyBxdW90ZSBiYXNlZCBvbiBxdW90ZUlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVvdGVJZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgc3VibWl0U2hpcHBpbmdRdW90ZShxdW90ZUlkLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgc2hpcHBpbmdfbWV0aG9kOiBxdW90ZUlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlbW90ZVJlcXVlc3QoJy9zaGlwcGluZy1xdW90ZScsICdQT1NUJywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgY291cG9uIGNvZGUgb3IgZ2lmdCBjZXJ0aWZpY2F0ZSB0byB0aGUgY2FydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGFwcGx5Q29kZShjb2RlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZW1vdGVSZXF1ZXN0KCcvYXBwbHktY29kZScsICdQT1NUJywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgY291cG9uIGNvZGUgb3IgZ2lmdCBjZXJ0aWZpY2F0ZSB0byB0aGUgY2FydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGFwcGx5R2lmdENlcnRpZmljYXRlKGNvZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlbW90ZVJlcXVlc3QoJy9naWZ0LWNlcnRpZmljYXRlcycsICdQT1NUJywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICAvLyBjYWxsIHBhcmVudFxuICAgICAgICBzdXBlcih2ZXJzaW9uKTtcblxuICAgICAgICAvLyBzZXQgdXAgY2xhc3MgdmFyaWFibGVzXG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSAnL2NvdW50cnktc3RhdGVzLyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBHZXQgY291bnRyeSBkYXRhIGJ5IGlkIHdyYXBwZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgZ2V0QnlJZChpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5lbmRwb2ludCArIGlkO1xuXG4gICAgICAgIHRoaXMucmVtb3RlUmVxdWVzdCh1cmwsICdHRVQnLCB7fSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjb3VudHJ5IGRhdGEgYnkgY291bnRyeSBuYW1lXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXRCeU5hbWUobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5lbmRwb2ludCArIG5hbWU7XG5cbiAgICAgICAgdGhpcy5yZW1vdGVSZXF1ZXN0KHVybCwgJ0dFVCcsIHt9LCBjYWxsYmFjayk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHJlcXVlc3QgZnJvbSAnLi4vbGliL3JlcXVlc3QnO1xuXG5pbXBvcnQgQ291bnRyeUFwaSBmcm9tICcuL2NvdW50cmllcyc7XG5pbXBvcnQgUHJvZHVjdEFwaSBmcm9tICcuL3Byb2R1Y3QnO1xuaW1wb3J0IFByb2R1Y3RBdHRyaWJ1dGVzQXBpIGZyb20gJy4vcHJvZHVjdC1hdHRyaWJ1dGVzJztcbmltcG9ydCBTZWFyY2hBcGkgZnJvbSAnLi9zZWFyY2gnO1xuaW1wb3J0IENhcnRBcGkgZnJvbSAnLi9jYXJ0JztcbmltcG9ydCBXaXNobGlzdCBmcm9tICcuL3dpc2hsaXN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gcmVxdWVzdCBhIHBhZ2UgdmlhIGFqYXhcbiAqXG4gKiBAcGFyYW0gdXJsXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbmludGVybmFscy5nZXRQYWdlID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICByZXF1ZXN0KHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZXF1ZXN0T3B0aW9uczogb3B0aW9ucyxcbiAgICB9LCBjYWxsYmFjayk7XG59O1xuXG5pbnRlcm5hbHMuZ2V0UGFnZUJ5R1FMID0gZnVuY3Rpb24gKHBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgcmVxdWVzdCgnL2dyYXBocWwtcmVuZGVyJywge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZXF1ZXN0T3B0aW9uczoge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVfbmFtZTogcGFnZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNvdW50cnk6IG5ldyBDb3VudHJ5QXBpKCksXG4gICAgcHJvZHVjdEF0dHJpYnV0ZXM6IG5ldyBQcm9kdWN0QXR0cmlidXRlc0FwaSgpLFxuICAgIHByb2R1Y3Q6IG5ldyBQcm9kdWN0QXBpKCksXG4gICAgc2VhcmNoOiBuZXcgU2VhcmNoQXBpKCksXG4gICAgY2FydDogbmV3IENhcnRBcGkoKSxcbiAgICB3aXNobGlzdDogbmV3IFdpc2hsaXN0KCksXG4gICAgZ2V0UGFnZTogaW50ZXJuYWxzLmdldFBhZ2UsXG4gICAgZ2V0UGFnZUJ5R1FMOiBpbnRlcm5hbHMuZ2V0UGFnZUJ5R1FMLFxufTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgSG9va3MgZnJvbSAnLi4vaG9va3MnO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICcuLi9saWIvcXVlcnktc3RyaW5nJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIC8vIGNhbGwgcGFyZW50XG4gICAgICAgIHN1cGVyKHZlcnNpb24pO1xuXG4gICAgICAgIC8vIHNldCB1cCBjbGFzcyB2YXJpYWJsZXNcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9ICcvcHJvZHVjdC1hdHRyaWJ1dGVzLyc7XG4gICAgICAgIHRoaXMuaW5DYXJ0RW5kcG9pbnQgPSAnL2NvbmZpZ3VyZS1vcHRpb25zLyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb2R1Y3RJZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBvcHRpb25DaGFuZ2UocHJvZHVjdElkLCBwYXJhbXMsIHRlbXBsYXRlID0gbnVsbCwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlQXJnID0gdGVtcGxhdGU7XG4gICAgICAgIGxldCBjYWxsYmFja0FyZyA9IGNhbGxiYWNrO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gdGVtcGxhdGVBcmc7XG4gICAgICAgICAgICB0ZW1wbGF0ZUFyZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbW90ZVJlcXVlc3QodGhpcy5lbmRwb2ludCArIHByb2R1Y3RJZCwgJ1BPU1QnLCB7IHBhcmFtczogcGFyc2UocGFyYW1zKSwgdGVtcGxhdGU6IHRlbXBsYXRlQXJnIH0sIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbWl0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBIb29rcy5lbWl0KCdwcm9kdWN0LW9wdGlvbnMtY2hhbmdlLXJlbW90ZScsIGVtaXREYXRhKTtcbiAgICAgICAgICAgIGNhbGxiYWNrQXJnKGVyciwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaXRlbUlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNvbmZpZ3VyZUluQ2FydChpdGVtSWQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yZW1vdGVSZXF1ZXN0KHRoaXMuaW5DYXJ0RW5kcG9pbnQgKyBpdGVtSWQsICdHRVQnLCBwYXJhbXMsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIC8vIGNhbGwgcGFyZW50XG4gICAgICAgIHN1cGVyKHZlcnNpb24pO1xuXG4gICAgICAgIC8vIHNldCB1cCBjbGFzcyB2YXJpYWJsZXNcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9ICcvcHJvZHVjdHMucGhwP3Byb2R1Y3RJZD0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb2R1Y3RJZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGdldEJ5SWQocHJvZHVjdElkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZW5kcG9pbnQgKyBwcm9kdWN0SWQ7XG4gICAgICAgIGxldCBwYXJhbXNBcmcgPSBwYXJhbXM7XG4gICAgICAgIGxldCBjYWxsYmFja0FyZyA9IGNhbGxiYWNrO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zQXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IHBhcmFtc0FyZztcbiAgICAgICAgICAgIHBhcmFtc0FyZyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWtlUmVxdWVzdCh1cmwsICdHRVQnLCBwYXJhbXNBcmcsIGZhbHNlLCBjYWxsYmFja0FyZyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEhvb2tzIGZyb20gJy4uL2hvb2tzJztcbmltcG9ydCBCYXNlIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICAvLyBjYWxsIHBhcmVudFxuICAgICAgICBzdXBlcih2ZXJzaW9uKTtcblxuICAgICAgICAvLyBzZXQgdXAgY2xhc3MgdmFyaWFibGVzXG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSAnL3NlYXJjaC5waHA/c2VhcmNoX3F1ZXJ5PSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlYXJjaCByZXN1bHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgc2VhcmNoKHF1ZXJ5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZW5kcG9pbnQgKyBlbmNvZGVVUklDb21wb25lbnQocXVlcnkpO1xuICAgICAgICBsZXQgcGFyYW1zQXJnID0gcGFyYW1zO1xuICAgICAgICBsZXQgY2FsbGJhY2tBcmcgPSBjYWxsYmFjaztcblxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc0FyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2tBcmcgPSBwYXJhbXNBcmc7XG4gICAgICAgICAgICBwYXJhbXNBcmcgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIEhvb2tzLmVtaXQoJ3NlYXJjaC1xdWljay1yZW1vdGUnLCBxdWVyeSk7XG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3QodXJsLCAnR0VUJywgcGFyYW1zQXJnLCBmYWxzZSwgY2FsbGJhY2tBcmcpO1xuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQmFzZSB7XG4gICAgaXRlbUFkZCh3aXNobGlzdElkLCBwcm9kdWN0SWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAvd2lzaGxpc3QucGhwP2FjdGlvbj1hZGQmd2lzaGxpc3RpZD0ke3dpc2hsaXN0SWR9JnByb2R1Y3RfaWQ9JHtwcm9kdWN0SWR9YDtcbiAgICAgICAgbGV0IG9wdHMgPSBvcHRpb25zO1xuICAgICAgICBsZXQgY2FsbGJhY2tGbiA9IGNhbGxiYWNrO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2tGbiA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KHVybCwgJ1BPU1QnLCBvcHRzLCBmYWxzZSwgY2FsbGJhY2tGbik7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0Qk9ETEV2ZW50cyB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYm9kbEV2ZW50cyA9IGdldEJPRExFdmVudHMoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBnZXRFdmVudElkLCBpc0JPRExFbmFibGVkIH0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgQmFzZSBmcm9tICcuL2Jhc2UnO1xuXG5jbGFzcyBDYXJ0IGV4dGVuZHMgQmFzZSB7XG4gICAgZW1pdEFkZEl0ZW0ocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuYm9kbEV2ZW50cy5BZGRDYXJ0SXRlbUV2ZW50LkNSRUFURSwgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGVtaXRSZW1vdmVJdGVtKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZEVtaXRSZW1vdmVJdGVtKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuYm9kbEV2ZW50cy5SZW1vdmVDYXJ0SXRlbUV2ZW50LkNSRUFURSwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hvdWxkRW1pdFJlbW92ZUl0ZW0ocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubGluZV9pdGVtcz8ubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBlbWl0KGV2ZW50TmFtZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMucHJlcGFyZVBheWxvYWQocmVzcG9uc2UpO1xuICAgICAgICB0aGlzLmJvZGxFdmVudHMuY2FydC5lbWl0KGV2ZW50TmFtZSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgcHJlcGFyZVBheWxvYWQocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGlzQk9ETEVuYWJsZWQoKSAmJiAhcmVzcG9uc2UuZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBldmVudF9pZDogZ2V0RXZlbnRJZCgpLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxfaWQ6IHJlc3BvbnNlLmRhdGEuY2hhbm5lbF9pZCxcbiAgICAgICAgICAgICAgICBjdXJyZW5jeTogcmVzcG9uc2UuZGF0YS5jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICBwcm9kdWN0X3ZhbHVlOiByZXNwb25zZS5kYXRhLnByb2R1Y3RfdmFsdWUsXG4gICAgICAgICAgICAgICAgbGluZV9pdGVtczogcmVzcG9uc2UuZGF0YS5saW5lX2l0ZW1zLm1hcCgoaXRlbSkgPT4gKHsgLi4uaXRlbSwgcHJvZHVjdF9pZDogU3RyaW5nKGl0ZW0ucHJvZHVjdF9pZCkgfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcnQ7XG4iLCJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcblxuZXhwb3J0IGNvbnN0IGlzQk9ETEVuYWJsZWQgPSAoKSA9PiB0eXBlb2Ygd2luZG93LmJvZGxFdmVudHMgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgY29uc3QgRmFrZUJPRExFdmVudHMgPSB7XG4gICAgY2FydDoge1xuICAgICAgICBhZGRJdGVtOiAoKSA9PiB7fSxcbiAgICAgICAgcmVtb3ZlSXRlbTogKCkgPT4ge30sXG4gICAgICAgIGVtaXQ6ICgpID0+IHt9LFxuICAgIH0sXG4gICAgQWRkQ2FydEl0ZW1FdmVudDoge1xuICAgICAgICBDUkVBVEU6ICdjcmVhdGVfYWRkX2NhcnRfaXRlbScsXG4gICAgfSxcbiAgICBSZW1vdmVDYXJ0SXRlbUV2ZW50OiB7XG4gICAgICAgIENSRUFURTogJ2NyZWF0ZV9yZW1vdmVfY2FydF9pdGVtJyxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IGdldEV2ZW50SWQgPSAoKSA9PiB1dWlkdjQoKTtcblxuZXhwb3J0IGNvbnN0IGdldEJPRExFdmVudHMgPSAoKSA9PiB7XG4gICAgaWYgKGlzQk9ETEVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gd2luZG93LmJvZGxFdmVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZha2VCT0RMRXZlbnRzO1xufTtcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBzdWJzY3JpYmUoZXZlbnROYW1lLCBlbGVtZW50U2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IHRhcmdldCB9ID0gZTsgdGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpczsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoZWxlbWVudFNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGFyZ2V0LCBlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQmFzZUhvb2tzIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQmFzZUhvb2tzIHtcbiAgICAvKipcbiAgICAgKiBAQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gY2FsbCBwYXJlbnRcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLml0ZW1BZGQoKTtcbiAgICB9XG5cbiAgICBpdGVtQWRkKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgnc3VibWl0JywgJ1tkYXRhLWNhcnQtaXRlbS1hZGRdJywgKGV2ZW50LCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2FydC1pdGVtLWFkZCcsIGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQmFzZUhvb2tzIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQmFzZUhvb2tzIHt9XG4iLCJpbXBvcnQgQmFzZUhvb2tzIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQmFzZUhvb2tzIHtcbiAgICAvKipcbiAgICAgKiBAQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gY2FsbCBwYXJlbnRcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmN1cnJlbmN5U2VsZWN0b3IoKTtcbiAgICB9XG5cbiAgICBjdXJyZW5jeVNlbGVjdG9yKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgnaW5wdXQnLCAnW2RhdGEtY3VycmVuY3ktc2VsZWN0b3ItdG9nZ2xlXScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjdXJyZW5jeVNlbGVjdG9yLXRvZ2dsZScsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2VIb29rcyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2VIb29rcyB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGNhbGwgcGFyZW50XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5zZWFyY2hFdmVudHMoKTtcbiAgICB9XG5cbiAgICBzZWFyY2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKCdjbGljaycsICdbZGF0YS1mYWNldGVkLXNlYXJjaC1mYWNldF0nLCAoZXZlbnQsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdmYWNldGVkU2VhcmNoLWZhY2V0LWNsaWNrZWQnLCBldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ3N1Ym1pdCcsICdbZGF0YS1mYWNldGVkLXNlYXJjaC1yYW5nZV0nLCAoZXZlbnQsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdmYWNldGVkU2VhcmNoLXJhbmdlLXN1Ym1pdHRlZCcsIGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ2FydEhvb2tzIGZyb20gJy4vY2FydCc7XG5pbXBvcnQgQ29va2llSG9va3MgZnJvbSAnLi9jb29raWUnO1xuaW1wb3J0IEN1cnJlbmN5U2VsZWN0b3JIb29rcyBmcm9tICcuL2N1cnJlbmN5LXNlbGVjdG9yJztcbmltcG9ydCBQcm9kdWN0SG9va3MgZnJvbSAnLi9wcm9kdWN0JztcbmltcG9ydCBTZWFyY2hIb29rcyBmcm9tICcuL3NlYXJjaCc7XG5pbXBvcnQgRmFjZXRlZFNlYXJjaEhvb2tzIGZyb20gJy4vZmFjZXRlZC1zZWFyY2gnO1xuaW1wb3J0IFNvcnRCeUhvb2tzIGZyb20gJy4vc29ydC1ieSc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5pbnRlcm5hbHMuY2xhc3NlcyA9IHtcbiAgICBjYXJ0OiBuZXcgQ2FydEhvb2tzKCksXG4gICAgY29va2llOiBuZXcgQ29va2llSG9va3MoKSxcbiAgICBjdXJyZW5jeVNlbGVjdG9yOiBuZXcgQ3VycmVuY3lTZWxlY3Rvckhvb2tzKCksXG4gICAgcHJvZHVjdDogbmV3IFByb2R1Y3RIb29rcygpLFxuICAgIHNlYXJjaDogbmV3IFNlYXJjaEhvb2tzKCksXG4gICAgZmFjZXRlZFNlYXJjaDogbmV3IEZhY2V0ZWRTZWFyY2hIb29rcygpLFxuICAgIHNvcnRCeTogbmV3IFNvcnRCeUhvb2tzKCksXG59O1xuXG5pbnRlcm5hbHMucGFyc2VIb29rcyA9IGZ1bmN0aW9uIChob29rTmFtZSkge1xuICAgIGNvbnN0IGhvb2tUeXBlID0gaG9va05hbWUuc3BsaXQoJy0nKVswXTtcblxuICAgIGlmIChpbnRlcm5hbHMuY2xhc3Nlc1tob29rVHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7aG9va1R5cGV9IGlzIG5vdCBhIHZhbGlkIGhvb2tUeXBlYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5jbGFzc2VzW2hvb2tUeXBlXTtcbn07XG5cbmNsYXNzIEhvb2tzIHtcbiAgICBvbihob29rTmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaG9vayA9IGludGVybmFscy5wYXJzZUhvb2tzKGhvb2tOYW1lKTtcblxuICAgICAgICByZXR1cm4gaG9vay5vbihob29rTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIG9mZihob29rTmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaG9vayA9IGludGVybmFscy5wYXJzZUhvb2tzKGhvb2tOYW1lKTtcblxuICAgICAgICByZXR1cm4gaG9vay5vZmYoaG9va05hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBlbWl0KGhvb2tOYW1lKSB7XG4gICAgICAgIGNvbnN0IGhvb2sgPSBpbnRlcm5hbHMucGFyc2VIb29rcyhob29rTmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIGhvb2suZW1pdCguLi5hcmd1bWVudHMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IEhvb2tzKCk7XG4iLCJpbXBvcnQgQmFzZUhvb2tzIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQmFzZUhvb2tzIHtcbiAgICAvKipcbiAgICAgKiBAQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gY2FsbCBwYXJlbnRcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnNDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBvcHRpb25zQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgnY2hhbmdlJywgJ1tkYXRhLXByb2R1Y3Qtb3B0aW9uLWNoYW5nZV0nLCAoZXZlbnQsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9kdWN0LW9wdGlvbi1jaGFuZ2UnLCBldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2VIb29rcyBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2VIb29rcyB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGNhbGwgcGFyZW50XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5xdWlja1NlYXJjaCgpO1xuICAgIH1cblxuICAgIHF1aWNrU2VhcmNoKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgnaW5wdXQnLCAnW2RhdGEtc2VhcmNoLXF1aWNrXScsIChldmVudCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3NlYXJjaC1xdWljaycsIGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQmFzZUhvb2tzIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgY2xvc2VzdCBmcm9tICcuLi9saWIvY2xvc2VzdCc7XG5cbi8vIGllIDExIGRvZXMgbm90IHN1cHBvcnQgbmF0aXZlIGNsb3Nlc3RcbmlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG59XG5cbmlmICghRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCkge1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QgPSBjbG9zZXN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEJhc2VIb29rcyB7XG4gICAgLyoqXG4gICAgICogQENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGNhbGwgcGFyZW50XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5zb3J0QnlFdmVudHMoKTtcbiAgICB9XG5cbiAgICBzb3J0QnlFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKCdzdWJtaXQnLCAnW2RhdGEtc29ydC1ieV0nLCAoZXZlbnQsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzb3J0Qnktc3VibWl0dGVkJywgZXZlbnQsIHRhcmdldCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKCdjaGFuZ2UnLCAnW2RhdGEtc29ydC1ieV0gc2VsZWN0JywgKGV2ZW50LCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc29ydEJ5LXNlbGVjdC1jaGFuZ2VkJywgZXZlbnQsIHRhcmdldCk7XG5cbiAgICAgICAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc29ydEJ5LXN1Ym1pdHRlZCcsIGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKipcbiAqIGllIDExIGRvZXMgbm90IHN1cHBvcnQgbmF0aXZlIGNsb3Nlc3Qgc28gdXNlIHRoaXMgcG9seWZpbGwgZnVuY3Rpb24gaW5zdGVhZCB0byBmaW5kIGNsb3Nlc3QgbWF0Y2hpbmcgc2VsZWN0b3Igc3RhcnRpbmcgZnJvbSBlbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXNcbiAqIEByZXR1cm5zIHthbnl9IG1hdGNoaW5nIHNlbGVjdG9yIG9yIG51bGxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xvc2VzdChzKSB7XG4gICAgbGV0IGVsID0gdGhpcztcblxuICAgIGRvIHtcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMocykpIHJldHVybiBlbDtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgfSB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEpO1xuXG4gICAgcmV0dXJuIG51bGw7XG59XG4iLCIvKipcbiAqIEVuY29kZXMgc3RyaW5nIGJ5IHN0cmljdGVyIHJ1bGVzXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2tldnZhL3N0cmljdC11cmktZW5jb2RlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICovXG5jb25zdCBlbmNvZGUgPSAoc3RyaW5nKSA9PiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKS5yZXBsYWNlKC9bIScoKSpdL2csICh4KSA9PiBgJSR7eC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfWApO1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXksIHdoZXJlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIHNsaWNlIHRpbGwgc2VwYXJhdG9yIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSByZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZXBhcmF0b3JcbiAqL1xuY29uc3Qgc3BsaXRPbkZpcnN0ID0gKHN0cmluZywgc2VwYXJhdG9yKSA9PiB7XG4gICAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSBzdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IpO1xuICAgIGlmIChzZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtzdHJpbmddO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBzdHJpbmcuc2xpY2UoMCwgc2VwYXJhdG9ySW5kZXgpLFxuICAgICAgICBzdHJpbmcuc2xpY2Uoc2VwYXJhdG9ySW5kZXggKyBzZXBhcmF0b3IubGVuZ3RoKSxcbiAgICBdO1xufTtcblxuLyoqXG4gKiBTb3J0cyBhcnJheSBvciBvYmplY3QgYnkga2V5c1xuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpbnB1dFxuICovXG5jb25zdCBzb3J0QnlLZXlzID0gKGlucHV0KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5zb3J0KCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRCeUtleXMoT2JqZWN0LmtleXMoaW5wdXQpKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IE51bWJlcihhKSAtIE51bWJlcihiKSlcbiAgICAgICAgICAgIC5tYXAoKGtleSkgPT4gaW5wdXRba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IGlmIHRoZSBrZXkgZXhpc3RzIGluIHRoZSBvYmplY3Qgb3IgdGhlIHZhbHVlIGlmIGRvZW4ndFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yXG4gKi9cbmNvbnN0IGdldFBhcnNlZFZhbHVlID0gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG4gICAgaWYgKGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFJlZHVjZXIgdGhhdCBmb3JtYXRzIGFuZCBjb21iaW5lcyBrZXktdmFsdWUgcGFpclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zXG4gKi9cbmNvbnN0IHJlZHVjZUJ5S2V5ID0gKG9wdGlvbnMpID0+IChrZXkpID0+IChyZXN1bHQsIHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5yZXN1bHQsIGVuY29kZShrZXkpXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlQXJyYXlJbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSByZXN1bHQubGVuZ3RoIC8gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGtleU9mVmFsdWUpID0+IChbXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICAnWycsIGVuY29kZShpbmRleCksICddJyxcbiAgICAgICAgICAgICAgICAgICAgJ1snLCBlbmNvZGUoa2V5T2ZWYWx1ZSksICddPScsXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZSh2YWx1ZVtrZXlPZlZhbHVlXSksXG4gICAgICAgICAgICAgICAgXS5qb2luKCcnKSkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIFtlbmNvZGUoa2V5KSwgJ1snLCBlbmNvZGUoaW5kZXgpLCAnXT0nLCBlbmNvZGUodmFsdWUpXS5qb2luKCcnKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICByZXR1cm4gWy4uLnJlc3VsdCwgW2VuY29kZShrZXkpLCAnPScsIGVuY29kZSh2YWx1ZSldLmpvaW4oJycpXTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgcXVlcnkgc3RyaW5nIGludG8gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0UGFyc2VkID0gaW5wdXQudHJpbSgpLnJlcGxhY2UoL15bPyMmXS8sICcnKTtcblxuICAgIGlmICghaW5wdXRQYXJzZWQpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBpbnB1dFBhcnNlZC5zcGxpdCgnJicpLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCAqL1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gc3BsaXRPbkZpcnN0KHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLCAnPScpO1xuXG4gICAgICAgIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgcmV0W2tleV0gPSBnZXRQYXJzZWRWYWx1ZShrZXksIHZhbHVlLCByZXQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJldCkuc29ydCgpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZXRba2V5XTtcbiAgICAgICAgaWYgKEJvb2xlYW4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3J0QnlLZXlzKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QgdG8gcXVlcnkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmlsdGVyVmFsdWVzXSAtIGZpbHRlcnMgZW1wdHkgc3RyaW5nIG9yIHVuZGVmaW5lZHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZUFycmF5SW5kZXhdIC0gaW5jbHVkZXMgYXJyYXkgaW5kZXggaW4gdGhlIHF1ZXJ5IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KG9iamVjdCwgb3B0aW9ucyA9IHtcbiAgICBmaWx0ZXJWYWx1ZXM6IGZhbHNlLFxuICAgIGFycmF5SW5kZXg6IGZhbHNlLFxufSkge1xuICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBjb25zdCBvYmplY3RDb3B5ID0ge307XG4gICAgY29uc3Qgc2hvdWxkRmlsdGVyID0gKGtleSkgPT4gKFxuICAgICAgICBvcHRpb25zLmZpbHRlclZhbHVlc1xuICAgICAgICAmJiAob2JqZWN0W2tleV0gPT09ICcnIHx8IG9iamVjdFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgKTtcblxuICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkRmlsdGVyKGtleSkpIHtcbiAgICAgICAgICAgIG9iamVjdENvcHlba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0Q29weSk7XG4gICAga2V5cy5zb3J0KCk7XG5cbiAgICByZXR1cm4ga2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGUoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAgICAgLnJlZHVjZShyZWR1Y2VCeUtleShvcHRpb25zKShrZXkpLCBbXSlcbiAgICAgICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke2VuY29kZShrZXkpfT0ke2VuY29kZSh2YWx1ZSl9YDtcbiAgICB9KS5maWx0ZXIoKHgpID0+IHgubGVuZ3RoID4gMCkuam9pbignJicpO1xufVxuIiwiaW1wb3J0ICd3aGF0d2ctZmV0Y2gnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9xdWVyeS1zdHJpbmcnO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgbWV0aG9kIHBhc3NlZCBpbiBpcyB2YWxpZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5jb25zdCBpc1ZhbGlkSFRUUE1ldGhvZCA9IChtZXRob2QpID0+IFsnR0VUJywgJ1BPU1QnLCAnUFVUJywgJ0RFTEVURSddLmluZGV4T2YobWV0aG9kKSAhPT0gLTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHJlcXVlc3RlZCB0ZW1wbGF0ZSBpcyB1c2luZyBzZWN0aW9uc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ30gcmVxdWVzdGVkVGVtcGxhdGVcbiAqL1xuY29uc3QgaXNVc2luZ1NlY3Rpb25zID0gKHJlcXVlc3RlZFRlbXBsYXRlKSA9PiByZXF1ZXN0ZWRUZW1wbGF0ZSAhPT0gbnVsbCAmJiB0eXBlb2YgKHJlcXVlc3RlZFRlbXBsYXRlKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVxdWVzdGVkVGVtcGxhdGUpO1xuXG4vKipcbiAqIFJldHVybnMgdGVtcGxhdGVzIGFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfSByZXF1ZXN0ZWRUZW1wbGF0ZVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5jb25zdCBnZXRUZW1wbGF0ZXMgPSAocmVxdWVzdGVkVGVtcGxhdGUpID0+IHtcbiAgICBsZXQgdGVtcGxhdGVzID0gW107XG4gICAgaWYgKGlzVXNpbmdTZWN0aW9ucyhyZXF1ZXN0ZWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgdGVtcGxhdGVzID0gT2JqZWN0LnZhbHVlcyhyZXF1ZXN0ZWRUZW1wbGF0ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKHJlcXVlc3RlZFRlbXBsYXRlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGVtcGxhdGVzID0gW3JlcXVlc3RlZFRlbXBsYXRlXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdGVkVGVtcGxhdGUpICYmIHJlcXVlc3RlZFRlbXBsYXRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGVtcGxhdGVzID0gcmVxdWVzdGVkVGVtcGxhdGU7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZXM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAocmVsYXRpdmVVcmwsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHJlbW90ZTogZmFsc2UsXG4gICAgICAgIHJlcXVlc3RPcHRpb25zOiB7XG4gICAgICAgICAgICBiYXNlVXJsOiBudWxsLFxuICAgICAgICAgICAgZm9ybURhdGE6IG51bGwsXG4gICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBbXSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH07XG4gICAgY29uc3QgZGF0YSA9IG9wdGlvbnMucmVxdWVzdE9wdGlvbnMuZm9ybURhdGEgPyBvcHRpb25zLnJlcXVlc3RPcHRpb25zLmZvcm1EYXRhIDogb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5wYXJhbXM7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ3N0ZW5jaWwtY29uZmlnJzogb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5jb25maWcgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlcXVlc3RPcHRpb25zLmNvbmZpZykgOiAne30nLFxuICAgICAgICAnc3RlbmNpbC1vcHRpb25zJzogJ3t9JyxcbiAgICAgICAgJ3gteHNyZi10b2tlbic6IHdpbmRvdy5CQ0RhdGEgJiYgd2luZG93LkJDRGF0YS5jc3JmX3Rva2VuID8gd2luZG93LkJDRGF0YS5jc3JmX3Rva2VuIDogJycsXG4gICAgICAgICd4LXJlcXVlc3RlZC13aXRoJzogJ3N0ZW5jaWwtdXRpbHMnLFxuICAgIH07XG5cbiAgICBpZiAoIWlzVmFsaWRIVFRQTWV0aG9kKG9wdGlvbnMubWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdOb3QgYSB2YWxpZCBIVFRQIG1ldGhvZCcpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZW1wbGF0ZXMgPSBnZXRUZW1wbGF0ZXMob3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy50ZW1wbGF0ZSk7XG4gICAgY29uc3QgdXNpbmdTZWN0aW9ucyA9IGlzVXNpbmdTZWN0aW9ucyhvcHRpb25zLnJlcXVlc3RPcHRpb25zLnRlbXBsYXRlKTtcbiAgICBjb25zdCB1c2luZ1RlbXBsYXRlcyA9IHRlbXBsYXRlcy5sZW5ndGggPiAwO1xuXG4gICAgaWYgKCFvcHRpb25zLnJlcXVlc3RPcHRpb25zLmZvcm1EYXRhKSB7XG4gICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCc7XG4gICAgfVxuXG4gICAgaWYgKHVzaW5nVGVtcGxhdGVzKSB7XG4gICAgICAgIGhlYWRlcnNbJ3N0ZW5jaWwtb3B0aW9ucyddID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgcmVuZGVyX3dpdGg6IHRlbXBsYXRlcy5qb2luKCcsJyksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICB9O1xuXG4gICAgbGV0IHVybCA9IG9wdGlvbnMucmVxdWVzdE9wdGlvbnMuYmFzZVVybCA/IGAke29wdGlvbnMucmVxdWVzdE9wdGlvbnMuYmFzZVVybH0ke3JlbGF0aXZlVXJsfWAgOiByZWxhdGl2ZVVybDtcbiAgICBpZiAoWydHRVQnLCAnSEVBRCddLmluZGV4T2YoY29uZmlnLm1ldGhvZCkgPT09IC0xKSB7XG4gICAgICAgIGNvbmZpZy5ib2R5ID0gIW9wdGlvbnMucmVxdWVzdE9wdGlvbnMuZm9ybURhdGEgPyBzdHJpbmdpZnkoZGF0YSwgeyBpbmNsdWRlQXJyYXlJbmRleDogdHJ1ZSB9KSA6IGRhdGE7XG4gICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlbGltaXRlciA9ICF1cmwuaW5jbHVkZXMoJz8nKSA/ICc/JyA6ICcmJztcbiAgICAgICAgdXJsICs9IGAke2RlbGltaXRlcn0ke3N0cmluZ2lmeShkYXRhKX1gO1xuICAgIH1cblxuICAgIHJldHVybiBmZXRjaCh1cmwsIGNvbmZpZylcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gb3B0aW9ucy5yZW1vdGUgPyByZXNwb25zZS5jb250ZW50IDogcmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgcmV0ID0gcmVzcG9uc2U7XG5cbiAgICAgICAgICAgIGlmICh1c2luZ1RlbXBsYXRlcykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgYGNvbXBvbmVudHNgIHByZWZpeCBmcm9tIHRoZSByZXNwb25zZSBpZiBpdCdzIGFuIG9iamVjdFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGNvbnRlbnQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZW50KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuS2V5ID0ga2V5LnJlcGxhY2UoL15jb21wb25lbnRzXFwvLywgJycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50W2NsZWFuS2V5XSA9IGNvbnRlbnRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSAoY29udGVudFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgXCJzZWN0aW9uc1wiLCBtb3JwaCB0aGUgY29udGVudCBpbnRvIHRoZSBhcmJpdHJhcnkga2V5cyA9PiBjb250ZW50IG9iamVjdC5cbiAgICAgICAgICAgICAgICBpZiAodXNpbmdTZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRUZW1wbGF0ZSA9IG9wdGlvbnMucmVxdWVzdE9wdGlvbnMudGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlcXVlc3RlZFRlbXBsYXRlKS5mb3JFYWNoKCh0ZW1wbGF0ZVZhcmlhYmxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50W3RlbXBsYXRlVmFyaWFibGVdID0gY29udGVudFtyZXF1ZXN0ZWRUZW1wbGF0ZVt0ZW1wbGF0ZVZhcmlhYmxlXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29udGVudFtyZXF1ZXN0ZWRUZW1wbGF0ZVt0ZW1wbGF0ZVZhcmlhYmxlXV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5yZW1vdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXQpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4gY2FsbGJhY2soZXJyKSk7XG59XG4iLCJpbXBvcnQgaG9va3MgZnJvbSAnLi9ob29rcyc7XG5pbXBvcnQgYXBpIGZyb20gJy4vYXBpJztcbmltcG9ydCB0b29scyBmcm9tICcuL3Rvb2xzJztcblxuY29uc3QgU3RlbmNpbFV0aWxzID0ge1xuICAgIGhvb2tzLFxuICAgIGFwaSxcbiAgICB0b29scyxcbn07XG5leHBvcnQgeyBob29rcywgYXBpLCB0b29scyB9O1xuZXhwb3J0IGRlZmF1bHQgU3RlbmNpbFV0aWxzO1xuXG4vKiBnbG9iYWwgZGVmaW5lICovXG4oZnVuY3Rpb24gKHJvb3QpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICYmIHJvb3QpIHtcbiAgICAgICAgLy8gSWdub3JlcyBiZWxvdyBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzUxNTBcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItYXJyb3ctY2FsbGJhY2tcbiAgICAgICAgICAgIHJvb3Quc3RlbmNpbFV0aWxzID0gU3RlbmNpbFV0aWxzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBTdGVuY2lsVXRpbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnN0ZW5jaWxVdGlscyA9IFN0ZW5jaWxVdGlscztcbiAgICB9XG59KHRoaXMpKTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgICBnZXRTcmMocGF0aCwgZGltZW5zaW9ucykge1xuICAgICAgICAvLyBSZWdleCB0byB0ZXN0IHNpemUgc3RyaW5nIGlzIG9mIHRoZSBmb3JtIDEyM3gxMjMgb3IgMTAwd1xuICAgICAgICBjb25zdCBzaXplUmVnZXggPSAvKF5cXGQrdyQpfCheKFxcZCs/KXgoXFxkKz8pJCkvZztcbiAgICAgICAgbGV0IHNpemU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoZGltZW5zaW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGRpbWVuc2lvbnMud2lkdGggfHwgMTAwO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgfHwgMTAwO1xuXG4gICAgICAgICAgICBzaXplID0gYCR7d2lkdGh9eCR7aGVpZ2h0fWA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChkaW1lbnNpb25zKSA9PT0gJ3N0cmluZycgJiYgc2l6ZVJlZ2V4LnRlc3QoZGltZW5zaW9ucykpIHtcbiAgICAgICAgICAgIC8vIElmIGRpbWVuc2lvbnMgaXMgYSBzdHJpbmcgYW5kIG1hdGNoIHRoZSBOTk54Tk5OIG9yIE5OTncgZm9ybWF0XG4gICAgICAgICAgICBzaXplID0gZGltZW5zaW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZVxuICAgICAgICAgICAgc2l6ZSA9ICdvcmlnaW5hbCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKCd7OnNpemV9Jywgc2l6ZSk7XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICAgIGdldFNyY3NldCh1cmwsIHNpemVzKSB7XG4gICAgICAgIC8vIFJlZ2V4IHRvIHRlc3Qgc2l6ZSBzdHJpbmcgaXMgb2YgdGhlIGZvcm0gMTIzeDEyMyBvciAxMDB3XG4gICAgICAgIGNvbnN0IHNpemVSZWdleCA9IC8oXlxcZCt3JCl8KF4oXFxkKz8peChcXGQrPykkKS87XG4gICAgICAgIC8vIFJlZ2V4IHRvIHRlc3QgdG8gdGhhdCBzcmNzZXQgZGVzY3JpcHRvciBpcyBvZiB0aGUgZm9ybSAxeCAxLjV4IDJ4IE9SIDEyM3dcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvclJlZ2V4ID0gLyheXFxkK3ckKXwoXihbMC05XShcXC5bMC05XSspPyl4KSQvO1xuXG4gICAgICAgIGxldCBzcmNzZXRzID0ge307XG5cbiAgICAgICAgaWYgKCFzaXplcykge1xuICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgc3Jjc2V0cyBpZiBub25lIGFyZSBwcm92aWRlZFxuICAgICAgICAgICAgc3Jjc2V0cyA9IHtcbiAgICAgICAgICAgICAgICAnODB3JzogJzgwdycsXG4gICAgICAgICAgICAgICAgJzE2MHcnOiAnMTYwdycsXG4gICAgICAgICAgICAgICAgJzMyMHcnOiAnMzIwdycsXG4gICAgICAgICAgICAgICAgJzY0MHcnOiAnNjQwdycsXG4gICAgICAgICAgICAgICAgJzk2MHcnOiAnOTYwdycsXG4gICAgICAgICAgICAgICAgJzEyODB3JzogJzEyODB3JyxcbiAgICAgICAgICAgICAgICAnMTkyMHcnOiAnMTkyMHcnLFxuICAgICAgICAgICAgICAgICcyNTYwdyc6ICcyNTYwdycsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKChzaXplcyA9PT0gT2JqZWN0KHNpemVzKSkgJiYgIU9iamVjdC5rZXlzKHNpemVzKS5zb21lKChkZXNjcmlwdG9yKSA9PiAhKGRlc2NyaXB0b3JSZWdleC50ZXN0KGRlc2NyaXB0b3IpICYmIHNpemVSZWdleC50ZXN0KHNpemVzW2Rlc2NyaXB0b3JdKSkpKSB7XG4gICAgICAgICAgICAvLyBJZiBvYmplY3QgY29uc2lzdHMgb2YgdmFsaWQgc3Jjc2V0cywgdXNlIGl0IGluc3RlYWRcbiAgICAgICAgICAgIHNyY3NldHMgPSBzaXplcztcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgYXJndW1lbnQsIHJldHVybiBhIGBzcmNgIG9ubHkgKGFsc28gd29ya3MgZm9yIGBzcmNzZXRgKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNyY3NldHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodXJsLnJlcGxhY2UoJ3s6c2l6ZX0nLCBzcmNzZXRzW09iamVjdC5rZXlzKHNyY3NldHMpWzBdXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNyY3NldCBkZXNjcmlwdG9yIG9yIHNpemUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzcmNzZXRzKS5tYXAoKGRlc2NyaXB0b3IpID0+IFt1cmwucmVwbGFjZSgnezpzaXplfScsIHNyY3NldHNbZGVzY3JpcHRvcl0pLCBkZXNjcmlwdG9yXS5qb2luKCcgJykpLmpvaW4oJywgJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEltYWdlVG9vbCBmcm9tICcuL2ltYWdlJztcbmltcG9ydCBJbWFnZVNyY3NldFRvb2wgZnJvbSAnLi9pbWFnZVNyY3NldCc7XG5pbXBvcnQgU3RvcmFnZVRvb2xzIGZyb20gJy4vc3RvcmFnZSc7XG5cbmNvbnN0IHRvb2xzID0ge1xuICAgIGltYWdlOiBuZXcgSW1hZ2VUb29sKCksXG4gICAgaW1hZ2VTcmNzZXQ6IG5ldyBJbWFnZVNyY3NldFRvb2woKSxcbiAgICBzdG9yYWdlOiBuZXcgU3RvcmFnZVRvb2xzKCksXG59O1xuXG5leHBvcnQgZGVmYXVsdCB0b29scztcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHN0b3JhZ2UgdHlwZSAobGlrZSBsb2NhbFN0b3JhZ2Ugb3Igc2Vzc2lvblN0b3JhZ2UpIGlzIGF2YWlsYWJsZSBmb3IgdXNlXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9TdG9yYWdlX0FQSS9Vc2luZ190aGVfV2ViX1N0b3JhZ2VfQVBJI1Rlc3RpbmdfZm9yX2F2YWlsYWJpbGl0eVxuICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuICAgIHN0b3JhZ2VBdmFpbGFibGUodHlwZSkge1xuICAgICAgICBjb25zdCBzdG9yYWdlID0gd2luZG93W3R5cGVdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeCA9ICdfX3N0b3JhZ2VfdGVzdF9fJztcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbSh4LCB4KTtcbiAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbSh4KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiAoXG4gICAgICAgICAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgICAgICAgICAgICAgZS5jb2RlID09PSAyMlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgICAgICB8fCBlLmNvZGUgPT09IDEwMTRcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IG5hbWUgZmllbGQgdG9vLCBiZWNhdXNlIGNvZGUgbWlnaHQgbm90IGJlIHByZXNlbnRcbiAgICAgICAgICAgICAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgICAgICAgICAgICAgfHwgZS5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJ1xuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgICAgICB8fCBlLm5hbWUgPT09ICdOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRCcpXG4gICAgICAgICAgICAgICAgLy8gYWNrbm93bGVkZ2UgUXVvdGFFeGNlZWRlZEVycm9yIG9ubHkgaWYgdGhlcmUncyBzb21ldGhpbmcgYWxyZWFkeSBzdG9yZWRcbiAgICAgICAgICAgICAgICAmJiBzdG9yYWdlLmxlbmd0aCAhPT0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsU3RvcmFnZUF2YWlsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZUF2YWlsYWJsZSgnbG9jYWxTdG9yYWdlJyk7XG4gICAgfVxufVxuIiwiLyohXG4gKiBiYWd1ZXR0ZUJveC5qc1xuICogQGF1dGhvciAgZmVpbW9zaVxuICogQHZlcnNpb24gMS4xMi4wXG4gKiBAdXJsIGh0dHBzOi8vZ2l0aHViLmNvbS9mZWltb3NpL2JhZ3VldHRlQm94LmpzXG4gKi9cbiFmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9dCgpOmUuYmFndWV0dGVCb3g9dCgpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHMsbCx1LGMsZCxmPSc8c3ZnIHdpZHRoPVwiNDRcIiBoZWlnaHQ9XCI2MFwiPjxwb2x5bGluZSBwb2ludHM9XCIzMCAxMCAxMCAzMCAzMCA1MFwiIHN0cm9rZT1cInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiIHN0cm9rZS13aWR0aD1cIjRcInN0cm9rZS1saW5lY2FwPVwiYnV0dFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIi8+PC9zdmc+JyxnPSc8c3ZnIHdpZHRoPVwiNDRcIiBoZWlnaHQ9XCI2MFwiPjxwb2x5bGluZSBwb2ludHM9XCIxNCAxMCAzNCAzMCAxNCA1MFwiIHN0cm9rZT1cInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiIHN0cm9rZS13aWR0aD1cIjRcInN0cm9rZS1saW5lY2FwPVwiYnV0dFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIi8+PC9zdmc+JyxwPSc8c3ZnIHdpZHRoPVwiMzBcIiBoZWlnaHQ9XCIzMFwiPjxnIHN0cm9rZT1cInJnYigxNjAsMTYwLDE2MClcIiBzdHJva2Utd2lkdGg9XCI0XCI+PGxpbmUgeDE9XCI1XCIgeTE9XCI1XCIgeDI9XCIyNVwiIHkyPVwiMjVcIi8+PGxpbmUgeDE9XCI1XCIgeTE9XCIyNVwiIHgyPVwiMjVcIiB5Mj1cIjVcIi8+PC9nPjwvc3ZnPicsYj17fSx2PXtjYXB0aW9uczohMCxidXR0b25zOlwiYXV0b1wiLGZ1bGxTY3JlZW46ITEsbm9TY3JvbGxiYXJzOiExLGJvZHlDbGFzczpcImJhZ3VldHRlQm94LW9wZW5cIix0aXRsZVRhZzohMSxhc3luYzohMSxwcmVsb2FkOjIsYW5pbWF0aW9uOlwic2xpZGVJblwiLGFmdGVyU2hvdzpudWxsLGFmdGVySGlkZTpudWxsLG9uQ2hhbmdlOm51bGwsb3ZlcmxheUJhY2tncm91bmRDb2xvcjpcInJnYmEoMCwwLDAsLjgpXCIsY2xvc2VYOnAsbGVmdEFycm93OmYscmlnaHRBcnJvdzpnfSxtPXt9LGg9W10sbz0wLG49ITEsaT17fSxhPSExLHk9Ly4rXFwuKGdpZnxqcGU/Z3xwbmd8d2VicCkvaSx3PXt9LGs9W10scj1udWxsLHg9ZnVuY3Rpb24oZSl7LTEhPT1lLnRhcmdldC5pZC5pbmRleE9mKFwiYmFndWV0dGUtaW1nXCIpJiZYKCl9LEU9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24/ZS5zdG9wUHJvcGFnYXRpb24oKTplLmNhbmNlbEJ1YmJsZT0hMCxxKCl9LEM9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24/ZS5zdG9wUHJvcGFnYXRpb24oKTplLmNhbmNlbEJ1YmJsZT0hMCxqKCl9LEI9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24/ZS5zdG9wUHJvcGFnYXRpb24oKTplLmNhbmNlbEJ1YmJsZT0hMCxYKCl9LFQ9ZnVuY3Rpb24oZSl7aS5jb3VudCsrLDE8aS5jb3VudCYmKGkubXVsdGl0b3VjaD0hMCksaS5zdGFydFg9ZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCxpLnN0YXJ0WT1lLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZfSxBPWZ1bmN0aW9uKGUpe2lmKCFhJiYhaS5tdWx0aXRvdWNoKXtlLnByZXZlbnREZWZhdWx0P2UucHJldmVudERlZmF1bHQoKTplLnJldHVyblZhbHVlPSExO3ZhciB0PWUudG91Y2hlc1swXXx8ZS5jaGFuZ2VkVG91Y2hlc1swXTs0MDx0LnBhZ2VYLWkuc3RhcnRYPyhhPSEwLHEoKSk6dC5wYWdlWC1pLnN0YXJ0WDwtNDA/KGE9ITAsaigpKToxMDA8aS5zdGFydFktdC5wYWdlWSYmWCgpfX0sTD1mdW5jdGlvbigpe2kuY291bnQtLSxpLmNvdW50PD0wJiYoaS5tdWx0aXRvdWNoPSExKSxhPSExfSxOPWZ1bmN0aW9uKCl7TCgpfSxIPWZ1bmN0aW9uKGUpe1wiYmxvY2tcIj09PXMuc3R5bGUuZGlzcGxheSYmcy5jb250YWlucyYmIXMuY29udGFpbnMoZS50YXJnZXQpJiYoZS5zdG9wUHJvcGFnYXRpb24oKSxNKCkpfTtmdW5jdGlvbiBQKGUpe2lmKHcuaGFzT3duUHJvcGVydHkoZSkpe3ZhciB0PXdbZV0uZ2FsbGVyaWVzO1tdLmZvckVhY2guY2FsbCh0LGZ1bmN0aW9uKGUpe1tdLmZvckVhY2guY2FsbChlLGZ1bmN0aW9uKGUpe1coZS5pbWFnZUVsZW1lbnQsXCJjbGlja1wiLGUuZXZlbnRIYW5kbGVyKX0pLGg9PT1lJiYoaD1bXSl9KSxkZWxldGUgd1tlXX19ZnVuY3Rpb24gUyhlKXtzd2l0Y2goZS5rZXlDb2RlKXtjYXNlIDM3OnEoKTticmVhaztjYXNlIDM5OmooKTticmVhaztjYXNlIDI3OlgoKTticmVhaztjYXNlIDM2OiFmdW5jdGlvbiB0KGUpe2UmJmUucHJldmVudERlZmF1bHQoKTtyZXR1cm4gRCgwKX0oZSk7YnJlYWs7Y2FzZSAzNTohZnVuY3Rpb24gbihlKXtlJiZlLnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIEQoaC5sZW5ndGgtMSl9KGUpfX1mdW5jdGlvbiBGKGUsdCl7aWYoaCE9PWUpe2ZvcihoPWUsZnVuY3Rpb24gcihlKXtlPWV8fHt9O2Zvcih2YXIgdCBpbiB2KWJbdF09dlt0XSxcInVuZGVmaW5lZFwiIT10eXBlb2YgZVt0XSYmKGJbdF09ZVt0XSk7bC5zdHlsZS50cmFuc2l0aW9uPWwuc3R5bGUud2Via2l0VHJhbnNpdGlvbj1cImZhZGVJblwiPT09Yi5hbmltYXRpb24/XCJvcGFjaXR5IC40cyBlYXNlXCI6XCJzbGlkZUluXCI9PT1iLmFuaW1hdGlvbj9cIlwiOlwibm9uZVwiLFwiYXV0b1wiPT09Yi5idXR0b25zJiYoXCJvbnRvdWNoc3RhcnRcImluIHdpbmRvd3x8MT09PWgubGVuZ3RoKSYmKGIuYnV0dG9ucz0hMSk7dS5zdHlsZS5kaXNwbGF5PWMuc3R5bGUuZGlzcGxheT1iLmJ1dHRvbnM/XCJcIjpcIm5vbmVcIixkLmlubmVySFRNTD1iLmNsb3NlWCxiLmJ1dHRvbnMmJih1LmlubmVySFRNTD1iLmxlZnRBcnJvdyxjLmlubmVySFRNTD1iLnJpZ2h0QXJyb3cpO3RyeXtzLnN0eWxlLmJhY2tncm91bmRDb2xvcj1iLm92ZXJsYXlCYWNrZ3JvdW5kQ29sb3J9Y2F0Y2gobil7fX0odCk7bC5maXJzdENoaWxkOylsLnJlbW92ZUNoaWxkKGwuZmlyc3RDaGlsZCk7Zm9yKHZhciBuLG89W10saT1bXSxhPWsubGVuZ3RoPTA7YTxlLmxlbmd0aDthKyspKG49SihcImRpdlwiKSkuY2xhc3NOYW1lPVwiZnVsbC1pbWFnZVwiLG4uaWQ9XCJiYWd1ZXR0ZS1pbWctXCIrYSxrLnB1c2gobiksby5wdXNoKFwiYmFndWV0dGVCb3gtZmlndXJlLVwiK2EpLGkucHVzaChcImJhZ3VldHRlQm94LWZpZ2NhcHRpb24tXCIrYSksbC5hcHBlbmRDaGlsZChrW2FdKTtzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLG8uam9pbihcIiBcIikpLHMuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLGkuam9pbihcIiBcIikpfX1mdW5jdGlvbiBJKGUpe2Iubm9TY3JvbGxiYXJzJiYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93WT1cImhpZGRlblwiLGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3dZPVwic2Nyb2xsXCIpLFwiYmxvY2tcIiE9PXMuc3R5bGUuZGlzcGxheSYmKFUoZG9jdW1lbnQsXCJrZXlkb3duXCIsUyksaT17Y291bnQ6MCxzdGFydFg6bnVsbCxzdGFydFk6bnVsbH0sWShvPWUsZnVuY3Rpb24oKXt6KG8pLFYobyl9KSxSKCkscy5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixiLmZ1bGxTY3JlZW4mJmZ1bmN0aW9uIHQoKXtzLnJlcXVlc3RGdWxsc2NyZWVuP3MucmVxdWVzdEZ1bGxzY3JlZW4oKTpzLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuP3Mud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTpzLm1velJlcXVlc3RGdWxsU2NyZWVuJiZzLm1velJlcXVlc3RGdWxsU2NyZWVuKCl9KCksc2V0VGltZW91dChmdW5jdGlvbigpe3MuY2xhc3NOYW1lPVwidmlzaWJsZVwiLGIuYm9keUNsYXNzJiZkb2N1bWVudC5ib2R5LmNsYXNzTGlzdCYmZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGIuYm9keUNsYXNzKSxiLmFmdGVyU2hvdyYmYi5hZnRlclNob3coKX0sNTApLGIub25DaGFuZ2UmJmIub25DaGFuZ2UobyxrLmxlbmd0aCkscj1kb2N1bWVudC5hY3RpdmVFbGVtZW50LE0oKSxuPSEwKX1mdW5jdGlvbiBNKCl7Yi5idXR0b25zP3UuZm9jdXMoKTpkLmZvY3VzKCl9ZnVuY3Rpb24gWCgpe2Iubm9TY3JvbGxiYXJzJiYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93WT1cImF1dG9cIixkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93WT1cImF1dG9cIiksXCJub25lXCIhPT1zLnN0eWxlLmRpc3BsYXkmJihXKGRvY3VtZW50LFwia2V5ZG93blwiLFMpLHMuY2xhc3NOYW1lPVwiXCIsc2V0VGltZW91dChmdW5jdGlvbigpe3Muc3R5bGUuZGlzcGxheT1cIm5vbmVcIixkb2N1bWVudC5mdWxsc2NyZWVuJiZmdW5jdGlvbiBlKCl7ZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4/ZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTpkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuP2RvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTpkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbiYmZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKX0oKSxiLmJvZHlDbGFzcyYmZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QmJmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShiLmJvZHlDbGFzcyksYi5hZnRlckhpZGUmJmIuYWZ0ZXJIaWRlKCksciYmci5mb2N1cygpLG49ITF9LDUwMCkpfWZ1bmN0aW9uIFkodCxuKXt2YXIgZT1rW3RdLG89aFt0XTtpZih2b2lkIDAhPT1lJiZ2b2lkIDAhPT1vKWlmKGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbWdcIilbMF0pbiYmbigpO2Vsc2V7dmFyIGk9by5pbWFnZUVsZW1lbnQsYT1pLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW1nXCIpWzBdLHI9XCJmdW5jdGlvblwiPT10eXBlb2YgYi5jYXB0aW9ucz9iLmNhcHRpb25zLmNhbGwoaCxpKTppLmdldEF0dHJpYnV0ZShcImRhdGEtY2FwdGlvblwiKXx8aS50aXRsZSxzPWZ1bmN0aW9uIGQoZSl7dmFyIHQ9ZS5ocmVmO2lmKGUuZGF0YXNldCl7dmFyIG49W107Zm9yKHZhciBvIGluIGUuZGF0YXNldClcImF0LVwiIT09by5zdWJzdHJpbmcoMCwzKXx8aXNOYU4oby5zdWJzdHJpbmcoMykpfHwobltvLnJlcGxhY2UoXCJhdC1cIixcIlwiKV09ZS5kYXRhc2V0W29dKTtmb3IodmFyIGk9T2JqZWN0LmtleXMobikuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiBwYXJzZUludChlLDEwKTxwYXJzZUludCh0LDEwKT8tMToxfSksYT13aW5kb3cuaW5uZXJXaWR0aCp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyxyPTA7cjxpLmxlbmd0aC0xJiZpW3JdPGE7KXIrKzt0PW5baVtyXV18fHR9cmV0dXJuIHR9KGkpLGw9SihcImZpZ3VyZVwiKTtpZihsLmlkPVwiYmFndWV0dGVCb3gtZmlndXJlLVwiK3QsbC5pbm5lckhUTUw9JzxkaXYgY2xhc3M9XCJiYWd1ZXR0ZUJveC1zcGlubmVyXCI+PGRpdiBjbGFzcz1cImJhZ3VldHRlQm94LWRvdWJsZS1ib3VuY2UxXCI+PC9kaXY+PGRpdiBjbGFzcz1cImJhZ3VldHRlQm94LWRvdWJsZS1ib3VuY2UyXCI+PC9kaXY+PC9kaXY+JyxiLmNhcHRpb25zJiZyKXt2YXIgdT1KKFwiZmlnY2FwdGlvblwiKTt1LmlkPVwiYmFndWV0dGVCb3gtZmlnY2FwdGlvbi1cIit0LHUuaW5uZXJIVE1MPXIsbC5hcHBlbmRDaGlsZCh1KX1lLmFwcGVuZENoaWxkKGwpO3ZhciBjPUooXCJpbWdcIik7Yy5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2JhZ3VldHRlLWltZy1cIit0K1wiIC5iYWd1ZXR0ZUJveC1zcGlubmVyXCIpO2wucmVtb3ZlQ2hpbGQoZSksIWIuYXN5bmMmJm4mJm4oKX0sYy5zZXRBdHRyaWJ1dGUoXCJzcmNcIixzKSxjLmFsdD1hJiZhLmFsdHx8XCJcIixiLnRpdGxlVGFnJiZyJiYoYy50aXRsZT1yKSxsLmFwcGVuZENoaWxkKGMpLGIuYXN5bmMmJm4mJm4oKX19ZnVuY3Rpb24gaigpe3JldHVybiBEKG8rMSl9ZnVuY3Rpb24gcSgpe3JldHVybiBEKG8tMSl9ZnVuY3Rpb24gRChlLHQpe3JldHVybiFuJiYwPD1lJiZlPHQubGVuZ3RoPyhGKHQsYiksSShlKSwhMCk6ZTwwPyhiLmFuaW1hdGlvbiYmTyhcImxlZnRcIiksITEpOmU+PWsubGVuZ3RoPyhiLmFuaW1hdGlvbiYmTyhcInJpZ2h0XCIpLCExKTooWShvPWUsZnVuY3Rpb24oKXt6KG8pLFYobyl9KSxSKCksYi5vbkNoYW5nZSYmYi5vbkNoYW5nZShvLGsubGVuZ3RoKSwhMCl9ZnVuY3Rpb24gTyhlKXtsLmNsYXNzTmFtZT1cImJvdW5jZS1mcm9tLVwiK2Usc2V0VGltZW91dChmdW5jdGlvbigpe2wuY2xhc3NOYW1lPVwiXCJ9LDQwMCl9ZnVuY3Rpb24gUigpe3ZhciBlPTEwMCotbytcIiVcIjtcImZhZGVJblwiPT09Yi5hbmltYXRpb24/KGwuc3R5bGUub3BhY2l0eT0wLHNldFRpbWVvdXQoZnVuY3Rpb24oKXttLnRyYW5zZm9ybXM/bC5zdHlsZS50cmFuc2Zvcm09bC5zdHlsZS53ZWJraXRUcmFuc2Zvcm09XCJ0cmFuc2xhdGUzZChcIitlK1wiLDAsMClcIjpsLnN0eWxlLmxlZnQ9ZSxsLnN0eWxlLm9wYWNpdHk9MX0sNDAwKSk6bS50cmFuc2Zvcm1zP2wuc3R5bGUudHJhbnNmb3JtPWwuc3R5bGUud2Via2l0VHJhbnNmb3JtPVwidHJhbnNsYXRlM2QoXCIrZStcIiwwLDApXCI6bC5zdHlsZS5sZWZ0PWV9ZnVuY3Rpb24geihlKXtlLW8+PWIucHJlbG9hZHx8WShlKzEsZnVuY3Rpb24oKXt6KGUrMSl9KX1mdW5jdGlvbiBWKGUpe28tZT49Yi5wcmVsb2FkfHxZKGUtMSxmdW5jdGlvbigpe1YoZS0xKX0pfWZ1bmN0aW9uIFUoZSx0LG4sbyl7ZS5hZGRFdmVudExpc3RlbmVyP2UuYWRkRXZlbnRMaXN0ZW5lcih0LG4sbyk6ZS5hdHRhY2hFdmVudChcIm9uXCIrdCxmdW5jdGlvbihlKXsoZT1lfHx3aW5kb3cuZXZlbnQpLnRhcmdldD1lLnRhcmdldHx8ZS5zcmNFbGVtZW50LG4oZSl9KX1mdW5jdGlvbiBXKGUsdCxuLG8pe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcj9lLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxuLG8pOmUuZGV0YWNoRXZlbnQoXCJvblwiK3Qsbil9ZnVuY3Rpb24gRyhlKXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSl9ZnVuY3Rpb24gSihlKXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlKX1yZXR1cm5bXS5mb3JFYWNofHwoQXJyYXkucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MDtuPHRoaXMubGVuZ3RoO24rKyllLmNhbGwodCx0aGlzW25dLG4sdGhpcyl9KSxbXS5maWx0ZXJ8fChBcnJheS5wcm90b3R5cGUuZmlsdGVyPWZ1bmN0aW9uKGUsdCxuLG8saSl7Zm9yKG49dGhpcyxvPVtdLGk9MDtpPG4ubGVuZ3RoO2krKyllLmNhbGwodCxuW2ldLGksbikmJm8ucHVzaChuW2ldKTtyZXR1cm4gb30pLHtydW46ZnVuY3Rpb24gSyhlLHQpe3JldHVybiBtLnRyYW5zZm9ybXM9ZnVuY3Rpb24gbigpe3ZhciBlPUooXCJkaXZcIik7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuc3R5bGUucGVyc3BlY3RpdmV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLnN0eWxlLndlYmtpdFBlcnNwZWN0aXZlfSgpLG0uc3ZnPWZ1bmN0aW9uIG8oKXt2YXIgZT1KKFwiZGl2XCIpO3JldHVybiBlLmlubmVySFRNTD1cIjxzdmcvPlwiLFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PShlLmZpcnN0Q2hpbGQmJmUuZmlyc3RDaGlsZC5uYW1lc3BhY2VVUkkpfSgpLG0ucGFzc2l2ZUV2ZW50cz1mdW5jdGlvbiBpKCl7dmFyIGU9ITE7dHJ5e3ZhciB0PU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7ZT0hMH19KTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIixudWxsLHQpfWNhdGNoKG4pe31yZXR1cm4gZX0oKSxmdW5jdGlvbiBhKCl7aWYocz1HKFwiYmFndWV0dGVCb3gtb3ZlcmxheVwiKSlyZXR1cm4gbD1HKFwiYmFndWV0dGVCb3gtc2xpZGVyXCIpLHU9RyhcInByZXZpb3VzLWJ1dHRvblwiKSxjPUcoXCJuZXh0LWJ1dHRvblwiKSx2b2lkKGQ9RyhcImNsb3NlLWJ1dHRvblwiKSk7KHM9SihcImRpdlwiKSkuc2V0QXR0cmlidXRlKFwicm9sZVwiLFwiZGlhbG9nXCIpLHMuaWQ9XCJiYWd1ZXR0ZUJveC1vdmVybGF5XCIsZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdLmFwcGVuZENoaWxkKHMpLChsPUooXCJkaXZcIikpLmlkPVwiYmFndWV0dGVCb3gtc2xpZGVyXCIscy5hcHBlbmRDaGlsZChsKSwodT1KKFwiYnV0dG9uXCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJidXR0b25cIiksdS5pZD1cInByZXZpb3VzLWJ1dHRvblwiLHUuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLFwiUHJldmlvdXNcIiksdS5pbm5lckhUTUw9bS5zdmc/ZjpcIiZsdDtcIixzLmFwcGVuZENoaWxkKHUpLChjPUooXCJidXR0b25cIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIixcImJ1dHRvblwiKSxjLmlkPVwibmV4dC1idXR0b25cIixjLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixcIk5leHRcIiksYy5pbm5lckhUTUw9bS5zdmc/ZzpcIiZndDtcIixzLmFwcGVuZENoaWxkKGMpLChkPUooXCJidXR0b25cIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIixcImJ1dHRvblwiKSxkLmlkPVwiY2xvc2UtYnV0dG9uXCIsZC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsXCJDbG9zZVwiKSxkLmlubmVySFRNTD1tLnN2Zz9wOlwiJnRpbWVzO1wiLHMuYXBwZW5kQ2hpbGQoZCksdS5jbGFzc05hbWU9Yy5jbGFzc05hbWU9ZC5jbGFzc05hbWU9XCJiYWd1ZXR0ZUJveC1idXR0b25cIixmdW5jdGlvbiBuKCl7dmFyIGU9bS5wYXNzaXZlRXZlbnRzP3twYXNzaXZlOiExfTpudWxsLHQ9bS5wYXNzaXZlRXZlbnRzP3twYXNzaXZlOiEwfTpudWxsO1UocyxcImNsaWNrXCIseCksVSh1LFwiY2xpY2tcIixFKSxVKGMsXCJjbGlja1wiLEMpLFUoZCxcImNsaWNrXCIsQiksVShsLFwiY29udGV4dG1lbnVcIixOKSxVKHMsXCJ0b3VjaHN0YXJ0XCIsVCx0KSxVKHMsXCJ0b3VjaG1vdmVcIixBLGUpLFUocyxcInRvdWNoZW5kXCIsTCksVShkb2N1bWVudCxcImZvY3VzXCIsSCwhMCl9KCl9KCksUChlKSxmdW5jdGlvbiByKGUsYSl7dmFyIHQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKSxuPXtnYWxsZXJpZXM6W10sbm9kZUxpc3Q6dH07cmV0dXJuIHdbZV09bixbXS5mb3JFYWNoLmNhbGwodCxmdW5jdGlvbihlKXthJiZhLmZpbHRlciYmKHk9YS5maWx0ZXIpO3ZhciB0PVtdO2lmKHQ9XCJBXCI9PT1lLnRhZ05hbWU/W2VdOmUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpLDAhPT0odD1bXS5maWx0ZXIuY2FsbCh0LGZ1bmN0aW9uKGUpe2lmKC0xPT09ZS5jbGFzc05hbWUuaW5kZXhPZihhJiZhLmlnbm9yZUNsYXNzKSlyZXR1cm4geS50ZXN0KGUuaHJlZil9KSkubGVuZ3RoKXt2YXIgaT1bXTtbXS5mb3JFYWNoLmNhbGwodCxmdW5jdGlvbihlLHQpe3ZhciBuPWZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQ/ZS5wcmV2ZW50RGVmYXVsdCgpOmUucmV0dXJuVmFsdWU9ITEsRihpLGEpLEkodCl9LG89e2V2ZW50SGFuZGxlcjpuLGltYWdlRWxlbWVudDplfTtVKGUsXCJjbGlja1wiLG4pLGkucHVzaChvKX0pLG4uZ2FsbGVyaWVzLnB1c2goaSl9fSksbi5nYWxsZXJpZXN9KGUsdCl9LHNob3c6RCxzaG93TmV4dDpqLHNob3dQcmV2aW91czpxLGhpZGU6WCxkZXN0cm95OmZ1bmN0aW9uIGUoKXshZnVuY3Rpb24gbigpe3ZhciBlPW0ucGFzc2l2ZUV2ZW50cz97cGFzc2l2ZTohMX06bnVsbCx0PW0ucGFzc2l2ZUV2ZW50cz97cGFzc2l2ZTohMH06bnVsbDtXKHMsXCJjbGlja1wiLHgpLFcodSxcImNsaWNrXCIsRSksVyhjLFwiY2xpY2tcIixDKSxXKGQsXCJjbGlja1wiLEIpLFcobCxcImNvbnRleHRtZW51XCIsTiksVyhzLFwidG91Y2hzdGFydFwiLFQsdCksVyhzLFwidG91Y2htb3ZlXCIsQSxlKSxXKHMsXCJ0b3VjaGVuZFwiLEwpLFcoZG9jdW1lbnQsXCJmb2N1c1wiLEgsITApfSgpLGZ1bmN0aW9uIHQoKXtmb3IodmFyIGUgaW4gdyl3Lmhhc093blByb3BlcnR5KGUpJiZQKGUpfSgpLFcoZG9jdW1lbnQsXCJrZXlkb3duXCIsUyksZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdLnJlbW92ZUNoaWxkKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmFndWV0dGVCb3gtb3ZlcmxheVwiKSksdz17fSxoPVtdLG89MH19fSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfanF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbnZhciBfanF1ZXJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pxdWVyeSk7XG5cbnZhciBfbG9kYXNoID0gcmVxdWlyZSgnbG9kYXNoLnRlbXBsYXRlJyk7XG5cbnZhciBfbG9kYXNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZGFzaCk7XG5cbnZhciBfanF1ZXJ5VHJlbmQgPSByZXF1aXJlKCdqcXVlcnktdHJlbmQnKTtcblxudmFyIF9qcXVlcnlUcmVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qcXVlcnlUcmVuZCk7XG5cbnZhciBfanF1ZXJ5UmV2ZWFsZXIgPSByZXF1aXJlKCdqcXVlcnktcmV2ZWFsZXInKTtcblxudmFyIF9qcXVlcnlSZXZlYWxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qcXVlcnlSZXZlYWxlcik7XG5cbnZhciBfZXZlbnRlbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMicpO1xuXG52YXIgX2V2ZW50ZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudGVtaXR0ZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb2R1Y3QgQ29tcGFyaXNvbiBXaWRnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgUHJvZHVjdENvbXBhcmUgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoUHJvZHVjdENvbXBhcmUsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIFByb2R1Y3RDb21wYXJlKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9kdWN0Q29tcGFyZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUHJvZHVjdENvbXBhcmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQcm9kdWN0Q29tcGFyZSkpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMub3B0aW9ucyA9IF9qcXVlcnkyLmRlZmF1bHQuZXh0ZW5kKHtcbiAgICAgIHNjb3BlOiAnW2RhdGEtcHJvZHVjdC1jb21wYXJlXScsXG4gICAgICBtYXhJdGVtczogNCxcbiAgICAgIGl0ZW1UZW1wbGF0ZTogKDAsIF9sb2Rhc2gyLmRlZmF1bHQpKCdcXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb21wYXJlLWl0ZW1cIiBkYXRhLWNvbXBhcmUtaXRlbT5cXG4gICAgICAgICAgPGEgaHJlZj1cIjwlPSB1cmwgJT5cIj5cXG4gICAgICAgICAgICA8aW1nIGNsYXNzPVwiY29tcGFyZS1pdGVtLXRodW1ibmFpbFwiIHNyYz1cIjwlPSB0aHVtYm5haWwgJT5cIi8+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbXBhcmUtaXRlbS1wcmljZVwiPjwlPSBwcmljZSAlPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb21wYXJlLWl0ZW0tdGl0bGVcIj48JT0gdGl0bGUgJT48L2Rpdj5cXG4gICAgICAgICAgPC9hPlxcbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY29tcGFyZS1pdGVtLXJlbW92ZVwiIGRhdGEtY29tcGFyZS1pdGVtLXJlbW92ZT1cIjwlPSBpZCAlPlwiPiZ0aW1lczs8L2J1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICcpXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy4kc2NvcGUgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoX3RoaXMub3B0aW9ucy5zY29wZSk7XG4gICAgX3RoaXMuJGNvbXBhcmVJdGVtcyA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSgnW2RhdGEtY29tcGFyZS1pdGVtc10nKTtcbiAgICBfdGhpcy4kY29tcGFyZUxpbmsgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoJ1tkYXRhLWNvbXBhcmUtbGlua10nKTtcblxuICAgIF90aGlzLmNoZWNrYm94ID0gJ1tkYXRhLWNvbXBhcmUtY2hlY2tib3hdJztcbiAgICBfdGhpcy5jb21wYXJlSXRlbSA9ICdbZGF0YS1jb21wYXJlLWl0ZW1dJztcbiAgICBfdGhpcy5jb21wYXJlUmVtb3ZlID0gJ2RhdGEtY29tcGFyZS1pdGVtLXJlbW92ZSc7XG5cbiAgICBfdGhpcy5faW5pdCgpO1xuICAgIF90aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFNldCB1cCB0aGUgY29tcGFyZSBsaXN0IE1hcFxuICAgKlxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoUHJvZHVjdENvbXBhcmUsIFt7XG4gICAga2V5OiAnX2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIGlmIChzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdjb21wYXJlJykpIHtcbiAgICAgICAgdGhpcy5jb21wYXJlTGlzdCA9IG5ldyBNYXAoSlNPTi5wYXJzZShzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdjb21wYXJlJykpKTtcbiAgICAgICAgdGhpcy5faW5pdFdpZGdldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wYXJlTGlzdCA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEJpbmQgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjb21wYXJlIHdpZGdldFxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19iaW5kRXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRFdmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy4kc2NvcGUub24oJ2NoYW5nZScsIHRoaXMuY2hlY2tib3gsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuX3RvZ2dsZUl0ZW0oZXZlbnQudGFyZ2V0KTtcbiAgICAgIH0pO1xuXG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoJ2JvZHknKS5vbignY2xpY2snLCAnWycgKyB0aGlzLmNvbXBhcmVSZW1vdmUgKyAnXScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaWQgPSBwYXJzZUludCgoMCwgX2pxdWVyeTIuZGVmYXVsdCkoZXZlbnQudGFyZ2V0KS5hdHRyKF90aGlzMi5jb21wYXJlUmVtb3ZlKSwgMTApO1xuICAgICAgICBfdGhpczIuX3JlbW92ZUl0ZW0oaWQpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2V0cyB0aGUgaW5pdGFsIHN0YXRlIG9mIHdpZGdldCBpZiBsb2FkaW5nIGZyb20gc2Vzc2lvblN0b3JhZ2VcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaW5pdFdpZGdldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0V2lkZ2V0KCkge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuY29tcGFyZUxpc3Qua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBpZCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdGhpcy5fY2hlY2tDaGVja2JveChpZCk7XG5cbiAgICAgICAgICB0aGlzLl9wb3B1bGF0ZVdpZGdldChpZCk7XG5cbiAgICAgICAgICB0aGlzLl91cGRhdGVXaWRnZXRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVwZGF0ZXMgYSBjaGVja2JveCBzdGF0ZSB0byBcImNoZWNrZWRcIlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpZH0gbnVtYmVyIFRoZSBJRCBvZiB0aGUgaXRlbSAvIGNoZWNrYm94IHRvIHRhcmdldFxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jaGVja0NoZWNrYm94JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrQ2hlY2tib3goaWQpIHtcbiAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSgnW2RhdGEtY29tcGFyZS1pZD1cIicgKyBpZCArICdcIl0nKS5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIHdpZGdldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtpZH0gbnVtYmVyIFRoZSBJRCBvZiB0aGUgaXRlbSBpdCBhZGRcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcG9wdWxhdGVXaWRnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9wdWxhdGVXaWRnZXQoaWQpIHtcbiAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh0aGlzLm9wdGlvbnMuaXRlbVRlbXBsYXRlKHRoaXMuY29tcGFyZUxpc3QuZ2V0KGlkKSkpLmFwcGVuZFRvKHRoaXMuJGNvbXBhcmVJdGVtcykucmV2ZWFsZXIoJ3Nob3cnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENvbnRyb2xzIHdoZXRoZXIgdG8gYWRkIG9yIHJlbW92ZSBhIHByb2R1Y3QgZnJvbSB0aGUgY29tcGFyZSBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hlY2tib3ggVGhlIGNoZWNrYm94IChkb20gZWxlbWVudClcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdG9nZ2xlSXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVJdGVtKGNoZWNrYm94KSB7XG4gICAgICB2YXIgJGNoZWNrYm94ID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGNoZWNrYm94KTtcbiAgICAgIHZhciBpZCA9IHBhcnNlSW50KCRjaGVja2JveC5kYXRhKCdjb21wYXJlLWlkJyksIDEwKTtcbiAgICAgIHZhciBwcm9kdWN0RGF0YSA9IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB0aXRsZTogJGNoZWNrYm94LmRhdGEoJ2NvbXBhcmUtdGl0bGUnKSxcbiAgICAgICAgdXJsOiAkY2hlY2tib3guZGF0YSgnY29tcGFyZS11cmwnKSxcbiAgICAgICAgcHJpY2U6ICRjaGVja2JveC5kYXRhKCdjb21wYXJlLXByaWNlJyksXG4gICAgICAgIHRodW1ibmFpbDogJGNoZWNrYm94LmRhdGEoJ2NvbXBhcmUtdGh1bWJuYWlsJylcbiAgICAgIH07XG5cbiAgICAgIC8vIEFkZCAvIHJlbW92ZSBpdGVtIGZyb20gY29tcGFyZSBsaXN0XG4gICAgICBpZiAoY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgICB0aGlzLl9hZGRJdGVtKGlkLCBwcm9kdWN0RGF0YSk7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgYW4gYXJyYXkgb2YgdGhlIGNvbXBhcmUgSURzIHNvIHdlIGNhbiB0YXJnZXQgdGhlIGZpcnN0IGl0ZW1cbiAgICAgICAgdmFyIGNvbXBhcmVJZHMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuY29tcGFyZUxpc3Qua2V5cygpKSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIGxpc3QgaWYgPiBtYXhJdGVtc1xuICAgICAgICBpZiAodGhpcy5jb21wYXJlTGlzdC5zaXplID4gdGhpcy5vcHRpb25zLm1heEl0ZW1zKSB7XG4gICAgICAgICAgdmFyIGZpcnN0SXRlbSA9IGNvbXBhcmVJZHNbMF07XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlSXRlbShmaXJzdEl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVJdGVtKGlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgY29tcGFyZSBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVGhlIElEIG9mIHRoZSBpdGVtIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9kdWN0RGF0YSBPYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSBvZiBhIGNvbXBhcmUgaXRlbVxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19hZGRJdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEl0ZW0oaWQsIHByb2R1Y3REYXRhKSB7XG4gICAgICB0aGlzLmVtaXQoJ2JlZm9yZWFkZCcsIGlkKTtcblxuICAgICAgdGhpcy5jb21wYXJlTGlzdC5zZXQoaWQsIHByb2R1Y3REYXRhKTtcblxuICAgICAgdGhpcy5fcG9wdWxhdGVXaWRnZXQoaWQpO1xuXG4gICAgICB0aGlzLl91cGRhdGVXaWRnZXRTdGF0ZSgpO1xuXG4gICAgICB0aGlzLmVtaXQoJ2FmdGVyYWRkJywgaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGNvbXBhcmUgbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbSB0byByZW1vdmVcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVtb3ZlSXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVJdGVtKGlkKSB7XG4gICAgICB0aGlzLmVtaXQoJ2JlZm9yZXJlbW92ZScsIGlkKTtcblxuICAgICAgdGhpcy5jb21wYXJlTGlzdC5kZWxldGUoaWQpO1xuXG4gICAgICB0aGlzLiRjb21wYXJlSXRlbXMuZmluZCgnWycgKyB0aGlzLmNvbXBhcmVSZW1vdmUgKyAnPScgKyBpZCArICddJykuY2xvc2VzdCh0aGlzLmNvbXBhcmVJdGVtKS5yZXZlYWxlcignaGlkZScpO1xuXG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcy5jb21wYXJlSXRlbSkub24oJ3JldmVhbGVyLWhpZGUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGV2ZW50LmN1cnJlbnRUYXJnZXQpLnJlbW92ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFVuY2hlY2sgdGhlIGNoZWNrYm94IGlmIHJlbW92ZWQgdmlhIGJ1dHRvblxuICAgICAgKDAsIF9qcXVlcnkyLmRlZmF1bHQpKCdbZGF0YS1jb21wYXJlLWlkPVwiJyArIGlkICsgJ1wiXScpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVdpZGdldFN0YXRlKCk7XG5cbiAgICAgIHRoaXMuZW1pdCgnYWZ0ZXJyZW1vdmUnLCBpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHRvIGNsZWFyIHRoZSBsaXN0IGFuZCB3aWRnZXQgaXRlbXNcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVBbGwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMuY29tcGFyZUxpc3Qua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGlkID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdGhpcy5fcmVtb3ZlSXRlbShpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNldHMgZWFjaCBjaGVja2JveCBpbiB0aGUgY29tcGFyZSBsaXN0IHRvIFwiY2hlY2tlZFwiLlxuICAgICAqIFVzZWZ1bCBpZiBwcm9kdWN0cyBhcmUgbG9hZGVkIGR5bmFtaWNhbGx5IGFuZCB0aGUgd2lkZ2V0IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlQ2hlY2tib3hlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNoZWNrYm94ZXMoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHRoaXMuY29tcGFyZUxpc3Qua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGlkID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgdGhpcy5fY2hlY2tDaGVja2JveChpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBhcmUgd2lkZ2V0IHN0YXRlXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZVdpZGdldFN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVdpZGdldFN0YXRlKCkge1xuICAgICAgdmFyIGNvbXBhcmVMZW5ndGggPSB0aGlzLmNvbXBhcmVMaXN0LnNpemU7XG5cbiAgICAgIC8vIFRvZ2dsZSB3aWRnZXQgc3RhdGUgY2xhc3NcbiAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSgnW2RhdGEtY29tcGFyZS13aWRnZXRdJykudG9nZ2xlQ2xhc3MoJ2lzLWVuYWJsZWQnLCAhIWNvbXBhcmVMZW5ndGgpO1xuXG4gICAgICAvLyBUb2dnbGUgY29tcGFyZSBsaW5rIGNsYXNzXG4gICAgICB0aGlzLiRjb21wYXJlTGluay50b2dnbGVDbGFzcygnaXMtZGlzYWJsZWQnLCBjb21wYXJlTGVuZ3RoIDw9IDEpO1xuXG4gICAgICAvLyBTZXQgY29tcGFyZSBsaW5rIGhyZWZcbiAgICAgIHRoaXMuJGNvbXBhcmVMaW5rLmF0dHIoJ2hyZWYnLCB0aGlzLiRjb21wYXJlTGluay5kYXRhKCdjb21wYXJlLWxpbmsnKSArICcvJyArIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5jb21wYXJlTGlzdC5rZXlzKCkpKS5qb2luKCcvJykpO1xuXG4gICAgICAvLyBTYXZlIHRoZSBjb21wYXJlIGRhdGEgZm9yIGxhdGVyXG4gICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdjb21wYXJlJywgSlNPTi5zdHJpbmdpZnkoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmNvbXBhcmVMaXN0KSkpKTtcblxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPdmVyLXJpZGUgRXZlbnRFbWl0dGVyJ3MgXCJvblwiIG1ldGhvZCBzbyB0aGF0IGV2ZW50cyBjYW4gYmUgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhleSdyZSBib3VuZFxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgZmlyZU9uQmluZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIF9nZXQoUHJvZHVjdENvbXBhcmUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUHJvZHVjdENvbXBhcmUucHJvdG90eXBlKSwgJ29uJywgdGhpcykuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgaWYgKGZpcmVPbkJpbmQpIHtcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFByb2R1Y3RDb21wYXJlO1xufShfZXZlbnRlbWl0dGVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUHJvZHVjdENvbXBhcmU7IiwiLyohXG4gKiBSZXZlYWxlciAzLjAuMFxuICpcbiAqIENvcHlyaWdodCAyMDIxLCBQaXhlbCBVbmlvbiAtIGh0dHA6Ly9waXhlbHVuaW9uLm5ldFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbihmdW5jdGlvbigkKXtcbiAgLy8gY2hlY2sgZm9yIHRyZW5kIGV2ZW50IChtYWtlIHN1cmUganF1ZXJ5LnRyZW5kIGlzIGluY2x1ZGVkKVxuICBpZiAodHlwZW9mICQuZXZlbnQuc3BlY2lhbC50cmVuZCAhPT0gXCJvYmplY3RcIikge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBtYWtlIHN1cmUganF1ZXJ5LnRyZW5kIGlzIGluY2x1ZGVkISBPdGhlcndpc2UgcmV2ZWFsZXIgd29uJ3Qgd29yay5cIik7XG4gIH1cblxuICAvLyBTaW1wbGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsXG4gIHZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBmdW5jdGlvbihmbikgeyB3aW5kb3cuc2V0VGltZW91dChmbiwgMTAwMC82MCk7IH1cblxuXG4gIC8vIFB1YmxpYyBBUElcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuICEhZWwuZGF0YShcInJldmVhbGVyLXZpc2libGVcIik7XG4gICAgfSxcblxuICAgIHNob3c6IGZ1bmN0aW9uKGVsLCBmb3JjZSkge1xuICAgICAgLy8gQ2hlY2sgc3RhdGVcbiAgICAgIGlmIChtZXRob2RzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLWluXCIpO1xuICAgICAgICBlbC5vZmYoXCJyZXZlYWxlci1hbmltYXRpbmcgcmV2ZWFsZXItc2hvd1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgcHJldmlvdXMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBlbC5kYXRhKFwicmV2ZWFsZXItdmlzaWJsZVwiLCB0cnVlKTtcbiAgICAgIGVsLm9mZihcInRyZW5kXCIpO1xuXG4gICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgZWwuYWRkQ2xhc3MoXCJ2aXNpYmxlXCIpO1xuICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItYW5pbWF0aW5nXCIpO1xuICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1zaG93XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gU3RhcnQgYW5pbWF0aW9uIHN0YXRlIHRyYW5zaXRpb25cbiAgICAgICAgZWwuYWRkQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLWluXCIpO1xuICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItYW5pbWF0aW5nXCIpO1xuXG4gICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgIGVsLmFkZENsYXNzKFwidmlzaWJsZVwiKTtcblxuICAgICAgICAgIGVsLm9uZShcInRyZW5kXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBlbC5yZW1vdmVDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctaW5cIik7XG4gICAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItc2hvd1wiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oZWwsIGZvcmNlKSB7XG4gICAgICAvLyBDaGVjayBzdGF0ZVxuICAgICAgaWYgKCFtZXRob2RzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLW91dCB2aXNpYmxlXCIpO1xuICAgICAgICBlbC5vZmYoXCJyZXZlYWxlci1hbmltYXRpbmcgcmV2ZWFsZXItaGlkZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgcHJldmlvdXMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBlbC5kYXRhKFwicmV2ZWFsZXItdmlzaWJsZVwiLCBmYWxzZSk7XG4gICAgICBlbC5vZmYoXCJ0cmVuZFwiKTtcblxuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgIGVsLnJlbW92ZUNsYXNzKFwidmlzaWJsZVwiKTtcbiAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWFuaW1hdGluZ1wiKTtcbiAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItaGlkZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgIGVsLmFkZENsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1vdXRcIik7XG4gICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1hbmltYXRpbmdcIik7XG5cbiAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJ2aXNpYmxlXCIpO1xuXG4gICAgICAgICAgZWwub25lKFwidHJlbmRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1pbiBhbmltYXRpbmctb3V0XCIpO1xuICAgICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWhpZGVcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRvZ2dsZTogZnVuY3Rpb24oZWwsIGZvcmNlKSB7XG4gICAgICBpZiAobWV0aG9kcy5pc1Zpc2libGUoZWwpKSB7XG4gICAgICAgIG1ldGhvZHMuaGlkZShlbCwgZm9yY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0aG9kcy5zaG93KGVsLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGpRdWVyeSBwbHVnaW5cbiAgJC5mbi5yZXZlYWxlciA9IGZ1bmN0aW9uKG1ldGhvZCwgZm9yY2UpIHtcbiAgICAvLyBHZXQgYWN0aW9uXG4gICAgdmFyIGFjdGlvbiA9IG1ldGhvZHNbbWV0aG9kIHx8IFwidG9nZ2xlXCJdO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gdGhpcztcblxuICAgIC8vIFJ1biBhY3Rpb25cbiAgICBpZiAobWV0aG9kID09PSBcImlzVmlzaWJsZVwiKSB7XG4gICAgICByZXR1cm4gYWN0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIGFjdGlvbigkKHRoaXMpLCBmb3JjZSk7XG4gICAgfSk7XG4gIH07XG59KShqUXVlcnkpO1xuIiwiLyohXG4gKiBUcmVuZCAwLjEuMFxuICpcbiAqIEZhaWwtc2FmZSBUcmFuc2l0aW9uRW5kIGV2ZW50IGZvciBqUXVlcnkuXG4gKlxuICogQWRkcyBhIG5ldyBcInRyZW5kXCIgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCBpbiBicm93c2VycyB0aGF0IGRvbid0XG4gKiBzdXBwb3J0IFwidHJhbnNpdGlvbmVuZFwiLlxuICpcbiAqIE5PVEU6IE9ubHkgc3VwcG9ydHMgYmVpbmcgYm91bmQgd2l0aCBcImpRdWVyeS5vbmVcIi5cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCwgUGl4ZWwgVW5pb24gLSBodHRwOi8vcGl4ZWx1bmlvbi5uZXRcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG47KGZ1bmN0aW9uKCQpe1xuXG4gIC8vIFByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZXNcbiAgdmFyIHRyYW5zaXRpb25FbmRFdmVudHMgPVxuICAgIFwid2Via2l0VHJhbnNpdGlvbkVuZCBcIiArXG4gICAgXCJvdHJhbnNpdGlvbmVuZCBcIiArXG4gICAgXCJvVHJhbnNpdGlvbkVuZCBcIiArXG4gICAgXCJtc1RyYW5zaXRpb25FbmQgXCIgK1xuICAgIFwidHJhbnNpdGlvbmVuZFwiO1xuXG4gIC8vIFByZWZpeGVkIHRyYW5zaXRpb24gZHVyYXRpb24gcHJvcGVydHkgbmFtZXNcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvblByb3BlcnRpZXMgPSBbXG4gICAgXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItbW96LXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi13ZWJraXQtdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLW1zLXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1vLXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1raHRtbC10cmFuc2l0aW9uLWR1cmF0aW9uXCJcbiAgXTtcblxuICAvLyBQYXJzZXMgYSBDU1MgZHVyYXRpb24gdmFsdWUgaW50byBtaWxsaXNlY29uZHMuXG4gIHZhciBwYXJzZUR1cmF0aW9uID0gZnVuY3Rpb24ocykge1xuICAgIHMgPSBzLnJlcGxhY2UoL1xccy8sIFwiXCIpO1xuICAgIHZhciB2ID0gd2luZG93LnBhcnNlRmxvYXQocyk7XG5cbiAgICByZXR1cm4gcy5tYXRjaCgvW15tXXMkL2kpXG4gICAgICA/IHYgKiAxMDAwXG4gICAgICA6IHY7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGZvciBhbiBlbGVtZW50LCBhcyBzcGVjaWZpZWQgYnkgQ1NTLlxuICAvLyBSZXR1cm5zIGEgdmFsdWUgaW4gbWlsbGlzZWNvbmRzLlxuICB2YXIgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgZHVyYXRpb24gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2l0aW9uRHVyYXRpb25Qcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBHZXQgcmF3IENTUyB2YWx1ZVxuICAgICAgdmFyIHZhbHVlID0gZWwuY3NzKHRyYW5zaXRpb25EdXJhdGlvblByb3BlcnRpZXNbaV0pO1xuICAgICAgaWYgKCF2YWx1ZSkgY29udGludWU7XG5cbiAgICAgIC8vIE11bHRpcGxlIHRyYW5zaXRpb25zLS1waWNrIHRoZSBsb25nZXN0XG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihcIixcIikgIT09IC0xKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgIHZhciBkdXJhdGlvbnMgPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBwYXJzZUR1cmF0aW9uKHZhbHVlc1tpXSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZHVyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGR1cmF0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbmdsZSB0cmFuc2l0aW9uXG4gICAgICBlbHNlIHtcbiAgICAgICAgZHVyYXRpb24gPSBwYXJzZUR1cmF0aW9uKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWNjZXB0IGZpcnN0IHZhdWVcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfTtcblxuICAkLmV2ZW50LnNwZWNpYWwudHJlbmQgPSB7XG4gICAgLy8gVHJpZ2dlcnMgYW4gZXZlbnQgaGFuZGxlciB3aGVuIGFuIGVsZW1lbnQgaXMgZG9uZSB0cmFuc2l0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gSGFuZGxlcyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdHJhbnNpdGlvbmVuZCBieSBhZGRpbmcgYVxuICAgIC8vIHRpbWVvdXQgd2l0aCB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbi5cbiAgICBhZGQ6IGZ1bmN0aW9uKGhhbmRsZU9iaikge1xuICAgICAgdmFyIGVsID0gJCh0aGlzKTtcbiAgICAgIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBNYXJrIGVsZW1lbnQgYXMgYmVpbmcgaW4gdHJhbnNpdGlvblxuICAgICAgZWwuZGF0YShcInRyZW5kXCIsIHRydWUpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYSBmYWxsYmFjayBkdXJhdGlvbi4gKyAyMCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgZmlyZVxuICAgICAgLy8gdGltZW91dHMgZmFzdGVyIHRoYW4gdHJhbnNpdGlvbmVuZC5cbiAgICAgIHZhciBkdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbihlbCkgKyAyMDtcblxuICAgICAgdmFyIGNiID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyB0cmFuc2l0aW9uZW5kIGV2ZW50cyBjYW4gYmUgc2VudCBmb3IgZWFjaCBwcm9wZXJ0eS4gTGV0J3MganVzdFxuICAgICAgICAvLyBza2lwIGFsbCBidXQgdGhlIGZpcnN0LiBBbHNvIGhhbmRsZXMgdGhlIHRpbWVvdXQgY2FsbGJhY2suXG4gICAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIENoaWxkIGVsZW1lbnRzIHRoYXQgYWxzbyBoYXZlIHRyYW5zaXRpb25zIGNhbiBiZSBmaXJlZCBiZWZvcmUgd2VcbiAgICAgICAgLy8gY29tcGxldGUuIFRoaXMgd2lsbCBjYXRjaCBhbmQgaWdub3JlIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCB3ZSdsbFxuICAgICAgICAvLyBoYXZlIHRvIHJlbHkgb24gdGhlIHRpbWVvdXQgaW4gdGhlc2UgY2FzZXMuXG4gICAgICAgIGlmIChlICYmIGUuc3JjRWxlbWVudCAhPT0gZWxbMF0pIHJldHVybjtcblxuICAgICAgICAvLyBNYXJrIGVsZW1lbnQgaGFzIG5vdCBiZWluZyBpbiB0cmFuc2l0aW9uXG4gICAgICAgIGVsLmRhdGEoXCJ0cmVuZFwiLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gQ2FsbGJhY2tcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaGFuZGxlT2JqLmhhbmRsZXIpIGhhbmRsZU9iai5oYW5kbGVyKCk7XG4gICAgICB9O1xuXG4gICAgICBlbC5vbmUodHJhbnNpdGlvbkVuZEV2ZW50cywgY2IpO1xuICAgICAgZWwuZGF0YShcInRyZW5kLXRpbWVvdXRcIiwgd2luZG93LnNldFRpbWVvdXQoY2IsIGR1cmF0aW9uKSk7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oaGFuZGxlT2JqKSB7XG4gICAgICB2YXIgZWwgPSAkKHRoaXMpO1xuICAgICAgZWwub2ZmKHRyYW5zaXRpb25FbmRFdmVudHMpO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChlbC5kYXRhKFwidHJlbmQtdGltZW91dFwiKSk7XG4gICAgfVxuICB9O1xuXG59KShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2pxdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgX2pxdWVyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qcXVlcnkpO1xuXG52YXIgX2pxdWVyeVRyZW5kID0gcmVxdWlyZSgnanF1ZXJ5LXRyZW5kJyk7XG5cbnZhciBfanF1ZXJ5VHJlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanF1ZXJ5VHJlbmQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTG9hZGluZ1V0aWxzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb2FkaW5nVXRpbHMob3B0aW9ucywgc2Nyb2xsTG9jaywgZWwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZGluZ1V0aWxzKTtcblxuICAgIHRoaXMuc2Nyb2xsTG9jayA9IHNjcm9sbExvY2s7XG4gICAgdGhpcy4kYm9keSA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShkb2N1bWVudC5ib2R5KTtcbiAgICB0aGlzLiRlbCA9IGVsID8gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGVsKSA6IHRoaXMuJGJvZHk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBfanF1ZXJ5Mi5kZWZhdWx0LmV4dGVuZCh7XG4gICAgICBsb2FkaW5nTWFya3VwOiAnPGRpdiBjbGFzcz1cImxvYWRpbmdcIj48c3BhbiBjbGFzcz1cImxvYWRpbmctc3Bpbm5lclwiPjwvc3Bhbj48L2Rpdj4nLFxuICAgICAgdmlzaWJsZUNsYXNzOiAndmlzaWJsZScsXG4gICAgICBzY3JvbGxMb2NrQ2xhc3M6ICdzY3JvbGwtbG9ja2VkJ1xuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy4kbG9hZGluZyA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh0aGlzLm9wdGlvbnMubG9hZGluZ01hcmt1cCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTG9hZGluZ1V0aWxzLCBbe1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsTG9jaykge1xuICAgICAgICB0aGlzLiRib2R5LmFkZENsYXNzKHRoaXMub3B0aW9ucy5zY3JvbGxMb2NrQ2xhc3MpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudFBvc2l0aW9uaW5nID0gdGhpcy4kZWwuY3NzKCdwb3NpdGlvbicpO1xuXG4gICAgICBpZiAoZWxlbWVudFBvc2l0aW9uaW5nID09PSAnc3RhdGljJykge1xuICAgICAgICB0aGlzLiRlbC5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsLnByZXBlbmQodGhpcy4kbG9hZGluZyk7XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy4kbG9hZGluZy5hZGRDbGFzcyhfdGhpcy5vcHRpb25zLnZpc2libGVDbGFzcyk7XG4gICAgICB9LCAxMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsTG9jaykge1xuICAgICAgICB0aGlzLiRib2R5LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zY3JvbGxMb2NrQ2xhc3MpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRsb2FkaW5nLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy52aXNpYmxlQ2xhc3MpLm9uZSgndHJlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi4kbG9hZGluZy5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMb2FkaW5nVXRpbHM7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExvYWRpbmdVdGlsczsiLCIvKiFcbiAqIFRyZW5kIDAuMS4wXG4gKlxuICogRmFpbC1zYWZlIFRyYW5zaXRpb25FbmQgZXZlbnQgZm9yIGpRdWVyeS5cbiAqXG4gKiBBZGRzIGEgbmV3IFwidHJlbmRcIiBldmVudCB0aGF0IGNhbiBiZSB1c2VkIGluIGJyb3dzZXJzIHRoYXQgZG9uJ3RcbiAqIHN1cHBvcnQgXCJ0cmFuc2l0aW9uZW5kXCIuXG4gKlxuICogTk9URTogT25seSBzdXBwb3J0cyBiZWluZyBib3VuZCB3aXRoIFwialF1ZXJ5Lm9uZVwiLlxuICpcbiAqIENvcHlyaWdodCAyMDE0LCBQaXhlbCBVbmlvbiAtIGh0dHA6Ly9waXhlbHVuaW9uLm5ldFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24oJCl7XG5cbiAgLy8gUHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lc1xuICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50cyA9XG4gICAgXCJ3ZWJraXRUcmFuc2l0aW9uRW5kIFwiICtcbiAgICBcIm90cmFuc2l0aW9uZW5kIFwiICtcbiAgICBcIm9UcmFuc2l0aW9uRW5kIFwiICtcbiAgICBcIm1zVHJhbnNpdGlvbkVuZCBcIiArXG4gICAgXCJ0cmFuc2l0aW9uZW5kXCI7XG5cbiAgLy8gUHJlZml4ZWQgdHJhbnNpdGlvbiBkdXJhdGlvbiBwcm9wZXJ0eSBuYW1lc1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uUHJvcGVydGllcyA9IFtcbiAgICBcInRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1tb3otdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLXdlYmtpdC10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItbXMtdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLW8tdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLWtodG1sLXRyYW5zaXRpb24tZHVyYXRpb25cIlxuICBdO1xuXG4gIC8vIFBhcnNlcyBhIENTUyBkdXJhdGlvbiB2YWx1ZSBpbnRvIG1pbGxpc2Vjb25kcy5cbiAgdmFyIHBhcnNlRHVyYXRpb24gPSBmdW5jdGlvbihzKSB7XG4gICAgcyA9IHMucmVwbGFjZSgvXFxzLywgXCJcIik7XG4gICAgdmFyIHYgPSB3aW5kb3cucGFyc2VGbG9hdChzKTtcblxuICAgIHJldHVybiBzLm1hdGNoKC9bXm1dcyQvaSlcbiAgICAgID8gdiAqIDEwMDBcbiAgICAgIDogdjtcbiAgfTtcblxuICAvLyBHZXQgdGhlIHRyYW5zaXRpb24gZHVyYXRpb24gZm9yIGFuIGVsZW1lbnQsIGFzIHNwZWNpZmllZCBieSBDU1MuXG4gIC8vIFJldHVybnMgYSB2YWx1ZSBpbiBtaWxsaXNlY29uZHMuXG4gIHZhciBnZXRUcmFuc2l0aW9uRHVyYXRpb24gPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBkdXJhdGlvbiA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zaXRpb25EdXJhdGlvblByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEdldCByYXcgQ1NTIHZhbHVlXG4gICAgICB2YXIgdmFsdWUgPSBlbC5jc3ModHJhbnNpdGlvbkR1cmF0aW9uUHJvcGVydGllc1tpXSk7XG4gICAgICBpZiAoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgLy8gTXVsdGlwbGUgdHJhbnNpdGlvbnMtLXBpY2sgdGhlIGxvbmdlc3RcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiLFwiKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgdmFyIGR1cmF0aW9ucyA9IChmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHBhcnNlRHVyYXRpb24odmFsdWVzW2ldKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChkdXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZHVyYXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2luZ2xlIHRyYW5zaXRpb25cbiAgICAgIGVsc2Uge1xuICAgICAgICBkdXJhdGlvbiA9IHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBY2NlcHQgZmlyc3QgdmF1ZVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9O1xuXG4gICQuZXZlbnQuc3BlY2lhbC50cmVuZCA9IHtcbiAgICAvLyBUcmlnZ2VycyBhbiBldmVudCBoYW5kbGVyIHdoZW4gYW4gZWxlbWVudCBpcyBkb25lIHRyYW5zaXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBIYW5kbGVzIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0cmFuc2l0aW9uZW5kIGJ5IGFkZGluZyBhXG4gICAgLy8gdGltZW91dCB3aXRoIHRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uLlxuICAgIGFkZDogZnVuY3Rpb24oaGFuZGxlT2JqKSB7XG4gICAgICB2YXIgZWwgPSAkKHRoaXMpO1xuICAgICAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgICAgIC8vIE1hcmsgZWxlbWVudCBhcyBiZWluZyBpbiB0cmFuc2l0aW9uXG4gICAgICBlbC5kYXRhKFwidHJlbmRcIiwgdHJ1ZSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBhIGZhbGxiYWNrIGR1cmF0aW9uLiArIDIwIGJlY2F1c2Ugc29tZSBicm93c2VycyBmaXJlXG4gICAgICAvLyB0aW1lb3V0cyBmYXN0ZXIgdGhhbiB0cmFuc2l0aW9uZW5kLlxuICAgICAgdmFyIGR1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uKGVsKSArIDIwO1xuXG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIHRyYW5zaXRpb25lbmQgZXZlbnRzIGNhbiBiZSBzZW50IGZvciBlYWNoIHByb3BlcnR5LiBMZXQncyBqdXN0XG4gICAgICAgIC8vIHNraXAgYWxsIGJ1dCB0aGUgZmlyc3QuIEFsc28gaGFuZGxlcyB0aGUgdGltZW91dCBjYWxsYmFjay5cbiAgICAgICAgaWYgKGZpcmVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gQ2hpbGQgZWxlbWVudHMgdGhhdCBhbHNvIGhhdmUgdHJhbnNpdGlvbnMgY2FuIGJlIGZpcmVkIGJlZm9yZSB3ZVxuICAgICAgICAvLyBjb21wbGV0ZS4gVGhpcyB3aWxsIGNhdGNoIGFuZCBpZ25vcmUgdGhvc2UuIFVuZm9ydHVuYXRlbHksIHdlJ2xsXG4gICAgICAgIC8vIGhhdmUgdG8gcmVseSBvbiB0aGUgdGltZW91dCBpbiB0aGVzZSBjYXNlcy5cbiAgICAgICAgaWYgKGUgJiYgZS5zcmNFbGVtZW50ICE9PSBlbFswXSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIE1hcmsgZWxlbWVudCBoYXMgbm90IGJlaW5nIGluIHRyYW5zaXRpb25cbiAgICAgICAgZWwuZGF0YShcInRyZW5kXCIsIGZhbHNlKTtcblxuICAgICAgICAvLyBDYWxsYmFja1xuICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgIGlmIChoYW5kbGVPYmouaGFuZGxlcikgaGFuZGxlT2JqLmhhbmRsZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIGVsLm9uZSh0cmFuc2l0aW9uRW5kRXZlbnRzLCBjYik7XG4gICAgICBlbC5kYXRhKFwidHJlbmQtdGltZW91dFwiLCB3aW5kb3cuc2V0VGltZW91dChjYiwgZHVyYXRpb24pKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihoYW5kbGVPYmopIHtcbiAgICAgIHZhciBlbCA9ICQodGhpcyk7XG4gICAgICBlbC5vZmYodHJhbnNpdGlvbkVuZEV2ZW50cyk7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGVsLmRhdGEoXCJ0cmVuZC10aW1lb3V0XCIpKTtcbiAgICB9XG4gIH07XG5cbn0pKGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfanF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbnZhciBfanF1ZXJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pxdWVyeSk7XG5cbnZhciBfanF1ZXJ5VHJlbmQgPSByZXF1aXJlKCdqcXVlcnktdHJlbmQnKTtcblxudmFyIF9qcXVlcnlUcmVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qcXVlcnlUcmVuZCk7XG5cbnZhciBfanF1ZXJ5UmV2ZWFsZXIgPSByZXF1aXJlKCdqcXVlcnktcmV2ZWFsZXInKTtcblxudmFyIF9qcXVlcnlSZXZlYWxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qcXVlcnlSZXZlYWxlcik7XG5cbnZhciBfanVzdERlYm91bmNlID0gcmVxdWlyZSgnanVzdC1kZWJvdW5jZScpO1xuXG52YXIgX2p1c3REZWJvdW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qdXN0RGVib3VuY2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vZGFsKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWwpO1xuXG4gICAgdGhpcy4kbW9kYWw7XG4gICAgdGhpcy4kbW9kYWxDb250ZW50O1xuICAgIHRoaXMuJGRpYWxvZztcbiAgICB0aGlzLiRib2R5ID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKCdib2R5Jyk7XG4gICAgdGhpcy4kZWwgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkob3B0aW9ucy5lbCk7XG4gICAgdGhpcy4kYmFja2Ryb3AgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoJzxkaXYgY2xhc3M9XCJtb2RhbC1vdmVybGF5XCI+Jyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBfanF1ZXJ5Mi5kZWZhdWx0LmV4dGVuZCh7XG4gICAgICBtb2RhbElkOiAnbW9kYWwnLFxuICAgICAgbW9kYWxDbGFzczogJycsXG4gICAgICBib2R5T3ZlcmZsb3dDbGFzczogJ3Njcm9sbC1sb2NrZWQnLFxuICAgICAgY2VudGVyVmVydGljYWxseTogdHJ1ZSxcbiAgICAgIGNsb3NlU2VsZWN0b3I6ICcubW9kYWwtY2xvc2UnLFxuICAgICAgYWZ0ZXJTaG93OiBmdW5jdGlvbiBhZnRlclNob3coKSB7fSxcbiAgICAgIGFmdGVySGlkZTogZnVuY3Rpb24gYWZ0ZXJIaWRlKCkge31cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMud3JhcHBlckh0bWwgPSAnPGRpdiBpZD1cIicgKyB0aGlzLm9wdGlvbnMubW9kYWxJZCArICdcIiBjbGFzcz1cIm1vZGFsLXdyYXBwZXJcIiB0YWJpbmRleD1cIi0xXCIgcm9sZT1cImRpYWxvZ1wiPjxkaXYgY2xhc3M9XCInICsgdGhpcy5vcHRpb25zLm1vZGFsQ2xhc3MgKyAnIG1vZGFsXCIgcm9sZT1cImRvY3VtZW50XCI+PGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj4nO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCB1cCBvdXIgZnJlc2ggbW9kYWwgZWxlbWVudFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhNb2RhbCwgW3tcbiAgICBrZXk6ICdfaW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgLy8gZ2V0IHRoZSBjb250ZW50c1xuICAgICAgdGhpcy4kbW9kYWxDb250ZW50ID0gdGhpcy4kZWwuY2hpbGRyZW4oKS5kZXRhY2goKTtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyB3cmFwcGluZyBlbGVtZW50XG4gICAgICB0aGlzLiRtb2RhbCA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh0aGlzLndyYXBwZXJIdG1sKTtcbiAgICAgIC8vIHBvcCBvdXIgY29udGVudCBpbiB0aGVyZVxuICAgICAgdGhpcy4kbW9kYWwuZmluZCgnLm1vZGFsLWNvbnRlbnQnKS5hcHBlbmQodGhpcy4kbW9kYWxDb250ZW50KTtcbiAgICAgIC8vIGFkZCBiYWNrZHJvcFxuICAgICAgdGhpcy4kYmFja2Ryb3AuYXBwZW5kVG8odGhpcy4kYm9keSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHV0IGV2ZXJ5dGhpbmcgYmFjayB3aGVyZSB0aGV5IHVzZWQgdG8gYmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3Jlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0KCkge1xuICAgICAgdGhpcy4kbW9kYWwuZGV0YWNoKCk7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy4kbW9kYWxDb250ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IGJvdGggdGhlIG1vZGFsIGFuZCBiYWNrZHJvcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfb3BlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vcGVuKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgdGhpcy5fYmluZE92ZXJsYXlDbGljaygpO1xuICAgICAgdGhpcy5fYmluZENsb3NlQ2xpY2soKTtcbiAgICAgIHRoaXMuX2JpbmRDbG9zZUVzYygpO1xuXG4gICAgICB0aGlzLiRib2R5LmFkZENsYXNzKHRoaXMub3B0aW9ucy5ib2R5T3ZlcmZsb3dDbGFzcykuYXBwZW5kKHRoaXMuJG1vZGFsKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jZW50ZXJWZXJ0aWNhbGx5KSB7XG4gICAgICAgIHRoaXMuJGRpYWxvZyA9IHRoaXMuJG1vZGFsLmZpbmQoJy5tb2RhbCcpO1xuICAgICAgICB0aGlzLl9iaW5kUmVzaXplKCk7XG5cbiAgICAgICAgLy8gcG9zaXRpb24gbW9kYWwgZm9yIHRoZSBmaXJzdCB0aW1lIGp1c3QgYWZ0ZXIgaXQncyBiZWVuIHVuaGlkZGVuXG4gICAgICAgIHRoaXMuJG1vZGFsLm9uZSgncmV2ZWFsZXItYW5pbWF0aW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl9yZXBvc2l0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBiaW5kIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICB0aGlzLiRtb2RhbC5vbmUoJ3JldmVhbGVyLXNob3cnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMub3B0aW9ucy5hZnRlclNob3coKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGV2ZW50LmN1cnJlbnRUYXJnZXQpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBzaG93IGJvdGggbW9kYWwgJiBiYWNrZHJvcFxuICAgICAgdGhpcy4kbW9kYWwuYWRkKHRoaXMuJGJhY2tkcm9wKS5yZXZlYWxlcignc2hvdycpO1xuXG4gICAgICAvLyBzZXQgdXAgYmFja2Ryb3AgcmVtb3ZhbCBvbiBoaWRlXG4gICAgICB0aGlzLiRiYWNrZHJvcC5vbigncmV2ZWFsZXItaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuJGJhY2tkcm9wLnJlbW92ZSgpO1xuICAgICAgICBfdGhpcy5vcHRpb25zLmFmdGVySGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZSAgYm90aCB0aGUgbW9kYWwgYW5kIGJhY2tkcm9wXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19jbG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZSgpIHtcbiAgICAgIHRoaXMuJG1vZGFsLmFkZCh0aGlzLiRiYWNrZHJvcCkucmV2ZWFsZXIoJ2hpZGUnKTtcblxuICAgICAgdGhpcy4kYm9keS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYm9keU92ZXJmbG93Q2xhc3MpO1xuXG4gICAgICB0aGlzLl91bmJpbmRSZXNpemUoKTtcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xvc2UgbW9kYWwgaWYgd2UgY2xpY2sgb25seSBvbiBiYWNrZHJvcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYmluZE92ZXJsYXlDbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kT3ZlcmxheUNsaWNrKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG1vZGFsLm9uKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgX3RoaXMyLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZSBtb2RhbCBpZiB3ZSBjbGljayBvbiBhIGNsb3NlIGJ1dHRvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYmluZENsb3NlQ2xpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZENsb3NlQ2xpY2soKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy4kbW9kYWwub24oJ2NsaWNrJywgdGhpcy5vcHRpb25zLmNsb3NlU2VsZWN0b3IsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpczMuX2Nsb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZSBtb2RhbCBpZiB3ZSBwcmVzcyB0aGUgZXNjYXBlIGJ1dHRvbiB3aGVuIGl0J3MgdmlzaWJsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYmluZENsb3NlRXNjJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRDbG9zZUVzYygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoZG9jdW1lbnQpLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcgJiYgX3RoaXM0LiRtb2RhbC5yZXZlYWxlcignaXNWaXNpYmxlJykpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIF90aGlzNC5fY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUG9zaXRpb25pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSBtYXJnaW4tdG9wIGZvciBlbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZXBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcG9zaXRpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuJGRpYWxvZyB8fCAhdGhpcy5vcHRpb25zLmNlbnRlclZlcnRpY2FsbHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxIZWlnaHQgPSB0aGlzLiRkaWFsb2cub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkod2luZG93KS5oZWlnaHQoKTtcbiAgICAgIHZhciBkaWZmID0gKHdpbmRvd0hlaWdodCAtIGVsSGVpZ2h0KSAvIDI7XG5cbiAgICAgIGRpZmYgPSBkaWZmIDwgMCA/IDAgOiBkaWZmO1xuXG4gICAgICB0aGlzLiRkaWFsb2cuY3NzKCdtYXJnaW4tdG9wJywgZGlmZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2JpbmRSZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZFJlc2l6ZSgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkod2luZG93KS5vbigncmVzaXplLm1vZGFsJywgKDAsIF9qdXN0RGVib3VuY2UyLmRlZmF1bHQpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM1Ll9yZXBvc2l0aW9uLmJpbmQoX3RoaXM1KTtcbiAgICAgIH0sIDEwMCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ191bmJpbmRSZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kUmVzaXplKCkge1xuICAgICAgKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHdpbmRvdykub2ZmKCdyZXNpemUubW9kYWwnKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFeHBvc2UgUHVibGljIE1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICB9LCB7XG4gICAga2V5OiAnb3BlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICB0aGlzLl9vcGVuKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlcG9zaXRpb24oKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTW9kYWw7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1vZGFsOyIsIi8qIVxuICogUmV2ZWFsZXIgMy4wLjBcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMSwgUGl4ZWwgVW5pb24gLSBodHRwOi8vcGl4ZWx1bmlvbi5uZXRcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24oJCl7XG4gIC8vIGNoZWNrIGZvciB0cmVuZCBldmVudCAobWFrZSBzdXJlIGpxdWVyeS50cmVuZCBpcyBpbmNsdWRlZClcbiAgaWYgKHR5cGVvZiAkLmV2ZW50LnNwZWNpYWwudHJlbmQgIT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQbGVhc2UgbWFrZSBzdXJlIGpxdWVyeS50cmVuZCBpcyBpbmNsdWRlZCEgT3RoZXJ3aXNlIHJldmVhbGVyIHdvbid0IHdvcmsuXCIpO1xuICB9XG5cbiAgLy8gU2ltcGxlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbFxuICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZnVuY3Rpb24oZm4pIHsgd2luZG93LnNldFRpbWVvdXQoZm4sIDEwMDAvNjApOyB9XG5cblxuICAvLyBQdWJsaWMgQVBJXG4gIHZhciBtZXRob2RzID0ge1xuICAgIGlzVmlzaWJsZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiAhIWVsLmRhdGEoXCJyZXZlYWxlci12aXNpYmxlXCIpO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbihlbCwgZm9yY2UpIHtcbiAgICAgIC8vIENoZWNrIHN0YXRlXG4gICAgICBpZiAobWV0aG9kcy5pc1Zpc2libGUoZWwpKSB7XG4gICAgICAgIGVsLnJlbW92ZUNsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1pblwiKTtcbiAgICAgICAgZWwub2ZmKFwicmV2ZWFsZXItYW5pbWF0aW5nIHJldmVhbGVyLXNob3dcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgZWwuZGF0YShcInJldmVhbGVyLXZpc2libGVcIiwgdHJ1ZSk7XG4gICAgICBlbC5vZmYoXCJ0cmVuZFwiKTtcblxuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgIGVsLmFkZENsYXNzKFwidmlzaWJsZVwiKTtcbiAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWFuaW1hdGluZ1wiKTtcbiAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItc2hvd1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFN0YXJ0IGFuaW1hdGlvbiBzdGF0ZSB0cmFuc2l0aW9uXG4gICAgICAgIGVsLmFkZENsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1pblwiKTtcbiAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWFuaW1hdGluZ1wiKTtcblxuICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbC5hZGRDbGFzcyhcInZpc2libGVcIik7XG5cbiAgICAgICAgICBlbC5vbmUoXCJ0cmVuZFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLWluXCIpO1xuICAgICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLXNob3dcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKGVsLCBmb3JjZSkge1xuICAgICAgLy8gQ2hlY2sgc3RhdGVcbiAgICAgIGlmICghbWV0aG9kcy5pc1Zpc2libGUoZWwpKSB7XG4gICAgICAgIGVsLnJlbW92ZUNsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1vdXQgdmlzaWJsZVwiKTtcbiAgICAgICAgZWwub2ZmKFwicmV2ZWFsZXItYW5pbWF0aW5nIHJldmVhbGVyLWhpZGVcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgZWwuZGF0YShcInJldmVhbGVyLXZpc2libGVcIiwgZmFsc2UpO1xuICAgICAgZWwub2ZmKFwidHJlbmRcIik7XG5cbiAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICBlbC5yZW1vdmVDbGFzcyhcInZpc2libGVcIik7XG4gICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1hbmltYXRpbmdcIik7XG4gICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWhpZGVcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICBlbC5hZGRDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctb3V0XCIpO1xuICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItYW5pbWF0aW5nXCIpO1xuXG4gICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKFwidmlzaWJsZVwiKTtcblxuICAgICAgICAgIGVsLm9uZShcInRyZW5kXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBlbC5yZW1vdmVDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctaW4gYW5pbWF0aW5nLW91dFwiKTtcbiAgICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1oaWRlXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0b2dnbGU6IGZ1bmN0aW9uKGVsLCBmb3JjZSkge1xuICAgICAgaWYgKG1ldGhvZHMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICBtZXRob2RzLmhpZGUoZWwsIGZvcmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGhvZHMuc2hvdyhlbCwgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBqUXVlcnkgcGx1Z2luXG4gICQuZm4ucmV2ZWFsZXIgPSBmdW5jdGlvbihtZXRob2QsIGZvcmNlKSB7XG4gICAgLy8gR2V0IGFjdGlvblxuICAgIHZhciBhY3Rpb24gPSBtZXRob2RzW21ldGhvZCB8fCBcInRvZ2dsZVwiXTtcbiAgICBpZiAoIWFjdGlvbikgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBSdW4gYWN0aW9uXG4gICAgaWYgKG1ldGhvZCA9PT0gXCJpc1Zpc2libGVcIikge1xuICAgICAgcmV0dXJuIGFjdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICBhY3Rpb24oJCh0aGlzKSwgZm9yY2UpO1xuICAgIH0pO1xuICB9O1xufSkoalF1ZXJ5KTtcbiIsIi8qIVxuICogVHJlbmQgMC4xLjBcbiAqXG4gKiBGYWlsLXNhZmUgVHJhbnNpdGlvbkVuZCBldmVudCBmb3IgalF1ZXJ5LlxuICpcbiAqIEFkZHMgYSBuZXcgXCJ0cmVuZFwiIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgaW4gYnJvd3NlcnMgdGhhdCBkb24ndFxuICogc3VwcG9ydCBcInRyYW5zaXRpb25lbmRcIi5cbiAqXG4gKiBOT1RFOiBPbmx5IHN1cHBvcnRzIGJlaW5nIGJvdW5kIHdpdGggXCJqUXVlcnkub25lXCIuXG4gKlxuICogQ29weXJpZ2h0IDIwMTQsIFBpeGVsIFVuaW9uIC0gaHR0cDovL3BpeGVsdW5pb24ubmV0XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbigkKXtcblxuICAvLyBQcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWVzXG4gIHZhciB0cmFuc2l0aW9uRW5kRXZlbnRzID1cbiAgICBcIndlYmtpdFRyYW5zaXRpb25FbmQgXCIgK1xuICAgIFwib3RyYW5zaXRpb25lbmQgXCIgK1xuICAgIFwib1RyYW5zaXRpb25FbmQgXCIgK1xuICAgIFwibXNUcmFuc2l0aW9uRW5kIFwiICtcbiAgICBcInRyYW5zaXRpb25lbmRcIjtcblxuICAvLyBQcmVmaXhlZCB0cmFuc2l0aW9uIGR1cmF0aW9uIHByb3BlcnR5IG5hbWVzXG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25Qcm9wZXJ0aWVzID0gW1xuICAgIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLW1vei10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1tcy10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItby10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCIta2h0bWwtdHJhbnNpdGlvbi1kdXJhdGlvblwiXG4gIF07XG5cbiAgLy8gUGFyc2VzIGEgQ1NTIGR1cmF0aW9uIHZhbHVlIGludG8gbWlsbGlzZWNvbmRzLlxuICB2YXIgcGFyc2VEdXJhdGlvbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICBzID0gcy5yZXBsYWNlKC9cXHMvLCBcIlwiKTtcbiAgICB2YXIgdiA9IHdpbmRvdy5wYXJzZUZsb2F0KHMpO1xuXG4gICAgcmV0dXJuIHMubWF0Y2goL1tebV1zJC9pKVxuICAgICAgPyB2ICogMTAwMFxuICAgICAgOiB2O1xuICB9O1xuXG4gIC8vIEdldCB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBmb3IgYW4gZWxlbWVudCwgYXMgc3BlY2lmaWVkIGJ5IENTUy5cbiAgLy8gUmV0dXJucyBhIHZhbHVlIGluIG1pbGxpc2Vjb25kcy5cbiAgdmFyIGdldFRyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNpdGlvbkR1cmF0aW9uUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHJhdyBDU1MgdmFsdWVcbiAgICAgIHZhciB2YWx1ZSA9IGVsLmNzcyh0cmFuc2l0aW9uRHVyYXRpb25Qcm9wZXJ0aWVzW2ldKTtcbiAgICAgIGlmICghdmFsdWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBNdWx0aXBsZSB0cmFuc2l0aW9ucy0tcGljayB0aGUgbG9uZ2VzdFxuICAgICAgaWYgKHZhbHVlLmluZGV4T2YoXCIsXCIpICE9PSAtMSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICB2YXIgZHVyYXRpb25zID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gcGFyc2VEdXJhdGlvbih2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGR1cmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heC5hcHBseShNYXRoLCBkdXJhdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5nbGUgdHJhbnNpdGlvblxuICAgICAgZWxzZSB7XG4gICAgICAgIGR1cmF0aW9uID0gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFjY2VwdCBmaXJzdCB2YXVlXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH07XG5cbiAgJC5ldmVudC5zcGVjaWFsLnRyZW5kID0ge1xuICAgIC8vIFRyaWdnZXJzIGFuIGV2ZW50IGhhbmRsZXIgd2hlbiBhbiBlbGVtZW50IGlzIGRvbmUgdHJhbnNpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIEhhbmRsZXMgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRyYW5zaXRpb25lbmQgYnkgYWRkaW5nIGFcbiAgICAvLyB0aW1lb3V0IHdpdGggdGhlIHRyYW5zaXRpb24gZHVyYXRpb24uXG4gICAgYWRkOiBmdW5jdGlvbihoYW5kbGVPYmopIHtcbiAgICAgIHZhciBlbCA9ICQodGhpcyk7XG4gICAgICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICAgICAgLy8gTWFyayBlbGVtZW50IGFzIGJlaW5nIGluIHRyYW5zaXRpb25cbiAgICAgIGVsLmRhdGEoXCJ0cmVuZFwiLCB0cnVlKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGEgZmFsbGJhY2sgZHVyYXRpb24uICsgMjAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGZpcmVcbiAgICAgIC8vIHRpbWVvdXRzIGZhc3RlciB0aGFuIHRyYW5zaXRpb25lbmQuXG4gICAgICB2YXIgZHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb24oZWwpICsgMjA7XG5cbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gdHJhbnNpdGlvbmVuZCBldmVudHMgY2FuIGJlIHNlbnQgZm9yIGVhY2ggcHJvcGVydHkuIExldCdzIGp1c3RcbiAgICAgICAgLy8gc2tpcCBhbGwgYnV0IHRoZSBmaXJzdC4gQWxzbyBoYW5kbGVzIHRoZSB0aW1lb3V0IGNhbGxiYWNrLlxuICAgICAgICBpZiAoZmlyZWQpIHJldHVybjtcblxuICAgICAgICAvLyBDaGlsZCBlbGVtZW50cyB0aGF0IGFsc28gaGF2ZSB0cmFuc2l0aW9ucyBjYW4gYmUgZmlyZWQgYmVmb3JlIHdlXG4gICAgICAgIC8vIGNvbXBsZXRlLiBUaGlzIHdpbGwgY2F0Y2ggYW5kIGlnbm9yZSB0aG9zZS4gVW5mb3J0dW5hdGVseSwgd2UnbGxcbiAgICAgICAgLy8gaGF2ZSB0byByZWx5IG9uIHRoZSB0aW1lb3V0IGluIHRoZXNlIGNhc2VzLlxuICAgICAgICBpZiAoZSAmJiBlLnNyY0VsZW1lbnQgIT09IGVsWzBdKSByZXR1cm47XG5cbiAgICAgICAgLy8gTWFyayBlbGVtZW50IGhhcyBub3QgYmVpbmcgaW4gdHJhbnNpdGlvblxuICAgICAgICBlbC5kYXRhKFwidHJlbmRcIiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIENhbGxiYWNrXG4gICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhbmRsZU9iai5oYW5kbGVyKSBoYW5kbGVPYmouaGFuZGxlcigpO1xuICAgICAgfTtcblxuICAgICAgZWwub25lKHRyYW5zaXRpb25FbmRFdmVudHMsIGNiKTtcbiAgICAgIGVsLmRhdGEoXCJ0cmVuZC10aW1lb3V0XCIsIHdpbmRvdy5zZXRUaW1lb3V0KGNiLCBkdXJhdGlvbikpO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKGhhbmRsZU9iaikge1xuICAgICAgdmFyIGVsID0gJCh0aGlzKTtcbiAgICAgIGVsLm9mZih0cmFuc2l0aW9uRW5kRXZlbnRzKTtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZWwuZGF0YShcInRyZW5kLXRpbWVvdXRcIikpO1xuICAgIH1cbiAgfTtcblxufSkoalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9qcXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIF9qcXVlcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanF1ZXJ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFNjcm9sbExpbmsgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjcm9sbExpbmsob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGxMaW5rKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IF9qcXVlcnkyLmRlZmF1bHQuZXh0ZW5kKHtcbiAgICAgIHNlbGVjdG9yOiAnW2RhdGEtc2Nyb2xsXScsXG4gICAgICBkdXJhdGlvbjogMTAwMCxcbiAgICAgIGVhc2luZzogJ3N3aW5nJyxcbiAgICAgIGRlbGF5OiAwLFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgdXBkYXRlSGFzaDogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNjcm9sbExpbmssIFt7XG4gICAga2V5OiAnX2JpbmRFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh0aGlzLm9wdGlvbnMuc2VsZWN0b3IpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuX3Njcm9sbFRvQ29udGVudCgoMCwgX2pxdWVyeTIuZGVmYXVsdCkoZS5jdXJyZW50VGFyZ2V0KSk7XG4gICAgICAgIH0sIF90aGlzLm9wdGlvbnMuZGVsYXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3Njcm9sbFRvQ29udGVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zY3JvbGxUb0NvbnRlbnQodGFyZ2V0KSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLm9wdGlvbnMuZHVyYXRpb247XG4gICAgICB2YXIgZWFzaW5nID0gdGhpcy5vcHRpb25zLmVhc2luZztcbiAgICAgIHZhciBzY3JvbGxUYXJnZXQgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGFyZ2V0KS5kYXRhKCdzY3JvbGwnKSB8fCB0YXJnZXQ7XG5cbiAgICAgIGlmIChzY3JvbGxUYXJnZXQgPT09ICcjJykge1xuICAgICAgICBzY3JvbGxUYXJnZXQgPSAnYm9keSc7XG4gICAgICB9XG5cbiAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xuICAgICAgICBzY3JvbGxUb3A6ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShzY3JvbGxUYXJnZXQpLm9mZnNldCgpLnRvcCArIHRoaXMub3B0aW9ucy5vZmZzZXRcbiAgICAgIH0sIGR1cmF0aW9uLCBlYXNpbmcpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZUhhc2gpIHtcbiAgICAgICAgaWYgKGhpc3RvcnkucmVwbGFjZVN0YXRlKSB7XG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIHNjcm9sbFRhcmdldCwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHNjcm9sbFRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Njcm9sbFRvQ29udGVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbFRvQ29udGVudCh0YXJnZXQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLl9zY3JvbGxUb0NvbnRlbnQodGFyZ2V0KTtcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5kZWxheSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjcm9sbExpbms7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbExpbms7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2pxdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgX2pxdWVyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qcXVlcnkpO1xuXG52YXIgX2p1c3REZWJvdW5jZSA9IHJlcXVpcmUoJ2p1c3QtZGVib3VuY2UnKTtcblxudmFyIF9qdXN0RGVib3VuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanVzdERlYm91bmNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFRhYnMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRhYnMob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJzKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IF9qcXVlcnkyLmRlZmF1bHQuZXh0ZW5kKHtcblxuICAgICAgLy8gU2NvcGluZyB0aGUgdGFicyAoZXZlbnQgYmluZGluZyksIGxpbmsgY2xhc3MsIGFuZCBjb250ZW50XG4gICAgICB0YWJTY29wZTogJ1tkYXRhLXRhYnNdJyxcbiAgICAgIHRhYlRvZ2dsZTogJ1tkYXRhLXRhYi1saW5rXScsXG4gICAgICB0YWJDb250ZW50OiAnW2RhdGEtdGFiLWNvbnRlbnRdJyxcbiAgICAgIHRvZ2dsZVRhYjogdGhpcy5fZGVmYXVsdFRvZ2dsZVRhYixcbiAgICAgIGtlZXBUYWJzT3BlbjogdGhpcy5rZWVwVGFic09wZW4sXG4gICAgICBhY3RpdmVDbGFzczogJ2FjdGl2ZScsXG4gICAgICBkZWZhdWx0VGFiOiAnJyxcbiAgICAgIGFmdGVyU2V0dXA6IGZ1bmN0aW9uIGFmdGVyU2V0dXAoKSB7fSxcbiAgICAgIGFmdGVyQ2hhbmdlOiBmdW5jdGlvbiBhZnRlckNoYW5nZSgkZWxlbWVudCkge30sXG4gICAgICB0YWJIaXN0b3J5OiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy4kc2NvcGUgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcy5vcHRpb25zLnRhYlNjb3BlKTtcbiAgICB0aGlzLiR0YWJUb2dnbGVzID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHRoaXMub3B0aW9ucy50YWJUb2dnbGUpO1xuICAgIHRoaXMuJHRhYkNvbnRlbnRzID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKHRoaXMub3B0aW9ucy50YWJDb250ZW50KTtcblxuICAgIHRoaXMuZGVmYXVsdFRhYiA9IHRoaXMub3B0aW9ucy5kZWZhdWx0VGFiIHx8IHRoaXMuJHRhYkNvbnRlbnRzLmdldCgwKTtcblxuICAgIHRoaXMuY3VycmVudFRhYiA9IHRoaXMuX2RlZmF1bHRUYWIoKTtcbiAgICB0aGlzLnByZXZpb3VzU3R5bGUgPSB0aGlzLl9nZXRUYWJTdHlsZSgpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgICB0aGlzLm9wdGlvbnMuYWZ0ZXJTZXR1cCgpO1xuICB9XG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gL1xuICAgRGVmYXVsdCBmdW5jdGlvbnM6IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgY2FsbGJhY2tzIGludG8gY29uc3RydWN0b3JcbiAgICovXG5cbiAgLy8gRmluZCBvdXQgdGhlIGRlZmF1bHQgdGFiIChpZiBub25lIHNlbGVjdGVkIGluIG9wdGlvbnMpXG5cblxuICBfY3JlYXRlQ2xhc3MoVGFicywgW3tcbiAgICBrZXk6ICdfZGVmYXVsdFRhYicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWZhdWx0VGFiKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHRhYkNvbnRlbnRzLmZpcnN0KCkuYXR0cignaWQnKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGZ1bmN0aW9uIHRvIHRvZ2dsZSBhIHRhYiBiZXR3ZWVuIGFjdGl2ZSAvIGluYWN0aXZlXG5cbiAgfSwge1xuICAgIGtleTogJ19kZWZhdWx0VG9nZ2xlVGFiJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlZmF1bHRUb2dnbGVUYWIoZWxlbWVudCwgYWN0aXZlKSB7XG4gICAgICB2YXIgJGVsZW1lbnQgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkoZWxlbWVudCk7XG5cbiAgICAgICRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMuYWN0aXZlQ2xhc3MsIGFjdGl2ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2dldFRhYlN0eWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRhYlN0eWxlKCkge1xuICAgICAgdmFyIHBzZXVkb0VsZW0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRzY29wZS5nZXQoMCksICc6YmVmb3JlJykuY29udGVudC5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICByZXR1cm4gcHNldWRvRWxlbTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGZ1bmN0aW9uIHRvIHRvZ2dsZSBzb21lIGNvbnRlbnQgb24gb3Igb2ZmXG5cbiAgfSwge1xuICAgIGtleTogJ19kZWZhdWx0VG9nZ2xlQ29udGVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWZhdWx0VG9nZ2xlQ29udGVudChlbGVtZW50LCBhY3RpdmUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciAkZWxlbWVudCA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShlbGVtZW50KTtcblxuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAvLyBTZXQgdGhlIHRhYiB0byBhY3RpdmVcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXNTdHlsZSA9PT0gJ3NsaWRlJykge1xuICAgICAgICAgIC8vIHNob3cgd2l0aCBhIHNsaWRldG9nZ2xlXG4gICAgICAgICAgJGVsZW1lbnQuc2xpZGVEb3duKCdmYXN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5hZnRlckNoYW5nZSgkZWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2hvdyBzaW1wbHkgdmlhIGRpc3BsYXlcbiAgICAgICAgICAkZWxlbWVudC5zaG93KCk7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFmdGVyQ2hhbmdlKCRlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0YWIgdG8gaW5hY3RpdmVcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXNTdHlsZSA9PT0gJ3NsaWRlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSB2aWEgYSBzbGlkZVRvZ2dsZVxuICAgICAgICAgICRlbGVtZW50LnNsaWRlVXAoJ2Zhc3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zLmFmdGVyQ2hhbmdlKCRlbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdmlhIGEgc2ltcGxlIGhpZGVcbiAgICAgICAgICAkZWxlbWVudC5oaWRlKCk7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFmdGVyQ2hhbmdlKCRlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgdGFyZ2V0IGFsbCB0YWJzIG9yIGluZGl2aWR1YWwgdGFic1xuICAgIC8vIChTd2FwIGJldHdlZW4gdGFiIGFuZCBhY2NvcmRpb24gZnVuY3Rpb25hbGl0eS4pXG5cbiAgfSwge1xuICAgIGtleTogJ2tlZXBUYWJzT3BlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtlZXBUYWJzT3BlbigpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCA8IDgwMDtcbiAgICB9XG5cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvXG4gICAgIEFjdGl2YXRpb24gZnVuY3Rpb25zOiBUcmlnZ2VyIHRoZSBjYWxsYmFja3MgZm9yIHNob3dpbmcgLyBoaWRpbmcgdGFiXG4gICAgIGNvbXBvbmVudHMgYW5kIGxpbmtzXG4gICAgICovXG5cbiAgICAvLyBTZXQgYSBwYXJ0aWN1bGFyIHRhYiBhcyBhY3RpdmUgKGFuZCBvcHRpb25hbGx5IGRpc2FibGUgb3RoZXJzKVxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgYSB3cmFwcGVyIGZvciBhY3RpdmF0aW5nIGJvdGggdGhlIHRhYi1saW5rIGFuZFxuICAgIC8vIHRhYi1jb250ZW50IGF0IHRoZSBzYW1lIHRpbWUuXG5cbiAgfSwge1xuICAgIGtleTogJ2FjdGl2YXRlVGFiJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWN0aXZhdGVUYWIoaGFzaCwgY2xvc2VPdGhlcnMpIHtcblxuICAgICAgLy8gbmVjZXNzYXJ5IHRvIGNoZWNrIGZvciBsaW5rcyB0aGF0IGxpbmsgdG8gdGFicyB0aGF0IGFyZW4ndCBhdmFpbGFibGU6XG4gICAgICBpZiAoISgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShoYXNoKS5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3RhYiBkb2VzblxcJ3QgZXhpc3QhJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzU3RpY2t5ID0gY2xvc2VPdGhlcnMgfHwgdGhpcy5vcHRpb25zLmtlZXBUYWJzT3BlbigpO1xuICAgICAgdGhpcy5hY3RpdmF0ZVRhYlRvZ2dsZShoYXNoLCBpc1N0aWNreSk7XG4gICAgICB0aGlzLmFjdGl2YXRlVGFiQ29udGVudChoYXNoLCBpc1N0aWNreSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGJjLXRhYnMgaWYgY29udGVudCB3aXRoIHRhYnMgaXMgdXBkYXRlZCwgcmVmcmVzaGVkIG9yIHJlcGxhY2VkXG5cbiAgfSwge1xuICAgIGtleTogJ3VubG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVubG9hZCgpIHtcbiAgICAgIHRoaXMuJHNjb3BlLm9mZignLmJjLXRhYnMnKTtcbiAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh3aW5kb3cpLm9mZignLmJjLXRhYnMnKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYSBwYXJ0aWN1bGFyIFtkYXRhLXRhYi10b2dnbGVdIGxpbmsgYXMgYWN0aXZlLFxuICAgIC8vIGFuZCAob3B0aW9uYWxseSkgZGVhY3RpdmF0ZSBvdGhlcnNcblxuICB9LCB7XG4gICAga2V5OiAnYWN0aXZhdGVUYWJUb2dnbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3RpdmF0ZVRhYlRvZ2dsZShoYXNoKSB7XG4gICAgICB2YXIgaXNTdGlja3kgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG5cbiAgICAgIHZhciAkdGhpc1RhYiA9ICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KShoYXNoKTtcblxuICAgICAgLy8gRmluZCB0YWJsaW5rcyB0aGF0IHBvaW50IHRvIHRoaXMgaGFzaFxuICAgICAgdmFyICR0YWJMaW5rcyA9IHRoaXMuJHRhYlRvZ2dsZXMuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh0aGlzKS5hdHRyKCdocmVmJykgPT09IGhhc2g7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFpc1N0aWNreSkge1xuICAgICAgICAvLyBUYWIgc3RpY2t5bmVzcyBub3QgYWN0aXZlLCB0YXJnZXQgYWxsIG90aGVyIHRhYnMgaW4gZ3JvdXBcblxuICAgICAgICBpZiAoJHRoaXNUYWIuaXMoJzp2aXNpYmxlJykpIHJldHVybjtcbiAgICAgICAgLy8gR3JhYiBhbGwgdGhlIGdyb3VwcyB0aGVzZSBsaW5rcyBiZWxvbmcgdG9cbiAgICAgICAgdmFyIHRhYnNHcm91cHMgPSBbXTtcbiAgICAgICAgJHRhYkxpbmtzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0aGlzVGFiR3JvdXAgPSAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcykuZGF0YSgndGFicy1ncm91cCcpO1xuICAgICAgICAgIGlmICh0YWJzR3JvdXBzLmluZGV4T2YodGhpc1RhYkdyb3VwKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRhYnNHcm91cHMucHVzaCh0aGlzVGFiR3JvdXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmlsdGVyIGFsbCB0aGUgdGFicyB0byBvbmx5IHRob3NlIGJlbG9uZ2luZyB0byB0aGVzZSBncm91cHNcbiAgICAgICAgdmFyICR0YWJzR3JvdXAgPSB0aGlzLiR0YWJUb2dnbGVzLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRhYnNHcm91cHMuaW5kZXhPZigoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcykuZGF0YSgndGFicy1ncm91cCcpKSA+IC0xO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEaXNhYmxlIGFsbCB0aGUgdGFiIGxpbmtzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHRhYnNHcm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy50b2dnbGVUYWIoJHRhYnNHcm91cFtpXSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5hYmxlIGp1c3QgdGhlIHRhYiBsaW5rcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBoYXNoXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCAkdGFiTGlua3MubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnRvZ2dsZVRhYigkdGFiTGlua3NbX2ldLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGFicyBhcmUgc3RpY2t5LCBzbyB3ZSBzaG91bGQgb25seSB0b2dnbGUgaXRlbXMgbWF0Y2hpbmcgdGhpcyBoYXNoXG4gICAgICAgIGlmICgkdGhpc1RhYi5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgIC8vIEVuYWJsZSBqdXN0IHRoZSB0YWIgbGlua3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaGFzaFxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8ICR0YWJMaW5rcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudG9nZ2xlVGFiKCR0YWJMaW5rc1tfaTJdLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8ICR0YWJMaW5rcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudG9nZ2xlVGFiKCR0YWJMaW5rc1tfaTNdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBY3RpdmF0ZSBhIGNvbnRlbnQtZWxlbWVudCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGhhc2gsIGFuZFxuICAgIC8vIChvcHRpb25hbGx5KSBoaWRlIG90aGVycyBpbiBncm91cFxuXG4gIH0sIHtcbiAgICBrZXk6ICdhY3RpdmF0ZVRhYkNvbnRlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3RpdmF0ZVRhYkNvbnRlbnQoaGFzaCkge1xuICAgICAgdmFyIGlzU3RpY2t5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgdmFyICR0aGlzVGFiID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGhhc2gpO1xuXG4gICAgICBpZiAoIWlzU3RpY2t5KSB7XG5cbiAgICAgICAgaWYgKCR0aGlzVGFiLmlzKCc6dmlzaWJsZScpKSByZXR1cm47XG5cbiAgICAgICAgLy8gTG9jYXRlIG90aGVyIHRhYnMgdGhhdCBzaGFyZSB0aGUgc2FtZSAndGFicy1ncm91cCdcbiAgICAgICAgdmFyIHRhYnNHcm91cCA9ICR0aGlzVGFiLmRhdGEoJ3RhYnMtZ3JvdXAnKTtcbiAgICAgICAgdmFyICR0YWJzR3JvdXAgPSB0aGlzLiR0YWJDb250ZW50cy5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAoMCwgX2pxdWVyeTIuZGVmYXVsdCkodGhpcykuZGF0YSgndGFicy1ncm91cCcpID09PSB0YWJzR3JvdXA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERpc2FibGUgb3RoZXIgdGFicyBpbiB0aGlzIGdyb3VwXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHRhYnNHcm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX2RlZmF1bHRUb2dnbGVDb250ZW50KCR0YWJzR3JvdXBbaV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmFibGUgdGhpcyB0YWIgY29udGVudFxuICAgICAgICB0aGlzLl9kZWZhdWx0VG9nZ2xlQ29udGVudCgkdGhpc1RhYiwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUYWJzIGFyZSBzdGlja3ksIHNvIHdlIG9ubHkgdG9nZ2xlIHRoZSBpbmRpdmlkdWFsIGl0ZW1cbiAgICAgICAgaWYgKCR0aGlzVGFiLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgdGhpcy5fZGVmYXVsdFRvZ2dsZUNvbnRlbnQoJHRoaXNUYWIsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kZWZhdWx0VG9nZ2xlQ29udGVudCgkdGhpc1RhYiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvXG4gICAgIE1pc2NlbGxhbmVvdXM6IGRlYWwgd2l0aCBpbml0aW5nIHRoZSBiYXNlIHRhYiBzdGF0ZSAoc2F5IGFmdGVyIHJlc2l6aW5nXG4gICAgIHRoZSB2aWV3cG9ydCBvciBvbiBwYWdlIGxvYWQpIGFuZCBldmVudCBiaW5kaW5nLlxuICAgICAqL1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gcnVuIHdoZW4gdGFicyBhcmUgZmlyc3QgaW5pdCAoc2V0cyBvbmUgYWN0aXZlIG92ZXIgb3RoZXJzKVxuXG4gIH0sIHtcbiAgICBrZXk6ICdfaW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KGNoZWNrU3R5bGVNYXRjaCkge1xuICAgICAgaWYgKGNoZWNrU3R5bGVNYXRjaCkge1xuICAgICAgICB2YXIgY3VycmVudFN0eWxlID0gdGhpcy5fZ2V0VGFiU3R5bGUoKTtcblxuICAgICAgICBpZiAodGhpcy5wcmV2aW91c1N0eWxlID09IGN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJldmlvdXNTdHlsZSA9IGN1cnJlbnRTdHlsZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaCB8fCAnIycgKyB0aGlzLmRlZmF1bHRUYWIuaWQ7XG4gICAgICB2YXIgY3VycmVudFRhYiA9IGhhc2ggPyAnYVtocmVmPVwiJyArIGhhc2ggKyAnXCJdJyA6ICdbZGF0YS10YWItbGlua106Zmlyc3QnO1xuXG4gICAgICAvLyBEaXNhYmxlIGFsbCB0aGUgdGFic1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiR0YWJUb2dnbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b2dnbGVUYWIodGhpcy4kdGFiVG9nZ2xlcy5nZXQoaSksIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdGhpcy4kdGFiQ29udGVudHMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB0aGlzLl9kZWZhdWx0VG9nZ2xlQ29udGVudCh0aGlzLiR0YWJDb250ZW50cy5nZXQoX2k0KSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kZWZhdWx0VG9nZ2xlQ29udGVudChoYXNoLCB0cnVlKTtcbiAgICAgIHRoaXMub3B0aW9ucy50b2dnbGVUYWIoY3VycmVudFRhYiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gQmluZCBldmVudCBoYW5kbGVycyB0byB0aGUgc2NvcGUgdGFyZ2V0LlxuXG4gIH0sIHtcbiAgICBrZXk6ICdfYmluZEV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJHNjb3BlLm9uKCdjbGljay5iYy10YWJzJywgdGhpcy5vcHRpb25zLnRhYlRvZ2dsZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBoYXNoID0gKDAsIF9qcXVlcnkyLmRlZmF1bHQpKGV2ZW50LnRhcmdldCkuYXR0cignaHJlZicpO1xuXG4gICAgICAgIF90aGlzMi5hY3RpdmF0ZVRhYihoYXNoKTtcblxuICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMudGFiSGlzdG9yeSkge1xuICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHt9LCBoYXNoLCBoYXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgaGFzaCwgaGFzaCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAoMCwgX2pxdWVyeTIuZGVmYXVsdCkod2luZG93KS5vbignaGFzaGNoYW5nZS5iYy10YWJzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuYWN0aXZhdGVUYWIod2luZG93LmxvY2F0aW9uLmhhc2gpO1xuICAgICAgfSk7XG5cbiAgICAgICgwLCBfanF1ZXJ5Mi5kZWZhdWx0KSh3aW5kb3cpLm9uKCdyZXNpemUuYmMtdGFicycsICgwLCBfanVzdERlYm91bmNlMi5kZWZhdWx0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5faW5pdCh0cnVlKTtcbiAgICAgIH0sIDMwMCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUYWJzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUYWJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBzZXRGdW5jdGlvbkxlbmd0aCA9IHJlcXVpcmUoJ3NldC1mdW5jdGlvbi1sZW5ndGgnKTtcblxudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ2VzLWRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ2luYWxGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdhIGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG5cdH1cblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRyZXR1cm4gc2V0RnVuY3Rpb25MZW5ndGgoXG5cdFx0ZnVuYyxcblx0XHQxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpLFxuXHRcdHRydWVcblx0KTtcbn07XG5cbnZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbn07XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0JGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdHlwZXMnKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gQ2FyZFR5cGVcblxuZnVuY3Rpb24gQ2FyZFR5cGUgKGRhdGEpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENhcmRUeXBlKSkgcmV0dXJuIG5ldyBDYXJkVHlwZShkYXRhKVxuICBPYmplY3QuYXNzaWduKHRoaXMsIGRhdGEpXG59XG5cbkNhcmRUeXBlLnByb3RvdHlwZS5kaWdpdHMgPSAxNlxuQ2FyZFR5cGUucHJvdG90eXBlLmN2Y0xlbmd0aCA9IDNcbkNhcmRUeXBlLnByb3RvdHlwZS5sdWhuID0gdHJ1ZVxuQ2FyZFR5cGUucHJvdG90eXBlLmdyb3VwUGF0dGVybiA9IC8oXFxkezEsNH0pKFxcZHsxLDR9KT8oXFxkezEsNH0pPyhcXGR7MSw0fSk/L1xuXG5DYXJkVHlwZS5wcm90b3R5cGUuZ3JvdXAgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiAobnVtYmVyLm1hdGNoKHRoaXMuZ3JvdXBQYXR0ZXJuKSB8fCBbXSlcbiAgICAuc2xpY2UoMSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG59XG5cbkNhcmRUeXBlLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKG51bWJlciwgZWFnZXIpIHtcbiAgcmV0dXJuIHRoaXNbZWFnZXIgPyAnZWFnZXJQYXR0ZXJuJyA6ICdwYXR0ZXJuJ10udGVzdChudW1iZXIpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGUoe1xuICBuYW1lOiAnQW1lcmljYW4gRXhwcmVzcycsXG4gIGRpZ2l0czogMTUsXG4gIHBhdHRlcm46IC9eM1s0N11cXGR7MTN9JC8sXG4gIGVhZ2VyUGF0dGVybjogL14zWzQ3XS8sXG4gIGdyb3VwUGF0dGVybjogLyhcXGR7MSw0fSkoXFxkezEsNn0pPyhcXGR7MSw1fSk/LyxcbiAgY3ZjTGVuZ3RoOiA0XG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlKHtcbiAgbmFtZTogJ0RhbmtvcnQnLFxuICBwYXR0ZXJuOiAvXjUwMTlcXGR7MTJ9JC8sXG4gIGVhZ2VyUGF0dGVybjogL141MDE5L1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdEaW5lcnMgQ2x1YicsXG4gIGRpZ2l0czogWzE0LCAxOV0sXG4gIHBhdHRlcm46IC9eMygwWzAtNV18WzY4XVxcZClcXGR7MTEsMTZ9JC8sXG4gIGVhZ2VyUGF0dGVybjogL14zKDB8WzY4XSkvLFxuICBncm91cFBhdHRlcm46IC8oXFxkezEsNH0pPyhcXGR7MSw2fSk/KFxcZHsxLDl9KT8vXG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlKHtcbiAgbmFtZTogJ0Rpc2NvdmVyJyxcbiAgcGF0dGVybjogL142KDAxMSgwWzAtOV18WzItNF1cXGR8NzR8N1s3LTldfDhbNi05XXw5WzAtOV0pfDRbNC05XVxcZHszfXw1XFxkezR9KVxcZHsxMH0kLyxcbiAgZWFnZXJQYXR0ZXJuOiAvXjYoMDExKDBbMC05XXxbMi00XXw3NHw3WzctOV18OFs2LTldfDlbMC05XSl8NFs0LTldfDUpL1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdFbG8nLFxuICBwYXR0ZXJuOiAvXig0WzAzNV18NVswXXw2WzIzNV0pKDZbNzI2M118OVs5MF18MVsyNDE2XXw3WzczNl18OFs5XXwwWzA0NTc5XXw1WzBdKShbMC05XSkoWzAtOV0pXFxkezEwfSQvLFxuICBlYWdlclBhdHRlcm46IC9eKDRbMDM1XXw1WzBdfDZbMjM1XSkoNls3MjYzXXw5WzkwXXwxWzI0MTZdfDdbNzM2XXw4WzldfDBbMDQ1NzldfDVbMF0pKFswLTldKShbMC05XSkvLFxuICBncm91cFBhdHRlcm46IC8oXFxkezEsNH0pKFxcZHsxLDR9KT8oXFxkezEsNH0pPyhcXGR7MSw0fSk/KFxcZHsxLDN9KT8vXG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlKHtcbiAgbmFtZTogJ0ZvcmJydWdzZm9yZW5pbmdlbicsXG4gIHBhdHRlcm46IC9eNjAwNzIyXFxkezEwfSQvLFxuICBlYWdlclBhdHRlcm46IC9eNjAwL1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi92aXNhJyksXG4gIHJlcXVpcmUoJy4vbWFlc3RybycpLFxuICByZXF1aXJlKCcuL2ZvcmJydWdzZm9yZW5pbmdlbicpLFxuICByZXF1aXJlKCcuL2RhbmtvcnQnKSxcbiAgcmVxdWlyZSgnLi9tYXN0ZXJjYXJkJyksXG4gIHJlcXVpcmUoJy4vYW1lcmljYW4tZXhwcmVzcycpLFxuICByZXF1aXJlKCcuL2RpbmVycy1jbHViJyksXG4gIHJlcXVpcmUoJy4vZGlzY292ZXInKSxcbiAgcmVxdWlyZSgnLi9qY2InKSxcbiAgcmVxdWlyZSgnLi91bmlvbnBheScpLFxuICByZXF1aXJlKCcuL3Ryb3knKSxcbiAgcmVxdWlyZSgnLi9lbG8nKSxcbiAgcmVxdWlyZSgnLi91YXRwJylcbl1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdKQ0InLFxuICBwYXR0ZXJuOiAvXjM1XFxkezE0fSQvLFxuICBlYWdlclBhdHRlcm46IC9eMzUvXG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlKHtcbiAgbmFtZTogJ01hZXN0cm8nLFxuICBkaWdpdHM6IFsxMiwgMTldLFxuICBwYXR0ZXJuOiAvXig/OjVbMDY3ODldXFxkXFxkfCg/ITYwMTFbMDIzNF0pKD8hNjAxMTdbNDc4OV0pKD8hNjAxMThbNjc4OV0pKD8hNjAxMTkpKD8hNjRbNDU2Nzg5XSkoPyE2NSk2XFxkezN9KVxcZHs4LDE1fSQvLFxuICBlYWdlclBhdHRlcm46IC9eKDUoMDE4fDBbMjNdfFs2OF0pfDZbMzddfDYwMTExfDYwMTE1fDYwMTE3KFs1Nl18N1s1Nl0pfDYwMTE4WzAtNV18NjRbMC0zXXw2NikvLFxuICBncm91cFBhdHRlcm46IC8oXFxkezEsNH0pKFxcZHsxLDR9KT8oXFxkezEsNH0pPyhcXGR7MSw0fSk/KFxcZHsxLDN9KT8vXG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlKHtcbiAgbmFtZTogJ01hc3RlcmNhcmQnLFxuICBwYXR0ZXJuOiAvXig1WzEtNV1bMC05XXsyfXwyMjJbMS05XXwyMlszLTldWzAtOV18MlszLTZdWzAtOV17Mn18MjdbMDFdWzAtOV18MjcyMClcXGR7MTJ9JC8sXG4gIGVhZ2VyUGF0dGVybjogL14oMlszLTddfDIyWzItOV18NVsxLTVdKS9cbn0pXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGUoe1xuICBuYW1lOiAnVHJveScsXG4gIHBhdHRlcm46IC9eOTc5MlxcZHsxMn0kLyxcbiAgZWFnZXJQYXR0ZXJuOiAvXjk3OTIvXG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlKHtcbiAgbmFtZTogJ1VBVFAnLFxuICBkaWdpdHM6IDE1LFxuICBwYXR0ZXJuOiAvXjFcXGR7MTR9JC8sXG4gIGVhZ2VyUGF0dGVybjogL14xLyxcbiAgZ3JvdXBQYXR0ZXJuOiAvKFxcZHsxLDR9KShcXGR7MSw1fSk/KFxcZHsxLDZ9KT8vXG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlKHtcbiAgbmFtZTogJ1VuaW9uUGF5JyxcbiAgcGF0dGVybjogL142MlswLTVdXFxkezEzLDE2fSQvLFxuICBlYWdlclBhdHRlcm46IC9eNjIvLFxuICBncm91cFBhdHRlcm46IC8oXFxkezEsNH0pKFxcZHsxLDR9KT8oXFxkezEsNH0pPyhcXGR7MSw0fSk/KFxcZHsxLDN9KT8vLFxuICBsdWhuOiBmYWxzZVxufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZSh7XG4gIG5hbWU6ICdWaXNhJyxcbiAgZGlnaXRzOiBbMTMsIDE5XSxcbiAgcGF0dGVybjogL140XFxkezEyfShcXGR7M318XFxkezZ9KT8kLyxcbiAgZWFnZXJQYXR0ZXJuOiAvXjQvLFxuICBncm91cFBhdHRlcm46IC8oXFxkezEsNH0pKFxcZHsxLDR9KT8oXFxkezEsNH0pPyhcXGR7MSw0fSk/KFxcZHsxLDN9KT8vXG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGx1aG4gPSByZXF1aXJlKCdmYXN0LWx1aG4nKVxuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJylcblxubW9kdWxlLmV4cG9ydHMgPSBDYXJkXG5cbmZ1bmN0aW9uIENhcmQgKGRhdGEpIHtcbiAgY29uc3QgdHlwZXMgPSBUeXBlcyhkYXRhKVxuXG4gIHJldHVybiB7XG4gICAgdHlwZXM6IGRhdGEsXG4gICAgcGFyc2U6IHBhcnNlQ2FyZCxcbiAgICBmb3JtYXQ6IGZvcm1hdENhcmQsXG4gICAgdHlwZTogY2FyZFR5cGUsXG4gICAgbHVobjogbHVobixcbiAgICBpc1ZhbGlkOiBpc0NhcmRWYWxpZFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDYXJkIChudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciAhPT0gJ3N0cmluZycpIHJldHVybiAnJ1xuICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvW15cXGRdL2csICcnKVxuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Q2FyZCAobnVtYmVyLCBzZXBhcmF0b3IpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZShudW1iZXIsIHRydWUpXG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVtYmVyXG4gICAgcmV0dXJuIHR5cGUuZ3JvdXAobnVtYmVyKS5qb2luKHNlcGFyYXRvciB8fCAnICcpXG4gIH1cblxuICBmdW5jdGlvbiBjYXJkVHlwZSAobnVtYmVyLCBlYWdlcikge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKG51bWJlciwgZWFnZXIpXG4gICAgcmV0dXJuIHR5cGUgPyB0eXBlLm5hbWUgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2FyZFZhbGlkIChudW1iZXIsIHR5cGUpIHtcbiAgICBpZiAodHlwZSkge1xuICAgICAgdHlwZSA9IHR5cGVzLmdldCh0eXBlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gZ2V0VHlwZShudW1iZXIpXG4gICAgfVxuICAgIGlmICghdHlwZSkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuICghdHlwZS5sdWhuIHx8IGx1aG4obnVtYmVyKSkgJiYgdHlwZS50ZXN0KG51bWJlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFR5cGUgKG51bWJlciwgZWFnZXIpIHtcbiAgICByZXR1cm4gdHlwZXMuZmluZChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIHR5cGUudGVzdChudW1iZXIsIGVhZ2VyKVxuICAgIH0pXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKVxuY29uc3QgY3ZjUmVnZXggPSAvXlxcZHszLDR9JC9cblxubW9kdWxlLmV4cG9ydHMgPSBDdmNcblxuZnVuY3Rpb24gQ3ZjIChkYXRhKSB7XG4gIGNvbnN0IHR5cGVzID0gVHlwZXMoZGF0YSlcblxuICByZXR1cm4ge1xuICAgIGlzVmFsaWQ6IGN2Y0lzVmFsaWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGN2Y0lzVmFsaWQgKGN2YywgdHlwZSkge1xuICAgIGlmICh0eXBlb2YgY3ZjICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlXG4gICAgaWYgKCFjdmNSZWdleC50ZXN0KGN2YykpIHJldHVybiBmYWxzZVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZXMuc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZS5jdmNMZW5ndGggPT09IGN2Yy5sZW5ndGhcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVzLmdldCh0eXBlKS5jdmNMZW5ndGggPT09IGN2Yy5sZW5ndGhcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGlzVmFsaWRNb250aCA9IHJlcXVpcmUoJ2lzLXZhbGlkLW1vbnRoJylcbmNvbnN0IHBhcnNlSW50U3RyaWN0ID0gcmVxdWlyZSgncGFyc2UtaW50JylcbmNvbnN0IHBhcnNlWWVhciA9IHJlcXVpcmUoJ3BhcnNlLXllYXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNQYXN0OiBpc1Bhc3QsXG4gIG1vbnRoOiB7XG4gICAgcGFyc2U6IHBhcnNlTW9udGgsXG4gICAgaXNWYWxpZDogaXNWYWxpZE1vbnRoXG4gIH0sXG4gIHllYXI6IHtcbiAgICBwYXJzZTogcGFyc2VZZWFyLFxuICAgIGZvcm1hdDogZm9ybWF0RXhwWWVhcixcbiAgICBpc1ZhbGlkOiBpc0V4cFllYXJWYWxpZCxcbiAgICBpc1Bhc3Q6IGlzRXhwWWVhclBhc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1Bhc3QgKG1vbnRoLCB5ZWFyKSB7XG4gIHJldHVybiBEYXRlLm5vdygpID49IG5ldyBEYXRlKHllYXIsIG1vbnRoKVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vbnRoIChtb250aCkge1xuICByZXR1cm4gcGFyc2VJbnRTdHJpY3QobW9udGgpXG59XG5cbmZ1bmN0aW9uIGZvcm1hdEV4cFllYXIgKHllYXIsIHN0cmlwKSB7XG4gIHllYXIgPSB5ZWFyLnRvU3RyaW5nKClcbiAgcmV0dXJuIHN0cmlwID8geWVhci5zdWJzdHIoMiwgNCkgOiB5ZWFyXG59XG5cbmZ1bmN0aW9uIGlzRXhwWWVhclZhbGlkICh5ZWFyKSB7XG4gIGlmICh0eXBlb2YgeWVhciAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZVxuICB5ZWFyID0gcGFyc2VJbnRTdHJpY3QoeWVhcilcbiAgcmV0dXJuIHllYXIgPiAwXG59XG5cbmZ1bmN0aW9uIGlzRXhwWWVhclBhc3QgKHllYXIpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSA+IHllYXJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJ2NyZWRpdGNhcmRzLXR5cGVzJylcbmNvbnN0IENhcmQgPSByZXF1aXJlKCcuL2NhcmQnKVxuY29uc3QgQ3ZjID0gcmVxdWlyZSgnLi9jdmMnKVxuY29uc3QgZXhwaXJhdGlvbiA9IHJlcXVpcmUoJy4vZXhwaXJhdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aFR5cGVzKHR5cGVzKVxubW9kdWxlLmV4cG9ydHMud2l0aFR5cGVzID0gd2l0aFR5cGVzXG5cbmZ1bmN0aW9uIHdpdGhUeXBlcyAodHlwZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBjYXJkOiBDYXJkKHR5cGVzKSxcbiAgICBjdmM6IEN2Yyh0eXBlcyksXG4gICAgZXhwaXJhdGlvbjogZXhwaXJhdGlvblxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGVmYXVsdHMgPSByZXF1aXJlKCdjcmVkaXRjYXJkcy10eXBlcycpXG5cbm1vZHVsZS5leHBvcnRzID0gQ2FyZFR5cGVzXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzXG5cbmZ1bmN0aW9uIENhcmRUeXBlcyAodHlwZXMpIHtcbiAgY29uc3QgbWFwID0gdHlwZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHR5cGUpIHtcbiAgICBhY2NbdHlwZS5uYW1lXSA9IHR5cGVcbiAgICByZXR1cm4gYWNjXG4gIH0sIHt9KVxuXG4gIHJldHVybiB7XG4gICAgZmluZDogdHlwZXMuZmluZC5iaW5kKHR5cGVzKSxcbiAgICBzb21lOiB0eXBlcy5zb21lLmJpbmQodHlwZXMpLFxuICAgIGdldDogZ2V0XG4gIH1cblxuICBmdW5jdGlvbiBnZXQgKG5hbWUpIHtcbiAgICBjb25zdCB0eXBlID0gbWFwW25hbWVdXG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdHlwZSBmb3VuZCBmb3IgbmFtZTogJyArIG5hbWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnZXMtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnZhciAkU3ludGF4RXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvc3ludGF4Jyk7XG52YXIgJFR5cGVFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy90eXBlJyk7XG5cbnZhciBnb3BkID0gcmVxdWlyZSgnZ29wZCcpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVEYXRhUHJvcGVydHkoXG5cdG9iaixcblx0cHJvcGVydHksXG5cdHZhbHVlXG4pIHtcblx0aWYgKCFvYmogfHwgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BvYmpgIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25gJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnc3ltYm9sJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgcHJvcGVydHlgIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBzeW1ib2xgJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHR5cGVvZiBhcmd1bWVudHNbM10gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbM10gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkVudW1lcmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCAmJiB0eXBlb2YgYXJndW1lbnRzWzRdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzRdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Xcml0YWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIHR5cGVvZiBhcmd1bWVudHNbNV0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNV0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkNvbmZpZ3VyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIHR5cGVvZiBhcmd1bWVudHNbNl0gIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbG9vc2VgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBub25FbnVtZXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXHR2YXIgbm9uV3JpdGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG5cdHZhciBub25Db25maWd1cmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XG5cblx0LyogQHR5cGUge2ZhbHNlIHwgVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8dW5rbm93bj59ICovXG5cdHZhciBkZXNjID0gISFnb3BkICYmIGdvcGQob2JqLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IG5vbkNvbmZpZ3VyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5jb25maWd1cmFibGUgOiAhbm9uQ29uZmlndXJhYmxlLFxuXHRcdFx0ZW51bWVyYWJsZTogbm9uRW51bWVyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5lbnVtZXJhYmxlIDogIW5vbkVudW1lcmFibGUsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogbm9uV3JpdGFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2Mud3JpdGFibGUgOiAhbm9uV3JpdGFibGVcblx0XHR9KTtcblx0fSBlbHNlIGlmIChsb29zZSB8fCAoIW5vbkVudW1lcmFibGUgJiYgIW5vbldyaXRhYmxlICYmICFub25Db25maWd1cmFibGUpKSB7XG5cdFx0Ly8gbXVzdCBmYWxsIGJhY2sgdG8gW1tTZXRdXSwgYW5kIHdhcyBub3QgZXhwbGljaXRseSBhc2tlZCB0byBtYWtlIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1jb25maWd1cmFibGVcblx0XHRvYmpbcHJvcGVydHldID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgZGVmaW5pbmcgYSBwcm9wZXJ0eSBhcyBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1lbnVtZXJhYmxlLicpO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKSB8fCBmYWxzZTtcbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZGVmaW5lUHJvcGVydHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2V2YWwnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRXZhbEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vcmFuZ2UnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vcmVmJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmVyZW5jZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9zeW50YXgnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gU3ludGF4RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gVHlwZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi91cmknKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gVVJJRXJyb3I7XG4iLCIvKipcbiAqIEV2RW1pdHRlciB2Mi4xLjFcbiAqIExpbCcgZXZlbnQgZW1pdHRlclxuICogTUlUIExpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZ2xvYmFsLkV2RW1pdHRlciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oKSB7XG5cbmZ1bmN0aW9uIEV2RW1pdHRlcigpIHt9XG5cbmxldCBwcm90byA9IEV2RW1pdHRlci5wcm90b3R5cGU7XG5cbnByb3RvLm9uID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKSB7XG4gIGlmICggIWV2ZW50TmFtZSB8fCAhbGlzdGVuZXIgKSByZXR1cm4gdGhpcztcblxuICAvLyBzZXQgZXZlbnRzIGhhc2hcbiAgbGV0IGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IGxpc3RlbmVycyBhcnJheVxuICBsZXQgbGlzdGVuZXJzID0gZXZlbnRzWyBldmVudE5hbWUgXSA9IGV2ZW50c1sgZXZlbnROYW1lIF0gfHwgW107XG4gIC8vIG9ubHkgYWRkIG9uY2VcbiAgaWYgKCAhbGlzdGVuZXJzLmluY2x1ZGVzKCBsaXN0ZW5lciApICkge1xuICAgIGxpc3RlbmVycy5wdXNoKCBsaXN0ZW5lciApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5vbmNlID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKSB7XG4gIGlmICggIWV2ZW50TmFtZSB8fCAhbGlzdGVuZXIgKSByZXR1cm4gdGhpcztcblxuICAvLyBhZGQgZXZlbnRcbiAgdGhpcy5vbiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAvLyBzZXQgb25jZSBmbGFnXG4gIC8vIHNldCBvbmNlRXZlbnRzIGhhc2hcbiAgbGV0IG9uY2VFdmVudHMgPSB0aGlzLl9vbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IG9uY2VMaXN0ZW5lcnMgb2JqZWN0XG4gIGxldCBvbmNlTGlzdGVuZXJzID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gPSBvbmNlRXZlbnRzWyBldmVudE5hbWUgXSB8fCB7fTtcbiAgLy8gc2V0IGZsYWdcbiAgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5vZmYgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbIGV2ZW50TmFtZSBdO1xuICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSByZXR1cm4gdGhpcztcblxuICBsZXQgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgaWYgKCBpbmRleCAhPSAtMSApIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBhcmdzICkge1xuICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1sgZXZlbnROYW1lIF07XG4gIGlmICggIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aCApIHJldHVybiB0aGlzO1xuXG4gIC8vIGNvcHkgb3ZlciB0byBhdm9pZCBpbnRlcmZlcmVuY2UgaWYgLm9mZigpIGluIGxpc3RlbmVyXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSggMCApO1xuICBhcmdzID0gYXJncyB8fCBbXTtcbiAgLy8gb25jZSBzdHVmZlxuICBsZXQgb25jZUxpc3RlbmVycyA9IHRoaXMuX29uY2VFdmVudHMgJiYgdGhpcy5fb25jZUV2ZW50c1sgZXZlbnROYW1lIF07XG5cbiAgZm9yICggbGV0IGxpc3RlbmVyIG9mIGxpc3RlbmVycyApIHtcbiAgICBsZXQgaXNPbmNlID0gb25jZUxpc3RlbmVycyAmJiBvbmNlTGlzdGVuZXJzWyBsaXN0ZW5lciBdO1xuICAgIGlmICggaXNPbmNlICkge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAvLyByZW1vdmUgYmVmb3JlIHRyaWdnZXIgdG8gcHJldmVudCByZWN1cnNpb25cbiAgICAgIHRoaXMub2ZmKCBldmVudE5hbWUsIGxpc3RlbmVyICk7XG4gICAgICAvLyB1bnNldCBvbmNlIGZsYWdcbiAgICAgIGRlbGV0ZSBvbmNlTGlzdGVuZXJzWyBsaXN0ZW5lciBdO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIGxpc3RlbmVyXG4gICAgbGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3MgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uYWxsT2ZmID0gZnVuY3Rpb24oKSB7XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gIGRlbGV0ZSB0aGlzLl9vbmNlRXZlbnRzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnJldHVybiBFdkVtaXR0ZXI7XG5cbn0gKSApO1xuIiwiLyohXG4gKiBFdmVudEVtaXR0ZXIyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaGlqMW54L0V2ZW50RW1pdHRlcjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgaGlqMW54XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbjshZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eT0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5IDogZnVuY3Rpb24gX2lzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH07XG4gIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG4gIHZhciBuZXh0VGlja1N1cHBvcnRlZD0gdHlwZW9mIHByb2Nlc3M9PSdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrPT0nZnVuY3Rpb24nO1xuICB2YXIgc3ltYm9sc1N1cHBvcnRlZD0gdHlwZW9mIFN5bWJvbD09PSdmdW5jdGlvbic7XG4gIHZhciByZWZsZWN0U3VwcG9ydGVkPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCc7XG4gIHZhciBzZXRJbW1lZGlhdGVTdXBwb3J0ZWQ9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbic7XG4gIHZhciBfc2V0SW1tZWRpYXRlPSBzZXRJbW1lZGlhdGVTdXBwb3J0ZWQgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0O1xuICB2YXIgb3duS2V5cz0gc3ltYm9sc1N1cHBvcnRlZD8gKHJlZmxlY3RTdXBwb3J0ZWQgJiYgdHlwZW9mIFJlZmxlY3Qub3duS2V5cz09PSdmdW5jdGlvbic/IFJlZmxlY3Qub3duS2V5cyA6IGZ1bmN0aW9uKG9iail7XG4gICAgdmFyIGFycj0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTtcbiAgICBhcnIucHVzaC5hcHBseShhcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG4gICAgcmV0dXJuIGFycjtcbiAgfSkgOiBPYmplY3Qua2V5cztcblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGlmICh0aGlzLl9jb25mKSB7XG4gICAgICBjb25maWd1cmUuY2FsbCh0aGlzLCB0aGlzLl9jb25mKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25maWd1cmUoY29uZikge1xuICAgIGlmIChjb25mKSB7XG4gICAgICB0aGlzLl9jb25mID0gY29uZjtcblxuICAgICAgY29uZi5kZWxpbWl0ZXIgJiYgKHRoaXMuZGVsaW1pdGVyID0gY29uZi5kZWxpbWl0ZXIpO1xuXG4gICAgICBpZihjb25mLm1heExpc3RlbmVycyE9PXVuZGVmaW5lZCl7XG4gICAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzPSBjb25mLm1heExpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgY29uZi53aWxkY2FyZCAmJiAodGhpcy53aWxkY2FyZCA9IGNvbmYud2lsZGNhcmQpO1xuICAgICAgY29uZi5uZXdMaXN0ZW5lciAmJiAodGhpcy5fbmV3TGlzdGVuZXIgPSBjb25mLm5ld0xpc3RlbmVyKTtcbiAgICAgIGNvbmYucmVtb3ZlTGlzdGVuZXIgJiYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyID0gY29uZi5yZW1vdmVMaXN0ZW5lcik7XG4gICAgICBjb25mLnZlcmJvc2VNZW1vcnlMZWFrICYmICh0aGlzLnZlcmJvc2VNZW1vcnlMZWFrID0gY29uZi52ZXJib3NlTWVtb3J5TGVhayk7XG4gICAgICBjb25mLmlnbm9yZUVycm9ycyAmJiAodGhpcy5pZ25vcmVFcnJvcnMgPSBjb25mLmlnbm9yZUVycm9ycyk7XG5cbiAgICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJUcmVlID0ge307XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9nUG9zc2libGVNZW1vcnlMZWFrKGNvdW50LCBldmVudE5hbWUpIHtcbiAgICB2YXIgZXJyb3JNc2cgPSAnKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICdsZWFrIGRldGVjdGVkLiAnICsgY291bnQgKyAnIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nO1xuXG4gICAgaWYodGhpcy52ZXJib3NlTWVtb3J5TGVhayl7XG4gICAgICBlcnJvck1zZyArPSAnIEV2ZW50IG5hbWU6ICcgKyBldmVudE5hbWUgKyAnLic7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW1pdFdhcm5pbmcpe1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgZS5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICBlLmVtaXR0ZXIgPSB0aGlzO1xuICAgICAgZS5jb3VudCA9IGNvdW50O1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvck1zZyk7XG5cbiAgICAgIGlmIChjb25zb2xlLnRyYWNlKXtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB0b0FycmF5ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIFthXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIFthLCBiXTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICBhcnJbbl0gPSBhcmd1bWVudHNbbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9PYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBrZXk7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXNDb3VudCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBvYmpba2V5XSA9IGkgPCB2YWx1ZXNDb3VudCA/IHZhbHVlc1tpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIFRhcmdldE9ic2VydmVyKGVtaXR0ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9saXN0ZW5lcnNDb3VudCA9IDA7XG5cbiAgICB2YXIgb24sIG9mZjtcblxuICAgIGlmIChvcHRpb25zLm9uIHx8IG9wdGlvbnMub2ZmKSB7XG4gICAgICBvbiA9IG9wdGlvbnMub247XG4gICAgICBvZmYgPSBvcHRpb25zLm9mZjtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIG9uID0gdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICBvZmYgPSB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hZGRMaXN0ZW5lcikge1xuICAgICAgb24gPSB0YXJnZXQuYWRkTGlzdGVuZXI7XG4gICAgICBvZmYgPSB0YXJnZXQucmVtb3ZlTGlzdGVuZXI7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQub24pIHtcbiAgICAgIG9uID0gdGFyZ2V0Lm9uO1xuICAgICAgb2ZmID0gdGFyZ2V0Lm9mZjtcbiAgICB9XG5cbiAgICBpZiAoIW9uICYmICFvZmYpIHtcbiAgICAgIHRocm93IEVycm9yKCd0YXJnZXQgZG9lcyBub3QgaW1wbGVtZW50IGFueSBrbm93biBldmVudCBBUEknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ29uIG1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9mZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdvZmYgbWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHRoaXMuX29uID0gb247XG4gICAgdGhpcy5fb2ZmID0gb2ZmO1xuXG4gICAgdmFyIF9vYnNlcnZlcnM9IGVtaXR0ZXIuX29ic2VydmVycztcbiAgICBpZihfb2JzZXJ2ZXJzKXtcbiAgICAgIF9vYnNlcnZlcnMucHVzaCh0aGlzKTtcbiAgICB9ZWxzZXtcbiAgICAgIGVtaXR0ZXIuX29ic2VydmVycz0gW3RoaXNdO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oVGFyZ2V0T2JzZXJ2ZXIucHJvdG90eXBlLCB7XG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbihldmVudCwgbG9jYWxFdmVudCwgcmVkdWNlcil7XG4gICAgICB2YXIgb2JzZXJ2ZXI9IHRoaXM7XG4gICAgICB2YXIgdGFyZ2V0PSB0aGlzLl90YXJnZXQ7XG4gICAgICB2YXIgZW1pdHRlcj0gdGhpcy5fZW1pdHRlcjtcbiAgICAgIHZhciBsaXN0ZW5lcnM9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgIHZhciBoYW5kbGVyPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYXJncz0gdG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgZXZlbnRPYmo9IHtcbiAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgIG5hbWU6IGxvY2FsRXZlbnQsXG4gICAgICAgICAgb3JpZ2luYWw6IGV2ZW50XG4gICAgICAgIH07XG4gICAgICAgIGlmKHJlZHVjZXIpe1xuICAgICAgICAgIHZhciByZXN1bHQ9IHJlZHVjZXIuY2FsbCh0YXJnZXQsIGV2ZW50T2JqKTtcbiAgICAgICAgICBpZihyZXN1bHQhPT1mYWxzZSl7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQuYXBwbHkoZW1pdHRlciwgW2V2ZW50T2JqLm5hbWVdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVtaXR0ZXIuZW1pdC5hcHBseShlbWl0dGVyLCBbbG9jYWxFdmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH07XG5cblxuICAgICAgaWYobGlzdGVuZXJzW2V2ZW50XSl7XG4gICAgICAgIHRocm93IEVycm9yKCdFdmVudCBcXCcnICsgZXZlbnQgKyAnXFwnIGlzIGFscmVhZHkgbGlzdGVuaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc0NvdW50Kys7XG5cbiAgICAgIGlmKGVtaXR0ZXIuX25ld0xpc3RlbmVyICYmIGVtaXR0ZXIuX3JlbW92ZUxpc3RlbmVyICYmICFvYnNlcnZlci5fb25OZXdMaXN0ZW5lcil7XG5cbiAgICAgICAgdGhpcy5fb25OZXdMaXN0ZW5lciA9IGZ1bmN0aW9uIChfZXZlbnQpIHtcbiAgICAgICAgICBpZiAoX2V2ZW50ID09PSBsb2NhbEV2ZW50ICYmIGxpc3RlbmVyc1tldmVudF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuX29uLmNhbGwodGFyZ2V0LCBldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGVtaXR0ZXIub24oJ25ld0xpc3RlbmVyJywgdGhpcy5fb25OZXdMaXN0ZW5lcik7XG5cbiAgICAgICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcj0gZnVuY3Rpb24oX2V2ZW50KXtcbiAgICAgICAgICBpZihfZXZlbnQgPT09IGxvY2FsRXZlbnQgJiYgIWVtaXR0ZXIuaGFzTGlzdGVuZXJzKF9ldmVudCkgJiYgbGlzdGVuZXJzW2V2ZW50XSl7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdPSBudWxsO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuX29mZi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdPSBudWxsO1xuXG4gICAgICAgIGVtaXR0ZXIub24oJ3JlbW92ZUxpc3RlbmVyJywgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XT0gaGFuZGxlcjtcbiAgICAgICAgb2JzZXJ2ZXIuX29uLmNhbGwodGFyZ2V0LCBldmVudCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbihldmVudCl7XG4gICAgICB2YXIgb2JzZXJ2ZXI9IHRoaXM7XG4gICAgICB2YXIgbGlzdGVuZXJzPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICB2YXIgZW1pdHRlcj0gdGhpcy5fZW1pdHRlcjtcbiAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgdmFyIGV2ZW50cztcbiAgICAgIHZhciBvZmY9IHRoaXMuX29mZjtcbiAgICAgIHZhciB0YXJnZXQ9IHRoaXMuX3RhcmdldDtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZihldmVudCAmJiB0eXBlb2YgZXZlbnQhPT0nc3RyaW5nJyl7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZXZlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhclJlZnMoKXtcbiAgICAgICAgaWYob2JzZXJ2ZXIuX29uTmV3TGlzdGVuZXIpe1xuICAgICAgICAgIGVtaXR0ZXIub2ZmKCduZXdMaXN0ZW5lcicsIG9ic2VydmVyLl9vbk5ld0xpc3RlbmVyKTtcbiAgICAgICAgICBlbWl0dGVyLm9mZigncmVtb3ZlTGlzdGVuZXInLCBvYnNlcnZlci5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgb2JzZXJ2ZXIuX29uTmV3TGlzdGVuZXI9IG51bGw7XG4gICAgICAgICAgb2JzZXJ2ZXIuX29uUmVtb3ZlTGlzdGVuZXI9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4PSBmaW5kVGFyZ2V0SW5kZXguY2FsbChlbWl0dGVyLCBvYnNlcnZlcik7XG4gICAgICAgIGVtaXR0ZXIuX29ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZihldmVudCl7XG4gICAgICAgIGhhbmRsZXI9IGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIGlmKCFoYW5kbGVyKSByZXR1cm47XG4gICAgICAgIG9mZi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgaWYoIS0tdGhpcy5fbGlzdGVuZXJzQ291bnQpe1xuICAgICAgICAgIGNsZWFyUmVmcygpO1xuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgZXZlbnRzPSBvd25LZXlzKGxpc3RlbmVycyk7XG4gICAgICAgIGk9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGktLT4wKXtcbiAgICAgICAgICBldmVudD0gZXZlbnRzW2ldO1xuICAgICAgICAgIG9mZi5jYWxsKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycz0ge307XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc0NvdW50PSAwO1xuICAgICAgICBjbGVhclJlZnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgcmVkdWNlcnMsIGFsbG93VW5rbm93bikge1xuICAgIHZhciBjb21wdXRlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEpO1xuXG4gICAgaWYgKCFvcHRpb25zKSByZXR1cm4gY29tcHV0ZWRPcHRpb25zO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgb3B0aW9uLCB2YWx1ZTtcbiAgICB2YXIgcmVkdWNlcjtcblxuICAgIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFwiJyArIG9wdGlvbiArICdcIiBvcHRpb24gdmFsdWUnICsgKHJlYXNvbiA/ICcuIFJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSlcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBvcHRpb24gPSBrZXlzW2ldO1xuICAgICAgaWYgKCFhbGxvd1Vua25vd24gJiYgIWhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBvcHRpb24pKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIFwiJyArIG9wdGlvbiArICdcIiBvcHRpb24nKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVkdWNlciA9IHJlZHVjZXJzW29wdGlvbl07XG4gICAgICAgIGNvbXB1dGVkT3B0aW9uc1tvcHRpb25dID0gcmVkdWNlciA/IHJlZHVjZXIodmFsdWUsIHJlamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXB1dGVkT3B0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdG9yUmVkdWNlcih2YWx1ZSwgcmVqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCAhdmFsdWUuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpKSB7XG4gICAgICByZWplY3QoJ3ZhbHVlIG11c3QgYmUgYSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlVHlwZVJlZHVjZXIodHlwZXMpIHtcbiAgICB2YXIgbWVzc2FnZT0gJ3ZhbHVlIG11c3QgYmUgdHlwZSBvZiAnICsgdHlwZXMuam9pbignfCcpO1xuICAgIHZhciBsZW49IHR5cGVzLmxlbmd0aDtcbiAgICB2YXIgZmlyc3RUeXBlPSB0eXBlc1swXTtcbiAgICB2YXIgc2Vjb25kVHlwZT0gdHlwZXNbMV07XG5cbiAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJlamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09IGZpcnN0VHlwZSkge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJlamVjdCkge1xuICAgICAgICB2YXIga2luZD0gdHlwZW9mIHY7XG4gICAgICAgIGlmIChraW5kID09PSBmaXJzdFR5cGUgfHwga2luZCA9PT0gc2Vjb25kVHlwZSkgcmV0dXJuIHY7XG4gICAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJlamVjdCkge1xuICAgICAgdmFyIGtpbmQgPSB0eXBlb2YgdjtcbiAgICAgIHZhciBpID0gbGVuO1xuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IHR5cGVzW2ldKSByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZnVuY3Rpb25SZWR1Y2VyPSBtYWtlVHlwZVJlZHVjZXIoWydmdW5jdGlvbiddKTtcblxuICB2YXIgb2JqZWN0RnVuY3Rpb25SZWR1Y2VyPSBtYWtlVHlwZVJlZHVjZXIoWydvYmplY3QnLCAnZnVuY3Rpb24nXSk7XG5cbiAgZnVuY3Rpb24gbWFrZUNhbmNlbGFibGVQcm9taXNlKFByb21pc2UsIGV4ZWN1dG9yLCBvcHRpb25zKSB7XG4gICAgdmFyIGlzQ2FuY2VsYWJsZTtcbiAgICB2YXIgY2FsbGJhY2tzO1xuICAgIHZhciB0aW1lcj0gMDtcbiAgICB2YXIgc3Vic2NyaXB0aW9uQ2xvc2VkO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkge1xuICAgICAgb3B0aW9ucz0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICBvdmVybG9hZDogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgdGltZW91dDogZnVuY3Rpb24odmFsdWUsIHJlamVjdCl7XG4gICAgICAgICAgdmFsdWUqPSAxO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCAhTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVqZWN0KCd0aW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXNDYW5jZWxhYmxlID0gIW9wdGlvbnMub3ZlcmxvYWQgJiYgdHlwZW9mIFByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb25DYW5jZWwgPT09ICdmdW5jdGlvbic7XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICBjYWxsYmFja3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgdGltZXIgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfcmVzb2x2ZT0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIF9yZWplY3Q9IGZ1bmN0aW9uKGVycil7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoaXNDYW5jZWxhYmxlKSB7XG4gICAgICAgIGV4ZWN1dG9yKF9yZXNvbHZlLCBfcmVqZWN0LCBvbkNhbmNlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja3MgPSBbZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgICBfcmVqZWN0KHJlYXNvbiB8fCBFcnJvcignY2FuY2VsZWQnKSk7XG4gICAgICAgIH1dO1xuICAgICAgICBleGVjdXRvcihfcmVzb2x2ZSwgX3JlamVjdCwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1VuYWJsZSB0byBzdWJzY3JpYmUgb24gY2FuY2VsIGV2ZW50IGFzeW5jaHJvbm91c2x5JylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdvbkNhbmNlbCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Vic2NyaXB0aW9uQ2xvc2VkPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICB0aW1lcj0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciByZWFzb249IEVycm9yKCd0aW1lb3V0Jyk7XG4gICAgICAgICAgcmVhc29uLmNvZGUgPSAnRVRJTUVET1VUJ1xuICAgICAgICAgIHRpbWVyPSAwO1xuICAgICAgICAgIHByb21pc2UuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWlzQ2FuY2VsYWJsZSkge1xuICAgICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2FsbGJhY2tzW2ldKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZXJuYWwgY2FsbGJhY2sgdG8gcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgIGNhbGxiYWNrc1swXShyZWFzb24pO1xuICAgICAgICBjYWxsYmFja3MgPSBudWxsO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRUYXJnZXRJbmRleChvYnNlcnZlcikge1xuICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnM7XG4gICAgaWYoIW9ic2VydmVycyl7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChvYnNlcnZlcnNbaV0uX3RhcmdldCA9PT0gb2JzZXJ2ZXIpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBBdHRlbnRpb24sIGZ1bmN0aW9uIHJldHVybiB0eXBlIG5vdyBpcyBhcnJheSwgYWx3YXlzICFcbiAgLy8gSXQgaGFzIHplcm8gZWxlbWVudHMgaWYgbm8gYW55IG1hdGNoZXMgZm91bmQgYW5kIG9uZSBvciBtb3JlXG4gIC8vIGVsZW1lbnRzIChsZWFmcykgaWYgdGhlcmUgYXJlIG1hdGNoZXNcbiAgLy9cbiAgZnVuY3Rpb24gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlLCBpLCB0eXBlTGVuZ3RoKSB7XG4gICAgaWYgKCF0cmVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgdmFyIGtpbmQgPSB0eXBlb2YgdHlwZTtcbiAgICAgIGlmIChraW5kID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbnMsIG4sIGwgPSAwLCBqID0gMCwgZGVsaW1pdGVyID0gdGhpcy5kZWxpbWl0ZXIsIGRsID0gZGVsaW1pdGVyLmxlbmd0aDtcbiAgICAgICAgaWYgKChuID0gdHlwZS5pbmRleE9mKGRlbGltaXRlcikpICE9PSAtMSkge1xuICAgICAgICAgIG5zID0gbmV3IEFycmF5KDUpO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5zW2wrK10gPSB0eXBlLnNsaWNlKGosIG4pO1xuICAgICAgICAgICAgaiA9IG4gKyBkbDtcbiAgICAgICAgICB9IHdoaWxlICgobiA9IHR5cGUuaW5kZXhPZihkZWxpbWl0ZXIsIGopKSAhPT0gLTEpO1xuXG4gICAgICAgICAgbnNbbCsrXSA9IHR5cGUuc2xpY2Uoaik7XG4gICAgICAgICAgdHlwZSA9IG5zO1xuICAgICAgICAgIHR5cGVMZW5ndGggPSBsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICAgICAgdHlwZUxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdHlwZUxlbmd0aCA9IHR5cGUubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICAgICAgdHlwZUxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycz0gbnVsbCwgYnJhbmNoLCB4VHJlZSwgeHhUcmVlLCBpc29sYXRlZEJyYW5jaCwgZW5kUmVhY2hlZCwgY3VycmVudFR5cGUgPSB0eXBlW2ldLFxuICAgICAgICBuZXh0VHlwZSA9IHR5cGVbaSArIDFdLCBicmFuY2hlcywgX2xpc3RlbmVycztcblxuICAgIGlmIChpID09PSB0eXBlTGVuZ3RoKSB7XG4gICAgICAvL1xuICAgICAgLy8gSWYgYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQocykgbGlzdCBhbmQgdGhlIHRyZWUgaGFzIGxpc3RlbmVyc1xuICAgICAgLy8gaW52b2tlIHRob3NlIGxpc3RlbmVycy5cbiAgICAgIC8vXG5cbiAgICAgIGlmKHRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICBpZiAodHlwZW9mIHRyZWUuX2xpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGhhbmRsZXJzICYmIGhhbmRsZXJzLnB1c2godHJlZS5fbGlzdGVuZXJzKTtcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBbdHJlZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaC5hcHBseShoYW5kbGVycywgdHJlZS5fbGlzdGVuZXJzKTtcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBbdHJlZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAoY3VycmVudFR5cGUgPT09ICcqJykge1xuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgZXZlbnQgZW1pdHRlZCBpcyAnKicgYXQgdGhpcyBwYXJ0XG4gICAgICAgIC8vIG9yIHRoZXJlIGlzIGEgY29uY3JldGUgbWF0Y2ggYXQgdGhpcyBwYXRjaFxuICAgICAgICAvL1xuICAgICAgICBicmFuY2hlcyA9IG93bktleXModHJlZSk7XG4gICAgICAgIG4gPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgYnJhbmNoID0gYnJhbmNoZXNbbl07XG4gICAgICAgICAgaWYgKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnKSB7XG4gICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChfbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIF9saXN0ZW5lcnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IF9saXN0ZW5lcnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFR5cGUgPT09ICcqKicpIHtcbiAgICAgICAgZW5kUmVhY2hlZCA9IChpICsgMSA9PT0gdHlwZUxlbmd0aCB8fCAoaSArIDIgPT09IHR5cGVMZW5ndGggJiYgbmV4dFR5cGUgPT09ICcqJykpO1xuICAgICAgICBpZiAoZW5kUmVhY2hlZCAmJiB0cmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAvLyBUaGUgbmV4dCBlbGVtZW50IGhhcyBhIF9saXN0ZW5lcnMsIGFkZCBpdCB0byB0aGUgaGFuZGxlcnMuXG4gICAgICAgICAgbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyYW5jaGVzID0gb3duS2V5cyh0cmVlKTtcbiAgICAgICAgbiA9IGJyYW5jaGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICBicmFuY2ggPSBicmFuY2hlc1tuXTtcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycpIHtcbiAgICAgICAgICAgIGlmIChicmFuY2ggPT09ICcqJyB8fCBicmFuY2ggPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgaWYgKHRyZWVbYnJhbmNoXS5fbGlzdGVuZXJzICYmICFlbmRSZWFjaGVkKSB7XG4gICAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIF9saXN0ZW5lcnMpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gX2xpc3RlbmVycztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnJhbmNoID09PSBuZXh0VHlwZSkge1xuICAgICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkgKyAyLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vIG1hdGNoIG9uIHRoaXMgb25lLCBzaGlmdCBpbnRvIHRoZSB0cmVlIGJ1dCBub3QgaW4gdGhlIHR5cGUgYXJyYXkuXG4gICAgICAgICAgICAgIF9saXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBfbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBfbGlzdGVuZXJzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2UgaWYgKHRyZWVbY3VycmVudFR5cGVdKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVtjdXJyZW50VHlwZV0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAgIHhUcmVlID0gdHJlZVsnKiddO1xuICAgIGlmICh4VHJlZSkge1xuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBsaXN0ZW5lciB0cmVlIHdpbGwgYWxsb3cgYW55IG1hdGNoIGZvciB0aGlzIHBhcnQsXG4gICAgICAvLyB0aGVuIHJlY3Vyc2l2ZWx5IGV4cGxvcmUgYWxsIGJyYW5jaGVzIG9mIHRoZSB0cmVlXG4gICAgICAvL1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4VHJlZSwgaSArIDEsIHR5cGVMZW5ndGgpO1xuICAgIH1cblxuICAgIHh4VHJlZSA9IHRyZWVbJyoqJ107XG4gICAgaWYgKHh4VHJlZSkge1xuICAgICAgaWYgKGkgPCB0eXBlTGVuZ3RoKSB7XG4gICAgICAgIGlmICh4eFRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBsaXN0ZW5lciBvbiBhICcqKicsIGl0IHdpbGwgY2F0Y2ggYWxsLCBzbyBhZGQgaXRzIGhhbmRsZXIuXG4gICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWUsIHR5cGVMZW5ndGgsIHR5cGVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgYXJyYXlzIG9mIG1hdGNoaW5nIG5leHQgYnJhbmNoZXMgYW5kIG90aGVycy5cbiAgICAgICAgYnJhbmNoZXM9IG93bktleXMoeHhUcmVlKTtcbiAgICAgICAgbj0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZShuLS0+MCl7XG4gICAgICAgICAgYnJhbmNoPSBicmFuY2hlc1tuXTtcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycpIHtcbiAgICAgICAgICAgIGlmIChicmFuY2ggPT09IG5leHRUeXBlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIG5leHQgZWxlbWVudCB3aWxsIG1hdGNoLCBzbyBqdW1wIHR3aWNlLlxuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVticmFuY2hdLCBpICsgMiwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJyYW5jaCA9PT0gY3VycmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgLy8gQ3VycmVudCBub2RlIG1hdGNoZXMsIG1vdmUgaW50byB0aGUgdHJlZS5cbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbYnJhbmNoXSwgaSArIDEsIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNvbGF0ZWRCcmFuY2ggPSB7fTtcbiAgICAgICAgICAgICAgaXNvbGF0ZWRCcmFuY2hbYnJhbmNoXSA9IHh4VHJlZVticmFuY2hdO1xuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHsnKionOiBpc29sYXRlZEJyYW5jaH0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoeHhUcmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgYW5kIHN0aWxsIG9uIGEgJyoqJ1xuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHh4VHJlZVsnKiddICYmIHh4VHJlZVsnKiddLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbJyonXSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RlbmVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdyb3dMaXN0ZW5lclRyZWUodHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgICB2YXIgbGVuID0gMCwgaiA9IDAsIGksIGRlbGltaXRlciA9IHRoaXMuZGVsaW1pdGVyLCBkbD0gZGVsaW1pdGVyLmxlbmd0aCwgbnM7XG5cbiAgICBpZih0eXBlb2YgdHlwZT09PSdzdHJpbmcnKSB7XG4gICAgICBpZiAoKGkgPSB0eXBlLmluZGV4T2YoZGVsaW1pdGVyKSkgIT09IC0xKSB7XG4gICAgICAgIG5zID0gbmV3IEFycmF5KDUpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbnNbbGVuKytdID0gdHlwZS5zbGljZShqLCBpKTtcbiAgICAgICAgICBqID0gaSArIGRsO1xuICAgICAgICB9IHdoaWxlICgoaSA9IHR5cGUuaW5kZXhPZihkZWxpbWl0ZXIsIGopKSAhPT0gLTEpO1xuXG4gICAgICAgIG5zW2xlbisrXSA9IHR5cGUuc2xpY2Uoaik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbnM9IFt0eXBlXTtcbiAgICAgICAgbGVuPSAxO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgbnM9IHR5cGU7XG4gICAgICBsZW49IHR5cGUubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTG9va3MgZm9yIHR3byBjb25zZWN1dGl2ZSAnKionLCBpZiBzbywgZG9uJ3QgYWRkIHRoZSBldmVudCBhdCBhbGwuXG4gICAgLy9cbiAgICBpZiAobGVuID4gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSArIDEgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAobnNbaV0gPT09ICcqKicgJiYgbnNbaSArIDFdID09PSAnKionKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5cblxuICAgIHZhciB0cmVlID0gdGhpcy5saXN0ZW5lclRyZWUsIG5hbWU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5hbWUgPSBuc1tpXTtcblxuICAgICAgdHJlZSA9IHRyZWVbbmFtZV0gfHwgKHRyZWVbbmFtZV0gPSB7fSk7XG5cbiAgICAgIGlmIChpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGlmICghdHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgdHJlZS5fbGlzdGVuZXJzID0gbGlzdGVuZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0cmVlLl9saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycyA9IFt0cmVlLl9saXN0ZW5lcnNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICF0cmVlLl9saXN0ZW5lcnMud2FybmVkICYmXG4gICAgICAgICAgICAgIHRoaXMuX21heExpc3RlbmVycyA+IDAgJiZcbiAgICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLmxlbmd0aCA+IHRoaXMuX21heExpc3RlbmVyc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLndhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICBsb2dQb3NzaWJsZU1lbW9yeUxlYWsuY2FsbCh0aGlzLCB0cmVlLl9saXN0ZW5lcnMubGVuZ3RoLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0VHJlZUV2ZW50cyh0cmVlLCBldmVudHMsIHJvb3QsIGFzQXJyYXkpe1xuICAgICB2YXIgYnJhbmNoZXM9IG93bktleXModHJlZSk7XG4gICAgIHZhciBpPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgIHZhciBicmFuY2gsIGJyYW5jaE5hbWUsIHBhdGg7XG4gICAgIHZhciBoYXNMaXN0ZW5lcnM9IHRyZWVbJ19saXN0ZW5lcnMnXTtcbiAgICAgdmFyIGlzQXJyYXlQYXRoO1xuXG4gICAgIHdoaWxlKGktLT4wKXtcbiAgICAgICAgIGJyYW5jaE5hbWU9IGJyYW5jaGVzW2ldO1xuXG4gICAgICAgICBicmFuY2g9IHRyZWVbYnJhbmNoTmFtZV07XG5cbiAgICAgICAgIGlmKGJyYW5jaE5hbWU9PT0nX2xpc3RlbmVycycpe1xuICAgICAgICAgICAgIHBhdGg9IHJvb3Q7XG4gICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgcGF0aCA9IHJvb3QgPyByb290LmNvbmNhdChicmFuY2hOYW1lKSA6IFticmFuY2hOYW1lXTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaXNBcnJheVBhdGg9IGFzQXJyYXkgfHwgdHlwZW9mIGJyYW5jaE5hbWU9PT0nc3ltYm9sJztcblxuICAgICAgICAgaGFzTGlzdGVuZXJzICYmIGV2ZW50cy5wdXNoKGlzQXJyYXlQYXRoPyBwYXRoIDogcGF0aC5qb2luKHRoaXMuZGVsaW1pdGVyKSk7XG5cbiAgICAgICAgIGlmKHR5cGVvZiBicmFuY2g9PT0nb2JqZWN0Jyl7XG4gICAgICAgICAgICAgY29sbGVjdFRyZWVFdmVudHMuY2FsbCh0aGlzLCBicmFuY2gsIGV2ZW50cywgcGF0aCwgaXNBcnJheVBhdGgpO1xuICAgICAgICAgfVxuICAgICB9XG5cbiAgICAgcmV0dXJuIGV2ZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3Qocm9vdCkge1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhyb290KTtcbiAgICB2YXIgaT0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIG9iaiwga2V5LCBmbGFnO1xuICAgIHdoaWxlKGktLT4wKXtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBvYmogPSByb290W2tleV07XG5cbiAgICAgIGlmKG9iail7XG4gICAgICAgICAgZmxhZz0gdHJ1ZTtcbiAgICAgICAgICBpZihrZXkgIT09ICdfbGlzdGVuZXJzJyAmJiAhcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdChvYmopKXtcbiAgICAgICAgICAgICBkZWxldGUgcm9vdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmxhZztcbiAgfVxuXG4gIGZ1bmN0aW9uIExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBsaXN0ZW5lcil7XG4gICAgdGhpcy5lbWl0dGVyPSBlbWl0dGVyO1xuICAgIHRoaXMuZXZlbnQ9IGV2ZW50O1xuICAgIHRoaXMubGlzdGVuZXI9IGxpc3RlbmVyO1xuICB9XG5cbiAgTGlzdGVuZXIucHJvdG90eXBlLm9mZj0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKHRoaXMuZXZlbnQsIHRoaXMubGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNldHVwTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKXtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHByb21pc2lmeSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGFzeW5jID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdCBvciB0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzeW5jID0gb3B0aW9ucy5hc3luYztcbiAgICAgICAgdmFyIHByb21pc2lmeSA9IG9wdGlvbnMucHJvbWlzaWZ5O1xuICAgICAgICB2YXIgbmV4dFRpY2sgPSBvcHRpb25zLm5leHRUaWNrO1xuICAgICAgICB2YXIgb2JqZWN0aWZ5ID0gb3B0aW9ucy5vYmplY3RpZnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhc3luYyB8fCBuZXh0VGljayB8fCBwcm9taXNpZnkpIHtcbiAgICAgICAgdmFyIF9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB2YXIgX29yaWdpbiA9IGxpc3RlbmVyLl9vcmlnaW4gfHwgbGlzdGVuZXI7XG5cbiAgICAgICAgaWYgKG5leHRUaWNrICYmICFuZXh0VGlja1N1cHBvcnRlZCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdwcm9jZXNzLm5leHRUaWNrIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNpZnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb21pc2lmeSA9IGxpc3RlbmVyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBc3luY0Z1bmN0aW9uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50O1xuXG4gICAgICAgICAgcmV0dXJuIHByb21pc2lmeSA/IChuZXh0VGljayA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF9zZXRJbW1lZGlhdGUocmVzb2x2ZSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2xpc3RlbmVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgICAgICAgfSkpIDogKG5leHRUaWNrID8gcHJvY2Vzcy5uZXh0VGljayA6IF9zZXRJbW1lZGlhdGUpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIF9saXN0ZW5lci5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxpc3RlbmVyLl9hc3luYyA9IHRydWU7XG4gICAgICAgIGxpc3RlbmVyLl9vcmlnaW4gPSBfb3JpZ2luO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIFtsaXN0ZW5lciwgb2JqZWN0aWZ5PyBuZXcgTGlzdGVuZXIodGhpcywgZXZlbnQsIGxpc3RlbmVyKTogdGhpc107XG4gIH1cblxuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoY29uZikge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHRoaXMuX25ld0xpc3RlbmVyID0gZmFsc2U7XG4gICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmJvc2VNZW1vcnlMZWFrID0gZmFsc2U7XG4gICAgY29uZmlndXJlLmNhbGwodGhpcywgY29uZik7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGV4cG9ydGluZyBFdmVudEVtaXR0ZXIgcHJvcGVydHlcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlblRvPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cywgb3B0aW9ucyl7XG4gICAgaWYodHlwZW9mIHRhcmdldCE9PSdvYmplY3QnKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcigndGFyZ2V0IG11c3RzIGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHZhciBlbWl0dGVyPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIG9uOiB1bmRlZmluZWQsXG4gICAgICBvZmY6IHVuZGVmaW5lZCxcbiAgICAgIHJlZHVjZXJzOiB1bmRlZmluZWRcbiAgICB9LCB7XG4gICAgICBvbjogZnVuY3Rpb25SZWR1Y2VyLFxuICAgICAgb2ZmOiBmdW5jdGlvblJlZHVjZXIsXG4gICAgICByZWR1Y2Vyczogb2JqZWN0RnVuY3Rpb25SZWR1Y2VyXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4oZXZlbnRzKXtcbiAgICAgIGlmKHR5cGVvZiBldmVudHMhPT0nb2JqZWN0Jyl7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZXZlbnRzIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWR1Y2Vycz0gb3B0aW9ucy5yZWR1Y2VycztcbiAgICAgIHZhciBpbmRleD0gZmluZFRhcmdldEluZGV4LmNhbGwoZW1pdHRlciwgdGFyZ2V0KTtcbiAgICAgIHZhciBvYnNlcnZlcjtcblxuICAgICAgaWYoaW5kZXg9PT0tMSl7XG4gICAgICAgIG9ic2VydmVyPSBuZXcgVGFyZ2V0T2JzZXJ2ZXIoZW1pdHRlciwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBvYnNlcnZlcj0gZW1pdHRlci5fb2JzZXJ2ZXJzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXM9IG93bktleXMoZXZlbnRzKTtcbiAgICAgIHZhciBsZW49IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGV2ZW50O1xuICAgICAgdmFyIGlzU2luZ2xlUmVkdWNlcj0gdHlwZW9mIHJlZHVjZXJzPT09J2Z1bmN0aW9uJztcblxuICAgICAgZm9yKHZhciBpPTA7IGk8bGVuOyBpKyspe1xuICAgICAgICBldmVudD0ga2V5c1tpXTtcbiAgICAgICAgb2JzZXJ2ZXIuc3Vic2NyaWJlKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBldmVudHNbZXZlbnRdIHx8IGV2ZW50LFxuICAgICAgICAgICAgaXNTaW5nbGVSZWR1Y2VyID8gcmVkdWNlcnMgOiByZWR1Y2VycyAmJiByZWR1Y2Vyc1tldmVudF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0FycmF5KGV2ZW50cyk/XG4gICAgICAgIGxpc3Rlbih0b09iamVjdChldmVudHMpKSA6XG4gICAgICAgICh0eXBlb2YgZXZlbnRzPT09J3N0cmluZyc/IGxpc3Rlbih0b09iamVjdChldmVudHMuc3BsaXQoL1xccysvKSkpOiBsaXN0ZW4oZXZlbnRzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnN0b3BMaXN0ZW5pbmdUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50KSB7XG4gICAgdmFyIG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycztcblxuICAgIGlmKCFvYnNlcnZlcnMpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgdmFyIG1hdGNoZWQ9IGZhbHNlO1xuXG4gICAgaWYodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQhPT0nb2JqZWN0Jyl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ3RhcmdldCBzaG91bGQgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIG9ic2VydmVyID0gb2JzZXJ2ZXJzW2ldO1xuICAgICAgaWYgKCF0YXJnZXQgfHwgb2JzZXJ2ZXIuX3RhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIG9ic2VydmVyLnVuc3Vic2NyaWJlKGV2ZW50KTtcbiAgICAgICAgbWF0Y2hlZD0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4gIC8vIDEwIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaFxuICAvLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbiAgLy9cbiAgLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4gIC8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZGVsaW1pdGVyID0gJy4nO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICAgIGlmIChuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gICAgICBpZiAoIXRoaXMuX2NvbmYpIHRoaXMuX2NvbmYgPSB7fTtcbiAgICAgIHRoaXMuX2NvbmYubWF4TGlzdGVuZXJzID0gbjtcbiAgICB9XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnQgPSAnJztcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25jZShldmVudCwgZm4sIGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25jZShldmVudCwgZm4sIHRydWUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX29uY2UgPSBmdW5jdGlvbihldmVudCwgZm4sIHByZXBlbmQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFueShldmVudCwgMSwgZm4sIHByZXBlbmQsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hbnkoZXZlbnQsIHR0bCwgZm4sIGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRNYW55ID0gZnVuY3Rpb24oZXZlbnQsIHR0bCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFueShldmVudCwgdHRsLCBmbiwgdHJ1ZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuLCBwcmVwZW5kLCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYW55IG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmICgtLXR0bCA9PT0gMCkge1xuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbGlzdGVuZXIuX29yaWdpbiA9IGZuO1xuXG4gICAgcmV0dXJuIHRoaXMuX29uKGV2ZW50LCBsaXN0ZW5lciwgcHJlcGVuZCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMgJiYgIXRoaXMuX2FsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSwgbnMsIHdpbGRjYXJkPSB0aGlzLndpbGRjYXJkO1xuICAgIHZhciBhcmdzLGwsaSxqLCBjb250YWluc1N5bWJvbDtcblxuICAgIGlmICh0eXBlID09PSAnbmV3TGlzdGVuZXInICYmICF0aGlzLl9uZXdMaXN0ZW5lcikge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgbnM9IHR5cGU7XG4gICAgICBpZih0eXBlIT09J25ld0xpc3RlbmVyJyAmJiB0eXBlIT09J3JlbW92ZUxpc3RlbmVyJyl7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBsID0gdHlwZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHN5bWJvbHNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlW2ldID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5zU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbnRhaW5zU3ltYm9sKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5qb2luKHRoaXMuZGVsaW1pdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBoYW5kbGVyO1xuXG4gICAgaWYgKHRoaXMuX2FsbCAmJiB0aGlzLl9hbGwubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fYWxsLnNsaWNlKCk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgaGFuZGxlciA9IFtdO1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlciwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwLCBsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgICAvLyBuZWVkIHRvIG1ha2UgY29weSBvZiBoYW5kbGVycyBiZWNhdXNlIGxpc3QgY2FuIGNoYW5nZSBpbiB0aGUgbWlkZGxlXG4gICAgICAgIC8vIG9mIGVtaXQgY2FsbFxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5zbGljZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVyICYmIGhhbmRsZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoYWwgPiAzKSB7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaGFuZGxlcltpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghdGhpcy5pZ25vcmVFcnJvcnMgJiYgIXRoaXMuX2FsbCAmJiB0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAhIXRoaXMuX2FsbDtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXRBc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzICYmICF0aGlzLl9hbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF0sIHdpbGRjYXJkPSB0aGlzLndpbGRjYXJkLCBucywgY29udGFpbnNTeW1ib2w7XG4gICAgdmFyIGFyZ3MsbCxpLGo7XG5cbiAgICBpZiAodHlwZSA9PT0gJ25ld0xpc3RlbmVyJyAmJiAhdGhpcy5fbmV3TGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbZmFsc2VdKTsgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgbnM9IHR5cGU7XG4gICAgICBpZih0eXBlIT09J25ld0xpc3RlbmVyJyAmJiB0eXBlIT09J3JlbW92ZUxpc3RlbmVyJyl7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBsID0gdHlwZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHN5bWJvbHNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlW2ldID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5zU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbnRhaW5zU3ltYm9sKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5qb2luKHRoaXMuZGVsaW1pdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZXM9IFtdO1xuXG4gICAgdmFyIGFsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaGFuZGxlcjtcblxuICAgIGlmICh0aGlzLl9hbGwpIHtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLl9hbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgIGhhbmRsZXIgPSBbXTtcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXIsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFuZGxlciAmJiBoYW5kbGVyLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICAgIGlmIChhbCA+IDMpIHtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5pZ25vcmVFcnJvcnMgJiYgIXRoaXMuX2FsbCAmJiB0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFyZ3VtZW50c1sxXSk7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb24odHlwZSwgbGlzdGVuZXIsIGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGxpc3RlbmVyLCB0cnVlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uQW55ID0gZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb25BbnkoZm4sIGZhbHNlKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRBbnkgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiB0aGlzLl9vbkFueShmbiwgdHJ1ZSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fb25BbnkgPSBmdW5jdGlvbihmbiwgcHJlcGVuZCl7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbkFueSBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9hbGwpIHtcbiAgICAgIHRoaXMuX2FsbCA9IFtdO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZnVuY3Rpb24gdG8gdGhlIGV2ZW50IGxpc3RlbmVyIGNvbGxlY3Rpb24uXG4gICAgaWYocHJlcGVuZCl7XG4gICAgICB0aGlzLl9hbGwudW5zaGlmdChmbik7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLl9hbGwucHVzaChmbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fb24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fb25BbnkodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbiBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgcmV0dXJuVmFsdWU9IHRoaXMsIHRlbXA7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0ZW1wID0gc2V0dXBMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIGxpc3RlbmVyID0gdGVtcFswXTtcbiAgICAgIHJldHVyblZhbHVlID0gdGVtcFsxXTtcbiAgICB9XG5cbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJzXCIuXG4gICAgaWYgKHRoaXMuX25ld0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICBncm93TGlzdGVuZXJUcmVlLmNhbGwodGhpcywgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpO1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBDaGFuZ2UgdG8gYXJyYXkuXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhZGRcbiAgICAgIGlmKHByZXBlbmQpe1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0udW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgICAgaWYgKFxuICAgICAgICAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCAmJlxuICAgICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPiAwICYmXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiB0aGlzLl9tYXhMaXN0ZW5lcnNcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgbG9nUG9zc2libGVNZW1vcnlMZWFrLmNhbGwodGhpcywgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzLGxlYWZzPVtdO1xuXG4gICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XG4gICAgICBsZWFmcyA9IHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIG51bGwsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgICBpZighbGVhZnMpIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcbiAgICAgIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgbGVhZnMucHVzaCh7X2xpc3RlbmVyczpoYW5kbGVyc30pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlMZWFmPTA7IGlMZWFmPGxlYWZzLmxlbmd0aDsgaUxlYWYrKykge1xuICAgICAgdmFyIGxlYWYgPSBsZWFmc1tpTGVhZl07XG4gICAgICBoYW5kbGVycyA9IGxlYWYuX2xpc3RlbmVycztcbiAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYW5kbGVyc1tpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAgIChoYW5kbGVyc1tpXS5saXN0ZW5lciAmJiBoYW5kbGVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHx8XG4gICAgICAgICAgICAoaGFuZGxlcnNbaV0uX29yaWdpbiAmJiBoYW5kbGVyc1tpXS5fb3JpZ2luID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICBsZWFmLl9saXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChoYW5kbGVycyA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgKGhhbmRsZXJzLmxpc3RlbmVyICYmIGhhbmRsZXJzLmxpc3RlbmVyID09PSBsaXN0ZW5lcikgfHxcbiAgICAgICAgKGhhbmRsZXJzLl9vcmlnaW4gJiYgaGFuZGxlcnMuX29yaWdpbiA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyVHJlZSAmJiByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHRoaXMubGlzdGVuZXJUcmVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmQW55ID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgaSA9IDAsIGwgPSAwLCBmbnM7XG4gICAgaWYgKGZuICYmIHRoaXMuX2FsbCAmJiB0aGlzLl9hbGwubGVuZ3RoID4gMCkge1xuICAgICAgZm5zID0gdGhpcy5fYWxsO1xuICAgICAgZm9yKGkgPSAwLCBsID0gZm5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZihmbiA9PT0gZm5zW2ldKSB7XG4gICAgICAgICAgZm5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lckFueVwiLCBmbik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm5zID0gdGhpcy5fYWxsO1xuICAgICAgaWYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGZvcihpID0gMCwgbCA9IGZucy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJBbnlcIiwgZm5zW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FsbCA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmY7XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICF0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIHZhciBsZWFmcyA9IHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIG51bGwsIHR5cGUsIHRoaXMubGlzdGVuZXJUcmVlLCAwKSwgbGVhZiwgaTtcbiAgICAgIGlmICghbGVhZnMpIHJldHVybiB0aGlzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlYWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlYWYgPSBsZWFmc1tpXTtcbiAgICAgICAgbGVhZi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGlzdGVuZXJUcmVlICYmIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3QodGhpcy5saXN0ZW5lclRyZWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIF9ldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgdmFyIGtleXMsIGxpc3RlbmVycywgYWxsTGlzdGVuZXJzO1xuICAgIHZhciBpO1xuICAgIHZhciBsaXN0ZW5lclRyZWU7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgICB0aHJvdyBFcnJvcignZXZlbnQgbmFtZSByZXF1aXJlZCBmb3Igd2lsZGNhcmQgZW1pdHRlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBrZXlzID0gb3duS2V5cyhfZXZlbnRzKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGFsbExpc3RlbmVycyA9IFtdO1xuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgbGlzdGVuZXJzID0gX2V2ZW50c1trZXlzW2ldXTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhbGxMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbExpc3RlbmVycy5wdXNoLmFwcGx5KGFsbExpc3RlbmVycywgbGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgbGlzdGVuZXJUcmVlPSB0aGlzLmxpc3RlbmVyVHJlZTtcbiAgICAgICAgaWYoIWxpc3RlbmVyVHJlZSkgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XG4gICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXJzLCBucywgbGlzdGVuZXJUcmVlLCAwKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBfZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJyA/IFtsaXN0ZW5lcnNdIDogbGlzdGVuZXJzO1xuICAgIH1cbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbihuc0FzQXJyYXkpe1xuICAgIHZhciBfZXZlbnRzPSB0aGlzLl9ldmVudHM7XG4gICAgcmV0dXJuIHRoaXMud2lsZGNhcmQ/IGNvbGxlY3RUcmVlRXZlbnRzLmNhbGwodGhpcywgdGhpcy5saXN0ZW5lclRyZWUsIFtdLCBudWxsLCBuc0FzQXJyYXkpIDogKF9ldmVudHM/IG93bktleXMoX2V2ZW50cykgOiBbXSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlcnMsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgICByZXR1cm4gaGFuZGxlcnMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICB2YXIgX2V2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICB2YXIgX2FsbCA9IHRoaXMuX2FsbDtcblxuICAgIHJldHVybiAhIShfYWxsICYmIF9hbGwubGVuZ3RoIHx8IF9ldmVudHMgJiYgKHR5cGUgPT09IHVuZGVmaW5lZCA/IG93bktleXMoX2V2ZW50cykubGVuZ3RoIDogX2V2ZW50c1t0eXBlXSkpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzQW55ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZih0aGlzLl9hbGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2FpdEZvciA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvcHRpb25zO1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucyA9IHt0aW1lb3V0OiBvcHRpb25zfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSB7ZmlsdGVyOiBvcHRpb25zfTtcbiAgICB9XG5cbiAgICBvcHRpb25zPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICB0aW1lb3V0OiAwLFxuICAgICAgZmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICBoYW5kbGVFcnJvcjogZmFsc2UsXG4gICAgICBQcm9taXNlOiBQcm9taXNlLFxuICAgICAgb3ZlcmxvYWQ6IGZhbHNlXG4gICAgfSwge1xuICAgICAgZmlsdGVyOiBmdW5jdGlvblJlZHVjZXIsXG4gICAgICBQcm9taXNlOiBjb25zdHJ1Y3RvclJlZHVjZXJcbiAgICB9KTtcblxuICAgIHJldHVybiBtYWtlQ2FuY2VsYWJsZVByb21pc2Uob3B0aW9ucy5Qcm9taXNlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkge1xuICAgICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICAgIHZhciBmaWx0ZXI9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVFcnJvcikge1xuICAgICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHRvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5zbGljZSgxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uQ2FuY2VsKGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5fb24oZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSwge1xuICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgb3ZlcmxvYWQ6IG9wdGlvbnMub3ZlcmxvYWRcbiAgICB9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnM9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIFByb21pc2U6IFByb21pc2UsXG4gICAgICB0aW1lb3V0OiAwLFxuICAgICAgb3ZlcmxvYWQ6IGZhbHNlXG4gICAgfSwge1xuICAgICAgUHJvbWlzZTogY29uc3RydWN0b3JSZWR1Y2VyXG4gICAgfSk7XG5cbiAgICB2YXIgX1Byb21pc2U9IG9wdGlvbnMuUHJvbWlzZTtcblxuICAgIHJldHVybiBtYWtlQ2FuY2VsYWJsZVByb21pc2UoX1Byb21pc2UsIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpe1xuICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVyPSAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUodG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvbkNhbmNlbChmdW5jdGlvbigpe1xuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICB7b25jZTogdHJ1ZX1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGVycm9yTGlzdGVuZXIgJiYgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgICAgcmVzb2x2ZSh0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGVycm9yTGlzdGVuZXI7XG5cbiAgICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICAgIGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXJyKXtcbiAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVtaXR0ZXIub25jZSgnZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgb25DYW5jZWwoZnVuY3Rpb24oKXtcbiAgICAgICAgZXJyb3JMaXN0ZW5lciAmJiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICB9LCB7XG4gICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsXG4gICAgICBvdmVybG9hZDogb3B0aW9ucy5vdmVybG9hZFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZT0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudEVtaXR0ZXIsIHtcbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZS5fbWF4TGlzdGVuZXJzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXIuaXNOYU4obikpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuICAgICAgICB9XG4gICAgICAgIHByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gbjtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBvbmNlOiB7XG4gICAgICB2YWx1ZTogb25jZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90b3R5cGUsIHtcbiAgICAgIF9tYXhMaXN0ZW5lcnM6IHtcbiAgICAgICAgICB2YWx1ZTogZGVmYXVsdE1heExpc3RlbmVycyxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBfb2JzZXJ2ZXJzOiB7dmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9XG4gIH0pO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnbG9iYWwgZm9yIGFueSBraW5kIG9mIGVudmlyb25tZW50LlxuICAgIHZhciBfZ2xvYmFsPSBuZXcgRnVuY3Rpb24oJycsJ3JldHVybiB0aGlzJykoKTtcbiAgICBfZ2xvYmFsLkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7XG4gIH1cbn0oKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgemVyb0ZpbGwgPSByZXF1aXJlKCd6ZXJvLWZpbGwnKVxudmFyIHBhcnNlSW50U3RyaWN0ID0gcmVxdWlyZSgncGFyc2UtaW50JylcblxudmFyIHBhZCA9IHplcm9GaWxsKDIpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwYW5kWWVhciAoeWVhciwgbm93KSB7XG4gIG5vdyA9IG5vdyB8fCBuZXcgRGF0ZSgpXG4gIHZhciBiYXNlID0gbm93LmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKS5zdWJzdHIoMCwgMilcbiAgeWVhciA9IHBhcnNlSW50U3RyaWN0KHllYXIpXG4gIHJldHVybiBwYXJzZUludFN0cmljdChiYXNlICsgcGFkKHllYXIpKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGxvb2t1cCA9IFswLCAyLCA0LCA2LCA4LCAxLCAzLCA1LCA3LCA5XVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGx1aG4gKG51bWJlcikge1xuICBpZiAodHlwZW9mIG51bWJlciAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHN0cmluZyBpbnB1dCcpXG4gIGlmICghbnVtYmVyKSByZXR1cm4gZmFsc2VcblxuICBsZXQgaW5kZXggPSBudW1iZXIubGVuZ3RoXG4gIGxldCB4MiA9IHRydWVcbiAgbGV0IHN1bSA9IDBcblxuICB3aGlsZSAoaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG51bWJlci5jaGFyQ29kZUF0KC0taW5kZXgpIC0gNDhcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gOSkgcmV0dXJuIGZhbHNlXG5cbiAgICB4MiA9ICF4MlxuICAgIHN1bSArPSB4MiA/IGxvb2t1cFt2YWx1ZV0gOiB2YWx1ZVxuICB9XG5cbiAgcmV0dXJuIHN1bSAlIDEwID09PSAwXG59XG4iLCJ2YXIgc2VsZWN0b3JzID0gW1xuICAnaWZyYW1lW3NyYyo9XCJwbGF5ZXIudmltZW8uY29tXCJdJyxcbiAgJ2lmcmFtZVtzcmMqPVwieW91dHViZS5jb21cIl0nLFxuICAnaWZyYW1lW3NyYyo9XCJ5b3V0dWJlLW5vY29va2llLmNvbVwiXScsXG4gICdpZnJhbWVbc3JjKj1cImtpY2tzdGFydGVyLmNvbVwiXVtzcmMqPVwidmlkZW8uaHRtbFwiXScsXG4gIFwib2JqZWN0XCJcbl07XG5cbnZhciBjc3MgPVxuICBcIi5mbHVpZC13aWR0aC12aWRlby13cmFwcGVye3dpZHRoOjEwMCU7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzowO30uZmx1aWQtd2lkdGgtdmlkZW8td3JhcHBlciBpZnJhbWUsLmZsdWlkLXdpZHRoLXZpZGVvLXdyYXBwZXIgb2JqZWN0LC5mbHVpZC13aWR0aC12aWRlby13cmFwcGVyIGVtYmVkIHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt9XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGFyZW50U2VsZWN0b3IsIG9wdHMpIHtcbiAgcGFyZW50U2VsZWN0b3IgPSBwYXJlbnRTZWxlY3RvciB8fCBcImJvZHlcIjtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKGlzT2JqZWN0KHBhcmVudFNlbGVjdG9yKSkge1xuICAgIG9wdHMgPSBwYXJlbnRTZWxlY3RvcjtcbiAgICBwYXJlbnRTZWxlY3RvciA9IFwiYm9keVwiO1xuICB9XG5cbiAgb3B0cy5pZ25vcmUgPSBvcHRzLmlnbm9yZSB8fCBcIlwiO1xuICBvcHRzLnBsYXllcnMgPSBvcHRzLnBsYXllcnMgfHwgXCJcIjtcblxuICB2YXIgY29udGFpbmVycyA9IHF1ZXJ5QWxsKHBhcmVudFNlbGVjdG9yKTtcbiAgaWYgKCFoYXNMZW5ndGgoY29udGFpbmVycykpIHJldHVybjtcblxuICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZml0LXZpZHMtc3R5bGVcIikpIHtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVzKCkpO1xuICB9XG5cbiAgdmFyIGN1c3RvbSA9IHRvU2VsZWN0b3JBcnJheShvcHRzLnBsYXllcnMpO1xuICB2YXIgaWdub3JlZCA9IHRvU2VsZWN0b3JBcnJheShvcHRzLmlnbm9yZSk7XG4gIHZhciBpZ25vcmVkU2VsZWN0b3IgPSBpZ25vcmVkLmxlbmd0aCA+IDAgPyBpZ25vcmVkLmpvaW4oKSA6IG51bGw7XG4gIHZhciBzZWxlY3RvciA9IHNlbGVjdG9ycy5jb25jYXQoY3VzdG9tKS5qb2luKCk7XG5cbiAgaWYgKCFoYXNMZW5ndGgoc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciB2aWRlb3MgPSBxdWVyeUFsbChjb250YWluZXIsIHNlbGVjdG9yKTtcblxuICAgIHZpZGVvcy5mb3JFYWNoKGZ1bmN0aW9uKHZpZGVvKSB7XG4gICAgICBpZiAoaWdub3JlZFNlbGVjdG9yICYmIHZpZGVvLm1hdGNoZXMoaWdub3JlZFNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3cmFwKHZpZGVvKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5QWxsKGVsLCBzZWxlY3Rvcikge1xuICBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgc2VsZWN0b3IgPSBlbDtcbiAgICBlbCA9IGRvY3VtZW50O1xuICB9XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3JBcnJheShpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGlucHV0XG4gICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAubWFwKHRyaW0pXG4gICAgICAuZmlsdGVyKGhhc0xlbmd0aCk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gZmxhdHRlbihpbnB1dC5tYXAodG9TZWxlY3RvckFycmF5KS5maWx0ZXIoaGFzTGVuZ3RoKSk7XG4gIH1cbiAgcmV0dXJuIGlucHV0IHx8IFtdO1xufVxuXG5mdW5jdGlvbiB3cmFwKGVsKSB7XG4gIGlmICgvZmx1aWQtd2lkdGgtdmlkZW8td3JhcHBlci8udGVzdChlbC5wYXJlbnROb2RlLmNsYXNzTmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgd2lkdGhBdHRyID0gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksIDEwKTtcbiAgdmFyIGhlaWdodEF0dHIgPSBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiksIDEwKTtcblxuICB2YXIgd2lkdGggPSAhaXNOYU4od2lkdGhBdHRyKSA/IHdpZHRoQXR0ciA6IGVsLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gIWlzTmFOKGhlaWdodEF0dHIpID8gaGVpZ2h0QXR0ciA6IGVsLmNsaWVudEhlaWdodDtcbiAgdmFyIGFzcGVjdCA9IGhlaWdodCAvIHdpZHRoO1xuXG4gIGVsLnJlbW92ZUF0dHJpYnV0ZShcIndpZHRoXCIpO1xuICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG5cbiAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBlbCk7XG4gIHdyYXBwZXIuY2xhc3NOYW1lID0gXCJmbHVpZC13aWR0aC12aWRlby13cmFwcGVyXCI7XG4gIHdyYXBwZXIuc3R5bGUucGFkZGluZ1RvcCA9IGFzcGVjdCAqIDEwMCArIFwiJVwiO1xuICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVzKCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgZGl2LmlubmVySFRNTCA9ICc8cD54PC9wPjxzdHlsZSBpZD1cImZpdC12aWRzLXN0eWxlXCI+JyArIGNzcyArIFwiPC9zdHlsZT5cIjtcbiAgcmV0dXJuIGRpdi5jaGlsZE5vZGVzWzFdO1xufVxuXG5mdW5jdGlvbiBoYXNMZW5ndGgoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0Lmxlbmd0aCA+IDA7XG59XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4oaW5wdXQpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG52YXIgY29uY2F0dHkgPSBmdW5jdGlvbiBjb25jYXR0eShhLCBiKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV07XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBhcnJbaiArIGEubGVuZ3RoXSA9IGJbal07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBzbGljeSA9IGZ1bmN0aW9uIHNsaWN5KGFyckxpa2UsIG9mZnNldCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0IHx8IDAsIGogPSAwOyBpIDwgYXJyTGlrZS5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICAgIGFycltqXSA9IGFyckxpa2VbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgam9pbnkgPSBmdW5jdGlvbiAoYXJyLCBqb2luZXIpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGFycltpXTtcbiAgICAgICAgaWYgKGkgKyAxIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyICs9IGpvaW5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5hcHBseSh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWN5KGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgKTtcblxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJnc1tpXSA9ICckJyArIGk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGpvaW55KGJvdW5kQXJncywgJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMnKTtcbnZhciAkRXZhbEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL2V2YWwnKTtcbnZhciAkUmFuZ2VFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9yYW5nZScpO1xudmFyICRSZWZlcmVuY2VFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9yZWYnKTtcbnZhciAkU3ludGF4RXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvc3ludGF4Jyk7XG52YXIgJFR5cGVFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy90eXBlJyk7XG52YXIgJFVSSUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3VyaScpO1xuXG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG52YXIgaGFzUHJvdG8gPSByZXF1aXJlKCdoYXMtcHJvdG8nKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgKFxuXHRoYXNQcm90b1xuXHRcdD8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblx0XHQ6IG51bGxcbik7XG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQmlnSW50NjRBcnJheSUnOiB0eXBlb2YgQmlnSW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQ2NEFycmF5LFxuXHQnJUJpZ1VpbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdVaW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdVaW50NjRBcnJheSxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6ICRFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiAkRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6ICRSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6ICRSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogJFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG5pZiAoZ2V0UHJvdG8pIHtcblx0dHJ5IHtcblx0XHRudWxsLmVycm9yOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc2hhZG93cmVhbG0vcHVsbC8zODQjaXNzdWVjb21tZW50LTEzNjQyNjQyMjlcblx0XHR2YXIgZXJyb3JQcm90byA9IGdldFByb3RvKGdldFByb3RvKGUpKTtcblx0XHRJTlRSSU5TSUNTWyclRXJyb3IucHJvdG90eXBlJSddID0gZXJyb3JQcm90bztcblx0fVxufVxuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuICYmIGdldFByb3RvKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXNvd24nKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG52YXIgJGV4ZWMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kLywgbmFtZSkgPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdgJWAgbWF5IG5vdCBiZSBwcmVzZW50IGFueXdoZXJlIGJ1dCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGludHJpbnNpYyBuYW1lJyk7XG5cdH1cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5cbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdlcy1kZWZpbmUtcHJvcGVydHknKTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBmdW5jdGlvbiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkge1xuXHRyZXR1cm4gISEkZGVmaW5lUHJvcGVydHk7XG59O1xuXG5oYXNQcm9wZXJ0eURlc2NyaXB0b3JzLmhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnID0gZnVuY3Rpb24gaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcoKSB7XG5cdC8vIG5vZGUgdjAuNiBoYXMgYSBidWcgd2hlcmUgYXJyYXkgbGVuZ3RocyBjYW4gYmUgU2V0IGJ1dCBub3QgRGVmaW5lZFxuXHRpZiAoISRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRkZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDEgfSkubGVuZ3RoICE9PSAxO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSW4gRmlyZWZveCA0LTIyLCBkZWZpbmluZyBsZW5ndGggb24gYW4gYXJyYXkgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVzdCA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzUHJvdG8oKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3I6IFRTIGVycm9ycyBvbiBhbiBpbmhlcml0ZWQgcHJvcGVydHkgZm9yIHNvbWUgcmVhc29uXG5cdHJldHVybiB7IF9fcHJvdG9fXzogdGVzdCB9LmZvbyA9PT0gdGVzdC5mb29cblx0XHQmJiAhKHRlc3QgaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciAkaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoY2FsbCwgJGhhc093bik7XG4iLCIvKlxuICAgIGpzb24yLmpzXG4gICAgMjAxMi0xMC0wOFxuXG4gICAgUHVibGljIERvbWFpbi5cblxuICAgIE5PIFdBUlJBTlRZIEVYUFJFU1NFRCBPUiBJTVBMSUVELiBVU0UgQVQgWU9VUiBPV04gUklTSy5cblxuICAgIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcblxuXG4gICAgVGhpcyBjb2RlIHNob3VsZCBiZSBtaW5pZmllZCBiZWZvcmUgZGVwbG95bWVudC5cbiAgICBTZWUgaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS9qc21pbi5odG1sXG5cbiAgICBVU0UgWU9VUiBPV04gQ09QWS4gSVQgSVMgRVhUUkVNRUxZIFVOV0lTRSBUTyBMT0FEIENPREUgRlJPTSBTRVJWRVJTIFlPVSBET1xuICAgIE5PVCBDT05UUk9MLlxuXG5cbiAgICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbiAgICBhbmQgcGFyc2UuXG5cbiAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSlcbiAgICAgICAgICAgIHZhbHVlICAgICAgIGFueSBKYXZhU2NyaXB0IHZhbHVlLCB1c3VhbGx5IGFuIG9iamVjdCBvciBhcnJheS5cblxuICAgICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cblxuICAgICAgICAgICAgc3BhY2UgICAgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb2YgbmVzdGVkIHN0cnVjdHVyZXMuIElmIGl0IGlzIG9taXR0ZWQsIHRoZSB0ZXh0IHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlIHBhY2tlZCB3aXRob3V0IGV4dHJhIHdoaXRlc3BhY2UuIElmIGl0IGlzIGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBzcGVjaWZ5IHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGluZGVudCBhdCBlYWNoXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC4gSWYgaXQgaXMgYSBzdHJpbmcgKHN1Y2ggYXMgJ1xcdCcgb3IgJyZuYnNwOycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXQgY29udGFpbnMgdGhlIGNoYXJhY3RlcnMgdXNlZCB0byBpbmRlbnQgYXQgZWFjaCBsZXZlbC5cblxuICAgICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG5cbiAgICAgICAgICAgIFdoZW4gYW4gb2JqZWN0IHZhbHVlIGlzIGZvdW5kLCBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGEgdG9KU09OXG4gICAgICAgICAgICBtZXRob2QsIGl0cyB0b0pTT04gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmVcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkLiBBIHRvSlNPTiBtZXRob2QgZG9lcyBub3Qgc2VyaWFsaXplOiBpdCByZXR1cm5zIHRoZVxuICAgICAgICAgICAgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIG5hbWUvdmFsdWUgcGFpciB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkLFxuICAgICAgICAgICAgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSB0b0pTT04gbWV0aG9kXG4gICAgICAgICAgICB3aWxsIGJlIHBhc3NlZCB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUsIGFuZCB0aGlzIHdpbGwgYmVcbiAgICAgICAgICAgIGJvdW5kIHRvIHRoZSB2YWx1ZVxuXG4gICAgICAgICAgICBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCBzZXJpYWxpemUgRGF0ZXMgYXMgSVNPIHN0cmluZ3MuXG5cbiAgICAgICAgICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgICArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArICdUJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICAgICArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArICdaJztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWwgcmVwbGFjZXIgbWV0aG9kLiBJdCB3aWxsIGJlIHBhc3NlZCB0aGVcbiAgICAgICAgICAgIGtleSBhbmQgdmFsdWUgb2YgZWFjaCBtZW1iZXIsIHdpdGggdGhpcyBib3VuZCB0byB0aGUgY29udGFpbmluZ1xuICAgICAgICAgICAgb2JqZWN0LiBUaGUgdmFsdWUgdGhhdCBpcyByZXR1cm5lZCBmcm9tIHlvdXIgbWV0aG9kIHdpbGwgYmVcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuIElmIHlvdXIgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLCB0aGVuIHRoZSBtZW1iZXIgd2lsbFxuICAgICAgICAgICAgYmUgZXhjbHVkZWQgZnJvbSB0aGUgc2VyaWFsaXphdGlvbi5cblxuICAgICAgICAgICAgSWYgdGhlIHJlcGxhY2VyIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCB0aGVuIGl0IHdpbGwgYmVcbiAgICAgICAgICAgIHVzZWQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHNlcmlhbGl6ZWQuIEl0IGZpbHRlcnMgdGhlIHJlc3VsdHNcbiAgICAgICAgICAgIHN1Y2ggdGhhdCBvbmx5IG1lbWJlcnMgd2l0aCBrZXlzIGxpc3RlZCBpbiB0aGUgcmVwbGFjZXIgYXJyYXkgYXJlXG4gICAgICAgICAgICBzdHJpbmdpZmllZC5cblxuICAgICAgICAgICAgVmFsdWVzIHRoYXQgZG8gbm90IGhhdmUgSlNPTiByZXByZXNlbnRhdGlvbnMsIHN1Y2ggYXMgdW5kZWZpbmVkIG9yXG4gICAgICAgICAgICBmdW5jdGlvbnMsIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuIFN1Y2ggdmFsdWVzIGluIG9iamVjdHMgd2lsbCBiZVxuICAgICAgICAgICAgZHJvcHBlZDsgaW4gYXJyYXlzIHRoZXkgd2lsbCBiZSByZXBsYWNlZCB3aXRoIG51bGwuIFlvdSBjYW4gdXNlXG4gICAgICAgICAgICBhIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIHJlcGxhY2UgdGhvc2Ugd2l0aCBKU09OIHZhbHVlcy5cbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHVuZGVmaW5lZCkgcmV0dXJucyB1bmRlZmluZWQuXG5cbiAgICAgICAgICAgIFRoZSBvcHRpb25hbCBzcGFjZSBwYXJhbWV0ZXIgcHJvZHVjZXMgYSBzdHJpbmdpZmljYXRpb24gb2YgdGhlXG4gICAgICAgICAgICB2YWx1ZSB0aGF0IGlzIGZpbGxlZCB3aXRoIGxpbmUgYnJlYWtzIGFuZCBpbmRlbnRhdGlvbiB0byBtYWtlIGl0XG4gICAgICAgICAgICBlYXNpZXIgdG8gcmVhZC5cblxuICAgICAgICAgICAgSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsIHRoZW4gdGhhdCBzdHJpbmcgd2lsbFxuICAgICAgICAgICAgYmUgdXNlZCBmb3IgaW5kZW50YXRpb24uIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIHRoZW5cbiAgICAgICAgICAgIHRoZSBpbmRlbnRhdGlvbiB3aWxsIGJlIHRoYXQgbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbJ2UnLCB7cGx1cmlidXM6ICd1bnVtJ31dKTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcImVcIix7XCJwbHVyaWJ1c1wiOlwidW51bVwifV0nXG5cblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFsnZScsIHtwbHVyaWJ1czogJ3VudW0nfV0sIG51bGwsICdcXHQnKTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlID9cbiAgICAgICAgICAgICAgICAgICAgJ0RhdGUoJyArIHRoaXNba2V5XSArICcpJyA6IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJEYXRlKC0tLWN1cnJlbnQgdGltZS0tLSlcIl0nXG5cblxuICAgICAgICBKU09OLnBhcnNlKHRleHQsIHJldml2ZXIpXG4gICAgICAgICAgICBUaGlzIG1ldGhvZCBwYXJzZXMgYSBKU09OIHRleHQgdG8gcHJvZHVjZSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICAgICAgICBJdCBjYW4gdGhyb3cgYSBTeW50YXhFcnJvciBleGNlcHRpb24uXG5cbiAgICAgICAgICAgIFRoZSBvcHRpb25hbCByZXZpdmVyIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGZpbHRlciBhbmRcbiAgICAgICAgICAgIHRyYW5zZm9ybSB0aGUgcmVzdWx0cy4gSXQgcmVjZWl2ZXMgZWFjaCBvZiB0aGUga2V5cyBhbmQgdmFsdWVzLFxuICAgICAgICAgICAgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgICAgIElmIGl0IHJldHVybnMgd2hhdCBpdCByZWNlaXZlZCwgdGhlbiB0aGUgc3RydWN0dXJlIGlzIG5vdCBtb2RpZmllZC5cbiAgICAgICAgICAgIElmIGl0IHJldHVybnMgdW5kZWZpbmVkIHRoZW4gdGhlIG1lbWJlciBpcyBkZWxldGVkLlxuXG4gICAgICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgdGV4dC4gVmFsdWVzIHRoYXQgbG9vayBsaWtlIElTTyBkYXRlIHN0cmluZ3Mgd2lsbFxuICAgICAgICAgICAgLy8gYmUgY29udmVydGVkIHRvIERhdGUgb2JqZWN0cy5cblxuICAgICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSh0ZXh0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPVxuL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgK2FbNV0sICthWzZdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UoJ1tcIkRhdGUoMDkvMDkvMjAwMSlcIl0nLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCA1KSA9PT0gJ0RhdGUoJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoLTEpID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKHZhbHVlLnNsaWNlKDUsIC0xKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgVGhpcyBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi4gWW91IGFyZSBmcmVlIHRvIGNvcHksIG1vZGlmeSwgb3JcbiAgICByZWRpc3RyaWJ1dGUuXG4qL1xuXG4vKmpzbGludCBldmlsOiB0cnVlLCByZWdleHA6IHRydWUgKi9cblxuLyptZW1iZXJzIFwiXCIsIFwiXFxiXCIsIFwiXFx0XCIsIFwiXFxuXCIsIFwiXFxmXCIsIFwiXFxyXCIsIFwiXFxcIlwiLCBKU09OLCBcIlxcXFxcIiwgYXBwbHksXG4gICAgY2FsbCwgY2hhckNvZGVBdCwgZ2V0VVRDRGF0ZSwgZ2V0VVRDRnVsbFllYXIsIGdldFVUQ0hvdXJzLFxuICAgIGdldFVUQ01pbnV0ZXMsIGdldFVUQ01vbnRoLCBnZXRVVENTZWNvbmRzLCBoYXNPd25Qcm9wZXJ0eSwgam9pbixcbiAgICBsYXN0SW5kZXgsIGxlbmd0aCwgcGFyc2UsIHByb3RvdHlwZSwgcHVzaCwgcmVwbGFjZSwgc2xpY2UsIHN0cmluZ2lmeSxcbiAgICB0ZXN0LCB0b0pTT04sIHRvU3RyaW5nLCB2YWx1ZU9mXG4qL1xuXG5cbi8vIENyZWF0ZSBhIEpTT04gb2JqZWN0IG9ubHkgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuIFdlIGNyZWF0ZSB0aGVcbi8vIG1ldGhvZHMgaW4gYSBjbG9zdXJlIHRvIGF2b2lkIGNyZWF0aW5nIGdsb2JhbCB2YXJpYWJsZXMuXG5cbmlmICh0eXBlb2YgSlNPTiAhPT0gJ29iamVjdCcpIHtcbiAgICBKU09OID0ge307XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gZihuKSB7XG4gICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIERhdGUucHJvdG90eXBlLnRvSlNPTiAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHRoaXMudmFsdWVPZigpKVxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRVVENGdWxsWWVhcigpICAgICArICctJyArXG4gICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSAgICAgICsgJ1QnICtcbiAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICAgICArICc6JyArXG4gICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSAgICsgJ1onXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUudG9KU09OICAgICAgPVxuICAgICAgICAgICAgTnVtYmVyLnByb3RvdHlwZS50b0pTT04gID1cbiAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBnYXAsXG4gICAgICAgIGluZGVudCxcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBjXG4gICAgICAgICAgICAgICAgOiAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcblxuLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuXG4gICAgICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgICAgICB2LCAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgICAgIHBhcnRpYWwsXG4gICAgICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuXG4vLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgIH1cblxuLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4vLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG5cbi8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cblxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgICAgICBjYXNlICdudW1iZXInOlxuXG4vLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG5cbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuXG4vLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4vLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzICdvYmplY3QnLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4vLyBudWxsLlxuXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG5cbi8vIER1ZSB0byBhIHNwZWNpZmljYXRpb24gYmx1bmRlciBpbiBFQ01BU2NyaXB0LCB0eXBlb2YgbnVsbCBpcyAnb2JqZWN0Jyxcbi8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cblxuLy8gTWFrZSBhbiBhcnJheSB0byBob2xkIHRoZSBwYXJ0aWFsIHJlc3VsdHMgb2Ygc3RyaW5naWZ5aW5nIHRoaXMgb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4vLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXG4vLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4vLyBmb3Igbm9uLUpTT04gdmFsdWVzLlxuXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyAnW10nXG4gICAgICAgICAgICAgICAgICAgIDogZ2FwXG4gICAgICAgICAgICAgICAgICAgID8gJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXSdcbiAgICAgICAgICAgICAgICAgICAgOiAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcFtpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4vLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cblxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyAne30nXG4gICAgICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgICAgICA/ICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nXG4gICAgICAgICAgICAgICAgOiAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gJyc7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbi8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG5cbiAgICAgICAgICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4vLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuXG4gICAgICAgICAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgSlNPTi5wYXJzZSA9IGZ1bmN0aW9uICh0ZXh0LCByZXZpdmVyKSB7XG5cbi8vIFRoZSBwYXJzZSBtZXRob2QgdGFrZXMgYSB0ZXh0IGFuZCBhbiBvcHRpb25hbCByZXZpdmVyIGZ1bmN0aW9uLCBhbmQgcmV0dXJuc1xuLy8gYSBKYXZhU2NyaXB0IHZhbHVlIGlmIHRoZSB0ZXh0IGlzIGEgdmFsaWQgSlNPTiB0ZXh0LlxuXG4gICAgICAgICAgICB2YXIgajtcblxuICAgICAgICAgICAgZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuXG4vLyBUaGUgd2FsayBtZXRob2QgaXMgdXNlZCB0byByZWN1cnNpdmVseSB3YWxrIHRoZSByZXN1bHRpbmcgc3RydWN0dXJlIHNvXG4vLyB0aGF0IG1vZGlmaWNhdGlvbnMgY2FuIGJlIG1hZGUuXG5cbiAgICAgICAgICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG5cbi8vIFBhcnNpbmcgaGFwcGVucyBpbiBmb3VyIHN0YWdlcy4gSW4gdGhlIGZpcnN0IHN0YWdlLCB3ZSByZXBsYWNlIGNlcnRhaW5cbi8vIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMuIEphdmFTY3JpcHQgaGFuZGxlcyBtYW55IGNoYXJhY3RlcnNcbi8vIGluY29ycmVjdGx5LCBlaXRoZXIgc2lsZW50bHkgZGVsZXRpbmcgdGhlbSwgb3IgdHJlYXRpbmcgdGhlbSBhcyBsaW5lIGVuZGluZ3MuXG5cbiAgICAgICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XG4gICAgICAgICAgICBjeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKGN4LnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGN4LCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCAnKCknIGFuZCAnbmV3J1xuLy8gYmVjYXVzZSB0aGV5IGNhbiBjYXVzZSBpbnZvY2F0aW9uLCBhbmQgJz0nIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoICdAJyAoYSBub24tSlNPTiBjaGFyYWN0ZXIpLiBTZWNvbmQsIHdlXG4vLyByZXBsYWNlIGFsbCBzaW1wbGUgdmFsdWUgdG9rZW5zIHdpdGggJ10nIGNoYXJhY3RlcnMuIFRoaXJkLCB3ZSBkZWxldGUgYWxsXG4vLyBvcGVuIGJyYWNrZXRzIHRoYXQgZm9sbG93IGEgY29sb24gb3IgY29tbWEgb3IgdGhhdCBiZWdpbiB0aGUgdGV4dC4gRmluYWxseSxcbi8vIHdlIGxvb2sgdG8gc2VlIHRoYXQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFyZSBvbmx5IHdoaXRlc3BhY2Ugb3IgJ10nIG9yXG4vLyAnLCcgb3IgJzonIG9yICd7JyBvciAnfScuIElmIHRoYXQgaXMgc28sIHRoZW4gdGhlIHRleHQgaXMgc2FmZSBmb3IgZXZhbC5cblxuICAgICAgICAgICAgaWYgKC9eW1xcXSw6e31cXHNdKiQvXG4gICAgICAgICAgICAgICAgICAgIC50ZXN0KHRleHQucmVwbGFjZSgvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLCAnQCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csICddJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZywgJycpKSkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlICd7JyBvcGVyYXRvciBpcyBzdWJqZWN0IHRvIGEgc3ludGFjdGljIGFtYmlndWl0eVxuLy8gaW4gSmF2YVNjcmlwdDogaXQgY2FuIGJlZ2luIGEgYmxvY2sgb3IgYW4gb2JqZWN0IGxpdGVyYWwuIFdlIHdyYXAgdGhlIHRleHRcbi8vIGluIHBhcmVucyB0byBlbGltaW5hdGUgdGhlIGFtYmlndWl0eS5cblxuICAgICAgICAgICAgICAgIGogPSBldmFsKCcoJyArIHRleHQgKyAnKScpO1xuXG4vLyBJbiB0aGUgb3B0aW9uYWwgZm91cnRoIHN0YWdlLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLCBwYXNzaW5nXG4vLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gd2Fsayh7Jyc6IGp9LCAnJylcbiAgICAgICAgICAgICAgICAgICAgOiBqO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgdGV4dCBpcyBub3QgSlNPTiBwYXJzZWFibGUsIHRoZW4gYSBTeW50YXhFcnJvciBpcyB0aHJvd24uXG5cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSlNPTi5wYXJzZScpO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7LyoqXG4gKiBIaXN0b3J5LmpzIGpRdWVyeSBBZGFwdGVyXG4gKiBAYXV0aG9yIEJlbmphbWluIEFydGh1ciBMdXB0b24gPGNvbnRhY3RAYmFsdXB0b24uY29tPlxuICogQGNvcHlyaWdodCAyMDEwLTIwMTEgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG4gKiBAbGljZW5zZSBOZXcgQlNEIExpY2Vuc2UgPGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL0JTRC8+XG4gKi9cblxuLy8gQ2xvc3VyZVxuKGZ1bmN0aW9uKHdpbmRvdyx1bmRlZmluZWQpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBMb2NhbGlzZSBHbG9iYWxzXG5cdHZhclxuXHRcdEhpc3RvcnkgPSB3aW5kb3cuSGlzdG9yeSA9IHdpbmRvdy5IaXN0b3J5fHx7fSxcblx0XHRqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xuXG5cdC8vIENoZWNrIEV4aXN0ZW5jZVxuXHRpZiAoIHR5cGVvZiBIaXN0b3J5LkFkYXB0ZXIgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdHRocm93IG5ldyBFcnJvcignSGlzdG9yeS5qcyBBZGFwdGVyIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkLi4uJyk7XG5cdH1cblxuXHQvLyBBZGQgdGhlIEFkYXB0ZXJcblx0SGlzdG9yeS5BZGFwdGVyID0ge1xuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuQWRhcHRlci5iaW5kKGVsLGV2ZW50LGNhbGxiYWNrKVxuXHRcdCAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IGVsXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gY3VzdG9tIGFuZCBzdGFuZGFyZCBldmVudHNcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuXHRcdCAqIEByZXR1cm4ge3ZvaWR9XG5cdFx0ICovXG5cdFx0YmluZDogZnVuY3Rpb24oZWwsZXZlbnQsY2FsbGJhY2spe1xuXHRcdFx0alF1ZXJ5KGVsKS5iaW5kKGV2ZW50LGNhbGxiYWNrKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIoZWwsZXZlbnQpXG5cdFx0ICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWxcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBjdXN0b20gYW5kIHN0YW5kYXJkIGV2ZW50c1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gZXh0cmEgLSBhIG9iamVjdCBvZiBleHRyYSBldmVudCBkYXRhIChvcHRpb25hbClcblx0XHQgKiBAcmV0dXJuIHt2b2lkfVxuXHRcdCAqL1xuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKGVsLGV2ZW50LGV4dHJhKXtcblx0XHRcdGpRdWVyeShlbCkudHJpZ2dlcihldmVudCxleHRyYSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuQWRhcHRlci5leHRyYWN0RXZlbnREYXRhKGtleSxldmVudCxleHRyYSlcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0ga2V5IGZvciB0aGUgZXZlbnQgZGF0YSB0byBleHRyYWN0XG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gY3VzdG9tIGFuZCBzdGFuZGFyZCBldmVudHNcblx0XHQgKiBAcGFyYW0ge09iamVjdD19IGV4dHJhIC0gYSBvYmplY3Qgb2YgZXh0cmEgZXZlbnQgZGF0YSAob3B0aW9uYWwpXG5cdFx0ICogQHJldHVybiB7bWl4ZWR9XG5cdFx0ICovXG5cdFx0ZXh0cmFjdEV2ZW50RGF0YTogZnVuY3Rpb24oa2V5LGV2ZW50LGV4dHJhKXtcblx0XHRcdC8vIGpRdWVyeSBOYXRpdmUgdGhlbiBqUXVlcnkgQ3VzdG9tXG5cdFx0XHR2YXIgcmVzdWx0ID0gKGV2ZW50ICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudFtrZXldKSB8fCAoZXh0cmEgJiYgZXh0cmFba2V5XSkgfHwgdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuQWRhcHRlci5vbkRvbUxvYWQoY2FsbGJhY2spXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcblx0XHQgKiBAcmV0dXJuIHt2b2lkfVxuXHRcdCAqL1xuXHRcdG9uRG9tTG9hZDogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdGpRdWVyeShjYWxsYmFjayk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFRyeSBhbmQgSW5pdGlhbGlzZSBIaXN0b3J5XG5cdGlmICggdHlwZW9mIEhpc3RvcnkuaW5pdCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0SGlzdG9yeS5pbml0KCk7XG5cdH1cblxufSkod2luZG93KTtcblxuLyoqXG4gKiBIaXN0b3J5LmpzIEhUTUw0IFN1cHBvcnRcbiAqIERlcGVuZHMgb24gdGhlIEhUTUw1IFN1cHBvcnRcbiAqIEBhdXRob3IgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG4gKiBAY29weXJpZ2h0IDIwMTAtMjAxMSBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cbiAqIEBsaWNlbnNlIE5ldyBCU0QgTGljZW5zZSA8aHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvQlNELz5cbiAqL1xuXG4oZnVuY3Rpb24od2luZG93LHVuZGVmaW5lZCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQvLyBJbml0aWFsaXNlXG5cblx0Ly8gTG9jYWxpc2UgR2xvYmFsc1xuXHR2YXJcblx0XHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCwgLy8gTWFrZSBzdXJlIHdlIGFyZSB1c2luZyB0aGUgY29ycmVjdCBkb2N1bWVudFxuXHRcdHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dHx8c2V0VGltZW91dCxcblx0XHRjbGVhclRpbWVvdXQgPSB3aW5kb3cuY2xlYXJUaW1lb3V0fHxjbGVhclRpbWVvdXQsXG5cdFx0c2V0SW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWx8fHNldEludGVydmFsLFxuXHRcdEhpc3RvcnkgPSB3aW5kb3cuSGlzdG9yeSA9IHdpbmRvdy5IaXN0b3J5fHx7fTsgLy8gUHVibGljIEhpc3RvcnkgT2JqZWN0XG5cblx0Ly8gQ2hlY2sgRXhpc3RlbmNlXG5cdGlmICggdHlwZW9mIEhpc3RvcnkuaW5pdEh0bWw0ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgSFRNTDQgU3VwcG9ydCBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZC4uLicpO1xuXHR9XG5cblxuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0Ly8gSW5pdGlhbGlzZSBIVE1MNCBTdXBwb3J0XG5cblx0Ly8gSW5pdGlhbGlzZSBIVE1MNCBTdXBwb3J0XG5cdEhpc3RvcnkuaW5pdEh0bWw0ID0gZnVuY3Rpb24oKXtcblx0XHQvLyBJbml0aWFsaXNlXG5cdFx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0SHRtbDQuaW5pdGlhbGl6ZWQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0Ly8gQWxyZWFkeSBMb2FkZWRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRIaXN0b3J5LmluaXRIdG1sNC5pbml0aWFsaXplZCA9IHRydWU7XG5cdFx0fVxuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFByb3BlcnRpZXNcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZW5hYmxlZFxuXHRcdCAqIElzIEhpc3RvcnkgZW5hYmxlZD9cblx0XHQgKi9cblx0XHRIaXN0b3J5LmVuYWJsZWQgPSB0cnVlO1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEhhc2ggU3RvcmFnZVxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zYXZlZEhhc2hlc1xuXHRcdCAqIFN0b3JlIHRoZSBoYXNoZXMgaW4gYW4gYXJyYXlcblx0XHQgKi9cblx0XHRIaXN0b3J5LnNhdmVkSGFzaGVzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmlzTGFzdEhhc2gobmV3SGFzaClcblx0XHQgKiBDaGVja3MgaWYgdGhlIGhhc2ggaXMgdGhlIGxhc3QgaGFzaFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuZXdIYXNoXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaXNMYXN0SGFzaCA9IGZ1bmN0aW9uKG5ld0hhc2gpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIG9sZEhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeUluZGV4KCksXG5cdFx0XHRcdGlzTGFzdDtcblxuXHRcdFx0Ly8gQ2hlY2tcblx0XHRcdGlzTGFzdCA9IG5ld0hhc2ggPT09IG9sZEhhc2g7XG5cblx0XHRcdC8vIFJldHVybiBpc0xhc3Rcblx0XHRcdHJldHVybiBpc0xhc3Q7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNIYXNoRXF1YWwobmV3SGFzaCwgb2xkSGFzaClcblx0XHQgKiBDaGVja3MgdG8gc2VlIGlmIHR3byBoYXNoZXMgYXJlIGZ1bmN0aW9uYWxseSBlcXVhbFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuZXdIYXNoXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG9sZEhhc2hcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc0hhc2hFcXVhbCA9IGZ1bmN0aW9uKG5ld0hhc2gsIG9sZEhhc2gpe1xuXHRcdFx0bmV3SGFzaCA9IGVuY29kZVVSSUNvbXBvbmVudChuZXdIYXNoKS5yZXBsYWNlKC8lMjUvZywgXCIlXCIpO1xuXHRcdFx0b2xkSGFzaCA9IGVuY29kZVVSSUNvbXBvbmVudChvbGRIYXNoKS5yZXBsYWNlKC8lMjUvZywgXCIlXCIpO1xuXHRcdFx0cmV0dXJuIG5ld0hhc2ggPT09IG9sZEhhc2g7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc2F2ZUhhc2gobmV3SGFzaClcblx0XHQgKiBQdXNoIGEgSGFzaFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuZXdIYXNoXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkuc2F2ZUhhc2ggPSBmdW5jdGlvbihuZXdIYXNoKXtcblx0XHRcdC8vIENoZWNrIEhhc2hcblx0XHRcdGlmICggSGlzdG9yeS5pc0xhc3RIYXNoKG5ld0hhc2gpICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1c2ggdGhlIEhhc2hcblx0XHRcdEhpc3Rvcnkuc2F2ZWRIYXNoZXMucHVzaChuZXdIYXNoKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEhhc2hCeUluZGV4KClcblx0XHQgKiBHZXRzIGEgaGFzaCBieSB0aGUgaW5kZXhcblx0XHQgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4XG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0SGFzaEJ5SW5kZXggPSBmdW5jdGlvbihpbmRleCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgaGFzaCA9IG51bGw7XG5cblx0XHRcdC8vIEhhbmRsZVxuXHRcdFx0aWYgKCB0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHQvLyBHZXQgdGhlIGxhc3QgaW5zZXJ0ZWRcblx0XHRcdFx0aGFzaCA9IEhpc3Rvcnkuc2F2ZWRIYXNoZXNbSGlzdG9yeS5zYXZlZEhhc2hlcy5sZW5ndGgtMV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHQvLyBHZXQgZnJvbSB0aGUgZW5kXG5cdFx0XHRcdGhhc2ggPSBIaXN0b3J5LnNhdmVkSGFzaGVzW0hpc3Rvcnkuc2F2ZWRIYXNoZXMubGVuZ3RoK2luZGV4XTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBHZXQgZnJvbSB0aGUgYmVnaW5uaW5nXG5cdFx0XHRcdGhhc2ggPSBIaXN0b3J5LnNhdmVkSGFzaGVzW2luZGV4XTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIGhhc2hcblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gRGlzY2FyZGVkIFN0YXRlc1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kaXNjYXJkZWRIYXNoZXNcblx0XHQgKiBBIGhhc2hlZCBhcnJheSBvZiBkaXNjYXJkZWQgaGFzaGVzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kaXNjYXJkZWRIYXNoZXMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZGlzY2FyZGVkU3RhdGVzXG5cdFx0ICogQSBoYXNoZWQgYXJyYXkgb2YgZGlzY2FyZGVkIHN0YXRlc1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZGlzY2FyZGVkU3RhdGVzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRpc2NhcmRTdGF0ZShTdGF0ZSlcblx0XHQgKiBEaXNjYXJkcyB0aGUgc3RhdGUgYnkgaWdub3JpbmcgaXQgdGhyb3VnaCBIaXN0b3J5XG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFN0YXRlXG5cdFx0ICogQHJldHVybiB7dHJ1ZX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmRpc2NhcmRTdGF0ZSA9IGZ1bmN0aW9uKGRpc2NhcmRlZFN0YXRlLGZvcndhcmRTdGF0ZSxiYWNrU3RhdGUpe1xuXHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmRpc2NhcmRTdGF0ZScsIGFyZ3VtZW50cyk7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgZGlzY2FyZGVkU3RhdGVIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShkaXNjYXJkZWRTdGF0ZSksXG5cdFx0XHRcdGRpc2NhcmRPYmplY3Q7XG5cblx0XHRcdC8vIENyZWF0ZSBEaXNjYXJkIE9iamVjdFxuXHRcdFx0ZGlzY2FyZE9iamVjdCA9IHtcblx0XHRcdFx0J2Rpc2NhcmRlZFN0YXRlJzogZGlzY2FyZGVkU3RhdGUsXG5cdFx0XHRcdCdiYWNrU3RhdGUnOiBiYWNrU3RhdGUsXG5cdFx0XHRcdCdmb3J3YXJkU3RhdGUnOiBmb3J3YXJkU3RhdGVcblx0XHRcdH07XG5cblx0XHRcdC8vIEFkZCB0byBEaXNjYXJkZWRTdGF0ZXNcblx0XHRcdEhpc3RvcnkuZGlzY2FyZGVkU3RhdGVzW2Rpc2NhcmRlZFN0YXRlSGFzaF0gPSBkaXNjYXJkT2JqZWN0O1xuXG5cdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZGlzY2FyZEhhc2goaGFzaClcblx0XHQgKiBEaXNjYXJkcyB0aGUgaGFzaCBieSBpZ25vcmluZyBpdCB0aHJvdWdoIEhpc3Rvcnlcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuXHRcdCAqIEByZXR1cm4ge3RydWV9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kaXNjYXJkSGFzaCA9IGZ1bmN0aW9uKGRpc2NhcmRlZEhhc2gsZm9yd2FyZFN0YXRlLGJhY2tTdGF0ZSl7XG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuZGlzY2FyZFN0YXRlJywgYXJndW1lbnRzKTtcblx0XHRcdC8vIENyZWF0ZSBEaXNjYXJkIE9iamVjdFxuXHRcdFx0dmFyIGRpc2NhcmRPYmplY3QgPSB7XG5cdFx0XHRcdCdkaXNjYXJkZWRIYXNoJzogZGlzY2FyZGVkSGFzaCxcblx0XHRcdFx0J2JhY2tTdGF0ZSc6IGJhY2tTdGF0ZSxcblx0XHRcdFx0J2ZvcndhcmRTdGF0ZSc6IGZvcndhcmRTdGF0ZVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gQWRkIHRvIGRpc2NhcmRlZEhhc2hcblx0XHRcdEhpc3RvcnkuZGlzY2FyZGVkSGFzaGVzW2Rpc2NhcmRlZEhhc2hdID0gZGlzY2FyZE9iamVjdDtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRpc2NhcmRlZFN0YXRlKFN0YXRlKVxuXHRcdCAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHN0YXRlIGlzIGRpc2NhcmRlZFxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge2Jvb2x9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kaXNjYXJkZWRTdGF0ZSA9IGZ1bmN0aW9uKFN0YXRlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZUhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKFN0YXRlKSxcblx0XHRcdFx0ZGlzY2FyZGVkO1xuXG5cdFx0XHQvLyBDaGVja1xuXHRcdFx0ZGlzY2FyZGVkID0gSGlzdG9yeS5kaXNjYXJkZWRTdGF0ZXNbU3RhdGVIYXNoXXx8ZmFsc2U7XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gZGlzY2FyZGVkO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRpc2NhcmRlZEhhc2goaGFzaClcblx0XHQgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBzdGF0ZSBpcyBkaXNjYXJkZWRcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gU3RhdGVcblx0XHQgKiBAcmV0dXJuIHtib29sfVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZGlzY2FyZGVkSGFzaCA9IGZ1bmN0aW9uKGhhc2gpe1xuXHRcdFx0Ly8gQ2hlY2tcblx0XHRcdHZhciBkaXNjYXJkZWQgPSBIaXN0b3J5LmRpc2NhcmRlZEhhc2hlc1toYXNoXXx8ZmFsc2U7XG5cblx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gZGlzY2FyZGVkO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnJlY3ljbGVTdGF0ZShTdGF0ZSlcblx0XHQgKiBBbGxvd3MgYSBkaXNjYXJkZWQgc3RhdGUgdG8gYmUgdXNlZCBhZ2FpblxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdCAqIEByZXR1cm4ge3RydWV9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5yZWN5Y2xlU3RhdGUgPSBmdW5jdGlvbihTdGF0ZSl7XG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucmVjeWNsZVN0YXRlJywgYXJndW1lbnRzKTtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBTdGF0ZUhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKFN0YXRlKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gRGlzY2FyZGVkU3RhdGVzXG5cdFx0XHRpZiAoIEhpc3RvcnkuZGlzY2FyZGVkU3RhdGUoU3RhdGUpICkge1xuXHRcdFx0XHRkZWxldGUgSGlzdG9yeS5kaXNjYXJkZWRTdGF0ZXNbU3RhdGVIYXNoXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSFRNTDQgSGFzaENoYW5nZSBTdXBwb3J0XG5cblx0XHRpZiAoIEhpc3RvcnkuZW11bGF0ZWQuaGFzaENoYW5nZSApIHtcblx0XHRcdC8qXG5cdFx0XHQgKiBXZSBtdXN0IGVtdWxhdGUgdGhlIEhUTUw0IEhhc2hDaGFuZ2UgU3VwcG9ydCBieSBtYW51YWxseSBjaGVja2luZyBmb3IgaGFzaCBjaGFuZ2VzXG5cdFx0XHQgKi9cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIaXN0b3J5Lmhhc2hDaGFuZ2VJbml0KClcblx0XHRcdCAqIEluaXQgdGhlIEhhc2hDaGFuZ2UgRW11bGF0aW9uXG5cdFx0XHQgKi9cblx0XHRcdEhpc3RvcnkuaGFzaENoYW5nZUluaXQgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHQvLyBEZWZpbmUgb3VyIENoZWNrZXIgRnVuY3Rpb25cblx0XHRcdFx0SGlzdG9yeS5jaGVja2VyRnVuY3Rpb24gPSBudWxsO1xuXG5cdFx0XHRcdC8vIERlZmluZSBzb21lIHZhcmlhYmxlcyB0aGF0IHdpbGwgaGVscCBpbiBvdXIgY2hlY2tlciBmdW5jdGlvblxuXHRcdFx0XHR2YXIgbGFzdERvY3VtZW50SGFzaCA9ICcnLFxuXHRcdFx0XHRcdGlmcmFtZUlkLCBpZnJhbWUsXG5cdFx0XHRcdFx0bGFzdElmcmFtZUhhc2gsIGNoZWNrZXJSdW5uaW5nLFxuXHRcdFx0XHRcdHN0YXJ0ZWRXaXRoSGFzaCA9IEJvb2xlYW4oSGlzdG9yeS5nZXRIYXNoKCkpO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3JlcigpICkge1xuXHRcdFx0XHRcdC8vIElFNiBhbmQgSUU3XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byB1c2UgYW4gaWZyYW1lIHRvIGVtdWxhdGUgdGhlIGJhY2sgYW5kIGZvcndhcmQgYnV0dG9uc1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGlGcmFtZVxuXHRcdFx0XHRcdGlmcmFtZUlkID0gJ2hpc3Rvcnlqcy1pZnJhbWUnO1xuXHRcdFx0XHRcdGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXG5cdFx0XHRcdFx0Ly8gQWRqdXN0IGlGYXJtZVxuXHRcdFx0XHRcdC8vIElFIDYgcmVxdWlyZXMgaWZyYW1lIHRvIGhhdmUgYSBzcmMgb24gSFRUUFMgcGFnZXMsIG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGFcblx0XHRcdFx0XHQvLyBcIlRoaXMgcGFnZSBjb250YWlucyBib3RoIHNlY3VyZSBhbmQgbm9uc2VjdXJlIGl0ZW1zXCIgd2FybmluZy5cblx0XHRcdFx0XHRpZnJhbWUuc2V0QXR0cmlidXRlKCdpZCcsIGlmcmFtZUlkKTtcblx0XHRcdFx0XHRpZnJhbWUuc2V0QXR0cmlidXRlKCdzcmMnLCAnIycpO1xuXHRcdFx0XHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG5cdFx0XHRcdFx0Ly8gQXBwZW5kIGlGcmFtZVxuXHRcdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBpbml0aWFsIGhpc3RvcnkgZW50cnlcblx0XHRcdFx0XHRpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XG5cdFx0XHRcdFx0aWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcblxuXHRcdFx0XHRcdC8vIERlZmluZSBzb21lIHZhcmlhYmxlcyB0aGF0IHdpbGwgaGVscCBpbiBvdXIgY2hlY2tlciBmdW5jdGlvblxuXHRcdFx0XHRcdGxhc3RJZnJhbWVIYXNoID0gJyc7XG5cdFx0XHRcdFx0Y2hlY2tlclJ1bm5pbmcgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIERlZmluZSB0aGUgY2hlY2tlciBmdW5jdGlvblxuXHRcdFx0XHRcdEhpc3RvcnkuY2hlY2tlckZ1bmN0aW9uID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdC8vIENoZWNrIFJ1bm5pbmdcblx0XHRcdFx0XHRcdGlmICggY2hlY2tlclJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVXBkYXRlIFJ1bm5pbmdcblx0XHRcdFx0XHRcdGNoZWNrZXJSdW5uaW5nID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0Ly8gRmV0Y2hcblx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0XHRkb2N1bWVudEhhc2ggPSBIaXN0b3J5LmdldEhhc2goKSxcblx0XHRcdFx0XHRcdFx0aWZyYW1lSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaChpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudCk7XG5cblx0XHRcdFx0XHRcdC8vIFRoZSBEb2N1bWVudCBIYXNoIGhhcyBjaGFuZ2VkIChhcHBsaWNhdGlvbiBjYXVzZWQpXG5cdFx0XHRcdFx0XHRpZiAoIGRvY3VtZW50SGFzaCAhPT0gbGFzdERvY3VtZW50SGFzaCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gRXF1YWxpc2Vcblx0XHRcdFx0XHRcdFx0bGFzdERvY3VtZW50SGFzaCA9IGRvY3VtZW50SGFzaDtcblxuXHRcdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBoaXN0b3J5IGVudHJ5IGluIHRoZSBpZnJhbWVcblx0XHRcdFx0XHRcdFx0aWYgKCBpZnJhbWVIYXNoICE9PSBkb2N1bWVudEhhc2ggKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdoYXNoY2hhbmdlLmNoZWNrZXI6IGlmcmFtZSBoYXNoIGNoYW5nZScsICdkb2N1bWVudEhhc2ggKG5ldyk6JywgZG9jdW1lbnRIYXNoLCAnaWZyYW1lSGFzaCAob2xkKTonLCBpZnJhbWVIYXNoKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEVxdWFsaXNlXG5cdFx0XHRcdFx0XHRcdFx0bGFzdElmcmFtZUhhc2ggPSBpZnJhbWVIYXNoID0gZG9jdW1lbnRIYXNoO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIEhpc3RvcnkgRW50cnlcblx0XHRcdFx0XHRcdFx0XHRpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVwZGF0ZSB0aGUgaWZyYW1lJ3MgaGFzaFxuXHRcdFx0XHRcdFx0XHRcdGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmxvY2F0aW9uLmhhc2ggPSBIaXN0b3J5LmVzY2FwZUhhc2goZG9jdW1lbnRIYXNoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIFRyaWdnZXIgSGFzaGNoYW5nZSBFdmVudFxuXHRcdFx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ2hhc2hjaGFuZ2UnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVGhlIGlGcmFtZSBIYXNoIGhhcyBjaGFuZ2VkIChiYWNrIGJ1dHRvbiBjYXVzZWQpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICggaWZyYW1lSGFzaCAhPT0gbGFzdElmcmFtZUhhc2ggKSB7XG5cdFx0XHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnaGFzaGNoYW5nZS5jaGVja2VyOiBpZnJhbWUgaGFzaCBvdXQgb2Ygc3luYycsICdpZnJhbWVIYXNoIChuZXcpOicsIGlmcmFtZUhhc2gsICdkb2N1bWVudEhhc2ggKG9sZCk6JywgZG9jdW1lbnRIYXNoKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBFcXVhbGlzZVxuXHRcdFx0XHRcdFx0XHRsYXN0SWZyYW1lSGFzaCA9IGlmcmFtZUhhc2g7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyBpZnJhbWUgaGFzaCB0aGF0IG1lYW5zIHdlJ3JlIGF0IHRoZSBvcmlnaW5hbFxuXHRcdFx0XHRcdFx0XHQvLyBpZnJhbWUgc3RhdGUuXG5cdFx0XHRcdFx0XHRcdC8vIEFuZCBpZiB0aGVyZSB3YXMgYSBoYXNoIG9uIHRoZSBvcmlnaW5hbCByZXF1ZXN0LCB0aGUgb3JpZ2luYWxcblx0XHRcdFx0XHRcdFx0Ly8gaWZyYW1lIHN0YXRlIHdhcyByZXBsYWNlZCBpbnN0YW50bHksIHNvIHNraXAgdGhpcyBzdGF0ZSBhbmQgdGFrZVxuXHRcdFx0XHRcdFx0XHQvLyB0aGUgdXNlciBiYWNrIHRvIHdoZXJlIHRoZXkgY2FtZSBmcm9tLlxuXHRcdFx0XHRcdFx0XHRpZiAoc3RhcnRlZFdpdGhIYXNoICYmIGlmcmFtZUhhc2ggPT09ICcnKSB7XG5cdFx0XHRcdFx0XHRcdFx0SGlzdG9yeS5iYWNrKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBIYXNoXG5cdFx0XHRcdFx0XHRcdFx0SGlzdG9yeS5zZXRIYXNoKGlmcmFtZUhhc2gsZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFJlc2V0IFJ1bm5pbmdcblx0XHRcdFx0XHRcdGNoZWNrZXJSdW5uaW5nID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIFdlIGFyZSBub3QgSUVcblx0XHRcdFx0XHQvLyBGaXJlZm94IDEgb3IgMiwgT3BlcmFcblxuXHRcdFx0XHRcdC8vIERlZmluZSB0aGUgY2hlY2tlciBmdW5jdGlvblxuXHRcdFx0XHRcdEhpc3RvcnkuY2hlY2tlckZ1bmN0aW9uID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdC8vIFByZXBhcmVcblx0XHRcdFx0XHRcdHZhciBkb2N1bWVudEhhc2ggPSBIaXN0b3J5LmdldEhhc2goKXx8Jyc7XG5cblx0XHRcdFx0XHRcdC8vIFRoZSBEb2N1bWVudCBIYXNoIGhhcyBjaGFuZ2VkIChhcHBsaWNhdGlvbiBjYXVzZWQpXG5cdFx0XHRcdFx0XHRpZiAoIGRvY3VtZW50SGFzaCAhPT0gbGFzdERvY3VtZW50SGFzaCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gRXF1YWxpc2Vcblx0XHRcdFx0XHRcdFx0bGFzdERvY3VtZW50SGFzaCA9IGRvY3VtZW50SGFzaDtcblxuXHRcdFx0XHRcdFx0XHQvLyBUcmlnZ2VyIEhhc2hjaGFuZ2UgRXZlbnRcblx0XHRcdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdoYXNoY2hhbmdlJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgdGhlIGNoZWNrZXIgZnVuY3Rpb25cblx0XHRcdFx0SGlzdG9yeS5pbnRlcnZhbExpc3QucHVzaChzZXRJbnRlcnZhbChIaXN0b3J5LmNoZWNrZXJGdW5jdGlvbiwgSGlzdG9yeS5vcHRpb25zLmhhc2hDaGFuZ2VJbnRlcnZhbCkpO1xuXG5cdFx0XHRcdC8vIERvbmVcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9OyAvLyBIaXN0b3J5Lmhhc2hDaGFuZ2VJbml0XG5cblx0XHRcdC8vIEJpbmQgaGFzaENoYW5nZUluaXRcblx0XHRcdEhpc3RvcnkuQWRhcHRlci5vbkRvbUxvYWQoSGlzdG9yeS5oYXNoQ2hhbmdlSW5pdCk7XG5cblx0XHR9IC8vIEhpc3RvcnkuZW11bGF0ZWQuaGFzaENoYW5nZVxuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEhUTUw1IFN0YXRlIFN1cHBvcnRcblxuXHRcdC8vIE5vbi1OYXRpdmUgcHVzaFN0YXRlIEltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdC8qXG5cdFx0XHQgKiBXZSBtdXN0IGVtdWxhdGUgdGhlIEhUTUw1IFN0YXRlIE1hbmFnZW1lbnQgYnkgdXNpbmcgSFRNTDQgSGFzaENoYW5nZVxuXHRcdFx0ICovXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSGlzdG9yeS5vbkhhc2hDaGFuZ2UoZXZlbnQpXG5cdFx0XHQgKiBUcmlnZ2VyIEhUTUw1J3Mgd2luZG93Lm9ucG9wc3RhdGUgdmlhIEhUTUw0IEhhc2hDaGFuZ2UgU3VwcG9ydFxuXHRcdFx0ICovXG5cdFx0XHRIaXN0b3J5Lm9uSGFzaENoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KXtcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uSGFzaENoYW5nZScsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0XHR2YXIgY3VycmVudFVybCA9ICgoZXZlbnQgJiYgZXZlbnQubmV3VVJMKSB8fCBIaXN0b3J5LmdldExvY2F0aW9uSHJlZigpKSxcblx0XHRcdFx0XHRjdXJyZW50SGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5VXJsKGN1cnJlbnRVcmwpLFxuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZSA9IG51bGwsXG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlSGFzaCA9IG51bGwsXG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlSGFzaEV4aXRzID0gbnVsbCxcblx0XHRcdFx0XHRkaXNjYXJkT2JqZWN0O1xuXG5cdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSB0aGUgc2FtZSBzdGF0ZVxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0SGFzaChjdXJyZW50SGFzaCkgKSB7XG5cdFx0XHRcdFx0Ly8gVGhlcmUgaGFzIGJlZW4gbm8gY2hhbmdlIChqdXN0IHRoZSBwYWdlJ3MgaGFzaCBoYXMgZmluYWxseSBwcm9wYWdhdGVkKVxuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5vbkhhc2hDaGFuZ2U6IG5vIGNoYW5nZScpO1xuXHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzZXQgdGhlIGRvdWJsZSBjaGVja1xuXHRcdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ29tcGxldGUoKTtcblxuXHRcdFx0XHQvLyBTdG9yZSBvdXIgbG9jYXRpb24gZm9yIHVzZSBpbiBkZXRlY3RpbmcgYmFjay9mb3J3YXJkIGRpcmVjdGlvblxuXHRcdFx0XHRIaXN0b3J5LnNhdmVIYXNoKGN1cnJlbnRIYXNoKTtcblxuXHRcdFx0XHQvLyBFeHBhbmQgSGFzaFxuXHRcdFx0XHRpZiAoIGN1cnJlbnRIYXNoICYmIEhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvcihjdXJyZW50SGFzaCkgKSB7XG5cdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5Lm9uSGFzaENoYW5nZTogdHJhZGl0aW9uYWwgYW5jaG9yJywgY3VycmVudEhhc2gpO1xuXHRcdFx0XHRcdC8vIFRyYWRpdGlvbmFsIEFuY2hvciBIYXNoXG5cdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdhbmNob3JjaGFuZ2UnKTtcblx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSBTdGF0ZVxuXHRcdFx0XHRjdXJyZW50U3RhdGUgPSBIaXN0b3J5LmV4dHJhY3RTdGF0ZShIaXN0b3J5LmdldEZ1bGxVcmwoY3VycmVudEhhc2h8fEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpLHRydWUpO1xuXG5cdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSB0aGUgc2FtZSBzdGF0ZVxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShjdXJyZW50U3RhdGUpICkge1xuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5vbkhhc2hDaGFuZ2U6IG5vIGNoYW5nZScpO1xuXHRcdFx0XHRcdC8vIFRoZXJlIGhhcyBiZWVuIG5vIGNoYW5nZSAoanVzdCB0aGUgcGFnZSdzIGhhc2ggaGFzIGZpbmFsbHkgcHJvcGFnYXRlZClcblx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgc3RhdGUgSGFzaFxuXHRcdFx0XHRjdXJyZW50U3RhdGVIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShjdXJyZW50U3RhdGUpO1xuXG5cdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSBEaXNjYXJkZWRTdGF0ZVxuXHRcdFx0XHRkaXNjYXJkT2JqZWN0ID0gSGlzdG9yeS5kaXNjYXJkZWRTdGF0ZShjdXJyZW50U3RhdGUpO1xuXHRcdFx0XHRpZiAoIGRpc2NhcmRPYmplY3QgKSB7XG5cdFx0XHRcdFx0Ly8gSWdub3JlIHRoaXMgc3RhdGUgYXMgaXQgaGFzIGJlZW4gZGlzY2FyZGVkIGFuZCBnbyBiYWNrIHRvIHRoZSBzdGF0ZSBiZWZvcmUgaXRcblx0XHRcdFx0XHRpZiAoIEhpc3RvcnkuZ2V0SGFzaEJ5SW5kZXgoLTIpID09PSBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKGRpc2NhcmRPYmplY3QuZm9yd2FyZFN0YXRlKSApIHtcblx0XHRcdFx0XHRcdC8vIFdlIGFyZSBnb2luZyBiYWNrd2FyZHNcblx0XHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5vbkhhc2hDaGFuZ2U6IGdvIGJhY2t3YXJkcycpO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5iYWNrKGZhbHNlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gV2UgYXJlIGdvaW5nIGZvcndhcmRzXG5cdFx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25IYXNoQ2hhbmdlOiBnbyBmb3J3YXJkcycpO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5mb3J3YXJkKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHVzaCB0aGUgbmV3IEhUTUw1IFN0YXRlXG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5vbkhhc2hDaGFuZ2U6IHN1Y2Nlc3MgaGFzaGNoYW5nZScpO1xuXHRcdFx0XHRIaXN0b3J5LnB1c2hTdGF0ZShjdXJyZW50U3RhdGUuZGF0YSxjdXJyZW50U3RhdGUudGl0bGUsZW5jb2RlVVJJKGN1cnJlbnRTdGF0ZS51cmwpLGZhbHNlKTtcblxuXHRcdFx0XHQvLyBFbmQgb25IYXNoQ2hhbmdlIGNsb3N1cmVcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0SGlzdG9yeS5BZGFwdGVyLmJpbmQod2luZG93LCdoYXNoY2hhbmdlJyxIaXN0b3J5Lm9uSGFzaENoYW5nZSk7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSGlzdG9yeS5wdXNoU3RhdGUoZGF0YSx0aXRsZSx1cmwpXG5cdFx0XHQgKiBBZGQgYSBuZXcgU3RhdGUgdG8gdGhlIGhpc3Rvcnkgb2JqZWN0LCBiZWNvbWUgaXQsIGFuZCB0cmlnZ2VyIG9ucG9wc3RhdGVcblx0XHRcdCAqIFdlIGhhdmUgdG8gdHJpZ2dlciBmb3IgSFRNTDQgY29tcGF0aWJpbGl0eVxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdFx0ICogQHJldHVybiB7dHJ1ZX1cblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUgPSBmdW5jdGlvbihkYXRhLHRpdGxlLHVybCxxdWV1ZSl7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5wdXNoU3RhdGU6IGNhbGxlZCcsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0Ly8gV2UgYXNzdW1lIHRoYXQgdGhlIFVSTCBwYXNzZWQgaW4gaXMgVVJJLWVuY29kZWQsIGJ1dCB0aGlzIG1ha2VzXG5cdFx0XHRcdC8vIHN1cmUgdGhhdCBpdCdzIGZ1bGx5IFVSSSBlbmNvZGVkOyBhbnkgJyUncyB0aGF0IGFyZSBlbmNvZGVkIGFyZVxuXHRcdFx0XHQvLyBjb252ZXJ0ZWQgYmFjayBpbnRvICclJ3Ncblx0XHRcdFx0dXJsID0gZW5jb2RlVVJJKHVybCkucmVwbGFjZSgvJTI1L2csIFwiJVwiKTtcblxuXHRcdFx0XHQvLyBDaGVjayB0aGUgU3RhdGVcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmdldEhhc2hCeVVybCh1cmwpICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSGlzdG9yeS5qcyBkb2VzIG5vdCBzdXBwb3J0IHN0YXRlcyB3aXRoIGZyYWdtZW50LWlkZW50aWZpZXJzIChoYXNoZXMvYW5jaG9ycykuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdFx0aWYgKCBxdWV1ZSAhPT0gZmFsc2UgJiYgSGlzdG9yeS5idXN5KCkgKSB7XG5cdFx0XHRcdFx0Ly8gV2FpdCArIFB1c2ggdG8gUXVldWVcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiB3ZSBtdXN0IHdhaXQnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKHtcblx0XHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2s6IEhpc3RvcnkucHVzaFN0YXRlLFxuXHRcdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0cXVldWU6IHF1ZXVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFrZSBCdXN5XG5cdFx0XHRcdEhpc3RvcnkuYnVzeSh0cnVlKTtcblxuXHRcdFx0XHQvLyBGZXRjaCB0aGUgU3RhdGUgT2JqZWN0XG5cdFx0XHRcdHZhciBuZXdTdGF0ZSA9IEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QoZGF0YSx0aXRsZSx1cmwpLFxuXHRcdFx0XHRcdG5ld1N0YXRlSGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5U3RhdGUobmV3U3RhdGUpLFxuXHRcdFx0XHRcdG9sZFN0YXRlID0gSGlzdG9yeS5nZXRTdGF0ZShmYWxzZSksXG5cdFx0XHRcdFx0b2xkU3RhdGVIYXNoID0gSGlzdG9yeS5nZXRIYXNoQnlTdGF0ZShvbGRTdGF0ZSksXG5cdFx0XHRcdFx0aHRtbDRIYXNoID0gSGlzdG9yeS5nZXRIYXNoKCksXG5cdFx0XHRcdFx0d2FzRXhwZWN0ZWQgPSBIaXN0b3J5LmV4cGVjdGVkU3RhdGVJZCA9PSBuZXdTdGF0ZS5pZDtcblxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgbmV3U3RhdGVcblx0XHRcdFx0SGlzdG9yeS5zdG9yZVN0YXRlKG5ld1N0YXRlKTtcblx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBuZXdTdGF0ZS5pZDtcblxuXHRcdFx0XHQvLyBSZWN5Y2xlIHRoZSBTdGF0ZVxuXHRcdFx0XHRIaXN0b3J5LnJlY3ljbGVTdGF0ZShuZXdTdGF0ZSk7XG5cblx0XHRcdFx0Ly8gRm9yY2UgdXBkYXRlIG9mIHRoZSB0aXRsZVxuXHRcdFx0XHRIaXN0b3J5LnNldFRpdGxlKG5ld1N0YXRlKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgdGhlIHNhbWUgU3RhdGVcblx0XHRcdFx0aWYgKCBuZXdTdGF0ZUhhc2ggPT09IG9sZFN0YXRlSGFzaCApIHtcblx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkucHVzaFN0YXRlOiBubyBjaGFuZ2UnLCBuZXdTdGF0ZUhhc2gpO1xuXHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlIEhUTUw1IFN0YXRlXG5cdFx0XHRcdEhpc3Rvcnkuc2F2ZVN0YXRlKG5ld1N0YXRlKTtcblxuXHRcdFx0XHQvLyBGaXJlIEhUTUw1IEV2ZW50XG5cdFx0XHRcdGlmKCF3YXNFeHBlY3RlZClcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3N0YXRlY2hhbmdlJyk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIEhUTUw0IEhhc2hcblx0XHRcdFx0aWYgKCAhSGlzdG9yeS5pc0hhc2hFcXVhbChuZXdTdGF0ZUhhc2gsIGh0bWw0SGFzaCkgJiYgIUhpc3RvcnkuaXNIYXNoRXF1YWwobmV3U3RhdGVIYXNoLCBIaXN0b3J5LmdldFNob3J0VXJsKEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCkpKSApIHtcblx0XHRcdFx0XHRIaXN0b3J5LnNldEhhc2gobmV3U3RhdGVIYXNoLGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblxuXHRcdFx0XHQvLyBFbmQgcHVzaFN0YXRlIGNsb3N1cmVcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3RvcnkucmVwbGFjZVN0YXRlKGRhdGEsdGl0bGUsdXJsKVxuXHRcdFx0ICogUmVwbGFjZSB0aGUgU3RhdGUgYW5kIHRyaWdnZXIgb25wb3BzdGF0ZVxuXHRcdFx0ICogV2UgaGF2ZSB0byB0cmlnZ2VyIGZvciBIVE1MNCBjb21wYXRpYmlsaXR5XG5cdFx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG5cdFx0XHQgKiBAcmV0dXJuIHt0cnVlfVxuXHRcdFx0ICovXG5cdFx0XHRIaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uKGRhdGEsdGl0bGUsdXJsLHF1ZXVlKXtcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnJlcGxhY2VTdGF0ZTogY2FsbGVkJywgYXJndW1lbnRzKTtcblxuXHRcdFx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgVVJMIHBhc3NlZCBpbiBpcyBVUkktZW5jb2RlZCwgYnV0IHRoaXMgbWFrZXNcblx0XHRcdFx0Ly8gc3VyZSB0aGF0IGl0J3MgZnVsbHkgVVJJIGVuY29kZWQ7IGFueSAnJSdzIHRoYXQgYXJlIGVuY29kZWQgYXJlXG5cdFx0XHRcdC8vIGNvbnZlcnRlZCBiYWNrIGludG8gJyUnc1xuXHRcdFx0XHR1cmwgPSBlbmNvZGVVUkkodXJsKS5yZXBsYWNlKC8lMjUvZywgXCIlXCIpO1xuXG5cdFx0XHRcdC8vIENoZWNrIHRoZSBTdGF0ZVxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuZ2V0SGFzaEJ5VXJsKHVybCkgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIaXN0b3J5LmpzIGRvZXMgbm90IHN1cHBvcnQgc3RhdGVzIHdpdGggZnJhZ21lbnQtaWRlbnRpZmllcnMgKGhhc2hlcy9hbmNob3JzKS4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBRdWV1ZWluZ1xuXHRcdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5yZXBsYWNlU3RhdGU6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdFx0c2NvcGU6IEhpc3RvcnksXG5cdFx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5yZXBsYWNlU3RhdGUsXG5cdFx0XHRcdFx0XHRhcmdzOiBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIEJ1c3lcblx0XHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHRcdC8vIEZldGNoIHRoZSBTdGF0ZSBPYmplY3RzXG5cdFx0XHRcdHZhciBuZXdTdGF0ZSAgICAgICAgPSBIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0KGRhdGEsdGl0bGUsdXJsKSxcblx0XHRcdFx0XHRuZXdTdGF0ZUhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKG5ld1N0YXRlKSxcblx0XHRcdFx0XHRvbGRTdGF0ZSAgICAgICAgPSBIaXN0b3J5LmdldFN0YXRlKGZhbHNlKSxcblx0XHRcdFx0XHRvbGRTdGF0ZUhhc2ggPSBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKG9sZFN0YXRlKSxcblx0XHRcdFx0XHRwcmV2aW91c1N0YXRlICAgPSBIaXN0b3J5LmdldFN0YXRlQnlJbmRleCgtMik7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCBPbGQgU3RhdGVcblx0XHRcdFx0SGlzdG9yeS5kaXNjYXJkU3RhdGUob2xkU3RhdGUsbmV3U3RhdGUscHJldmlvdXNTdGF0ZSk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHVybCBoYXNuJ3QgY2hhbmdlZCwganVzdCBzdG9yZSBhbmQgc2F2ZSB0aGUgc3RhdGVcblx0XHRcdFx0Ly8gYW5kIGZpcmUgYSBzdGF0ZWNoYW5nZSBldmVudCB0byBiZSBjb25zaXN0ZW50IHdpdGggdGhlXG5cdFx0XHRcdC8vIGh0bWwgNSBhcGlcblx0XHRcdFx0aWYgKCBuZXdTdGF0ZUhhc2ggPT09IG9sZFN0YXRlSGFzaCApIHtcblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgbmV3U3RhdGVcblx0XHRcdFx0XHRIaXN0b3J5LnN0b3JlU3RhdGUobmV3U3RhdGUpO1xuXHRcdFx0XHRcdEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkID0gbmV3U3RhdGUuaWQ7XG5cdFxuXHRcdFx0XHRcdC8vIFJlY3ljbGUgdGhlIFN0YXRlXG5cdFx0XHRcdFx0SGlzdG9yeS5yZWN5Y2xlU3RhdGUobmV3U3RhdGUpO1xuXHRcblx0XHRcdFx0XHQvLyBGb3JjZSB1cGRhdGUgb2YgdGhlIHRpdGxlXG5cdFx0XHRcdFx0SGlzdG9yeS5zZXRUaXRsZShuZXdTdGF0ZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gVXBkYXRlIEhUTUw1IFN0YXRlXG5cdFx0XHRcdFx0SGlzdG9yeS5zYXZlU3RhdGUobmV3U3RhdGUpO1xuXG5cdFx0XHRcdFx0Ly8gRmlyZSBIVE1MNSBFdmVudFxuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5wdXNoU3RhdGU6IHRyaWdnZXIgcG9wc3RhdGUnKTtcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3N0YXRlY2hhbmdlJyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBBbGlhcyB0byBQdXNoU3RhdGVcblx0XHRcdFx0XHRIaXN0b3J5LnB1c2hTdGF0ZShuZXdTdGF0ZS5kYXRhLG5ld1N0YXRlLnRpdGxlLG5ld1N0YXRlLnVybCxmYWxzZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFbmQgcmVwbGFjZVN0YXRlIGNsb3N1cmVcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXG5cdFx0fSAvLyBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZVxuXG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSW5pdGlhbGlzZVxuXG5cdFx0Ly8gTm9uLU5hdGl2ZSBwdXNoU3RhdGUgSW1wbGVtZW50YXRpb25cblx0XHRpZiAoIEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICkge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBFbnN1cmUgaW5pdGlhbCBzdGF0ZSBpcyBoYW5kbGVkIGNvcnJlY3RseVxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIEhpc3RvcnkuZ2V0SGFzaCgpICYmICFIaXN0b3J5LmVtdWxhdGVkLmhhc2hDaGFuZ2UgKSB7XG5cdFx0XHRcdEhpc3RvcnkuQWRhcHRlci5vbkRvbUxvYWQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ2hhc2hjaGFuZ2UnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHR9IC8vIEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlXG5cblx0fTsgLy8gSGlzdG9yeS5pbml0SHRtbDRcblxuXHQvLyBUcnkgdG8gSW5pdGlhbGlzZSBIaXN0b3J5XG5cdGlmICggdHlwZW9mIEhpc3RvcnkuaW5pdCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0SGlzdG9yeS5pbml0KCk7XG5cdH1cblxufSkod2luZG93KTtcbi8qKlxuICogSGlzdG9yeS5qcyBDb3JlXG4gKiBAYXV0aG9yIEJlbmphbWluIEFydGh1ciBMdXB0b24gPGNvbnRhY3RAYmFsdXB0b24uY29tPlxuICogQGNvcHlyaWdodCAyMDEwLTIwMTEgQmVuamFtaW4gQXJ0aHVyIEx1cHRvbiA8Y29udGFjdEBiYWx1cHRvbi5jb20+XG4gKiBAbGljZW5zZSBOZXcgQlNEIExpY2Vuc2UgPGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL0JTRC8+XG4gKi9cblxuKGZ1bmN0aW9uKHdpbmRvdyx1bmRlZmluZWQpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0Ly8gSW5pdGlhbGlzZVxuXG5cdC8vIExvY2FsaXNlIEdsb2JhbHNcblx0dmFyXG5cdFx0Y29uc29sZSA9IHdpbmRvdy5jb25zb2xlfHx1bmRlZmluZWQsIC8vIFByZXZlbnQgYSBKU0xpbnQgY29tcGxhaW5cblx0XHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCwgLy8gTWFrZSBzdXJlIHdlIGFyZSB1c2luZyB0aGUgY29ycmVjdCBkb2N1bWVudFxuXHRcdG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IsIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgdXNpbmcgdGhlIGNvcnJlY3QgbmF2aWdhdG9yXG5cdFx0c2Vzc2lvblN0b3JhZ2UgPSBmYWxzZSwgLy8gc2Vzc2lvblN0b3JhZ2Vcblx0XHRzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQsXG5cdFx0Y2xlYXJUaW1lb3V0ID0gd2luZG93LmNsZWFyVGltZW91dCxcblx0XHRzZXRJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCxcblx0XHRjbGVhckludGVydmFsID0gd2luZG93LmNsZWFySW50ZXJ2YWwsXG5cdFx0SlNPTiA9IHdpbmRvdy5KU09OLFxuXHRcdGFsZXJ0ID0gd2luZG93LmFsZXJ0LFxuXHRcdEhpc3RvcnkgPSB3aW5kb3cuSGlzdG9yeSA9IHdpbmRvdy5IaXN0b3J5fHx7fSwgLy8gUHVibGljIEhpc3RvcnkgT2JqZWN0XG5cdFx0aGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5OyAvLyBPbGQgSGlzdG9yeSBPYmplY3RcblxuXHR0cnkge1xuXHRcdHNlc3Npb25TdG9yYWdlID0gd2luZG93LnNlc3Npb25TdG9yYWdlOyAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGluIHNvbWUgYnJvd3NlcnMgd2hlbiBjb29raWVzL2xvY2FsU3RvcmFnZSBhcmUgZXhwbGljaXRseSBkaXNhYmxlZCAoaS5lLiBDaHJvbWUpXG5cdFx0c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnVEVTVCcsICcxJyk7XG5cdFx0c2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgnVEVTVCcpO1xuXHR9IGNhdGNoKGUpIHtcblx0XHRzZXNzaW9uU3RvcmFnZSA9IGZhbHNlO1xuXHR9XG5cblx0Ly8gTW9vVG9vbHMgQ29tcGF0aWJpbGl0eVxuXHRKU09OLnN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5fHxKU09OLmVuY29kZTtcblx0SlNPTi5wYXJzZSA9IEpTT04ucGFyc2V8fEpTT04uZGVjb2RlO1xuXG5cdC8vIENoZWNrIEV4aXN0ZW5jZVxuXHRpZiAoIHR5cGVvZiBIaXN0b3J5LmluaXQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdHRocm93IG5ldyBFcnJvcignSGlzdG9yeS5qcyBDb3JlIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkLi4uJyk7XG5cdH1cblxuXHQvLyBJbml0aWFsaXNlIEhpc3Rvcnlcblx0SGlzdG9yeS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucyl7XG5cdFx0Ly8gQ2hlY2sgTG9hZCBTdGF0dXMgb2YgQWRhcHRlclxuXHRcdGlmICggdHlwZW9mIEhpc3RvcnkuQWRhcHRlciA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgTG9hZCBTdGF0dXMgb2YgQ29yZVxuXHRcdGlmICggdHlwZW9mIEhpc3RvcnkuaW5pdENvcmUgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0SGlzdG9yeS5pbml0Q29yZSgpO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIExvYWQgU3RhdHVzIG9mIEhUTUw0IFN1cHBvcnRcblx0XHRpZiAoIHR5cGVvZiBIaXN0b3J5LmluaXRIdG1sNCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRIaXN0b3J5LmluaXRIdG1sNCgpO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0cnVlXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0Ly8gSW5pdGlhbGlzZSBDb3JlXG5cblx0Ly8gSW5pdGlhbGlzZSBDb3JlXG5cdEhpc3RvcnkuaW5pdENvcmUgPSBmdW5jdGlvbihvcHRpb25zKXtcblx0XHQvLyBJbml0aWFsaXNlXG5cdFx0aWYgKCB0eXBlb2YgSGlzdG9yeS5pbml0Q29yZS5pbml0aWFsaXplZCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHQvLyBBbHJlYWR5IExvYWRlZFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdEhpc3RvcnkuaW5pdENvcmUuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdH1cblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBPcHRpb25zXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnNcblx0XHQgKiBDb25maWd1cmFibGUgb3B0aW9uc1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucyA9IEhpc3Rvcnkub3B0aW9uc3x8e307XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuaGFzaENoYW5nZUludGVydmFsXG5cdFx0ICogSG93IGxvbmcgc2hvdWxkIHRoZSBpbnRlcnZhbCBiZSBiZWZvcmUgaGFzaGNoYW5nZSBjaGVja3Ncblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuaGFzaENoYW5nZUludGVydmFsID0gSGlzdG9yeS5vcHRpb25zLmhhc2hDaGFuZ2VJbnRlcnZhbCB8fCAxMDA7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuc2FmYXJpUG9sbEludGVydmFsXG5cdFx0ICogSG93IGxvbmcgc2hvdWxkIHRoZSBpbnRlcnZhbCBiZSBiZWZvcmUgc2FmYXJpIHBvbGwgY2hlY2tzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLnNhZmFyaVBvbGxJbnRlcnZhbCA9IEhpc3Rvcnkub3B0aW9ucy5zYWZhcmlQb2xsSW50ZXJ2YWwgfHwgNTAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmRvdWJsZUNoZWNrSW50ZXJ2YWxcblx0XHQgKiBIb3cgbG9uZyBzaG91bGQgdGhlIGludGVydmFsIGJlIGJlZm9yZSB3ZSBwZXJmb3JtIGEgZG91YmxlIGNoZWNrXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmRvdWJsZUNoZWNrSW50ZXJ2YWwgPSBIaXN0b3J5Lm9wdGlvbnMuZG91YmxlQ2hlY2tJbnRlcnZhbCB8fCA1MDA7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuZGlzYWJsZVN1aWRcblx0XHQgKiBGb3JjZSBIaXN0b3J5IG5vdCB0byBhcHBlbmQgc3VpZFxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5kaXNhYmxlU3VpZCA9IEhpc3Rvcnkub3B0aW9ucy5kaXNhYmxlU3VpZCB8fCBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5zdG9yZUludGVydmFsXG5cdFx0ICogSG93IGxvbmcgc2hvdWxkIHdlIHdhaXQgYmV0d2VlbiBzdG9yZSBjYWxsc1xuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5zdG9yZUludGVydmFsID0gSGlzdG9yeS5vcHRpb25zLnN0b3JlSW50ZXJ2YWwgfHwgMTAwMDtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXlcblx0XHQgKiBIb3cgbG9uZyBzaG91bGQgd2Ugd2FpdCBiZXR3ZWVuIGJ1c3kgZXZlbnRzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmJ1c3lEZWxheSA9IEhpc3Rvcnkub3B0aW9ucy5idXN5RGVsYXkgfHwgMjUwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmRlYnVnXG5cdFx0ICogSWYgdHJ1ZSB3aWxsIGVuYWJsZSBkZWJ1ZyBtZXNzYWdlcyB0byBiZSBsb2dnZWRcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuZGVidWcgPSBIaXN0b3J5Lm9wdGlvbnMuZGVidWcgfHwgZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm9wdGlvbnMuaW5pdGlhbFRpdGxlXG5cdFx0ICogV2hhdCBpcyB0aGUgdGl0bGUgb2YgdGhlIGluaXRpYWwgc3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5Lm9wdGlvbnMuaW5pdGlhbFRpdGxlID0gSGlzdG9yeS5vcHRpb25zLmluaXRpYWxUaXRsZSB8fCBkb2N1bWVudC50aXRsZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkub3B0aW9ucy5odG1sNE1vZGVcblx0XHQgKiBJZiB0cnVlLCB3aWxsIGZvcmNlIEhUTWw0IG1vZGUgKGhhc2h0YWdzKVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkub3B0aW9ucy5odG1sNE1vZGUgPSBIaXN0b3J5Lm9wdGlvbnMuaHRtbDRNb2RlIHx8IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5vcHRpb25zLmRlbGF5SW5pdFxuXHRcdCAqIFdhbnQgdG8gb3ZlcnJpZGUgZGVmYXVsdCBvcHRpb25zIGFuZCBjYWxsIGluaXQgbWFudWFsbHkuXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5vcHRpb25zLmRlbGF5SW5pdCA9IEhpc3Rvcnkub3B0aW9ucy5kZWxheUluaXQgfHwgZmFsc2U7XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSW50ZXJ2YWwgcmVjb3JkXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmludGVydmFsTGlzdFxuXHRcdCAqIExpc3Qgb2YgaW50ZXJ2YWxzIHNldCwgdG8gYmUgY2xlYXJlZCB3aGVuIGRvY3VtZW50IGlzIHVubG9hZGVkLlxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuaW50ZXJ2YWxMaXN0ID0gW107XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmNsZWFyQWxsSW50ZXJ2YWxzXG5cdFx0ICogQ2xlYXJzIGFsbCBzZXRJbnRlcnZhbCBpbnN0YW5jZXMuXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5jbGVhckFsbEludGVydmFscyA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgaSwgaWwgPSBIaXN0b3J5LmludGVydmFsTGlzdDtcblx0XHRcdGlmICh0eXBlb2YgaWwgIT09IFwidW5kZWZpbmVkXCIgJiYgaWwgIT09IG51bGwpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGlsLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChpbFtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0SGlzdG9yeS5pbnRlcnZhbExpc3QgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gRGVidWdcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZGVidWcobWVzc2FnZSwuLi4pXG5cdFx0ICogTG9ncyB0aGUgcGFzc2VkIGFyZ3VtZW50cyBpZiBkZWJ1ZyBlbmFibGVkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5kZWJ1ZyA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoIChIaXN0b3J5Lm9wdGlvbnMuZGVidWd8fGZhbHNlKSApIHtcblx0XHRcdFx0SGlzdG9yeS5sb2cuYXBwbHkoSGlzdG9yeSxhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmxvZyhtZXNzYWdlLC4uLilcblx0XHQgKiBMb2dzIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5sb2cgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyXG5cdFx0XHRcdGNvbnNvbGVFeGlzdHMgPSAhKHR5cGVvZiBjb25zb2xlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgY29uc29sZS5sb2cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjb25zb2xlLmxvZy5hcHBseSA9PT0gJ3VuZGVmaW5lZCcpLFxuXHRcdFx0XHR0ZXh0YXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2cnKSxcblx0XHRcdFx0bWVzc2FnZSxcblx0XHRcdFx0aSxuLFxuXHRcdFx0XHRhcmdzLGFyZ1xuXHRcdFx0XHQ7XG5cblx0XHRcdC8vIFdyaXRlIHRvIENvbnNvbGVcblx0XHRcdGlmICggY29uc29sZUV4aXN0cyApIHtcblx0XHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRcdG1lc3NhZ2UgPSBhcmdzLnNoaWZ0KCk7XG5cdFx0XHRcdGlmICggdHlwZW9mIGNvbnNvbGUuZGVidWcgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcuYXBwbHkoY29uc29sZSxbbWVzc2FnZSxhcmdzXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSxbbWVzc2FnZSxhcmdzXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRtZXNzYWdlID0gKFwiXFxuXCIrYXJndW1lbnRzWzBdK1wiXFxuXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXcml0ZSB0byBsb2dcblx0XHRcdGZvciAoIGk9MSxuPWFyZ3VtZW50cy5sZW5ndGg7IGk8bjsgKytpICkge1xuXHRcdFx0XHRhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGlmICggdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRhcmcgPSBKU09OLnN0cmluZ2lmeShhcmcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCAoIEV4Y2VwdGlvbiApIHtcblx0XHRcdFx0XHRcdC8vIFJlY3Vyc2l2ZSBPYmplY3Rcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bWVzc2FnZSArPSBcIlxcblwiK2FyZytcIlxcblwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUZXh0YXJlYVxuXHRcdFx0aWYgKCB0ZXh0YXJlYSApIHtcblx0XHRcdFx0dGV4dGFyZWEudmFsdWUgKz0gbWVzc2FnZStcIlxcbi0tLS0tXFxuXCI7XG5cdFx0XHRcdHRleHRhcmVhLnNjcm9sbFRvcCA9IHRleHRhcmVhLnNjcm9sbEhlaWdodCAtIHRleHRhcmVhLmNsaWVudEhlaWdodDtcblx0XHRcdH1cblx0XHRcdC8vIE5vIFRleHRhcmVhLCBObyBDb25zb2xlXG5cdFx0XHRlbHNlIGlmICggIWNvbnNvbGVFeGlzdHMgKSB7XG5cdFx0XHRcdGFsZXJ0KG1lc3NhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gdHJ1ZVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBFbXVsYXRlZCBTdGF0dXNcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbigpXG5cdFx0ICogR2V0J3MgdGhlIG1ham9yIHZlcnNpb24gb2YgSW50ZXJuZXQgRXhwbG9yZXJcblx0XHQgKiBAcmV0dXJuIHtpbnRlZ2VyfVxuXHRcdCAqIEBsaWNlbnNlIFB1YmxpYyBEb21haW5cblx0XHQgKiBAYXV0aG9yIEJlbmphbWluIEFydGh1ciBMdXB0b24gPGNvbnRhY3RAYmFsdXB0b24uY29tPlxuXHRcdCAqIEBhdXRob3IgSmFtZXMgUGFkb2xzZXkgPGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzUyNzY4Mz5cblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24gPSBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHJlc3VsdCA9IEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbi5jYWNoZWQgPVxuXHRcdFx0XHRcdCh0eXBlb2YgSGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uLmNhY2hlZCAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRcdD9cdEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbi5jYWNoZWRcblx0XHRcdFx0Olx0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHR2YXIgdiA9IDMsXG5cdFx0XHRcdFx0XHRcdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0XHRcdFx0XHRcdFx0YWxsID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpJyk7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIChkaXYuaW5uZXJIVE1MID0gJzwhLS1baWYgZ3QgSUUgJyArICgrK3YpICsgJ10+PGk+PC9pPjwhW2VuZGlmXS0tPicpICYmIGFsbFswXSApIHt9XG5cdFx0XHRcdFx0XHRyZXR1cm4gKHYgPiA0KSA/IHYgOiBmYWxzZTtcblx0XHRcdFx0XHR9KSgpXG5cdFx0XHRcdDtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyKClcblx0XHQgKiBBcmUgd2UgdXNpbmcgSW50ZXJuZXQgRXhwbG9yZXI/XG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0XHQgKiBAbGljZW5zZSBQdWJsaWMgRG9tYWluXG5cdFx0ICogQGF1dGhvciBCZW5qYW1pbiBBcnRodXIgTHVwdG9uIDxjb250YWN0QGJhbHVwdG9uLmNvbT5cblx0XHQgKi9cblx0XHRIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3JlciA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcmVzdWx0ID1cblx0XHRcdFx0SGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIuY2FjaGVkID1cblx0XHRcdFx0KHR5cGVvZiBIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3Jlci5jYWNoZWQgIT09ICd1bmRlZmluZWQnKVxuXHRcdFx0XHRcdD9cdEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyLmNhY2hlZFxuXHRcdFx0XHRcdDpcdEJvb2xlYW4oSGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uKCkpXG5cdFx0XHRcdDtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZW11bGF0ZWRcblx0XHQgKiBXaGljaCBmZWF0dXJlcyByZXF1aXJlIGVtdWxhdGluZz9cblx0XHQgKi9cblxuXHRcdGlmIChIaXN0b3J5Lm9wdGlvbnMuaHRtbDRNb2RlKSB7XG5cdFx0XHRIaXN0b3J5LmVtdWxhdGVkID0ge1xuXHRcdFx0XHRwdXNoU3RhdGUgOiB0cnVlLFxuXHRcdFx0XHRoYXNoQ2hhbmdlOiB0cnVlXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGVsc2Uge1xuXG5cdFx0XHRIaXN0b3J5LmVtdWxhdGVkID0ge1xuXHRcdFx0XHRwdXNoU3RhdGU6ICFCb29sZWFuKFxuXHRcdFx0XHRcdHdpbmRvdy5oaXN0b3J5ICYmIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSAmJiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGVcblx0XHRcdFx0XHQmJiAhKFxuXHRcdFx0XHRcdFx0KC8gTW9iaWxlXFwvKFsxLTddW2Etel18KDgoW2FiY2RlXXxmKDFbMC04XSkpKSkvaSkudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAvKiBkaXNhYmxlIGZvciB2ZXJzaW9ucyBvZiBpT1MgYmVmb3JlIHZlcnNpb24gNC4zICg4RjE5MCkgKi9cblx0XHRcdFx0XHRcdHx8ICgvQXBwbGVXZWJLaXRcXC81KFswLTJdfDNbMC0yXSkvaSkudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAvKiBkaXNhYmxlIGZvciB0aGUgbWVyY3VyeSBpT1MgYnJvd3Nlciwgb3IgYXQgbGVhc3Qgb2xkZXIgdmVyc2lvbnMgb2YgdGhlIHdlYmtpdCBlbmdpbmUgKi9cblx0XHRcdFx0XHQpXG5cdFx0XHRcdCksXG5cdFx0XHRcdGhhc2hDaGFuZ2U6IEJvb2xlYW4oXG5cdFx0XHRcdFx0ISgoJ29uaGFzaGNoYW5nZScgaW4gd2luZG93KSB8fCAoJ29uaGFzaGNoYW5nZScgaW4gZG9jdW1lbnQpKVxuXHRcdFx0XHRcdHx8XG5cdFx0XHRcdFx0KEhpc3RvcnkuaXNJbnRlcm5ldEV4cGxvcmVyKCkgJiYgSGlzdG9yeS5nZXRJbnRlcm5ldEV4cGxvcmVyTWFqb3JWZXJzaW9uKCkgPCA4KVxuXHRcdFx0XHQpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZW5hYmxlZFxuXHRcdCAqIElzIEhpc3RvcnkgZW5hYmxlZD9cblx0XHQgKi9cblx0XHRIaXN0b3J5LmVuYWJsZWQgPSAhSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGU7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmJ1Z3Ncblx0XHQgKiBXaGljaCBidWdzIGFyZSBwcmVzZW50XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5idWdzID0ge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBTYWZhcmkgNSBhbmQgU2FmYXJpIGlPUyA0IGZhaWwgdG8gcmV0dXJuIHRvIHRoZSBjb3JyZWN0IHN0YXRlIG9uY2UgYSBoYXNoIGlzIHJlcGxhY2VkIGJ5IGEgYHJlcGxhY2VTdGF0ZWAgY2FsbFxuXHRcdFx0ICogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTU2MjQ5XG5cdFx0XHQgKi9cblx0XHRcdHNldEhhc2g6IEJvb2xlYW4oIUhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICYmIG5hdmlnYXRvci52ZW5kb3IgPT09ICdBcHBsZSBDb21wdXRlciwgSW5jLicgJiYgL0FwcGxlV2ViS2l0XFwvNShbMC0yXXwzWzAtM10pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTYWZhcmkgNSBhbmQgU2FmYXJpIGlPUyA0IHNvbWV0aW1lcyBmYWlsIHRvIGFwcGx5IHRoZSBzdGF0ZSBjaGFuZ2UgdW5kZXIgYnVzeSBjb25kaXRpb25zXG5cdFx0XHQgKiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDI5NDBcblx0XHRcdCAqL1xuXHRcdFx0c2FmYXJpUG9sbDogQm9vbGVhbighSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgJiYgbmF2aWdhdG9yLnZlbmRvciA9PT0gJ0FwcGxlIENvbXB1dGVyLCBJbmMuJyAmJiAvQXBwbGVXZWJLaXRcXC81KFswLTJdfDNbMC0zXSkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIE1TSUUgNiBhbmQgNyBzb21ldGltZXMgZG8gbm90IGFwcGx5IGEgaGFzaCBldmVuIGl0IHdhcyB0b2xkIHRvIChyZXF1aXJpbmcgYSBzZWNvbmQgY2FsbCB0byB0aGUgYXBwbHkgZnVuY3Rpb24pXG5cdFx0XHQgKi9cblx0XHRcdGllRG91YmxlQ2hlY2s6IEJvb2xlYW4oSGlzdG9yeS5pc0ludGVybmV0RXhwbG9yZXIoKSAmJiBIaXN0b3J5LmdldEludGVybmV0RXhwbG9yZXJNYWpvclZlcnNpb24oKSA8IDgpLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIE1TSUUgNiByZXF1aXJlcyB0aGUgZW50aXJlIGhhc2ggdG8gYmUgZW5jb2RlZCBmb3IgdGhlIGhhc2hlcyB0byB0cmlnZ2VyIHRoZSBvbkhhc2hDaGFuZ2UgZXZlbnRcblx0XHRcdCAqL1xuXHRcdFx0aGFzaEVzY2FwZTogQm9vbGVhbihIaXN0b3J5LmlzSW50ZXJuZXRFeHBsb3JlcigpICYmIEhpc3RvcnkuZ2V0SW50ZXJuZXRFeHBsb3Jlck1ham9yVmVyc2lvbigpIDwgNylcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5pc0VtcHR5T2JqZWN0KG9iailcblx0XHQgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBPYmplY3QgaXMgRW1wdHlcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcblx0XHRcdGZvciAoIHZhciBuYW1lIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBvYmouaGFzT3duUHJvcGVydHkobmFtZSkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5jbG9uZU9iamVjdChvYmopXG5cdFx0ICogQ2xvbmVzIGEgb2JqZWN0IGFuZCBlbGltaW5hdGUgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHRzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHRcdCAqIEByZXR1cm4ge09iamVjdH1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmNsb25lT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHR2YXIgaGFzaCxuZXdPYmo7XG5cdFx0XHRpZiAoIG9iaiApIHtcblx0XHRcdFx0aGFzaCA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG5cdFx0XHRcdG5ld09iaiA9IEpTT04ucGFyc2UoaGFzaCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bmV3T2JqID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3T2JqO1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gVVJMIEhlbHBlcnNcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0Um9vdFVybCgpXG5cdFx0ICogVHVybnMgXCJodHRwOi8vbXlzaXRlLmNvbS9kaXIvcGFnZS5odG1sP2FzZFwiIGludG8gXCJodHRwOi8vbXlzaXRlLmNvbVwiXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSByb290VXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRSb290VXJsID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0dmFyIHJvb3RVcmwgPSBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCsnLy8nKyhkb2N1bWVudC5sb2NhdGlvbi5ob3N0bmFtZXx8ZG9jdW1lbnQubG9jYXRpb24uaG9zdCk7XG5cdFx0XHRpZiAoIGRvY3VtZW50LmxvY2F0aW9uLnBvcnR8fGZhbHNlICkge1xuXHRcdFx0XHRyb290VXJsICs9ICc6Jytkb2N1bWVudC5sb2NhdGlvbi5wb3J0O1xuXHRcdFx0fVxuXHRcdFx0cm9vdFVybCArPSAnLyc7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIHJvb3RVcmw7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0QmFzZUhyZWYoKVxuXHRcdCAqIEZldGNoZXMgdGhlIGBocmVmYCBhdHRyaWJ1dGUgb2YgdGhlIGA8YmFzZSBocmVmPVwiLi4uXCI+YCBlbGVtZW50IGlmIGl0IGV4aXN0c1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gYmFzZUhyZWZcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldEJhc2VIcmVmID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0dmFyXG5cdFx0XHRcdGJhc2VFbGVtZW50cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdiYXNlJyksXG5cdFx0XHRcdGJhc2VFbGVtZW50ID0gbnVsbCxcblx0XHRcdFx0YmFzZUhyZWYgPSAnJztcblxuXHRcdFx0Ly8gVGVzdCBmb3IgQmFzZSBFbGVtZW50XG5cdFx0XHRpZiAoIGJhc2VFbGVtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdC8vIFByZXBhcmUgZm9yIEJhc2UgRWxlbWVudFxuXHRcdFx0XHRiYXNlRWxlbWVudCA9IGJhc2VFbGVtZW50c1swXTtcblx0XHRcdFx0YmFzZUhyZWYgPSBiYXNlRWxlbWVudC5ocmVmLnJlcGxhY2UoL1teXFwvXSskLywnJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkanVzdCB0cmFpbGluZyBzbGFzaFxuXHRcdFx0YmFzZUhyZWYgPSBiYXNlSHJlZi5yZXBsYWNlKC9cXC8rJC8sJycpO1xuXHRcdFx0aWYgKCBiYXNlSHJlZiApIGJhc2VIcmVmICs9ICcvJztcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gYmFzZUhyZWY7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0QmFzZVVybCgpXG5cdFx0ICogRmV0Y2hlcyB0aGUgYmFzZUhyZWYgb3IgYmFzZVBhZ2VVcmwgb3Igcm9vdFVybCAod2hpY2hldmVyIG9uZSBleGlzdHMgZmlyc3QpXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBiYXNlVXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRCYXNlVXJsID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0dmFyIGJhc2VVcmwgPSBIaXN0b3J5LmdldEJhc2VIcmVmKCl8fEhpc3RvcnkuZ2V0QmFzZVBhZ2VVcmwoKXx8SGlzdG9yeS5nZXRSb290VXJsKCk7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGJhc2VVcmw7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0UGFnZVVybCgpXG5cdFx0ICogRmV0Y2hlcyB0aGUgVVJMIG9mIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IHBhZ2VVcmxcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldFBhZ2VVcmwgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdHZhclxuXHRcdFx0XHRTdGF0ZSA9IEhpc3RvcnkuZ2V0U3RhdGUoZmFsc2UsZmFsc2UpLFxuXHRcdFx0XHRzdGF0ZVVybCA9IChTdGF0ZXx8e30pLnVybHx8SGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSxcblx0XHRcdFx0cGFnZVVybDtcblxuXHRcdFx0Ly8gQ3JlYXRlXG5cdFx0XHRwYWdlVXJsID0gc3RhdGVVcmwucmVwbGFjZSgvXFwvKyQvLCcnKS5yZXBsYWNlKC9bXlxcL10rJC8sZnVuY3Rpb24ocGFydCxpbmRleCxzdHJpbmcpe1xuXHRcdFx0XHRyZXR1cm4gKC9cXC4vKS50ZXN0KHBhcnQpID8gcGFydCA6IHBhcnQrJy8nO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIHBhZ2VVcmw7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0QmFzZVBhZ2VVcmwoKVxuXHRcdCAqIEZldGNoZXMgdGhlIFVybCBvZiB0aGUgZGlyZWN0b3J5IG9mIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2VQYWdlVXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRCYXNlUGFnZVVybCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBDcmVhdGVcblx0XHRcdHZhciBiYXNlUGFnZVVybCA9IChIaXN0b3J5LmdldExvY2F0aW9uSHJlZigpKS5yZXBsYWNlKC9bI1xcP10uKi8sJycpLnJlcGxhY2UoL1teXFwvXSskLyxmdW5jdGlvbihwYXJ0LGluZGV4LHN0cmluZyl7XG5cdFx0XHRcdHJldHVybiAoL1teXFwvXSQvKS50ZXN0KHBhcnQpID8gJycgOiBwYXJ0O1xuXHRcdFx0fSkucmVwbGFjZSgvXFwvKyQvLCcnKSsnLyc7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGJhc2VQYWdlVXJsO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEZ1bGxVcmwodXJsKVxuXHRcdCAqIEVuc3VyZXMgdGhhdCB3ZSBoYXZlIGFuIGFic29sdXRlIFVSTCBhbmQgbm90IGEgcmVsYXRpdmUgVVJMXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dCYXNlSHJlZlxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gZnVsbFVybFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0RnVsbFVybCA9IGZ1bmN0aW9uKHVybCxhbGxvd0Jhc2VIcmVmKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBmdWxsVXJsID0gdXJsLCBmaXJzdENoYXIgPSB1cmwuc3Vic3RyaW5nKDAsMSk7XG5cdFx0XHRhbGxvd0Jhc2VIcmVmID0gKHR5cGVvZiBhbGxvd0Jhc2VIcmVmID09PSAndW5kZWZpbmVkJykgPyB0cnVlIDogYWxsb3dCYXNlSHJlZjtcblxuXHRcdFx0Ly8gQ2hlY2tcblx0XHRcdGlmICggL1thLXpdK1xcOlxcL1xcLy8udGVzdCh1cmwpICkge1xuXHRcdFx0XHQvLyBGdWxsIFVSTFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGZpcnN0Q2hhciA9PT0gJy8nICkge1xuXHRcdFx0XHQvLyBSb290IFVSTFxuXHRcdFx0XHRmdWxsVXJsID0gSGlzdG9yeS5nZXRSb290VXJsKCkrdXJsLnJlcGxhY2UoL15cXC8rLywnJyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggZmlyc3RDaGFyID09PSAnIycgKSB7XG5cdFx0XHRcdC8vIEFuY2hvciBVUkxcblx0XHRcdFx0ZnVsbFVybCA9IEhpc3RvcnkuZ2V0UGFnZVVybCgpLnJlcGxhY2UoLyMuKi8sJycpK3VybDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBmaXJzdENoYXIgPT09ICc/JyApIHtcblx0XHRcdFx0Ly8gUXVlcnkgVVJMXG5cdFx0XHRcdGZ1bGxVcmwgPSBIaXN0b3J5LmdldFBhZ2VVcmwoKS5yZXBsYWNlKC9bXFw/I10uKi8sJycpK3VybDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBSZWxhdGl2ZSBVUkxcblx0XHRcdFx0aWYgKCBhbGxvd0Jhc2VIcmVmICkge1xuXHRcdFx0XHRcdGZ1bGxVcmwgPSBIaXN0b3J5LmdldEJhc2VVcmwoKSt1cmwucmVwbGFjZSgvXihcXC5cXC8pKy8sJycpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZ1bGxVcmwgPSBIaXN0b3J5LmdldEJhc2VQYWdlVXJsKCkrdXJsLnJlcGxhY2UoL14oXFwuXFwvKSsvLCcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBXZSBoYXZlIGFuIGlmIGNvbmRpdGlvbiBhYm92ZSBhcyB3ZSBkbyBub3Qgd2FudCBoYXNoZXNcblx0XHRcdFx0Ly8gd2hpY2ggYXJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlSHJlZiBpbiBvdXIgVVJMc1xuXHRcdFx0XHQvLyBhcyBpZiB0aGUgYmFzZUhyZWYgY2hhbmdlcywgdGhlbiBhbGwgb3VyIGJvb2ttYXJrc1xuXHRcdFx0XHQvLyB3b3VsZCBub3cgcG9pbnQgdG8gZGlmZmVyZW50IGxvY2F0aW9uc1xuXHRcdFx0XHQvLyB3aGVyZWFzIHRoZSBiYXNlUGFnZVVybCB3aWxsIGFsd2F5cyBzdGF5IHRoZSBzYW1lXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGZ1bGxVcmwucmVwbGFjZSgvXFwjJC8sJycpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFNob3J0VXJsKHVybClcblx0XHQgKiBFbnN1cmVzIHRoYXQgd2UgaGF2ZSBhIHJlbGF0aXZlIFVSTCBhbmQgbm90IGEgYWJzb2x1dGUgVVJMXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gdXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTaG9ydFVybCA9IGZ1bmN0aW9uKHVybCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgc2hvcnRVcmwgPSB1cmwsIGJhc2VVcmwgPSBIaXN0b3J5LmdldEJhc2VVcmwoKSwgcm9vdFVybCA9IEhpc3RvcnkuZ2V0Um9vdFVybCgpO1xuXG5cdFx0XHQvLyBUcmltIGJhc2VVcmxcblx0XHRcdGlmICggSGlzdG9yeS5lbXVsYXRlZC5wdXNoU3RhdGUgKSB7XG5cdFx0XHRcdC8vIFdlIGFyZSBpbiBhIGlmIHN0YXRlbWVudCBhcyB3aGVuIHB1c2hTdGF0ZSBpcyBub3QgZW11bGF0ZWRcblx0XHRcdFx0Ly8gVGhlIGFjdHVhbCB1cmwgdGhlc2Ugc2hvcnQgdXJscyBhcmUgcmVsYXRpdmUgdG8gY2FuIGNoYW5nZVxuXHRcdFx0XHQvLyBTbyB3aXRoaW4gdGhlIHNhbWUgc2Vzc2lvbiwgd2UgdGhlIHVybCBtYXkgZW5kIHVwIHNvbWV3aGVyZSBkaWZmZXJlbnRcblx0XHRcdFx0c2hvcnRVcmwgPSBzaG9ydFVybC5yZXBsYWNlKGJhc2VVcmwsJycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmltIHJvb3RVcmxcblx0XHRcdHNob3J0VXJsID0gc2hvcnRVcmwucmVwbGFjZShyb290VXJsLCcvJyk7XG5cblx0XHRcdC8vIEVuc3VyZSB3ZSBjYW4gc3RpbGwgZGV0ZWN0IGl0IGFzIGEgc3RhdGVcblx0XHRcdGlmICggSGlzdG9yeS5pc1RyYWRpdGlvbmFsQW5jaG9yKHNob3J0VXJsKSApIHtcblx0XHRcdFx0c2hvcnRVcmwgPSAnLi8nK3Nob3J0VXJsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhbiBJdFxuXHRcdFx0c2hvcnRVcmwgPSBzaG9ydFVybC5yZXBsYWNlKC9eKFxcLlxcLykrL2csJy4vJykucmVwbGFjZSgvXFwjJC8sJycpO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBzaG9ydFVybDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoZG9jdW1lbnQpXG5cdFx0ICogUmV0dXJucyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmXG5cdFx0ICogYWNjb3VudGluZyBmb3IgYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMsIGV0Yy5cblx0XHQgKlxuXHRcdCAqIFRoaXMgVVJMIHdpbGwgYmUgVVJJLWVuY29kZWQgYW5kIHdpbGwgaW5jbHVkZSB0aGUgaGFzaFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGRvY3VtZW50XG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSB1cmxcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldExvY2F0aW9uSHJlZiA9IGZ1bmN0aW9uKGRvYykge1xuXHRcdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0XHQvLyBtb3N0IG9mIHRoZSB0aW1lLCB0aGlzIHdpbGwgYmUgdHJ1ZVxuXHRcdFx0aWYgKGRvYy5VUkwgPT09IGRvYy5sb2NhdGlvbi5ocmVmKVxuXHRcdFx0XHRyZXR1cm4gZG9jLmxvY2F0aW9uLmhyZWY7XG5cblx0XHRcdC8vIHNvbWUgdmVyc2lvbnMgb2Ygd2Via2l0IFVSSS1kZWNvZGUgZG9jdW1lbnQubG9jYXRpb24uaHJlZlxuXHRcdFx0Ly8gYnV0IHRoZXkgbGVhdmUgZG9jdW1lbnQuVVJMIGluIGFuIGVuY29kZWQgc3RhdGVcblx0XHRcdGlmIChkb2MubG9jYXRpb24uaHJlZiA9PT0gZGVjb2RlVVJJQ29tcG9uZW50KGRvYy5VUkwpKVxuXHRcdFx0XHRyZXR1cm4gZG9jLlVSTDtcblxuXHRcdFx0Ly8gRkYgMy42IG9ubHkgdXBkYXRlcyBkb2N1bWVudC5VUkwgd2hlbiBhIHBhZ2UgaXMgcmVsb2FkZWRcblx0XHRcdC8vIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgaXMgdXBkYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmIChkb2MubG9jYXRpb24uaGFzaCAmJiBkZWNvZGVVUklDb21wb25lbnQoZG9jLmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvXlteI10rLywgXCJcIikpID09PSBkb2MubG9jYXRpb24uaGFzaClcblx0XHRcdFx0cmV0dXJuIGRvYy5sb2NhdGlvbi5ocmVmO1xuXG5cdFx0XHRpZiAoZG9jLlVSTC5pbmRleE9mKCcjJykgPT0gLTEgJiYgZG9jLmxvY2F0aW9uLmhyZWYuaW5kZXhPZignIycpICE9IC0xKVxuXHRcdFx0XHRyZXR1cm4gZG9jLmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRcblx0XHRcdHJldHVybiBkb2MuVVJMIHx8IGRvYy5sb2NhdGlvbi5ocmVmO1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gU3RhdGUgU3RvcmFnZVxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zdG9yZVxuXHRcdCAqIFRoZSBzdG9yZSBmb3IgYWxsIHNlc3Npb24gc3BlY2lmaWMgZGF0YVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkuc3RvcmUgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuaWRUb1N0YXRlXG5cdFx0ICogMS0xOiBTdGF0ZSBJRCB0byBTdGF0ZSBPYmplY3Rcblx0XHQgKi9cblx0XHRIaXN0b3J5LmlkVG9TdGF0ZSA9IEhpc3RvcnkuaWRUb1N0YXRlfHx7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc3RhdGVUb0lkXG5cdFx0ICogMS0xOiBTdGF0ZSBTdHJpbmcgdG8gU3RhdGUgSURcblx0XHQgKi9cblx0XHRIaXN0b3J5LnN0YXRlVG9JZCA9IEhpc3Rvcnkuc3RhdGVUb0lkfHx7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkudXJsVG9JZFxuXHRcdCAqIDEtMTogU3RhdGUgVVJMIHRvIFN0YXRlIElEXG5cdFx0ICovXG5cdFx0SGlzdG9yeS51cmxUb0lkID0gSGlzdG9yeS51cmxUb0lkfHx7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc3RvcmVkU3RhdGVzXG5cdFx0ICogU3RvcmUgdGhlIHN0YXRlcyBpbiBhbiBhcnJheVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkuc3RvcmVkU3RhdGVzID0gSGlzdG9yeS5zdG9yZWRTdGF0ZXN8fFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zYXZlZFN0YXRlc1xuXHRcdCAqIFNhdmVkIHRoZSBzdGF0ZXMgaW4gYW4gYXJyYXlcblx0XHQgKi9cblx0XHRIaXN0b3J5LnNhdmVkU3RhdGVzID0gSGlzdG9yeS5zYXZlZFN0YXRlc3x8W107XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm5vcmFtbGl6ZVN0b3JlKClcblx0XHQgKiBOb3JhbWxpemUgdGhlIHN0b3JlIGJ5IGFkZGluZyBuZWNlc3NhcnkgdmFsdWVzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5ub3JtYWxpemVTdG9yZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRIaXN0b3J5LnN0b3JlLmlkVG9TdGF0ZSA9IEhpc3Rvcnkuc3RvcmUuaWRUb1N0YXRlfHx7fTtcblx0XHRcdEhpc3Rvcnkuc3RvcmUudXJsVG9JZCA9IEhpc3Rvcnkuc3RvcmUudXJsVG9JZHx8e307XG5cdFx0XHRIaXN0b3J5LnN0b3JlLnN0YXRlVG9JZCA9IEhpc3Rvcnkuc3RvcmUuc3RhdGVUb0lkfHx7fTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRTdGF0ZSgpXG5cdFx0ICogR2V0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhLCB0aXRsZSBhbmQgdXJsIG9mIHRoZSBjdXJyZW50IHN0YXRlXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBmcmllbmRseVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY3JlYXRlXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBTdGF0ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0U3RhdGUgPSBmdW5jdGlvbihmcmllbmRseSxjcmVhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0aWYgKCB0eXBlb2YgZnJpZW5kbHkgPT09ICd1bmRlZmluZWQnICkgeyBmcmllbmRseSA9IHRydWU7IH1cblx0XHRcdGlmICggdHlwZW9mIGNyZWF0ZSA9PT0gJ3VuZGVmaW5lZCcgKSB7IGNyZWF0ZSA9IHRydWU7IH1cblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdHZhciBTdGF0ZSA9IEhpc3RvcnkuZ2V0TGFzdFNhdmVkU3RhdGUoKTtcblxuXHRcdFx0Ly8gQ3JlYXRlXG5cdFx0XHRpZiAoICFTdGF0ZSAmJiBjcmVhdGUgKSB7XG5cdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGp1c3Rcblx0XHRcdGlmICggZnJpZW5kbHkgKSB7XG5cdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5jbG9uZU9iamVjdChTdGF0ZSk7XG5cdFx0XHRcdFN0YXRlLnVybCA9IFN0YXRlLmNsZWFuVXJsfHxTdGF0ZS51cmw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIFN0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldElkQnlTdGF0ZShTdGF0ZSlcblx0XHQgKiBHZXRzIGEgSUQgZm9yIGEgU3RhdGVcblx0XHQgKiBAcGFyYW0ge1N0YXRlfSBuZXdTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gaWRcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldElkQnlTdGF0ZSA9IGZ1bmN0aW9uKG5ld1N0YXRlKXtcblxuXHRcdFx0Ly8gRmV0Y2ggSURcblx0XHRcdHZhciBpZCA9IEhpc3RvcnkuZXh0cmFjdElkKG5ld1N0YXRlLnVybCksXG5cdFx0XHRcdHN0cjtcblxuXHRcdFx0aWYgKCAhaWQgKSB7XG5cdFx0XHRcdC8vIEZpbmQgSUQgdmlhIFN0YXRlIFN0cmluZ1xuXHRcdFx0XHRzdHIgPSBIaXN0b3J5LmdldFN0YXRlU3RyaW5nKG5ld1N0YXRlKTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgSGlzdG9yeS5zdGF0ZVRvSWRbc3RyXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0aWQgPSBIaXN0b3J5LnN0YXRlVG9JZFtzdHJdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgSGlzdG9yeS5zdG9yZS5zdGF0ZVRvSWRbc3RyXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0aWQgPSBIaXN0b3J5LnN0b3JlLnN0YXRlVG9JZFtzdHJdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIEdlbmVyYXRlIGEgbmV3IElEXG5cdFx0XHRcdFx0d2hpbGUgKCB0cnVlICkge1xuXHRcdFx0XHRcdFx0aWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCcnKTtcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIEhpc3RvcnkuaWRUb1N0YXRlW2lkXSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEhpc3Rvcnkuc3RvcmUuaWRUb1N0YXRlW2lkXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFwcGx5IHRoZSBuZXcgU3RhdGUgdG8gdGhlIElEXG5cdFx0XHRcdFx0SGlzdG9yeS5zdGF0ZVRvSWRbc3RyXSA9IGlkO1xuXHRcdFx0XHRcdEhpc3RvcnkuaWRUb1N0YXRlW2lkXSA9IG5ld1N0YXRlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBJRFxuXHRcdFx0cmV0dXJuIGlkO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm5vcm1hbGl6ZVN0YXRlKFN0YXRlKVxuXHRcdCAqIEV4cGFuZHMgYSBTdGF0ZSBPYmplY3Rcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gU3RhdGVcblx0XHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5ub3JtYWxpemVTdGF0ZSA9IGZ1bmN0aW9uKG9sZFN0YXRlKXtcblx0XHRcdC8vIFZhcmlhYmxlc1xuXHRcdFx0dmFyIG5ld1N0YXRlLCBkYXRhTm90RW1wdHk7XG5cblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdGlmICggIW9sZFN0YXRlIHx8ICh0eXBlb2Ygb2xkU3RhdGUgIT09ICdvYmplY3QnKSApIHtcblx0XHRcdFx0b2xkU3RhdGUgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2tcblx0XHRcdGlmICggdHlwZW9mIG9sZFN0YXRlLm5vcm1hbGl6ZWQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRyZXR1cm4gb2xkU3RhdGU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkanVzdFxuXHRcdFx0aWYgKCAhb2xkU3RhdGUuZGF0YSB8fCAodHlwZW9mIG9sZFN0YXRlLmRhdGEgIT09ICdvYmplY3QnKSApIHtcblx0XHRcdFx0b2xkU3RhdGUuZGF0YSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRcdC8vIENyZWF0ZVxuXHRcdFx0bmV3U3RhdGUgPSB7fTtcblx0XHRcdG5ld1N0YXRlLm5vcm1hbGl6ZWQgPSB0cnVlO1xuXHRcdFx0bmV3U3RhdGUudGl0bGUgPSBvbGRTdGF0ZS50aXRsZXx8Jyc7XG5cdFx0XHRuZXdTdGF0ZS51cmwgPSBIaXN0b3J5LmdldEZ1bGxVcmwob2xkU3RhdGUudXJsP29sZFN0YXRlLnVybDooSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSkpO1xuXHRcdFx0bmV3U3RhdGUuaGFzaCA9IEhpc3RvcnkuZ2V0U2hvcnRVcmwobmV3U3RhdGUudXJsKTtcblx0XHRcdG5ld1N0YXRlLmRhdGEgPSBIaXN0b3J5LmNsb25lT2JqZWN0KG9sZFN0YXRlLmRhdGEpO1xuXG5cdFx0XHQvLyBGZXRjaCBJRFxuXHRcdFx0bmV3U3RhdGUuaWQgPSBIaXN0b3J5LmdldElkQnlTdGF0ZShuZXdTdGF0ZSk7XG5cblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFx0Ly8gQ2xlYW4gdGhlIFVSTFxuXHRcdFx0bmV3U3RhdGUuY2xlYW5VcmwgPSBuZXdTdGF0ZS51cmwucmVwbGFjZSgvXFw/P1xcJl9zdWlkLiovLCcnKTtcblx0XHRcdG5ld1N0YXRlLnVybCA9IG5ld1N0YXRlLmNsZWFuVXJsO1xuXG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBtb3JlIHRoYW4ganVzdCBhIHVybFxuXHRcdFx0ZGF0YU5vdEVtcHR5ID0gIUhpc3RvcnkuaXNFbXB0eU9iamVjdChuZXdTdGF0ZS5kYXRhKTtcblxuXHRcdFx0Ly8gQXBwbHlcblx0XHRcdGlmICggKG5ld1N0YXRlLnRpdGxlIHx8IGRhdGFOb3RFbXB0eSkgJiYgSGlzdG9yeS5vcHRpb25zLmRpc2FibGVTdWlkICE9PSB0cnVlICkge1xuXHRcdFx0XHQvLyBBZGQgSUQgdG8gSGFzaFxuXHRcdFx0XHRuZXdTdGF0ZS5oYXNoID0gSGlzdG9yeS5nZXRTaG9ydFVybChuZXdTdGF0ZS51cmwpLnJlcGxhY2UoL1xcPz9cXCZfc3VpZC4qLywnJyk7XG5cdFx0XHRcdGlmICggIS9cXD8vLnRlc3QobmV3U3RhdGUuaGFzaCkgKSB7XG5cdFx0XHRcdFx0bmV3U3RhdGUuaGFzaCArPSAnPyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3U3RhdGUuaGFzaCArPSAnJl9zdWlkPScrbmV3U3RhdGUuaWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgSGFzaGVkIFVSTFxuXHRcdFx0bmV3U3RhdGUuaGFzaGVkVXJsID0gSGlzdG9yeS5nZXRGdWxsVXJsKG5ld1N0YXRlLmhhc2gpO1xuXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgVVJMIGlmIHdlIGhhdmUgYSBkdXBsaWNhdGVcblx0XHRcdGlmICggKEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlIHx8IEhpc3RvcnkuYnVncy5zYWZhcmlQb2xsKSAmJiBIaXN0b3J5Lmhhc1VybER1cGxpY2F0ZShuZXdTdGF0ZSkgKSB7XG5cdFx0XHRcdG5ld1N0YXRlLnVybCA9IG5ld1N0YXRlLmhhc2hlZFVybDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBuZXdTdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChkYXRhLHRpdGxlLHVybClcblx0XHQgKiBDcmVhdGVzIGEgb2JqZWN0IGJhc2VkIG9uIHRoZSBkYXRhLCB0aXRsZSBhbmQgdXJsIHN0YXRlIHBhcmFtc1xuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdCAqIEByZXR1cm4ge29iamVjdH1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0ID0gZnVuY3Rpb24oZGF0YSx0aXRsZSx1cmwpe1xuXHRcdFx0Ly8gSGFzaGlmeVxuXHRcdFx0dmFyIFN0YXRlID0ge1xuXHRcdFx0XHQnZGF0YSc6IGRhdGEsXG5cdFx0XHRcdCd0aXRsZSc6IHRpdGxlLFxuXHRcdFx0XHQndXJsJzogdXJsXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBFeHBhbmQgdGhlIFN0YXRlXG5cdFx0XHRTdGF0ZSA9IEhpc3Rvcnkubm9ybWFsaXplU3RhdGUoU3RhdGUpO1xuXG5cdFx0XHQvLyBSZXR1cm4gb2JqZWN0XG5cdFx0XHRyZXR1cm4gU3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0U3RhdGVCeUlkKGlkKVxuXHRcdCAqIEdldCBhIHN0YXRlIGJ5IGl0J3MgVUlEXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGlkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTdGF0ZUJ5SWQgPSBmdW5jdGlvbihpZCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHRpZCA9IFN0cmluZyhpZCk7XG5cblx0XHRcdC8vIFJldHJpZXZlXG5cdFx0XHR2YXIgU3RhdGUgPSBIaXN0b3J5LmlkVG9TdGF0ZVtpZF0gfHwgSGlzdG9yeS5zdG9yZS5pZFRvU3RhdGVbaWRdIHx8IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gUmV0dXJuIFN0YXRlXG5cdFx0XHRyZXR1cm4gU3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIFN0YXRlJ3MgU3RyaW5nXG5cdFx0ICogQHBhcmFtIHtTdGF0ZX0gcGFzc2VkU3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldFN0YXRlU3RyaW5nID0gZnVuY3Rpb24ocGFzc2VkU3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlLCBjbGVhbmVkU3RhdGUsIHN0cjtcblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdFN0YXRlID0gSGlzdG9yeS5ub3JtYWxpemVTdGF0ZShwYXNzZWRTdGF0ZSk7XG5cblx0XHRcdC8vIENsZWFuXG5cdFx0XHRjbGVhbmVkU3RhdGUgPSB7XG5cdFx0XHRcdGRhdGE6IFN0YXRlLmRhdGEsXG5cdFx0XHRcdHRpdGxlOiBwYXNzZWRTdGF0ZS50aXRsZSxcblx0XHRcdFx0dXJsOiBwYXNzZWRTdGF0ZS51cmxcblx0XHRcdH07XG5cblx0XHRcdC8vIEZldGNoXG5cdFx0XHRzdHIgPSBKU09OLnN0cmluZ2lmeShjbGVhbmVkU3RhdGUpO1xuXG5cdFx0XHQvLyBSZXR1cm5cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIFN0YXRlJ3MgSURcblx0XHQgKiBAcGFyYW0ge1N0YXRlfSBwYXNzZWRTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gaWRcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldFN0YXRlSWQgPSBmdW5jdGlvbihwYXNzZWRTdGF0ZSl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgU3RhdGUsIGlkO1xuXG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0U3RhdGUgPSBIaXN0b3J5Lm5vcm1hbGl6ZVN0YXRlKHBhc3NlZFN0YXRlKTtcblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdGlkID0gU3RhdGUuaWQ7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGlkO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldEhhc2hCeVN0YXRlKFN0YXRlKVxuXHRcdCAqIENyZWF0ZXMgYSBIYXNoIGZvciB0aGUgU3RhdGUgT2JqZWN0XG5cdFx0ICogQHBhcmFtIHtTdGF0ZX0gcGFzc2VkU3RhdGVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IGhhc2hcblx0XHQgKi9cblx0XHRIaXN0b3J5LmdldEhhc2hCeVN0YXRlID0gZnVuY3Rpb24ocGFzc2VkU3RhdGUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlLCBoYXNoO1xuXG5cdFx0XHQvLyBGZXRjaFxuXHRcdFx0U3RhdGUgPSBIaXN0b3J5Lm5vcm1hbGl6ZVN0YXRlKHBhc3NlZFN0YXRlKTtcblxuXHRcdFx0Ly8gSGFzaFxuXHRcdFx0aGFzaCA9IFN0YXRlLmhhc2g7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZXh0cmFjdElkKHVybF9vcl9oYXNoKVxuXHRcdCAqIEdldCBhIFN0YXRlIElEIGJ5IGl0J3MgVVJMIG9yIEhhc2hcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsX29yX2hhc2hcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IGlkXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5leHRyYWN0SWQgPSBmdW5jdGlvbiAoIHVybF9vcl9oYXNoICkge1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGlkLHBhcnRzLHVybCwgdG1wO1xuXG5cdFx0XHQvLyBFeHRyYWN0XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBVUkwgaGFzIGEgIywgdXNlIHRoZSBpZCBmcm9tIGJlZm9yZSB0aGUgI1xuXHRcdFx0aWYgKHVybF9vcl9oYXNoLmluZGV4T2YoJyMnKSAhPSAtMSlcblx0XHRcdHtcblx0XHRcdFx0dG1wID0gdXJsX29yX2hhc2guc3BsaXQoXCIjXCIpWzBdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0bXAgPSB1cmxfb3JfaGFzaDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cGFydHMgPSAvKC4qKVxcJl9zdWlkPShbMC05XSspJC8uZXhlYyh0bXApO1xuXHRcdFx0dXJsID0gcGFydHMgPyAocGFydHNbMV18fHVybF9vcl9oYXNoKSA6IHVybF9vcl9oYXNoO1xuXHRcdFx0aWQgPSBwYXJ0cyA/IFN0cmluZyhwYXJ0c1syXXx8JycpIDogJyc7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGlkfHxmYWxzZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5pc1RyYWRpdGlvbmFsQW5jaG9yXG5cdFx0ICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgdXJsIGlzIGEgdHJhZGl0aW9uYWwgYW5jaG9yIG9yIG5vdFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxfb3JfaGFzaFxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5pc1RyYWRpdGlvbmFsQW5jaG9yID0gZnVuY3Rpb24odXJsX29yX2hhc2gpe1xuXHRcdFx0Ly8gQ2hlY2tcblx0XHRcdHZhciBpc1RyYWRpdGlvbmFsID0gISgvW1xcL1xcP1xcLl0vLnRlc3QodXJsX29yX2hhc2gpKTtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gaXNUcmFkaXRpb25hbDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5leHRyYWN0U3RhdGVcblx0XHQgKiBHZXQgYSBTdGF0ZSBieSBpdCdzIFVSTCBvciBIYXNoXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHVybF9vcl9oYXNoXG5cdFx0ICogQHJldHVybiB7U3RhdGV8bnVsbH1cblx0XHQgKi9cblx0XHRIaXN0b3J5LmV4dHJhY3RTdGF0ZSA9IGZ1bmN0aW9uKHVybF9vcl9oYXNoLGNyZWF0ZSl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgU3RhdGUgPSBudWxsLCBpZCwgdXJsO1xuXHRcdFx0Y3JlYXRlID0gY3JlYXRlfHxmYWxzZTtcblxuXHRcdFx0Ly8gRmV0Y2ggU1VJRFxuXHRcdFx0aWQgPSBIaXN0b3J5LmV4dHJhY3RJZCh1cmxfb3JfaGFzaCk7XG5cdFx0XHRpZiAoIGlkICkge1xuXHRcdFx0XHRTdGF0ZSA9IEhpc3RvcnkuZ2V0U3RhdGVCeUlkKGlkKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmV0Y2ggU1VJRCByZXR1cm5lZCBubyBTdGF0ZVxuXHRcdFx0aWYgKCAhU3RhdGUgKSB7XG5cdFx0XHRcdC8vIEZldGNoIFVSTFxuXHRcdFx0XHR1cmwgPSBIaXN0b3J5LmdldEZ1bGxVcmwodXJsX29yX2hhc2gpO1xuXG5cdFx0XHRcdC8vIENoZWNrIFVSTFxuXHRcdFx0XHRpZCA9IEhpc3RvcnkuZ2V0SWRCeVVybCh1cmwpfHxmYWxzZTtcblx0XHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0XHRTdGF0ZSA9IEhpc3RvcnkuZ2V0U3RhdGVCeUlkKGlkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSBTdGF0ZVxuXHRcdFx0XHRpZiAoICFTdGF0ZSAmJiBjcmVhdGUgJiYgIUhpc3RvcnkuaXNUcmFkaXRpb25hbEFuY2hvcih1cmxfb3JfaGFzaCkgKSB7XG5cdFx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0KG51bGwsbnVsbCx1cmwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIFN0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldElkQnlVcmwoKVxuXHRcdCAqIEdldCBhIFN0YXRlIElEIGJ5IGEgU3RhdGUgVVJMXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRJZEJ5VXJsID0gZnVuY3Rpb24odXJsKXtcblx0XHRcdC8vIEZldGNoXG5cdFx0XHR2YXIgaWQgPSBIaXN0b3J5LnVybFRvSWRbdXJsXSB8fCBIaXN0b3J5LnN0b3JlLnVybFRvSWRbdXJsXSB8fCB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIGlkO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldExhc3RTYXZlZFN0YXRlKClcblx0XHQgKiBHZXQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEsIHRpdGxlIGFuZCB1cmwgb2YgdGhlIGN1cnJlbnQgc3RhdGVcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IFN0YXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRMYXN0U2F2ZWRTdGF0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gSGlzdG9yeS5zYXZlZFN0YXRlc1tIaXN0b3J5LnNhdmVkU3RhdGVzLmxlbmd0aC0xXXx8dW5kZWZpbmVkO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldExhc3RTdG9yZWRTdGF0ZSgpXG5cdFx0ICogR2V0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhLCB0aXRsZSBhbmQgdXJsIG9mIHRoZSBjdXJyZW50IHN0YXRlXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBTdGF0ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ2V0TGFzdFN0b3JlZFN0YXRlID0gZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiBIaXN0b3J5LnN0b3JlZFN0YXRlc1tIaXN0b3J5LnN0b3JlZFN0YXRlcy5sZW5ndGgtMV18fHVuZGVmaW5lZDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5oYXNVcmxEdXBsaWNhdGVcblx0XHQgKiBDaGVja3MgaWYgYSBVcmwgd2lsbCBoYXZlIGEgdXJsIGNvbmZsaWN0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG5ld1N0YXRlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gaGFzRHVwbGljYXRlXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5oYXNVcmxEdXBsaWNhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSkge1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGhhc0R1cGxpY2F0ZSA9IGZhbHNlLFxuXHRcdFx0XHRvbGRTdGF0ZTtcblxuXHRcdFx0Ly8gRmV0Y2hcblx0XHRcdG9sZFN0YXRlID0gSGlzdG9yeS5leHRyYWN0U3RhdGUobmV3U3RhdGUudXJsKTtcblxuXHRcdFx0Ly8gQ2hlY2tcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IG9sZFN0YXRlICYmIG9sZFN0YXRlLmlkICE9PSBuZXdTdGF0ZS5pZDtcblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gaGFzRHVwbGljYXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnN0b3JlU3RhdGVcblx0XHQgKiBTdG9yZSBhIFN0YXRlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG5ld1N0YXRlXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBuZXdTdGF0ZVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uKG5ld1N0YXRlKXtcblx0XHRcdC8vIFN0b3JlIHRoZSBTdGF0ZVxuXHRcdFx0SGlzdG9yeS51cmxUb0lkW25ld1N0YXRlLnVybF0gPSBuZXdTdGF0ZS5pZDtcblxuXHRcdFx0Ly8gUHVzaCB0aGUgU3RhdGVcblx0XHRcdEhpc3Rvcnkuc3RvcmVkU3RhdGVzLnB1c2goSGlzdG9yeS5jbG9uZU9iamVjdChuZXdTdGF0ZSkpO1xuXG5cdFx0XHQvLyBSZXR1cm4gbmV3U3RhdGVcblx0XHRcdHJldHVybiBuZXdTdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlKG5ld1N0YXRlKVxuXHRcdCAqIFRlc3RzIHRvIHNlZSBpZiB0aGUgc3RhdGUgaXMgdGhlIGxhc3Qgc3RhdGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbmV3U3RhdGVcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufSBpc0xhc3Rcblx0XHQgKi9cblx0XHRIaXN0b3J5LmlzTGFzdFNhdmVkU3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgaXNMYXN0ID0gZmFsc2UsXG5cdFx0XHRcdG5ld0lkLCBvbGRTdGF0ZSwgb2xkSWQ7XG5cblx0XHRcdC8vIENoZWNrXG5cdFx0XHRpZiAoIEhpc3Rvcnkuc2F2ZWRTdGF0ZXMubGVuZ3RoICkge1xuXHRcdFx0XHRuZXdJZCA9IG5ld1N0YXRlLmlkO1xuXHRcdFx0XHRvbGRTdGF0ZSA9IEhpc3RvcnkuZ2V0TGFzdFNhdmVkU3RhdGUoKTtcblx0XHRcdFx0b2xkSWQgPSBvbGRTdGF0ZS5pZDtcblxuXHRcdFx0XHQvLyBDaGVja1xuXHRcdFx0XHRpc0xhc3QgPSAobmV3SWQgPT09IG9sZElkKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuXG5cdFx0XHRyZXR1cm4gaXNMYXN0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNhdmVTdGF0ZVxuXHRcdCAqIFB1c2ggYSBTdGF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59IGNoYW5nZWRcblx0XHQgKi9cblx0XHRIaXN0b3J5LnNhdmVTdGF0ZSA9IGZ1bmN0aW9uKG5ld1N0YXRlKXtcblx0XHRcdC8vIENoZWNrIEhhc2hcblx0XHRcdGlmICggSGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlKG5ld1N0YXRlKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXNoIHRoZSBTdGF0ZVxuXHRcdFx0SGlzdG9yeS5zYXZlZFN0YXRlcy5wdXNoKEhpc3RvcnkuY2xvbmVPYmplY3QobmV3U3RhdGUpKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRydWVcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmdldFN0YXRlQnlJbmRleCgpXG5cdFx0ICogR2V0cyBhIHN0YXRlIGJ5IHRoZSBpbmRleFxuXHRcdCAqIEBwYXJhbSB7aW50ZWdlcn0gaW5kZXhcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRTdGF0ZUJ5SW5kZXggPSBmdW5jdGlvbihpbmRleCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgU3RhdGUgPSBudWxsO1xuXG5cdFx0XHQvLyBIYW5kbGVcblx0XHRcdGlmICggdHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBsYXN0IGluc2VydGVkXG5cdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5zYXZlZFN0YXRlc1tIaXN0b3J5LnNhdmVkU3RhdGVzLmxlbmd0aC0xXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdC8vIEdldCBmcm9tIHRoZSBlbmRcblx0XHRcdFx0U3RhdGUgPSBIaXN0b3J5LnNhdmVkU3RhdGVzW0hpc3Rvcnkuc2F2ZWRTdGF0ZXMubGVuZ3RoK2luZGV4XTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBHZXQgZnJvbSB0aGUgYmVnaW5uaW5nXG5cdFx0XHRcdFN0YXRlID0gSGlzdG9yeS5zYXZlZFN0YXRlc1tpbmRleF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBTdGF0ZVxuXHRcdFx0cmV0dXJuIFN0YXRlO1xuXHRcdH07XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5nZXRDdXJyZW50SW5kZXgoKVxuXHRcdCAqIEdldHMgdGhlIGN1cnJlbnQgaW5kZXhcblx0XHQgKiBAcmV0dXJuIChpbnRlZ2VyKVxuXHRcdCovXG5cdFx0SGlzdG9yeS5nZXRDdXJyZW50SW5kZXggPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGluZGV4ID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0Ly8gTm8gc3RhdGVzIHNhdmVkXG5cdFx0XHRpZihIaXN0b3J5LnNhdmVkU3RhdGVzLmxlbmd0aCA8IDEpIHtcblx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGluZGV4ID0gSGlzdG9yeS5zYXZlZFN0YXRlcy5sZW5ndGgtMTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9O1xuXG5cdFx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHQvLyBIYXNoIEhlbHBlcnNcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0SGFzaCgpXG5cdFx0ICogQHBhcmFtIHtMb2NhdGlvbj19IGxvY2F0aW9uXG5cdFx0ICogR2V0cyB0aGUgY3VycmVudCBkb2N1bWVudCBoYXNoXG5cdFx0ICogTm90ZTogdW5saWtlIGxvY2F0aW9uLmhhc2gsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gdGhlIGVzY2FwZWQgaGFzaCBpbiBhbGwgYnJvd3NlcnNcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRIYXNoID0gZnVuY3Rpb24oZG9jKXtcblx0XHRcdHZhciB1cmwgPSBIaXN0b3J5LmdldExvY2F0aW9uSHJlZihkb2MpLFxuXHRcdFx0XHRoYXNoO1xuXHRcdFx0aGFzaCA9IEhpc3RvcnkuZ2V0SGFzaEJ5VXJsKHVybCk7XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS51bmVzY2FwZUhhc2goKVxuXHRcdCAqIG5vcm1hbGl6ZSBhbmQgVW5lc2NhcGUgYSBIYXNoXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGhhc2hcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS51bmVzY2FwZUhhc2ggPSBmdW5jdGlvbihoYXNoKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciByZXN1bHQgPSBIaXN0b3J5Lm5vcm1hbGl6ZUhhc2goaGFzaCk7XG5cblx0XHRcdC8vIFVuZXNjYXBlIGhhc2hcblx0XHRcdHJlc3VsdCA9IGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHQpO1xuXG5cdFx0XHQvLyBSZXR1cm4gcmVzdWx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5Lm5vcm1hbGl6ZUhhc2goKVxuXHRcdCAqIG5vcm1hbGl6ZSBhIGhhc2ggYWNyb3NzIGJyb3dzZXJzXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkubm9ybWFsaXplSGFzaCA9IGZ1bmN0aW9uKGhhc2gpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIHJlc3VsdCA9IGhhc2gucmVwbGFjZSgvW14jXSojLywnJykucmVwbGFjZSgvIy4qLywgJycpO1xuXG5cdFx0XHQvLyBSZXR1cm4gcmVzdWx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnNldEhhc2goaGFzaClcblx0XHQgKiBTZXRzIHRoZSBkb2N1bWVudCBoYXNoXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcblx0XHQgKiBAcmV0dXJuIHtIaXN0b3J5fVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkuc2V0SGFzaCA9IGZ1bmN0aW9uKGhhc2gscXVldWUpe1xuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIFN0YXRlLCBwYWdlVXJsO1xuXG5cdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdGlmICggcXVldWUgIT09IGZhbHNlICYmIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkuc2V0SGFzaDogd2UgbXVzdCB3YWl0JywgYXJndW1lbnRzKTtcblx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdGNhbGxiYWNrOiBIaXN0b3J5LnNldEhhc2gsXG5cdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdHF1ZXVlOiBxdWV1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb2dcblx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5zZXRIYXNoOiBjYWxsZWQnLGhhc2gpO1xuXG5cdFx0XHQvLyBNYWtlIEJ1c3kgKyBDb250aW51ZVxuXHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBoYXNoIGlzIGEgc3RhdGVcblx0XHRcdFN0YXRlID0gSGlzdG9yeS5leHRyYWN0U3RhdGUoaGFzaCx0cnVlKTtcblx0XHRcdGlmICggU3RhdGUgJiYgIUhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICkge1xuXHRcdFx0XHQvLyBIYXNoIGlzIGEgc3RhdGUgc28gc2tpcCB0aGUgc2V0SGFzaFxuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkuc2V0SGFzaDogSGFzaCBpcyBhIHN0YXRlIHNvIHNraXBwaW5nIHRoZSBoYXNoIHNldCB3aXRoIGEgZGlyZWN0IHB1c2hTdGF0ZSBjYWxsJyxhcmd1bWVudHMpO1xuXG5cdFx0XHRcdC8vIFB1c2hTdGF0ZVxuXHRcdFx0XHRIaXN0b3J5LnB1c2hTdGF0ZShTdGF0ZS5kYXRhLFN0YXRlLnRpdGxlLFN0YXRlLnVybCxmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggSGlzdG9yeS5nZXRIYXNoKCkgIT09IGhhc2ggKSB7XG5cdFx0XHRcdC8vIEhhc2ggaXMgYSBwcm9wZXIgaGFzaCwgc28gYXBwbHkgaXRcblxuXHRcdFx0XHQvLyBIYW5kbGUgYnJvd3NlciBidWdzXG5cdFx0XHRcdGlmICggSGlzdG9yeS5idWdzLnNldEhhc2ggKSB7XG5cdFx0XHRcdFx0Ly8gRml4IFNhZmFyaSBCdWcgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTU2MjQ5XG5cblx0XHRcdFx0XHQvLyBGZXRjaCB0aGUgYmFzZSBwYWdlXG5cdFx0XHRcdFx0cGFnZVVybCA9IEhpc3RvcnkuZ2V0UGFnZVVybCgpO1xuXG5cdFx0XHRcdFx0Ly8gU2FmYXJpIGhhc2ggYXBwbHlcblx0XHRcdFx0XHRIaXN0b3J5LnB1c2hTdGF0ZShudWxsLG51bGwscGFnZVVybCsnIycraGFzaCxmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gTm9ybWFsIGhhc2ggYXBwbHlcblx0XHRcdFx0XHRkb2N1bWVudC5sb2NhdGlvbi5oYXNoID0gaGFzaDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGFpblxuXHRcdFx0cmV0dXJuIEhpc3Rvcnk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZXNjYXBlKClcblx0XHQgKiBub3JtYWxpemUgYW5kIEVzY2FwZSBhIEhhc2hcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5lc2NhcGVIYXNoID0gZnVuY3Rpb24oaGFzaCl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgcmVzdWx0ID0gSGlzdG9yeS5ub3JtYWxpemVIYXNoKGhhc2gpO1xuXG5cdFx0XHQvLyBFc2NhcGUgaGFzaFxuXHRcdFx0cmVzdWx0ID0gd2luZG93LmVuY29kZVVSSUNvbXBvbmVudChyZXN1bHQpO1xuXG5cdFx0XHQvLyBJRTYgRXNjYXBlIEJ1Z1xuXHRcdFx0aWYgKCAhSGlzdG9yeS5idWdzLmhhc2hFc2NhcGUgKSB7XG5cdFx0XHRcdC8vIFJlc3RvcmUgY29tbW9uIHBhcnRzXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdFxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXCUyMS9nLCchJylcblx0XHRcdFx0XHQucmVwbGFjZSgvXFwlMjYvZywnJicpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcJTNEL2csJz0nKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXCUzRi9nLCc/Jyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiByZXN1bHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ2V0SGFzaEJ5VXJsKHVybClcblx0XHQgKiBFeHRyYWN0cyB0aGUgSGFzaCBmcm9tIGEgVVJMXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gdXJsXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5nZXRIYXNoQnlVcmwgPSBmdW5jdGlvbih1cmwpe1xuXHRcdFx0Ly8gRXh0cmFjdCB0aGUgaGFzaFxuXHRcdFx0dmFyIGhhc2ggPSBTdHJpbmcodXJsKVxuXHRcdFx0XHQucmVwbGFjZSgvKFteI10qKSM/KFteI10qKSM/KC4qKS8sICckMicpXG5cdFx0XHRcdDtcblxuXHRcdFx0Ly8gVW5lc2NhcGUgaGFzaFxuXHRcdFx0aGFzaCA9IEhpc3RvcnkudW5lc2NhcGVIYXNoKGhhc2gpO1xuXG5cdFx0XHQvLyBSZXR1cm4gaGFzaFxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc2V0VGl0bGUodGl0bGUpXG5cdFx0ICogQXBwbGllcyB0aGUgdGl0bGUgdG8gdGhlIGRvY3VtZW50XG5cdFx0ICogQHBhcmFtIHtTdGF0ZX0gbmV3U3RhdGVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdEhpc3Rvcnkuc2V0VGl0bGUgPSBmdW5jdGlvbihuZXdTdGF0ZSl7XG5cdFx0XHQvLyBQcmVwYXJlXG5cdFx0XHR2YXIgdGl0bGUgPSBuZXdTdGF0ZS50aXRsZSxcblx0XHRcdFx0Zmlyc3RTdGF0ZTtcblxuXHRcdFx0Ly8gSW5pdGlhbFxuXHRcdFx0aWYgKCAhdGl0bGUgKSB7XG5cdFx0XHRcdGZpcnN0U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJbmRleCgwKTtcblx0XHRcdFx0aWYgKCBmaXJzdFN0YXRlICYmIGZpcnN0U3RhdGUudXJsID09PSBuZXdTdGF0ZS51cmwgKSB7XG5cdFx0XHRcdFx0dGl0bGUgPSBmaXJzdFN0YXRlLnRpdGxlfHxIaXN0b3J5Lm9wdGlvbnMuaW5pdGlhbFRpdGxlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGl0bGUnKVswXS5pbm5lckhUTUwgPSB0aXRsZS5yZXBsYWNlKCc8JywnJmx0OycpLnJlcGxhY2UoJz4nLCcmZ3Q7JykucmVwbGFjZSgnICYgJywnICZhbXA7ICcpO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBFeGNlcHRpb24gKSB7IH1cblx0XHRcdGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG5cblx0XHRcdC8vIENoYWluXG5cdFx0XHRyZXR1cm4gSGlzdG9yeTtcblx0XHR9O1xuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIFF1ZXVlaW5nXG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LnF1ZXVlc1xuXHRcdCAqIFRoZSBsaXN0IG9mIHF1ZXVlcyB0byB1c2Vcblx0XHQgKiBGaXJzdCBJbiwgRmlyc3QgT3V0XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5xdWV1ZXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuYnVzeSh2YWx1ZSlcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFtvcHRpb25hbF1cblx0XHQgKiBAcmV0dXJuIHtib29sZWFufSBidXN5XG5cdFx0ICovXG5cdFx0SGlzdG9yeS5idXN5ID0gZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0Ly8gQXBwbHlcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmJ1c3k6IGNoYW5naW5nIFsnKyhIaXN0b3J5LmJ1c3kuZmxhZ3x8ZmFsc2UpKyddIHRvIFsnKyh2YWx1ZXx8ZmFsc2UpKyddJywgSGlzdG9yeS5xdWV1ZXMubGVuZ3RoKTtcblx0XHRcdFx0SGlzdG9yeS5idXN5LmZsYWcgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdC8vIERlZmF1bHRcblx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgSGlzdG9yeS5idXN5LmZsYWcgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRIaXN0b3J5LmJ1c3kuZmxhZyA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBRdWV1ZVxuXHRcdFx0aWYgKCAhSGlzdG9yeS5idXN5LmZsYWcgKSB7XG5cdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIG5leHQgaXRlbSBpbiB0aGUgcXVldWVcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KEhpc3RvcnkuYnVzeS50aW1lb3V0KTtcblx0XHRcdFx0dmFyIGZpcmVOZXh0ID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgaSwgcXVldWUsIGl0ZW07XG5cdFx0XHRcdFx0aWYgKCBIaXN0b3J5LmJ1c3kuZmxhZyApIHJldHVybjtcblx0XHRcdFx0XHRmb3IgKCBpPUhpc3RvcnkucXVldWVzLmxlbmd0aC0xOyBpID49IDA7IC0taSApIHtcblx0XHRcdFx0XHRcdHF1ZXVlID0gSGlzdG9yeS5xdWV1ZXNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIHF1ZXVlLmxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aXRlbSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LmZpcmVRdWV1ZUl0ZW0oaXRlbSk7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LmJ1c3kudGltZW91dCA9IHNldFRpbWVvdXQoZmlyZU5leHQsSGlzdG9yeS5vcHRpb25zLmJ1c3lEZWxheSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRIaXN0b3J5LmJ1c3kudGltZW91dCA9IHNldFRpbWVvdXQoZmlyZU5leHQsSGlzdG9yeS5vcHRpb25zLmJ1c3lEZWxheSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVyblxuXHRcdFx0cmV0dXJuIEhpc3RvcnkuYnVzeS5mbGFnO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmJ1c3kuZmxhZ1xuXHRcdCAqL1xuXHRcdEhpc3RvcnkuYnVzeS5mbGFnID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmZpcmVRdWV1ZUl0ZW0oaXRlbSlcblx0XHQgKiBGaXJlIGEgUXVldWUgSXRlbVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdFx0ICogQHJldHVybiB7TWl4ZWR9IHJlc3VsdFxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZmlyZVF1ZXVlSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0cmV0dXJuIGl0ZW0uY2FsbGJhY2suYXBwbHkoaXRlbS5zY29wZXx8SGlzdG9yeSxpdGVtLmFyZ3N8fFtdKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5wdXNoUXVldWUoY2FsbGJhY2ssYXJncylcblx0XHQgKiBBZGQgYW4gaXRlbSB0byB0aGUgcXVldWVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBbc2NvcGUsY2FsbGJhY2ssYXJncyxxdWV1ZV1cblx0XHQgKi9cblx0XHRIaXN0b3J5LnB1c2hRdWV1ZSA9IGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0Ly8gUHJlcGFyZSB0aGUgcXVldWVcblx0XHRcdEhpc3RvcnkucXVldWVzW2l0ZW0ucXVldWV8fDBdID0gSGlzdG9yeS5xdWV1ZXNbaXRlbS5xdWV1ZXx8MF18fFtdO1xuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIHF1ZXVlXG5cdFx0XHRIaXN0b3J5LnF1ZXVlc1tpdGVtLnF1ZXVlfHwwXS5wdXNoKGl0ZW0pO1xuXG5cdFx0XHQvLyBDaGFpblxuXHRcdFx0cmV0dXJuIEhpc3Rvcnk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkucXVldWUgKGl0ZW0scXVldWUpLCAoZnVuYyxxdWV1ZSksIChmdW5jKSwgKGl0ZW0pXG5cdFx0ICogRWl0aGVyIGZpcnMgdGhlIGl0ZW0gbm93IGlmIG5vdCBidXN5LCBvciBhZGRzIGl0IHRvIHRoZSBxdWV1ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkucXVldWUgPSBmdW5jdGlvbihpdGVtLHF1ZXVlKXtcblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGl0ZW0gPSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2s6IGl0ZW1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHF1ZXVlICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0aXRlbS5xdWV1ZSA9IHF1ZXVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGVcblx0XHRcdGlmICggSGlzdG9yeS5idXN5KCkgKSB7XG5cdFx0XHRcdEhpc3RvcnkucHVzaFF1ZXVlKGl0ZW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0SGlzdG9yeS5maXJlUXVldWVJdGVtKGl0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGFpblxuXHRcdFx0cmV0dXJuIEhpc3Rvcnk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuY2xlYXJRdWV1ZSgpXG5cdFx0ICogQ2xlYXJzIHRoZSBRdWV1ZVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuY2xlYXJRdWV1ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRIaXN0b3J5LmJ1c3kuZmxhZyA9IGZhbHNlO1xuXHRcdFx0SGlzdG9yeS5xdWV1ZXMgPSBbXTtcblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSUUgQnVnIEZpeFxuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5zdGF0ZUNoYW5nZWRcblx0XHQgKiBTdGF0ZXMgd2hldGhlciBvciBub3QgdGhlIHN0YXRlIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGRvdWJsZSBjaGVjayB3YXMgaW5pdGlhbGlzZWRcblx0XHQgKi9cblx0XHRIaXN0b3J5LnN0YXRlQ2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5kb3VibGVDaGVja2VyXG5cdFx0ICogQ29udGFpbnMgdGhlIHRpbWVvdXQgdXNlZCBmb3IgdGhlIGRvdWJsZSBjaGVja3Ncblx0XHQgKi9cblx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrZXIgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZG91YmxlQ2hlY2tDb21wbGV0ZSgpXG5cdFx0ICogQ29tcGxldGUgYSBkb3VibGUgY2hlY2tcblx0XHQgKiBAcmV0dXJuIHtIaXN0b3J5fVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZG91YmxlQ2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBVcGRhdGVcblx0XHRcdEhpc3Rvcnkuc3RhdGVDaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXJcblx0XHRcdEhpc3RvcnkuZG91YmxlQ2hlY2tDbGVhcigpO1xuXG5cdFx0XHQvLyBDaGFpblxuXHRcdFx0cmV0dXJuIEhpc3Rvcnk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZG91YmxlQ2hlY2tDbGVhcigpXG5cdFx0ICogQ2xlYXIgYSBkb3VibGUgY2hlY2tcblx0XHQgKiBAcmV0dXJuIHtIaXN0b3J5fVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZG91YmxlQ2hlY2tDbGVhciA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBDbGVhclxuXHRcdFx0aWYgKCBIaXN0b3J5LmRvdWJsZUNoZWNrZXIgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dChIaXN0b3J5LmRvdWJsZUNoZWNrZXIpO1xuXHRcdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrZXIgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIaXN0b3J5LmRvdWJsZUNoZWNrKClcblx0XHQgKiBDcmVhdGUgYSBkb3VibGUgY2hlY2tcblx0XHQgKiBAcmV0dXJuIHtIaXN0b3J5fVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZG91YmxlQ2hlY2sgPSBmdW5jdGlvbih0cnlBZ2Fpbil7XG5cdFx0XHQvLyBSZXNldFxuXHRcdFx0SGlzdG9yeS5zdGF0ZUNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdEhpc3RvcnkuZG91YmxlQ2hlY2tDbGVhcigpO1xuXG5cdFx0XHQvLyBGaXggSUU2LElFNyBidWcgd2hlcmUgY2FsbGluZyBoaXN0b3J5LmJhY2sgb3IgaGlzdG9yeS5mb3J3YXJkIGRvZXMgbm90IGFjdHVhbGx5IGNoYW5nZSB0aGUgaGFzaCAod2hlcmVhcyBkb2luZyBpdCBtYW51YWxseSBkb2VzKVxuXHRcdFx0Ly8gRml4IFNhZmFyaSA1IGJ1ZyB3aGVyZSBzb21ldGltZXMgdGhlIHN0YXRlIGRvZXMgbm90IGNoYW5nZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQyOTQwXG5cdFx0XHRpZiAoIEhpc3RvcnkuYnVncy5pZURvdWJsZUNoZWNrICkge1xuXHRcdFx0XHQvLyBBcHBseSBDaGVja1xuXHRcdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrZXIgPSBzZXRUaW1lb3V0KFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrQ2xlYXIoKTtcblx0XHRcdFx0XHRcdGlmICggIUhpc3Rvcnkuc3RhdGVDaGFuZ2VkICkge1xuXHRcdFx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuZG91YmxlQ2hlY2s6IFN0YXRlIGhhcyBub3QgeWV0IGNoYW5nZWQsIHRyeWluZyBhZ2FpbicsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdC8vIFJlLUF0dGVtcHRcblx0XHRcdFx0XHRcdFx0dHJ5QWdhaW4oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0SGlzdG9yeS5vcHRpb25zLmRvdWJsZUNoZWNrSW50ZXJ2YWxcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gU2FmYXJpIEJ1ZyBGaXhcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3Rvcnkuc2FmYXJpU3RhdGVQb2xsKClcblx0XHQgKiBQb2xsIHRoZSBjdXJyZW50IHN0YXRlXG5cdFx0ICogQHJldHVybiB7SGlzdG9yeX1cblx0XHQgKi9cblx0XHRIaXN0b3J5LnNhZmFyaVN0YXRlUG9sbCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBQb2xsIHRoZSBVUkxcblxuXHRcdFx0Ly8gR2V0IHRoZSBMYXN0IFN0YXRlIHdoaWNoIGhhcyB0aGUgbmV3IFVSTFxuXHRcdFx0dmFyXG5cdFx0XHRcdHVybFN0YXRlID0gSGlzdG9yeS5leHRyYWN0U3RhdGUoSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSksXG5cdFx0XHRcdG5ld1N0YXRlO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgYSBkaWZmZXJlbmNlXG5cdFx0XHRpZiAoICFIaXN0b3J5LmlzTGFzdFNhdmVkU3RhdGUodXJsU3RhdGUpICkge1xuXHRcdFx0XHRuZXdTdGF0ZSA9IHVybFN0YXRlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgaWYgd2UgaGF2ZSBhIHN0YXRlIHdpdGggdGhhdCB1cmxcblx0XHRcdC8vIElmIG5vdCBjcmVhdGUgaXRcblx0XHRcdGlmICggIW5ld1N0YXRlICkge1xuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkuc2FmYXJpU3RhdGVQb2xsOiBuZXcnKTtcblx0XHRcdFx0bmV3U3RhdGUgPSBIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHRoZSBOZXcgU3RhdGVcblx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5zYWZhcmlTdGF0ZVBvbGw6IHRyaWdnZXInKTtcblx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywncG9wc3RhdGUnKTtcblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gU3RhdGUgQWxpYXNlc1xuXG5cdFx0LyoqXG5cdFx0ICogSGlzdG9yeS5iYWNrKHF1ZXVlKVxuXHRcdCAqIFNlbmQgdGhlIGJyb3dzZXIgaGlzdG9yeSBiYWNrIG9uZSBpdGVtXG5cdFx0ICogQHBhcmFtIHtJbnRlZ2VyfSBxdWV1ZSBbb3B0aW9uYWxdXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5iYWNrID0gZnVuY3Rpb24ocXVldWUpe1xuXHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LmJhY2s6IGNhbGxlZCcsIGFyZ3VtZW50cyk7XG5cblx0XHRcdC8vIEhhbmRsZSBRdWV1ZWluZ1xuXHRcdFx0aWYgKCBxdWV1ZSAhPT0gZmFsc2UgJiYgSGlzdG9yeS5idXN5KCkgKSB7XG5cdFx0XHRcdC8vIFdhaXQgKyBQdXNoIHRvIFF1ZXVlXG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5iYWNrOiB3ZSBtdXN0IHdhaXQnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRIaXN0b3J5LnB1c2hRdWV1ZSh7XG5cdFx0XHRcdFx0c2NvcGU6IEhpc3RvcnksXG5cdFx0XHRcdFx0Y2FsbGJhY2s6IEhpc3RvcnkuYmFjayxcblx0XHRcdFx0XHRhcmdzOiBhcmd1bWVudHMsXG5cdFx0XHRcdFx0cXVldWU6IHF1ZXVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2UgQnVzeSArIENvbnRpbnVlXG5cdFx0XHRIaXN0b3J5LmJ1c3kodHJ1ZSk7XG5cblx0XHRcdC8vIEZpeCBjZXJ0YWluIGJyb3dzZXIgYnVncyB0aGF0IHByZXZlbnQgdGhlIHN0YXRlIGZyb20gY2hhbmdpbmdcblx0XHRcdEhpc3RvcnkuZG91YmxlQ2hlY2soZnVuY3Rpb24oKXtcblx0XHRcdFx0SGlzdG9yeS5iYWNrKGZhbHNlKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBHbyBiYWNrXG5cdFx0XHRoaXN0b3J5LmdvKC0xKTtcblxuXHRcdFx0Ly8gRW5kIGJhY2sgY2xvc3VyZVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZm9yd2FyZChxdWV1ZSlcblx0XHQgKiBTZW5kIHRoZSBicm93c2VyIGhpc3RvcnkgZm9yd2FyZCBvbmUgaXRlbVxuXHRcdCAqIEBwYXJhbSB7SW50ZWdlcn0gcXVldWUgW29wdGlvbmFsXVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZm9yd2FyZCA9IGZ1bmN0aW9uKHF1ZXVlKXtcblx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5mb3J3YXJkOiBjYWxsZWQnLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBIYW5kbGUgUXVldWVpbmdcblx0XHRcdGlmICggcXVldWUgIT09IGZhbHNlICYmIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuZm9yd2FyZDogd2UgbXVzdCB3YWl0JywgYXJndW1lbnRzKTtcblx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdHNjb3BlOiBIaXN0b3J5LFxuXHRcdFx0XHRcdGNhbGxiYWNrOiBIaXN0b3J5LmZvcndhcmQsXG5cdFx0XHRcdFx0YXJnczogYXJndW1lbnRzLFxuXHRcdFx0XHRcdHF1ZXVlOiBxdWV1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIEJ1c3kgKyBDb250aW51ZVxuXHRcdFx0SGlzdG9yeS5idXN5KHRydWUpO1xuXG5cdFx0XHQvLyBGaXggY2VydGFpbiBicm93c2VyIGJ1Z3MgdGhhdCBwcmV2ZW50IHRoZSBzdGF0ZSBmcm9tIGNoYW5naW5nXG5cdFx0XHRIaXN0b3J5LmRvdWJsZUNoZWNrKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdEhpc3RvcnkuZm9yd2FyZChmYWxzZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gR28gZm9yd2FyZFxuXHRcdFx0aGlzdG9yeS5nbygxKTtcblxuXHRcdFx0Ly8gRW5kIGZvcndhcmQgY2xvc3VyZVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpc3RvcnkuZ28oaW5kZXgscXVldWUpXG5cdFx0ICogU2VuZCB0aGUgYnJvd3NlciBoaXN0b3J5IGJhY2sgb3IgZm9yd2FyZCBpbmRleCB0aW1lc1xuXHRcdCAqIEBwYXJhbSB7SW50ZWdlcn0gcXVldWUgW29wdGlvbmFsXVxuXHRcdCAqL1xuXHRcdEhpc3RvcnkuZ28gPSBmdW5jdGlvbihpbmRleCxxdWV1ZSl7XG5cdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3RvcnkuZ286IGNhbGxlZCcsIGFyZ3VtZW50cyk7XG5cblx0XHRcdC8vIFByZXBhcmVcblx0XHRcdHZhciBpO1xuXG5cdFx0XHQvLyBIYW5kbGVcblx0XHRcdGlmICggaW5kZXggPiAwICkge1xuXHRcdFx0XHQvLyBGb3J3YXJkXG5cdFx0XHRcdGZvciAoIGk9MTsgaTw9aW5kZXg7ICsraSApIHtcblx0XHRcdFx0XHRIaXN0b3J5LmZvcndhcmQocXVldWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHQvLyBCYWNrd2FyZFxuXHRcdFx0XHRmb3IgKCBpPS0xOyBpPj1pbmRleDsgLS1pICkge1xuXHRcdFx0XHRcdEhpc3RvcnkuYmFjayhxdWV1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuZ286IEhpc3RvcnkuZ28gcmVxdWlyZXMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIHBhc3NlZC4nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhaW5cblx0XHRcdHJldHVybiBIaXN0b3J5O1xuXHRcdH07XG5cblxuXHRcdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0Ly8gSFRNTDUgU3RhdGUgU3VwcG9ydFxuXG5cdFx0Ly8gTm9uLU5hdGl2ZSBwdXNoU3RhdGUgSW1wbGVtZW50YXRpb25cblx0XHRpZiAoIEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICkge1xuXHRcdFx0Lypcblx0XHRcdCAqIFByb3ZpZGUgU2tlbGV0b24gZm9yIEhUTUw0IEJyb3dzZXJzXG5cdFx0XHQgKi9cblxuXHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0dmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbigpe307XG5cdFx0XHRIaXN0b3J5LnB1c2hTdGF0ZSA9IEhpc3RvcnkucHVzaFN0YXRlfHxlbXB0eUZ1bmN0aW9uO1xuXHRcdFx0SGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBIaXN0b3J5LnJlcGxhY2VTdGF0ZXx8ZW1wdHlGdW5jdGlvbjtcblx0XHR9IC8vIEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlXG5cblx0XHQvLyBOYXRpdmUgcHVzaFN0YXRlIEltcGxlbWVudGF0aW9uXG5cdFx0ZWxzZSB7XG5cdFx0XHQvKlxuXHRcdFx0ICogVXNlIG5hdGl2ZSBIVE1MNSBIaXN0b3J5IEFQSSBJbXBsZW1lbnRhdGlvblxuXHRcdFx0ICovXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSGlzdG9yeS5vblBvcFN0YXRlKGV2ZW50LGV4dHJhKVxuXHRcdFx0ICogUmVmcmVzaCB0aGUgQ3VycmVudCBTdGF0ZVxuXHRcdFx0ICovXG5cdFx0XHRIaXN0b3J5Lm9uUG9wU3RhdGUgPSBmdW5jdGlvbihldmVudCxleHRyYSl7XG5cdFx0XHRcdC8vIFByZXBhcmVcblx0XHRcdFx0dmFyIHN0YXRlSWQgPSBmYWxzZSwgbmV3U3RhdGUgPSBmYWxzZSwgY3VycmVudEhhc2gsIGN1cnJlbnRTdGF0ZTtcblxuXHRcdFx0XHQvLyBSZXNldCB0aGUgZG91YmxlIGNoZWNrXG5cdFx0XHRcdEhpc3RvcnkuZG91YmxlQ2hlY2tDb21wbGV0ZSgpO1xuXG5cdFx0XHRcdC8vIENoZWNrIGZvciBhIEhhc2gsIGFuZCBoYW5kbGUgYXBwb3JpYXRseVxuXHRcdFx0XHRjdXJyZW50SGFzaCA9IEhpc3RvcnkuZ2V0SGFzaCgpO1xuXHRcdFx0XHRpZiAoIGN1cnJlbnRIYXNoICkge1xuXHRcdFx0XHRcdC8vIEV4cGFuZCBIYXNoXG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlID0gSGlzdG9yeS5leHRyYWN0U3RhdGUoY3VycmVudEhhc2h8fEhpc3RvcnkuZ2V0TG9jYXRpb25IcmVmKCksdHJ1ZSk7XG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50U3RhdGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBXZSB3ZXJlIGFibGUgdG8gcGFyc2UgaXQsIGl0IG11c3QgYmUgYSBTdGF0ZSFcblx0XHRcdFx0XHRcdC8vIExldCdzIGZvcndhcmQgdG8gcmVwbGFjZVN0YXRlXG5cdFx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25Qb3BTdGF0ZTogc3RhdGUgYW5jaG9yJywgY3VycmVudEhhc2gsIGN1cnJlbnRTdGF0ZSk7XG5cdFx0XHRcdFx0XHRIaXN0b3J5LnJlcGxhY2VTdGF0ZShjdXJyZW50U3RhdGUuZGF0YSwgY3VycmVudFN0YXRlLnRpdGxlLCBjdXJyZW50U3RhdGUudXJsLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gVHJhZGl0aW9uYWwgQW5jaG9yXG5cdFx0XHRcdFx0XHQvL0hpc3RvcnkuZGVidWcoJ0hpc3Rvcnkub25Qb3BTdGF0ZTogdHJhZGl0aW9uYWwgYW5jaG9yJywgY3VycmVudEhhc2gpO1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdhbmNob3JjaGFuZ2UnKTtcblx0XHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgY2FyZSBmb3IgaGFzaGVzXG5cdFx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFbnN1cmVcblx0XHRcdFx0c3RhdGVJZCA9IEhpc3RvcnkuQWRhcHRlci5leHRyYWN0RXZlbnREYXRhKCdzdGF0ZScsZXZlbnQsZXh0cmEpIHx8IGZhbHNlO1xuXG5cdFx0XHRcdC8vIEZldGNoIFN0YXRlXG5cdFx0XHRcdGlmICggc3RhdGVJZCApIHtcblx0XHRcdFx0XHQvLyBWYW5pbGxhOiBCYWNrL2ZvcndhcmQgYnV0dG9uIHdhcyB1c2VkXG5cdFx0XHRcdFx0bmV3U3RhdGUgPSBIaXN0b3J5LmdldFN0YXRlQnlJZChzdGF0ZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggSGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgKSB7XG5cdFx0XHRcdFx0Ly8gVmFuaWxsYTogQSBuZXcgc3RhdGUgd2FzIHB1c2hlZCwgYW5kIHBvcHN0YXRlIHdhcyBjYWxsZWQgbWFudWFsbHlcblx0XHRcdFx0XHRuZXdTdGF0ZSA9IEhpc3RvcnkuZ2V0U3RhdGVCeUlkKEhpc3RvcnkuZXhwZWN0ZWRTdGF0ZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBJbml0aWFsIFN0YXRlXG5cdFx0XHRcdFx0bmV3U3RhdGUgPSBIaXN0b3J5LmV4dHJhY3RTdGF0ZShIaXN0b3J5LmdldExvY2F0aW9uSHJlZigpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoZSBTdGF0ZSBkaWQgbm90IGV4aXN0IGluIG91ciBzdG9yZVxuXHRcdFx0XHRpZiAoICFuZXdTdGF0ZSApIHtcblx0XHRcdFx0XHQvLyBSZWdlbmVyYXRlIHRoZSBTdGF0ZVxuXHRcdFx0XHRcdG5ld1N0YXRlID0gSGlzdG9yeS5jcmVhdGVTdGF0ZU9iamVjdChudWxsLG51bGwsSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDbGVhblxuXHRcdFx0XHRIaXN0b3J5LmV4cGVjdGVkU3RhdGVJZCA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSB0aGUgc2FtZSBzdGF0ZVxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSkgKSB7XG5cdFx0XHRcdFx0Ly8gVGhlcmUgaGFzIGJlZW4gbm8gY2hhbmdlIChqdXN0IHRoZSBwYWdlJ3MgaGFzaCBoYXMgZmluYWxseSBwcm9wYWdhdGVkKVxuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5vblBvcFN0YXRlOiBubyBjaGFuZ2UnLCBuZXdTdGF0ZSwgSGlzdG9yeS5zYXZlZFN0YXRlcyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5idXN5KGZhbHNlKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgU3RhdGVcblx0XHRcdFx0SGlzdG9yeS5zdG9yZVN0YXRlKG5ld1N0YXRlKTtcblx0XHRcdFx0SGlzdG9yeS5zYXZlU3RhdGUobmV3U3RhdGUpO1xuXG5cdFx0XHRcdC8vIEZvcmNlIHVwZGF0ZSBvZiB0aGUgdGl0bGVcblx0XHRcdFx0SGlzdG9yeS5zZXRUaXRsZShuZXdTdGF0ZSk7XG5cblx0XHRcdFx0Ly8gRmlyZSBPdXIgRXZlbnRcblx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdzdGF0ZWNoYW5nZScpO1xuXHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXG5cdFx0XHRcdC8vIFJldHVybiB0cnVlXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fTtcblx0XHRcdEhpc3RvcnkuQWRhcHRlci5iaW5kKHdpbmRvdywncG9wc3RhdGUnLEhpc3Rvcnkub25Qb3BTdGF0ZSk7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSGlzdG9yeS5wdXNoU3RhdGUoZGF0YSx0aXRsZSx1cmwpXG5cdFx0XHQgKiBBZGQgYSBuZXcgU3RhdGUgdG8gdGhlIGhpc3Rvcnkgb2JqZWN0LCBiZWNvbWUgaXQsIGFuZCB0cmlnZ2VyIG9ucG9wc3RhdGVcblx0XHRcdCAqIFdlIGhhdmUgdG8gdHJpZ2dlciBmb3IgSFRNTDQgY29tcGF0aWJpbGl0eVxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHRcdFx0ICogQHJldHVybiB7dHJ1ZX1cblx0XHRcdCAqL1xuXHRcdFx0SGlzdG9yeS5wdXNoU3RhdGUgPSBmdW5jdGlvbihkYXRhLHRpdGxlLHVybCxxdWV1ZSl7XG5cdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5wdXNoU3RhdGU6IGNhbGxlZCcsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgdGhlIFN0YXRlXG5cdFx0XHRcdGlmICggSGlzdG9yeS5nZXRIYXNoQnlVcmwodXJsKSAmJiBIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hpc3RvcnkuanMgZG9lcyBub3Qgc3VwcG9ydCBzdGF0ZXMgd2l0aCBmcmFnZW1lbnQtaWRlbnRpZmllcnMgKGhhc2hlcy9hbmNob3JzKS4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBRdWV1ZWluZ1xuXHRcdFx0XHRpZiAoIHF1ZXVlICE9PSBmYWxzZSAmJiBIaXN0b3J5LmJ1c3koKSApIHtcblx0XHRcdFx0XHQvLyBXYWl0ICsgUHVzaCB0byBRdWV1ZVxuXHRcdFx0XHRcdC8vSGlzdG9yeS5kZWJ1ZygnSGlzdG9yeS5wdXNoU3RhdGU6IHdlIG11c3Qgd2FpdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0SGlzdG9yeS5wdXNoUXVldWUoe1xuXHRcdFx0XHRcdFx0c2NvcGU6IEhpc3RvcnksXG5cdFx0XHRcdFx0XHRjYWxsYmFjazogSGlzdG9yeS5wdXNoU3RhdGUsXG5cdFx0XHRcdFx0XHRhcmdzOiBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRxdWV1ZTogcXVldWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIEJ1c3kgKyBDb250aW51ZVxuXHRcdFx0XHRIaXN0b3J5LmJ1c3kodHJ1ZSk7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHR2YXIgbmV3U3RhdGUgPSBIaXN0b3J5LmNyZWF0ZVN0YXRlT2JqZWN0KGRhdGEsdGl0bGUsdXJsKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpdFxuXHRcdFx0XHRpZiAoIEhpc3RvcnkuaXNMYXN0U2F2ZWRTdGF0ZShuZXdTdGF0ZSkgKSB7XG5cdFx0XHRcdFx0Ly8gV29uJ3QgYmUgYSBjaGFuZ2Vcblx0XHRcdFx0XHRIaXN0b3J5LmJ1c3koZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBuZXdTdGF0ZVxuXHRcdFx0XHRcdEhpc3Rvcnkuc3RvcmVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0XHRcdFx0SGlzdG9yeS5leHBlY3RlZFN0YXRlSWQgPSBuZXdTdGF0ZS5pZDtcblxuXHRcdFx0XHRcdC8vIFB1c2ggdGhlIG5ld1N0YXRlXG5cdFx0XHRcdFx0aGlzdG9yeS5wdXNoU3RhdGUobmV3U3RhdGUuaWQsbmV3U3RhdGUudGl0bGUsbmV3U3RhdGUudXJsKTtcblxuXHRcdFx0XHRcdC8vIEZpcmUgSFRNTDUgRXZlbnRcblx0XHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIudHJpZ2dlcih3aW5kb3csJ3BvcHN0YXRlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFbmQgcHVzaFN0YXRlIGNsb3N1cmVcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEhpc3RvcnkucmVwbGFjZVN0YXRlKGRhdGEsdGl0bGUsdXJsKVxuXHRcdFx0ICogUmVwbGFjZSB0aGUgU3RhdGUgYW5kIHRyaWdnZXIgb25wb3BzdGF0ZVxuXHRcdFx0ICogV2UgaGF2ZSB0byB0cmlnZ2VyIGZvciBIVE1MNCBjb21wYXRpYmlsaXR5XG5cdFx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG5cdFx0XHQgKiBAcmV0dXJuIHt0cnVlfVxuXHRcdFx0ICovXG5cdFx0XHRIaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uKGRhdGEsdGl0bGUsdXJsLHF1ZXVlKXtcblx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnJlcGxhY2VTdGF0ZTogY2FsbGVkJywgYXJndW1lbnRzKTtcblxuXHRcdFx0XHQvLyBDaGVjayB0aGUgU3RhdGVcblx0XHRcdFx0aWYgKCBIaXN0b3J5LmdldEhhc2hCeVVybCh1cmwpICYmIEhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSGlzdG9yeS5qcyBkb2VzIG5vdCBzdXBwb3J0IHN0YXRlcyB3aXRoIGZyYWdlbWVudC1pZGVudGlmaWVycyAoaGFzaGVzL2FuY2hvcnMpLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIFF1ZXVlaW5nXG5cdFx0XHRcdGlmICggcXVldWUgIT09IGZhbHNlICYmIEhpc3RvcnkuYnVzeSgpICkge1xuXHRcdFx0XHRcdC8vIFdhaXQgKyBQdXNoIHRvIFF1ZXVlXG5cdFx0XHRcdFx0Ly9IaXN0b3J5LmRlYnVnKCdIaXN0b3J5LnJlcGxhY2VTdGF0ZTogd2UgbXVzdCB3YWl0JywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRIaXN0b3J5LnB1c2hRdWV1ZSh7XG5cdFx0XHRcdFx0XHRzY29wZTogSGlzdG9yeSxcblx0XHRcdFx0XHRcdGNhbGxiYWNrOiBIaXN0b3J5LnJlcGxhY2VTdGF0ZSxcblx0XHRcdFx0XHRcdGFyZ3M6IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdHF1ZXVlOiBxdWV1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1ha2UgQnVzeSArIENvbnRpbnVlXG5cdFx0XHRcdEhpc3RvcnkuYnVzeSh0cnVlKTtcblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIG5ld1N0YXRlXG5cdFx0XHRcdHZhciBuZXdTdGF0ZSA9IEhpc3RvcnkuY3JlYXRlU3RhdGVPYmplY3QoZGF0YSx0aXRsZSx1cmwpO1xuXG5cdFx0XHRcdC8vIENoZWNrIGl0XG5cdFx0XHRcdGlmICggSGlzdG9yeS5pc0xhc3RTYXZlZFN0YXRlKG5ld1N0YXRlKSApIHtcblx0XHRcdFx0XHQvLyBXb24ndCBiZSBhIGNoYW5nZVxuXHRcdFx0XHRcdEhpc3RvcnkuYnVzeShmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIG5ld1N0YXRlXG5cdFx0XHRcdFx0SGlzdG9yeS5zdG9yZVN0YXRlKG5ld1N0YXRlKTtcblx0XHRcdFx0XHRIaXN0b3J5LmV4cGVjdGVkU3RhdGVJZCA9IG5ld1N0YXRlLmlkO1xuXG5cdFx0XHRcdFx0Ly8gUHVzaCB0aGUgbmV3U3RhdGVcblx0XHRcdFx0XHRoaXN0b3J5LnJlcGxhY2VTdGF0ZShuZXdTdGF0ZS5pZCxuZXdTdGF0ZS50aXRsZSxuZXdTdGF0ZS51cmwpO1xuXG5cdFx0XHRcdFx0Ly8gRmlyZSBIVE1MNSBFdmVudFxuXHRcdFx0XHRcdEhpc3RvcnkuQWRhcHRlci50cmlnZ2VyKHdpbmRvdywncG9wc3RhdGUnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEVuZCByZXBsYWNlU3RhdGUgY2xvc3VyZVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cblx0XHR9IC8vICFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZVxuXG5cblx0XHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdC8vIEluaXRpYWxpc2VcblxuXHRcdC8qKlxuXHRcdCAqIExvYWQgdGhlIFN0b3JlXG5cdFx0ICovXG5cdFx0aWYgKCBzZXNzaW9uU3RvcmFnZSApIHtcblx0XHRcdC8vIEZldGNoXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRIaXN0b3J5LnN0b3JlID0gSlNPTi5wYXJzZShzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdIaXN0b3J5LnN0b3JlJykpfHx7fTtcblx0XHRcdH1cblx0XHRcdGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRIaXN0b3J5LnN0b3JlID0ge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vcm1hbGl6ZVxuXHRcdFx0SGlzdG9yeS5ub3JtYWxpemVTdG9yZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIERlZmF1bHQgTG9hZFxuXHRcdFx0SGlzdG9yeS5zdG9yZSA9IHt9O1xuXHRcdFx0SGlzdG9yeS5ub3JtYWxpemVTdG9yZSgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENsZWFyIEludGVydmFscyBvbiBleGl0IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0ICovXG5cdFx0SGlzdG9yeS5BZGFwdGVyLmJpbmQod2luZG93LFwidW5sb2FkXCIsSGlzdG9yeS5jbGVhckFsbEludGVydmFscyk7XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgdGhlIGluaXRpYWwgU3RhdGVcblx0XHQgKi9cblx0XHRIaXN0b3J5LnNhdmVTdGF0ZShIaXN0b3J5LnN0b3JlU3RhdGUoSGlzdG9yeS5leHRyYWN0U3RhdGUoSGlzdG9yeS5nZXRMb2NhdGlvbkhyZWYoKSx0cnVlKSkpO1xuXG5cdFx0LyoqXG5cdFx0ICogQmluZCBmb3IgU2F2aW5nIFN0b3JlXG5cdFx0ICovXG5cdFx0aWYgKCBzZXNzaW9uU3RvcmFnZSApIHtcblx0XHRcdC8vIFdoZW4gdGhlIHBhZ2UgaXMgY2xvc2VkXG5cdFx0XHRIaXN0b3J5Lm9uVW5sb2FkID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0Ly8gUHJlcGFyZVxuXHRcdFx0XHR2YXJcdGN1cnJlbnRTdG9yZSwgaXRlbSwgY3VycmVudFN0b3JlU3RyaW5nO1xuXG5cdFx0XHRcdC8vIEZldGNoXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y3VycmVudFN0b3JlID0gSlNPTi5wYXJzZShzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdIaXN0b3J5LnN0b3JlJykpfHx7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHRjdXJyZW50U3RvcmUgPSB7fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEVuc3VyZVxuXHRcdFx0XHRjdXJyZW50U3RvcmUuaWRUb1N0YXRlID0gY3VycmVudFN0b3JlLmlkVG9TdGF0ZSB8fCB7fTtcblx0XHRcdFx0Y3VycmVudFN0b3JlLnVybFRvSWQgPSBjdXJyZW50U3RvcmUudXJsVG9JZCB8fCB7fTtcblx0XHRcdFx0Y3VycmVudFN0b3JlLnN0YXRlVG9JZCA9IGN1cnJlbnRTdG9yZS5zdGF0ZVRvSWQgfHwge307XG5cblx0XHRcdFx0Ly8gU3luY1xuXHRcdFx0XHRmb3IgKCBpdGVtIGluIEhpc3RvcnkuaWRUb1N0YXRlICkge1xuXHRcdFx0XHRcdGlmICggIUhpc3RvcnkuaWRUb1N0YXRlLmhhc093blByb3BlcnR5KGl0ZW0pICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1cnJlbnRTdG9yZS5pZFRvU3RhdGVbaXRlbV0gPSBIaXN0b3J5LmlkVG9TdGF0ZVtpdGVtXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBpdGVtIGluIEhpc3RvcnkudXJsVG9JZCApIHtcblx0XHRcdFx0XHRpZiAoICFIaXN0b3J5LnVybFRvSWQuaGFzT3duUHJvcGVydHkoaXRlbSkgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VycmVudFN0b3JlLnVybFRvSWRbaXRlbV0gPSBIaXN0b3J5LnVybFRvSWRbaXRlbV07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggaXRlbSBpbiBIaXN0b3J5LnN0YXRlVG9JZCApIHtcblx0XHRcdFx0XHRpZiAoICFIaXN0b3J5LnN0YXRlVG9JZC5oYXNPd25Qcm9wZXJ0eShpdGVtKSApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50U3RvcmUuc3RhdGVUb0lkW2l0ZW1dID0gSGlzdG9yeS5zdGF0ZVRvSWRbaXRlbV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVcGRhdGVcblx0XHRcdFx0SGlzdG9yeS5zdG9yZSA9IGN1cnJlbnRTdG9yZTtcblx0XHRcdFx0SGlzdG9yeS5ub3JtYWxpemVTdG9yZSgpO1xuXG5cdFx0XHRcdC8vIEluIFNhZmFyaSwgZ29pbmcgaW50byBQcml2YXRlIEJyb3dzaW5nIG1vZGUgY2F1c2VzIHRoZVxuXHRcdFx0XHQvLyBTZXNzaW9uIFN0b3JhZ2Ugb2JqZWN0IHRvIHN0aWxsIGV4aXN0IGJ1dCBpZiB5b3UgdHJ5IGFuZCB1c2Vcblx0XHRcdFx0Ly8gb3Igc2V0IGFueSBwcm9wZXJ0eS9mdW5jdGlvbiBvZiBpdCBpdCB0aHJvd3MgdGhlIGV4Y2VwdGlvblxuXHRcdFx0XHQvLyBcIlFVT1RBX0VYQ0VFREVEX0VSUjogRE9NIEV4Y2VwdGlvbiAyMjogQW4gYXR0ZW1wdCB3YXMgbWFkZSB0b1xuXHRcdFx0XHQvLyBhZGQgc29tZXRoaW5nIHRvIHN0b3JhZ2UgdGhhdCBleGNlZWRlZCB0aGUgcXVvdGEuXCIgaW5maW5pdGVseVxuXHRcdFx0XHQvLyBldmVyeSBzZWNvbmQuXG5cdFx0XHRcdGN1cnJlbnRTdG9yZVN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTdG9yZSk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gU3RvcmVcblx0XHRcdFx0XHRzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdIaXN0b3J5LnN0b3JlJywgY3VycmVudFN0b3JlU3RyaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGlmIChlLmNvZGUgPT09IERPTUV4Y2VwdGlvbi5RVU9UQV9FWENFRURFRF9FUlIpIHtcblx0XHRcdFx0XHRcdGlmIChzZXNzaW9uU3RvcmFnZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0Ly8gV29ya2Fyb3VuZCBmb3IgYSBidWcgc2VlbiBvbiBpUGFkcy4gU29tZXRpbWVzIHRoZSBxdW90YSBleGNlZWRlZCBlcnJvciBjb21lcyB1cCBhbmQgc2ltcGx5XG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92aW5nL3Jlc2V0dGluZyB0aGUgc3RvcmFnZSBjYW4gd29yay5cblx0XHRcdFx0XHRcdFx0c2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgnSGlzdG9yeS5zdG9yZScpO1xuXHRcdFx0XHRcdFx0XHRzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdIaXN0b3J5LnN0b3JlJywgY3VycmVudFN0b3JlU3RyaW5nKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgd2UncmUgcHJvYmFibHkgcHJpdmF0ZSBicm93c2luZyBpbiBTYWZhcmksIHNvIHdlJ2xsIGlnbm9yZSB0aGUgZXhjZXB0aW9uLlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRm9yIEludGVybmV0IEV4cGxvcmVyXG5cdFx0XHRIaXN0b3J5LmludGVydmFsTGlzdC5wdXNoKHNldEludGVydmFsKEhpc3Rvcnkub25VbmxvYWQsSGlzdG9yeS5vcHRpb25zLnN0b3JlSW50ZXJ2YWwpKTtcblxuXHRcdFx0Ly8gRm9yIE90aGVyIEJyb3dzZXJzXG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIuYmluZCh3aW5kb3csJ2JlZm9yZXVubG9hZCcsSGlzdG9yeS5vblVubG9hZCk7XG5cdFx0XHRIaXN0b3J5LkFkYXB0ZXIuYmluZCh3aW5kb3csJ3VubG9hZCcsSGlzdG9yeS5vblVubG9hZCk7XG5cblx0XHRcdC8vIEJvdGggYXJlIGVuYWJsZWQgZm9yIGNvbnNpc3RlbmN5XG5cdFx0fVxuXG5cdFx0Ly8gTm9uLU5hdGl2ZSBwdXNoU3RhdGUgSW1wbGVtZW50YXRpb25cblx0XHRpZiAoICFIaXN0b3J5LmVtdWxhdGVkLnB1c2hTdGF0ZSApIHtcblx0XHRcdC8vIEJlIGF3YXJlLCB0aGUgZm9sbG93aW5nIGlzIG9ubHkgZm9yIG5hdGl2ZSBwdXNoU3RhdGUgaW1wbGVtZW50YXRpb25zXG5cdFx0XHQvLyBJZiB5b3UgYXJlIHdhbnRpbmcgdG8gaW5jbHVkZSBzb21ldGhpbmcgZm9yIGFsbCBicm93c2Vyc1xuXHRcdFx0Ly8gVGhlbiBpbmNsdWRlIGl0IGFib3ZlIHRoaXMgaWYgYmxvY2tcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXR1cCBTYWZhcmkgRml4XG5cdFx0XHQgKi9cblx0XHRcdGlmICggSGlzdG9yeS5idWdzLnNhZmFyaVBvbGwgKSB7XG5cdFx0XHRcdEhpc3RvcnkuaW50ZXJ2YWxMaXN0LnB1c2goc2V0SW50ZXJ2YWwoSGlzdG9yeS5zYWZhcmlTdGF0ZVBvbGwsIEhpc3Rvcnkub3B0aW9ucy5zYWZhcmlQb2xsSW50ZXJ2YWwpKTtcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBFbnN1cmUgQ3Jvc3MgQnJvd3NlciBDb21wYXRpYmlsaXR5XG5cdFx0XHQgKi9cblx0XHRcdGlmICggbmF2aWdhdG9yLnZlbmRvciA9PT0gJ0FwcGxlIENvbXB1dGVyLCBJbmMuJyB8fCAobmF2aWdhdG9yLmFwcENvZGVOYW1lfHwnJykgPT09ICdNb3ppbGxhJyApIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEZpeCBTYWZhcmkgSGFzaENoYW5nZSBJc3N1ZVxuXHRcdFx0XHQgKi9cblxuXHRcdFx0XHQvLyBTZXR1cCBBbGlhc1xuXHRcdFx0XHRIaXN0b3J5LkFkYXB0ZXIuYmluZCh3aW5kb3csJ2hhc2hjaGFuZ2UnLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdwb3BzdGF0ZScpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBJbml0aWFsaXNlIEFsaWFzXG5cdFx0XHRcdGlmICggSGlzdG9yeS5nZXRIYXNoKCkgKSB7XG5cdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLm9uRG9tTG9hZChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0SGlzdG9yeS5BZGFwdGVyLnRyaWdnZXIod2luZG93LCdoYXNoY2hhbmdlJyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gLy8gIUhpc3RvcnkuZW11bGF0ZWQucHVzaFN0YXRlXG5cblxuXHR9OyAvLyBIaXN0b3J5LmluaXRDb3JlXG5cblx0Ly8gVHJ5IHRvIEluaXRpYWxpc2UgSGlzdG9yeVxuXHRpZiAoIUhpc3Rvcnkub3B0aW9ucyB8fCAhSGlzdG9yeS5vcHRpb25zLmRlbGF5SW5pdCkge1xuXHRcdEhpc3RvcnkuaW5pdCgpO1xuXHR9XG5cbn0pKHdpbmRvdyk7XG4iLCIvKiFcbiAqIGltYWdlc0xvYWRlZCB2NS4wLjBcbiAqIEphdmFTY3JpcHQgaXMgYWxsIGxpa2UgXCJZb3UgaW1hZ2VzIGFyZSBkb25lIHlldCBvciB3aGF0P1wiXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggd2luZG93LCByZXF1aXJlKCdldi1lbWl0dGVyJykgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5pbWFnZXNMb2FkZWQgPSBmYWN0b3J5KCB3aW5kb3csIHdpbmRvdy5FdkVtaXR0ZXIgKTtcbiAgfVxuXG59ICkoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyxcbiAgICBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIEV2RW1pdHRlciApIHtcblxubGV0ICQgPSB3aW5kb3cualF1ZXJ5O1xubGV0IGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyB0dXJuIGVsZW1lbnQgb3Igbm9kZUxpc3QgaW50byBhbiBhcnJheVxuZnVuY3Rpb24gbWFrZUFycmF5KCBvYmogKSB7XG4gIC8vIHVzZSBvYmplY3QgaWYgYWxyZWFkeSBhbiBhcnJheVxuICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkgcmV0dXJuIG9iajtcblxuICBsZXQgaXNBcnJheUxpa2UgPSB0eXBlb2Ygb2JqID09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoubGVuZ3RoID09ICdudW1iZXInO1xuICAvLyBjb252ZXJ0IG5vZGVMaXN0IHRvIGFycmF5XG4gIGlmICggaXNBcnJheUxpa2UgKSByZXR1cm4gWyAuLi5vYmogXTtcblxuICAvLyBhcnJheSBvZiBzaW5nbGUgaW5kZXhcbiAgcmV0dXJuIFsgb2JqIF07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGltYWdlc0xvYWRlZCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIEBwYXJhbSB7W0FycmF5LCBFbGVtZW50LCBOb2RlTGlzdCwgU3RyaW5nXX0gZWxlbVxuICogQHBhcmFtIHtbT2JqZWN0LCBGdW5jdGlvbl19IG9wdGlvbnMgLSBpZiBmdW5jdGlvbiwgdXNlIGFzIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkFsd2F5cyAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7SW1hZ2VzTG9hZGVkfVxuICovXG5mdW5jdGlvbiBJbWFnZXNMb2FkZWQoIGVsZW0sIG9wdGlvbnMsIG9uQWx3YXlzICkge1xuICAvLyBjb2VyY2UgSW1hZ2VzTG9hZGVkKCkgd2l0aG91dCBuZXcsIHRvIGJlIG5ldyBJbWFnZXNMb2FkZWQoKVxuICBpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBJbWFnZXNMb2FkZWQgKSApIHtcbiAgICByZXR1cm4gbmV3IEltYWdlc0xvYWRlZCggZWxlbSwgb3B0aW9ucywgb25BbHdheXMgKTtcbiAgfVxuICAvLyB1c2UgZWxlbSBhcyBzZWxlY3RvciBzdHJpbmdcbiAgbGV0IHF1ZXJ5RWxlbSA9IGVsZW07XG4gIGlmICggdHlwZW9mIGVsZW0gPT0gJ3N0cmluZycgKSB7XG4gICAgcXVlcnlFbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggZWxlbSApO1xuICB9XG4gIC8vIGJhaWwgaWYgYmFkIGVsZW1lbnRcbiAgaWYgKCAhcXVlcnlFbGVtICkge1xuICAgIGNvbnNvbGUuZXJyb3IoYEJhZCBlbGVtZW50IGZvciBpbWFnZXNMb2FkZWQgJHtxdWVyeUVsZW0gfHwgZWxlbX1gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVsZW1lbnRzID0gbWFrZUFycmF5KCBxdWVyeUVsZW0gKTtcbiAgdGhpcy5vcHRpb25zID0ge307XG4gIC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBubyBvcHRpb25zIHNldFxuICBpZiAoIHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicgKSB7XG4gICAgb25BbHdheXMgPSBvcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5hc3NpZ24oIHRoaXMub3B0aW9ucywgb3B0aW9ucyApO1xuICB9XG5cbiAgaWYgKCBvbkFsd2F5cyApIHRoaXMub24oICdhbHdheXMnLCBvbkFsd2F5cyApO1xuXG4gIHRoaXMuZ2V0SW1hZ2VzKCk7XG4gIC8vIGFkZCBqUXVlcnkgRGVmZXJyZWQgb2JqZWN0XG4gIGlmICggJCApIHRoaXMuanFEZWZlcnJlZCA9IG5ldyAkLkRlZmVycmVkKCk7XG5cbiAgLy8gSEFDSyBjaGVjayBhc3luYyB0byBhbGxvdyB0aW1lIHRvIGJpbmQgbGlzdGVuZXJzXG4gIHNldFRpbWVvdXQoIHRoaXMuY2hlY2suYmluZCggdGhpcyApICk7XG59XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuZ2V0SW1hZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW1hZ2VzID0gW107XG5cbiAgLy8gZmlsdGVyICYgZmluZCBpdGVtcyBpZiB3ZSBoYXZlIGFuIGl0ZW0gc2VsZWN0b3JcbiAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKCB0aGlzLmFkZEVsZW1lbnRJbWFnZXMsIHRoaXMgKTtcbn07XG5cbmNvbnN0IGVsZW1lbnROb2RlVHlwZXMgPSBbIDEsIDksIDExIF07XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBlbGVtXG4gKi9cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuYWRkRWxlbWVudEltYWdlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAvLyBmaWx0ZXIgc2libGluZ3NcbiAgaWYgKCBlbGVtLm5vZGVOYW1lID09PSAnSU1HJyApIHtcbiAgICB0aGlzLmFkZEltYWdlKCBlbGVtICk7XG4gIH1cbiAgLy8gZ2V0IGJhY2tncm91bmQgaW1hZ2Ugb24gZWxlbWVudFxuICBpZiAoIHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kID09PSB0cnVlICkge1xuICAgIHRoaXMuYWRkRWxlbWVudEJhY2tncm91bmRJbWFnZXMoIGVsZW0gKTtcbiAgfVxuXG4gIC8vIGZpbmQgY2hpbGRyZW5cbiAgLy8gbm8gbm9uLWVsZW1lbnQgbm9kZXMsICMxNDNcbiAgbGV0IHsgbm9kZVR5cGUgfSA9IGVsZW07XG4gIGlmICggIW5vZGVUeXBlIHx8ICFlbGVtZW50Tm9kZVR5cGVzLmluY2x1ZGVzKCBub2RlVHlwZSApICkgcmV0dXJuO1xuXG4gIGxldCBjaGlsZEltZ3MgPSBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpO1xuICAvLyBjb25jYXQgY2hpbGRFbGVtcyB0byBmaWx0ZXJGb3VuZCBhcnJheVxuICBmb3IgKCBsZXQgaW1nIG9mIGNoaWxkSW1ncyApIHtcbiAgICB0aGlzLmFkZEltYWdlKCBpbWcgKTtcbiAgfVxuXG4gIC8vIGdldCBjaGlsZCBiYWNrZ3JvdW5kIGltYWdlc1xuICBpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZCA9PSAnc3RyaW5nJyApIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoIHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kICk7XG4gICAgZm9yICggbGV0IGNoaWxkIG9mIGNoaWxkcmVuICkge1xuICAgICAgdGhpcy5hZGRFbGVtZW50QmFja2dyb3VuZEltYWdlcyggY2hpbGQgKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHJlVVJMID0gL3VybFxcKChbJ1wiXSk/KC4qPylcXDFcXCkvZ2k7XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuYWRkRWxlbWVudEJhY2tncm91bmRJbWFnZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgbGV0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuICAvLyBGaXJlZm94IHJldHVybnMgbnVsbCBpZiBpbiBhIGhpZGRlbiBpZnJhbWUgaHR0cHM6Ly9idWd6aWwubGEvNTQ4Mzk3XG4gIGlmICggIXN0eWxlICkgcmV0dXJuO1xuXG4gIC8vIGdldCB1cmwgaW5zaWRlIHVybChcIi4uLlwiKVxuICBsZXQgbWF0Y2hlcyA9IHJlVVJMLmV4ZWMoIHN0eWxlLmJhY2tncm91bmRJbWFnZSApO1xuICB3aGlsZSAoIG1hdGNoZXMgIT09IG51bGwgKSB7XG4gICAgbGV0IHVybCA9IG1hdGNoZXMgJiYgbWF0Y2hlc1syXTtcbiAgICBpZiAoIHVybCApIHtcbiAgICAgIHRoaXMuYWRkQmFja2dyb3VuZCggdXJsLCBlbGVtICk7XG4gICAgfVxuICAgIG1hdGNoZXMgPSByZVVSTC5leGVjKCBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWdcbiAqL1xuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5hZGRJbWFnZSA9IGZ1bmN0aW9uKCBpbWcgKSB7XG4gIGxldCBsb2FkaW5nSW1hZ2UgPSBuZXcgTG9hZGluZ0ltYWdlKCBpbWcgKTtcbiAgdGhpcy5pbWFnZXMucHVzaCggbG9hZGluZ0ltYWdlICk7XG59O1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmFkZEJhY2tncm91bmQgPSBmdW5jdGlvbiggdXJsLCBlbGVtICkge1xuICBsZXQgYmFja2dyb3VuZCA9IG5ldyBCYWNrZ3JvdW5kKCB1cmwsIGVsZW0gKTtcbiAgdGhpcy5pbWFnZXMucHVzaCggYmFja2dyb3VuZCApO1xufTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByb2dyZXNzZWRDb3VudCA9IDA7XG4gIHRoaXMuaGFzQW55QnJva2VuID0gZmFsc2U7XG4gIC8vIGNvbXBsZXRlIGlmIG5vIGltYWdlc1xuICBpZiAoICF0aGlzLmltYWdlcy5sZW5ndGggKSB7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLXN0eWxlICovXG4gIGxldCBvblByb2dyZXNzID0gKCBpbWFnZSwgZWxlbSwgbWVzc2FnZSApID0+IHtcbiAgICAvLyBIQUNLIC0gQ2hyb21lIHRyaWdnZXJzIGV2ZW50IGJlZm9yZSBvYmplY3QgcHJvcGVydGllcyBoYXZlIGNoYW5nZWQuICM4M1xuICAgIHNldFRpbWVvdXQoICgpID0+IHtcbiAgICAgIHRoaXMucHJvZ3Jlc3MoIGltYWdlLCBlbGVtLCBtZXNzYWdlICk7XG4gICAgfSApO1xuICB9O1xuXG4gIHRoaXMuaW1hZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBsb2FkaW5nSW1hZ2UgKSB7XG4gICAgbG9hZGluZ0ltYWdlLm9uY2UoICdwcm9ncmVzcycsIG9uUHJvZ3Jlc3MgKTtcbiAgICBsb2FkaW5nSW1hZ2UuY2hlY2soKTtcbiAgfSApO1xufTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uKCBpbWFnZSwgZWxlbSwgbWVzc2FnZSApIHtcbiAgdGhpcy5wcm9ncmVzc2VkQ291bnQrKztcbiAgdGhpcy5oYXNBbnlCcm9rZW4gPSB0aGlzLmhhc0FueUJyb2tlbiB8fCAhaW1hZ2UuaXNMb2FkZWQ7XG4gIC8vIHByb2dyZXNzIGV2ZW50XG4gIHRoaXMuZW1pdEV2ZW50KCAncHJvZ3Jlc3MnLCBbIHRoaXMsIGltYWdlLCBlbGVtIF0gKTtcbiAgaWYgKCB0aGlzLmpxRGVmZXJyZWQgJiYgdGhpcy5qcURlZmVycmVkLm5vdGlmeSApIHtcbiAgICB0aGlzLmpxRGVmZXJyZWQubm90aWZ5KCB0aGlzLCBpbWFnZSApO1xuICB9XG4gIC8vIGNoZWNrIGlmIGNvbXBsZXRlZFxuICBpZiAoIHRoaXMucHJvZ3Jlc3NlZENvdW50ID09PSB0aGlzLmltYWdlcy5sZW5ndGggKSB7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xuICB9XG5cbiAgaWYgKCB0aGlzLm9wdGlvbnMuZGVidWcgJiYgY29uc29sZSApIHtcbiAgICBjb25zb2xlLmxvZyggYHByb2dyZXNzOiAke21lc3NhZ2V9YCwgaW1hZ2UsIGVsZW0gKTtcbiAgfVxufTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgZXZlbnROYW1lID0gdGhpcy5oYXNBbnlCcm9rZW4gPyAnZmFpbCcgOiAnZG9uZSc7XG4gIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gIHRoaXMuZW1pdEV2ZW50KCBldmVudE5hbWUsIFsgdGhpcyBdICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAnYWx3YXlzJywgWyB0aGlzIF0gKTtcbiAgaWYgKCB0aGlzLmpxRGVmZXJyZWQgKSB7XG4gICAgbGV0IGpxTWV0aG9kID0gdGhpcy5oYXNBbnlCcm9rZW4gPyAncmVqZWN0JyA6ICdyZXNvbHZlJztcbiAgICB0aGlzLmpxRGVmZXJyZWRbIGpxTWV0aG9kIF0oIHRoaXMgKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIExvYWRpbmdJbWFnZSggaW1nICkge1xuICB0aGlzLmltZyA9IGltZztcbn1cblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2RW1pdHRlci5wcm90b3R5cGUgKTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCkge1xuICAvLyBJZiBjb21wbGV0ZSBpcyB0cnVlIGFuZCBicm93c2VyIHN1cHBvcnRzIG5hdHVyYWwgc2l6ZXMsXG4gIC8vIHRyeSB0byBjaGVjayBmb3IgaW1hZ2Ugc3RhdHVzIG1hbnVhbGx5LlxuICBsZXQgaXNDb21wbGV0ZSA9IHRoaXMuZ2V0SXNJbWFnZUNvbXBsZXRlKCk7XG4gIGlmICggaXNDb21wbGV0ZSApIHtcbiAgICAvLyByZXBvcnQgYmFzZWQgb24gbmF0dXJhbFdpZHRoXG4gICAgdGhpcy5jb25maXJtKCB0aGlzLmltZy5uYXR1cmFsV2lkdGggIT09IDAsICduYXR1cmFsV2lkdGgnICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbm9uZSBvZiB0aGUgY2hlY2tzIGFib3ZlIG1hdGNoZWQsIHNpbXVsYXRlIGxvYWRpbmcgb24gZGV0YWNoZWQgZWxlbWVudC5cbiAgdGhpcy5wcm94eUltYWdlID0gbmV3IEltYWdlKCk7XG4gIC8vIGFkZCBjcm9zc09yaWdpbiBhdHRyaWJ1dGUuICMyMDRcbiAgaWYgKCB0aGlzLmltZy5jcm9zc09yaWdpbiApIHtcbiAgICB0aGlzLnByb3h5SW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmltZy5jcm9zc09yaWdpbjtcbiAgfVxuICB0aGlzLnByb3h5SW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMucHJveHlJbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG4gIC8vIGJpbmQgdG8gaW1hZ2UgYXMgd2VsbCBmb3IgRmlyZWZveC4gIzE5MVxuICB0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICB0aGlzLnByb3h5SW1hZ2Uuc3JjID0gdGhpcy5pbWcuY3VycmVudFNyYyB8fCB0aGlzLmltZy5zcmM7XG59O1xuXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLmdldElzSW1hZ2VDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBjaGVjayBmb3Igbm9uLXplcm8sIG5vbi11bmRlZmluZWQgbmF0dXJhbFdpZHRoXG4gIC8vIGZpeGVzIFNhZmFyaStJbmZpbml0ZVNjcm9sbCtNYXNvbnJ5IGJ1ZyBpbmZpbml0ZS1zY3JvbGwjNjcxXG4gIHJldHVybiB0aGlzLmltZy5jb21wbGV0ZSAmJiB0aGlzLmltZy5uYXR1cmFsV2lkdGg7XG59O1xuXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLmNvbmZpcm0gPSBmdW5jdGlvbiggaXNMb2FkZWQsIG1lc3NhZ2UgKSB7XG4gIHRoaXMuaXNMb2FkZWQgPSBpc0xvYWRlZDtcbiAgbGV0IHsgcGFyZW50Tm9kZSB9ID0gdGhpcy5pbWc7XG4gIC8vIGVtaXQgcHJvZ3Jlc3Mgd2l0aCBwYXJlbnQgPHBpY3R1cmU+IG9yIHNlbGYgPGltZz5cbiAgbGV0IGVsZW0gPSBwYXJlbnROb2RlLm5vZGVOYW1lID09PSAnUElDVFVSRScgPyBwYXJlbnROb2RlIDogdGhpcy5pbWc7XG4gIHRoaXMuZW1pdEV2ZW50KCAncHJvZ3Jlc3MnLCBbIHRoaXMsIGVsZW0sIG1lc3NhZ2UgXSApO1xufTtcblxuLy8gLS0tLS0gZXZlbnRzIC0tLS0tIC8vXG5cbi8vIHRyaWdnZXIgc3BlY2lmaWVkIGhhbmRsZXIgZm9yIGV2ZW50IHR5cGVcbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGxldCBtZXRob2QgPSAnb24nICsgZXZlbnQudHlwZTtcbiAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcbiAgICB0aGlzWyBtZXRob2QgXSggZXZlbnQgKTtcbiAgfVxufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb25maXJtKCB0cnVlLCAnb25sb2FkJyApO1xuICB0aGlzLnVuYmluZEV2ZW50cygpO1xufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29uZmlybSggZmFsc2UsICdvbmVycm9yJyApO1xuICB0aGlzLnVuYmluZEV2ZW50cygpO1xufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS51bmJpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcm94eUltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLnByb3h5SW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICB0aGlzLmltZy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5pbWcucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQmFja2dyb3VuZCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBCYWNrZ3JvdW5kKCB1cmwsIGVsZW1lbnQgKSB7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmltZyA9IG5ldyBJbWFnZSgpO1xufVxuXG4vLyBpbmhlcml0IExvYWRpbmdJbWFnZSBwcm90b3R5cGVcbkJhY2tncm91bmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTG9hZGluZ0ltYWdlLnByb3RvdHlwZSApO1xuXG5CYWNrZ3JvdW5kLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICB0aGlzLmltZy5zcmMgPSB0aGlzLnVybDtcbiAgLy8gY2hlY2sgaWYgaW1hZ2UgaXMgYWxyZWFkeSBjb21wbGV0ZVxuICBsZXQgaXNDb21wbGV0ZSA9IHRoaXMuZ2V0SXNJbWFnZUNvbXBsZXRlKCk7XG4gIGlmICggaXNDb21wbGV0ZSApIHtcbiAgICB0aGlzLmNvbmZpcm0oIHRoaXMuaW1nLm5hdHVyYWxXaWR0aCAhPT0gMCwgJ25hdHVyYWxXaWR0aCcgKTtcbiAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICB9XG59O1xuXG5CYWNrZ3JvdW5kLnByb3RvdHlwZS51bmJpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbWcucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbn07XG5cbkJhY2tncm91bmQucHJvdG90eXBlLmNvbmZpcm0gPSBmdW5jdGlvbiggaXNMb2FkZWQsIG1lc3NhZ2UgKSB7XG4gIHRoaXMuaXNMb2FkZWQgPSBpc0xvYWRlZDtcbiAgdGhpcy5lbWl0RXZlbnQoICdwcm9ncmVzcycsIFsgdGhpcywgdGhpcy5lbGVtZW50LCBtZXNzYWdlIF0gKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGpRdWVyeSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5JbWFnZXNMb2FkZWQubWFrZUpRdWVyeVBsdWdpbiA9IGZ1bmN0aW9uKCBqUXVlcnkgKSB7XG4gIGpRdWVyeSA9IGpRdWVyeSB8fCB3aW5kb3cualF1ZXJ5O1xuICBpZiAoICFqUXVlcnkgKSByZXR1cm47XG5cbiAgLy8gc2V0IGxvY2FsIHZhcmlhYmxlXG4gICQgPSBqUXVlcnk7XG4gIC8vICQoKS5pbWFnZXNMb2FkZWQoKVxuICAkLmZuLmltYWdlc0xvYWRlZCA9IGZ1bmN0aW9uKCBvcHRpb25zLCBvbkFsd2F5cyApIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBuZXcgSW1hZ2VzTG9hZGVkKCB0aGlzLCBvcHRpb25zLCBvbkFsd2F5cyApO1xuICAgIHJldHVybiBpbnN0YW5jZS5qcURlZmVycmVkLnByb21pc2UoICQoIHRoaXMgKSApO1xuICB9O1xufTtcbi8vIHRyeSBtYWtpbmcgcGx1Z2luXG5JbWFnZXNMb2FkZWQubWFrZUpRdWVyeVBsdWdpbigpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxucmV0dXJuIEltYWdlc0xvYWRlZDtcblxufSApO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuICEodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAhPT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5IHx8IHZhbHVlID09PSAtSW5maW5pdHkpO1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvZXM2LXNoaW1cbi8vIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5pc2ludGVnZXJcbnZhciBpc0Zpbml0ZSA9IHJlcXVpcmUoXCJpcy1maW5pdGVcIik7XG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmXG4gICAgaXNGaW5pdGUodmFsKSAmJlxuICAgIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnaXMtaW50ZWdlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNWYWxpZE1vbnRoIChtb250aCkge1xuICBpZiAodHlwZW9mIG1vbnRoICE9PSAnbnVtYmVyJyB8fCAhaXNJbnRlZ2VyKG1vbnRoKSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyXG59XG4iLCIvKiFcbiAqIFJldmVhbGVyIDMuMC4wXG4gKlxuICogQ29weXJpZ2h0IDIwMjEsIFBpeGVsIFVuaW9uIC0gaHR0cDovL3BpeGVsdW5pb24ubmV0XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uKCQpe1xuICAvLyBjaGVjayBmb3IgdHJlbmQgZXZlbnQgKG1ha2Ugc3VyZSBqcXVlcnkudHJlbmQgaXMgaW5jbHVkZWQpXG4gIGlmICh0eXBlb2YgJC5ldmVudC5zcGVjaWFsLnRyZW5kICE9PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIG1ha2Ugc3VyZSBqcXVlcnkudHJlbmQgaXMgaW5jbHVkZWQhIE90aGVyd2lzZSByZXZlYWxlciB3b24ndCB3b3JrLlwiKTtcbiAgfVxuXG4gIC8vIFNpbXBsZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGxcbiAgdmFyIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIGZ1bmN0aW9uKGZuKSB7IHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAxMDAwLzYwKTsgfVxuXG5cbiAgLy8gUHVibGljIEFQSVxuICB2YXIgbWV0aG9kcyA9IHtcbiAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gISFlbC5kYXRhKFwicmV2ZWFsZXItdmlzaWJsZVwiKTtcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24oZWwsIGZvcmNlKSB7XG4gICAgICAvLyBDaGVjayBzdGF0ZVxuICAgICAgaWYgKG1ldGhvZHMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICBlbC5yZW1vdmVDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctaW5cIik7XG4gICAgICAgIGVsLm9mZihcInJldmVhbGVyLWFuaW1hdGluZyByZXZlYWxlci1zaG93XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBldmVudCBsaXN0ZW5lcnNcbiAgICAgIGVsLmRhdGEoXCJyZXZlYWxlci12aXNpYmxlXCIsIHRydWUpO1xuICAgICAgZWwub2ZmKFwidHJlbmRcIik7XG5cbiAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICBlbC5hZGRDbGFzcyhcInZpc2libGVcIik7XG4gICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1hbmltYXRpbmdcIik7XG4gICAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLXNob3dcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAvLyBTdGFydCBhbmltYXRpb24gc3RhdGUgdHJhbnNpdGlvblxuICAgICAgICBlbC5hZGRDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctaW5cIik7XG4gICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1hbmltYXRpbmdcIik7XG5cbiAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZWwuYWRkQ2xhc3MoXCJ2aXNpYmxlXCIpO1xuXG4gICAgICAgICAgZWwub25lKFwidHJlbmRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKFwiYW5pbWF0aW5nIGFuaW1hdGluZy1pblwiKTtcbiAgICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1zaG93XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbihlbCwgZm9yY2UpIHtcbiAgICAgIC8vIENoZWNrIHN0YXRlXG4gICAgICBpZiAoIW1ldGhvZHMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICBlbC5yZW1vdmVDbGFzcyhcImFuaW1hdGluZyBhbmltYXRpbmctb3V0IHZpc2libGVcIik7XG4gICAgICAgIGVsLm9mZihcInJldmVhbGVyLWFuaW1hdGluZyByZXZlYWxlci1oaWRlXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBldmVudCBsaXN0ZW5lcnNcbiAgICAgIGVsLmRhdGEoXCJyZXZlYWxlci12aXNpYmxlXCIsIGZhbHNlKTtcbiAgICAgIGVsLm9mZihcInRyZW5kXCIpO1xuXG4gICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJ2aXNpYmxlXCIpO1xuICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItYW5pbWF0aW5nXCIpO1xuICAgICAgICAgIGVsLnRyaWdnZXIoXCJyZXZlYWxlci1oaWRlXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgZWwuYWRkQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLW91dFwiKTtcbiAgICAgICAgZWwudHJpZ2dlcihcInJldmVhbGVyLWFuaW1hdGluZ1wiKTtcblxuICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbC5yZW1vdmVDbGFzcyhcInZpc2libGVcIik7XG5cbiAgICAgICAgICBlbC5vbmUoXCJ0cmVuZFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoXCJhbmltYXRpbmcgYW5pbWF0aW5nLWluIGFuaW1hdGluZy1vdXRcIik7XG4gICAgICAgICAgICBlbC50cmlnZ2VyKFwicmV2ZWFsZXItaGlkZVwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlOiBmdW5jdGlvbihlbCwgZm9yY2UpIHtcbiAgICAgIGlmIChtZXRob2RzLmlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgbWV0aG9kcy5oaWRlKGVsLCBmb3JjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRob2RzLnNob3coZWwsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8galF1ZXJ5IHBsdWdpblxuICAkLmZuLnJldmVhbGVyID0gZnVuY3Rpb24obWV0aG9kLCBmb3JjZSkge1xuICAgIC8vIEdldCBhY3Rpb25cbiAgICB2YXIgYWN0aW9uID0gbWV0aG9kc1ttZXRob2QgfHwgXCJ0b2dnbGVcIl07XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiB0aGlzO1xuXG4gICAgLy8gUnVuIGFjdGlvblxuICAgIGlmIChtZXRob2QgPT09IFwiaXNWaXNpYmxlXCIpIHtcbiAgICAgIHJldHVybiBhY3Rpb24odGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgYWN0aW9uKCQodGhpcyksIGZvcmNlKTtcbiAgICB9KTtcbiAgfTtcbn0pKGpRdWVyeSk7XG4iLCIvKiFcbiAqIFRyZW5kIDEuMC4wXG4gKlxuICogRmFpbC1zYWZlIFRyYW5zaXRpb25FbmQgZXZlbnQgZm9yIGpRdWVyeS5cbiAqXG4gKiBBZGRzIGEgbmV3IFwidHJlbmRcIiBldmVudCB0aGF0IGNhbiBiZSB1c2VkIGluIGJyb3dzZXJzIHRoYXQgZG9uJ3RcbiAqIHN1cHBvcnQgXCJ0cmFuc2l0aW9uZW5kXCIuXG4gKlxuICogTk9URTogT25seSBzdXBwb3J0cyBiZWluZyBib3VuZCB3aXRoIFwialF1ZXJ5Lm9uZVwiLlxuICpcbiAqIENvcHlyaWdodCAyMDIxLCBQaXhlbCBVbmlvbiAtIGh0dHA6Ly9waXhlbHVuaW9uLm5ldFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24oJCl7XG5cbiAgLy8gUHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lc1xuICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50cyA9XG4gICAgXCJ3ZWJraXRUcmFuc2l0aW9uRW5kIFwiICtcbiAgICBcIm90cmFuc2l0aW9uZW5kIFwiICtcbiAgICBcIm9UcmFuc2l0aW9uRW5kIFwiICtcbiAgICBcIm1zVHJhbnNpdGlvbkVuZCBcIiArXG4gICAgXCJ0cmFuc2l0aW9uZW5kXCI7XG5cbiAgLy8gUHJlZml4ZWQgdHJhbnNpdGlvbiBkdXJhdGlvbiBwcm9wZXJ0eSBuYW1lc1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uUHJvcGVydGllcyA9IFtcbiAgICBcInRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1tb3otdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLXdlYmtpdC10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItbXMtdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLW8tdHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwiLWtodG1sLXRyYW5zaXRpb24tZHVyYXRpb25cIlxuICBdO1xuXG4gIC8vIFByZWZpeGVkIHRyYW5zaXRpb24gZGVsYXkgcHJvcGVydHkgbmFtZXNcbiAgdmFyIHRyYW5zaXRpb25EZWxheVByb3BlcnRpZXMgPSBbXG4gICAgXCJ0cmFuc2l0aW9uLWRlbGF5XCIsXG4gICAgXCItbW96LXRyYW5zaXRpb24tZGVsYXlcIixcbiAgICBcIi13ZWJraXQtdHJhbnNpdGlvbi1kZWxheVwiLFxuICAgIFwiLW1zLXRyYW5zaXRpb24tZGVsYXlcIixcbiAgICBcIi1vLXRyYW5zaXRpb24tZGVsYXlcIixcbiAgICBcIi1raHRtbC10cmFuc2l0aW9uLWRlbGF5XCJcbiAgXTtcblxuICAvLyBQYXJzZXMgYSBDU1MgdGltZSB2YWx1ZSBpbnRvIG1pbGxpc2Vjb25kcy5cbiAgdmFyIHBhcnNlVGltZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICBzID0gcy5yZXBsYWNlKC9cXHMvLCBcIlwiKTtcbiAgICB2YXIgdiA9IHdpbmRvdy5wYXJzZUZsb2F0KHMpO1xuXG4gICAgcmV0dXJuIHMubWF0Y2goL1tebV1zJC9pKVxuICAgICAgPyB2ICogMTAwMFxuICAgICAgOiB2O1xuICB9O1xuXG4gIC8vIFBhcnNlcyB0aGUgbG9uZ2VzdCB0aW1lIHVuaXQgZm91bmQgaW4gYSBzZXJpZXMgb2YgQ1NTIHByb3BlcnRpZXMuXG4gIC8vIFJldHVybnMgYSB2YWx1ZSBpbiBtaWxsaXNlY29uZHMuXG4gIHZhciBwYXJzZVByb3BlcnRpZXMgPSBmdW5jdGlvbihlbCwgcHJvcGVydGllcykge1xuICAgIHZhciBkdXJhdGlvbiA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEdldCByYXcgQ1NTIHZhbHVlXG4gICAgICB2YXIgdmFsdWUgPSBlbC5jc3MocHJvcGVydGllc1tpXSk7XG4gICAgICBpZiAoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgLy8gTXVsdGlwbGUgdHJhbnNpdGlvbnMtLXBpY2sgdGhlIGxvbmdlc3RcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiLFwiKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgdmFyIGR1cmF0aW9ucyA9IChmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHBhcnNlVGltZSh2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGR1cmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heC5hcHBseShNYXRoLCBkdXJhdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5nbGUgdHJhbnNpdGlvblxuICAgICAgZWxzZSB7XG4gICAgICAgIGR1cmF0aW9uID0gcGFyc2VUaW1lKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWNjZXB0IGZpcnN0IHZhdWVcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfTtcblxuICAkLmV2ZW50LnNwZWNpYWwudHJlbmQgPSB7XG4gICAgLy8gVHJpZ2dlcnMgYW4gZXZlbnQgaGFuZGxlciB3aGVuIGFuIGVsZW1lbnQgaXMgZG9uZSB0cmFuc2l0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gSGFuZGxlcyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdHJhbnNpdGlvbmVuZCBieSBhZGRpbmcgYVxuICAgIC8vIHRpbWVvdXQgd2l0aCB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbi5cbiAgICBhZGQ6IGZ1bmN0aW9uKGhhbmRsZU9iaikge1xuICAgICAgdmFyIGVsID0gJCh0aGlzKTtcbiAgICAgIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBNYXJrIGVsZW1lbnQgYXMgYmVpbmcgaW4gdHJhbnNpdGlvblxuICAgICAgZWwuZGF0YShcInRyZW5kXCIsIHRydWUpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYSBmYWxsYmFjayBkdXJhdGlvbi4gKyAyMCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgZmlyZVxuICAgICAgLy8gdGltZW91dHMgZmFzdGVyIHRoYW4gdHJhbnNpdGlvbmVuZC5cbiAgICAgIHZhciB0aW1lID1cbiAgICAgICAgcGFyc2VQcm9wZXJ0aWVzKGVsLCB0cmFuc2l0aW9uRHVyYXRpb25Qcm9wZXJ0aWVzKSArXG4gICAgICAgIHBhcnNlUHJvcGVydGllcyhlbCwgdHJhbnNpdGlvbkRlbGF5UHJvcGVydGllcykgK1xuICAgICAgICAyMDtcblxuICAgICAgdmFyIGNiID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyB0cmFuc2l0aW9uZW5kIGV2ZW50cyBjYW4gYmUgc2VudCBmb3IgZWFjaCBwcm9wZXJ0eS4gTGV0J3MganVzdFxuICAgICAgICAvLyBza2lwIGFsbCBidXQgdGhlIGZpcnN0LiBBbHNvIGhhbmRsZXMgdGhlIHRpbWVvdXQgY2FsbGJhY2suXG4gICAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIENoaWxkIGVsZW1lbnRzIHRoYXQgYWxzbyBoYXZlIHRyYW5zaXRpb25zIGNhbiBiZSBmaXJlZCBiZWZvcmUgd2VcbiAgICAgICAgLy8gY29tcGxldGUuIFRoaXMgd2lsbCBjYXRjaCBhbmQgaWdub3JlIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCB3ZSdsbFxuICAgICAgICAvLyBoYXZlIHRvIHJlbHkgb24gdGhlIHRpbWVvdXQgaW4gdGhlc2UgY2FzZXMuXG4gICAgICAgIGlmIChlICYmIGUuc3JjRWxlbWVudCAhPT0gZWxbMF0pIHJldHVybjtcblxuICAgICAgICAvLyBNYXJrIGVsZW1lbnQgaGFzIG5vdCBiZWluZyBpbiB0cmFuc2l0aW9uXG4gICAgICAgIGVsLmRhdGEoXCJ0cmVuZFwiLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gQ2FsbGJhY2tcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaGFuZGxlT2JqLmhhbmRsZXIpIGhhbmRsZU9iai5oYW5kbGVyKCk7XG4gICAgICB9O1xuXG4gICAgICBlbC5vbmUodHJhbnNpdGlvbkVuZEV2ZW50cywgY2IpO1xuICAgICAgZWwuZGF0YShcInRyZW5kLXRpbWVvdXRcIiwgd2luZG93LnNldFRpbWVvdXQoY2IsIHRpbWUpKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihoYW5kbGVPYmopIHtcbiAgICAgIHZhciBlbCA9ICQodGhpcyk7XG4gICAgICBlbC5vZmYodHJhbnNpdGlvbkVuZEV2ZW50cyk7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGVsLmRhdGEoXCJ0cmVuZC10aW1lb3V0XCIpKTtcbiAgICB9XG4gIH07XG5cbn0pKGpRdWVyeSk7XG4iLCIvKiEgalF1ZXJ5IHYzLjcuMSB8IChjKSBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXG4hZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZS5kb2N1bWVudD90KGUsITApOmZ1bmN0aW9uKGUpe2lmKCFlLmRvY3VtZW50KXRocm93IG5ldyBFcnJvcihcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIik7cmV0dXJuIHQoZSl9OnQoZSl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnRoaXMsZnVuY3Rpb24oaWUsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG9lPVtdLHI9T2JqZWN0LmdldFByb3RvdHlwZU9mLGFlPW9lLnNsaWNlLGc9b2UuZmxhdD9mdW5jdGlvbihlKXtyZXR1cm4gb2UuZmxhdC5jYWxsKGUpfTpmdW5jdGlvbihlKXtyZXR1cm4gb2UuY29uY2F0LmFwcGx5KFtdLGUpfSxzPW9lLnB1c2gsc2U9b2UuaW5kZXhPZixuPXt9LGk9bi50b1N0cmluZyx1ZT1uLmhhc093blByb3BlcnR5LG89dWUudG9TdHJpbmcsYT1vLmNhbGwoT2JqZWN0KSxsZT17fSx2PWZ1bmN0aW9uKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJlwibnVtYmVyXCIhPXR5cGVvZiBlLm5vZGVUeXBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlLml0ZW19LHk9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWUmJmU9PT1lLndpbmRvd30sQz1pZS5kb2N1bWVudCx1PXt0eXBlOiEwLHNyYzohMCxub25jZTohMCxub01vZHVsZTohMH07ZnVuY3Rpb24gbShlLHQsbil7dmFyIHIsaSxvPShuPW58fEMpLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7aWYoby50ZXh0PWUsdClmb3IociBpbiB1KShpPXRbcl18fHQuZ2V0QXR0cmlidXRlJiZ0LmdldEF0dHJpYnV0ZShyKSkmJm8uc2V0QXR0cmlidXRlKHIsaSk7bi5oZWFkLmFwcGVuZENoaWxkKG8pLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobyl9ZnVuY3Rpb24geChlKXtyZXR1cm4gbnVsbD09ZT9lK1wiXCI6XCJvYmplY3RcIj09dHlwZW9mIGV8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGU/bltpLmNhbGwoZSldfHxcIm9iamVjdFwiOnR5cGVvZiBlfXZhciB0PVwiMy43LjFcIixsPS9IVE1MJC9pLGNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBjZS5mbi5pbml0KGUsdCl9O2Z1bmN0aW9uIGMoZSl7dmFyIHQ9ISFlJiZcImxlbmd0aFwiaW4gZSYmZS5sZW5ndGgsbj14KGUpO3JldHVybiF2KGUpJiYheShlKSYmKFwiYXJyYXlcIj09PW58fDA9PT10fHxcIm51bWJlclwiPT10eXBlb2YgdCYmMDx0JiZ0LTEgaW4gZSl9ZnVuY3Rpb24gZmUoZSx0KXtyZXR1cm4gZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09dC50b0xvd2VyQ2FzZSgpfWNlLmZuPWNlLnByb3RvdHlwZT17anF1ZXJ5OnQsY29uc3RydWN0b3I6Y2UsbGVuZ3RoOjAsdG9BcnJheTpmdW5jdGlvbigpe3JldHVybiBhZS5jYWxsKHRoaXMpfSxnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/YWUuY2FsbCh0aGlzKTplPDA/dGhpc1tlK3RoaXMubGVuZ3RoXTp0aGlzW2VdfSxwdXNoU3RhY2s6ZnVuY3Rpb24oZSl7dmFyIHQ9Y2UubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLGUpO3JldHVybiB0LnByZXZPYmplY3Q9dGhpcyx0fSxlYWNoOmZ1bmN0aW9uKGUpe3JldHVybiBjZS5lYWNoKHRoaXMsZSl9LG1hcDpmdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soY2UubWFwKHRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5jYWxsKGUsdCxlKX0pKX0sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soYWUuYXBwbHkodGhpcyxhcmd1bWVudHMpKX0sZmlyc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcSgwKX0sbGFzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKC0xKX0sZXZlbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFjayhjZS5ncmVwKHRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4odCsxKSUyfSkpfSxvZGQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soY2UuZ3JlcCh0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQlMn0pKX0sZXE6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5sZW5ndGgsbj0rZSsoZTwwP3Q6MCk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKDA8PW4mJm48dD9bdGhpc1tuXV06W10pfSxlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmV2T2JqZWN0fHx0aGlzLmNvbnN0cnVjdG9yKCl9LHB1c2g6cyxzb3J0Om9lLnNvcnQsc3BsaWNlOm9lLnNwbGljZX0sY2UuZXh0ZW5kPWNlLmZuLmV4dGVuZD1mdW5jdGlvbigpe3ZhciBlLHQsbixyLGksbyxhPWFyZ3VtZW50c1swXXx8e30scz0xLHU9YXJndW1lbnRzLmxlbmd0aCxsPSExO2ZvcihcImJvb2xlYW5cIj09dHlwZW9mIGEmJihsPWEsYT1hcmd1bWVudHNbc118fHt9LHMrKyksXCJvYmplY3RcIj09dHlwZW9mIGF8fHYoYSl8fChhPXt9KSxzPT09dSYmKGE9dGhpcyxzLS0pO3M8dTtzKyspaWYobnVsbCE9KGU9YXJndW1lbnRzW3NdKSlmb3IodCBpbiBlKXI9ZVt0XSxcIl9fcHJvdG9fX1wiIT09dCYmYSE9PXImJihsJiZyJiYoY2UuaXNQbGFpbk9iamVjdChyKXx8KGk9QXJyYXkuaXNBcnJheShyKSkpPyhuPWFbdF0sbz1pJiYhQXJyYXkuaXNBcnJheShuKT9bXTppfHxjZS5pc1BsYWluT2JqZWN0KG4pP246e30saT0hMSxhW3RdPWNlLmV4dGVuZChsLG8scikpOnZvaWQgMCE9PXImJihhW3RdPXIpKTtyZXR1cm4gYX0sY2UuZXh0ZW5kKHtleHBhbmRvOlwialF1ZXJ5XCIrKHQrTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csXCJcIiksaXNSZWFkeTohMCxlcnJvcjpmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoZSl9LG5vb3A6ZnVuY3Rpb24oKXt9LGlzUGxhaW5PYmplY3Q6ZnVuY3Rpb24oZSl7dmFyIHQsbjtyZXR1cm4hKCFlfHxcIltvYmplY3QgT2JqZWN0XVwiIT09aS5jYWxsKGUpKSYmKCEodD1yKGUpKXx8XCJmdW5jdGlvblwiPT10eXBlb2Yobj11ZS5jYWxsKHQsXCJjb25zdHJ1Y3RvclwiKSYmdC5jb25zdHJ1Y3RvcikmJm8uY2FsbChuKT09PWEpfSxpc0VtcHR5T2JqZWN0OmZ1bmN0aW9uKGUpe3ZhciB0O2Zvcih0IGluIGUpcmV0dXJuITE7cmV0dXJuITB9LGdsb2JhbEV2YWw6ZnVuY3Rpb24oZSx0LG4pe20oZSx7bm9uY2U6dCYmdC5ub25jZX0sbil9LGVhY2g6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTA7aWYoYyhlKSl7Zm9yKG49ZS5sZW5ndGg7cjxuO3IrKylpZighMT09PXQuY2FsbChlW3JdLHIsZVtyXSkpYnJlYWt9ZWxzZSBmb3IociBpbiBlKWlmKCExPT09dC5jYWxsKGVbcl0scixlW3JdKSlicmVhaztyZXR1cm4gZX0sdGV4dDpmdW5jdGlvbihlKXt2YXIgdCxuPVwiXCIscj0wLGk9ZS5ub2RlVHlwZTtpZighaSl3aGlsZSh0PWVbcisrXSluKz1jZS50ZXh0KHQpO3JldHVybiAxPT09aXx8MTE9PT1pP2UudGV4dENvbnRlbnQ6OT09PWk/ZS5kb2N1bWVudEVsZW1lbnQudGV4dENvbnRlbnQ6Mz09PWl8fDQ9PT1pP2Uubm9kZVZhbHVlOm59LG1ha2VBcnJheTpmdW5jdGlvbihlLHQpe3ZhciBuPXR8fFtdO3JldHVybiBudWxsIT1lJiYoYyhPYmplY3QoZSkpP2NlLm1lcmdlKG4sXCJzdHJpbmdcIj09dHlwZW9mIGU/W2VdOmUpOnMuY2FsbChuLGUpKSxufSxpbkFycmF5OmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbnVsbD09dD8tMTpzZS5jYWxsKHQsZSxuKX0saXNYTUxEb2M6ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5uYW1lc3BhY2VVUkksbj1lJiYoZS5vd25lckRvY3VtZW50fHxlKS5kb2N1bWVudEVsZW1lbnQ7cmV0dXJuIWwudGVzdCh0fHxuJiZuLm5vZGVOYW1lfHxcIkhUTUxcIil9LG1lcmdlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPSt0Lmxlbmd0aCxyPTAsaT1lLmxlbmd0aDtyPG47cisrKWVbaSsrXT10W3JdO3JldHVybiBlLmxlbmd0aD1pLGV9LGdyZXA6ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj1bXSxpPTAsbz1lLmxlbmd0aCxhPSFuO2k8bztpKyspIXQoZVtpXSxpKSE9PWEmJnIucHVzaChlW2ldKTtyZXR1cm4gcn0sbWFwOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89MCxhPVtdO2lmKGMoZSkpZm9yKHI9ZS5sZW5ndGg7bzxyO28rKyludWxsIT0oaT10KGVbb10sbyxuKSkmJmEucHVzaChpKTtlbHNlIGZvcihvIGluIGUpbnVsbCE9KGk9dChlW29dLG8sbikpJiZhLnB1c2goaSk7cmV0dXJuIGcoYSl9LGd1aWQ6MSxzdXBwb3J0OmxlfSksXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoY2UuZm5bU3ltYm9sLml0ZXJhdG9yXT1vZVtTeW1ib2wuaXRlcmF0b3JdKSxjZS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oZSx0KXtuW1wiW29iamVjdCBcIit0K1wiXVwiXT10LnRvTG93ZXJDYXNlKCl9KTt2YXIgcGU9b2UucG9wLGRlPW9lLnNvcnQsaGU9b2Uuc3BsaWNlLGdlPVwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIix2ZT1uZXcgUmVnRXhwKFwiXlwiK2dlK1wiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIitnZStcIiskXCIsXCJnXCIpO2NlLmNvbnRhaW5zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dCYmdC5wYXJlbnROb2RlO3JldHVybiBlPT09bnx8ISghbnx8MSE9PW4ubm9kZVR5cGV8fCEoZS5jb250YWlucz9lLmNvbnRhaW5zKG4pOmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24mJjE2JmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obikpKX07dmFyIGY9LyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFx4ODAtXFx1RkZGRlxcdy1dL2c7ZnVuY3Rpb24gcChlLHQpe3JldHVybiB0P1wiXFwwXCI9PT1lP1wiXFx1ZmZmZFwiOmUuc2xpY2UoMCwtMSkrXCJcXFxcXCIrZS5jaGFyQ29kZUF0KGUubGVuZ3RoLTEpLnRvU3RyaW5nKDE2KStcIiBcIjpcIlxcXFxcIitlfWNlLmVzY2FwZVNlbGVjdG9yPWZ1bmN0aW9uKGUpe3JldHVybihlK1wiXCIpLnJlcGxhY2UoZixwKX07dmFyIHllPUMsbWU9czshZnVuY3Rpb24oKXt2YXIgZSxiLHcsbyxhLFQscixDLGQsaSxrPW1lLFM9Y2UuZXhwYW5kbyxFPTAsbj0wLHM9VygpLGM9VygpLHU9VygpLGg9VygpLGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT09PXQmJihhPSEwKSwwfSxmPVwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIix0PVwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIitnZStcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLHA9XCJcXFxcW1wiK2dlK1wiKihcIit0K1wiKSg/OlwiK2dlK1wiKihbKl4kfCF+XT89KVwiK2dlK1wiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIrdCtcIikpfClcIitnZStcIipcXFxcXVwiLGc9XCI6KFwiK3QrXCIpKD86XFxcXCgoKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8KCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiK3ArXCIpKil8LiopXFxcXCl8KVwiLHY9bmV3IFJlZ0V4cChnZStcIitcIixcImdcIikseT1uZXcgUmVnRXhwKFwiXlwiK2dlK1wiKixcIitnZStcIipcIiksbT1uZXcgUmVnRXhwKFwiXlwiK2dlK1wiKihbPit+XXxcIitnZStcIilcIitnZStcIipcIikseD1uZXcgUmVnRXhwKGdlK1wifD5cIiksaj1uZXcgUmVnRXhwKGcpLEE9bmV3IFJlZ0V4cChcIl5cIit0K1wiJFwiKSxEPXtJRDpuZXcgUmVnRXhwKFwiXiMoXCIrdCtcIilcIiksQ0xBU1M6bmV3IFJlZ0V4cChcIl5cXFxcLihcIit0K1wiKVwiKSxUQUc6bmV3IFJlZ0V4cChcIl4oXCIrdCtcInxbKl0pXCIpLEFUVFI6bmV3IFJlZ0V4cChcIl5cIitwKSxQU0VVRE86bmV3IFJlZ0V4cChcIl5cIitnKSxDSElMRDpuZXcgUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIitnZStcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiK2dlK1wiKig/OihbKy1dfClcIitnZStcIiooXFxcXGQrKXwpKVwiK2dlK1wiKlxcXFwpfClcIixcImlcIiksYm9vbDpuZXcgUmVnRXhwKFwiXig/OlwiK2YrXCIpJFwiLFwiaVwiKSxuZWVkc0NvbnRleHQ6bmV3IFJlZ0V4cChcIl5cIitnZStcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIrZ2UrXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiK2dlK1wiKlxcXFwpfCkoPz1bXi1dfCQpXCIsXCJpXCIpfSxOPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2kscT0vXmhcXGQkL2ksTD0vXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxIPS9bK35dLyxPPW5ldyBSZWdFeHAoXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiK2dlK1wiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsXCJnXCIpLFA9ZnVuY3Rpb24oZSx0KXt2YXIgbj1cIjB4XCIrZS5zbGljZSgxKS02NTUzNjtyZXR1cm4gdHx8KG48MD9TdHJpbmcuZnJvbUNoYXJDb2RlKG4rNjU1MzYpOlN0cmluZy5mcm9tQ2hhckNvZGUobj4+MTB8NTUyOTYsMTAyMyZufDU2MzIwKSl9LE09ZnVuY3Rpb24oKXtWKCl9LFI9SihmdW5jdGlvbihlKXtyZXR1cm4hMD09PWUuZGlzYWJsZWQmJmZlKGUsXCJmaWVsZHNldFwiKX0se2RpcjpcInBhcmVudE5vZGVcIixuZXh0OlwibGVnZW5kXCJ9KTt0cnl7ay5hcHBseShvZT1hZS5jYWxsKHllLmNoaWxkTm9kZXMpLHllLmNoaWxkTm9kZXMpLG9lW3llLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZX1jYXRjaChlKXtrPXthcHBseTpmdW5jdGlvbihlLHQpe21lLmFwcGx5KGUsYWUuY2FsbCh0KSl9LGNhbGw6ZnVuY3Rpb24oZSl7bWUuYXBwbHkoZSxhZS5jYWxsKGFyZ3VtZW50cywxKSl9fX1mdW5jdGlvbiBJKHQsZSxuLHIpe3ZhciBpLG8sYSxzLHUsbCxjLGY9ZSYmZS5vd25lckRvY3VtZW50LHA9ZT9lLm5vZGVUeXBlOjk7aWYobj1ufHxbXSxcInN0cmluZ1wiIT10eXBlb2YgdHx8IXR8fDEhPT1wJiY5IT09cCYmMTEhPT1wKXJldHVybiBuO2lmKCFyJiYoVihlKSxlPWV8fFQsQykpe2lmKDExIT09cCYmKHU9TC5leGVjKHQpKSlpZihpPXVbMV0pe2lmKDk9PT1wKXtpZighKGE9ZS5nZXRFbGVtZW50QnlJZChpKSkpcmV0dXJuIG47aWYoYS5pZD09PWkpcmV0dXJuIGsuY2FsbChuLGEpLG59ZWxzZSBpZihmJiYoYT1mLmdldEVsZW1lbnRCeUlkKGkpKSYmSS5jb250YWlucyhlLGEpJiZhLmlkPT09aSlyZXR1cm4gay5jYWxsKG4sYSksbn1lbHNle2lmKHVbMl0pcmV0dXJuIGsuYXBwbHkobixlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHQpKSxuO2lmKChpPXVbM10pJiZlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpcmV0dXJuIGsuYXBwbHkobixlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaSkpLG59aWYoIShoW3QrXCIgXCJdfHxkJiZkLnRlc3QodCkpKXtpZihjPXQsZj1lLDE9PT1wJiYoeC50ZXN0KHQpfHxtLnRlc3QodCkpKXsoZj1ILnRlc3QodCkmJlUoZS5wYXJlbnROb2RlKXx8ZSk9PWUmJmxlLnNjb3BlfHwoKHM9ZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk/cz1jZS5lc2NhcGVTZWxlY3RvcihzKTplLnNldEF0dHJpYnV0ZShcImlkXCIscz1TKSksbz0obD1ZKHQpKS5sZW5ndGg7d2hpbGUoby0tKWxbb109KHM/XCIjXCIrczpcIjpzY29wZVwiKStcIiBcIitRKGxbb10pO2M9bC5qb2luKFwiLFwiKX10cnl7cmV0dXJuIGsuYXBwbHkobixmLnF1ZXJ5U2VsZWN0b3JBbGwoYykpLG59Y2F0Y2goZSl7aCh0LCEwKX1maW5hbGx5e3M9PT1TJiZlLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpfX19cmV0dXJuIHJlKHQucmVwbGFjZSh2ZSxcIiQxXCIpLGUsbixyKX1mdW5jdGlvbiBXKCl7dmFyIHI9W107cmV0dXJuIGZ1bmN0aW9uIGUodCxuKXtyZXR1cm4gci5wdXNoKHQrXCIgXCIpPmIuY2FjaGVMZW5ndGgmJmRlbGV0ZSBlW3Iuc2hpZnQoKV0sZVt0K1wiIFwiXT1ufX1mdW5jdGlvbiBGKGUpe3JldHVybiBlW1NdPSEwLGV9ZnVuY3Rpb24gJChlKXt2YXIgdD1ULmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTt0cnl7cmV0dXJuISFlKHQpfWNhdGNoKGUpe3JldHVybiExfWZpbmFsbHl7dC5wYXJlbnROb2RlJiZ0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCksdD1udWxsfX1mdW5jdGlvbiBCKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZmUoZSxcImlucHV0XCIpJiZlLnR5cGU9PT10fX1mdW5jdGlvbiBfKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4oZmUoZSxcImlucHV0XCIpfHxmZShlLFwiYnV0dG9uXCIpKSYmZS50eXBlPT09dH19ZnVuY3Rpb24geih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuXCJmb3JtXCJpbiBlP2UucGFyZW50Tm9kZSYmITE9PT1lLmRpc2FibGVkP1wibGFiZWxcImluIGU/XCJsYWJlbFwiaW4gZS5wYXJlbnROb2RlP2UucGFyZW50Tm9kZS5kaXNhYmxlZD09PXQ6ZS5kaXNhYmxlZD09PXQ6ZS5pc0Rpc2FibGVkPT09dHx8ZS5pc0Rpc2FibGVkIT09IXQmJlIoZSk9PT10OmUuZGlzYWJsZWQ9PT10OlwibGFiZWxcImluIGUmJmUuZGlzYWJsZWQ9PT10fX1mdW5jdGlvbiBYKGEpe3JldHVybiBGKGZ1bmN0aW9uKG8pe3JldHVybiBvPStvLEYoZnVuY3Rpb24oZSx0KXt2YXIgbixyPWEoW10sZS5sZW5ndGgsbyksaT1yLmxlbmd0aDt3aGlsZShpLS0pZVtuPXJbaV1dJiYoZVtuXT0hKHRbbl09ZVtuXSkpfSl9KX1mdW5jdGlvbiBVKGUpe3JldHVybiBlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSYmZX1mdW5jdGlvbiBWKGUpe3ZhciB0LG49ZT9lLm93bmVyRG9jdW1lbnR8fGU6eWU7cmV0dXJuIG4hPVQmJjk9PT1uLm5vZGVUeXBlJiZuLmRvY3VtZW50RWxlbWVudCYmKHI9KFQ9bikuZG9jdW1lbnRFbGVtZW50LEM9IWNlLmlzWE1MRG9jKFQpLGk9ci5tYXRjaGVzfHxyLndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8ci5tc01hdGNoZXNTZWxlY3RvcixyLm1zTWF0Y2hlc1NlbGVjdG9yJiZ5ZSE9VCYmKHQ9VC5kZWZhdWx0VmlldykmJnQudG9wIT09dCYmdC5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsTSksbGUuZ2V0QnlJZD0kKGZ1bmN0aW9uKGUpe3JldHVybiByLmFwcGVuZENoaWxkKGUpLmlkPWNlLmV4cGFuZG8sIVQuZ2V0RWxlbWVudHNCeU5hbWV8fCFULmdldEVsZW1lbnRzQnlOYW1lKGNlLmV4cGFuZG8pLmxlbmd0aH0pLGxlLmRpc2Nvbm5lY3RlZE1hdGNoPSQoZnVuY3Rpb24oZSl7cmV0dXJuIGkuY2FsbChlLFwiKlwiKX0pLGxlLnNjb3BlPSQoZnVuY3Rpb24oKXtyZXR1cm4gVC5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlXCIpfSksbGUuY3NzSGFzPSQoZnVuY3Rpb24oKXt0cnl7cmV0dXJuIFQucXVlcnlTZWxlY3RvcihcIjpoYXMoKiw6anFmYWtlKVwiKSwhMX1jYXRjaChlKXtyZXR1cm4hMH19KSxsZS5nZXRCeUlkPyhiLmZpbHRlci5JRD1mdW5jdGlvbihlKXt2YXIgdD1lLnJlcGxhY2UoTyxQKTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlKFwiaWRcIik9PT10fX0sYi5maW5kLklEPWZ1bmN0aW9uKGUsdCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQuZ2V0RWxlbWVudEJ5SWQmJkMpe3ZhciBuPXQuZ2V0RWxlbWVudEJ5SWQoZSk7cmV0dXJuIG4/W25dOltdfX0pOihiLmZpbHRlci5JRD1mdW5jdGlvbihlKXt2YXIgbj1lLnJlcGxhY2UoTyxQKTtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuZ2V0QXR0cmlidXRlTm9kZSYmZS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7cmV0dXJuIHQmJnQudmFsdWU9PT1ufX0sYi5maW5kLklEPWZ1bmN0aW9uKGUsdCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQuZ2V0RWxlbWVudEJ5SWQmJkMpe3ZhciBuLHIsaSxvPXQuZ2V0RWxlbWVudEJ5SWQoZSk7aWYobyl7aWYoKG49by5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikpJiZuLnZhbHVlPT09ZSlyZXR1cm5bb107aT10LmdldEVsZW1lbnRzQnlOYW1lKGUpLHI9MDt3aGlsZShvPWlbcisrXSlpZigobj1vLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKSkmJm4udmFsdWU9PT1lKXJldHVybltvXX1yZXR1cm5bXX19KSxiLmZpbmQuVEFHPWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQuZ2V0RWxlbWVudHNCeVRhZ05hbWU/dC5nZXRFbGVtZW50c0J5VGFnTmFtZShlKTp0LnF1ZXJ5U2VsZWN0b3JBbGwoZSl9LGIuZmluZC5DTEFTUz1mdW5jdGlvbihlLHQpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUmJkMpcmV0dXJuIHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShlKX0sZD1bXSwkKGZ1bmN0aW9uKGUpe3ZhciB0O3IuYXBwZW5kQ2hpbGQoZSkuaW5uZXJIVE1MPVwiPGEgaWQ9J1wiK1MrXCInIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+PHNlbGVjdCBpZD0nXCIrUytcIi1cXHJcXFxcJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCIsZS5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGh8fGQucHVzaChcIlxcXFxbXCIrZ2UrXCIqKD86dmFsdWV8XCIrZitcIilcIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIitTK1wiLV1cIikubGVuZ3RofHxkLnB1c2goXCJ+PVwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhI1wiK1MrXCIrKlwiKS5sZW5ndGh8fGQucHVzaChcIi4jLitbK35dXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aHx8ZC5wdXNoKFwiOmNoZWNrZWRcIiksKHQ9VC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIixcImhpZGRlblwiKSxlLmFwcGVuZENoaWxkKHQpLnNldEF0dHJpYnV0ZShcIm5hbWVcIixcIkRcIiksci5hcHBlbmRDaGlsZChlKS5kaXNhYmxlZD0hMCwyIT09ZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCYmZC5wdXNoKFwiOmVuYWJsZWRcIixcIjpkaXNhYmxlZFwiKSwodD1ULmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwiXCIpLGUuYXBwZW5kQ2hpbGQodCksZS5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9JyddXCIpLmxlbmd0aHx8ZC5wdXNoKFwiXFxcXFtcIitnZStcIipuYW1lXCIrZ2UrXCIqPVwiK2dlK1wiKig/OicnfFxcXCJcXFwiKVwiKX0pLGxlLmNzc0hhc3x8ZC5wdXNoKFwiOmhhc1wiKSxkPWQubGVuZ3RoJiZuZXcgUmVnRXhwKGQuam9pbihcInxcIikpLGw9ZnVuY3Rpb24oZSx0KXtpZihlPT09dClyZXR1cm4gYT0hMCwwO3ZhciBuPSFlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uLSF0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO3JldHVybiBufHwoMSYobj0oZS5vd25lckRvY3VtZW50fHxlKT09KHQub3duZXJEb2N1bWVudHx8dCk/ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KToxKXx8IWxlLnNvcnREZXRhY2hlZCYmdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKT09PW4/ZT09PVR8fGUub3duZXJEb2N1bWVudD09eWUmJkkuY29udGFpbnMoeWUsZSk/LTE6dD09PVR8fHQub3duZXJEb2N1bWVudD09eWUmJkkuY29udGFpbnMoeWUsdCk/MTpvP3NlLmNhbGwobyxlKS1zZS5jYWxsKG8sdCk6MDo0Jm4/LTE6MSl9KSxUfWZvcihlIGluIEkubWF0Y2hlcz1mdW5jdGlvbihlLHQpe3JldHVybiBJKGUsbnVsbCxudWxsLHQpfSxJLm1hdGNoZXNTZWxlY3Rvcj1mdW5jdGlvbihlLHQpe2lmKFYoZSksQyYmIWhbdCtcIiBcIl0mJighZHx8IWQudGVzdCh0KSkpdHJ5e3ZhciBuPWkuY2FsbChlLHQpO2lmKG58fGxlLmRpc2Nvbm5lY3RlZE1hdGNofHxlLmRvY3VtZW50JiYxMSE9PWUuZG9jdW1lbnQubm9kZVR5cGUpcmV0dXJuIG59Y2F0Y2goZSl7aCh0LCEwKX1yZXR1cm4gMDxJKHQsVCxudWxsLFtlXSkubGVuZ3RofSxJLmNvbnRhaW5zPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKGUub3duZXJEb2N1bWVudHx8ZSkhPVQmJlYoZSksY2UuY29udGFpbnMoZSx0KX0sSS5hdHRyPWZ1bmN0aW9uKGUsdCl7KGUub3duZXJEb2N1bWVudHx8ZSkhPVQmJlYoZSk7dmFyIG49Yi5hdHRySGFuZGxlW3QudG9Mb3dlckNhc2UoKV0scj1uJiZ1ZS5jYWxsKGIuYXR0ckhhbmRsZSx0LnRvTG93ZXJDYXNlKCkpP24oZSx0LCFDKTp2b2lkIDA7cmV0dXJuIHZvaWQgMCE9PXI/cjplLmdldEF0dHJpYnV0ZSh0KX0sSS5lcnJvcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIitlKX0sY2UudW5pcXVlU29ydD1mdW5jdGlvbihlKXt2YXIgdCxuPVtdLHI9MCxpPTA7aWYoYT0hbGUuc29ydFN0YWJsZSxvPSFsZS5zb3J0U3RhYmxlJiZhZS5jYWxsKGUsMCksZGUuY2FsbChlLGwpLGEpe3doaWxlKHQ9ZVtpKytdKXQ9PT1lW2ldJiYocj1uLnB1c2goaSkpO3doaWxlKHItLSloZS5jYWxsKGUsbltyXSwxKX1yZXR1cm4gbz1udWxsLGV9LGNlLmZuLnVuaXF1ZVNvcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soY2UudW5pcXVlU29ydChhZS5hcHBseSh0aGlzKSkpfSwoYj1jZS5leHByPXtjYWNoZUxlbmd0aDo1MCxjcmVhdGVQc2V1ZG86RixtYXRjaDpELGF0dHJIYW5kbGU6e30sZmluZDp7fSxyZWxhdGl2ZTp7XCI+XCI6e2RpcjpcInBhcmVudE5vZGVcIixmaXJzdDohMH0sXCIgXCI6e2RpcjpcInBhcmVudE5vZGVcIn0sXCIrXCI6e2RpcjpcInByZXZpb3VzU2libGluZ1wiLGZpcnN0OiEwfSxcIn5cIjp7ZGlyOlwicHJldmlvdXNTaWJsaW5nXCJ9fSxwcmVGaWx0ZXI6e0FUVFI6ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMV09ZVsxXS5yZXBsYWNlKE8sUCksZVszXT0oZVszXXx8ZVs0XXx8ZVs1XXx8XCJcIikucmVwbGFjZShPLFApLFwifj1cIj09PWVbMl0mJihlWzNdPVwiIFwiK2VbM10rXCIgXCIpLGUuc2xpY2UoMCw0KX0sQ0hJTEQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMV09ZVsxXS50b0xvd2VyQ2FzZSgpLFwibnRoXCI9PT1lWzFdLnNsaWNlKDAsMyk/KGVbM118fEkuZXJyb3IoZVswXSksZVs0XT0rKGVbNF0/ZVs1XSsoZVs2XXx8MSk6MiooXCJldmVuXCI9PT1lWzNdfHxcIm9kZFwiPT09ZVszXSkpLGVbNV09KyhlWzddK2VbOF18fFwib2RkXCI9PT1lWzNdKSk6ZVszXSYmSS5lcnJvcihlWzBdKSxlfSxQU0VVRE86ZnVuY3Rpb24oZSl7dmFyIHQsbj0hZVs2XSYmZVsyXTtyZXR1cm4gRC5DSElMRC50ZXN0KGVbMF0pP251bGw6KGVbM10/ZVsyXT1lWzRdfHxlWzVdfHxcIlwiOm4mJmoudGVzdChuKSYmKHQ9WShuLCEwKSkmJih0PW4uaW5kZXhPZihcIilcIixuLmxlbmd0aC10KS1uLmxlbmd0aCkmJihlWzBdPWVbMF0uc2xpY2UoMCx0KSxlWzJdPW4uc2xpY2UoMCx0KSksZS5zbGljZSgwLDMpKX19LGZpbHRlcjp7VEFHOmZ1bmN0aW9uKGUpe3ZhciB0PWUucmVwbGFjZShPLFApLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCIqXCI9PT1lP2Z1bmN0aW9uKCl7cmV0dXJuITB9OmZ1bmN0aW9uKGUpe3JldHVybiBmZShlLHQpfX0sQ0xBU1M6ZnVuY3Rpb24oZSl7dmFyIHQ9c1tlK1wiIFwiXTtyZXR1cm4gdHx8KHQ9bmV3IFJlZ0V4cChcIihefFwiK2dlK1wiKVwiK2UrXCIoXCIrZ2UrXCJ8JClcIikpJiZzKGUsZnVuY3Rpb24oZSl7cmV0dXJuIHQudGVzdChcInN0cmluZ1wiPT10eXBlb2YgZS5jbGFzc05hbWUmJmUuY2xhc3NOYW1lfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgZS5nZXRBdHRyaWJ1dGUmJmUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIpfSl9LEFUVFI6ZnVuY3Rpb24obixyLGkpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1JLmF0dHIoZSxuKTtyZXR1cm4gbnVsbD09dD9cIiE9XCI9PT1yOiFyfHwodCs9XCJcIixcIj1cIj09PXI/dD09PWk6XCIhPVwiPT09cj90IT09aTpcIl49XCI9PT1yP2kmJjA9PT10LmluZGV4T2YoaSk6XCIqPVwiPT09cj9pJiYtMTx0LmluZGV4T2YoaSk6XCIkPVwiPT09cj9pJiZ0LnNsaWNlKC1pLmxlbmd0aCk9PT1pOlwifj1cIj09PXI/LTE8KFwiIFwiK3QucmVwbGFjZSh2LFwiIFwiKStcIiBcIikuaW5kZXhPZihpKTpcInw9XCI9PT1yJiYodD09PWl8fHQuc2xpY2UoMCxpLmxlbmd0aCsxKT09PWkrXCItXCIpKX19LENISUxEOmZ1bmN0aW9uKGQsZSx0LGgsZyl7dmFyIHY9XCJudGhcIiE9PWQuc2xpY2UoMCwzKSx5PVwibGFzdFwiIT09ZC5zbGljZSgtNCksbT1cIm9mLXR5cGVcIj09PWU7cmV0dXJuIDE9PT1oJiYwPT09Zz9mdW5jdGlvbihlKXtyZXR1cm4hIWUucGFyZW50Tm9kZX06ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhLHMsdT12IT09eT9cIm5leHRTaWJsaW5nXCI6XCJwcmV2aW91c1NpYmxpbmdcIixsPWUucGFyZW50Tm9kZSxjPW0mJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxmPSFuJiYhbSxwPSExO2lmKGwpe2lmKHYpe3doaWxlKHUpe289ZTt3aGlsZShvPW9bdV0paWYobT9mZShvLGMpOjE9PT1vLm5vZGVUeXBlKXJldHVybiExO3M9dT1cIm9ubHlcIj09PWQmJiFzJiZcIm5leHRTaWJsaW5nXCJ9cmV0dXJuITB9aWYocz1beT9sLmZpcnN0Q2hpbGQ6bC5sYXN0Q2hpbGRdLHkmJmYpe3A9KGE9KHI9KGk9bFtTXXx8KGxbU109e30pKVtkXXx8W10pWzBdPT09RSYmclsxXSkmJnJbMl0sbz1hJiZsLmNoaWxkTm9kZXNbYV07d2hpbGUobz0rK2EmJm8mJm9bdV18fChwPWE9MCl8fHMucG9wKCkpaWYoMT09PW8ubm9kZVR5cGUmJisrcCYmbz09PWUpe2lbZF09W0UsYSxwXTticmVha319ZWxzZSBpZihmJiYocD1hPShyPShpPWVbU118fChlW1NdPXt9KSlbZF18fFtdKVswXT09PUUmJnJbMV0pLCExPT09cCl3aGlsZShvPSsrYSYmbyYmb1t1XXx8KHA9YT0wKXx8cy5wb3AoKSlpZigobT9mZShvLGMpOjE9PT1vLm5vZGVUeXBlKSYmKytwJiYoZiYmKChpPW9bU118fChvW1NdPXt9KSlbZF09W0UscF0pLG89PT1lKSlicmVhaztyZXR1cm4ocC09Zyk9PT1ofHxwJWg9PTAmJjA8PXAvaH19fSxQU0VVRE86ZnVuY3Rpb24oZSxvKXt2YXIgdCxhPWIucHNldWRvc1tlXXx8Yi5zZXRGaWx0ZXJzW2UudG9Mb3dlckNhc2UoKV18fEkuZXJyb3IoXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiK2UpO3JldHVybiBhW1NdP2Eobyk6MTxhLmxlbmd0aD8odD1bZSxlLFwiXCIsb10sYi5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KGUudG9Mb3dlckNhc2UoKSk/RihmdW5jdGlvbihlLHQpe3ZhciBuLHI9YShlLG8pLGk9ci5sZW5ndGg7d2hpbGUoaS0tKWVbbj1zZS5jYWxsKGUscltpXSldPSEodFtuXT1yW2ldKX0pOmZ1bmN0aW9uKGUpe3JldHVybiBhKGUsMCx0KX0pOmF9fSxwc2V1ZG9zOntub3Q6RihmdW5jdGlvbihlKXt2YXIgcj1bXSxpPVtdLHM9bmUoZS5yZXBsYWNlKHZlLFwiJDFcIikpO3JldHVybiBzW1NdP0YoZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbz1zKGUsbnVsbCxyLFtdKSxhPWUubGVuZ3RoO3doaWxlKGEtLSkoaT1vW2FdKSYmKGVbYV09ISh0W2FdPWkpKX0pOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gclswXT1lLHMocixudWxsLG4saSksclswXT1udWxsLCFpLnBvcCgpfX0pLGhhczpGKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gMDxJKHQsZSkubGVuZ3RofX0pLGNvbnRhaW5zOkYoZnVuY3Rpb24odCl7cmV0dXJuIHQ9dC5yZXBsYWNlKE8sUCksZnVuY3Rpb24oZSl7cmV0dXJuLTE8KGUudGV4dENvbnRlbnR8fGNlLnRleHQoZSkpLmluZGV4T2YodCl9fSksbGFuZzpGKGZ1bmN0aW9uKG4pe3JldHVybiBBLnRlc3Qobnx8XCJcIil8fEkuZXJyb3IoXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIituKSxuPW4ucmVwbGFjZShPLFApLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oZSl7dmFyIHQ7ZG97aWYodD1DP2UubGFuZzplLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpfHxlLmdldEF0dHJpYnV0ZShcImxhbmdcIikpcmV0dXJuKHQ9dC50b0xvd2VyQ2FzZSgpKT09PW58fDA9PT10LmluZGV4T2YobitcIi1cIil9d2hpbGUoKGU9ZS5wYXJlbnROb2RlKSYmMT09PWUubm9kZVR5cGUpO3JldHVybiExfX0pLHRhcmdldDpmdW5jdGlvbihlKXt2YXIgdD1pZS5sb2NhdGlvbiYmaWUubG9jYXRpb24uaGFzaDtyZXR1cm4gdCYmdC5zbGljZSgxKT09PWUuaWR9LHJvb3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1yfSxmb2N1czpmdW5jdGlvbihlKXtyZXR1cm4gZT09PWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBULmFjdGl2ZUVsZW1lbnR9Y2F0Y2goZSl7fX0oKSYmVC5oYXNGb2N1cygpJiYhIShlLnR5cGV8fGUuaHJlZnx8fmUudGFiSW5kZXgpfSxlbmFibGVkOnooITEpLGRpc2FibGVkOnooITApLGNoZWNrZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGZlKGUsXCJpbnB1dFwiKSYmISFlLmNoZWNrZWR8fGZlKGUsXCJvcHRpb25cIikmJiEhZS5zZWxlY3RlZH0sc2VsZWN0ZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucGFyZW50Tm9kZSYmZS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsITA9PT1lLnNlbGVjdGVkfSxlbXB0eTpmdW5jdGlvbihlKXtmb3IoZT1lLmZpcnN0Q2hpbGQ7ZTtlPWUubmV4dFNpYmxpbmcpaWYoZS5ub2RlVHlwZTw2KXJldHVybiExO3JldHVybiEwfSxwYXJlbnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIWIucHNldWRvcy5lbXB0eShlKX0saGVhZGVyOmZ1bmN0aW9uKGUpe3JldHVybiBxLnRlc3QoZS5ub2RlTmFtZSl9LGlucHV0OmZ1bmN0aW9uKGUpe3JldHVybiBOLnRlc3QoZS5ub2RlTmFtZSl9LGJ1dHRvbjpmdW5jdGlvbihlKXtyZXR1cm4gZmUoZSxcImlucHV0XCIpJiZcImJ1dHRvblwiPT09ZS50eXBlfHxmZShlLFwiYnV0dG9uXCIpfSx0ZXh0OmZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiBmZShlLFwiaW5wdXRcIikmJlwidGV4dFwiPT09ZS50eXBlJiYobnVsbD09KHQ9ZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKXx8XCJ0ZXh0XCI9PT10LnRvTG93ZXJDYXNlKCkpfSxmaXJzdDpYKGZ1bmN0aW9uKCl7cmV0dXJuWzBdfSksbGFzdDpYKGZ1bmN0aW9uKGUsdCl7cmV0dXJuW3QtMV19KSxlcTpYKGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm5bbjwwP24rdDpuXX0pLGV2ZW46WChmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248dDtuKz0yKWUucHVzaChuKTtyZXR1cm4gZX0pLG9kZDpYKGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTE7bjx0O24rPTIpZS5wdXNoKG4pO3JldHVybiBlfSksbHQ6WChmdW5jdGlvbihlLHQsbil7dmFyIHI7Zm9yKHI9bjwwP24rdDp0PG4/dDpuOzA8PS0tcjspZS5wdXNoKHIpO3JldHVybiBlfSksZ3Q6WChmdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPW48MD9uK3Q6bjsrK3I8dDspZS5wdXNoKHIpO3JldHVybiBlfSl9fSkucHNldWRvcy5udGg9Yi5wc2V1ZG9zLmVxLHtyYWRpbzohMCxjaGVja2JveDohMCxmaWxlOiEwLHBhc3N3b3JkOiEwLGltYWdlOiEwfSliLnBzZXVkb3NbZV09QihlKTtmb3IoZSBpbntzdWJtaXQ6ITAscmVzZXQ6ITB9KWIucHNldWRvc1tlXT1fKGUpO2Z1bmN0aW9uIEcoKXt9ZnVuY3Rpb24gWShlLHQpe3ZhciBuLHIsaSxvLGEscyx1LGw9Y1tlK1wiIFwiXTtpZihsKXJldHVybiB0PzA6bC5zbGljZSgwKTthPWUscz1bXSx1PWIucHJlRmlsdGVyO3doaWxlKGEpe2ZvcihvIGluIG4mJiEocj15LmV4ZWMoYSkpfHwociYmKGE9YS5zbGljZShyWzBdLmxlbmd0aCl8fGEpLHMucHVzaChpPVtdKSksbj0hMSwocj1tLmV4ZWMoYSkpJiYobj1yLnNoaWZ0KCksaS5wdXNoKHt2YWx1ZTpuLHR5cGU6clswXS5yZXBsYWNlKHZlLFwiIFwiKX0pLGE9YS5zbGljZShuLmxlbmd0aCkpLGIuZmlsdGVyKSEocj1EW29dLmV4ZWMoYSkpfHx1W29dJiYhKHI9dVtvXShyKSl8fChuPXIuc2hpZnQoKSxpLnB1c2goe3ZhbHVlOm4sdHlwZTpvLG1hdGNoZXM6cn0pLGE9YS5zbGljZShuLmxlbmd0aCkpO2lmKCFuKWJyZWFrfXJldHVybiB0P2EubGVuZ3RoOmE/SS5lcnJvcihlKTpjKGUscykuc2xpY2UoMCl9ZnVuY3Rpb24gUShlKXtmb3IodmFyIHQ9MCxuPWUubGVuZ3RoLHI9XCJcIjt0PG47dCsrKXIrPWVbdF0udmFsdWU7cmV0dXJuIHJ9ZnVuY3Rpb24gSihhLGUsdCl7dmFyIHM9ZS5kaXIsdT1lLm5leHQsbD11fHxzLGM9dCYmXCJwYXJlbnROb2RlXCI9PT1sLGY9bisrO3JldHVybiBlLmZpcnN0P2Z1bmN0aW9uKGUsdCxuKXt3aGlsZShlPWVbc10paWYoMT09PWUubm9kZVR5cGV8fGMpcmV0dXJuIGEoZSx0LG4pO3JldHVybiExfTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPVtFLGZdO2lmKG4pe3doaWxlKGU9ZVtzXSlpZigoMT09PWUubm9kZVR5cGV8fGMpJiZhKGUsdCxuKSlyZXR1cm4hMH1lbHNlIHdoaWxlKGU9ZVtzXSlpZigxPT09ZS5ub2RlVHlwZXx8YylpZihpPWVbU118fChlW1NdPXt9KSx1JiZmZShlLHUpKWU9ZVtzXXx8ZTtlbHNle2lmKChyPWlbbF0pJiZyWzBdPT09RSYmclsxXT09PWYpcmV0dXJuIG9bMl09clsyXTtpZigoaVtsXT1vKVsyXT1hKGUsdCxuKSlyZXR1cm4hMH1yZXR1cm4hMX19ZnVuY3Rpb24gSyhpKXtyZXR1cm4gMTxpLmxlbmd0aD9mdW5jdGlvbihlLHQsbil7dmFyIHI9aS5sZW5ndGg7d2hpbGUoci0tKWlmKCFpW3JdKGUsdCxuKSlyZXR1cm4hMTtyZXR1cm4hMH06aVswXX1mdW5jdGlvbiBaKGUsdCxuLHIsaSl7Zm9yKHZhciBvLGE9W10scz0wLHU9ZS5sZW5ndGgsbD1udWxsIT10O3M8dTtzKyspKG89ZVtzXSkmJihuJiYhbihvLHIsaSl8fChhLnB1c2gobyksbCYmdC5wdXNoKHMpKSk7cmV0dXJuIGF9ZnVuY3Rpb24gZWUoZCxoLGcsdix5LGUpe3JldHVybiB2JiYhdltTXSYmKHY9ZWUodikpLHkmJiF5W1NdJiYoeT1lZSh5LGUpKSxGKGZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYSxzLHU9W10sbD1bXSxjPXQubGVuZ3RoLGY9ZXx8ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj0wLGk9dC5sZW5ndGg7cjxpO3IrKylJKGUsdFtyXSxuKTtyZXR1cm4gbn0oaHx8XCIqXCIsbi5ub2RlVHlwZT9bbl06bixbXSkscD0hZHx8IWUmJmg/ZjpaKGYsdSxkLG4scik7aWYoZz9nKHAscz15fHwoZT9kOmN8fHYpP1tdOnQsbixyKTpzPXAsdil7aT1aKHMsbCksdihpLFtdLG4sciksbz1pLmxlbmd0aDt3aGlsZShvLS0pKGE9aVtvXSkmJihzW2xbb11dPSEocFtsW29dXT1hKSl9aWYoZSl7aWYoeXx8ZCl7aWYoeSl7aT1bXSxvPXMubGVuZ3RoO3doaWxlKG8tLSkoYT1zW29dKSYmaS5wdXNoKHBbb109YSk7eShudWxsLHM9W10saSxyKX1vPXMubGVuZ3RoO3doaWxlKG8tLSkoYT1zW29dKSYmLTE8KGk9eT9zZS5jYWxsKGUsYSk6dVtvXSkmJihlW2ldPSEodFtpXT1hKSl9fWVsc2Ugcz1aKHM9PT10P3Muc3BsaWNlKGMscy5sZW5ndGgpOnMpLHk/eShudWxsLHQscyxyKTprLmFwcGx5KHQscyl9KX1mdW5jdGlvbiB0ZShlKXtmb3IodmFyIGksdCxuLHI9ZS5sZW5ndGgsbz1iLnJlbGF0aXZlW2VbMF0udHlwZV0sYT1vfHxiLnJlbGF0aXZlW1wiIFwiXSxzPW8/MTowLHU9SihmdW5jdGlvbihlKXtyZXR1cm4gZT09PWl9LGEsITApLGw9SihmdW5jdGlvbihlKXtyZXR1cm4tMTxzZS5jYWxsKGksZSl9LGEsITApLGM9W2Z1bmN0aW9uKGUsdCxuKXt2YXIgcj0hbyYmKG58fHQhPXcpfHwoKGk9dCkubm9kZVR5cGU/dShlLHQsbik6bChlLHQsbikpO3JldHVybiBpPW51bGwscn1dO3M8cjtzKyspaWYodD1iLnJlbGF0aXZlW2Vbc10udHlwZV0pYz1bSihLKGMpLHQpXTtlbHNle2lmKCh0PWIuZmlsdGVyW2Vbc10udHlwZV0uYXBwbHkobnVsbCxlW3NdLm1hdGNoZXMpKVtTXSl7Zm9yKG49KytzO248cjtuKyspaWYoYi5yZWxhdGl2ZVtlW25dLnR5cGVdKWJyZWFrO3JldHVybiBlZSgxPHMmJksoYyksMTxzJiZRKGUuc2xpY2UoMCxzLTEpLmNvbmNhdCh7dmFsdWU6XCIgXCI9PT1lW3MtMl0udHlwZT9cIipcIjpcIlwifSkpLnJlcGxhY2UodmUsXCIkMVwiKSx0LHM8biYmdGUoZS5zbGljZShzLG4pKSxuPHImJnRlKGU9ZS5zbGljZShuKSksbjxyJiZRKGUpKX1jLnB1c2godCl9cmV0dXJuIEsoYyl9ZnVuY3Rpb24gbmUoZSx0KXt2YXIgbix2LHksbSx4LHIsaT1bXSxvPVtdLGE9dVtlK1wiIFwiXTtpZighYSl7dHx8KHQ9WShlKSksbj10Lmxlbmd0aDt3aGlsZShuLS0pKGE9dGUodFtuXSkpW1NdP2kucHVzaChhKTpvLnB1c2goYSk7KGE9dShlLCh2PW8sbT0wPCh5PWkpLmxlbmd0aCx4PTA8di5sZW5ndGgscj1mdW5jdGlvbihlLHQsbixyLGkpe3ZhciBvLGEscyx1PTAsbD1cIjBcIixjPWUmJltdLGY9W10scD13LGQ9ZXx8eCYmYi5maW5kLlRBRyhcIipcIixpKSxoPUUrPW51bGw9PXA/MTpNYXRoLnJhbmRvbSgpfHwuMSxnPWQubGVuZ3RoO2ZvcihpJiYodz10PT1UfHx0fHxpKTtsIT09ZyYmbnVsbCE9KG89ZFtsXSk7bCsrKXtpZih4JiZvKXthPTAsdHx8by5vd25lckRvY3VtZW50PT1UfHwoVihvKSxuPSFDKTt3aGlsZShzPXZbYSsrXSlpZihzKG8sdHx8VCxuKSl7ay5jYWxsKHIsbyk7YnJlYWt9aSYmKEU9aCl9bSYmKChvPSFzJiZvKSYmdS0tLGUmJmMucHVzaChvKSl9aWYodSs9bCxtJiZsIT09dSl7YT0wO3doaWxlKHM9eVthKytdKXMoYyxmLHQsbik7aWYoZSl7aWYoMDx1KXdoaWxlKGwtLSljW2xdfHxmW2xdfHwoZltsXT1wZS5jYWxsKHIpKTtmPVooZil9ay5hcHBseShyLGYpLGkmJiFlJiYwPGYubGVuZ3RoJiYxPHUreS5sZW5ndGgmJmNlLnVuaXF1ZVNvcnQocil9cmV0dXJuIGkmJihFPWgsdz1wKSxjfSxtP0Yocik6cikpKS5zZWxlY3Rvcj1lfXJldHVybiBhfWZ1bmN0aW9uIHJlKGUsdCxuLHIpe3ZhciBpLG8sYSxzLHUsbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLGM9IXImJlkoZT1sLnNlbGVjdG9yfHxlKTtpZihuPW58fFtdLDE9PT1jLmxlbmd0aCl7aWYoMjwobz1jWzBdPWNbMF0uc2xpY2UoMCkpLmxlbmd0aCYmXCJJRFwiPT09KGE9b1swXSkudHlwZSYmOT09PXQubm9kZVR5cGUmJkMmJmIucmVsYXRpdmVbb1sxXS50eXBlXSl7aWYoISh0PShiLmZpbmQuSUQoYS5tYXRjaGVzWzBdLnJlcGxhY2UoTyxQKSx0KXx8W10pWzBdKSlyZXR1cm4gbjtsJiYodD10LnBhcmVudE5vZGUpLGU9ZS5zbGljZShvLnNoaWZ0KCkudmFsdWUubGVuZ3RoKX1pPUQubmVlZHNDb250ZXh0LnRlc3QoZSk/MDpvLmxlbmd0aDt3aGlsZShpLS0pe2lmKGE9b1tpXSxiLnJlbGF0aXZlW3M9YS50eXBlXSlicmVhaztpZigodT1iLmZpbmRbc10pJiYocj11KGEubWF0Y2hlc1swXS5yZXBsYWNlKE8sUCksSC50ZXN0KG9bMF0udHlwZSkmJlUodC5wYXJlbnROb2RlKXx8dCkpKXtpZihvLnNwbGljZShpLDEpLCEoZT1yLmxlbmd0aCYmUShvKSkpcmV0dXJuIGsuYXBwbHkobixyKSxuO2JyZWFrfX19cmV0dXJuKGx8fG5lKGUsYykpKHIsdCwhQyxuLCF0fHxILnRlc3QoZSkmJlUodC5wYXJlbnROb2RlKXx8dCksbn1HLnByb3RvdHlwZT1iLmZpbHRlcnM9Yi5wc2V1ZG9zLGIuc2V0RmlsdGVycz1uZXcgRyxsZS5zb3J0U3RhYmxlPVMuc3BsaXQoXCJcIikuc29ydChsKS5qb2luKFwiXCIpPT09UyxWKCksbGUuc29ydERldGFjaGVkPSQoZnVuY3Rpb24oZSl7cmV0dXJuIDEmZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihULmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSl9KSxjZS5maW5kPUksY2UuZXhwcltcIjpcIl09Y2UuZXhwci5wc2V1ZG9zLGNlLnVuaXF1ZT1jZS51bmlxdWVTb3J0LEkuY29tcGlsZT1uZSxJLnNlbGVjdD1yZSxJLnNldERvY3VtZW50PVYsSS50b2tlbml6ZT1ZLEkuZXNjYXBlPWNlLmVzY2FwZVNlbGVjdG9yLEkuZ2V0VGV4dD1jZS50ZXh0LEkuaXNYTUw9Y2UuaXNYTUxEb2MsSS5zZWxlY3RvcnM9Y2UuZXhwcixJLnN1cHBvcnQ9Y2Uuc3VwcG9ydCxJLnVuaXF1ZVNvcnQ9Y2UudW5pcXVlU29ydH0oKTt2YXIgZD1mdW5jdGlvbihlLHQsbil7dmFyIHI9W10saT12b2lkIDAhPT1uO3doaWxlKChlPWVbdF0pJiY5IT09ZS5ub2RlVHlwZSlpZigxPT09ZS5ub2RlVHlwZSl7aWYoaSYmY2UoZSkuaXMobikpYnJlYWs7ci5wdXNoKGUpfXJldHVybiByfSxoPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPVtdO2U7ZT1lLm5leHRTaWJsaW5nKTE9PT1lLm5vZGVUeXBlJiZlIT09dCYmbi5wdXNoKGUpO3JldHVybiBufSxiPWNlLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LHc9L148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2k7ZnVuY3Rpb24gVChlLG4scil7cmV0dXJuIHYobik/Y2UuZ3JlcChlLGZ1bmN0aW9uKGUsdCl7cmV0dXJuISFuLmNhbGwoZSx0LGUpIT09cn0pOm4ubm9kZVR5cGU/Y2UuZ3JlcChlLGZ1bmN0aW9uKGUpe3JldHVybiBlPT09biE9PXJ9KTpcInN0cmluZ1wiIT10eXBlb2Ygbj9jZS5ncmVwKGUsZnVuY3Rpb24oZSl7cmV0dXJuLTE8c2UuY2FsbChuLGUpIT09cn0pOmNlLmZpbHRlcihuLGUscil9Y2UuZmlsdGVyPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdO3JldHVybiBuJiYoZT1cIjpub3QoXCIrZStcIilcIiksMT09PXQubGVuZ3RoJiYxPT09ci5ub2RlVHlwZT9jZS5maW5kLm1hdGNoZXNTZWxlY3RvcihyLGUpP1tyXTpbXTpjZS5maW5kLm1hdGNoZXMoZSxjZS5ncmVwKHQsZnVuY3Rpb24oZSl7cmV0dXJuIDE9PT1lLm5vZGVUeXBlfSkpfSxjZS5mbi5leHRlbmQoe2ZpbmQ6ZnVuY3Rpb24oZSl7dmFyIHQsbixyPXRoaXMubGVuZ3RoLGk9dGhpcztpZihcInN0cmluZ1wiIT10eXBlb2YgZSlyZXR1cm4gdGhpcy5wdXNoU3RhY2soY2UoZSkuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKHQ9MDt0PHI7dCsrKWlmKGNlLmNvbnRhaW5zKGlbdF0sdGhpcykpcmV0dXJuITB9KSk7Zm9yKG49dGhpcy5wdXNoU3RhY2soW10pLHQ9MDt0PHI7dCsrKWNlLmZpbmQoZSxpW3RdLG4pO3JldHVybiAxPHI/Y2UudW5pcXVlU29ydChuKTpufSxmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKFQodGhpcyxlfHxbXSwhMSkpfSxub3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKFQodGhpcyxlfHxbXSwhMCkpfSxpczpmdW5jdGlvbihlKXtyZXR1cm4hIVQodGhpcyxcInN0cmluZ1wiPT10eXBlb2YgZSYmYi50ZXN0KGUpP2NlKGUpOmV8fFtdLCExKS5sZW5ndGh9fSk7dmFyIGssUz0vXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLzsoY2UuZm4uaW5pdD1mdW5jdGlvbihlLHQsbil7dmFyIHIsaTtpZighZSlyZXR1cm4gdGhpcztpZihuPW58fGssXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKCEocj1cIjxcIj09PWVbMF0mJlwiPlwiPT09ZVtlLmxlbmd0aC0xXSYmMzw9ZS5sZW5ndGg/W251bGwsZSxudWxsXTpTLmV4ZWMoZSkpfHwhclsxXSYmdClyZXR1cm4hdHx8dC5qcXVlcnk/KHR8fG4pLmZpbmQoZSk6dGhpcy5jb25zdHJ1Y3Rvcih0KS5maW5kKGUpO2lmKHJbMV0pe2lmKHQ9dCBpbnN0YW5jZW9mIGNlP3RbMF06dCxjZS5tZXJnZSh0aGlzLGNlLnBhcnNlSFRNTChyWzFdLHQmJnQubm9kZVR5cGU/dC5vd25lckRvY3VtZW50fHx0OkMsITApKSx3LnRlc3QoclsxXSkmJmNlLmlzUGxhaW5PYmplY3QodCkpZm9yKHIgaW4gdCl2KHRoaXNbcl0pP3RoaXNbcl0odFtyXSk6dGhpcy5hdHRyKHIsdFtyXSk7cmV0dXJuIHRoaXN9cmV0dXJuKGk9Qy5nZXRFbGVtZW50QnlJZChyWzJdKSkmJih0aGlzWzBdPWksdGhpcy5sZW5ndGg9MSksdGhpc31yZXR1cm4gZS5ub2RlVHlwZT8odGhpc1swXT1lLHRoaXMubGVuZ3RoPTEsdGhpcyk6dihlKT92b2lkIDAhPT1uLnJlYWR5P24ucmVhZHkoZSk6ZShjZSk6Y2UubWFrZUFycmF5KGUsdGhpcyl9KS5wcm90b3R5cGU9Y2UuZm4saz1jZShDKTt2YXIgRT0vXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxqPXtjaGlsZHJlbjohMCxjb250ZW50czohMCxuZXh0OiEwLHByZXY6ITB9O2Z1bmN0aW9uIEEoZSx0KXt3aGlsZSgoZT1lW3RdKSYmMSE9PWUubm9kZVR5cGUpO3JldHVybiBlfWNlLmZuLmV4dGVuZCh7aGFzOmZ1bmN0aW9uKGUpe3ZhciB0PWNlKGUsdGhpcyksbj10Lmxlbmd0aDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKXtmb3IodmFyIGU9MDtlPG47ZSsrKWlmKGNlLmNvbnRhaW5zKHRoaXMsdFtlXSkpcmV0dXJuITB9KX0sY2xvc2VzdDpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MCxpPXRoaXMubGVuZ3RoLG89W10sYT1cInN0cmluZ1wiIT10eXBlb2YgZSYmY2UoZSk7aWYoIWIudGVzdChlKSlmb3IoO3I8aTtyKyspZm9yKG49dGhpc1tyXTtuJiZuIT09dDtuPW4ucGFyZW50Tm9kZSlpZihuLm5vZGVUeXBlPDExJiYoYT8tMTxhLmluZGV4KG4pOjE9PT1uLm5vZGVUeXBlJiZjZS5maW5kLm1hdGNoZXNTZWxlY3RvcihuLGUpKSl7by5wdXNoKG4pO2JyZWFrfXJldHVybiB0aGlzLnB1c2hTdGFjaygxPG8ubGVuZ3RoP2NlLnVuaXF1ZVNvcnQobyk6byl9LGluZGV4OmZ1bmN0aW9uKGUpe3JldHVybiBlP1wic3RyaW5nXCI9PXR5cGVvZiBlP3NlLmNhbGwoY2UoZSksdGhpc1swXSk6c2UuY2FsbCh0aGlzLGUuanF1ZXJ5P2VbMF06ZSk6dGhpc1swXSYmdGhpc1swXS5wYXJlbnROb2RlP3RoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoOi0xfSxhZGQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soY2UudW5pcXVlU29ydChjZS5tZXJnZSh0aGlzLmdldCgpLGNlKGUsdCkpKSl9LGFkZEJhY2s6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWRkKG51bGw9PWU/dGhpcy5wcmV2T2JqZWN0OnRoaXMucHJldk9iamVjdC5maWx0ZXIoZSkpfX0pLGNlLmVhY2goe3BhcmVudDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7cmV0dXJuIHQmJjExIT09dC5ub2RlVHlwZT90Om51bGx9LHBhcmVudHM6ZnVuY3Rpb24oZSl7cmV0dXJuIGQoZSxcInBhcmVudE5vZGVcIil9LHBhcmVudHNVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGQoZSxcInBhcmVudE5vZGVcIixuKX0sbmV4dDpmdW5jdGlvbihlKXtyZXR1cm4gQShlLFwibmV4dFNpYmxpbmdcIil9LHByZXY6ZnVuY3Rpb24oZSl7cmV0dXJuIEEoZSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dEFsbDpmdW5jdGlvbihlKXtyZXR1cm4gZChlLFwibmV4dFNpYmxpbmdcIil9LHByZXZBbGw6ZnVuY3Rpb24oZSl7cmV0dXJuIGQoZSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dFVudGlsOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZChlLFwibmV4dFNpYmxpbmdcIixuKX0scHJldlVudGlsOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZChlLFwicHJldmlvdXNTaWJsaW5nXCIsbil9LHNpYmxpbmdzOmZ1bmN0aW9uKGUpe3JldHVybiBoKChlLnBhcmVudE5vZGV8fHt9KS5maXJzdENoaWxkLGUpfSxjaGlsZHJlbjpmdW5jdGlvbihlKXtyZXR1cm4gaChlLmZpcnN0Q2hpbGQpfSxjb250ZW50czpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZS5jb250ZW50RG9jdW1lbnQmJnIoZS5jb250ZW50RG9jdW1lbnQpP2UuY29udGVudERvY3VtZW50OihmZShlLFwidGVtcGxhdGVcIikmJihlPWUuY29udGVudHx8ZSksY2UubWVyZ2UoW10sZS5jaGlsZE5vZGVzKSl9fSxmdW5jdGlvbihyLGkpe2NlLmZuW3JdPWZ1bmN0aW9uKGUsdCl7dmFyIG49Y2UubWFwKHRoaXMsaSxlKTtyZXR1cm5cIlVudGlsXCIhPT1yLnNsaWNlKC01KSYmKHQ9ZSksdCYmXCJzdHJpbmdcIj09dHlwZW9mIHQmJihuPWNlLmZpbHRlcih0LG4pKSwxPHRoaXMubGVuZ3RoJiYoaltyXXx8Y2UudW5pcXVlU29ydChuKSxFLnRlc3QocikmJm4ucmV2ZXJzZSgpKSx0aGlzLnB1c2hTdGFjayhuKX19KTt2YXIgRD0vW15cXHgyMFxcdFxcclxcblxcZl0rL2c7ZnVuY3Rpb24gTihlKXtyZXR1cm4gZX1mdW5jdGlvbiBxKGUpe3Rocm93IGV9ZnVuY3Rpb24gTChlLHQsbixyKXt2YXIgaTt0cnl7ZSYmdihpPWUucHJvbWlzZSk/aS5jYWxsKGUpLmRvbmUodCkuZmFpbChuKTplJiZ2KGk9ZS50aGVuKT9pLmNhbGwoZSx0LG4pOnQuYXBwbHkodm9pZCAwLFtlXS5zbGljZShyKSl9Y2F0Y2goZSl7bi5hcHBseSh2b2lkIDAsW2VdKX19Y2UuQ2FsbGJhY2tzPWZ1bmN0aW9uKHIpe3ZhciBlLG47cj1cInN0cmluZ1wiPT10eXBlb2Ygcj8oZT1yLG49e30sY2UuZWFjaChlLm1hdGNoKEQpfHxbXSxmdW5jdGlvbihlLHQpe25bdF09ITB9KSxuKTpjZS5leHRlbmQoe30scik7dmFyIGksdCxvLGEscz1bXSx1PVtdLGw9LTEsYz1mdW5jdGlvbigpe2ZvcihhPWF8fHIub25jZSxvPWk9ITA7dS5sZW5ndGg7bD0tMSl7dD11LnNoaWZ0KCk7d2hpbGUoKytsPHMubGVuZ3RoKSExPT09c1tsXS5hcHBseSh0WzBdLHRbMV0pJiZyLnN0b3BPbkZhbHNlJiYobD1zLmxlbmd0aCx0PSExKX1yLm1lbW9yeXx8KHQ9ITEpLGk9ITEsYSYmKHM9dD9bXTpcIlwiKX0sZj17YWRkOmZ1bmN0aW9uKCl7cmV0dXJuIHMmJih0JiYhaSYmKGw9cy5sZW5ndGgtMSx1LnB1c2godCkpLGZ1bmN0aW9uIG4oZSl7Y2UuZWFjaChlLGZ1bmN0aW9uKGUsdCl7dih0KT9yLnVuaXF1ZSYmZi5oYXModCl8fHMucHVzaCh0KTp0JiZ0Lmxlbmd0aCYmXCJzdHJpbmdcIiE9PXgodCkmJm4odCl9KX0oYXJndW1lbnRzKSx0JiYhaSYmYygpKSx0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gY2UuZWFjaChhcmd1bWVudHMsZnVuY3Rpb24oZSx0KXt2YXIgbjt3aGlsZSgtMTwobj1jZS5pbkFycmF5KHQscyxuKSkpcy5zcGxpY2UobiwxKSxuPD1sJiZsLS19KSx0aGlzfSxoYXM6ZnVuY3Rpb24oZSl7cmV0dXJuIGU/LTE8Y2UuaW5BcnJheShlLHMpOjA8cy5sZW5ndGh9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHMmJihzPVtdKSx0aGlzfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGE9dT1bXSxzPXQ9XCJcIix0aGlzfSxkaXNhYmxlZDpmdW5jdGlvbigpe3JldHVybiFzfSxsb2NrOmZ1bmN0aW9uKCl7cmV0dXJuIGE9dT1bXSx0fHxpfHwocz10PVwiXCIpLHRoaXN9LGxvY2tlZDpmdW5jdGlvbigpe3JldHVybiEhYX0sZmlyZVdpdGg6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYXx8KHQ9W2UsKHQ9dHx8W10pLnNsaWNlP3Quc2xpY2UoKTp0XSx1LnB1c2godCksaXx8YygpKSx0aGlzfSxmaXJlOmZ1bmN0aW9uKCl7cmV0dXJuIGYuZmlyZVdpdGgodGhpcyxhcmd1bWVudHMpLHRoaXN9LGZpcmVkOmZ1bmN0aW9uKCl7cmV0dXJuISFvfX07cmV0dXJuIGZ9LGNlLmV4dGVuZCh7RGVmZXJyZWQ6ZnVuY3Rpb24oZSl7dmFyIG89W1tcIm5vdGlmeVwiLFwicHJvZ3Jlc3NcIixjZS5DYWxsYmFja3MoXCJtZW1vcnlcIiksY2UuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLDJdLFtcInJlc29sdmVcIixcImRvbmVcIixjZS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxjZS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwwLFwicmVzb2x2ZWRcIl0sW1wicmVqZWN0XCIsXCJmYWlsXCIsY2UuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksY2UuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksMSxcInJlamVjdGVkXCJdXSxpPVwicGVuZGluZ1wiLGE9e3N0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIGl9LGFsd2F5czpmdW5jdGlvbigpe3JldHVybiBzLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyksdGhpc30sXCJjYXRjaFwiOmZ1bmN0aW9uKGUpe3JldHVybiBhLnRoZW4obnVsbCxlKX0scGlwZTpmdW5jdGlvbigpe3ZhciBpPWFyZ3VtZW50cztyZXR1cm4gY2UuRGVmZXJyZWQoZnVuY3Rpb24ocil7Y2UuZWFjaChvLGZ1bmN0aW9uKGUsdCl7dmFyIG49dihpW3RbNF1dKSYmaVt0WzRdXTtzW3RbMV1dKGZ1bmN0aW9uKCl7dmFyIGU9biYmbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZSYmdihlLnByb21pc2UpP2UucHJvbWlzZSgpLnByb2dyZXNzKHIubm90aWZ5KS5kb25lKHIucmVzb2x2ZSkuZmFpbChyLnJlamVjdCk6clt0WzBdK1wiV2l0aFwiXSh0aGlzLG4/W2VdOmFyZ3VtZW50cyl9KX0pLGk9bnVsbH0pLnByb21pc2UoKX0sdGhlbjpmdW5jdGlvbih0LG4scil7dmFyIHU9MDtmdW5jdGlvbiBsKGksbyxhLHMpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXMscj1hcmd1bWVudHMsZT1mdW5jdGlvbigpe3ZhciBlLHQ7aWYoIShpPHUpKXtpZigoZT1hLmFwcGx5KG4scikpPT09by5wcm9taXNlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiKTt0PWUmJihcIm9iamVjdFwiPT10eXBlb2YgZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgZSkmJmUudGhlbix2KHQpP3M/dC5jYWxsKGUsbCh1LG8sTixzKSxsKHUsbyxxLHMpKToodSsrLHQuY2FsbChlLGwodSxvLE4scyksbCh1LG8scSxzKSxsKHUsbyxOLG8ubm90aWZ5V2l0aCkpKTooYSE9PU4mJihuPXZvaWQgMCxyPVtlXSksKHN8fG8ucmVzb2x2ZVdpdGgpKG4scikpfX0sdD1zP2U6ZnVuY3Rpb24oKXt0cnl7ZSgpfWNhdGNoKGUpe2NlLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2smJmNlLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soZSx0LmVycm9yKSx1PD1pKzEmJihhIT09cSYmKG49dm9pZCAwLHI9W2VdKSxvLnJlamVjdFdpdGgobixyKSl9fTtpP3QoKTooY2UuRGVmZXJyZWQuZ2V0RXJyb3JIb29rP3QuZXJyb3I9Y2UuRGVmZXJyZWQuZ2V0RXJyb3JIb29rKCk6Y2UuRGVmZXJyZWQuZ2V0U3RhY2tIb29rJiYodC5lcnJvcj1jZS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKSksaWUuc2V0VGltZW91dCh0KSl9fXJldHVybiBjZS5EZWZlcnJlZChmdW5jdGlvbihlKXtvWzBdWzNdLmFkZChsKDAsZSx2KHIpP3I6TixlLm5vdGlmeVdpdGgpKSxvWzFdWzNdLmFkZChsKDAsZSx2KHQpP3Q6TikpLG9bMl1bM10uYWRkKGwoMCxlLHYobik/bjpxKSl9KS5wcm9taXNlKCl9LHByb21pc2U6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWU/Y2UuZXh0ZW5kKGUsYSk6YX19LHM9e307cmV0dXJuIGNlLmVhY2gobyxmdW5jdGlvbihlLHQpe3ZhciBuPXRbMl0scj10WzVdO2FbdFsxXV09bi5hZGQsciYmbi5hZGQoZnVuY3Rpb24oKXtpPXJ9LG9bMy1lXVsyXS5kaXNhYmxlLG9bMy1lXVszXS5kaXNhYmxlLG9bMF1bMl0ubG9jayxvWzBdWzNdLmxvY2spLG4uYWRkKHRbM10uZmlyZSksc1t0WzBdXT1mdW5jdGlvbigpe3JldHVybiBzW3RbMF0rXCJXaXRoXCJdKHRoaXM9PT1zP3ZvaWQgMDp0aGlzLGFyZ3VtZW50cyksdGhpc30sc1t0WzBdK1wiV2l0aFwiXT1uLmZpcmVXaXRofSksYS5wcm9taXNlKHMpLGUmJmUuY2FsbChzLHMpLHN9LHdoZW46ZnVuY3Rpb24oZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aCx0PW4scj1BcnJheSh0KSxpPWFlLmNhbGwoYXJndW1lbnRzKSxvPWNlLkRlZmVycmVkKCksYT1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7clt0XT10aGlzLGlbdF09MTxhcmd1bWVudHMubGVuZ3RoP2FlLmNhbGwoYXJndW1lbnRzKTplLC0tbnx8by5yZXNvbHZlV2l0aChyLGkpfX07aWYobjw9MSYmKEwoZSxvLmRvbmUoYSh0KSkucmVzb2x2ZSxvLnJlamVjdCwhbiksXCJwZW5kaW5nXCI9PT1vLnN0YXRlKCl8fHYoaVt0XSYmaVt0XS50aGVuKSkpcmV0dXJuIG8udGhlbigpO3doaWxlKHQtLSlMKGlbdF0sYSh0KSxvLnJlamVjdCk7cmV0dXJuIG8ucHJvbWlzZSgpfX0pO3ZhciBIPS9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO2NlLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2s9ZnVuY3Rpb24oZSx0KXtpZS5jb25zb2xlJiZpZS5jb25zb2xlLndhcm4mJmUmJkgudGVzdChlLm5hbWUpJiZpZS5jb25zb2xlLndhcm4oXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIitlLm1lc3NhZ2UsZS5zdGFjayx0KX0sY2UucmVhZHlFeGNlcHRpb249ZnVuY3Rpb24oZSl7aWUuc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGV9KX07dmFyIE89Y2UuRGVmZXJyZWQoKTtmdW5jdGlvbiBQKCl7Qy5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLFApLGllLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsUCksY2UucmVhZHkoKX1jZS5mbi5yZWFkeT1mdW5jdGlvbihlKXtyZXR1cm4gTy50aGVuKGUpW1wiY2F0Y2hcIl0oZnVuY3Rpb24oZSl7Y2UucmVhZHlFeGNlcHRpb24oZSl9KSx0aGlzfSxjZS5leHRlbmQoe2lzUmVhZHk6ITEscmVhZHlXYWl0OjEscmVhZHk6ZnVuY3Rpb24oZSl7KCEwPT09ZT8tLWNlLnJlYWR5V2FpdDpjZS5pc1JlYWR5KXx8KGNlLmlzUmVhZHk9ITApIT09ZSYmMDwtLWNlLnJlYWR5V2FpdHx8Ty5yZXNvbHZlV2l0aChDLFtjZV0pfX0pLGNlLnJlYWR5LnRoZW49Ty50aGVuLFwiY29tcGxldGVcIj09PUMucmVhZHlTdGF0ZXx8XCJsb2FkaW5nXCIhPT1DLnJlYWR5U3RhdGUmJiFDLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbD9pZS5zZXRUaW1lb3V0KGNlLnJlYWR5KTooQy5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLFApLGllLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsUCkpO3ZhciBNPWZ1bmN0aW9uKGUsdCxuLHIsaSxvLGEpe3ZhciBzPTAsdT1lLmxlbmd0aCxsPW51bGw9PW47aWYoXCJvYmplY3RcIj09PXgobikpZm9yKHMgaW4gaT0hMCxuKU0oZSx0LHMsbltzXSwhMCxvLGEpO2Vsc2UgaWYodm9pZCAwIT09ciYmKGk9ITAsdihyKXx8KGE9ITApLGwmJihhPyh0LmNhbGwoZSxyKSx0PW51bGwpOihsPXQsdD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGwuY2FsbChjZShlKSxuKX0pKSx0KSlmb3IoO3M8dTtzKyspdChlW3NdLG4sYT9yOnIuY2FsbChlW3NdLHMsdChlW3NdLG4pKSk7cmV0dXJuIGk/ZTpsP3QuY2FsbChlKTp1P3QoZVswXSxuKTpvfSxSPS9eLW1zLS8sST0vLShbYS16XSkvZztmdW5jdGlvbiBXKGUsdCl7cmV0dXJuIHQudG9VcHBlckNhc2UoKX1mdW5jdGlvbiBGKGUpe3JldHVybiBlLnJlcGxhY2UoUixcIm1zLVwiKS5yZXBsYWNlKEksVyl9dmFyICQ9ZnVuY3Rpb24oZSl7cmV0dXJuIDE9PT1lLm5vZGVUeXBlfHw5PT09ZS5ub2RlVHlwZXx8IStlLm5vZGVUeXBlfTtmdW5jdGlvbiBCKCl7dGhpcy5leHBhbmRvPWNlLmV4cGFuZG8rQi51aWQrK31CLnVpZD0xLEIucHJvdG90eXBlPXtjYWNoZTpmdW5jdGlvbihlKXt2YXIgdD1lW3RoaXMuZXhwYW5kb107cmV0dXJuIHR8fCh0PXt9LCQoZSkmJihlLm5vZGVUeXBlP2VbdGhpcy5leHBhbmRvXT10Ok9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHRoaXMuZXhwYW5kbyx7dmFsdWU6dCxjb25maWd1cmFibGU6ITB9KSkpLHR9LHNldDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaT10aGlzLmNhY2hlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KWlbRih0KV09bjtlbHNlIGZvcihyIGluIHQpaVtGKHIpXT10W3JdO3JldHVybiBpfSxnZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dD90aGlzLmNhY2hlKGUpOmVbdGhpcy5leHBhbmRvXSYmZVt0aGlzLmV4cGFuZG9dW0YodCldfSxhY2Nlc3M6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2b2lkIDA9PT10fHx0JiZcInN0cmluZ1wiPT10eXBlb2YgdCYmdm9pZCAwPT09bj90aGlzLmdldChlLHQpOih0aGlzLnNldChlLHQsbiksdm9pZCAwIT09bj9uOnQpfSxyZW1vdmU6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPWVbdGhpcy5leHBhbmRvXTtpZih2b2lkIDAhPT1yKXtpZih2b2lkIDAhPT10KXtuPSh0PUFycmF5LmlzQXJyYXkodCk/dC5tYXAoRik6KHQ9Rih0KSlpbiByP1t0XTp0Lm1hdGNoKEQpfHxbXSkubGVuZ3RoO3doaWxlKG4tLSlkZWxldGUgclt0W25dXX0odm9pZCAwPT09dHx8Y2UuaXNFbXB0eU9iamVjdChyKSkmJihlLm5vZGVUeXBlP2VbdGhpcy5leHBhbmRvXT12b2lkIDA6ZGVsZXRlIGVbdGhpcy5leHBhbmRvXSl9fSxoYXNEYXRhOmZ1bmN0aW9uKGUpe3ZhciB0PWVbdGhpcy5leHBhbmRvXTtyZXR1cm4gdm9pZCAwIT09dCYmIWNlLmlzRW1wdHlPYmplY3QodCl9fTt2YXIgXz1uZXcgQix6PW5ldyBCLFg9L14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFU9L1tBLVpdL2c7ZnVuY3Rpb24gVihlLHQsbil7dmFyIHIsaTtpZih2b2lkIDA9PT1uJiYxPT09ZS5ub2RlVHlwZSlpZihyPVwiZGF0YS1cIit0LnJlcGxhY2UoVSxcIi0kJlwiKS50b0xvd2VyQ2FzZSgpLFwic3RyaW5nXCI9PXR5cGVvZihuPWUuZ2V0QXR0cmlidXRlKHIpKSl7dHJ5e249XCJ0cnVlXCI9PT0oaT1uKXx8XCJmYWxzZVwiIT09aSYmKFwibnVsbFwiPT09aT9udWxsOmk9PT0raStcIlwiPytpOlgudGVzdChpKT9KU09OLnBhcnNlKGkpOmkpfWNhdGNoKGUpe316LnNldChlLHQsbil9ZWxzZSBuPXZvaWQgMDtyZXR1cm4gbn1jZS5leHRlbmQoe2hhc0RhdGE6ZnVuY3Rpb24oZSl7cmV0dXJuIHouaGFzRGF0YShlKXx8Xy5oYXNEYXRhKGUpfSxkYXRhOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gei5hY2Nlc3MoZSx0LG4pfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGUsdCl7ei5yZW1vdmUoZSx0KX0sX2RhdGE6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBfLmFjY2VzcyhlLHQsbil9LF9yZW1vdmVEYXRhOmZ1bmN0aW9uKGUsdCl7Xy5yZW1vdmUoZSx0KX19KSxjZS5mbi5leHRlbmQoe2RhdGE6ZnVuY3Rpb24obixlKXt2YXIgdCxyLGksbz10aGlzWzBdLGE9byYmby5hdHRyaWJ1dGVzO2lmKHZvaWQgMD09PW4pe2lmKHRoaXMubGVuZ3RoJiYoaT16LmdldChvKSwxPT09by5ub2RlVHlwZSYmIV8uZ2V0KG8sXCJoYXNEYXRhQXR0cnNcIikpKXt0PWEubGVuZ3RoO3doaWxlKHQtLSlhW3RdJiYwPT09KHI9YVt0XS5uYW1lKS5pbmRleE9mKFwiZGF0YS1cIikmJihyPUYoci5zbGljZSg1KSksVihvLHIsaVtyXSkpO18uc2V0KG8sXCJoYXNEYXRhQXR0cnNcIiwhMCl9cmV0dXJuIGl9cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIG4/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7ei5zZXQodGhpcyxuKX0pOk0odGhpcyxmdW5jdGlvbihlKXt2YXIgdDtpZihvJiZ2b2lkIDA9PT1lKXJldHVybiB2b2lkIDAhPT0odD16LmdldChvLG4pKT90OnZvaWQgMCE9PSh0PVYobyxuKSk/dDp2b2lkIDA7dGhpcy5lYWNoKGZ1bmN0aW9uKCl7ei5zZXQodGhpcyxuLGUpfSl9LG51bGwsZSwxPGFyZ3VtZW50cy5sZW5ndGgsbnVsbCwhMCl9LHJlbW92ZURhdGE6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3oucmVtb3ZlKHRoaXMsZSl9KX19KSxjZS5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtpZihlKXJldHVybiB0PSh0fHxcImZ4XCIpK1wicXVldWVcIixyPV8uZ2V0KGUsdCksbiYmKCFyfHxBcnJheS5pc0FycmF5KG4pP3I9Xy5hY2Nlc3MoZSx0LGNlLm1ha2VBcnJheShuKSk6ci5wdXNoKG4pKSxyfHxbXX0sZGVxdWV1ZTpmdW5jdGlvbihlLHQpe3Q9dHx8XCJmeFwiO3ZhciBuPWNlLnF1ZXVlKGUsdCkscj1uLmxlbmd0aCxpPW4uc2hpZnQoKSxvPWNlLl9xdWV1ZUhvb2tzKGUsdCk7XCJpbnByb2dyZXNzXCI9PT1pJiYoaT1uLnNoaWZ0KCksci0tKSxpJiYoXCJmeFwiPT09dCYmbi51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKSxkZWxldGUgby5zdG9wLGkuY2FsbChlLGZ1bmN0aW9uKCl7Y2UuZGVxdWV1ZShlLHQpfSxvKSksIXImJm8mJm8uZW1wdHkuZmlyZSgpfSxfcXVldWVIb29rczpmdW5jdGlvbihlLHQpe3ZhciBuPXQrXCJxdWV1ZUhvb2tzXCI7cmV0dXJuIF8uZ2V0KGUsbil8fF8uYWNjZXNzKGUsbix7ZW1wdHk6Y2UuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCl7Xy5yZW1vdmUoZSxbdCtcInF1ZXVlXCIsbl0pfSl9KX19KSxjZS5mbi5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKHQsbil7dmFyIGU9MjtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgdCYmKG49dCx0PVwiZnhcIixlLS0pLGFyZ3VtZW50cy5sZW5ndGg8ZT9jZS5xdWV1ZSh0aGlzWzBdLHQpOnZvaWQgMD09PW4/dGhpczp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT1jZS5xdWV1ZSh0aGlzLHQsbik7Y2UuX3F1ZXVlSG9va3ModGhpcyx0KSxcImZ4XCI9PT10JiZcImlucHJvZ3Jlc3NcIiE9PWVbMF0mJmNlLmRlcXVldWUodGhpcyx0KX0pfSxkZXF1ZXVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtjZS5kZXF1ZXVlKHRoaXMsZSl9KX0sY2xlYXJRdWV1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5xdWV1ZShlfHxcImZ4XCIsW10pfSxwcm9taXNlOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj0xLGk9Y2UuRGVmZXJyZWQoKSxvPXRoaXMsYT10aGlzLmxlbmd0aCxzPWZ1bmN0aW9uKCl7LS1yfHxpLnJlc29sdmVXaXRoKG8sW29dKX07XCJzdHJpbmdcIiE9dHlwZW9mIGUmJih0PWUsZT12b2lkIDApLGU9ZXx8XCJmeFwiO3doaWxlKGEtLSkobj1fLmdldChvW2FdLGUrXCJxdWV1ZUhvb2tzXCIpKSYmbi5lbXB0eSYmKHIrKyxuLmVtcHR5LmFkZChzKSk7cmV0dXJuIHMoKSxpLnByb21pc2UodCl9fSk7dmFyIEc9L1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlLFk9bmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIrRytcIikoW2EteiVdKikkXCIsXCJpXCIpLFE9W1wiVG9wXCIsXCJSaWdodFwiLFwiQm90dG9tXCIsXCJMZWZ0XCJdLEo9Qy5kb2N1bWVudEVsZW1lbnQsSz1mdW5jdGlvbihlKXtyZXR1cm4gY2UuY29udGFpbnMoZS5vd25lckRvY3VtZW50LGUpfSxaPXtjb21wb3NlZDohMH07Si5nZXRSb290Tm9kZSYmKEs9ZnVuY3Rpb24oZSl7cmV0dXJuIGNlLmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCxlKXx8ZS5nZXRSb290Tm9kZShaKT09PWUub3duZXJEb2N1bWVudH0pO3ZhciBlZT1mdW5jdGlvbihlLHQpe3JldHVyblwibm9uZVwiPT09KGU9dHx8ZSkuc3R5bGUuZGlzcGxheXx8XCJcIj09PWUuc3R5bGUuZGlzcGxheSYmSyhlKSYmXCJub25lXCI9PT1jZS5jc3MoZSxcImRpc3BsYXlcIil9O2Z1bmN0aW9uIHRlKGUsdCxuLHIpe3ZhciBpLG8sYT0yMCxzPXI/ZnVuY3Rpb24oKXtyZXR1cm4gci5jdXIoKX06ZnVuY3Rpb24oKXtyZXR1cm4gY2UuY3NzKGUsdCxcIlwiKX0sdT1zKCksbD1uJiZuWzNdfHwoY2UuY3NzTnVtYmVyW3RdP1wiXCI6XCJweFwiKSxjPWUubm9kZVR5cGUmJihjZS5jc3NOdW1iZXJbdF18fFwicHhcIiE9PWwmJit1KSYmWS5leGVjKGNlLmNzcyhlLHQpKTtpZihjJiZjWzNdIT09bCl7dS89MixsPWx8fGNbM10sYz0rdXx8MTt3aGlsZShhLS0pY2Uuc3R5bGUoZSx0LGMrbCksKDEtbykqKDEtKG89cygpL3V8fC41KSk8PTAmJihhPTApLGMvPW87Yyo9MixjZS5zdHlsZShlLHQsYytsKSxuPW58fFtdfXJldHVybiBuJiYoYz0rY3x8K3V8fDAsaT1uWzFdP2MrKG5bMV0rMSkqblsyXTorblsyXSxyJiYoci51bml0PWwsci5zdGFydD1jLHIuZW5kPWkpKSxpfXZhciBuZT17fTtmdW5jdGlvbiByZShlLHQpe2Zvcih2YXIgbixyLGksbyxhLHMsdSxsPVtdLGM9MCxmPWUubGVuZ3RoO2M8ZjtjKyspKHI9ZVtjXSkuc3R5bGUmJihuPXIuc3R5bGUuZGlzcGxheSx0PyhcIm5vbmVcIj09PW4mJihsW2NdPV8uZ2V0KHIsXCJkaXNwbGF5XCIpfHxudWxsLGxbY118fChyLnN0eWxlLmRpc3BsYXk9XCJcIikpLFwiXCI9PT1yLnN0eWxlLmRpc3BsYXkmJmVlKHIpJiYobFtjXT0odT1hPW89dm9pZCAwLGE9KGk9cikub3duZXJEb2N1bWVudCxzPWkubm9kZU5hbWUsKHU9bmVbc10pfHwobz1hLmJvZHkuYXBwZW5kQ2hpbGQoYS5jcmVhdGVFbGVtZW50KHMpKSx1PWNlLmNzcyhvLFwiZGlzcGxheVwiKSxvLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobyksXCJub25lXCI9PT11JiYodT1cImJsb2NrXCIpLG5lW3NdPXUpKSkpOlwibm9uZVwiIT09biYmKGxbY109XCJub25lXCIsXy5zZXQocixcImRpc3BsYXlcIixuKSkpO2ZvcihjPTA7YzxmO2MrKyludWxsIT1sW2NdJiYoZVtjXS5zdHlsZS5kaXNwbGF5PWxbY10pO3JldHVybiBlfWNlLmZuLmV4dGVuZCh7c2hvdzpmdW5jdGlvbigpe3JldHVybiByZSh0aGlzLCEwKX0saGlkZTpmdW5jdGlvbigpe3JldHVybiByZSh0aGlzKX0sdG9nZ2xlOmZ1bmN0aW9uKGUpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgZT9lP3RoaXMuc2hvdygpOnRoaXMuaGlkZSgpOnRoaXMuZWFjaChmdW5jdGlvbigpe2VlKHRoaXMpP2NlKHRoaXMpLnNob3coKTpjZSh0aGlzKS5oaWRlKCl9KX19KTt2YXIgeGUsYmUsd2U9L14oPzpjaGVja2JveHxyYWRpbykkL2ksVGU9LzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pLENlPS9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2k7eGU9Qy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkuYXBwZW5kQ2hpbGQoQy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwoYmU9Qy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIixcInJhZGlvXCIpLGJlLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIixcImNoZWNrZWRcIiksYmUuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwidFwiKSx4ZS5hcHBlbmRDaGlsZChiZSksbGUuY2hlY2tDbG9uZT14ZS5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQseGUuaW5uZXJIVE1MPVwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiLGxlLm5vQ2xvbmVDaGVja2VkPSEheGUuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlLHhlLmlubmVySFRNTD1cIjxvcHRpb24+PC9vcHRpb24+XCIsbGUub3B0aW9uPSEheGUubGFzdENoaWxkO3ZhciBrZT17dGhlYWQ6WzEsXCI8dGFibGU+XCIsXCI8L3RhYmxlPlwiXSxjb2w6WzIsXCI8dGFibGU+PGNvbGdyb3VwPlwiLFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSx0cjpbMixcIjx0YWJsZT48dGJvZHk+XCIsXCI8L3Rib2R5PjwvdGFibGU+XCJdLHRkOlszLFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sX2RlZmF1bHQ6WzAsXCJcIixcIlwiXX07ZnVuY3Rpb24gU2UoZSx0KXt2YXIgbjtyZXR1cm4gbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZT9lLmdldEVsZW1lbnRzQnlUYWdOYW1lKHR8fFwiKlwiKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZS5xdWVyeVNlbGVjdG9yQWxsP2UucXVlcnlTZWxlY3RvckFsbCh0fHxcIipcIik6W10sdm9pZCAwPT09dHx8dCYmZmUoZSx0KT9jZS5tZXJnZShbZV0sbik6bn1mdW5jdGlvbiBFZShlLHQpe2Zvcih2YXIgbj0wLHI9ZS5sZW5ndGg7bjxyO24rKylfLnNldChlW25dLFwiZ2xvYmFsRXZhbFwiLCF0fHxfLmdldCh0W25dLFwiZ2xvYmFsRXZhbFwiKSl9a2UudGJvZHk9a2UudGZvb3Q9a2UuY29sZ3JvdXA9a2UuY2FwdGlvbj1rZS50aGVhZCxrZS50aD1rZS50ZCxsZS5vcHRpb258fChrZS5vcHRncm91cD1rZS5vcHRpb249WzEsXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsXCI8L3NlbGVjdD5cIl0pO3ZhciBqZT0vPHwmIz9cXHcrOy87ZnVuY3Rpb24gQWUoZSx0LG4scixpKXtmb3IodmFyIG8sYSxzLHUsbCxjLGY9dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkscD1bXSxkPTAsaD1lLmxlbmd0aDtkPGg7ZCsrKWlmKChvPWVbZF0pfHwwPT09bylpZihcIm9iamVjdFwiPT09eChvKSljZS5tZXJnZShwLG8ubm9kZVR5cGU/W29dOm8pO2Vsc2UgaWYoamUudGVzdChvKSl7YT1hfHxmLmFwcGVuZENoaWxkKHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkscz0oVGUuZXhlYyhvKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCksdT1rZVtzXXx8a2UuX2RlZmF1bHQsYS5pbm5lckhUTUw9dVsxXStjZS5odG1sUHJlZmlsdGVyKG8pK3VbMl0sYz11WzBdO3doaWxlKGMtLSlhPWEubGFzdENoaWxkO2NlLm1lcmdlKHAsYS5jaGlsZE5vZGVzKSwoYT1mLmZpcnN0Q2hpbGQpLnRleHRDb250ZW50PVwiXCJ9ZWxzZSBwLnB1c2godC5jcmVhdGVUZXh0Tm9kZShvKSk7Zi50ZXh0Q29udGVudD1cIlwiLGQ9MDt3aGlsZShvPXBbZCsrXSlpZihyJiYtMTxjZS5pbkFycmF5KG8scikpaSYmaS5wdXNoKG8pO2Vsc2UgaWYobD1LKG8pLGE9U2UoZi5hcHBlbmRDaGlsZChvKSxcInNjcmlwdFwiKSxsJiZFZShhKSxuKXtjPTA7d2hpbGUobz1hW2MrK10pQ2UudGVzdChvLnR5cGV8fFwiXCIpJiZuLnB1c2gobyl9cmV0dXJuIGZ9dmFyIERlPS9eKFteLl0qKSg/OlxcLiguKyl8KS87ZnVuY3Rpb24gTmUoKXtyZXR1cm4hMH1mdW5jdGlvbiBxZSgpe3JldHVybiExfWZ1bmN0aW9uIExlKGUsdCxuLHIsaSxvKXt2YXIgYSxzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0KXtmb3IocyBpblwic3RyaW5nXCIhPXR5cGVvZiBuJiYocj1yfHxuLG49dm9pZCAwKSx0KUxlKGUscyxuLHIsdFtzXSxvKTtyZXR1cm4gZX1pZihudWxsPT1yJiZudWxsPT1pPyhpPW4scj1uPXZvaWQgMCk6bnVsbD09aSYmKFwic3RyaW5nXCI9PXR5cGVvZiBuPyhpPXIscj12b2lkIDApOihpPXIscj1uLG49dm9pZCAwKSksITE9PT1pKWk9cWU7ZWxzZSBpZighaSlyZXR1cm4gZTtyZXR1cm4gMT09PW8mJihhPWksKGk9ZnVuY3Rpb24oZSl7cmV0dXJuIGNlKCkub2ZmKGUpLGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfSkuZ3VpZD1hLmd1aWR8fChhLmd1aWQ9Y2UuZ3VpZCsrKSksZS5lYWNoKGZ1bmN0aW9uKCl7Y2UuZXZlbnQuYWRkKHRoaXMsdCxpLHIsbil9KX1mdW5jdGlvbiBIZShlLHIsdCl7dD8oXy5zZXQoZSxyLCExKSxjZS5ldmVudC5hZGQoZSxyLHtuYW1lc3BhY2U6ITEsaGFuZGxlcjpmdW5jdGlvbihlKXt2YXIgdCxuPV8uZ2V0KHRoaXMscik7aWYoMSZlLmlzVHJpZ2dlciYmdGhpc1tyXSl7aWYobikoY2UuZXZlbnQuc3BlY2lhbFtyXXx8e30pLmRlbGVnYXRlVHlwZSYmZS5zdG9wUHJvcGFnYXRpb24oKTtlbHNlIGlmKG49YWUuY2FsbChhcmd1bWVudHMpLF8uc2V0KHRoaXMscixuKSx0aGlzW3JdKCksdD1fLmdldCh0aGlzLHIpLF8uc2V0KHRoaXMsciwhMSksbiE9PXQpcmV0dXJuIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLHR9ZWxzZSBuJiYoXy5zZXQodGhpcyxyLGNlLmV2ZW50LnRyaWdnZXIoblswXSxuLnNsaWNlKDEpLHRoaXMpKSxlLnN0b3BQcm9wYWdhdGlvbigpLGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9TmUpfX0pKTp2b2lkIDA9PT1fLmdldChlLHIpJiZjZS5ldmVudC5hZGQoZSxyLE5lKX1jZS5ldmVudD17Z2xvYmFsOnt9LGFkZDpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvLGEscyx1LGwsYyxmLHAsZCxoLGcsdj1fLmdldCh0KTtpZigkKHQpKXtuLmhhbmRsZXImJihuPShvPW4pLmhhbmRsZXIsaT1vLnNlbGVjdG9yKSxpJiZjZS5maW5kLm1hdGNoZXNTZWxlY3RvcihKLGkpLG4uZ3VpZHx8KG4uZ3VpZD1jZS5ndWlkKyspLCh1PXYuZXZlbnRzKXx8KHU9di5ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSksKGE9di5oYW5kbGUpfHwoYT12LmhhbmRsZT1mdW5jdGlvbihlKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgY2UmJmNlLmV2ZW50LnRyaWdnZXJlZCE9PWUudHlwZT9jZS5ldmVudC5kaXNwYXRjaC5hcHBseSh0LGFyZ3VtZW50cyk6dm9pZCAwfSksbD0oZT0oZXx8XCJcIikubWF0Y2goRCl8fFtcIlwiXSkubGVuZ3RoO3doaWxlKGwtLSlkPWc9KHM9RGUuZXhlYyhlW2xdKXx8W10pWzFdLGg9KHNbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksZCYmKGY9Y2UuZXZlbnQuc3BlY2lhbFtkXXx8e30sZD0oaT9mLmRlbGVnYXRlVHlwZTpmLmJpbmRUeXBlKXx8ZCxmPWNlLmV2ZW50LnNwZWNpYWxbZF18fHt9LGM9Y2UuZXh0ZW5kKHt0eXBlOmQsb3JpZ1R5cGU6ZyxkYXRhOnIsaGFuZGxlcjpuLGd1aWQ6bi5ndWlkLHNlbGVjdG9yOmksbmVlZHNDb250ZXh0OmkmJmNlLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoaSksbmFtZXNwYWNlOmguam9pbihcIi5cIil9LG8pLChwPXVbZF0pfHwoKHA9dVtkXT1bXSkuZGVsZWdhdGVDb3VudD0wLGYuc2V0dXAmJiExIT09Zi5zZXR1cC5jYWxsKHQscixoLGEpfHx0LmFkZEV2ZW50TGlzdGVuZXImJnQuYWRkRXZlbnRMaXN0ZW5lcihkLGEpKSxmLmFkZCYmKGYuYWRkLmNhbGwodCxjKSxjLmhhbmRsZXIuZ3VpZHx8KGMuaGFuZGxlci5ndWlkPW4uZ3VpZCkpLGk/cC5zcGxpY2UocC5kZWxlZ2F0ZUNvdW50KyssMCxjKTpwLnB1c2goYyksY2UuZXZlbnQuZ2xvYmFsW2RdPSEwKX19LHJlbW92ZTpmdW5jdGlvbihlLHQsbixyLGkpe3ZhciBvLGEscyx1LGwsYyxmLHAsZCxoLGcsdj1fLmhhc0RhdGEoZSkmJl8uZ2V0KGUpO2lmKHYmJih1PXYuZXZlbnRzKSl7bD0odD0odHx8XCJcIikubWF0Y2goRCl8fFtcIlwiXSkubGVuZ3RoO3doaWxlKGwtLSlpZihkPWc9KHM9RGUuZXhlYyh0W2xdKXx8W10pWzFdLGg9KHNbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksZCl7Zj1jZS5ldmVudC5zcGVjaWFsW2RdfHx7fSxwPXVbZD0ocj9mLmRlbGVnYXRlVHlwZTpmLmJpbmRUeXBlKXx8ZF18fFtdLHM9c1syXSYmbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiK2guam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpLGE9bz1wLmxlbmd0aDt3aGlsZShvLS0pYz1wW29dLCFpJiZnIT09Yy5vcmlnVHlwZXx8biYmbi5ndWlkIT09Yy5ndWlkfHxzJiYhcy50ZXN0KGMubmFtZXNwYWNlKXx8ciYmciE9PWMuc2VsZWN0b3ImJihcIioqXCIhPT1yfHwhYy5zZWxlY3Rvcil8fChwLnNwbGljZShvLDEpLGMuc2VsZWN0b3ImJnAuZGVsZWdhdGVDb3VudC0tLGYucmVtb3ZlJiZmLnJlbW92ZS5jYWxsKGUsYykpO2EmJiFwLmxlbmd0aCYmKGYudGVhcmRvd24mJiExIT09Zi50ZWFyZG93bi5jYWxsKGUsaCx2LmhhbmRsZSl8fGNlLnJlbW92ZUV2ZW50KGUsZCx2LmhhbmRsZSksZGVsZXRlIHVbZF0pfWVsc2UgZm9yKGQgaW4gdSljZS5ldmVudC5yZW1vdmUoZSxkK3RbbF0sbixyLCEwKTtjZS5pc0VtcHR5T2JqZWN0KHUpJiZfLnJlbW92ZShlLFwiaGFuZGxlIGV2ZW50c1wiKX19LGRpc3BhdGNoOmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpLG8sYSxzPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSx1PWNlLmV2ZW50LmZpeChlKSxsPShfLmdldCh0aGlzLFwiZXZlbnRzXCIpfHxPYmplY3QuY3JlYXRlKG51bGwpKVt1LnR5cGVdfHxbXSxjPWNlLmV2ZW50LnNwZWNpYWxbdS50eXBlXXx8e307Zm9yKHNbMF09dSx0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKylzW3RdPWFyZ3VtZW50c1t0XTtpZih1LmRlbGVnYXRlVGFyZ2V0PXRoaXMsIWMucHJlRGlzcGF0Y2h8fCExIT09Yy5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsdSkpe2E9Y2UuZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLHUsbCksdD0wO3doaWxlKChpPWFbdCsrXSkmJiF1LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpe3UuY3VycmVudFRhcmdldD1pLmVsZW0sbj0wO3doaWxlKChvPWkuaGFuZGxlcnNbbisrXSkmJiF1LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpdS5ybmFtZXNwYWNlJiYhMSE9PW8ubmFtZXNwYWNlJiYhdS5ybmFtZXNwYWNlLnRlc3Qoby5uYW1lc3BhY2UpfHwodS5oYW5kbGVPYmo9byx1LmRhdGE9by5kYXRhLHZvaWQgMCE9PShyPSgoY2UuZXZlbnQuc3BlY2lhbFtvLm9yaWdUeXBlXXx8e30pLmhhbmRsZXx8by5oYW5kbGVyKS5hcHBseShpLmVsZW0scykpJiYhMT09PSh1LnJlc3VsdD1yKSYmKHUucHJldmVudERlZmF1bHQoKSx1LnN0b3BQcm9wYWdhdGlvbigpKSl9cmV0dXJuIGMucG9zdERpc3BhdGNoJiZjLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsdSksdS5yZXN1bHR9fSxoYW5kbGVyczpmdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxvLGEscz1bXSx1PXQuZGVsZWdhdGVDb3VudCxsPWUudGFyZ2V0O2lmKHUmJmwubm9kZVR5cGUmJiEoXCJjbGlja1wiPT09ZS50eXBlJiYxPD1lLmJ1dHRvbikpZm9yKDtsIT09dGhpcztsPWwucGFyZW50Tm9kZXx8dGhpcylpZigxPT09bC5ub2RlVHlwZSYmKFwiY2xpY2tcIiE9PWUudHlwZXx8ITAhPT1sLmRpc2FibGVkKSl7Zm9yKG89W10sYT17fSxuPTA7bjx1O24rKyl2b2lkIDA9PT1hW2k9KHI9dFtuXSkuc2VsZWN0b3IrXCIgXCJdJiYoYVtpXT1yLm5lZWRzQ29udGV4dD8tMTxjZShpLHRoaXMpLmluZGV4KGwpOmNlLmZpbmQoaSx0aGlzLG51bGwsW2xdKS5sZW5ndGgpLGFbaV0mJm8ucHVzaChyKTtvLmxlbmd0aCYmcy5wdXNoKHtlbGVtOmwsaGFuZGxlcnM6b30pfXJldHVybiBsPXRoaXMsdTx0Lmxlbmd0aCYmcy5wdXNoKHtlbGVtOmwsaGFuZGxlcnM6dC5zbGljZSh1KX0pLHN9LGFkZFByb3A6ZnVuY3Rpb24odCxlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoY2UuRXZlbnQucHJvdG90eXBlLHQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDp2KGUpP2Z1bmN0aW9uKCl7aWYodGhpcy5vcmlnaW5hbEV2ZW50KXJldHVybiBlKHRoaXMub3JpZ2luYWxFdmVudCl9OmZ1bmN0aW9uKCl7aWYodGhpcy5vcmlnaW5hbEV2ZW50KXJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbdF19LHNldDpmdW5jdGlvbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyx0LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSl9fSl9LGZpeDpmdW5jdGlvbihlKXtyZXR1cm4gZVtjZS5leHBhbmRvXT9lOm5ldyBjZS5FdmVudChlKX0sc3BlY2lhbDp7bG9hZDp7bm9CdWJibGU6ITB9LGNsaWNrOntzZXR1cDpmdW5jdGlvbihlKXt2YXIgdD10aGlzfHxlO3JldHVybiB3ZS50ZXN0KHQudHlwZSkmJnQuY2xpY2smJmZlKHQsXCJpbnB1dFwiKSYmSGUodCxcImNsaWNrXCIsITApLCExfSx0cmlnZ2VyOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXN8fGU7cmV0dXJuIHdlLnRlc3QodC50eXBlKSYmdC5jbGljayYmZmUodCxcImlucHV0XCIpJiZIZSh0LFwiY2xpY2tcIiksITB9LF9kZWZhdWx0OmZ1bmN0aW9uKGUpe3ZhciB0PWUudGFyZ2V0O3JldHVybiB3ZS50ZXN0KHQudHlwZSkmJnQuY2xpY2smJmZlKHQsXCJpbnB1dFwiKSYmXy5nZXQodCxcImNsaWNrXCIpfHxmZSh0LFwiYVwiKX19LGJlZm9yZXVubG9hZDp7cG9zdERpc3BhdGNoOmZ1bmN0aW9uKGUpe3ZvaWQgMCE9PWUucmVzdWx0JiZlLm9yaWdpbmFsRXZlbnQmJihlLm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWU9ZS5yZXN1bHQpfX19fSxjZS5yZW1vdmVFdmVudD1mdW5jdGlvbihlLHQsbil7ZS5yZW1vdmVFdmVudExpc3RlbmVyJiZlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxuKX0sY2UuRXZlbnQ9ZnVuY3Rpb24oZSx0KXtpZighKHRoaXMgaW5zdGFuY2VvZiBjZS5FdmVudCkpcmV0dXJuIG5ldyBjZS5FdmVudChlLHQpO2UmJmUudHlwZT8odGhpcy5vcmlnaW5hbEV2ZW50PWUsdGhpcy50eXBlPWUudHlwZSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1lLmRlZmF1bHRQcmV2ZW50ZWR8fHZvaWQgMD09PWUuZGVmYXVsdFByZXZlbnRlZCYmITE9PT1lLnJldHVyblZhbHVlP05lOnFlLHRoaXMudGFyZ2V0PWUudGFyZ2V0JiYzPT09ZS50YXJnZXQubm9kZVR5cGU/ZS50YXJnZXQucGFyZW50Tm9kZTplLnRhcmdldCx0aGlzLmN1cnJlbnRUYXJnZXQ9ZS5jdXJyZW50VGFyZ2V0LHRoaXMucmVsYXRlZFRhcmdldD1lLnJlbGF0ZWRUYXJnZXQpOnRoaXMudHlwZT1lLHQmJmNlLmV4dGVuZCh0aGlzLHQpLHRoaXMudGltZVN0YW1wPWUmJmUudGltZVN0YW1wfHxEYXRlLm5vdygpLHRoaXNbY2UuZXhwYW5kb109ITB9LGNlLkV2ZW50LnByb3RvdHlwZT17Y29uc3RydWN0b3I6Y2UuRXZlbnQsaXNEZWZhdWx0UHJldmVudGVkOnFlLGlzUHJvcGFnYXRpb25TdG9wcGVkOnFlLGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOnFlLGlzU2ltdWxhdGVkOiExLHByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPU5lLGUmJiF0aGlzLmlzU2ltdWxhdGVkJiZlLnByZXZlbnREZWZhdWx0KCl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBlPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPU5lLGUmJiF0aGlzLmlzU2ltdWxhdGVkJiZlLnN0b3BQcm9wYWdhdGlvbigpfSxzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD1OZSxlJiYhdGhpcy5pc1NpbXVsYXRlZCYmZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSx0aGlzLnN0b3BQcm9wYWdhdGlvbigpfX0sY2UuZWFjaCh7YWx0S2V5OiEwLGJ1YmJsZXM6ITAsY2FuY2VsYWJsZTohMCxjaGFuZ2VkVG91Y2hlczohMCxjdHJsS2V5OiEwLGRldGFpbDohMCxldmVudFBoYXNlOiEwLG1ldGFLZXk6ITAscGFnZVg6ITAscGFnZVk6ITAsc2hpZnRLZXk6ITAsdmlldzohMCxcImNoYXJcIjohMCxjb2RlOiEwLGNoYXJDb2RlOiEwLGtleTohMCxrZXlDb2RlOiEwLGJ1dHRvbjohMCxidXR0b25zOiEwLGNsaWVudFg6ITAsY2xpZW50WTohMCxvZmZzZXRYOiEwLG9mZnNldFk6ITAscG9pbnRlcklkOiEwLHBvaW50ZXJUeXBlOiEwLHNjcmVlblg6ITAsc2NyZWVuWTohMCx0YXJnZXRUb3VjaGVzOiEwLHRvRWxlbWVudDohMCx0b3VjaGVzOiEwLHdoaWNoOiEwfSxjZS5ldmVudC5hZGRQcm9wKSxjZS5lYWNoKHtmb2N1czpcImZvY3VzaW5cIixibHVyOlwiZm9jdXNvdXRcIn0sZnVuY3Rpb24ocixpKXtmdW5jdGlvbiBvKGUpe2lmKEMuZG9jdW1lbnRNb2RlKXt2YXIgdD1fLmdldCh0aGlzLFwiaGFuZGxlXCIpLG49Y2UuZXZlbnQuZml4KGUpO24udHlwZT1cImZvY3VzaW5cIj09PWUudHlwZT9cImZvY3VzXCI6XCJibHVyXCIsbi5pc1NpbXVsYXRlZD0hMCx0KGUpLG4udGFyZ2V0PT09bi5jdXJyZW50VGFyZ2V0JiZ0KG4pfWVsc2UgY2UuZXZlbnQuc2ltdWxhdGUoaSxlLnRhcmdldCxjZS5ldmVudC5maXgoZSkpfWNlLmV2ZW50LnNwZWNpYWxbcl09e3NldHVwOmZ1bmN0aW9uKCl7dmFyIGU7aWYoSGUodGhpcyxyLCEwKSwhQy5kb2N1bWVudE1vZGUpcmV0dXJuITE7KGU9Xy5nZXQodGhpcyxpKSl8fHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihpLG8pLF8uc2V0KHRoaXMsaSwoZXx8MCkrMSl9LHRyaWdnZXI6ZnVuY3Rpb24oKXtyZXR1cm4gSGUodGhpcyxyKSwhMH0sdGVhcmRvd246ZnVuY3Rpb24oKXt2YXIgZTtpZighQy5kb2N1bWVudE1vZGUpcmV0dXJuITE7KGU9Xy5nZXQodGhpcyxpKS0xKT9fLnNldCh0aGlzLGksZSk6KHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLG8pLF8ucmVtb3ZlKHRoaXMsaSkpfSxfZGVmYXVsdDpmdW5jdGlvbihlKXtyZXR1cm4gXy5nZXQoZS50YXJnZXQscil9LGRlbGVnYXRlVHlwZTppfSxjZS5ldmVudC5zcGVjaWFsW2ldPXtzZXR1cDpmdW5jdGlvbigpe3ZhciBlPXRoaXMub3duZXJEb2N1bWVudHx8dGhpcy5kb2N1bWVudHx8dGhpcyx0PUMuZG9jdW1lbnRNb2RlP3RoaXM6ZSxuPV8uZ2V0KHQsaSk7bnx8KEMuZG9jdW1lbnRNb2RlP3RoaXMuYWRkRXZlbnRMaXN0ZW5lcihpLG8pOmUuYWRkRXZlbnRMaXN0ZW5lcihyLG8sITApKSxfLnNldCh0LGksKG58fDApKzEpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3ZhciBlPXRoaXMub3duZXJEb2N1bWVudHx8dGhpcy5kb2N1bWVudHx8dGhpcyx0PUMuZG9jdW1lbnRNb2RlP3RoaXM6ZSxuPV8uZ2V0KHQsaSktMTtuP18uc2V0KHQsaSxuKTooQy5kb2N1bWVudE1vZGU/dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGksbyk6ZS5yZW1vdmVFdmVudExpc3RlbmVyKHIsbywhMCksXy5yZW1vdmUodCxpKSl9fX0pLGNlLmVhY2goe21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIixwb2ludGVyZW50ZXI6XCJwb2ludGVyb3ZlclwiLHBvaW50ZXJsZWF2ZTpcInBvaW50ZXJvdXRcIn0sZnVuY3Rpb24oZSxpKXtjZS5ldmVudC5zcGVjaWFsW2VdPXtkZWxlZ2F0ZVR5cGU6aSxiaW5kVHlwZTppLGhhbmRsZTpmdW5jdGlvbihlKXt2YXIgdCxuPWUucmVsYXRlZFRhcmdldCxyPWUuaGFuZGxlT2JqO3JldHVybiBuJiYobj09PXRoaXN8fGNlLmNvbnRhaW5zKHRoaXMsbikpfHwoZS50eXBlPXIub3JpZ1R5cGUsdD1yLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGUudHlwZT1pKSx0fX19KSxjZS5mbi5leHRlbmQoe29uOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBMZSh0aGlzLGUsdCxuLHIpfSxvbmU6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIExlKHRoaXMsZSx0LG4sciwxKX0sb2ZmOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpO2lmKGUmJmUucHJldmVudERlZmF1bHQmJmUuaGFuZGxlT2JqKXJldHVybiByPWUuaGFuZGxlT2JqLGNlKGUuZGVsZWdhdGVUYXJnZXQpLm9mZihyLm5hbWVzcGFjZT9yLm9yaWdUeXBlK1wiLlwiK3IubmFtZXNwYWNlOnIub3JpZ1R5cGUsci5zZWxlY3RvcixyLmhhbmRsZXIpLHRoaXM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUpe2ZvcihpIGluIGUpdGhpcy5vZmYoaSx0LGVbaV0pO3JldHVybiB0aGlzfXJldHVybiExIT09dCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdHx8KG49dCx0PXZvaWQgMCksITE9PT1uJiYobj1xZSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Y2UuZXZlbnQucmVtb3ZlKHRoaXMsZSxuLHQpfSl9fSk7dmFyIE9lPS88c2NyaXB0fDxzdHlsZXw8bGluay9pLFBlPS9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksTWU9L15cXHMqPCFcXFtDREFUQVxcW3xcXF1cXF0+XFxzKiQvZztmdW5jdGlvbiBSZShlLHQpe3JldHVybiBmZShlLFwidGFibGVcIikmJmZlKDExIT09dC5ub2RlVHlwZT90OnQuZmlyc3RDaGlsZCxcInRyXCIpJiZjZShlKS5jaGlsZHJlbihcInRib2R5XCIpWzBdfHxlfWZ1bmN0aW9uIEllKGUpe3JldHVybiBlLnR5cGU9KG51bGwhPT1lLmdldEF0dHJpYnV0ZShcInR5cGVcIikpK1wiL1wiK2UudHlwZSxlfWZ1bmN0aW9uIFdlKGUpe3JldHVyblwidHJ1ZS9cIj09PShlLnR5cGV8fFwiXCIpLnNsaWNlKDAsNSk/ZS50eXBlPWUudHlwZS5zbGljZSg1KTplLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIiksZX1mdW5jdGlvbiBGZShlLHQpe3ZhciBuLHIsaSxvLGEscztpZigxPT09dC5ub2RlVHlwZSl7aWYoXy5oYXNEYXRhKGUpJiYocz1fLmdldChlKS5ldmVudHMpKWZvcihpIGluIF8ucmVtb3ZlKHQsXCJoYW5kbGUgZXZlbnRzXCIpLHMpZm9yKG49MCxyPXNbaV0ubGVuZ3RoO248cjtuKyspY2UuZXZlbnQuYWRkKHQsaSxzW2ldW25dKTt6Lmhhc0RhdGEoZSkmJihvPXouYWNjZXNzKGUpLGE9Y2UuZXh0ZW5kKHt9LG8pLHouc2V0KHQsYSkpfX1mdW5jdGlvbiAkZShuLHIsaSxvKXtyPWcocik7dmFyIGUsdCxhLHMsdSxsLGM9MCxmPW4ubGVuZ3RoLHA9Zi0xLGQ9clswXSxoPXYoZCk7aWYoaHx8MTxmJiZcInN0cmluZ1wiPT10eXBlb2YgZCYmIWxlLmNoZWNrQ2xvbmUmJlBlLnRlc3QoZCkpcmV0dXJuIG4uZWFjaChmdW5jdGlvbihlKXt2YXIgdD1uLmVxKGUpO2gmJihyWzBdPWQuY2FsbCh0aGlzLGUsdC5odG1sKCkpKSwkZSh0LHIsaSxvKX0pO2lmKGYmJih0PShlPUFlKHIsblswXS5vd25lckRvY3VtZW50LCExLG4sbykpLmZpcnN0Q2hpbGQsMT09PWUuY2hpbGROb2Rlcy5sZW5ndGgmJihlPXQpLHR8fG8pKXtmb3Iocz0oYT1jZS5tYXAoU2UoZSxcInNjcmlwdFwiKSxJZSkpLmxlbmd0aDtjPGY7YysrKXU9ZSxjIT09cCYmKHU9Y2UuY2xvbmUodSwhMCwhMCkscyYmY2UubWVyZ2UoYSxTZSh1LFwic2NyaXB0XCIpKSksaS5jYWxsKG5bY10sdSxjKTtpZihzKWZvcihsPWFbYS5sZW5ndGgtMV0ub3duZXJEb2N1bWVudCxjZS5tYXAoYSxXZSksYz0wO2M8cztjKyspdT1hW2NdLENlLnRlc3QodS50eXBlfHxcIlwiKSYmIV8uYWNjZXNzKHUsXCJnbG9iYWxFdmFsXCIpJiZjZS5jb250YWlucyhsLHUpJiYodS5zcmMmJlwibW9kdWxlXCIhPT0odS50eXBlfHxcIlwiKS50b0xvd2VyQ2FzZSgpP2NlLl9ldmFsVXJsJiYhdS5ub01vZHVsZSYmY2UuX2V2YWxVcmwodS5zcmMse25vbmNlOnUubm9uY2V8fHUuZ2V0QXR0cmlidXRlKFwibm9uY2VcIil9LGwpOm0odS50ZXh0Q29udGVudC5yZXBsYWNlKE1lLFwiXCIpLHUsbCkpfXJldHVybiBufWZ1bmN0aW9uIEJlKGUsdCxuKXtmb3IodmFyIHIsaT10P2NlLmZpbHRlcih0LGUpOmUsbz0wO251bGwhPShyPWlbb10pO28rKylufHwxIT09ci5ub2RlVHlwZXx8Y2UuY2xlYW5EYXRhKFNlKHIpKSxyLnBhcmVudE5vZGUmJihuJiZLKHIpJiZFZShTZShyLFwic2NyaXB0XCIpKSxyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocikpO3JldHVybiBlfWNlLmV4dGVuZCh7aHRtbFByZWZpbHRlcjpmdW5jdGlvbihlKXtyZXR1cm4gZX0sY2xvbmU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhLHMsdSxsLGM9ZS5jbG9uZU5vZGUoITApLGY9SyhlKTtpZighKGxlLm5vQ2xvbmVDaGVja2VkfHwxIT09ZS5ub2RlVHlwZSYmMTEhPT1lLm5vZGVUeXBlfHxjZS5pc1hNTERvYyhlKSkpZm9yKGE9U2UoYykscj0wLGk9KG89U2UoZSkpLmxlbmd0aDtyPGk7cisrKXM9b1tyXSx1PWFbcl0sdm9pZCAwLFwiaW5wdXRcIj09PShsPXUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkmJndlLnRlc3Qocy50eXBlKT91LmNoZWNrZWQ9cy5jaGVja2VkOlwiaW5wdXRcIiE9PWwmJlwidGV4dGFyZWFcIiE9PWx8fCh1LmRlZmF1bHRWYWx1ZT1zLmRlZmF1bHRWYWx1ZSk7aWYodClpZihuKWZvcihvPW98fFNlKGUpLGE9YXx8U2UoYykscj0wLGk9by5sZW5ndGg7cjxpO3IrKylGZShvW3JdLGFbcl0pO2Vsc2UgRmUoZSxjKTtyZXR1cm4gMDwoYT1TZShjLFwic2NyaXB0XCIpKS5sZW5ndGgmJkVlKGEsIWYmJlNlKGUsXCJzY3JpcHRcIikpLGN9LGNsZWFuRGF0YTpmdW5jdGlvbihlKXtmb3IodmFyIHQsbixyLGk9Y2UuZXZlbnQuc3BlY2lhbCxvPTA7dm9pZCAwIT09KG49ZVtvXSk7bysrKWlmKCQobikpe2lmKHQ9bltfLmV4cGFuZG9dKXtpZih0LmV2ZW50cylmb3IociBpbiB0LmV2ZW50cylpW3JdP2NlLmV2ZW50LnJlbW92ZShuLHIpOmNlLnJlbW92ZUV2ZW50KG4scix0LmhhbmRsZSk7bltfLmV4cGFuZG9dPXZvaWQgMH1uW3ouZXhwYW5kb10mJihuW3ouZXhwYW5kb109dm9pZCAwKX19fSksY2UuZm4uZXh0ZW5kKHtkZXRhY2g6ZnVuY3Rpb24oZSl7cmV0dXJuIEJlKHRoaXMsZSwhMCl9LHJlbW92ZTpmdW5jdGlvbihlKXtyZXR1cm4gQmUodGhpcyxlKX0sdGV4dDpmdW5jdGlvbihlKXtyZXR1cm4gTSh0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lP2NlLnRleHQodGhpcyk6dGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24oKXsxIT09dGhpcy5ub2RlVHlwZSYmMTEhPT10aGlzLm5vZGVUeXBlJiY5IT09dGhpcy5ub2RlVHlwZXx8KHRoaXMudGV4dENvbnRlbnQ9ZSl9KX0sbnVsbCxlLGFyZ3VtZW50cy5sZW5ndGgpfSxhcHBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gJGUodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oZSl7MSE9PXRoaXMubm9kZVR5cGUmJjExIT09dGhpcy5ub2RlVHlwZSYmOSE9PXRoaXMubm9kZVR5cGV8fFJlKHRoaXMsZSkuYXBwZW5kQ2hpbGQoZSl9KX0scHJlcGVuZDpmdW5jdGlvbigpe3JldHVybiAkZSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihlKXtpZigxPT09dGhpcy5ub2RlVHlwZXx8MTE9PT10aGlzLm5vZGVUeXBlfHw5PT09dGhpcy5ub2RlVHlwZSl7dmFyIHQ9UmUodGhpcyxlKTt0Lmluc2VydEJlZm9yZShlLHQuZmlyc3RDaGlsZCl9fSl9LGJlZm9yZTpmdW5jdGlvbigpe3JldHVybiAkZSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihlKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSx0aGlzKX0pfSxhZnRlcjpmdW5jdGlvbigpe3JldHVybiAkZSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihlKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSx0aGlzLm5leHRTaWJsaW5nKX0pfSxlbXB0eTpmdW5jdGlvbigpe2Zvcih2YXIgZSx0PTA7bnVsbCE9KGU9dGhpc1t0XSk7dCsrKTE9PT1lLm5vZGVUeXBlJiYoY2UuY2xlYW5EYXRhKFNlKGUsITEpKSxlLnRleHRDb250ZW50PVwiXCIpO3JldHVybiB0aGlzfSxjbG9uZTpmdW5jdGlvbihlLHQpe3JldHVybiBlPW51bGwhPWUmJmUsdD1udWxsPT10P2U6dCx0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiBjZS5jbG9uZSh0aGlzLGUsdCl9KX0saHRtbDpmdW5jdGlvbihlKXtyZXR1cm4gTSh0aGlzLGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXNbMF18fHt9LG49MCxyPXRoaXMubGVuZ3RoO2lmKHZvaWQgMD09PWUmJjE9PT10Lm5vZGVUeXBlKXJldHVybiB0LmlubmVySFRNTDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmIU9lLnRlc3QoZSkmJiFrZVsoVGUuZXhlYyhlKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKXtlPWNlLmh0bWxQcmVmaWx0ZXIoZSk7dHJ5e2Zvcig7bjxyO24rKykxPT09KHQ9dGhpc1tuXXx8e30pLm5vZGVUeXBlJiYoY2UuY2xlYW5EYXRhKFNlKHQsITEpKSx0LmlubmVySFRNTD1lKTt0PTB9Y2F0Y2goZSl7fX10JiZ0aGlzLmVtcHR5KCkuYXBwZW5kKGUpfSxudWxsLGUsYXJndW1lbnRzLmxlbmd0aCl9LHJlcGxhY2VXaXRoOmZ1bmN0aW9uKCl7dmFyIG49W107cmV0dXJuICRlKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMucGFyZW50Tm9kZTtjZS5pbkFycmF5KHRoaXMsbik8MCYmKGNlLmNsZWFuRGF0YShTZSh0aGlzKSksdCYmdC5yZXBsYWNlQ2hpbGQoZSx0aGlzKSl9LG4pfX0pLGNlLmVhY2goe2FwcGVuZFRvOlwiYXBwZW5kXCIscHJlcGVuZFRvOlwicHJlcGVuZFwiLGluc2VydEJlZm9yZTpcImJlZm9yZVwiLGluc2VydEFmdGVyOlwiYWZ0ZXJcIixyZXBsYWNlQWxsOlwicmVwbGFjZVdpdGhcIn0sZnVuY3Rpb24oZSxhKXtjZS5mbltlXT1mdW5jdGlvbihlKXtmb3IodmFyIHQsbj1bXSxyPWNlKGUpLGk9ci5sZW5ndGgtMSxvPTA7bzw9aTtvKyspdD1vPT09aT90aGlzOnRoaXMuY2xvbmUoITApLGNlKHJbb10pW2FdKHQpLHMuYXBwbHkobix0LmdldCgpKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2sobil9fSk7dmFyIF9lPW5ldyBSZWdFeHAoXCJeKFwiK0crXCIpKD8hcHgpW2EteiVdKyRcIixcImlcIiksemU9L14tLS8sWGU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O3JldHVybiB0JiZ0Lm9wZW5lcnx8KHQ9aWUpLHQuZ2V0Q29tcHV0ZWRTdHlsZShlKX0sVWU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbz17fTtmb3IoaSBpbiB0KW9baV09ZS5zdHlsZVtpXSxlLnN0eWxlW2ldPXRbaV07Zm9yKGkgaW4gcj1uLmNhbGwoZSksdCllLnN0eWxlW2ldPW9baV07cmV0dXJuIHJ9LFZlPW5ldyBSZWdFeHAoUS5qb2luKFwifFwiKSxcImlcIik7ZnVuY3Rpb24gR2UoZSx0LG4pe3ZhciByLGksbyxhLHM9emUudGVzdCh0KSx1PWUuc3R5bGU7cmV0dXJuKG49bnx8WGUoZSkpJiYoYT1uLmdldFByb3BlcnR5VmFsdWUodCl8fG5bdF0scyYmYSYmKGE9YS5yZXBsYWNlKHZlLFwiJDFcIil8fHZvaWQgMCksXCJcIiE9PWF8fEsoZSl8fChhPWNlLnN0eWxlKGUsdCkpLCFsZS5waXhlbEJveFN0eWxlcygpJiZfZS50ZXN0KGEpJiZWZS50ZXN0KHQpJiYocj11LndpZHRoLGk9dS5taW5XaWR0aCxvPXUubWF4V2lkdGgsdS5taW5XaWR0aD11Lm1heFdpZHRoPXUud2lkdGg9YSxhPW4ud2lkdGgsdS53aWR0aD1yLHUubWluV2lkdGg9aSx1Lm1heFdpZHRoPW8pKSx2b2lkIDAhPT1hP2ErXCJcIjphfWZ1bmN0aW9uIFllKGUsdCl7cmV0dXJue2dldDpmdW5jdGlvbigpe2lmKCFlKCkpcmV0dXJuKHRoaXMuZ2V0PXQpLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtkZWxldGUgdGhpcy5nZXR9fX0hZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7aWYobCl7dS5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O21hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiLGwuc3R5bGUuY3NzVGV4dD1cInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDttYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O3dpZHRoOjYwJTt0b3A6MSVcIixKLmFwcGVuZENoaWxkKHUpLmFwcGVuZENoaWxkKGwpO3ZhciBlPWllLmdldENvbXB1dGVkU3R5bGUobCk7bj1cIjElXCIhPT1lLnRvcCxzPTEyPT09dChlLm1hcmdpbkxlZnQpLGwuc3R5bGUucmlnaHQ9XCI2MCVcIixvPTM2PT09dChlLnJpZ2h0KSxyPTM2PT09dChlLndpZHRoKSxsLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixpPTEyPT09dChsLm9mZnNldFdpZHRoLzMpLEoucmVtb3ZlQ2hpbGQodSksbD1udWxsfX1mdW5jdGlvbiB0KGUpe3JldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZSkpfXZhciBuLHIsaSxvLGEscyx1PUMuY3JlYXRlRWxlbWVudChcImRpdlwiKSxsPUMuY3JlYXRlRWxlbWVudChcImRpdlwiKTtsLnN0eWxlJiYobC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cImNvbnRlbnQtYm94XCIsbC5jbG9uZU5vZGUoITApLnN0eWxlLmJhY2tncm91bmRDbGlwPVwiXCIsbGUuY2xlYXJDbG9uZVN0eWxlPVwiY29udGVudC1ib3hcIj09PWwuc3R5bGUuYmFja2dyb3VuZENsaXAsY2UuZXh0ZW5kKGxlLHtib3hTaXppbmdSZWxpYWJsZTpmdW5jdGlvbigpe3JldHVybiBlKCkscn0scGl4ZWxCb3hTdHlsZXM6ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLG99LHBpeGVsUG9zaXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLG59LHJlbGlhYmxlTWFyZ2luTGVmdDpmdW5jdGlvbigpe3JldHVybiBlKCksc30sc2Nyb2xsYm94U2l6ZTpmdW5jdGlvbigpe3JldHVybiBlKCksaX0scmVsaWFibGVUckRpbWVuc2lvbnM6ZnVuY3Rpb24oKXt2YXIgZSx0LG4scjtyZXR1cm4gbnVsbD09YSYmKGU9Qy5jcmVhdGVFbGVtZW50KFwidGFibGVcIiksdD1DLmNyZWF0ZUVsZW1lbnQoXCJ0clwiKSxuPUMuY3JlYXRlRWxlbWVudChcImRpdlwiKSxlLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiLHQuc3R5bGUuY3NzVGV4dD1cImJveC1zaXppbmc6Y29udGVudC1ib3g7Ym9yZGVyOjFweCBzb2xpZFwiLHQuc3R5bGUuaGVpZ2h0PVwiMXB4XCIsbi5zdHlsZS5oZWlnaHQ9XCI5cHhcIixuLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLEouYXBwZW5kQ2hpbGQoZSkuYXBwZW5kQ2hpbGQodCkuYXBwZW5kQ2hpbGQobikscj1pZS5nZXRDb21wdXRlZFN0eWxlKHQpLGE9cGFyc2VJbnQoci5oZWlnaHQsMTApK3BhcnNlSW50KHIuYm9yZGVyVG9wV2lkdGgsMTApK3BhcnNlSW50KHIuYm9yZGVyQm90dG9tV2lkdGgsMTApPT09dC5vZmZzZXRIZWlnaHQsSi5yZW1vdmVDaGlsZChlKSksYX19KSl9KCk7dmFyIFFlPVtcIldlYmtpdFwiLFwiTW96XCIsXCJtc1wiXSxKZT1DLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsS2U9e307ZnVuY3Rpb24gWmUoZSl7dmFyIHQ9Y2UuY3NzUHJvcHNbZV18fEtlW2VdO3JldHVybiB0fHwoZSBpbiBKZT9lOktlW2VdPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0udG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLG49UWUubGVuZ3RoO3doaWxlKG4tLSlpZigoZT1RZVtuXSt0KWluIEplKXJldHVybiBlfShlKXx8ZSl9dmFyIGV0PS9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyx0dD17cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIixkaXNwbGF5OlwiYmxvY2tcIn0sbnQ9e2xldHRlclNwYWNpbmc6XCIwXCIsZm9udFdlaWdodDpcIjQwMFwifTtmdW5jdGlvbiBydChlLHQsbil7dmFyIHI9WS5leGVjKHQpO3JldHVybiByP01hdGgubWF4KDAsclsyXS0obnx8MCkpKyhyWzNdfHxcInB4XCIpOnR9ZnVuY3Rpb24gaXQoZSx0LG4scixpLG8pe3ZhciBhPVwid2lkdGhcIj09PXQ/MTowLHM9MCx1PTAsbD0wO2lmKG49PT0ocj9cImJvcmRlclwiOlwiY29udGVudFwiKSlyZXR1cm4gMDtmb3IoO2E8NDthKz0yKVwibWFyZ2luXCI9PT1uJiYobCs9Y2UuY3NzKGUsbitRW2FdLCEwLGkpKSxyPyhcImNvbnRlbnRcIj09PW4mJih1LT1jZS5jc3MoZSxcInBhZGRpbmdcIitRW2FdLCEwLGkpKSxcIm1hcmdpblwiIT09biYmKHUtPWNlLmNzcyhlLFwiYm9yZGVyXCIrUVthXStcIldpZHRoXCIsITAsaSkpKToodSs9Y2UuY3NzKGUsXCJwYWRkaW5nXCIrUVthXSwhMCxpKSxcInBhZGRpbmdcIiE9PW4/dSs9Y2UuY3NzKGUsXCJib3JkZXJcIitRW2FdK1wiV2lkdGhcIiwhMCxpKTpzKz1jZS5jc3MoZSxcImJvcmRlclwiK1FbYV0rXCJXaWR0aFwiLCEwLGkpKTtyZXR1cm4hciYmMDw9byYmKHUrPU1hdGgubWF4KDAsTWF0aC5jZWlsKGVbXCJvZmZzZXRcIit0WzBdLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKV0tby11LXMtLjUpKXx8MCksdStsfWZ1bmN0aW9uIG90KGUsdCxuKXt2YXIgcj1YZShlKSxpPSghbGUuYm94U2l6aW5nUmVsaWFibGUoKXx8bikmJlwiYm9yZGVyLWJveFwiPT09Y2UuY3NzKGUsXCJib3hTaXppbmdcIiwhMSxyKSxvPWksYT1HZShlLHQscikscz1cIm9mZnNldFwiK3RbMF0udG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpO2lmKF9lLnRlc3QoYSkpe2lmKCFuKXJldHVybiBhO2E9XCJhdXRvXCJ9cmV0dXJuKCFsZS5ib3hTaXppbmdSZWxpYWJsZSgpJiZpfHwhbGUucmVsaWFibGVUckRpbWVuc2lvbnMoKSYmZmUoZSxcInRyXCIpfHxcImF1dG9cIj09PWF8fCFwYXJzZUZsb2F0KGEpJiZcImlubGluZVwiPT09Y2UuY3NzKGUsXCJkaXNwbGF5XCIsITEscikpJiZlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoJiYoaT1cImJvcmRlci1ib3hcIj09PWNlLmNzcyhlLFwiYm94U2l6aW5nXCIsITEsciksKG89cyBpbiBlKSYmKGE9ZVtzXSkpLChhPXBhcnNlRmxvYXQoYSl8fDApK2l0KGUsdCxufHwoaT9cImJvcmRlclwiOlwiY29udGVudFwiKSxvLHIsYSkrXCJweFwifWZ1bmN0aW9uIGF0KGUsdCxuLHIsaSl7cmV0dXJuIG5ldyBhdC5wcm90b3R5cGUuaW5pdChlLHQsbixyLGkpfWNlLmV4dGVuZCh7Y3NzSG9va3M6e29wYWNpdHk6e2dldDpmdW5jdGlvbihlLHQpe2lmKHQpe3ZhciBuPUdlKGUsXCJvcGFjaXR5XCIpO3JldHVyblwiXCI9PT1uP1wiMVwiOm59fX19LGNzc051bWJlcjp7YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYXNwZWN0UmF0aW86ITAsYm9yZGVySW1hZ2VTbGljZTohMCxjb2x1bW5Db3VudDohMCxmbGV4R3JvdzohMCxmbGV4U2hyaW5rOiEwLGZvbnRXZWlnaHQ6ITAsZ3JpZEFyZWE6ITAsZ3JpZENvbHVtbjohMCxncmlkQ29sdW1uRW5kOiEwLGdyaWRDb2x1bW5TdGFydDohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1N0YXJ0OiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHNjYWxlOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMCxmaWxsT3BhY2l0eTohMCxmbG9vZE9wYWNpdHk6ITAsc3RvcE9wYWNpdHk6ITAsc3Ryb2tlTWl0ZXJsaW1pdDohMCxzdHJva2VPcGFjaXR5OiEwfSxjc3NQcm9wczp7fSxzdHlsZTpmdW5jdGlvbihlLHQsbixyKXtpZihlJiYzIT09ZS5ub2RlVHlwZSYmOCE9PWUubm9kZVR5cGUmJmUuc3R5bGUpe3ZhciBpLG8sYSxzPUYodCksdT16ZS50ZXN0KHQpLGw9ZS5zdHlsZTtpZih1fHwodD1aZShzKSksYT1jZS5jc3NIb29rc1t0XXx8Y2UuY3NzSG9va3Nbc10sdm9pZCAwPT09bilyZXR1cm4gYSYmXCJnZXRcImluIGEmJnZvaWQgMCE9PShpPWEuZ2V0KGUsITEscikpP2k6bFt0XTtcInN0cmluZ1wiPT09KG89dHlwZW9mIG4pJiYoaT1ZLmV4ZWMobikpJiZpWzFdJiYobj10ZShlLHQsaSksbz1cIm51bWJlclwiKSxudWxsIT1uJiZuPT1uJiYoXCJudW1iZXJcIiE9PW98fHV8fChuKz1pJiZpWzNdfHwoY2UuY3NzTnVtYmVyW3NdP1wiXCI6XCJweFwiKSksbGUuY2xlYXJDbG9uZVN0eWxlfHxcIlwiIT09bnx8MCE9PXQuaW5kZXhPZihcImJhY2tncm91bmRcIil8fChsW3RdPVwiaW5oZXJpdFwiKSxhJiZcInNldFwiaW4gYSYmdm9pZCAwPT09KG49YS5zZXQoZSxuLHIpKXx8KHU/bC5zZXRQcm9wZXJ0eSh0LG4pOmxbdF09bikpfX0sY3NzOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYSxzPUYodCk7cmV0dXJuIHplLnRlc3QodCl8fCh0PVplKHMpKSwoYT1jZS5jc3NIb29rc1t0XXx8Y2UuY3NzSG9va3Nbc10pJiZcImdldFwiaW4gYSYmKGk9YS5nZXQoZSwhMCxuKSksdm9pZCAwPT09aSYmKGk9R2UoZSx0LHIpKSxcIm5vcm1hbFwiPT09aSYmdCBpbiBudCYmKGk9bnRbdF0pLFwiXCI9PT1ufHxuPyhvPXBhcnNlRmxvYXQoaSksITA9PT1ufHxpc0Zpbml0ZShvKT9vfHwwOmkpOml9fSksY2UuZWFjaChbXCJoZWlnaHRcIixcIndpZHRoXCJdLGZ1bmN0aW9uKGUsdSl7Y2UuY3NzSG9va3NbdV09e2dldDpmdW5jdGlvbihlLHQsbil7aWYodClyZXR1cm4hZXQudGVzdChjZS5jc3MoZSxcImRpc3BsYXlcIikpfHxlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoJiZlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoP290KGUsdSxuKTpVZShlLHR0LGZ1bmN0aW9uKCl7cmV0dXJuIG90KGUsdSxuKX0pfSxzZXQ6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk9WGUoZSksbz0hbGUuc2Nyb2xsYm94U2l6ZSgpJiZcImFic29sdXRlXCI9PT1pLnBvc2l0aW9uLGE9KG98fG4pJiZcImJvcmRlci1ib3hcIj09PWNlLmNzcyhlLFwiYm94U2l6aW5nXCIsITEsaSkscz1uP2l0KGUsdSxuLGEsaSk6MDtyZXR1cm4gYSYmbyYmKHMtPU1hdGguY2VpbChlW1wib2Zmc2V0XCIrdVswXS50b1VwcGVyQ2FzZSgpK3Uuc2xpY2UoMSldLXBhcnNlRmxvYXQoaVt1XSktaXQoZSx1LFwiYm9yZGVyXCIsITEsaSktLjUpKSxzJiYocj1ZLmV4ZWModCkpJiZcInB4XCIhPT0oclszXXx8XCJweFwiKSYmKGUuc3R5bGVbdV09dCx0PWNlLmNzcyhlLHUpKSxydCgwLHQscyl9fX0pLGNlLmNzc0hvb2tzLm1hcmdpbkxlZnQ9WWUobGUucmVsaWFibGVNYXJnaW5MZWZ0LGZ1bmN0aW9uKGUsdCl7aWYodClyZXR1cm4ocGFyc2VGbG9hdChHZShlLFwibWFyZ2luTGVmdFwiKSl8fGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdC1VZShlLHttYXJnaW5MZWZ0OjB9LGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdH0pKStcInB4XCJ9KSxjZS5lYWNoKHttYXJnaW46XCJcIixwYWRkaW5nOlwiXCIsYm9yZGVyOlwiV2lkdGhcIn0sZnVuY3Rpb24oaSxvKXtjZS5jc3NIb29rc1tpK29dPXtleHBhbmQ6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj17fSxyPVwic3RyaW5nXCI9PXR5cGVvZiBlP2Uuc3BsaXQoXCIgXCIpOltlXTt0PDQ7dCsrKW5baStRW3RdK29dPXJbdF18fHJbdC0yXXx8clswXTtyZXR1cm4gbn19LFwibWFyZ2luXCIhPT1pJiYoY2UuY3NzSG9va3NbaStvXS5zZXQ9cnQpfSksY2UuZm4uZXh0ZW5kKHtjc3M6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gTSh0aGlzLGZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89e30sYT0wO2lmKEFycmF5LmlzQXJyYXkodCkpe2ZvcihyPVhlKGUpLGk9dC5sZW5ndGg7YTxpO2ErKylvW3RbYV1dPWNlLmNzcyhlLHRbYV0sITEscik7cmV0dXJuIG99cmV0dXJuIHZvaWQgMCE9PW4/Y2Uuc3R5bGUoZSx0LG4pOmNlLmNzcyhlLHQpfSxlLHQsMTxhcmd1bWVudHMubGVuZ3RoKX19KSwoKGNlLlR3ZWVuPWF0KS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmF0LGluaXQ6ZnVuY3Rpb24oZSx0LG4scixpLG8pe3RoaXMuZWxlbT1lLHRoaXMucHJvcD1uLHRoaXMuZWFzaW5nPWl8fGNlLmVhc2luZy5fZGVmYXVsdCx0aGlzLm9wdGlvbnM9dCx0aGlzLnN0YXJ0PXRoaXMubm93PXRoaXMuY3VyKCksdGhpcy5lbmQ9cix0aGlzLnVuaXQ9b3x8KGNlLmNzc051bWJlcltuXT9cIlwiOlwicHhcIil9LGN1cjpmdW5jdGlvbigpe3ZhciBlPWF0LnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiBlJiZlLmdldD9lLmdldCh0aGlzKTphdC5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpfSxydW46ZnVuY3Rpb24oZSl7dmFyIHQsbj1hdC5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gdGhpcy5vcHRpb25zLmR1cmF0aW9uP3RoaXMucG9zPXQ9Y2UuZWFzaW5nW3RoaXMuZWFzaW5nXShlLHRoaXMub3B0aW9ucy5kdXJhdGlvbiplLDAsMSx0aGlzLm9wdGlvbnMuZHVyYXRpb24pOnRoaXMucG9zPXQ9ZSx0aGlzLm5vdz0odGhpcy5lbmQtdGhpcy5zdGFydCkqdCt0aGlzLnN0YXJ0LHRoaXMub3B0aW9ucy5zdGVwJiZ0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSx0aGlzLm5vdyx0aGlzKSxuJiZuLnNldD9uLnNldCh0aGlzKTphdC5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLHRoaXN9fSkuaW5pdC5wcm90b3R5cGU9YXQucHJvdG90eXBlLChhdC5wcm9wSG9va3M9e19kZWZhdWx0OntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIDEhPT1lLmVsZW0ubm9kZVR5cGV8fG51bGwhPWUuZWxlbVtlLnByb3BdJiZudWxsPT1lLmVsZW0uc3R5bGVbZS5wcm9wXT9lLmVsZW1bZS5wcm9wXToodD1jZS5jc3MoZS5lbGVtLGUucHJvcCxcIlwiKSkmJlwiYXV0b1wiIT09dD90OjB9LHNldDpmdW5jdGlvbihlKXtjZS5meC5zdGVwW2UucHJvcF0/Y2UuZnguc3RlcFtlLnByb3BdKGUpOjEhPT1lLmVsZW0ubm9kZVR5cGV8fCFjZS5jc3NIb29rc1tlLnByb3BdJiZudWxsPT1lLmVsZW0uc3R5bGVbWmUoZS5wcm9wKV0/ZS5lbGVtW2UucHJvcF09ZS5ub3c6Y2Uuc3R5bGUoZS5lbGVtLGUucHJvcCxlLm5vdytlLnVuaXQpfX19KS5zY3JvbGxUb3A9YXQucHJvcEhvb2tzLnNjcm9sbExlZnQ9e3NldDpmdW5jdGlvbihlKXtlLmVsZW0ubm9kZVR5cGUmJmUuZWxlbS5wYXJlbnROb2RlJiYoZS5lbGVtW2UucHJvcF09ZS5ub3cpfX0sY2UuZWFzaW5nPXtsaW5lYXI6ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHN3aW5nOmZ1bmN0aW9uKGUpe3JldHVybi41LU1hdGguY29zKGUqTWF0aC5QSSkvMn0sX2RlZmF1bHQ6XCJzd2luZ1wifSxjZS5meD1hdC5wcm90b3R5cGUuaW5pdCxjZS5meC5zdGVwPXt9O3ZhciBzdCx1dCxsdCxjdCxmdD0vXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8scHQ9L3F1ZXVlSG9va3MkLztmdW5jdGlvbiBkdCgpe3V0JiYoITE9PT1DLmhpZGRlbiYmaWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lP2llLnJlcXVlc3RBbmltYXRpb25GcmFtZShkdCk6aWUuc2V0VGltZW91dChkdCxjZS5meC5pbnRlcnZhbCksY2UuZngudGljaygpKX1mdW5jdGlvbiBodCgpe3JldHVybiBpZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c3Q9dm9pZCAwfSksc3Q9RGF0ZS5ub3coKX1mdW5jdGlvbiBndChlLHQpe3ZhciBuLHI9MCxpPXtoZWlnaHQ6ZX07Zm9yKHQ9dD8xOjA7cjw0O3IrPTItdClpW1wibWFyZ2luXCIrKG49UVtyXSldPWlbXCJwYWRkaW5nXCIrbl09ZTtyZXR1cm4gdCYmKGkub3BhY2l0eT1pLndpZHRoPWUpLGl9ZnVuY3Rpb24gdnQoZSx0LG4pe2Zvcih2YXIgcixpPSh5dC50d2VlbmVyc1t0XXx8W10pLmNvbmNhdCh5dC50d2VlbmVyc1tcIipcIl0pLG89MCxhPWkubGVuZ3RoO288YTtvKyspaWYocj1pW29dLmNhbGwobix0LGUpKXJldHVybiByfWZ1bmN0aW9uIHl0KG8sZSx0KXt2YXIgbixhLHI9MCxpPXl0LnByZWZpbHRlcnMubGVuZ3RoLHM9Y2UuRGVmZXJyZWQoKS5hbHdheXMoZnVuY3Rpb24oKXtkZWxldGUgdS5lbGVtfSksdT1mdW5jdGlvbigpe2lmKGEpcmV0dXJuITE7Zm9yKHZhciBlPXN0fHxodCgpLHQ9TWF0aC5tYXgoMCxsLnN0YXJ0VGltZStsLmR1cmF0aW9uLWUpLG49MS0odC9sLmR1cmF0aW9ufHwwKSxyPTAsaT1sLnR3ZWVucy5sZW5ndGg7cjxpO3IrKylsLnR3ZWVuc1tyXS5ydW4obik7cmV0dXJuIHMubm90aWZ5V2l0aChvLFtsLG4sdF0pLG48MSYmaT90OihpfHxzLm5vdGlmeVdpdGgobyxbbCwxLDBdKSxzLnJlc29sdmVXaXRoKG8sW2xdKSwhMSl9LGw9cy5wcm9taXNlKHtlbGVtOm8scHJvcHM6Y2UuZXh0ZW5kKHt9LGUpLG9wdHM6Y2UuZXh0ZW5kKCEwLHtzcGVjaWFsRWFzaW5nOnt9LGVhc2luZzpjZS5lYXNpbmcuX2RlZmF1bHR9LHQpLG9yaWdpbmFsUHJvcGVydGllczplLG9yaWdpbmFsT3B0aW9uczp0LHN0YXJ0VGltZTpzdHx8aHQoKSxkdXJhdGlvbjp0LmR1cmF0aW9uLHR3ZWVuczpbXSxjcmVhdGVUd2VlbjpmdW5jdGlvbihlLHQpe3ZhciBuPWNlLlR3ZWVuKG8sbC5vcHRzLGUsdCxsLm9wdHMuc3BlY2lhbEVhc2luZ1tlXXx8bC5vcHRzLmVhc2luZyk7cmV0dXJuIGwudHdlZW5zLnB1c2gobiksbn0sc3RvcDpmdW5jdGlvbihlKXt2YXIgdD0wLG49ZT9sLnR3ZWVucy5sZW5ndGg6MDtpZihhKXJldHVybiB0aGlzO2ZvcihhPSEwO3Q8bjt0KyspbC50d2VlbnNbdF0ucnVuKDEpO3JldHVybiBlPyhzLm5vdGlmeVdpdGgobyxbbCwxLDBdKSxzLnJlc29sdmVXaXRoKG8sW2wsZV0pKTpzLnJlamVjdFdpdGgobyxbbCxlXSksdGhpc319KSxjPWwucHJvcHM7Zm9yKCFmdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxvLGE7Zm9yKG4gaW4gZSlpZihpPXRbcj1GKG4pXSxvPWVbbl0sQXJyYXkuaXNBcnJheShvKSYmKGk9b1sxXSxvPWVbbl09b1swXSksbiE9PXImJihlW3JdPW8sZGVsZXRlIGVbbl0pLChhPWNlLmNzc0hvb2tzW3JdKSYmXCJleHBhbmRcImluIGEpZm9yKG4gaW4gbz1hLmV4cGFuZChvKSxkZWxldGUgZVtyXSxvKW4gaW4gZXx8KGVbbl09b1tuXSx0W25dPWkpO2Vsc2UgdFtyXT1pfShjLGwub3B0cy5zcGVjaWFsRWFzaW5nKTtyPGk7cisrKWlmKG49eXQucHJlZmlsdGVyc1tyXS5jYWxsKGwsbyxjLGwub3B0cykpcmV0dXJuIHYobi5zdG9wKSYmKGNlLl9xdWV1ZUhvb2tzKGwuZWxlbSxsLm9wdHMucXVldWUpLnN0b3A9bi5zdG9wLmJpbmQobikpLG47cmV0dXJuIGNlLm1hcChjLHZ0LGwpLHYobC5vcHRzLnN0YXJ0KSYmbC5vcHRzLnN0YXJ0LmNhbGwobyxsKSxsLnByb2dyZXNzKGwub3B0cy5wcm9ncmVzcykuZG9uZShsLm9wdHMuZG9uZSxsLm9wdHMuY29tcGxldGUpLmZhaWwobC5vcHRzLmZhaWwpLmFsd2F5cyhsLm9wdHMuYWx3YXlzKSxjZS5meC50aW1lcihjZS5leHRlbmQodSx7ZWxlbTpvLGFuaW06bCxxdWV1ZTpsLm9wdHMucXVldWV9KSksbH1jZS5BbmltYXRpb249Y2UuZXh0ZW5kKHl0LHt0d2VlbmVyczp7XCIqXCI6W2Z1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5jcmVhdGVUd2VlbihlLHQpO3JldHVybiB0ZShuLmVsZW0sZSxZLmV4ZWModCksbiksbn1dfSx0d2VlbmVyOmZ1bmN0aW9uKGUsdCl7dihlKT8odD1lLGU9W1wiKlwiXSk6ZT1lLm1hdGNoKEQpO2Zvcih2YXIgbixyPTAsaT1lLmxlbmd0aDtyPGk7cisrKW49ZVtyXSx5dC50d2VlbmVyc1tuXT15dC50d2VlbmVyc1tuXXx8W10seXQudHdlZW5lcnNbbl0udW5zaGlmdCh0KX0scHJlZmlsdGVyczpbZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhLHMsdSxsLGMsZj1cIndpZHRoXCJpbiB0fHxcImhlaWdodFwiaW4gdCxwPXRoaXMsZD17fSxoPWUuc3R5bGUsZz1lLm5vZGVUeXBlJiZlZShlKSx2PV8uZ2V0KGUsXCJmeHNob3dcIik7Zm9yKHIgaW4gbi5xdWV1ZXx8KG51bGw9PShhPWNlLl9xdWV1ZUhvb2tzKGUsXCJmeFwiKSkudW5xdWV1ZWQmJihhLnVucXVldWVkPTAscz1hLmVtcHR5LmZpcmUsYS5lbXB0eS5maXJlPWZ1bmN0aW9uKCl7YS51bnF1ZXVlZHx8cygpfSksYS51bnF1ZXVlZCsrLHAuYWx3YXlzKGZ1bmN0aW9uKCl7cC5hbHdheXMoZnVuY3Rpb24oKXthLnVucXVldWVkLS0sY2UucXVldWUoZSxcImZ4XCIpLmxlbmd0aHx8YS5lbXB0eS5maXJlKCl9KX0pKSx0KWlmKGk9dFtyXSxmdC50ZXN0KGkpKXtpZihkZWxldGUgdFtyXSxvPW98fFwidG9nZ2xlXCI9PT1pLGk9PT0oZz9cImhpZGVcIjpcInNob3dcIikpe2lmKFwic2hvd1wiIT09aXx8IXZ8fHZvaWQgMD09PXZbcl0pY29udGludWU7Zz0hMH1kW3JdPXYmJnZbcl18fGNlLnN0eWxlKGUscil9aWYoKHU9IWNlLmlzRW1wdHlPYmplY3QodCkpfHwhY2UuaXNFbXB0eU9iamVjdChkKSlmb3IociBpbiBmJiYxPT09ZS5ub2RlVHlwZSYmKG4ub3ZlcmZsb3c9W2gub3ZlcmZsb3csaC5vdmVyZmxvd1gsaC5vdmVyZmxvd1ldLG51bGw9PShsPXYmJnYuZGlzcGxheSkmJihsPV8uZ2V0KGUsXCJkaXNwbGF5XCIpKSxcIm5vbmVcIj09PShjPWNlLmNzcyhlLFwiZGlzcGxheVwiKSkmJihsP2M9bDoocmUoW2VdLCEwKSxsPWUuc3R5bGUuZGlzcGxheXx8bCxjPWNlLmNzcyhlLFwiZGlzcGxheVwiKSxyZShbZV0pKSksKFwiaW5saW5lXCI9PT1jfHxcImlubGluZS1ibG9ja1wiPT09YyYmbnVsbCE9bCkmJlwibm9uZVwiPT09Y2UuY3NzKGUsXCJmbG9hdFwiKSYmKHV8fChwLmRvbmUoZnVuY3Rpb24oKXtoLmRpc3BsYXk9bH0pLG51bGw9PWwmJihjPWguZGlzcGxheSxsPVwibm9uZVwiPT09Yz9cIlwiOmMpKSxoLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIikpLG4ub3ZlcmZsb3cmJihoLm92ZXJmbG93PVwiaGlkZGVuXCIscC5hbHdheXMoZnVuY3Rpb24oKXtoLm92ZXJmbG93PW4ub3ZlcmZsb3dbMF0saC5vdmVyZmxvd1g9bi5vdmVyZmxvd1sxXSxoLm92ZXJmbG93WT1uLm92ZXJmbG93WzJdfSkpLHU9ITEsZCl1fHwodj9cImhpZGRlblwiaW4gdiYmKGc9di5oaWRkZW4pOnY9Xy5hY2Nlc3MoZSxcImZ4c2hvd1wiLHtkaXNwbGF5Omx9KSxvJiYodi5oaWRkZW49IWcpLGcmJnJlKFtlXSwhMCkscC5kb25lKGZ1bmN0aW9uKCl7Zm9yKHIgaW4gZ3x8cmUoW2VdKSxfLnJlbW92ZShlLFwiZnhzaG93XCIpLGQpY2Uuc3R5bGUoZSxyLGRbcl0pfSkpLHU9dnQoZz92W3JdOjAscixwKSxyIGluIHZ8fCh2W3JdPXUuc3RhcnQsZyYmKHUuZW5kPXUuc3RhcnQsdS5zdGFydD0wKSl9XSxwcmVmaWx0ZXI6ZnVuY3Rpb24oZSx0KXt0P3l0LnByZWZpbHRlcnMudW5zaGlmdChlKTp5dC5wcmVmaWx0ZXJzLnB1c2goZSl9fSksY2Uuc3BlZWQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWUmJlwib2JqZWN0XCI9PXR5cGVvZiBlP2NlLmV4dGVuZCh7fSxlKTp7Y29tcGxldGU6bnx8IW4mJnR8fHYoZSkmJmUsZHVyYXRpb246ZSxlYXNpbmc6biYmdHx8dCYmIXYodCkmJnR9O3JldHVybiBjZS5meC5vZmY/ci5kdXJhdGlvbj0wOlwibnVtYmVyXCIhPXR5cGVvZiByLmR1cmF0aW9uJiYoci5kdXJhdGlvbiBpbiBjZS5meC5zcGVlZHM/ci5kdXJhdGlvbj1jZS5meC5zcGVlZHNbci5kdXJhdGlvbl06ci5kdXJhdGlvbj1jZS5meC5zcGVlZHMuX2RlZmF1bHQpLG51bGwhPXIucXVldWUmJiEwIT09ci5xdWV1ZXx8KHIucXVldWU9XCJmeFwiKSxyLm9sZD1yLmNvbXBsZXRlLHIuY29tcGxldGU9ZnVuY3Rpb24oKXt2KHIub2xkKSYmci5vbGQuY2FsbCh0aGlzKSxyLnF1ZXVlJiZjZS5kZXF1ZXVlKHRoaXMsci5xdWV1ZSl9LHJ9LGNlLmZuLmV4dGVuZCh7ZmFkZVRvOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLmZpbHRlcihlZSkuY3NzKFwib3BhY2l0eVwiLDApLnNob3coKS5lbmQoKS5hbmltYXRlKHtvcGFjaXR5OnR9LGUsbixyKX0sYW5pbWF0ZTpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1jZS5pc0VtcHR5T2JqZWN0KHQpLG89Y2Uuc3BlZWQoZSxuLHIpLGE9ZnVuY3Rpb24oKXt2YXIgZT15dCh0aGlzLGNlLmV4dGVuZCh7fSx0KSxvKTsoaXx8Xy5nZXQodGhpcyxcImZpbmlzaFwiKSkmJmUuc3RvcCghMCl9O3JldHVybiBhLmZpbmlzaD1hLGl8fCExPT09by5xdWV1ZT90aGlzLmVhY2goYSk6dGhpcy5xdWV1ZShvLnF1ZXVlLGEpfSxzdG9wOmZ1bmN0aW9uKGksZSxvKXt2YXIgYT1mdW5jdGlvbihlKXt2YXIgdD1lLnN0b3A7ZGVsZXRlIGUuc3RvcCx0KG8pfTtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgaSYmKG89ZSxlPWksaT12b2lkIDApLGUmJnRoaXMucXVldWUoaXx8XCJmeFwiLFtdKSx0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT0hMCx0PW51bGwhPWkmJmkrXCJxdWV1ZUhvb2tzXCIsbj1jZS50aW1lcnMscj1fLmdldCh0aGlzKTtpZih0KXJbdF0mJnJbdF0uc3RvcCYmYShyW3RdKTtlbHNlIGZvcih0IGluIHIpclt0XSYmclt0XS5zdG9wJiZwdC50ZXN0KHQpJiZhKHJbdF0pO2Zvcih0PW4ubGVuZ3RoO3QtLTspblt0XS5lbGVtIT09dGhpc3x8bnVsbCE9aSYmblt0XS5xdWV1ZSE9PWl8fChuW3RdLmFuaW0uc3RvcChvKSxlPSExLG4uc3BsaWNlKHQsMSkpOyFlJiZvfHxjZS5kZXF1ZXVlKHRoaXMsaSl9KX0sZmluaXNoOmZ1bmN0aW9uKGEpe3JldHVybiExIT09YSYmKGE9YXx8XCJmeFwiKSx0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZSx0PV8uZ2V0KHRoaXMpLG49dFthK1wicXVldWVcIl0scj10W2ErXCJxdWV1ZUhvb2tzXCJdLGk9Y2UudGltZXJzLG89bj9uLmxlbmd0aDowO2Zvcih0LmZpbmlzaD0hMCxjZS5xdWV1ZSh0aGlzLGEsW10pLHImJnIuc3RvcCYmci5zdG9wLmNhbGwodGhpcywhMCksZT1pLmxlbmd0aDtlLS07KWlbZV0uZWxlbT09PXRoaXMmJmlbZV0ucXVldWU9PT1hJiYoaVtlXS5hbmltLnN0b3AoITApLGkuc3BsaWNlKGUsMSkpO2ZvcihlPTA7ZTxvO2UrKyluW2VdJiZuW2VdLmZpbmlzaCYmbltlXS5maW5pc2guY2FsbCh0aGlzKTtkZWxldGUgdC5maW5pc2h9KX19KSxjZS5lYWNoKFtcInRvZ2dsZVwiLFwic2hvd1wiLFwiaGlkZVwiXSxmdW5jdGlvbihlLHIpe3ZhciBpPWNlLmZuW3JdO2NlLmZuW3JdPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbnVsbD09ZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlP2kuYXBwbHkodGhpcyxhcmd1bWVudHMpOnRoaXMuYW5pbWF0ZShndChyLCEwKSxlLHQsbil9fSksY2UuZWFjaCh7c2xpZGVEb3duOmd0KFwic2hvd1wiKSxzbGlkZVVwOmd0KFwiaGlkZVwiKSxzbGlkZVRvZ2dsZTpndChcInRvZ2dsZVwiKSxmYWRlSW46e29wYWNpdHk6XCJzaG93XCJ9LGZhZGVPdXQ6e29wYWNpdHk6XCJoaWRlXCJ9LGZhZGVUb2dnbGU6e29wYWNpdHk6XCJ0b2dnbGVcIn19LGZ1bmN0aW9uKGUscil7Y2UuZm5bZV09ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLmFuaW1hdGUocixlLHQsbil9fSksY2UudGltZXJzPVtdLGNlLmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgZSx0PTAsbj1jZS50aW1lcnM7Zm9yKHN0PURhdGUubm93KCk7dDxuLmxlbmd0aDt0KyspKGU9blt0XSkoKXx8blt0XSE9PWV8fG4uc3BsaWNlKHQtLSwxKTtuLmxlbmd0aHx8Y2UuZnguc3RvcCgpLHN0PXZvaWQgMH0sY2UuZngudGltZXI9ZnVuY3Rpb24oZSl7Y2UudGltZXJzLnB1c2goZSksY2UuZnguc3RhcnQoKX0sY2UuZnguaW50ZXJ2YWw9MTMsY2UuZnguc3RhcnQ9ZnVuY3Rpb24oKXt1dHx8KHV0PSEwLGR0KCkpfSxjZS5meC5zdG9wPWZ1bmN0aW9uKCl7dXQ9bnVsbH0sY2UuZnguc3BlZWRzPXtzbG93OjYwMCxmYXN0OjIwMCxfZGVmYXVsdDo0MDB9LGNlLmZuLmRlbGF5PWZ1bmN0aW9uKHIsZSl7cmV0dXJuIHI9Y2UuZngmJmNlLmZ4LnNwZWVkc1tyXXx8cixlPWV8fFwiZnhcIix0aGlzLnF1ZXVlKGUsZnVuY3Rpb24oZSx0KXt2YXIgbj1pZS5zZXRUaW1lb3V0KGUscik7dC5zdG9wPWZ1bmN0aW9uKCl7aWUuY2xlYXJUaW1lb3V0KG4pfX0pfSxsdD1DLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxjdD1DLmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIikuYXBwZW5kQ2hpbGQoQy5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKSxsdC50eXBlPVwiY2hlY2tib3hcIixsZS5jaGVja09uPVwiXCIhPT1sdC52YWx1ZSxsZS5vcHRTZWxlY3RlZD1jdC5zZWxlY3RlZCwobHQ9Qy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnZhbHVlPVwidFwiLGx0LnR5cGU9XCJyYWRpb1wiLGxlLnJhZGlvVmFsdWU9XCJ0XCI9PT1sdC52YWx1ZTt2YXIgbXQseHQ9Y2UuZXhwci5hdHRySGFuZGxlO2NlLmZuLmV4dGVuZCh7YXR0cjpmdW5jdGlvbihlLHQpe3JldHVybiBNKHRoaXMsY2UuYXR0cixlLHQsMTxhcmd1bWVudHMubGVuZ3RoKX0scmVtb3ZlQXR0cjpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Y2UucmVtb3ZlQXR0cih0aGlzLGUpfSl9fSksY2UuZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89ZS5ub2RlVHlwZTtpZigzIT09byYmOCE9PW8mJjIhPT1vKXJldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBlLmdldEF0dHJpYnV0ZT9jZS5wcm9wKGUsdCxuKTooMT09PW8mJmNlLmlzWE1MRG9jKGUpfHwoaT1jZS5hdHRySG9va3NbdC50b0xvd2VyQ2FzZSgpXXx8KGNlLmV4cHIubWF0Y2guYm9vbC50ZXN0KHQpP210OnZvaWQgMCkpLHZvaWQgMCE9PW4/bnVsbD09PW4/dm9pZCBjZS5yZW1vdmVBdHRyKGUsdCk6aSYmXCJzZXRcImluIGkmJnZvaWQgMCE9PShyPWkuc2V0KGUsbix0KSk/cjooZS5zZXRBdHRyaWJ1dGUodCxuK1wiXCIpLG4pOmkmJlwiZ2V0XCJpbiBpJiZudWxsIT09KHI9aS5nZXQoZSx0KSk/cjpudWxsPT0ocj1jZS5maW5kLmF0dHIoZSx0KSk/dm9pZCAwOnIpfSxhdHRySG9va3M6e3R5cGU6e3NldDpmdW5jdGlvbihlLHQpe2lmKCFsZS5yYWRpb1ZhbHVlJiZcInJhZGlvXCI9PT10JiZmZShlLFwiaW5wdXRcIikpe3ZhciBuPWUudmFsdWU7cmV0dXJuIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLHQpLG4mJihlLnZhbHVlPW4pLHR9fX19LHJlbW92ZUF0dHI6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTAsaT10JiZ0Lm1hdGNoKEQpO2lmKGkmJjE9PT1lLm5vZGVUeXBlKXdoaWxlKG49aVtyKytdKWUucmVtb3ZlQXR0cmlidXRlKG4pfX0pLG10PXtzZXQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiExPT09dD9jZS5yZW1vdmVBdHRyKGUsbik6ZS5zZXRBdHRyaWJ1dGUobixuKSxufX0sY2UuZWFjaChjZS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cXHcrL2cpLGZ1bmN0aW9uKGUsdCl7dmFyIGE9eHRbdF18fGNlLmZpbmQuYXR0cjt4dFt0XT1mdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPXQudG9Mb3dlckNhc2UoKTtyZXR1cm4gbnx8KGk9eHRbb10seHRbb109cixyPW51bGwhPWEoZSx0LG4pP286bnVsbCx4dFtvXT1pKSxyfX0pO3ZhciBidD0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLHd0PS9eKD86YXxhcmVhKSQvaTtmdW5jdGlvbiBUdChlKXtyZXR1cm4oZS5tYXRjaChEKXx8W10pLmpvaW4oXCIgXCIpfWZ1bmN0aW9uIEN0KGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIn1mdW5jdGlvbiBrdChlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT9lOlwic3RyaW5nXCI9PXR5cGVvZiBlJiZlLm1hdGNoKEQpfHxbXX1jZS5mbi5leHRlbmQoe3Byb3A6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gTSh0aGlzLGNlLnByb3AsZSx0LDE8YXJndW1lbnRzLmxlbmd0aCl9LHJlbW92ZVByb3A6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2RlbGV0ZSB0aGlzW2NlLnByb3BGaXhbZV18fGVdfSl9fSksY2UuZXh0ZW5kKHtwcm9wOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89ZS5ub2RlVHlwZTtpZigzIT09byYmOCE9PW8mJjIhPT1vKXJldHVybiAxPT09byYmY2UuaXNYTUxEb2MoZSl8fCh0PWNlLnByb3BGaXhbdF18fHQsaT1jZS5wcm9wSG9va3NbdF0pLHZvaWQgMCE9PW4/aSYmXCJzZXRcImluIGkmJnZvaWQgMCE9PShyPWkuc2V0KGUsbix0KSk/cjplW3RdPW46aSYmXCJnZXRcImluIGkmJm51bGwhPT0ocj1pLmdldChlLHQpKT9yOmVbdF19LHByb3BIb29rczp7dGFiSW5kZXg6e2dldDpmdW5jdGlvbihlKXt2YXIgdD1jZS5maW5kLmF0dHIoZSxcInRhYmluZGV4XCIpO3JldHVybiB0P3BhcnNlSW50KHQsMTApOmJ0LnRlc3QoZS5ub2RlTmFtZSl8fHd0LnRlc3QoZS5ub2RlTmFtZSkmJmUuaHJlZj8wOi0xfX19LHByb3BGaXg6e1wiZm9yXCI6XCJodG1sRm9yXCIsXCJjbGFzc1wiOlwiY2xhc3NOYW1lXCJ9fSksbGUub3B0U2VsZWN0ZWR8fChjZS5wcm9wSG9va3Muc2VsZWN0ZWQ9e2dldDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7cmV0dXJuIHQmJnQucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsbnVsbH0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0PWUucGFyZW50Tm9kZTt0JiYodC5zZWxlY3RlZEluZGV4LHQucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpfX0pLGNlLmVhY2goW1widGFiSW5kZXhcIixcInJlYWRPbmx5XCIsXCJtYXhMZW5ndGhcIixcImNlbGxTcGFjaW5nXCIsXCJjZWxsUGFkZGluZ1wiLFwicm93U3BhblwiLFwiY29sU3BhblwiLFwidXNlTWFwXCIsXCJmcmFtZUJvcmRlclwiLFwiY29udGVudEVkaXRhYmxlXCJdLGZ1bmN0aW9uKCl7Y2UucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldPXRoaXN9KSxjZS5mbi5leHRlbmQoe2FkZENsYXNzOmZ1bmN0aW9uKHQpe3ZhciBlLG4scixpLG8sYTtyZXR1cm4gdih0KT90aGlzLmVhY2goZnVuY3Rpb24oZSl7Y2UodGhpcykuYWRkQ2xhc3ModC5jYWxsKHRoaXMsZSxDdCh0aGlzKSkpfSk6KGU9a3QodCkpLmxlbmd0aD90aGlzLmVhY2goZnVuY3Rpb24oKXtpZihyPUN0KHRoaXMpLG49MT09PXRoaXMubm9kZVR5cGUmJlwiIFwiK1R0KHIpK1wiIFwiKXtmb3Iobz0wO288ZS5sZW5ndGg7bysrKWk9ZVtvXSxuLmluZGV4T2YoXCIgXCIraStcIiBcIik8MCYmKG4rPWkrXCIgXCIpO2E9VHQobiksciE9PWEmJnRoaXMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixhKX19KTp0aGlzfSxyZW1vdmVDbGFzczpmdW5jdGlvbih0KXt2YXIgZSxuLHIsaSxvLGE7cmV0dXJuIHYodCk/dGhpcy5lYWNoKGZ1bmN0aW9uKGUpe2NlKHRoaXMpLnJlbW92ZUNsYXNzKHQuY2FsbCh0aGlzLGUsQ3QodGhpcykpKX0pOmFyZ3VtZW50cy5sZW5ndGg/KGU9a3QodCkpLmxlbmd0aD90aGlzLmVhY2goZnVuY3Rpb24oKXtpZihyPUN0KHRoaXMpLG49MT09PXRoaXMubm9kZVR5cGUmJlwiIFwiK1R0KHIpK1wiIFwiKXtmb3Iobz0wO288ZS5sZW5ndGg7bysrKXtpPWVbb107d2hpbGUoLTE8bi5pbmRleE9mKFwiIFwiK2krXCIgXCIpKW49bi5yZXBsYWNlKFwiIFwiK2krXCIgXCIsXCIgXCIpfWE9VHQobiksciE9PWEmJnRoaXMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixhKX19KTp0aGlzOnRoaXMuYXR0cihcImNsYXNzXCIsXCJcIil9LHRvZ2dsZUNsYXNzOmZ1bmN0aW9uKHQsbil7dmFyIGUscixpLG8sYT10eXBlb2YgdCxzPVwic3RyaW5nXCI9PT1hfHxBcnJheS5pc0FycmF5KHQpO3JldHVybiB2KHQpP3RoaXMuZWFjaChmdW5jdGlvbihlKXtjZSh0aGlzKS50b2dnbGVDbGFzcyh0LmNhbGwodGhpcyxlLEN0KHRoaXMpLG4pLG4pfSk6XCJib29sZWFuXCI9PXR5cGVvZiBuJiZzP24/dGhpcy5hZGRDbGFzcyh0KTp0aGlzLnJlbW92ZUNsYXNzKHQpOihlPWt0KHQpLHRoaXMuZWFjaChmdW5jdGlvbigpe2lmKHMpZm9yKG89Y2UodGhpcyksaT0wO2k8ZS5sZW5ndGg7aSsrKXI9ZVtpXSxvLmhhc0NsYXNzKHIpP28ucmVtb3ZlQ2xhc3Mocik6by5hZGRDbGFzcyhyKTtlbHNlIHZvaWQgMCE9PXQmJlwiYm9vbGVhblwiIT09YXx8KChyPUN0KHRoaXMpKSYmXy5zZXQodGhpcyxcIl9fY2xhc3NOYW1lX19cIixyKSx0aGlzLnNldEF0dHJpYnV0ZSYmdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLHJ8fCExPT09dD9cIlwiOl8uZ2V0KHRoaXMsXCJfX2NsYXNzTmFtZV9fXCIpfHxcIlwiKSl9KSl9LGhhc0NsYXNzOmZ1bmN0aW9uKGUpe3ZhciB0LG4scj0wO3Q9XCIgXCIrZStcIiBcIjt3aGlsZShuPXRoaXNbcisrXSlpZigxPT09bi5ub2RlVHlwZSYmLTE8KFwiIFwiK1R0KEN0KG4pKStcIiBcIikuaW5kZXhPZih0KSlyZXR1cm4hMDtyZXR1cm4hMX19KTt2YXIgU3Q9L1xcci9nO2NlLmZuLmV4dGVuZCh7dmFsOmZ1bmN0aW9uKG4pe3ZhciByLGUsaSx0PXRoaXNbMF07cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9dihuKSx0aGlzLmVhY2goZnVuY3Rpb24oZSl7dmFyIHQ7MT09PXRoaXMubm9kZVR5cGUmJihudWxsPT0odD1pP24uY2FsbCh0aGlzLGUsY2UodGhpcykudmFsKCkpOm4pP3Q9XCJcIjpcIm51bWJlclwiPT10eXBlb2YgdD90Kz1cIlwiOkFycmF5LmlzQXJyYXkodCkmJih0PWNlLm1hcCh0LGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP1wiXCI6ZStcIlwifSkpLChyPWNlLnZhbEhvb2tzW3RoaXMudHlwZV18fGNlLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pJiZcInNldFwiaW4gciYmdm9pZCAwIT09ci5zZXQodGhpcyx0LFwidmFsdWVcIil8fCh0aGlzLnZhbHVlPXQpKX0pKTp0PyhyPWNlLnZhbEhvb2tzW3QudHlwZV18fGNlLnZhbEhvb2tzW3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pJiZcImdldFwiaW4gciYmdm9pZCAwIT09KGU9ci5nZXQodCxcInZhbHVlXCIpKT9lOlwic3RyaW5nXCI9PXR5cGVvZihlPXQudmFsdWUpP2UucmVwbGFjZShTdCxcIlwiKTpudWxsPT1lP1wiXCI6ZTp2b2lkIDB9fSksY2UuZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9Y2UuZmluZC5hdHRyKGUsXCJ2YWx1ZVwiKTtyZXR1cm4gbnVsbCE9dD90OlR0KGNlLnRleHQoZSkpfX0sc2VsZWN0OntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQsbixyLGk9ZS5vcHRpb25zLG89ZS5zZWxlY3RlZEluZGV4LGE9XCJzZWxlY3Qtb25lXCI9PT1lLnR5cGUscz1hP251bGw6W10sdT1hP28rMTppLmxlbmd0aDtmb3Iocj1vPDA/dTphP286MDtyPHU7cisrKWlmKCgobj1pW3JdKS5zZWxlY3RlZHx8cj09PW8pJiYhbi5kaXNhYmxlZCYmKCFuLnBhcmVudE5vZGUuZGlzYWJsZWR8fCFmZShuLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe2lmKHQ9Y2UobikudmFsKCksYSlyZXR1cm4gdDtzLnB1c2godCl9cmV0dXJuIHN9LHNldDpmdW5jdGlvbihlLHQpe3ZhciBuLHIsaT1lLm9wdGlvbnMsbz1jZS5tYWtlQXJyYXkodCksYT1pLmxlbmd0aDt3aGlsZShhLS0pKChyPWlbYV0pLnNlbGVjdGVkPS0xPGNlLmluQXJyYXkoY2UudmFsSG9va3Mub3B0aW9uLmdldChyKSxvKSkmJihuPSEwKTtyZXR1cm4gbnx8KGUuc2VsZWN0ZWRJbmRleD0tMSksb319fX0pLGNlLmVhY2goW1wicmFkaW9cIixcImNoZWNrYm94XCJdLGZ1bmN0aW9uKCl7Y2UudmFsSG9va3NbdGhpc109e3NldDpmdW5jdGlvbihlLHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIGUuY2hlY2tlZD0tMTxjZS5pbkFycmF5KGNlKGUpLnZhbCgpLHQpfX0sbGUuY2hlY2tPbnx8KGNlLnZhbEhvb2tzW3RoaXNdLmdldD1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09PWUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik/XCJvblwiOmUudmFsdWV9KX0pO3ZhciBFdD1pZS5sb2NhdGlvbixqdD17Z3VpZDpEYXRlLm5vdygpfSxBdD0vXFw/LztjZS5wYXJzZVhNTD1mdW5jdGlvbihlKXt2YXIgdCxuO2lmKCFlfHxcInN0cmluZ1wiIT10eXBlb2YgZSlyZXR1cm4gbnVsbDt0cnl7dD0obmV3IGllLkRPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKGUsXCJ0ZXh0L3htbFwiKX1jYXRjaChlKXt9cmV0dXJuIG49dCYmdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpWzBdLHQmJiFufHxjZS5lcnJvcihcIkludmFsaWQgWE1MOiBcIisobj9jZS5tYXAobi5jaGlsZE5vZGVzLGZ1bmN0aW9uKGUpe3JldHVybiBlLnRleHRDb250ZW50fSkuam9pbihcIlxcblwiKTplKSksdH07dmFyIER0PS9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxOdD1mdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpfTtjZS5leHRlbmQoY2UuZXZlbnQse3RyaWdnZXI6ZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHMsdSxsLGMsZixwPVtufHxDXSxkPXVlLmNhbGwoZSxcInR5cGVcIik/ZS50eXBlOmUsaD11ZS5jYWxsKGUsXCJuYW1lc3BhY2VcIik/ZS5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpOltdO2lmKG89Zj1hPW49bnx8QywzIT09bi5ub2RlVHlwZSYmOCE9PW4ubm9kZVR5cGUmJiFEdC50ZXN0KGQrY2UuZXZlbnQudHJpZ2dlcmVkKSYmKC0xPGQuaW5kZXhPZihcIi5cIikmJihkPShoPWQuc3BsaXQoXCIuXCIpKS5zaGlmdCgpLGguc29ydCgpKSx1PWQuaW5kZXhPZihcIjpcIik8MCYmXCJvblwiK2QsKGU9ZVtjZS5leHBhbmRvXT9lOm5ldyBjZS5FdmVudChkLFwib2JqZWN0XCI9PXR5cGVvZiBlJiZlKSkuaXNUcmlnZ2VyPXI/MjozLGUubmFtZXNwYWNlPWguam9pbihcIi5cIiksZS5ybmFtZXNwYWNlPWUubmFtZXNwYWNlP25ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKTpudWxsLGUucmVzdWx0PXZvaWQgMCxlLnRhcmdldHx8KGUudGFyZ2V0PW4pLHQ9bnVsbD09dD9bZV06Y2UubWFrZUFycmF5KHQsW2VdKSxjPWNlLmV2ZW50LnNwZWNpYWxbZF18fHt9LHJ8fCFjLnRyaWdnZXJ8fCExIT09Yy50cmlnZ2VyLmFwcGx5KG4sdCkpKXtpZighciYmIWMubm9CdWJibGUmJiF5KG4pKXtmb3Iocz1jLmRlbGVnYXRlVHlwZXx8ZCxEdC50ZXN0KHMrZCl8fChvPW8ucGFyZW50Tm9kZSk7bztvPW8ucGFyZW50Tm9kZSlwLnB1c2gobyksYT1vO2E9PT0obi5vd25lckRvY3VtZW50fHxDKSYmcC5wdXNoKGEuZGVmYXVsdFZpZXd8fGEucGFyZW50V2luZG93fHxpZSl9aT0wO3doaWxlKChvPXBbaSsrXSkmJiFlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpZj1vLGUudHlwZT0xPGk/czpjLmJpbmRUeXBlfHxkLChsPShfLmdldChvLFwiZXZlbnRzXCIpfHxPYmplY3QuY3JlYXRlKG51bGwpKVtlLnR5cGVdJiZfLmdldChvLFwiaGFuZGxlXCIpKSYmbC5hcHBseShvLHQpLChsPXUmJm9bdV0pJiZsLmFwcGx5JiYkKG8pJiYoZS5yZXN1bHQ9bC5hcHBseShvLHQpLCExPT09ZS5yZXN1bHQmJmUucHJldmVudERlZmF1bHQoKSk7cmV0dXJuIGUudHlwZT1kLHJ8fGUuaXNEZWZhdWx0UHJldmVudGVkKCl8fGMuX2RlZmF1bHQmJiExIT09Yy5fZGVmYXVsdC5hcHBseShwLnBvcCgpLHQpfHwhJChuKXx8dSYmdihuW2RdKSYmIXkobikmJigoYT1uW3VdKSYmKG5bdV09bnVsbCksY2UuZXZlbnQudHJpZ2dlcmVkPWQsZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpJiZmLmFkZEV2ZW50TGlzdGVuZXIoZCxOdCksbltkXSgpLGUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSYmZi5yZW1vdmVFdmVudExpc3RlbmVyKGQsTnQpLGNlLmV2ZW50LnRyaWdnZXJlZD12b2lkIDAsYSYmKG5bdV09YSkpLGUucmVzdWx0fX0sc2ltdWxhdGU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWNlLmV4dGVuZChuZXcgY2UuRXZlbnQsbix7dHlwZTplLGlzU2ltdWxhdGVkOiEwfSk7Y2UuZXZlbnQudHJpZ2dlcihyLG51bGwsdCl9fSksY2UuZm4uZXh0ZW5kKHt0cmlnZ2VyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2NlLmV2ZW50LnRyaWdnZXIoZSx0LHRoaXMpfSl9LHRyaWdnZXJIYW5kbGVyOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpc1swXTtpZihuKXJldHVybiBjZS5ldmVudC50cmlnZ2VyKGUsdCxuLCEwKX19KTt2YXIgcXQ9L1xcW1xcXSQvLEx0PS9cXHI/XFxuL2csSHQ9L14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLE90PS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtmdW5jdGlvbiBQdChuLGUscixpKXt2YXIgdDtpZihBcnJheS5pc0FycmF5KGUpKWNlLmVhY2goZSxmdW5jdGlvbihlLHQpe3J8fHF0LnRlc3Qobik/aShuLHQpOlB0KG4rXCJbXCIrKFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT10P2U6XCJcIikrXCJdXCIsdCxyLGkpfSk7ZWxzZSBpZihyfHxcIm9iamVjdFwiIT09eChlKSlpKG4sZSk7ZWxzZSBmb3IodCBpbiBlKVB0KG4rXCJbXCIrdCtcIl1cIixlW3RdLHIsaSl9Y2UucGFyYW09ZnVuY3Rpb24oZSx0KXt2YXIgbixyPVtdLGk9ZnVuY3Rpb24oZSx0KXt2YXIgbj12KHQpP3QoKTp0O3Jbci5sZW5ndGhdPWVuY29kZVVSSUNvbXBvbmVudChlKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQobnVsbD09bj9cIlwiOm4pfTtpZihudWxsPT1lKXJldHVyblwiXCI7aWYoQXJyYXkuaXNBcnJheShlKXx8ZS5qcXVlcnkmJiFjZS5pc1BsYWluT2JqZWN0KGUpKWNlLmVhY2goZSxmdW5jdGlvbigpe2kodGhpcy5uYW1lLHRoaXMudmFsdWUpfSk7ZWxzZSBmb3IobiBpbiBlKVB0KG4sZVtuXSx0LGkpO3JldHVybiByLmpvaW4oXCImXCIpfSxjZS5mbi5leHRlbmQoe3NlcmlhbGl6ZTpmdW5jdGlvbigpe3JldHVybiBjZS5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpfSxzZXJpYWxpemVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBlPWNlLnByb3AodGhpcyxcImVsZW1lbnRzXCIpO3JldHVybiBlP2NlLm1ha2VBcnJheShlKTp0aGlzfSkuZmlsdGVyKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy50eXBlO3JldHVybiB0aGlzLm5hbWUmJiFjZSh0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSYmT3QudGVzdCh0aGlzLm5vZGVOYW1lKSYmIUh0LnRlc3QoZSkmJih0aGlzLmNoZWNrZWR8fCF3ZS50ZXN0KGUpKX0pLm1hcChmdW5jdGlvbihlLHQpe3ZhciBuPWNlKHRoaXMpLnZhbCgpO3JldHVybiBudWxsPT1uP251bGw6QXJyYXkuaXNBcnJheShuKT9jZS5tYXAobixmdW5jdGlvbihlKXtyZXR1cm57bmFtZTp0Lm5hbWUsdmFsdWU6ZS5yZXBsYWNlKEx0LFwiXFxyXFxuXCIpfX0pOntuYW1lOnQubmFtZSx2YWx1ZTpuLnJlcGxhY2UoTHQsXCJcXHJcXG5cIil9fSkuZ2V0KCl9fSk7dmFyIE10PS8lMjAvZyxSdD0vIy4qJC8sSXQ9LyhbPyZdKV89W14mXSovLFd0PS9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvZ20sRnQ9L14oPzpHRVR8SEVBRCkkLywkdD0vXlxcL1xcLy8sQnQ9e30sX3Q9e30senQ9XCIqL1wiLmNvbmNhdChcIipcIiksWHQ9Qy5jcmVhdGVFbGVtZW50KFwiYVwiKTtmdW5jdGlvbiBVdChvKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtcInN0cmluZ1wiIT10eXBlb2YgZSYmKHQ9ZSxlPVwiKlwiKTt2YXIgbixyPTAsaT1lLnRvTG93ZXJDYXNlKCkubWF0Y2goRCl8fFtdO2lmKHYodCkpd2hpbGUobj1pW3IrK10pXCIrXCI9PT1uWzBdPyhuPW4uc2xpY2UoMSl8fFwiKlwiLChvW25dPW9bbl18fFtdKS51bnNoaWZ0KHQpKToob1tuXT1vW25dfHxbXSkucHVzaCh0KX19ZnVuY3Rpb24gVnQodCxpLG8sYSl7dmFyIHM9e30sdT10PT09X3Q7ZnVuY3Rpb24gbChlKXt2YXIgcjtyZXR1cm4gc1tlXT0hMCxjZS5lYWNoKHRbZV18fFtdLGZ1bmN0aW9uKGUsdCl7dmFyIG49dChpLG8sYSk7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIG58fHV8fHNbbl0/dT8hKHI9bik6dm9pZCAwOihpLmRhdGFUeXBlcy51bnNoaWZ0KG4pLGwobiksITEpfSkscn1yZXR1cm4gbChpLmRhdGFUeXBlc1swXSl8fCFzW1wiKlwiXSYmbChcIipcIil9ZnVuY3Rpb24gR3QoZSx0KXt2YXIgbixyLGk9Y2UuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zfHx7fTtmb3IobiBpbiB0KXZvaWQgMCE9PXRbbl0mJigoaVtuXT9lOnJ8fChyPXt9KSlbbl09dFtuXSk7cmV0dXJuIHImJmNlLmV4dGVuZCghMCxlLHIpLGV9WHQuaHJlZj1FdC5ocmVmLGNlLmV4dGVuZCh7YWN0aXZlOjAsbGFzdE1vZGlmaWVkOnt9LGV0YWc6e30sYWpheFNldHRpbmdzOnt1cmw6RXQuaHJlZix0eXBlOlwiR0VUXCIsaXNMb2NhbDovXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLy50ZXN0KEV0LnByb3RvY29sKSxnbG9iYWw6ITAscHJvY2Vzc0RhdGE6ITAsYXN5bmM6ITAsY29udGVudFR5cGU6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixhY2NlcHRzOntcIipcIjp6dCx0ZXh0OlwidGV4dC9wbGFpblwiLGh0bWw6XCJ0ZXh0L2h0bWxcIix4bWw6XCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsanNvbjpcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwifSxjb250ZW50czp7eG1sOi9cXGJ4bWxcXGIvLGh0bWw6L1xcYmh0bWwvLGpzb246L1xcYmpzb25cXGIvfSxyZXNwb25zZUZpZWxkczp7eG1sOlwicmVzcG9uc2VYTUxcIix0ZXh0OlwicmVzcG9uc2VUZXh0XCIsanNvbjpcInJlc3BvbnNlSlNPTlwifSxjb252ZXJ0ZXJzOntcIiogdGV4dFwiOlN0cmluZyxcInRleHQgaHRtbFwiOiEwLFwidGV4dCBqc29uXCI6SlNPTi5wYXJzZSxcInRleHQgeG1sXCI6Y2UucGFyc2VYTUx9LGZsYXRPcHRpb25zOnt1cmw6ITAsY29udGV4dDohMH19LGFqYXhTZXR1cDpmdW5jdGlvbihlLHQpe3JldHVybiB0P0d0KEd0KGUsY2UuYWpheFNldHRpbmdzKSx0KTpHdChjZS5hamF4U2V0dGluZ3MsZSl9LGFqYXhQcmVmaWx0ZXI6VXQoQnQpLGFqYXhUcmFuc3BvcnQ6VXQoX3QpLGFqYXg6ZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZSYmKHQ9ZSxlPXZvaWQgMCksdD10fHx7fTt2YXIgYyxmLHAsbixkLHIsaCxnLGksbyx2PWNlLmFqYXhTZXR1cCh7fSx0KSx5PXYuY29udGV4dHx8dixtPXYuY29udGV4dCYmKHkubm9kZVR5cGV8fHkuanF1ZXJ5KT9jZSh5KTpjZS5ldmVudCx4PWNlLkRlZmVycmVkKCksYj1jZS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSx3PXYuc3RhdHVzQ29kZXx8e30sYT17fSxzPXt9LHU9XCJjYW5jZWxlZFwiLFQ9e3JlYWR5U3RhdGU6MCxnZXRSZXNwb25zZUhlYWRlcjpmdW5jdGlvbihlKXt2YXIgdDtpZihoKXtpZighbil7bj17fTt3aGlsZSh0PVd0LmV4ZWMocCkpblt0WzFdLnRvTG93ZXJDYXNlKCkrXCIgXCJdPShuW3RbMV0udG9Mb3dlckNhc2UoKStcIiBcIl18fFtdKS5jb25jYXQodFsyXSl9dD1uW2UudG9Mb3dlckNhc2UoKStcIiBcIl19cmV0dXJuIG51bGw9PXQ/bnVsbDp0LmpvaW4oXCIsIFwiKX0sZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIGg/cDpudWxsfSxzZXRSZXF1ZXN0SGVhZGVyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGw9PWgmJihlPXNbZS50b0xvd2VyQ2FzZSgpXT1zW2UudG9Mb3dlckNhc2UoKV18fGUsYVtlXT10KSx0aGlzfSxvdmVycmlkZU1pbWVUeXBlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1oJiYodi5taW1lVHlwZT1lKSx0aGlzfSxzdGF0dXNDb2RlOmZ1bmN0aW9uKGUpe3ZhciB0O2lmKGUpaWYoaClULmFsd2F5cyhlW1Quc3RhdHVzXSk7ZWxzZSBmb3IodCBpbiBlKXdbdF09W3dbdF0sZVt0XV07cmV0dXJuIHRoaXN9LGFib3J0OmZ1bmN0aW9uKGUpe3ZhciB0PWV8fHU7cmV0dXJuIGMmJmMuYWJvcnQodCksbCgwLHQpLHRoaXN9fTtpZih4LnByb21pc2UoVCksdi51cmw9KChlfHx2LnVybHx8RXQuaHJlZikrXCJcIikucmVwbGFjZSgkdCxFdC5wcm90b2NvbCtcIi8vXCIpLHYudHlwZT10Lm1ldGhvZHx8dC50eXBlfHx2Lm1ldGhvZHx8di50eXBlLHYuZGF0YVR5cGVzPSh2LmRhdGFUeXBlfHxcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChEKXx8W1wiXCJdLG51bGw9PXYuY3Jvc3NEb21haW4pe3I9Qy5jcmVhdGVFbGVtZW50KFwiYVwiKTt0cnl7ci5ocmVmPXYudXJsLHIuaHJlZj1yLmhyZWYsdi5jcm9zc0RvbWFpbj1YdC5wcm90b2NvbCtcIi8vXCIrWHQuaG9zdCE9ci5wcm90b2NvbCtcIi8vXCIrci5ob3N0fWNhdGNoKGUpe3YuY3Jvc3NEb21haW49ITB9fWlmKHYuZGF0YSYmdi5wcm9jZXNzRGF0YSYmXCJzdHJpbmdcIiE9dHlwZW9mIHYuZGF0YSYmKHYuZGF0YT1jZS5wYXJhbSh2LmRhdGEsdi50cmFkaXRpb25hbCkpLFZ0KEJ0LHYsdCxUKSxoKXJldHVybiBUO2ZvcihpIGluKGc9Y2UuZXZlbnQmJnYuZ2xvYmFsKSYmMD09Y2UuYWN0aXZlKysmJmNlLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIiksdi50eXBlPXYudHlwZS50b1VwcGVyQ2FzZSgpLHYuaGFzQ29udGVudD0hRnQudGVzdCh2LnR5cGUpLGY9di51cmwucmVwbGFjZShSdCxcIlwiKSx2Lmhhc0NvbnRlbnQ/di5kYXRhJiZ2LnByb2Nlc3NEYXRhJiYwPT09KHYuY29udGVudFR5cGV8fFwiXCIpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikmJih2LmRhdGE9di5kYXRhLnJlcGxhY2UoTXQsXCIrXCIpKToobz12LnVybC5zbGljZShmLmxlbmd0aCksdi5kYXRhJiYodi5wcm9jZXNzRGF0YXx8XCJzdHJpbmdcIj09dHlwZW9mIHYuZGF0YSkmJihmKz0oQXQudGVzdChmKT9cIiZcIjpcIj9cIikrdi5kYXRhLGRlbGV0ZSB2LmRhdGEpLCExPT09di5jYWNoZSYmKGY9Zi5yZXBsYWNlKEl0LFwiJDFcIiksbz0oQXQudGVzdChmKT9cIiZcIjpcIj9cIikrXCJfPVwiK2p0Lmd1aWQrKytvKSx2LnVybD1mK28pLHYuaWZNb2RpZmllZCYmKGNlLmxhc3RNb2RpZmllZFtmXSYmVC5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIixjZS5sYXN0TW9kaWZpZWRbZl0pLGNlLmV0YWdbZl0mJlQuc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIixjZS5ldGFnW2ZdKSksKHYuZGF0YSYmdi5oYXNDb250ZW50JiYhMSE9PXYuY29udGVudFR5cGV8fHQuY29udGVudFR5cGUpJiZULnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIix2LmNvbnRlbnRUeXBlKSxULnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIix2LmRhdGFUeXBlc1swXSYmdi5hY2NlcHRzW3YuZGF0YVR5cGVzWzBdXT92LmFjY2VwdHNbdi5kYXRhVHlwZXNbMF1dKyhcIipcIiE9PXYuZGF0YVR5cGVzWzBdP1wiLCBcIit6dCtcIjsgcT0wLjAxXCI6XCJcIik6di5hY2NlcHRzW1wiKlwiXSksdi5oZWFkZXJzKVQuc2V0UmVxdWVzdEhlYWRlcihpLHYuaGVhZGVyc1tpXSk7aWYodi5iZWZvcmVTZW5kJiYoITE9PT12LmJlZm9yZVNlbmQuY2FsbCh5LFQsdil8fGgpKXJldHVybiBULmFib3J0KCk7aWYodT1cImFib3J0XCIsYi5hZGQodi5jb21wbGV0ZSksVC5kb25lKHYuc3VjY2VzcyksVC5mYWlsKHYuZXJyb3IpLGM9VnQoX3Qsdix0LFQpKXtpZihULnJlYWR5U3RhdGU9MSxnJiZtLnRyaWdnZXIoXCJhamF4U2VuZFwiLFtULHZdKSxoKXJldHVybiBUO3YuYXN5bmMmJjA8di50aW1lb3V0JiYoZD1pZS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7VC5hYm9ydChcInRpbWVvdXRcIil9LHYudGltZW91dCkpO3RyeXtoPSExLGMuc2VuZChhLGwpfWNhdGNoKGUpe2lmKGgpdGhyb3cgZTtsKC0xLGUpfX1lbHNlIGwoLTEsXCJObyBUcmFuc3BvcnRcIik7ZnVuY3Rpb24gbChlLHQsbixyKXt2YXIgaSxvLGEscyx1LGw9dDtofHwoaD0hMCxkJiZpZS5jbGVhclRpbWVvdXQoZCksYz12b2lkIDAscD1yfHxcIlwiLFQucmVhZHlTdGF0ZT0wPGU/NDowLGk9MjAwPD1lJiZlPDMwMHx8MzA0PT09ZSxuJiYocz1mdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGEscz1lLmNvbnRlbnRzLHU9ZS5kYXRhVHlwZXM7d2hpbGUoXCIqXCI9PT11WzBdKXUuc2hpZnQoKSx2b2lkIDA9PT1yJiYocj1lLm1pbWVUeXBlfHx0LmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpKTtpZihyKWZvcihpIGluIHMpaWYoc1tpXSYmc1tpXS50ZXN0KHIpKXt1LnVuc2hpZnQoaSk7YnJlYWt9aWYodVswXWluIG4pbz11WzBdO2Vsc2V7Zm9yKGkgaW4gbil7aWYoIXVbMF18fGUuY29udmVydGVyc1tpK1wiIFwiK3VbMF1dKXtvPWk7YnJlYWt9YXx8KGE9aSl9bz1vfHxhfWlmKG8pcmV0dXJuIG8hPT11WzBdJiZ1LnVuc2hpZnQobyksbltvXX0odixULG4pKSwhaSYmLTE8Y2UuaW5BcnJheShcInNjcmlwdFwiLHYuZGF0YVR5cGVzKSYmY2UuaW5BcnJheShcImpzb25cIix2LmRhdGFUeXBlcyk8MCYmKHYuY29udmVydGVyc1tcInRleHQgc2NyaXB0XCJdPWZ1bmN0aW9uKCl7fSkscz1mdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvLGEscyx1LGw9e30sYz1lLmRhdGFUeXBlcy5zbGljZSgpO2lmKGNbMV0pZm9yKGEgaW4gZS5jb252ZXJ0ZXJzKWxbYS50b0xvd2VyQ2FzZSgpXT1lLmNvbnZlcnRlcnNbYV07bz1jLnNoaWZ0KCk7d2hpbGUobylpZihlLnJlc3BvbnNlRmllbGRzW29dJiYobltlLnJlc3BvbnNlRmllbGRzW29dXT10KSwhdSYmciYmZS5kYXRhRmlsdGVyJiYodD1lLmRhdGFGaWx0ZXIodCxlLmRhdGFUeXBlKSksdT1vLG89Yy5zaGlmdCgpKWlmKFwiKlwiPT09bylvPXU7ZWxzZSBpZihcIipcIiE9PXUmJnUhPT1vKXtpZighKGE9bFt1K1wiIFwiK29dfHxsW1wiKiBcIitvXSkpZm9yKGkgaW4gbClpZigocz1pLnNwbGl0KFwiIFwiKSlbMV09PT1vJiYoYT1sW3UrXCIgXCIrc1swXV18fGxbXCIqIFwiK3NbMF1dKSl7ITA9PT1hP2E9bFtpXTohMCE9PWxbaV0mJihvPXNbMF0sYy51bnNoaWZ0KHNbMV0pKTticmVha31pZighMCE9PWEpaWYoYSYmZVtcInRocm93c1wiXSl0PWEodCk7ZWxzZSB0cnl7dD1hKHQpfWNhdGNoKGUpe3JldHVybntzdGF0ZTpcInBhcnNlcmVycm9yXCIsZXJyb3I6YT9lOlwiTm8gY29udmVyc2lvbiBmcm9tIFwiK3UrXCIgdG8gXCIrb319fXJldHVybntzdGF0ZTpcInN1Y2Nlc3NcIixkYXRhOnR9fSh2LHMsVCxpKSxpPyh2LmlmTW9kaWZpZWQmJigodT1ULmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKSkmJihjZS5sYXN0TW9kaWZpZWRbZl09dSksKHU9VC5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIikpJiYoY2UuZXRhZ1tmXT11KSksMjA0PT09ZXx8XCJIRUFEXCI9PT12LnR5cGU/bD1cIm5vY29udGVudFwiOjMwND09PWU/bD1cIm5vdG1vZGlmaWVkXCI6KGw9cy5zdGF0ZSxvPXMuZGF0YSxpPSEoYT1zLmVycm9yKSkpOihhPWwsIWUmJmx8fChsPVwiZXJyb3JcIixlPDAmJihlPTApKSksVC5zdGF0dXM9ZSxULnN0YXR1c1RleHQ9KHR8fGwpK1wiXCIsaT94LnJlc29sdmVXaXRoKHksW28sbCxUXSk6eC5yZWplY3RXaXRoKHksW1QsbCxhXSksVC5zdGF0dXNDb2RlKHcpLHc9dm9pZCAwLGcmJm0udHJpZ2dlcihpP1wiYWpheFN1Y2Nlc3NcIjpcImFqYXhFcnJvclwiLFtULHYsaT9vOmFdKSxiLmZpcmVXaXRoKHksW1QsbF0pLGcmJihtLnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIixbVCx2XSksLS1jZS5hY3RpdmV8fGNlLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpfXJldHVybiBUfSxnZXRKU09OOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gY2UuZ2V0KGUsdCxuLFwianNvblwiKX0sZ2V0U2NyaXB0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGNlLmdldChlLHZvaWQgMCx0LFwic2NyaXB0XCIpfX0pLGNlLmVhY2goW1wiZ2V0XCIsXCJwb3N0XCJdLGZ1bmN0aW9uKGUsaSl7Y2VbaV09ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHYodCkmJihyPXJ8fG4sbj10LHQ9dm9pZCAwKSxjZS5hamF4KGNlLmV4dGVuZCh7dXJsOmUsdHlwZTppLGRhdGFUeXBlOnIsZGF0YTp0LHN1Y2Nlc3M6bn0sY2UuaXNQbGFpbk9iamVjdChlKSYmZSkpfX0pLGNlLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24oZSl7dmFyIHQ7Zm9yKHQgaW4gZS5oZWFkZXJzKVwiY29udGVudC10eXBlXCI9PT10LnRvTG93ZXJDYXNlKCkmJihlLmNvbnRlbnRUeXBlPWUuaGVhZGVyc1t0XXx8XCJcIil9KSxjZS5fZXZhbFVybD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGNlLmFqYXgoe3VybDplLHR5cGU6XCJHRVRcIixkYXRhVHlwZTpcInNjcmlwdFwiLGNhY2hlOiEwLGFzeW5jOiExLGdsb2JhbDohMSxjb252ZXJ0ZXJzOntcInRleHQgc2NyaXB0XCI6ZnVuY3Rpb24oKXt9fSxkYXRhRmlsdGVyOmZ1bmN0aW9uKGUpe2NlLmdsb2JhbEV2YWwoZSx0LG4pfX0pfSxjZS5mbi5leHRlbmQoe3dyYXBBbGw6ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIHRoaXNbMF0mJih2KGUpJiYoZT1lLmNhbGwodGhpc1swXSkpLHQ9Y2UoZSx0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSx0aGlzWzBdLnBhcmVudE5vZGUmJnQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLHQubWFwKGZ1bmN0aW9uKCl7dmFyIGU9dGhpczt3aGlsZShlLmZpcnN0RWxlbWVudENoaWxkKWU9ZS5maXJzdEVsZW1lbnRDaGlsZDtyZXR1cm4gZX0pLmFwcGVuZCh0aGlzKSksdGhpc30sd3JhcElubmVyOmZ1bmN0aW9uKG4pe3JldHVybiB2KG4pP3RoaXMuZWFjaChmdW5jdGlvbihlKXtjZSh0aGlzKS53cmFwSW5uZXIobi5jYWxsKHRoaXMsZSkpfSk6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9Y2UodGhpcyksdD1lLmNvbnRlbnRzKCk7dC5sZW5ndGg/dC53cmFwQWxsKG4pOmUuYXBwZW5kKG4pfSl9LHdyYXA6ZnVuY3Rpb24odCl7dmFyIG49dih0KTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGUpe2NlKHRoaXMpLndyYXBBbGwobj90LmNhbGwodGhpcyxlKTp0KX0pfSx1bndyYXA6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucGFyZW50KGUpLm5vdChcImJvZHlcIikuZWFjaChmdW5jdGlvbigpe2NlKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyl9KSx0aGlzfX0pLGNlLmV4cHIucHNldWRvcy5oaWRkZW49ZnVuY3Rpb24oZSl7cmV0dXJuIWNlLmV4cHIucHNldWRvcy52aXNpYmxlKGUpfSxjZS5leHByLnBzZXVkb3MudmlzaWJsZT1mdW5jdGlvbihlKXtyZXR1cm4hIShlLm9mZnNldFdpZHRofHxlLm9mZnNldEhlaWdodHx8ZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCl9LGNlLmFqYXhTZXR0aW5ncy54aHI9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIG5ldyBpZS5YTUxIdHRwUmVxdWVzdH1jYXRjaChlKXt9fTt2YXIgWXQ9ezA6MjAwLDEyMjM6MjA0fSxRdD1jZS5hamF4U2V0dGluZ3MueGhyKCk7bGUuY29ycz0hIVF0JiZcIndpdGhDcmVkZW50aWFsc1wiaW4gUXQsbGUuYWpheD1RdD0hIVF0LGNlLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oaSl7dmFyIG8sYTtpZihsZS5jb3JzfHxRdCYmIWkuY3Jvc3NEb21haW4pcmV0dXJue3NlbmQ6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPWkueGhyKCk7aWYoci5vcGVuKGkudHlwZSxpLnVybCxpLmFzeW5jLGkudXNlcm5hbWUsaS5wYXNzd29yZCksaS54aHJGaWVsZHMpZm9yKG4gaW4gaS54aHJGaWVsZHMpcltuXT1pLnhockZpZWxkc1tuXTtmb3IobiBpbiBpLm1pbWVUeXBlJiZyLm92ZXJyaWRlTWltZVR5cGUmJnIub3ZlcnJpZGVNaW1lVHlwZShpLm1pbWVUeXBlKSxpLmNyb3NzRG9tYWlufHxlW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXXx8KGVbXCJYLVJlcXVlc3RlZC1XaXRoXCJdPVwiWE1MSHR0cFJlcXVlc3RcIiksZSlyLnNldFJlcXVlc3RIZWFkZXIobixlW25dKTtvPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbigpe28mJihvPWE9ci5vbmxvYWQ9ci5vbmVycm9yPXIub25hYm9ydD1yLm9udGltZW91dD1yLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLFwiYWJvcnRcIj09PWU/ci5hYm9ydCgpOlwiZXJyb3JcIj09PWU/XCJudW1iZXJcIiE9dHlwZW9mIHIuc3RhdHVzP3QoMCxcImVycm9yXCIpOnQoci5zdGF0dXMsci5zdGF0dXNUZXh0KTp0KFl0W3Iuc3RhdHVzXXx8ci5zdGF0dXMsci5zdGF0dXNUZXh0LFwidGV4dFwiIT09KHIucmVzcG9uc2VUeXBlfHxcInRleHRcIil8fFwic3RyaW5nXCIhPXR5cGVvZiByLnJlc3BvbnNlVGV4dD97YmluYXJ5OnIucmVzcG9uc2V9Ont0ZXh0OnIucmVzcG9uc2VUZXh0fSxyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSl9fSxyLm9ubG9hZD1vKCksYT1yLm9uZXJyb3I9ci5vbnRpbWVvdXQ9byhcImVycm9yXCIpLHZvaWQgMCE9PXIub25hYm9ydD9yLm9uYWJvcnQ9YTpyLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpezQ9PT1yLnJlYWR5U3RhdGUmJmllLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtvJiZhKCl9KX0sbz1vKFwiYWJvcnRcIik7dHJ5e3Iuc2VuZChpLmhhc0NvbnRlbnQmJmkuZGF0YXx8bnVsbCl9Y2F0Y2goZSl7aWYobyl0aHJvdyBlfX0sYWJvcnQ6ZnVuY3Rpb24oKXtvJiZvKCl9fX0pLGNlLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24oZSl7ZS5jcm9zc0RvbWFpbiYmKGUuY29udGVudHMuc2NyaXB0PSExKX0pLGNlLmFqYXhTZXR1cCh7YWNjZXB0czp7c2NyaXB0OlwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIn0sY29udGVudHM6e3NjcmlwdDovXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi99LGNvbnZlcnRlcnM6e1widGV4dCBzY3JpcHRcIjpmdW5jdGlvbihlKXtyZXR1cm4gY2UuZ2xvYmFsRXZhbChlKSxlfX19KSxjZS5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsZnVuY3Rpb24oZSl7dm9pZCAwPT09ZS5jYWNoZSYmKGUuY2FjaGU9ITEpLGUuY3Jvc3NEb21haW4mJihlLnR5cGU9XCJHRVRcIil9KSxjZS5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsZnVuY3Rpb24obil7dmFyIHIsaTtpZihuLmNyb3NzRG9tYWlufHxuLnNjcmlwdEF0dHJzKXJldHVybntzZW5kOmZ1bmN0aW9uKGUsdCl7cj1jZShcIjxzY3JpcHQ+XCIpLmF0dHIobi5zY3JpcHRBdHRyc3x8e30pLnByb3Aoe2NoYXJzZXQ6bi5zY3JpcHRDaGFyc2V0LHNyYzpuLnVybH0pLm9uKFwibG9hZCBlcnJvclwiLGk9ZnVuY3Rpb24oZSl7ci5yZW1vdmUoKSxpPW51bGwsZSYmdChcImVycm9yXCI9PT1lLnR5cGU/NDA0OjIwMCxlLnR5cGUpfSksQy5oZWFkLmFwcGVuZENoaWxkKHJbMF0pfSxhYm9ydDpmdW5jdGlvbigpe2kmJmkoKX19fSk7dmFyIEp0LEt0PVtdLFp0PS8oPSlcXD8oPz0mfCQpfFxcP1xcPy87Y2UuYWpheFNldHVwKHtqc29ucDpcImNhbGxiYWNrXCIsanNvbnBDYWxsYmFjazpmdW5jdGlvbigpe3ZhciBlPUt0LnBvcCgpfHxjZS5leHBhbmRvK1wiX1wiK2p0Lmd1aWQrKztyZXR1cm4gdGhpc1tlXT0hMCxlfX0pLGNlLmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhPSExIT09ZS5qc29ucCYmKFp0LnRlc3QoZS51cmwpP1widXJsXCI6XCJzdHJpbmdcIj09dHlwZW9mIGUuZGF0YSYmMD09PShlLmNvbnRlbnRUeXBlfHxcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpJiZadC50ZXN0KGUuZGF0YSkmJlwiZGF0YVwiKTtpZihhfHxcImpzb25wXCI9PT1lLmRhdGFUeXBlc1swXSlyZXR1cm4gcj1lLmpzb25wQ2FsbGJhY2s9dihlLmpzb25wQ2FsbGJhY2spP2UuanNvbnBDYWxsYmFjaygpOmUuanNvbnBDYWxsYmFjayxhP2VbYV09ZVthXS5yZXBsYWNlKFp0LFwiJDFcIityKTohMSE9PWUuanNvbnAmJihlLnVybCs9KEF0LnRlc3QoZS51cmwpP1wiJlwiOlwiP1wiKStlLmpzb25wK1wiPVwiK3IpLGUuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdPWZ1bmN0aW9uKCl7cmV0dXJuIG98fGNlLmVycm9yKHIrXCIgd2FzIG5vdCBjYWxsZWRcIiksb1swXX0sZS5kYXRhVHlwZXNbMF09XCJqc29uXCIsaT1pZVtyXSxpZVtyXT1mdW5jdGlvbigpe289YXJndW1lbnRzfSxuLmFsd2F5cyhmdW5jdGlvbigpe3ZvaWQgMD09PWk/Y2UoaWUpLnJlbW92ZVByb3Aocik6aWVbcl09aSxlW3JdJiYoZS5qc29ucENhbGxiYWNrPXQuanNvbnBDYWxsYmFjayxLdC5wdXNoKHIpKSxvJiZ2KGkpJiZpKG9bMF0pLG89aT12b2lkIDB9KSxcInNjcmlwdFwifSksbGUuY3JlYXRlSFRNTERvY3VtZW50PSgoSnQ9Qy5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikuYm9keSkuaW5uZXJIVE1MPVwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIiwyPT09SnQuY2hpbGROb2Rlcy5sZW5ndGgpLGNlLnBhcnNlSFRNTD1mdW5jdGlvbihlLHQsbil7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGU/W106KFwiYm9vbGVhblwiPT10eXBlb2YgdCYmKG49dCx0PSExKSx0fHwobGUuY3JlYXRlSFRNTERvY3VtZW50Pygocj0odD1DLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKSkuY3JlYXRlRWxlbWVudChcImJhc2VcIikpLmhyZWY9Qy5sb2NhdGlvbi5ocmVmLHQuaGVhZC5hcHBlbmRDaGlsZChyKSk6dD1DKSxvPSFuJiZbXSwoaT13LmV4ZWMoZSkpP1t0LmNyZWF0ZUVsZW1lbnQoaVsxXSldOihpPUFlKFtlXSx0LG8pLG8mJm8ubGVuZ3RoJiZjZShvKS5yZW1vdmUoKSxjZS5tZXJnZShbXSxpLmNoaWxkTm9kZXMpKSk7dmFyIHIsaSxvfSxjZS5mbi5sb2FkPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYT10aGlzLHM9ZS5pbmRleE9mKFwiIFwiKTtyZXR1cm4tMTxzJiYocj1UdChlLnNsaWNlKHMpKSxlPWUuc2xpY2UoMCxzKSksdih0KT8obj10LHQ9dm9pZCAwKTp0JiZcIm9iamVjdFwiPT10eXBlb2YgdCYmKGk9XCJQT1NUXCIpLDA8YS5sZW5ndGgmJmNlLmFqYXgoe3VybDplLHR5cGU6aXx8XCJHRVRcIixkYXRhVHlwZTpcImh0bWxcIixkYXRhOnR9KS5kb25lKGZ1bmN0aW9uKGUpe289YXJndW1lbnRzLGEuaHRtbChyP2NlKFwiPGRpdj5cIikuYXBwZW5kKGNlLnBhcnNlSFRNTChlKSkuZmluZChyKTplKX0pLmFsd2F5cyhuJiZmdW5jdGlvbihlLHQpe2EuZWFjaChmdW5jdGlvbigpe24uYXBwbHkodGhpcyxvfHxbZS5yZXNwb25zZVRleHQsdCxlXSl9KX0pLHRoaXN9LGNlLmV4cHIucHNldWRvcy5hbmltYXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gY2UuZ3JlcChjZS50aW1lcnMsZnVuY3Rpb24oZSl7cmV0dXJuIHQ9PT1lLmVsZW19KS5sZW5ndGh9LGNlLm9mZnNldD17c2V0T2Zmc2V0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzLHUsbD1jZS5jc3MoZSxcInBvc2l0aW9uXCIpLGM9Y2UoZSksZj17fTtcInN0YXRpY1wiPT09bCYmKGUuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiKSxzPWMub2Zmc2V0KCksbz1jZS5jc3MoZSxcInRvcFwiKSx1PWNlLmNzcyhlLFwibGVmdFwiKSwoXCJhYnNvbHV0ZVwiPT09bHx8XCJmaXhlZFwiPT09bCkmJi0xPChvK3UpLmluZGV4T2YoXCJhdXRvXCIpPyhhPShyPWMucG9zaXRpb24oKSkudG9wLGk9ci5sZWZ0KTooYT1wYXJzZUZsb2F0KG8pfHwwLGk9cGFyc2VGbG9hdCh1KXx8MCksdih0KSYmKHQ9dC5jYWxsKGUsbixjZS5leHRlbmQoe30scykpKSxudWxsIT10LnRvcCYmKGYudG9wPXQudG9wLXMudG9wK2EpLG51bGwhPXQubGVmdCYmKGYubGVmdD10LmxlZnQtcy5sZWZ0K2kpLFwidXNpbmdcImluIHQ/dC51c2luZy5jYWxsKGUsZik6Yy5jc3MoZil9fSxjZS5mbi5leHRlbmQoe29mZnNldDpmdW5jdGlvbih0KXtpZihhcmd1bWVudHMubGVuZ3RoKXJldHVybiB2b2lkIDA9PT10P3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKGUpe2NlLm9mZnNldC5zZXRPZmZzZXQodGhpcyx0LGUpfSk7dmFyIGUsbixyPXRoaXNbMF07cmV0dXJuIHI/ci5nZXRDbGllbnRSZWN0cygpLmxlbmd0aD8oZT1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49ci5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LHt0b3A6ZS50b3Arbi5wYWdlWU9mZnNldCxsZWZ0OmUubGVmdCtuLnBhZ2VYT2Zmc2V0fSk6e3RvcDowLGxlZnQ6MH06dm9pZCAwfSxwb3NpdGlvbjpmdW5jdGlvbigpe2lmKHRoaXNbMF0pe3ZhciBlLHQsbixyPXRoaXNbMF0saT17dG9wOjAsbGVmdDowfTtpZihcImZpeGVkXCI9PT1jZS5jc3MocixcInBvc2l0aW9uXCIpKXQ9ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtlbHNle3Q9dGhpcy5vZmZzZXQoKSxuPXIub3duZXJEb2N1bWVudCxlPXIub2Zmc2V0UGFyZW50fHxuLmRvY3VtZW50RWxlbWVudDt3aGlsZShlJiYoZT09PW4uYm9keXx8ZT09PW4uZG9jdW1lbnRFbGVtZW50KSYmXCJzdGF0aWNcIj09PWNlLmNzcyhlLFwicG9zaXRpb25cIikpZT1lLnBhcmVudE5vZGU7ZSYmZSE9PXImJjE9PT1lLm5vZGVUeXBlJiYoKGk9Y2UoZSkub2Zmc2V0KCkpLnRvcCs9Y2UuY3NzKGUsXCJib3JkZXJUb3BXaWR0aFwiLCEwKSxpLmxlZnQrPWNlLmNzcyhlLFwiYm9yZGVyTGVmdFdpZHRoXCIsITApKX1yZXR1cm57dG9wOnQudG9wLWkudG9wLWNlLmNzcyhyLFwibWFyZ2luVG9wXCIsITApLGxlZnQ6dC5sZWZ0LWkubGVmdC1jZS5jc3MocixcIm1hcmdpbkxlZnRcIiwhMCl9fX0sb2Zmc2V0UGFyZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vZmZzZXRQYXJlbnQ7d2hpbGUoZSYmXCJzdGF0aWNcIj09PWNlLmNzcyhlLFwicG9zaXRpb25cIikpZT1lLm9mZnNldFBhcmVudDtyZXR1cm4gZXx8Sn0pfX0pLGNlLmVhY2goe3Njcm9sbExlZnQ6XCJwYWdlWE9mZnNldFwiLHNjcm9sbFRvcDpcInBhZ2VZT2Zmc2V0XCJ9LGZ1bmN0aW9uKHQsaSl7dmFyIG89XCJwYWdlWU9mZnNldFwiPT09aTtjZS5mblt0XT1mdW5jdGlvbihlKXtyZXR1cm4gTSh0aGlzLGZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtpZih5KGUpP3I9ZTo5PT09ZS5ub2RlVHlwZSYmKHI9ZS5kZWZhdWx0Vmlldyksdm9pZCAwPT09bilyZXR1cm4gcj9yW2ldOmVbdF07cj9yLnNjcm9sbFRvKG8/ci5wYWdlWE9mZnNldDpuLG8/bjpyLnBhZ2VZT2Zmc2V0KTplW3RdPW59LHQsZSxhcmd1bWVudHMubGVuZ3RoKX19KSxjZS5lYWNoKFtcInRvcFwiLFwibGVmdFwiXSxmdW5jdGlvbihlLG4pe2NlLmNzc0hvb2tzW25dPVllKGxlLnBpeGVsUG9zaXRpb24sZnVuY3Rpb24oZSx0KXtpZih0KXJldHVybiB0PUdlKGUsbiksX2UudGVzdCh0KT9jZShlKS5wb3NpdGlvbigpW25dK1wicHhcIjp0fSl9KSxjZS5lYWNoKHtIZWlnaHQ6XCJoZWlnaHRcIixXaWR0aDpcIndpZHRoXCJ9LGZ1bmN0aW9uKGEscyl7Y2UuZWFjaCh7cGFkZGluZzpcImlubmVyXCIrYSxjb250ZW50OnMsXCJcIjpcIm91dGVyXCIrYX0sZnVuY3Rpb24ocixvKXtjZS5mbltvXT1mdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgmJihyfHxcImJvb2xlYW5cIiE9dHlwZW9mIGUpLGk9cnx8KCEwPT09ZXx8ITA9PT10P1wibWFyZ2luXCI6XCJib3JkZXJcIik7cmV0dXJuIE0odGhpcyxmdW5jdGlvbihlLHQsbil7dmFyIHI7cmV0dXJuIHkoZSk/MD09PW8uaW5kZXhPZihcIm91dGVyXCIpP2VbXCJpbm5lclwiK2FdOmUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIrYV06OT09PWUubm9kZVR5cGU/KHI9ZS5kb2N1bWVudEVsZW1lbnQsTWF0aC5tYXgoZS5ib2R5W1wic2Nyb2xsXCIrYV0scltcInNjcm9sbFwiK2FdLGUuYm9keVtcIm9mZnNldFwiK2FdLHJbXCJvZmZzZXRcIithXSxyW1wiY2xpZW50XCIrYV0pKTp2b2lkIDA9PT1uP2NlLmNzcyhlLHQsaSk6Y2Uuc3R5bGUoZSx0LG4saSl9LHMsbj9lOnZvaWQgMCxuKX19KX0pLGNlLmVhY2goW1wiYWpheFN0YXJ0XCIsXCJhamF4U3RvcFwiLFwiYWpheENvbXBsZXRlXCIsXCJhamF4RXJyb3JcIixcImFqYXhTdWNjZXNzXCIsXCJhamF4U2VuZFwiXSxmdW5jdGlvbihlLHQpe2NlLmZuW3RdPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9uKHQsZSl9fSksY2UuZm4uZXh0ZW5kKHtiaW5kOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy5vbihlLG51bGwsdCxuKX0sdW5iaW5kOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMub2ZmKGUsbnVsbCx0KX0sZGVsZWdhdGU6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHRoaXMub24odCxlLG4scil9LHVuZGVsZWdhdGU6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aD90aGlzLm9mZihlLFwiKipcIik6dGhpcy5vZmYodCxlfHxcIioqXCIsbil9LGhvdmVyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMub24oXCJtb3VzZWVudGVyXCIsZSkub24oXCJtb3VzZWxlYXZlXCIsdHx8ZSl9fSksY2UuZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oZSxuKXtjZS5mbltuXT1mdW5jdGlvbihlLHQpe3JldHVybiAwPGFyZ3VtZW50cy5sZW5ndGg/dGhpcy5vbihuLG51bGwsZSx0KTp0aGlzLnRyaWdnZXIobil9fSk7dmFyIGVuPS9eW1xcc1xcdUZFRkZcXHhBMF0rfChbXlxcc1xcdUZFRkZcXHhBMF0pW1xcc1xcdUZFRkZcXHhBMF0rJC9nO2NlLnByb3h5PWZ1bmN0aW9uKGUsdCl7dmFyIG4scixpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYobj1lW3RdLHQ9ZSxlPW4pLHYoZSkpcmV0dXJuIHI9YWUuY2FsbChhcmd1bWVudHMsMiksKGk9ZnVuY3Rpb24oKXtyZXR1cm4gZS5hcHBseSh0fHx0aGlzLHIuY29uY2F0KGFlLmNhbGwoYXJndW1lbnRzKSkpfSkuZ3VpZD1lLmd1aWQ9ZS5ndWlkfHxjZS5ndWlkKyssaX0sY2UuaG9sZFJlYWR5PWZ1bmN0aW9uKGUpe2U/Y2UucmVhZHlXYWl0Kys6Y2UucmVhZHkoITApfSxjZS5pc0FycmF5PUFycmF5LmlzQXJyYXksY2UucGFyc2VKU09OPUpTT04ucGFyc2UsY2Uubm9kZU5hbWU9ZmUsY2UuaXNGdW5jdGlvbj12LGNlLmlzV2luZG93PXksY2UuY2FtZWxDYXNlPUYsY2UudHlwZT14LGNlLm5vdz1EYXRlLm5vdyxjZS5pc051bWVyaWM9ZnVuY3Rpb24oZSl7dmFyIHQ9Y2UudHlwZShlKTtyZXR1cm4oXCJudW1iZXJcIj09PXR8fFwic3RyaW5nXCI9PT10KSYmIWlzTmFOKGUtcGFyc2VGbG9hdChlKSl9LGNlLnRyaW09ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/XCJcIjooZStcIlwiKS5yZXBsYWNlKGVuLFwiJDFcIil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZCYmZGVmaW5lKFwianF1ZXJ5XCIsW10sZnVuY3Rpb24oKXtyZXR1cm4gY2V9KTt2YXIgdG49aWUualF1ZXJ5LG5uPWllLiQ7cmV0dXJuIGNlLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGllLiQ9PT1jZSYmKGllLiQ9bm4pLGUmJmllLmpRdWVyeT09PWNlJiYoaWUualF1ZXJ5PXRuKSxjZX0sXCJ1bmRlZmluZWRcIj09dHlwZW9mIGUmJihpZS5qUXVlcnk9aWUuJD1jZSksY2V9KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSwgYXRTdGFydCwgZ3VhcmFudGVlKSB7XG4gIHZhciB0aW1lb3V0O1xuICB2YXIgYXJncztcbiAgdmFyIHNlbGY7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICBzZWxmID0gdGhpcztcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGlmICh0aW1lb3V0ICYmIChhdFN0YXJ0IHx8IGd1YXJhbnRlZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKCFhdFN0YXJ0KSB7XG4gICAgICBjbGVhcigpO1xuXG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChydW4sIGRlbGF5KTtcbiAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH1cblxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFyLCBkZWxheSk7XG4gICAgZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICBmdW5jdGlvbiBydW4oKSB7XG4gICAgICBjbGVhcigpO1xuICAgICAgZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNy4wIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxubW9kdWxlLmV4cG9ydHMgPSByZUludGVycG9sYXRlO1xuIiwiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL29wZW5qc2Yub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xudmFyIHJlSW50ZXJwb2xhdGUgPSByZXF1aXJlKCdsb2Rhc2guX3JlaW50ZXJwb2xhdGUnKSxcbiAgICB0ZW1wbGF0ZVNldHRpbmdzID0gcmVxdWlyZSgnbG9kYXNoLnRlbXBsYXRlc2V0dGluZ3MnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG52YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaFxuICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAqL1xudmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICdcXFxcJzogJ1xcXFwnLFxuICBcIidcIjogXCInXCIsXG4gICdcXG4nOiAnbicsXG4gICdcXHInOiAncicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFcnJvcihFcnJvcik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGV4dGVuZFdpdGhcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICogfVxuICpcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAqXG4gKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAqXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gKlxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gKlxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAqXG4gKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAqXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICpcbiAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICogY29tcGlsZWQoZGF0YSk7XG4gKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICpcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICogY29tcGlsZWQuc291cmNlO1xuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICogLy8gICByZXR1cm4gX19wO1xuICogLy8gfVxuICpcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICogICB2YXIgSlNUID0ge1xcXG4gKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAqICAgfTtcXFxuICogJyk7XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAsICdnJyk7XG5cbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gIC8vIHdpdGggbG9va3VwIChpbiBjYXNlIG9mIGUuZy4gcHJvdG90eXBlIHBvbGx1dGlvbiksIGFuZCBzdHJpcCBuZXdsaW5lcyBpZiBhbnkuXG4gIC8vIEEgbmV3bGluZSB3b3VsZG4ndCBiZSBhIHZhbGlkIHNvdXJjZVVSTCBhbnl3YXksIGFuZCBpdCdkIGVuYWJsZSBjb2RlIGluamVjdGlvbi5cbiAgdmFyIHNvdXJjZVVSTCA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgPyAoJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJykgK1xuICAgICAgICdcXG4nKVxuICAgIDogJyc7XG5cbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gIC8vIExpa2Ugd2l0aCBzb3VyY2VVUkwsIHdlIHRha2UgY2FyZSB0byBub3QgY2hlY2sgdGhlIG9wdGlvbidzIHByb3RvdHlwZSxcbiAgLy8gYXMgdGhpcyBjb25maWd1cmF0aW9uIGlzIGEgY29kZSBpbmplY3Rpb24gdmVjdG9yLlxuICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gIGlmICghdmFyaWFibGUpIHtcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgfVxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICh2YXJpYWJsZVxuICAgICAgPyAnJ1xuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICkgK1xuICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgKGlzRXNjYXBpbmdcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgIDogJydcbiAgICApICtcbiAgICAoaXNFdmFsdWF0aW5nXG4gICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICA6ICc7XFxuJ1xuICAgICkgK1xuICAgIHNvdXJjZSArXG4gICAgJ3JldHVybiBfX3BcXG59JztcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICB9KTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICogfSwgJz5fPicpO1xuICpcbiAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gKiAgIGVsZW1lbnRzID0gW107XG4gKiB9XG4gKi9cbnZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICB9XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcbiIsIi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbnZhciByZUludGVycG9sYXRlID0gcmVxdWlyZSgnbG9kYXNoLl9yZWludGVycG9sYXRlJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2c7XG5cbi8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG52YXIgaHRtbEVzY2FwZXMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbnZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAndmFyaWFibGUnOiAnJyxcblxuICAvKipcbiAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICAnaW1wb3J0cyc6IHtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICAnXyc6IHsgJ2VzY2FwZSc6IGVzY2FwZSB9XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAqXG4gKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAqIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGVTZXR0aW5ncztcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlPZjtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgIH1cbiAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDdG9yO1xuIiwidmFyIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZpbmQ7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpLFxuICAgIGNyZWF0ZUN0b3IgPSByZXF1aXJlKCcuL19jcmVhdGVDdG9yJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcbiAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpLFxuICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcHBseShmbiwgaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVBhcnRpYWw7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICByZXR1cm4gc3JjVmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGN1c3RvbURlZmF1bHRzQXNzaWduSW47XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIGJhc2VQcm9wZXJ0eU9mID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5T2YnKTtcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlSHRtbENoYXI7XG4iLCIvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAnXFxcXCc6ICdcXFxcJyxcbiAgXCInXCI6IFwiJ1wiLFxuICAnXFxuJzogJ24nLFxuICAnXFxyJzogJ3InLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlU3RyaW5nQ2hhcjtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9vcDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZztcblxubW9kdWxlLmV4cG9ydHMgPSByZUVzY2FwZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2c7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVFdmFsdWF0ZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlSW50ZXJwb2xhdGU7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduSW5XaXRoO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNFcnJvciA9IHJlcXVpcmUoJy4vaXNFcnJvcicpO1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICogfSwgJz5fPicpO1xuICpcbiAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gKiAgIGVsZW1lbnRzID0gW107XG4gKiB9XG4gKi9cbnZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhdHRlbXB0O1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBjcmVhdGVXcmFwID0gcmVxdWlyZSgnLi9fY3JlYXRlV3JhcCcpLFxuICAgIGdldEhvbGRlciA9IHJlcXVpcmUoJy4vX2dldEhvbGRlcicpLFxuICAgIHJlcGxhY2VIb2xkZXJzID0gcmVxdWlyZSgnLi9fcmVwbGFjZUhvbGRlcnMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAqXG4gKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gKiB9XG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gKiBib3VuZCgnIScpO1xuICogLy8gPT4gJ2hpIGZyZWQhJ1xuICpcbiAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gKiBib3VuZCgnaGknKTtcbiAqIC8vID0+ICdoaSBmcmVkISdcbiAqL1xudmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHO1xuICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICB9XG4gIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbn0pO1xuXG4vLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG5iaW5kLnBsYWNlaG9sZGVyID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBub3cgPSByZXF1aXJlKCcuL25vdycpLFxuICAgIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nXG4gICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICA6IHRpbWVXYWl0aW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGVzY2FwZUh0bWxDaGFyID0gcmVxdWlyZSgnLi9fZXNjYXBlSHRtbENoYXInKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAqXG4gKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICpcbiAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICogWFNTIHZlY3RvcnMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGU7XG4iLCJ2YXIgY3JlYXRlRmluZCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUZpbmQnKSxcbiAgICBmaW5kSW5kZXggPSByZXF1aXJlKCcuL2ZpbmRJbmRleCcpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqL1xudmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZDtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFcnJvcihFcnJvcik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXJyb3I7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlSZWR1Y2U7XG4iLCJ2YXIgYXNzaWduSW5XaXRoID0gcmVxdWlyZSgnLi9hc3NpZ25JbldpdGgnKSxcbiAgICBhdHRlbXB0ID0gcmVxdWlyZSgnLi9hdHRlbXB0JyksXG4gICAgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBjdXN0b21EZWZhdWx0c0Fzc2lnbkluID0gcmVxdWlyZSgnLi9fY3VzdG9tRGVmYXVsdHNBc3NpZ25JbicpLFxuICAgIGVzY2FwZVN0cmluZ0NoYXIgPSByZXF1aXJlKCcuL19lc2NhcGVTdHJpbmdDaGFyJyksXG4gICAgaXNFcnJvciA9IHJlcXVpcmUoJy4vaXNFcnJvcicpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyksXG4gICAgcmVJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vX3JlSW50ZXJwb2xhdGUnKSxcbiAgICB0ZW1wbGF0ZVNldHRpbmdzID0gcmVxdWlyZSgnLi90ZW1wbGF0ZVNldHRpbmdzJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUID0gJ0ludmFsaWQgYHZhcmlhYmxlYCBvcHRpb24gcGFzc2VkIGludG8gYF8udGVtcGxhdGVgJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbnZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuLyoqXG4gKiBVc2VkIHRvIHZhbGlkYXRlIHRoZSBgdmFsaWRhdGVgIG9wdGlvbiBpbiBgXy50ZW1wbGF0ZWAgdmFyaWFibGUuXG4gKlxuICogRm9yYmlkcyBjaGFyYWN0ZXJzIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGNoYW5nZSB0aGUgbWVhbmluZyBvZiB0aGUgZnVuY3Rpb24gYXJndW1lbnQgZGVmaW5pdGlvbjpcbiAqIC0gXCIoKSxcIiAobW9kaWZpY2F0aW9uIG9mIGZ1bmN0aW9uIHBhcmFtZXRlcnMpXG4gKiAtIFwiPVwiIChkZWZhdWx0IHZhbHVlKVxuICogLSBcIltde31cIiAoZGVzdHJ1Y3R1cmluZyBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICogLSBcIi9cIiAoYmVnaW5uaW5nIG9mIGEgY29tbWVudClcbiAqIC0gd2hpdGVzcGFjZVxuICovXG52YXIgcmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMgPSAvWygpPSx7fVxcW1xcXVxcL1xcc10vO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2hcbiAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gKi9cbnZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbi8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICpcbiAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSd0ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAqXG4gKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAqXG4gKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICpcbiAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICpcbiAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gKlxuICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gKiBjb21waWxlZChkYXRhKTtcbiAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gKlxuICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gKiBjb21waWxlZC5zb3VyY2U7XG4gKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gKiAvLyAgIHJldHVybiBfX3A7XG4gKiAvLyB9XG4gKlxuICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gKiAgIHZhciBKU1QgPSB7XFxcbiAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICogICB9O1xcXG4gKiAnKTtcbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gIHZhciBzZXR0aW5ncyA9IHRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0cy5fLnRlbXBsYXRlU2V0dGluZ3MgfHwgdGVtcGxhdGVTZXR0aW5ncztcblxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICB2YXIgaXNFc2NhcGluZyxcbiAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICwgJ2cnKTtcblxuICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgLy8gdG8gbm9ybWFsaXplIGFsbCBraW5kcyBvZiB3aGl0ZXNwYWNlLCBzbyBlLmcuIG5ld2xpbmVzIChhbmQgdW5pY29kZSB2ZXJzaW9ucyBvZiBpdCkgY2FuJ3Qgc25lYWsgaW5cbiAgLy8gYW5kIGVzY2FwZSB0aGUgY29tbWVudCwgdGh1cyBpbmplY3RpbmcgY29kZSB0aGF0IGdldHMgZXZhbGVkLlxuICB2YXIgc291cmNlVVJMID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc291cmNlVVJMJylcbiAgICA/ICgnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJykgK1xuICAgICAgICdcXG4nKVxuICAgIDogJyc7XG5cbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgaWYgKCF2YXJpYWJsZSkge1xuICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICB9XG4gIC8vIFRocm93IGFuIGVycm9yIGlmIGEgZm9yYmlkZGVuIGNoYXJhY3RlciB3YXMgZm91bmQgaW4gYHZhcmlhYmxlYCwgdG8gcHJldmVudFxuICAvLyBwb3RlbnRpYWwgY29tbWFuZCBpbmplY3Rpb24gYXR0YWNrcy5cbiAgZWxzZSBpZiAocmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMudGVzdCh2YXJpYWJsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCk7XG4gIH1cblxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICh2YXJpYWJsZVxuICAgICAgPyAnJ1xuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICkgK1xuICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgKGlzRXNjYXBpbmdcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgIDogJydcbiAgICApICtcbiAgICAoaXNFdmFsdWF0aW5nXG4gICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICA6ICc7XFxuJ1xuICAgICkgK1xuICAgIHNvdXJjZSArXG4gICAgJ3JldHVybiBfX3BcXG59JztcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICB9KTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xuIiwidmFyIGVzY2FwZSA9IHJlcXVpcmUoJy4vZXNjYXBlJyksXG4gICAgcmVFc2NhcGUgPSByZXF1aXJlKCcuL19yZUVzY2FwZScpLFxuICAgIHJlRXZhbHVhdGUgPSByZXF1aXJlKCcuL19yZUV2YWx1YXRlJyksXG4gICAgcmVJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vX3JlSW50ZXJwb2xhdGUnKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgJ2ltcG9ydHMnOiB7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgJ18nOiB7ICdlc2NhcGUnOiBlc2NhcGUgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlU2V0dGluZ3M7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgaGFzTWFwID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXAucHJvdG90eXBlO1xudmFyIG1hcFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNNYXAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1hcC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIG1hcFNpemUgPSBoYXNNYXAgJiYgbWFwU2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIG1hcFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG1hcFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgbWFwRm9yRWFjaCA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlO1xudmFyIHNldFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNTZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFNldC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIHNldFNpemUgPSBoYXNTZXQgJiYgc2V0U2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIHNldFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgc2V0Rm9yRWFjaCA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIFdlYWtNYXAucHJvdG90eXBlO1xudmFyIHdlYWtNYXBIYXMgPSBoYXNXZWFrTWFwID8gV2Vha01hcC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgJiYgV2Vha1NldC5wcm90b3R5cGU7XG52YXIgd2Vha1NldEhhcyA9IGhhc1dlYWtTZXQgPyBXZWFrU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyIGhhc1dlYWtSZWYgPSB0eXBlb2YgV2Vha1JlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrUmVmLnByb3RvdHlwZTtcbnZhciB3ZWFrUmVmRGVyZWYgPSBoYXNXZWFrUmVmID8gV2Vha1JlZi5wcm90b3R5cGUuZGVyZWYgOiBudWxsO1xudmFyIGJvb2xlYW5WYWx1ZU9mID0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZjtcbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciAkbWF0Y2ggPSBTdHJpbmcucHJvdG90eXBlLm1hdGNoO1xudmFyICRzbGljZSA9IFN0cmluZy5wcm90b3R5cGUuc2xpY2U7XG52YXIgJHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgJHRvVXBwZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZTtcbnZhciAkdG9Mb3dlckNhc2UgPSBTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlO1xudmFyICR0ZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xudmFyICRjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyICRqb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG52YXIgJGFyclNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyICRmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgYmlnSW50VmFsdWVPZiA9IHR5cGVvZiBCaWdJbnQgPT09ICdmdW5jdGlvbicgPyBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YgOiBudWxsO1xudmFyIGdPUFMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHN5bVRvU3RyaW5nID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgOiBudWxsO1xudmFyIGhhc1NoYW1tZWRTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnb2JqZWN0Jztcbi8vIGllLCBgaGFzLXRvc3RyaW5ndGFnL3NoYW1zXG52YXIgdG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gaGFzU2hhbW1lZFN5bWJvbHMgPyAnb2JqZWN0JyA6ICdzeW1ib2wnKVxuICAgID8gU3ltYm9sLnRvU3RyaW5nVGFnXG4gICAgOiBudWxsO1xudmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBnUE8gPSAodHlwZW9mIFJlZmxlY3QgPT09ICdmdW5jdGlvbicgPyBSZWZsZWN0LmdldFByb3RvdHlwZU9mIDogT2JqZWN0LmdldFByb3RvdHlwZU9mKSB8fCAoXG4gICAgW10uX19wcm90b19fID09PSBBcnJheS5wcm90b3R5cGUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuICAgICAgICA/IGZ1bmN0aW9uIChPKSB7XG4gICAgICAgICAgICByZXR1cm4gTy5fX3Byb3RvX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgfVxuICAgICAgICA6IG51bGxcbik7XG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNTZXBhcmF0b3IobnVtLCBzdHIpIHtcbiAgICBpZiAoXG4gICAgICAgIG51bSA9PT0gSW5maW5pdHlcbiAgICAgICAgfHwgbnVtID09PSAtSW5maW5pdHlcbiAgICAgICAgfHwgbnVtICE9PSBudW1cbiAgICAgICAgfHwgKG51bSAmJiBudW0gPiAtMTAwMCAmJiBudW0gPCAxMDAwKVxuICAgICAgICB8fCAkdGVzdC5jYWxsKC9lLywgc3RyKVxuICAgICkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB2YXIgc2VwUmVnZXggPSAvWzAtOV0oPz0oPzpbMC05XXszfSkrKD8hWzAtOV0pKS9nO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgaW50ID0gbnVtIDwgMCA/IC0kZmxvb3IoLW51bSkgOiAkZmxvb3IobnVtKTsgLy8gdHJ1bmMobnVtKVxuICAgICAgICBpZiAoaW50ICE9PSBudW0pIHtcbiAgICAgICAgICAgIHZhciBpbnRTdHIgPSBTdHJpbmcoaW50KTtcbiAgICAgICAgICAgIHZhciBkZWMgPSAkc2xpY2UuY2FsbChzdHIsIGludFN0ci5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKGludFN0ciwgc2VwUmVnZXgsICckJl8nKSArICcuJyArICRyZXBsYWNlLmNhbGwoJHJlcGxhY2UuY2FsbChkZWMsIC8oWzAtOV17M30pL2csICckJl8nKSwgL18kLywgJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKHN0ciwgc2VwUmVnZXgsICckJl8nKTtcbn1cblxudmFyIHV0aWxJbnNwZWN0ID0gcmVxdWlyZSgnLi91dGlsLmluc3BlY3QnKTtcbnZhciBpbnNwZWN0Q3VzdG9tID0gdXRpbEluc3BlY3QuY3VzdG9tO1xudmFyIGluc3BlY3RTeW1ib2wgPSBpc1N5bWJvbChpbnNwZWN0Q3VzdG9tKSA/IGluc3BlY3RDdXN0b20gOiBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluc3BlY3RfKG9iaiwgb3B0aW9ucywgZGVwdGgsIHNlZW4pIHtcbiAgICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoaGFzKG9wdHMsICdxdW90ZVN0eWxlJykgJiYgKG9wdHMucXVvdGVTdHlsZSAhPT0gJ3NpbmdsZScgJiYgb3B0cy5xdW90ZVN0eWxlICE9PSAnZG91YmxlJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwicXVvdGVTdHlsZVwiIG11c3QgYmUgXCJzaW5nbGVcIiBvciBcImRvdWJsZVwiJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICAgaGFzKG9wdHMsICdtYXhTdHJpbmdMZW5ndGgnKSAmJiAodHlwZW9mIG9wdHMubWF4U3RyaW5nTGVuZ3RoID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBvcHRzLm1heFN0cmluZ0xlbmd0aCA8IDAgJiYgb3B0cy5tYXhTdHJpbmdMZW5ndGggIT09IEluZmluaXR5XG4gICAgICAgICAgICA6IG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBudWxsXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwibWF4U3RyaW5nTGVuZ3RoXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgSW5maW5pdHksIG9yIGBudWxsYCcpO1xuICAgIH1cbiAgICB2YXIgY3VzdG9tSW5zcGVjdCA9IGhhcyhvcHRzLCAnY3VzdG9tSW5zcGVjdCcpID8gb3B0cy5jdXN0b21JbnNwZWN0IDogdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGN1c3RvbUluc3BlY3QgIT09ICdib29sZWFuJyAmJiBjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJjdXN0b21JbnNwZWN0XCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCwgYGZhbHNlYCwgb3IgYFxcJ3N5bWJvbFxcJ2AnKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnaW5kZW50JylcbiAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09IG51bGxcbiAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09ICdcXHQnXG4gICAgICAgICYmICEocGFyc2VJbnQob3B0cy5pbmRlbnQsIDEwKSA9PT0gb3B0cy5pbmRlbnQgJiYgb3B0cy5pbmRlbnQgPiAwKVxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJpbmRlbnRcIiBtdXN0IGJlIFwiXFxcXHRcIiwgYW4gaW50ZWdlciA+IDAsIG9yIGBudWxsYCcpO1xuICAgIH1cbiAgICBpZiAoaGFzKG9wdHMsICdudW1lcmljU2VwYXJhdG9yJykgJiYgdHlwZW9mIG9wdHMubnVtZXJpY1NlcGFyYXRvciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm51bWVyaWNTZXBhcmF0b3JcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYHRydWVgIG9yIGBmYWxzZWAnKTtcbiAgICB9XG4gICAgdmFyIG51bWVyaWNTZXBhcmF0b3IgPSBvcHRzLm51bWVyaWNTZXBhcmF0b3I7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIG9iaiA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKG9iaiwgb3B0cyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAob2JqID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHkgLyBvYmogPiAwID8gJzAnIDogJy0wJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyID0gU3RyaW5nKG9iaik7XG4gICAgICAgIHJldHVybiBudW1lcmljU2VwYXJhdG9yID8gYWRkTnVtZXJpY1NlcGFyYXRvcihvYmosIHN0cikgOiBzdHI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnYmlnaW50Jykge1xuICAgICAgICB2YXIgYmlnSW50U3RyID0gU3RyaW5nKG9iaikgKyAnbic7XG4gICAgICAgIHJldHVybiBudW1lcmljU2VwYXJhdG9yID8gYWRkTnVtZXJpY1NlcGFyYXRvcihvYmosIGJpZ0ludFN0cikgOiBiaWdJbnRTdHI7XG4gICAgfVxuXG4gICAgdmFyIG1heERlcHRoID0gdHlwZW9mIG9wdHMuZGVwdGggPT09ICd1bmRlZmluZWQnID8gNSA6IG9wdHMuZGVwdGg7XG4gICAgaWYgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVwdGggPSAwOyB9XG4gICAgaWYgKGRlcHRoID49IG1heERlcHRoICYmIG1heERlcHRoID4gMCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheShvYmopID8gJ1tBcnJheV0nIDogJ1tPYmplY3RdJztcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50ID0gZ2V0SW5kZW50KG9wdHMsIGRlcHRoKTtcblxuICAgIGlmICh0eXBlb2Ygc2VlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VlbiA9IFtdO1xuICAgIH0gZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBvYmopID49IDApIHtcbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNwZWN0KHZhbHVlLCBmcm9tLCBub0luZGVudCkge1xuICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgc2VlbiA9ICRhcnJTbGljZS5jYWxsKHNlZW4pO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub0luZGVudCkge1xuICAgICAgICAgICAgdmFyIG5ld09wdHMgPSB7XG4gICAgICAgICAgICAgICAgZGVwdGg6IG9wdHMuZGVwdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGFzKG9wdHMsICdxdW90ZVN0eWxlJykpIHtcbiAgICAgICAgICAgICAgICBuZXdPcHRzLnF1b3RlU3R5bGUgPSBvcHRzLnF1b3RlU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdF8odmFsdWUsIG5ld09wdHMsIGRlcHRoICsgMSwgc2Vlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBvcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmICFpc1JlZ0V4cChvYmopKSB7IC8vIGluIG9sZGVyIGVuZ2luZXMsIHJlZ2V4ZXMgYXJlIGNhbGxhYmxlXG4gICAgICAgIHZhciBuYW1lID0gbmFtZU9mKG9iaik7XG4gICAgICAgIHZhciBrZXlzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICByZXR1cm4gJ1tGdW5jdGlvbicgKyAobmFtZSA/ICc6ICcgKyBuYW1lIDogJyAoYW5vbnltb3VzKScpICsgJ10nICsgKGtleXMubGVuZ3RoID4gMCA/ICcgeyAnICsgJGpvaW4uY2FsbChrZXlzLCAnLCAnKSArICcgfScgOiAnJyk7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChvYmopKSB7XG4gICAgICAgIHZhciBzeW1TdHJpbmcgPSBoYXNTaGFtbWVkU3ltYm9scyA/ICRyZXBsYWNlLmNhbGwoU3RyaW5nKG9iaiksIC9eKFN5bWJvbFxcKC4qXFwpKV9bXildKiQvLCAnJDEnKSA6IHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFoYXNTaGFtbWVkU3ltYm9scyA/IG1hcmtCb3hlZChzeW1TdHJpbmcpIDogc3ltU3RyaW5nO1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KG9iaikpIHtcbiAgICAgICAgdmFyIHMgPSAnPCcgKyAkdG9Mb3dlckNhc2UuY2FsbChTdHJpbmcob2JqLm5vZGVOYW1lKSk7XG4gICAgICAgIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzICs9ICcgJyArIGF0dHJzW2ldLm5hbWUgKyAnPScgKyB3cmFwUXVvdGVzKHF1b3RlKGF0dHJzW2ldLnZhbHVlKSwgJ2RvdWJsZScsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gJz4nO1xuICAgICAgICBpZiAob2JqLmNoaWxkTm9kZXMgJiYgb2JqLmNoaWxkTm9kZXMubGVuZ3RoKSB7IHMgKz0gJy4uLic7IH1cbiAgICAgICAgcyArPSAnPC8nICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpICsgJz4nO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJ1tdJzsgfVxuICAgICAgICB2YXIgeHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmIChpbmRlbnQgJiYgIXNpbmdsZUxpbmVWYWx1ZXMoeHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgaW5kZW50ZWRKb2luKHhzLCBpbmRlbnQpICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnWyAnICsgJGpvaW4uY2FsbCh4cywgJywgJykgKyAnIF0nO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcihvYmopKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgaWYgKCEoJ2NhdXNlJyBpbiBFcnJvci5wcm90b3R5cGUpICYmICdjYXVzZScgaW4gb2JqICYmICFpc0VudW1lcmFibGUuY2FsbChvYmosICdjYXVzZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3sgWycgKyBTdHJpbmcob2JqKSArICddICcgKyAkam9pbi5jYWxsKCRjb25jYXQuY2FsbCgnW2NhdXNlXTogJyArIGluc3BlY3Qob2JqLmNhdXNlKSwgcGFydHMpLCAnLCAnKSArICcgfSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJ1snICsgU3RyaW5nKG9iaikgKyAnXSc7IH1cbiAgICAgICAgcmV0dXJuICd7IFsnICsgU3RyaW5nKG9iaikgKyAnXSAnICsgJGpvaW4uY2FsbChwYXJ0cywgJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgY3VzdG9tSW5zcGVjdCkge1xuICAgICAgICBpZiAoaW5zcGVjdFN5bWJvbCAmJiB0eXBlb2Ygb2JqW2luc3BlY3RTeW1ib2xdID09PSAnZnVuY3Rpb24nICYmIHV0aWxJbnNwZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbEluc3BlY3Qob2JqLCB7IGRlcHRoOiBtYXhEZXB0aCAtIGRlcHRoIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbUluc3BlY3QgIT09ICdzeW1ib2wnICYmIHR5cGVvZiBvYmouaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5pbnNwZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWFwKG9iaikpIHtcbiAgICAgICAgdmFyIG1hcFBhcnRzID0gW107XG4gICAgICAgIGlmIChtYXBGb3JFYWNoKSB7XG4gICAgICAgICAgICBtYXBGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIG1hcFBhcnRzLnB1c2goaW5zcGVjdChrZXksIG9iaiwgdHJ1ZSkgKyAnID0+ICcgKyBpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ01hcCcsIG1hcFNpemUuY2FsbChvYmopLCBtYXBQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzU2V0KG9iaikpIHtcbiAgICAgICAgdmFyIHNldFBhcnRzID0gW107XG4gICAgICAgIGlmIChzZXRGb3JFYWNoKSB7XG4gICAgICAgICAgICBzZXRGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZXRQYXJ0cy5wdXNoKGluc3BlY3QodmFsdWUsIG9iaikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25PZignU2V0Jywgc2V0U2l6ZS5jYWxsKG9iaiksIHNldFBhcnRzLCBpbmRlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrTWFwKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtNYXAnKTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha1NldChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrU2V0Jyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1JlZicpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoTnVtYmVyKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnSW50KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KGJpZ0ludFZhbHVlT2YuY2FsbChvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4ob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGJvb2xlYW5WYWx1ZU9mLmNhbGwob2JqKSk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChTdHJpbmcob2JqKSkpO1xuICAgIH1cbiAgICAvLyBub3RlOiBpbiBJRSA4LCBzb21ldGltZXMgYGdsb2JhbCAhPT0gd2luZG93YCBidXQgYm90aCBhcmUgdGhlIHByb3RvdHlwZXMgb2YgZWFjaCBvdGhlclxuICAgIC8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBvYmogPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gJ3sgW29iamVjdCBXaW5kb3ddIH0nO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAgICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqID09PSBnbG9iYWxUaGlzKVxuICAgICAgICB8fCAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqID09PSBnbG9iYWwpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiAneyBbb2JqZWN0IGdsb2JhbFRoaXNdIH0nO1xuICAgIH1cbiAgICBpZiAoIWlzRGF0ZShvYmopICYmICFpc1JlZ0V4cChvYmopKSB7XG4gICAgICAgIHZhciB5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgdmFyIGlzUGxhaW5PYmplY3QgPSBnUE8gPyBnUE8ob2JqKSA9PT0gT2JqZWN0LnByb3RvdHlwZSA6IG9iaiBpbnN0YW5jZW9mIE9iamVjdCB8fCBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICAgICAgdmFyIHByb3RvVGFnID0gb2JqIGluc3RhbmNlb2YgT2JqZWN0ID8gJycgOiAnbnVsbCBwcm90b3R5cGUnO1xuICAgICAgICB2YXIgc3RyaW5nVGFnID0gIWlzUGxhaW5PYmplY3QgJiYgdG9TdHJpbmdUYWcgJiYgT2JqZWN0KG9iaikgPT09IG9iaiAmJiB0b1N0cmluZ1RhZyBpbiBvYmogPyAkc2xpY2UuY2FsbCh0b1N0cihvYmopLCA4LCAtMSkgOiBwcm90b1RhZyA/ICdPYmplY3QnIDogJyc7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvclRhZyA9IGlzUGxhaW5PYmplY3QgfHwgdHlwZW9mIG9iai5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJyA/ICcnIDogb2JqLmNvbnN0cnVjdG9yLm5hbWUgPyBvYmouY29uc3RydWN0b3IubmFtZSArICcgJyA6ICcnO1xuICAgICAgICB2YXIgdGFnID0gY29uc3RydWN0b3JUYWcgKyAoc3RyaW5nVGFnIHx8IHByb3RvVGFnID8gJ1snICsgJGpvaW4uY2FsbCgkY29uY2F0LmNhbGwoW10sIHN0cmluZ1RhZyB8fCBbXSwgcHJvdG9UYWcgfHwgW10pLCAnOiAnKSArICddICcgOiAnJyk7XG4gICAgICAgIGlmICh5cy5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRhZyArICd7fSc7IH1cbiAgICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZyArICd7JyArIGluZGVudGVkSm9pbih5cywgaW5kZW50KSArICd9JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnICsgJ3sgJyArICRqb2luLmNhbGwoeXMsICcsICcpICsgJyB9JztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhvYmopO1xufTtcblxuZnVuY3Rpb24gd3JhcFF1b3RlcyhzLCBkZWZhdWx0U3R5bGUsIG9wdHMpIHtcbiAgICB2YXIgcXVvdGVDaGFyID0gKG9wdHMucXVvdGVTdHlsZSB8fCBkZWZhdWx0U3R5bGUpID09PSAnZG91YmxlJyA/ICdcIicgOiBcIidcIjtcbiAgICByZXR1cm4gcXVvdGVDaGFyICsgcyArIHF1b3RlQ2hhcjtcbn1cblxuZnVuY3Rpb24gcXVvdGUocykge1xuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKFN0cmluZyhzKSwgL1wiL2csICcmcXVvdDsnKTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBEYXRlXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNFcnJvcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEVycm9yXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cblxuLy8gU3ltYm9sIGFuZCBCaWdJbnQgZG8gaGF2ZSBTeW1ib2wudG9TdHJpbmdUYWcgYnkgc3BlYywgc28gdGhhdCBjYW4ndCBiZSB1c2VkIHRvIGVsaW1pbmF0ZSBmYWxzZSBwb3NpdGl2ZXNcbmZ1bmN0aW9uIGlzU3ltYm9sKG9iaikge1xuICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scykge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiBpbnN0YW5jZW9mIFN5bWJvbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCAhc3ltVG9TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0JpZ0ludChvYmopIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCAhYmlnSW50VmFsdWVPZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGJpZ0ludFZhbHVlT2YuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5IGluIHRoaXM7IH07XG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufVxuXG5mdW5jdGlvbiB0b1N0cihvYmopIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBuYW1lT2YoZikge1xuICAgIGlmIChmLm5hbWUpIHsgcmV0dXJuIGYubmFtZTsgfVxuICAgIHZhciBtID0gJG1hdGNoLmNhbGwoZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGYpLCAvXmZ1bmN0aW9uXFxzKihbXFx3JF0rKS8pO1xuICAgIGlmIChtKSB7IHJldHVybiBtWzFdOyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgeyByZXR1cm4geHMuaW5kZXhPZih4KTsgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0geCkgeyByZXR1cm4gaTsgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzTWFwKHgpIHtcbiAgICBpZiAoIW1hcFNpemUgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0U2l6ZS5jYWxsKHgpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIE1hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha01hcCh4KSB7XG4gICAgaWYgKCF3ZWFrTWFwSGFzIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtNYXBIYXMuY2FsbCh4LCB3ZWFrTWFwSGFzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdlYWtTZXRIYXMuY2FsbCh4LCB3ZWFrU2V0SGFzKTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXZWFrTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrUmVmKHgpIHtcbiAgICBpZiAoIXdlYWtSZWZEZXJlZiB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrUmVmRGVyZWYuY2FsbCh4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU2V0KHgpIHtcbiAgICBpZiAoIXNldFNpemUgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc2V0U2l6ZS5jYWxsKHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xuICAgICAgICB9IGNhdGNoIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFNldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha1NldCh4KSB7XG4gICAgaWYgKCF3ZWFrU2V0SGFzIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtTZXRIYXMuY2FsbCh4LCB3ZWFrU2V0SGFzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdlYWtNYXBIYXMuY2FsbCh4LCB3ZWFrTWFwSGFzKTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXZWFrU2V0OyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50KHgpIHtcbiAgICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB4Lm5vZGVOYW1lID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgeC5nZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RTdHJpbmcoc3RyLCBvcHRzKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPiBvcHRzLm1heFN0cmluZ0xlbmd0aCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gc3RyLmxlbmd0aCAtIG9wdHMubWF4U3RyaW5nTGVuZ3RoO1xuICAgICAgICB2YXIgdHJhaWxlciA9ICcuLi4gJyArIHJlbWFpbmluZyArICcgbW9yZSBjaGFyYWN0ZXInICsgKHJlbWFpbmluZyA+IDEgPyAncycgOiAnJyk7XG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKCRzbGljZS5jYWxsKHN0ciwgMCwgb3B0cy5tYXhTdHJpbmdMZW5ndGgpLCBvcHRzKSArIHRyYWlsZXI7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgdmFyIHMgPSAkcmVwbGFjZS5jYWxsKCRyZXBsYWNlLmNhbGwoc3RyLCAvKFsnXFxcXF0pL2csICdcXFxcJDEnKSwgL1tcXHgwMC1cXHgxZl0vZywgbG93Ynl0ZSk7XG4gICAgcmV0dXJuIHdyYXBRdW90ZXMocywgJ3NpbmdsZScsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBsb3dieXRlKGMpIHtcbiAgICB2YXIgbiA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgeCA9IHtcbiAgICAgICAgODogJ2InLFxuICAgICAgICA5OiAndCcsXG4gICAgICAgIDEwOiAnbicsXG4gICAgICAgIDEyOiAnZicsXG4gICAgICAgIDEzOiAncidcbiAgICB9W25dO1xuICAgIGlmICh4KSB7IHJldHVybiAnXFxcXCcgKyB4OyB9XG4gICAgcmV0dXJuICdcXFxceCcgKyAobiA8IDB4MTAgPyAnMCcgOiAnJykgKyAkdG9VcHBlckNhc2UuY2FsbChuLnRvU3RyaW5nKDE2KSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtCb3hlZChzdHIpIHtcbiAgICByZXR1cm4gJ09iamVjdCgnICsgc3RyICsgJyknO1xufVxuXG5mdW5jdGlvbiB3ZWFrQ29sbGVjdGlvbk9mKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSArICcgeyA/IH0nO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uT2YodHlwZSwgc2l6ZSwgZW50cmllcywgaW5kZW50KSB7XG4gICAgdmFyIGpvaW5lZEVudHJpZXMgPSBpbmRlbnQgPyBpbmRlbnRlZEpvaW4oZW50cmllcywgaW5kZW50KSA6ICRqb2luLmNhbGwoZW50cmllcywgJywgJyk7XG4gICAgcmV0dXJuIHR5cGUgKyAnICgnICsgc2l6ZSArICcpIHsnICsgam9pbmVkRW50cmllcyArICd9Jztcbn1cblxuZnVuY3Rpb24gc2luZ2xlTGluZVZhbHVlcyh4cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluZGV4T2YoeHNbaV0sICdcXG4nKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEluZGVudChvcHRzLCBkZXB0aCkge1xuICAgIHZhciBiYXNlSW5kZW50O1xuICAgIGlmIChvcHRzLmluZGVudCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgYmFzZUluZGVudCA9ICdcXHQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuaW5kZW50ID09PSAnbnVtYmVyJyAmJiBvcHRzLmluZGVudCA+IDApIHtcbiAgICAgICAgYmFzZUluZGVudCA9ICRqb2luLmNhbGwoQXJyYXkob3B0cy5pbmRlbnQgKyAxKSwgJyAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZTogYmFzZUluZGVudCxcbiAgICAgICAgcHJldjogJGpvaW4uY2FsbChBcnJheShkZXB0aCArIDEpLCBiYXNlSW5kZW50KVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGluZGVudGVkSm9pbih4cywgaW5kZW50KSB7XG4gICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJyc7IH1cbiAgICB2YXIgbGluZUpvaW5lciA9ICdcXG4nICsgaW5kZW50LnByZXYgKyBpbmRlbnQuYmFzZTtcbiAgICByZXR1cm4gbGluZUpvaW5lciArICRqb2luLmNhbGwoeHMsICcsJyArIGxpbmVKb2luZXIpICsgJ1xcbicgKyBpbmRlbnQucHJldjtcbn1cblxuZnVuY3Rpb24gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iaik7XG4gICAgdmFyIHhzID0gW107XG4gICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHhzLmxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4c1tpXSA9IGhhcyhvYmosIGkpID8gaW5zcGVjdChvYmpbaV0sIG9iaikgOiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3ltcyA9IHR5cGVvZiBnT1BTID09PSAnZnVuY3Rpb24nID8gZ09QUyhvYmopIDogW107XG4gICAgdmFyIHN5bU1hcDtcbiAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMpIHtcbiAgICAgICAgc3ltTWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3ltcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgc3ltTWFwWyckJyArIHN5bXNba11dID0gc3ltc1trXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBpZiAoIWhhcyhvYmosIGtleSkpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgaWYgKGlzQXJyICYmIFN0cmluZyhOdW1iZXIoa2V5KSkgPT09IGtleSAmJiBrZXkgPCBvYmoubGVuZ3RoKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scyAmJiBzeW1NYXBbJyQnICsga2V5XSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBwcmV2ZW50IHNoYW1tZWQgU3ltYm9scywgd2hpY2ggYXJlIHN0b3JlZCBhcyBzdHJpbmdzLCBmcm9tIGJlaW5nIGluY2x1ZGVkIGluIHRoZSBzdHJpbmcga2V5IHNlY3Rpb25cbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKCR0ZXN0LmNhbGwoL1teXFx3JF0vLCBrZXkpKSB7XG4gICAgICAgICAgICB4cy5wdXNoKGluc3BlY3Qoa2V5LCBvYmopICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeHMucHVzaChrZXkgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnT1BTID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ltcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltc1tqXSkpIHtcbiAgICAgICAgICAgICAgICB4cy5wdXNoKCdbJyArIGluc3BlY3Qoc3ltc1tqXSkgKyAnXTogJyArIGluc3BlY3Qob2JqW3N5bXNbal1dLCBvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geHM7XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJ2lzLWludGVnZXInKVxudmFyIGlzSW50ZWdlclJlZ2V4ID0gL14tP1xcZCskL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSW50U3RyaWN0IChpbnRlZ2VyKSB7XG4gIGlmICh0eXBlb2YgaW50ZWdlciA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKGludGVnZXIpID8gaW50ZWdlciA6IHVuZGVmaW5lZFxuICB9XG4gIGlmICh0eXBlb2YgaW50ZWdlciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyUmVnZXgudGVzdChpbnRlZ2VyKSA/IHBhcnNlSW50KGludGVnZXIsIDEwKSA6IHVuZGVmaW5lZFxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHBhcnNlSW50U3RyaWN0ID0gcmVxdWlyZSgncGFyc2UtaW50JylcbnZhciBleHBhbmRZZWFyID0gcmVxdWlyZSgnZXhwYW5kLXllYXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlWWVhciAoeWVhciwgZXhwYW5kLCBub3cpIHtcbiAgeWVhciA9IHBhcnNlSW50U3RyaWN0KHllYXIpXG4gIGlmICh5ZWFyID09IG51bGwpIHJldHVyblxuICBpZiAoIWV4cGFuZCkgcmV0dXJuIHllYXJcbiAgcmV0dXJuIGV4cGFuZFllYXIoeWVhciwgbm93KVxufVxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG52YXIgRm9ybWF0ID0ge1xuICAgIFJGQzE3Mzg6ICdSRkMxNzM4JyxcbiAgICBSRkMzOTg2OiAnUkZDMzk4Nidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdkZWZhdWx0JzogRm9ybWF0LlJGQzM5ODYsXG4gICAgZm9ybWF0dGVyczoge1xuICAgICAgICBSRkMxNzM4OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlLmNhbGwodmFsdWUsIHBlcmNlbnRUd2VudGllcywgJysnKTtcbiAgICAgICAgfSxcbiAgICAgICAgUkZDMzk4NjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUkZDMTczODogRm9ybWF0LlJGQzE3MzgsXG4gICAgUkZDMzk4NjogRm9ybWF0LlJGQzM5ODZcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0czogZm9ybWF0cyxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93RW1wdHlBcnJheXM6IGZhbHNlLFxuICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG4gICAgYWxsb3dTcGFyc2U6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBjb21tYTogZmFsc2UsXG4gICAgZGVjb2RlRG90SW5LZXlzOiBmYWxzZSxcbiAgICBkZWNvZGVyOiB1dGlscy5kZWNvZGUsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgZHVwbGljYXRlczogJ2NvbWJpbmUnLFxuICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IGZhbHNlLFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuICAgIHBhcnNlQXJyYXlzOiB0cnVlLFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXG4gICAgc3RyaWN0RGVwdGg6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBpbnRlcnByZXROdW1lcmljRW50aXRpZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIyhcXGQrKTsvZywgZnVuY3Rpb24gKCQwLCBudW1iZXJTdHIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobnVtYmVyU3RyLCAxMCkpO1xuICAgIH0pO1xufTtcblxudmFyIHBhcnNlQXJyYXlWYWx1ZSA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuY29tbWEgJiYgdmFsLmluZGV4T2YoJywnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB2YWwuc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyB3aGF0IGJyb3dzZXJzIHdpbGwgc3VibWl0IHdoZW4gdGhlIOKckyBjaGFyYWN0ZXIgb2NjdXJzIGluIGFuXG4vLyBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgYm9keSBhbmQgdGhlIGVuY29kaW5nIG9mIHRoZSBwYWdlIGNvbnRhaW5pbmdcbi8vIHRoZSBmb3JtIGlzIGlzby04ODU5LTEsIG9yIHdoZW4gdGhlIHN1Ym1pdHRlZCBmb3JtIGhhcyBhbiBhY2NlcHQtY2hhcnNldFxuLy8gYXR0cmlidXRlIG9mIGlzby04ODU5LTEuIFByZXN1bWFibHkgYWxzbyB3aXRoIG90aGVyIGNoYXJzZXRzIHRoYXQgZG8gbm90IGNvbnRhaW5cbi8vIHRoZSDinJMgY2hhcmFjdGVyLCBzdWNoIGFzIHVzLWFzY2lpLlxudmFyIGlzb1NlbnRpbmVsID0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0InOyAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JylcblxuLy8gVGhlc2UgYXJlIHRoZSBwZXJjZW50LWVuY29kZWQgdXRmLTggb2N0ZXRzIHJlcHJlc2VudGluZyBhIGNoZWNrbWFyaywgaW5kaWNhdGluZyB0aGF0IHRoZSByZXF1ZXN0IGFjdHVhbGx5IGlzIHV0Zi04IGVuY29kZWQuXG52YXIgY2hhcnNldFNlbnRpbmVsID0gJ3V0Zjg9JUUyJTlDJTkzJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuXG52YXIgcGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nVmFsdWVzKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuXG4gICAgdmFyIGNsZWFuU3RyID0gb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA/IHN0ci5yZXBsYWNlKC9eXFw/LywgJycpIDogc3RyO1xuICAgIGNsZWFuU3RyID0gY2xlYW5TdHIucmVwbGFjZSgvJTVCL2dpLCAnWycpLnJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbiAgICB2YXIgbGltaXQgPSBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQ7XG4gICAgdmFyIHBhcnRzID0gY2xlYW5TdHIuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIsIGxpbWl0KTtcbiAgICB2YXIgc2tpcEluZGV4ID0gLTE7IC8vIEtlZXAgdHJhY2sgb2Ygd2hlcmUgdGhlIHV0Zjggc2VudGluZWwgd2FzIGZvdW5kXG4gICAgdmFyIGk7XG5cbiAgICB2YXIgY2hhcnNldCA9IG9wdGlvbnMuY2hhcnNldDtcbiAgICBpZiAob3B0aW9ucy5jaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAocGFydHNbaV0uaW5kZXhPZigndXRmOD0nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1tpXSA9PT0gY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSAndXRmLTgnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydHNbaV0gPT09IGlzb1NlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSAnaXNvLTg4NTktMSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXBJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgaSA9IHBhcnRzLmxlbmd0aDsgLy8gVGhlIGVzbGludCBzZXR0aW5ncyBkbyBub3QgYWxsb3cgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT09IHNraXBJbmRleCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICB2YXIgYnJhY2tldEVxdWFsc1BvcyA9IHBhcnQuaW5kZXhPZignXT0nKTtcbiAgICAgICAgdmFyIHBvcyA9IGJyYWNrZXRFcXVhbHNQb3MgPT09IC0xID8gcGFydC5pbmRleE9mKCc9JykgOiBicmFja2V0RXF1YWxzUG9zICsgMTtcblxuICAgICAgICB2YXIga2V5LCB2YWw7XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuICAgICAgICAgICAgdmFsID0gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPyBudWxsIDogJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydC5zbGljZSgwLCBwb3MpLCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XG4gICAgICAgICAgICB2YWwgPSB1dGlscy5tYXliZU1hcChcbiAgICAgICAgICAgICAgICBwYXJzZUFycmF5VmFsdWUocGFydC5zbGljZShwb3MgKyAxKSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVuY29kZWRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVjb2RlcihlbmNvZGVkVmFsLCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAndmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCAmJiBvcHRpb25zLmludGVycHJldE51bWVyaWNFbnRpdGllcyAmJiBjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIHZhbCA9IGludGVycHJldE51bWVyaWNFbnRpdGllcyh2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnQuaW5kZXhPZignW109JykgPiAtMSkge1xuICAgICAgICAgICAgdmFsID0gaXNBcnJheSh2YWwpID8gW3ZhbF0gOiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhpc3RpbmcgPSBoYXMuY2FsbChvYmosIGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZyAmJiBvcHRpb25zLmR1cGxpY2F0ZXMgPT09ICdjb21iaW5lJykge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1dGlscy5jb21iaW5lKG9ialtrZXldLCB2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKCFleGlzdGluZyB8fCBvcHRpb25zLmR1cGxpY2F0ZXMgPT09ICdsYXN0Jykge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIHZhciBsZWFmID0gdmFsdWVzUGFyc2VkID8gdmFsIDogcGFyc2VBcnJheVZhbHVlKHZhbCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJyAmJiBvcHRpb25zLnBhcnNlQXJyYXlzKSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLmFsbG93RW1wdHlBcnJheXMgJiYgKGxlYWYgPT09ICcnIHx8IChvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyAmJiBsZWFmID09PSBudWxsKSlcbiAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgOiBbXS5jb25jYXQobGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBkZWNvZGVkUm9vdCA9IG9wdGlvbnMuZGVjb2RlRG90SW5LZXlzID8gY2xlYW5Sb290LnJlcGxhY2UoLyUyRS9nLCAnLicpIDogY2xlYW5Sb290O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoZGVjb2RlZFJvb3QsIDEwKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wYXJzZUFycmF5cyAmJiBkZWNvZGVkUm9vdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB7IDA6IGxlYWYgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgICAgICYmIHJvb3QgIT09IGRlY29kZWRSb290XG4gICAgICAgICAgICAgICAgJiYgU3RyaW5nKGluZGV4KSA9PT0gZGVjb2RlZFJvb3RcbiAgICAgICAgICAgICAgICAmJiBpbmRleCA+PSAwXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlY29kZWRSb290ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgIG9ialtkZWNvZGVkUm9vdF0gPSBsZWFmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZiA9IG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVhZjtcbn07XG5cbnZhciBwYXJzZUtleXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nS2V5cyhnaXZlbktleSwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcbiAgICBpZiAoIWdpdmVuS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cbiAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXG5cbiAgICB2YXIgYnJhY2tldHMgPSAvKFxcW1teW1xcXV0qXSkvO1xuICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gb3B0aW9ucy5kZXB0aCA+IDAgJiYgYnJhY2tldHMuZXhlYyhrZXkpO1xuICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgcGxhaW4gb2JqZWN0cywgb3B0aW9uYWxseSBwcmVmaXgga2V5cyB0aGF0IHdvdWxkIG92ZXJ3cml0ZSBvYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKG9wdGlvbnMuZGVwdGggPiAwICYmIChzZWdtZW50ID0gY2hpbGQuZXhlYyhrZXkpKSAhPT0gbnVsbCAmJiBpIDwgb3B0aW9ucy5kZXB0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc2VnbWVudFsxXS5zbGljZSgxLCAtMSkpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBjaGVjayBzdHJpY3REZXB0aCBvcHRpb24gZm9yIHRocm93LCBlbHNlIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdERlcHRoID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5wdXQgZGVwdGggZXhjZWVkZWQgZGVwdGggb3B0aW9uIG9mICcgKyBvcHRpb25zLmRlcHRoICsgJyBhbmQgc3RyaWN0RGVwdGggaXMgdHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCk7XG59O1xuXG52YXIgbm9ybWFsaXplUGFyc2VPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplUGFyc2VPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGFsbG93RW1wdHlBcnJheXNgIG9wdGlvbiBjYW4gb25seSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYCwgd2hlbiBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5kZWNvZGVEb3RJbktleXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmRlY29kZURvdEluS2V5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BkZWNvZGVEb3RJbktleXNgIG9wdGlvbiBjYW4gb25seSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYCwgd2hlbiBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmRlY29kZXIgIT09IG51bGwgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgdmFyIGNoYXJzZXQgPSB0eXBlb2Ygb3B0cy5jaGFyc2V0ID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmNoYXJzZXQgOiBvcHRzLmNoYXJzZXQ7XG5cbiAgICB2YXIgZHVwbGljYXRlcyA9IHR5cGVvZiBvcHRzLmR1cGxpY2F0ZXMgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZHVwbGljYXRlcyA6IG9wdHMuZHVwbGljYXRlcztcblxuICAgIGlmIChkdXBsaWNhdGVzICE9PSAnY29tYmluZScgJiYgZHVwbGljYXRlcyAhPT0gJ2ZpcnN0JyAmJiBkdXBsaWNhdGVzICE9PSAnbGFzdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGR1cGxpY2F0ZXMgb3B0aW9uIG11c3QgYmUgZWl0aGVyIGNvbWJpbmUsIGZpcnN0LCBvciBsYXN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGFsbG93RG90cyA9IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmRlY29kZURvdEluS2V5cyA9PT0gdHJ1ZSA/IHRydWUgOiBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxsb3dEb3RzOiBhbGxvd0RvdHMsXG4gICAgICAgIGFsbG93RW1wdHlBcnJheXM6IHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgPT09ICdib29sZWFuJyA/ICEhb3B0cy5hbGxvd0VtcHR5QXJyYXlzIDogZGVmYXVsdHMuYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgYWxsb3dQcm90b3R5cGVzOiB0eXBlb2Ygb3B0cy5hbGxvd1Byb3RvdHlwZXMgPT09ICdib29sZWFuJyA/IG9wdHMuYWxsb3dQcm90b3R5cGVzIDogZGVmYXVsdHMuYWxsb3dQcm90b3R5cGVzLFxuICAgICAgICBhbGxvd1NwYXJzZTogdHlwZW9mIG9wdHMuYWxsb3dTcGFyc2UgPT09ICdib29sZWFuJyA/IG9wdHMuYWxsb3dTcGFyc2UgOiBkZWZhdWx0cy5hbGxvd1NwYXJzZSxcbiAgICAgICAgYXJyYXlMaW1pdDogdHlwZW9mIG9wdHMuYXJyYXlMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLmFycmF5TGltaXQgOiBkZWZhdWx0cy5hcnJheUxpbWl0LFxuICAgICAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgICAgICBjaGFyc2V0U2VudGluZWw6IHR5cGVvZiBvcHRzLmNoYXJzZXRTZW50aW5lbCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaGFyc2V0U2VudGluZWwgOiBkZWZhdWx0cy5jaGFyc2V0U2VudGluZWwsXG4gICAgICAgIGNvbW1hOiB0eXBlb2Ygb3B0cy5jb21tYSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jb21tYSA6IGRlZmF1bHRzLmNvbW1hLFxuICAgICAgICBkZWNvZGVEb3RJbktleXM6IHR5cGVvZiBvcHRzLmRlY29kZURvdEluS2V5cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5kZWNvZGVEb3RJbktleXMgOiBkZWZhdWx0cy5kZWNvZGVEb3RJbktleXMsXG4gICAgICAgIGRlY29kZXI6IHR5cGVvZiBvcHRzLmRlY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmRlY29kZXIgOiBkZWZhdWx0cy5kZWNvZGVyLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgdXRpbHMuaXNSZWdFeHAob3B0cy5kZWxpbWl0ZXIpID8gb3B0cy5kZWxpbWl0ZXIgOiBkZWZhdWx0cy5kZWxpbWl0ZXIsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvbiwgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgIGRlcHRoOiAodHlwZW9mIG9wdHMuZGVwdGggPT09ICdudW1iZXInIHx8IG9wdHMuZGVwdGggPT09IGZhbHNlKSA/ICtvcHRzLmRlcHRoIDogZGVmYXVsdHMuZGVwdGgsXG4gICAgICAgIGR1cGxpY2F0ZXM6IGR1cGxpY2F0ZXMsXG4gICAgICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBvcHRzLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlLFxuICAgICAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IHR5cGVvZiBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgOiBkZWZhdWx0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMsXG4gICAgICAgIHBhcmFtZXRlckxpbWl0OiB0eXBlb2Ygb3B0cy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLnBhcmFtZXRlckxpbWl0IDogZGVmYXVsdHMucGFyYW1ldGVyTGltaXQsXG4gICAgICAgIHBhcnNlQXJyYXlzOiBvcHRzLnBhcnNlQXJyYXlzICE9PSBmYWxzZSxcbiAgICAgICAgcGxhaW5PYmplY3RzOiB0eXBlb2Ygb3B0cy5wbGFpbk9iamVjdHMgPT09ICdib29sZWFuJyA/IG9wdHMucGxhaW5PYmplY3RzIDogZGVmYXVsdHMucGxhaW5PYmplY3RzLFxuICAgICAgICBzdHJpY3REZXB0aDogdHlwZW9mIG9wdHMuc3RyaWN0RGVwdGggPT09ICdib29sZWFuJyA/ICEhb3B0cy5zdHJpY3REZXB0aCA6IGRlZmF1bHRzLnN0cmljdERlcHRoLFxuICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmdcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cyk7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zLCB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XG4gICAgICAgIG9iaiA9IHV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd1NwYXJzZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0U2lkZUNoYW5uZWwgPSByZXF1aXJlKCdzaWRlLWNoYW5uZWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGFycmF5UHJlZml4R2VuZXJhdG9ycyA9IHtcbiAgICBicmFja2V0czogZnVuY3Rpb24gYnJhY2tldHMocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnW10nO1xuICAgIH0sXG4gICAgY29tbWE6ICdjb21tYScsXG4gICAgaW5kaWNlczogZnVuY3Rpb24gaW5kaWNlcyhwcmVmaXgsIGtleSkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1snICsga2V5ICsgJ10nO1xuICAgIH0sXG4gICAgcmVwZWF0OiBmdW5jdGlvbiByZXBlYXQocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfVxufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbnZhciBwdXNoVG9BcnJheSA9IGZ1bmN0aW9uIChhcnIsIHZhbHVlT3JBcnJheSkge1xuICAgIHB1c2guYXBwbHkoYXJyLCBpc0FycmF5KHZhbHVlT3JBcnJheSkgPyB2YWx1ZU9yQXJyYXkgOiBbdmFsdWVPckFycmF5XSk7XG59O1xuXG52YXIgdG9JU08gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGRlZmF1bHRGb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWRkUXVlcnlQcmVmaXg6IGZhbHNlLFxuICAgIGFsbG93RG90czogZmFsc2UsXG4gICAgYWxsb3dFbXB0eUFycmF5czogZmFsc2UsXG4gICAgYXJyYXlGb3JtYXQ6ICdpbmRpY2VzJyxcbiAgICBjaGFyc2V0OiAndXRmLTgnLFxuICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZURvdEluS2V5czogZmFsc2UsXG4gICAgZW5jb2RlcjogdXRpbHMuZW5jb2RlLFxuICAgIGVuY29kZVZhbHVlc09ubHk6IGZhbHNlLFxuICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcbiAgICBmb3JtYXR0ZXI6IGZvcm1hdHMuZm9ybWF0dGVyc1tkZWZhdWx0Rm9ybWF0XSxcbiAgICAvLyBkZXByZWNhdGVkXG4gICAgaW5kaWNlczogZmFsc2UsXG4gICAgc2VyaWFsaXplRGF0ZTogZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKGRhdGUpO1xuICAgIH0sXG4gICAgc2tpcE51bGxzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgaXNOb25OdWxsaXNoUHJpbWl0aXZlID0gZnVuY3Rpb24gaXNOb25OdWxsaXNoUHJpbWl0aXZlKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnc3ltYm9sJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCc7XG59O1xuXG52YXIgc2VudGluZWwgPSB7fTtcblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShcbiAgICBvYmplY3QsXG4gICAgcHJlZml4LFxuICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgY29tbWFSb3VuZFRyaXAsXG4gICAgYWxsb3dFbXB0eUFycmF5cyxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgc2tpcE51bGxzLFxuICAgIGVuY29kZURvdEluS2V5cyxcbiAgICBlbmNvZGVyLFxuICAgIGZpbHRlcixcbiAgICBzb3J0LFxuICAgIGFsbG93RG90cyxcbiAgICBzZXJpYWxpemVEYXRlLFxuICAgIGZvcm1hdCxcbiAgICBmb3JtYXR0ZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICBjaGFyc2V0LFxuICAgIHNpZGVDaGFubmVsXG4pIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuXG4gICAgdmFyIHRtcFNjID0gc2lkZUNoYW5uZWw7XG4gICAgdmFyIHN0ZXAgPSAwO1xuICAgIHZhciBmaW5kRmxhZyA9IGZhbHNlO1xuICAgIHdoaWxlICgodG1wU2MgPSB0bXBTYy5nZXQoc2VudGluZWwpKSAhPT0gdm9pZCB1bmRlZmluZWQgJiYgIWZpbmRGbGFnKSB7XG4gICAgICAgIC8vIFdoZXJlIG9iamVjdCBsYXN0IGFwcGVhcmVkIGluIHRoZSByZWYgdHJlZVxuICAgICAgICB2YXIgcG9zID0gdG1wU2MuZ2V0KG9iamVjdCk7XG4gICAgICAgIHN0ZXAgKz0gMTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAocG9zID09PSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0N5Y2xpYyBvYmplY3QgdmFsdWUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluZEZsYWcgPSB0cnVlOyAvLyBCcmVhayB3aGlsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG1wU2MuZ2V0KHNlbnRpbmVsKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN0ZXAgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqID0gdXRpbHMubWF5YmVNYXAob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCkgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAoaXNOb25OdWxsaXNoUHJpbWl0aXZlKG9iaikgfHwgdXRpbHMuaXNCdWZmZXIob2JqKSkge1xuICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gZW5jb2RlVmFsdWVzT25seSA/IHByZWZpeCA6IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KTtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKGtleVZhbHVlKSArICc9JyArIGZvcm1hdHRlcihlbmNvZGVyKG9iaiwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJywgZm9ybWF0KSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZm9ybWF0dGVyKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXIoU3RyaW5nKG9iaikpXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBqb2luIGVsZW1lbnRzIGluXG4gICAgICAgIGlmIChlbmNvZGVWYWx1ZXNPbmx5ICYmIGVuY29kZXIpIHtcbiAgICAgICAgICAgIG9iaiA9IHV0aWxzLm1heWJlTWFwKG9iaiwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqS2V5cyA9IFt7IHZhbHVlOiBvYmoubGVuZ3RoID4gMCA/IG9iai5qb2luKCcsJykgfHwgbnVsbCA6IHZvaWQgdW5kZWZpbmVkIH1dO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBvYmpLZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG4gICAgfVxuXG4gICAgdmFyIGVuY29kZWRQcmVmaXggPSBlbmNvZGVEb3RJbktleXMgPyBwcmVmaXgucmVwbGFjZSgvXFwuL2csICclMkUnKSA6IHByZWZpeDtcblxuICAgIHZhciBhZGp1c3RlZFByZWZpeCA9IGNvbW1hUm91bmRUcmlwICYmIGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAxID8gZW5jb2RlZFByZWZpeCArICdbXScgOiBlbmNvZGVkUHJlZml4O1xuXG4gICAgaWYgKGFsbG93RW1wdHlBcnJheXMgJiYgaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFkanVzdGVkUHJlZml4ICsgJ1tdJztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iaktleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbal07XG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkudmFsdWUgIT09ICd1bmRlZmluZWQnID8ga2V5LnZhbHVlIDogb2JqW2tleV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5jb2RlZEtleSA9IGFsbG93RG90cyAmJiBlbmNvZGVEb3RJbktleXMgPyBrZXkucmVwbGFjZSgvXFwuL2csICclMkUnKSA6IGtleTtcbiAgICAgICAgdmFyIGtleVByZWZpeCA9IGlzQXJyYXkob2JqKVxuICAgICAgICAgICAgPyB0eXBlb2YgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2Z1bmN0aW9uJyA/IGdlbmVyYXRlQXJyYXlQcmVmaXgoYWRqdXN0ZWRQcmVmaXgsIGVuY29kZWRLZXkpIDogYWRqdXN0ZWRQcmVmaXhcbiAgICAgICAgICAgIDogYWRqdXN0ZWRQcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsgZW5jb2RlZEtleSA6ICdbJyArIGVuY29kZWRLZXkgKyAnXScpO1xuXG4gICAgICAgIHNpZGVDaGFubmVsLnNldChvYmplY3QsIHN0ZXApO1xuICAgICAgICB2YXIgdmFsdWVTaWRlQ2hhbm5lbCA9IGdldFNpZGVDaGFubmVsKCk7XG4gICAgICAgIHZhbHVlU2lkZUNoYW5uZWwuc2V0KHNlbnRpbmVsLCBzaWRlQ2hhbm5lbCk7XG4gICAgICAgIHB1c2hUb0FycmF5KHZhbHVlcywgc3RyaW5naWZ5KFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBrZXlQcmVmaXgsXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgY29tbWFSb3VuZFRyaXAsXG4gICAgICAgICAgICBhbGxvd0VtcHR5QXJyYXlzLFxuICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgZW5jb2RlRG90SW5LZXlzLFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBlbmNvZGVWYWx1ZXNPbmx5ICYmIGlzQXJyYXkob2JqKSA/IG51bGwgOiBlbmNvZGVyLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgY2hhcnNldCxcbiAgICAgICAgICAgIHZhbHVlU2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbnZhciBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BhbGxvd0VtcHR5QXJyYXlzYCBvcHRpb24gY2FuIG9ubHkgYmUgYHRydWVgIG9yIGBmYWxzZWAsIHdoZW4gcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuZW5jb2RlRG90SW5LZXlzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVEb3RJbktleXMgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgZW5jb2RlRG90SW5LZXlzYCBvcHRpb24gY2FuIG9ubHkgYmUgYHRydWVgIG9yIGBmYWxzZWAsIHdoZW4gcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5lbmNvZGVyICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcnNldCA9IG9wdHMuY2hhcnNldCB8fCBkZWZhdWx0cy5jaGFyc2V0O1xuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5mb3JtYXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghaGFzLmNhbGwoZm9ybWF0cy5mb3JtYXR0ZXJzLCBvcHRzLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBvcHRzLmZvcm1hdDtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgdmFyIGZpbHRlciA9IGRlZmF1bHRzLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIG9wdHMuZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGlzQXJyYXkob3B0cy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdHMuZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBhcnJheUZvcm1hdDtcbiAgICBpZiAob3B0cy5hcnJheUZvcm1hdCBpbiBhcnJheVByZWZpeEdlbmVyYXRvcnMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmFycmF5Rm9ybWF0O1xuICAgIH0gZWxzZSBpZiAoJ2luZGljZXMnIGluIG9wdHMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmluZGljZXMgPyAnaW5kaWNlcycgOiAncmVwZWF0JztcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheUZvcm1hdCA9IGRlZmF1bHRzLmFycmF5Rm9ybWF0O1xuICAgIH1cblxuICAgIGlmICgnY29tbWFSb3VuZFRyaXAnIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMuY29tbWFSb3VuZFRyaXAgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgY29tbWFSb3VuZFRyaXBgIG11c3QgYmUgYSBib29sZWFuLCBvciBhYnNlbnQnKTtcbiAgICB9XG5cbiAgICB2YXIgYWxsb3dEb3RzID0gdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IG9wdHMuZW5jb2RlRG90SW5LZXlzID09PSB0cnVlID8gdHJ1ZSA6IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRRdWVyeVByZWZpeDogdHlwZW9mIG9wdHMuYWRkUXVlcnlQcmVmaXggPT09ICdib29sZWFuJyA/IG9wdHMuYWRkUXVlcnlQcmVmaXggOiBkZWZhdWx0cy5hZGRRdWVyeVByZWZpeCxcbiAgICAgICAgYWxsb3dEb3RzOiBhbGxvd0RvdHMsXG4gICAgICAgIGFsbG93RW1wdHlBcnJheXM6IHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgPT09ICdib29sZWFuJyA/ICEhb3B0cy5hbGxvd0VtcHR5QXJyYXlzIDogZGVmYXVsdHMuYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgYXJyYXlGb3JtYXQ6IGFycmF5Rm9ybWF0LFxuICAgICAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgICAgICBjaGFyc2V0U2VudGluZWw6IHR5cGVvZiBvcHRzLmNoYXJzZXRTZW50aW5lbCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaGFyc2V0U2VudGluZWwgOiBkZWZhdWx0cy5jaGFyc2V0U2VudGluZWwsXG4gICAgICAgIGNvbW1hUm91bmRUcmlwOiBvcHRzLmNvbW1hUm91bmRUcmlwLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRzLmRlbGltaXRlcixcbiAgICAgICAgZW5jb2RlOiB0eXBlb2Ygb3B0cy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlLFxuICAgICAgICBlbmNvZGVEb3RJbktleXM6IHR5cGVvZiBvcHRzLmVuY29kZURvdEluS2V5cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGVEb3RJbktleXMgOiBkZWZhdWx0cy5lbmNvZGVEb3RJbktleXMsXG4gICAgICAgIGVuY29kZXI6IHR5cGVvZiBvcHRzLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyLFxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5OiB0eXBlb2Ygb3B0cy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICAgICAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgc2tpcE51bGxzOiB0eXBlb2Ygb3B0cy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdHMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzLFxuICAgICAgICBzb3J0OiB0eXBlb2Ygb3B0cy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0cy5zb3J0IDogbnVsbCxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpO1xuXG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5UHJlZml4R2VuZXJhdG9yc1tvcHRpb25zLmFycmF5Rm9ybWF0XTtcbiAgICB2YXIgY29tbWFSb3VuZFRyaXAgPSBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIG9wdGlvbnMuY29tbWFSb3VuZFRyaXA7XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5za2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hUb0FycmF5KGtleXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd0VtcHR5QXJyYXlzLFxuICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBvcHRpb25zLnNraXBOdWxscyxcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jb2RlRG90SW5LZXlzLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGUgPyBvcHRpb25zLmVuY29kZXIgOiBudWxsLFxuICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLnNvcnQsXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93RG90cyxcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgICAgb3B0aW9ucy5mb3JtYXR0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzZXQsXG4gICAgICAgICAgICBzaWRlQ2hhbm5lbFxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICB2YXIgam9pbmVkID0ga2V5cy5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy5hZGRRdWVyeVByZWZpeCA9PT0gdHJ1ZSA/ICc/JyA6ICcnO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpLCB0aGUgXCJudW1lcmljIGVudGl0eVwiIHJlcHJlc2VudGF0aW9uIG9mIGEgY2hlY2ttYXJrXG4gICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0ImJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgn4pyTJylcbiAgICAgICAgICAgIHByZWZpeCArPSAndXRmOD0lRTIlOUMlOTMmJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqb2luZWQubGVuZ3RoID4gMCA/IHByZWZpeCArIGpvaW5lZCA6ICcnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBoZXhUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICBhcnJheS5wdXNoKCclJyArICgoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn0oKSk7XG5cbnZhciBjb21wYWN0UXVldWUgPSBmdW5jdGlvbiBjb21wYWN0UXVldWUocXVldWUpIHtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICB2YXIgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFjdGVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKG9ialtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLm9ialtpdGVtLnByb3BdID0gY29tcGFjdGVkO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiBhcnJheVRvT2JqZWN0KHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zICYmIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb2JqW2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiAwICovXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucyAmJiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpKSB8fCAhaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtzb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbdGFyZ2V0LCBzb3VyY2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW3RhcmdldF0uY29uY2F0KHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgIWlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBtZXJnZVRhcmdldCA9IGFycmF5VG9PYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKHRhcmdldCwgaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SXRlbSA9IHRhcmdldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SXRlbSAmJiB0eXBlb2YgdGFyZ2V0SXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gbWVyZ2UodGFyZ2V0SXRlbSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChoYXMuY2FsbChhY2MsIGtleSkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gbWVyZ2UoYWNjW2tleV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBtZXJnZVRhcmdldCk7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduU2luZ2xlU291cmNlKHRhcmdldCwgc291cmNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBhY2Nba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRhcmdldCk7XG59O1xuXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gKHN0ciwgZGVjb2RlciwgY2hhcnNldCkge1xuICAgIHZhciBzdHJXaXRob3V0UGx1cyA9IHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIC8vIHVuZXNjYXBlIG5ldmVyIHRocm93cywgbm8gdHJ5Li4uY2F0Y2ggbmVlZGVkOlxuICAgICAgICByZXR1cm4gc3RyV2l0aG91dFBsdXMucmVwbGFjZSgvJVswLTlhLWZdezJ9L2dpLCB1bmVzY2FwZSk7XG4gICAgfVxuICAgIC8vIHV0Zi04XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHJXaXRob3V0UGx1cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RyV2l0aG91dFBsdXM7XG4gICAgfVxufTtcblxudmFyIGxpbWl0ID0gMTAyNDtcblxuLyogZXNsaW50IG9wZXJhdG9yLWxpbmVicmVhazogWzIsIFwiYmVmb3JlXCJdICovXG5cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoc3RyLCBkZWZhdWx0RW5jb2RlciwgY2hhcnNldCwga2luZCwgZm9ybWF0KSB7XG4gICAgLy8gVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQnJpYW4gV2hpdGUgKG1zY2RleCkgZm9yIHRoZSBpby5qcyBjb3JlIHF1ZXJ5c3RyaW5nIGxpYnJhcnkuXG4gICAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSBzdHI7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyaW5nID0gU3RyaW5nKHN0cik7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyUyNiUyMycgKyBwYXJzZUludCgkMC5zbGljZSgyKSwgMTYpICsgJyUzQic7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0cmluZy5sZW5ndGg7IGogKz0gbGltaXQpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzdHJpbmcubGVuZ3RoID49IGxpbWl0ID8gc3RyaW5nLnNsaWNlKGosIGogKyBsaW1pdCkgOiBzdHJpbmc7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gc2VnbWVudC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgICAgIHx8IGMgPT09IDB4MkUgLy8gLlxuICAgICAgICAgICAgICAgIHx8IGMgPT09IDB4NUYgLy8gX1xuICAgICAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgICAgIHx8IChjID49IDB4MzAgJiYgYyA8PSAweDM5KSAvLyAwLTlcbiAgICAgICAgICAgICAgICB8fCAoYyA+PSAweDQxICYmIGMgPD0gMHg1QSkgLy8gYS16XG4gICAgICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICAgICAgICAgIHx8IChmb3JtYXQgPT09IGZvcm1hdHMuUkZDMTczOCAmJiAoYyA9PT0gMHgyOCB8fCBjID09PSAweDI5KSkgLy8gKCApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBzZWdtZW50LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gaGV4VGFibGVbY107XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBoZXhUYWJsZVsweEMwIHwgKGMgPj4gNildXG4gICAgICAgICAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgICAgIGFyclthcnIubGVuZ3RoXSA9IGhleFRhYmxlWzB4RTAgfCAoYyA+PiAxMildXG4gICAgICAgICAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzZWdtZW50LmNoYXJDb2RlQXQoaSkgJiAweDNGRikpO1xuXG4gICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBoZXhUYWJsZVsweEYwIHwgKGMgPj4gMTgpXVxuICAgICAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV1cbiAgICAgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dCArPSBhcnIuam9pbignJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn07XG5cbnZhciBtYXliZU1hcCA9IGZ1bmN0aW9uIG1heWJlTWFwKHZhbCwgZm4pIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbih2YWwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21iaW5lOiBjb21iaW5lLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtYXliZU1hcDogbWF5YmVNYXAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1kYXRhLXByb3BlcnR5Jyk7XG52YXIgaGFzRGVzY3JpcHRvcnMgPSByZXF1aXJlKCdoYXMtcHJvcGVydHktZGVzY3JpcHRvcnMnKSgpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcbnZhciAkZmxvb3IgPSBHZXRJbnRyaW5zaWMoJyVNYXRoLmZsb29yJScpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXRGdW5jdGlvbkxlbmd0aChmbiwgbGVuZ3RoKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGZuYCBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHR9XG5cdGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBsZW5ndGggPCAwIHx8IGxlbmd0aCA+IDB4RkZGRkZGRkYgfHwgJGZsb29yKGxlbmd0aCkgIT09IGxlbmd0aCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbGVuZ3RoYCBtdXN0IGJlIGEgcG9zaXRpdmUgMzItYml0IGludGVnZXInKTtcblx0fVxuXG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmICEhYXJndW1lbnRzWzJdO1xuXG5cdHZhciBmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlID0gdHJ1ZTtcblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IHRydWU7XG5cdGlmICgnbGVuZ3RoJyBpbiBmbiAmJiBnT1BEKSB7XG5cdFx0dmFyIGRlc2MgPSBnT1BEKGZuLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChkZXNjICYmICFkZXNjLndyaXRhYmxlKSB7XG5cdFx0XHRmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRpZiAoZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSB8fCBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgfHwgIWxvb3NlKSB7XG5cdFx0aWYgKGhhc0Rlc2NyaXB0b3JzKSB7XG5cdFx0XHRkZWZpbmUoLyoqIEB0eXBlIHtQYXJhbWV0ZXJzPGRlZmluZT5bMF19ICovIChmbiksICdsZW5ndGgnLCBsZW5ndGgsIHRydWUsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWZpbmUoLyoqIEB0eXBlIHtQYXJhbWV0ZXJzPGRlZmluZT5bMF19ICovIChmbiksICdsZW5ndGgnLCBsZW5ndGgpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWluc3BlY3QnKTtcblxudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRXZWFrTWFwID0gR2V0SW50cmluc2ljKCclV2Vha01hcCUnLCB0cnVlKTtcbnZhciAkTWFwID0gR2V0SW50cmluc2ljKCclTWFwJScsIHRydWUpO1xuXG52YXIgJHdlYWtNYXBHZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xudmFyICR3ZWFrTWFwU2V0ID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5zZXQnLCB0cnVlKTtcbnZhciAkd2Vha01hcEhhcyA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG52YXIgJG1hcEdldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbnZhciAkbWFwU2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xudmFyICRtYXBIYXMgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG5cbi8qXG4qIFRoaXMgZnVuY3Rpb24gdHJhdmVyc2VzIHRoZSBsaXN0IHJldHVybmluZyB0aGUgbm9kZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXkuXG4qXG4qIFRoYXQgbm9kZSBpcyBhbHNvIG1vdmVkIHRvIHRoZSBoZWFkIG9mIHRoZSBsaXN0LCBzbyB0aGF0IGlmIGl0J3MgYWNjZXNzZWQgYWdhaW4gd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgd2hvbGUgbGlzdC4gQnkgZG9pbmcgc28sIGFsbCB0aGUgcmVjZW50bHkgdXNlZCBub2RlcyBjYW4gYmUgYWNjZXNzZWQgcmVsYXRpdmVseSBxdWlja2x5LlxuKi9cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJykubGlzdEdldE5vZGV9ICovXG52YXIgbGlzdEdldE5vZGUgPSBmdW5jdGlvbiAobGlzdCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0LyoqIEB0eXBlIHt0eXBlb2YgbGlzdCB8IE5vbk51bGxhYmxlPCh0eXBlb2YgbGlzdClbJ25leHQnXT59ICovXG5cdHZhciBwcmV2ID0gbGlzdDtcblx0LyoqIEB0eXBlIHsodHlwZW9mIGxpc3QpWyduZXh0J119ICovXG5cdHZhciBjdXJyO1xuXHRmb3IgKDsgKGN1cnIgPSBwcmV2Lm5leHQpICE9PSBudWxsOyBwcmV2ID0gY3Vycikge1xuXHRcdGlmIChjdXJyLmtleSA9PT0ga2V5KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBjdXJyLm5leHQ7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG5cdFx0XHRjdXJyLm5leHQgPSAvKiogQHR5cGUge05vbk51bGxhYmxlPHR5cGVvZiBsaXN0Lm5leHQ+fSAqLyAobGlzdC5uZXh0KTtcblx0XHRcdGxpc3QubmV4dCA9IGN1cnI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHRcdHJldHVybiBjdXJyO1xuXHRcdH1cblx0fVxufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKS5saXN0R2V0fSAqL1xudmFyIGxpc3RHZXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5KSB7XG5cdHZhciBub2RlID0gbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcblx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZTtcbn07XG4vKiogQHR5cGUge2ltcG9ydCgnLicpLmxpc3RTZXR9ICovXG52YXIgbGlzdFNldCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXksIHZhbHVlKSB7XG5cdHZhciBub2RlID0gbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcblx0aWYgKG5vZGUpIHtcblx0XHRub2RlLnZhbHVlID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gUHJlcGVuZCB0aGUgbmV3IG5vZGUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXHRcdG9iamVjdHMubmV4dCA9IC8qKiBAdHlwZSB7aW1wb3J0KCcuJykuTGlzdE5vZGU8dHlwZW9mIHZhbHVlPn0gKi8gKHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgbm8tZXh0cmEtcGFyZW5zXG5cdFx0XHRrZXk6IGtleSxcblx0XHRcdG5leHQ6IG9iamVjdHMubmV4dCxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH0pO1xuXHR9XG59O1xuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKS5saXN0SGFzfSAqL1xudmFyIGxpc3RIYXMgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5KSB7XG5cdHJldHVybiAhIWxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTaWRlQ2hhbm5lbCgpIHtcblx0LyoqIEB0eXBlIHtXZWFrTWFwPG9iamVjdCwgdW5rbm93bj59ICovIHZhciAkd207XG5cdC8qKiBAdHlwZSB7TWFwPG9iamVjdCwgdW5rbm93bj59ICovIHZhciAkbTtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4nKS5Sb290Tm9kZTx1bmtub3duPn0gKi8gdmFyICRvO1xuXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuJykuQ2hhbm5lbH0gKi9cblx0dmFyIGNoYW5uZWwgPSB7XG5cdFx0YXNzZXJ0OiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAoIWNoYW5uZWwuaGFzKGtleSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1NpZGUgY2hhbm5lbCBkb2VzIG5vdCBjb250YWluICcgKyBpbnNwZWN0KGtleSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2V0OiBmdW5jdGlvbiAoa2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdGlmICgkd20pIHtcblx0XHRcdFx0XHRyZXR1cm4gJHdlYWtNYXBHZXQoJHdtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCRNYXApIHtcblx0XHRcdFx0aWYgKCRtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICRtYXBHZXQoJG0sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgkbykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmVseS1pZlxuXHRcdFx0XHRcdHJldHVybiBsaXN0R2V0KCRvLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoYXM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdGlmICgkd20pIHtcblx0XHRcdFx0XHRyZXR1cm4gJHdlYWtNYXBIYXMoJHdtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCRNYXApIHtcblx0XHRcdFx0aWYgKCRtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICRtYXBIYXMoJG0sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgkbykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmVseS1pZlxuXHRcdFx0XHRcdHJldHVybiBsaXN0SGFzKCRvLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoISR3bSkge1xuXHRcdFx0XHRcdCR3bSA9IG5ldyAkV2Vha01hcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCR3ZWFrTWFwU2V0KCR3bSwga2V5LCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKCRNYXApIHtcblx0XHRcdFx0aWYgKCEkbSkge1xuXHRcdFx0XHRcdCRtID0gbmV3ICRNYXAoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkbWFwU2V0KCRtLCBrZXksIHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghJG8pIHtcblx0XHRcdFx0XHQvLyBJbml0aWFsaXplIHRoZSBsaW5rZWQgbGlzdCBhcyBhbiBlbXB0eSBub2RlLCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gc3BlY2lhbC1jYXNlIGhhbmRsaW5nIG9mIHRoZSBmaXJzdCBub2RlOiB3ZSBjYW4gYWx3YXlzIHJlZmVyIHRvIGl0IGFzIChwcmV2aW91cyBub2RlKS5uZXh0LCBpbnN0ZWFkIG9mIHNvbWV0aGluZyBsaWtlIChsaXN0KS5oZWFkXG5cdFx0XHRcdFx0JG8gPSB7IGtleToge30sIG5leHQ6IG51bGwgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0U2V0KCRvLCBrZXksIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBjaGFubmVsO1xufTtcbiIsIi8qXG4gICAgIF8gXyAgICAgIF8gICAgICAgX1xuIF9fX3wgKF8pIF9fX3wgfCBfXyAgKF8pX19fXG4vIF9ffCB8IHwvIF9ffCB8LyAvICB8IC8gX198XG5cXF9fIFxcIHwgfCAoX198ICAgPCBfIHwgXFxfXyBcXFxufF9fXy9ffF98XFxfX198X3xcXF8oXykvIHxfX18vXG4gICAgICAgICAgICAgICAgICAgfF9fL1xuXG4gVmVyc2lvbjogMS44LjFcbiAgQXV0aG9yOiBLZW4gV2hlZWxlclxuIFdlYnNpdGU6IGh0dHA6Ly9rZW53aGVlbGVyLmdpdGh1Yi5pb1xuICAgIERvY3M6IGh0dHA6Ly9rZW53aGVlbGVyLmdpdGh1Yi5pby9zbGlja1xuICAgIFJlcG86IGh0dHA6Ly9naXRodWIuY29tL2tlbndoZWVsZXIvc2xpY2tcbiAgSXNzdWVzOiBodHRwOi8vZ2l0aHViLmNvbS9rZW53aGVlbGVyL3NsaWNrL2lzc3Vlc1xuXG4gKi9cbi8qIGdsb2JhbCB3aW5kb3csIGRvY3VtZW50LCBkZWZpbmUsIGpRdWVyeSwgc2V0SW50ZXJ2YWwsIGNsZWFySW50ZXJ2YWwgKi9cbjsoZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoalF1ZXJ5KTtcbiAgICB9XG5cbn0oZnVuY3Rpb24oJCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgU2xpY2sgPSB3aW5kb3cuU2xpY2sgfHwge307XG5cbiAgICBTbGljayA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgaW5zdGFuY2VVaWQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIFNsaWNrKGVsZW1lbnQsIHNldHRpbmdzKSB7XG5cbiAgICAgICAgICAgIHZhciBfID0gdGhpcywgZGF0YVNldHRpbmdzO1xuXG4gICAgICAgICAgICBfLmRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgYWRhcHRpdmVIZWlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFwcGVuZEFycm93czogJChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBhcHBlbmREb3RzOiAkKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGFycm93czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhc05hdkZvcjogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmV2QXJyb3c6ICc8YnV0dG9uIGNsYXNzPVwic2xpY2stcHJldlwiIGFyaWEtbGFiZWw9XCJQcmV2aW91c1wiIHR5cGU9XCJidXR0b25cIj5QcmV2aW91czwvYnV0dG9uPicsXG4gICAgICAgICAgICAgICAgbmV4dEFycm93OiAnPGJ1dHRvbiBjbGFzcz1cInNsaWNrLW5leHRcIiBhcmlhLWxhYmVsPVwiTmV4dFwiIHR5cGU9XCJidXR0b25cIj5OZXh0PC9idXR0b24+JyxcbiAgICAgICAgICAgICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXV0b3BsYXlTcGVlZDogMzAwMCxcbiAgICAgICAgICAgICAgICBjZW50ZXJNb2RlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjZW50ZXJQYWRkaW5nOiAnNTBweCcsXG4gICAgICAgICAgICAgICAgY3NzRWFzZTogJ2Vhc2UnLFxuICAgICAgICAgICAgICAgIGN1c3RvbVBhZ2luZzogZnVuY3Rpb24oc2xpZGVyLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiAvPicpLnRleHQoaSArIDEpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG90czogZmFsc2UsXG4gICAgICAgICAgICAgICAgZG90c0NsYXNzOiAnc2xpY2stZG90cycsXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgICAgICAgICAgZWRnZUZyaWN0aW9uOiAwLjM1LFxuICAgICAgICAgICAgICAgIGZhZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZvY3VzT25TZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZvY3VzT25DaGFuZ2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGluZmluaXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluaXRpYWxTbGlkZTogMCxcbiAgICAgICAgICAgICAgICBsYXp5TG9hZDogJ29uZGVtYW5kJyxcbiAgICAgICAgICAgICAgICBtb2JpbGVGaXJzdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhdXNlT25Gb2N1czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXVzZU9uRG90c0hvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXNwb25kVG86ICd3aW5kb3cnLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNpdmU6IG51bGwsXG4gICAgICAgICAgICAgICAgcm93czogMSxcbiAgICAgICAgICAgICAgICBydGw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNsaWRlOiAnJyxcbiAgICAgICAgICAgICAgICBzbGlkZXNQZXJSb3c6IDEsXG4gICAgICAgICAgICAgICAgc2xpZGVzVG9TaG93OiAxLFxuICAgICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICAgICAgICAgICAgICAgIHNwZWVkOiA1MDAsXG4gICAgICAgICAgICAgICAgc3dpcGU6IHRydWUsXG4gICAgICAgICAgICAgICAgc3dpcGVUb1NsaWRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b3VjaE1vdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgdG91Y2hUaHJlc2hvbGQ6IDUsXG4gICAgICAgICAgICAgICAgdXNlQ1NTOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVzZVRyYW5zZm9ybTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZVdpZHRoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmVydGljYWxTd2lwaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YWl0Rm9yQW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDEwMDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF8uaW5pdGlhbHMgPSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXV0b1BsYXlUaW1lcjogbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50RGlyZWN0aW9uOiAwLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZWZ0OiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTbGlkZTogMCxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgJGRvdHM6IG51bGwsXG4gICAgICAgICAgICAgICAgbGlzdFdpZHRoOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpc3RIZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbG9hZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgICRuZXh0QXJyb3c6IG51bGwsXG4gICAgICAgICAgICAgICAgJHByZXZBcnJvdzogbnVsbCxcbiAgICAgICAgICAgICAgICBzY3JvbGxpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNsaWRlQ291bnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc2xpZGVXaWR0aDogbnVsbCxcbiAgICAgICAgICAgICAgICAkc2xpZGVUcmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAkc2xpZGVzOiBudWxsLFxuICAgICAgICAgICAgICAgIHNsaWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNsaWRlT2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIHN3aXBlTGVmdDogbnVsbCxcbiAgICAgICAgICAgICAgICBzd2lwaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAkbGlzdDogbnVsbCxcbiAgICAgICAgICAgICAgICB0b3VjaE9iamVjdDoge30sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3Jtc0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuc2xpY2tlZDogZmFsc2VcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQuZXh0ZW5kKF8sIF8uaW5pdGlhbHMpO1xuXG4gICAgICAgICAgICBfLmFjdGl2ZUJyZWFrcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9IG51bGw7XG4gICAgICAgICAgICBfLmFuaW1Qcm9wID0gbnVsbDtcbiAgICAgICAgICAgIF8uYnJlYWtwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIF8uYnJlYWtwb2ludFNldHRpbmdzID0gW107XG4gICAgICAgICAgICBfLmNzc1RyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgICAgICBfLmZvY3Vzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBfLmludGVycnVwdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBfLmhpZGRlbiA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgXy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgXy5wb3NpdGlvblByb3AgPSBudWxsO1xuICAgICAgICAgICAgXy5yZXNwb25kVG8gPSBudWxsO1xuICAgICAgICAgICAgXy5yb3dDb3VudCA9IDE7XG4gICAgICAgICAgICBfLnNob3VsZENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIF8uJHNsaWRlciA9ICQoZWxlbWVudCk7XG4gICAgICAgICAgICBfLiRzbGlkZXNDYWNoZSA9IG51bGw7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgXy50cmFuc2l0aW9uVHlwZSA9IG51bGw7XG4gICAgICAgICAgICBfLnZpc2liaWxpdHlDaGFuZ2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICBfLndpbmRvd1dpZHRoID0gMDtcbiAgICAgICAgICAgIF8ud2luZG93VGltZXIgPSBudWxsO1xuXG4gICAgICAgICAgICBkYXRhU2V0dGluZ3MgPSAkKGVsZW1lbnQpLmRhdGEoJ3NsaWNrJykgfHwge307XG5cbiAgICAgICAgICAgIF8ub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBfLmRlZmF1bHRzLCBzZXR0aW5ncywgZGF0YVNldHRpbmdzKTtcblxuICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLm9wdGlvbnMuaW5pdGlhbFNsaWRlO1xuXG4gICAgICAgICAgICBfLm9yaWdpbmFsU2V0dGluZ3MgPSBfLm9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIF8uaGlkZGVuID0gJ21vekhpZGRlbic7XG4gICAgICAgICAgICAgICAgXy52aXNpYmlsaXR5Q2hhbmdlID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQud2Via2l0SGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIF8uaGlkZGVuID0gJ3dlYmtpdEhpZGRlbic7XG4gICAgICAgICAgICAgICAgXy52aXNpYmlsaXR5Q2hhbmdlID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLmF1dG9QbGF5ID0gJC5wcm94eShfLmF1dG9QbGF5LCBfKTtcbiAgICAgICAgICAgIF8uYXV0b1BsYXlDbGVhciA9ICQucHJveHkoXy5hdXRvUGxheUNsZWFyLCBfKTtcbiAgICAgICAgICAgIF8uYXV0b1BsYXlJdGVyYXRvciA9ICQucHJveHkoXy5hdXRvUGxheUl0ZXJhdG9yLCBfKTtcbiAgICAgICAgICAgIF8uY2hhbmdlU2xpZGUgPSAkLnByb3h5KF8uY2hhbmdlU2xpZGUsIF8pO1xuICAgICAgICAgICAgXy5jbGlja0hhbmRsZXIgPSAkLnByb3h5KF8uY2xpY2tIYW5kbGVyLCBfKTtcbiAgICAgICAgICAgIF8uc2VsZWN0SGFuZGxlciA9ICQucHJveHkoXy5zZWxlY3RIYW5kbGVyLCBfKTtcbiAgICAgICAgICAgIF8uc2V0UG9zaXRpb24gPSAkLnByb3h5KF8uc2V0UG9zaXRpb24sIF8pO1xuICAgICAgICAgICAgXy5zd2lwZUhhbmRsZXIgPSAkLnByb3h5KF8uc3dpcGVIYW5kbGVyLCBfKTtcbiAgICAgICAgICAgIF8uZHJhZ0hhbmRsZXIgPSAkLnByb3h5KF8uZHJhZ0hhbmRsZXIsIF8pO1xuICAgICAgICAgICAgXy5rZXlIYW5kbGVyID0gJC5wcm94eShfLmtleUhhbmRsZXIsIF8pO1xuXG4gICAgICAgICAgICBfLmluc3RhbmNlVWlkID0gaW5zdGFuY2VVaWQrKztcblxuICAgICAgICAgICAgLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcbiAgICAgICAgICAgIC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uIChtdXN0IHN0YXJ0IHdpdGggPClcbiAgICAgICAgICAgIC8vIEV4dHJhY3RlZCBmcm9tIGpRdWVyeSB2MS4xMSBzb3VyY2VcbiAgICAgICAgICAgIF8uaHRtbEV4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSopJC87XG5cblxuICAgICAgICAgICAgXy5yZWdpc3RlckJyZWFrcG9pbnRzKCk7XG4gICAgICAgICAgICBfLmluaXQodHJ1ZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTbGljaztcblxuICAgIH0oKSk7XG5cbiAgICBTbGljay5wcm90b3R5cGUuYWN0aXZhdGVBREEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suZmluZCgnLnNsaWNrLWFjdGl2ZScpLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ2ZhbHNlJ1xuICAgICAgICB9KS5maW5kKCdhLCBpbnB1dCwgYnV0dG9uLCBzZWxlY3QnKS5hdHRyKHtcbiAgICAgICAgICAgICd0YWJpbmRleCc6ICcwJ1xuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYWRkU2xpZGUgPSBTbGljay5wcm90b3R5cGUuc2xpY2tBZGQgPSBmdW5jdGlvbihtYXJrdXAsIGluZGV4LCBhZGRCZWZvcmUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZihpbmRleCkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgYWRkQmVmb3JlID0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCAwIHx8IChpbmRleCA+PSBfLnNsaWRlQ291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBfLnVubG9hZCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YoaW5kZXgpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIF8uJHNsaWRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAkKG1hcmt1cCkuYXBwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFkZEJlZm9yZSkge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5pbnNlcnRCZWZvcmUoXy4kc2xpZGVzLmVxKGluZGV4KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5pbnNlcnRBZnRlcihfLiRzbGlkZXMuZXEoaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhZGRCZWZvcmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAkKG1hcmt1cCkucHJlcGVuZFRvKF8uJHNsaWRlVHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKG1hcmt1cCkuYXBwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfLiRzbGlkZXMgPSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suYXBwZW5kKF8uJHNsaWRlcyk7XG5cbiAgICAgICAgXy4kc2xpZGVzLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICQoZWxlbWVudCkuYXR0cignZGF0YS1zbGljay1pbmRleCcsIGluZGV4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy4kc2xpZGVzQ2FjaGUgPSBfLiRzbGlkZXM7XG5cbiAgICAgICAgXy5yZWluaXQoKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYW5pbWF0ZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXM7XG4gICAgICAgIGlmIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID09PSAxICYmIF8ub3B0aW9ucy5hZGFwdGl2ZUhlaWdodCA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gXy4kc2xpZGVzLmVxKF8uY3VycmVudFNsaWRlKS5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAgICAgICAgIF8uJGxpc3QuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0YXJnZXRIZWlnaHRcbiAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmFuaW1hdGVTbGlkZSA9IGZ1bmN0aW9uKHRhcmdldExlZnQsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgdmFyIGFuaW1Qcm9wcyA9IHt9LFxuICAgICAgICAgICAgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5hbmltYXRlSGVpZ2h0KCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5ydGwgPT09IHRydWUgJiYgXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IC10YXJnZXRMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLnRyYW5zZm9ybXNFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRMZWZ0XG4gICAgICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkLCBfLm9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGFyZ2V0TGVmdFxuICAgICAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCwgXy5vcHRpb25zLmVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChfLmNzc1RyYW5zaXRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uY3VycmVudExlZnQgPSAtKF8uY3VycmVudExlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbVN0YXJ0OiBfLmN1cnJlbnRMZWZ0XG4gICAgICAgICAgICAgICAgfSkuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1TdGFydDogdGFyZ2V0TGVmdFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IF8ub3B0aW9ucy5zcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBfLm9wdGlvbnMuZWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICBzdGVwOiBmdW5jdGlvbihub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9IE1hdGguY2VpbChub3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltUHJvcHNbXy5hbmltVHlwZV0gPSAndHJhbnNsYXRlKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgKyAncHgsIDBweCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKGFuaW1Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUoMHB4LCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgKyAncHgpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhhbmltUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF8uYXBwbHlUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IE1hdGguY2VpbCh0YXJnZXRMZWZ0KTtcblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUzZCgnICsgdGFyZ2V0TGVmdCArICdweCwgMHB4LCAwcHgpJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbmltUHJvcHNbXy5hbmltVHlwZV0gPSAndHJhbnNsYXRlM2QoMHB4LCcgKyB0YXJnZXRMZWZ0ICsgJ3B4LCAwcHgpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MoYW5pbVByb3BzKTtcblxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmRpc2FibGVUcmFuc2l0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldE5hdlRhcmdldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGFzTmF2Rm9yID0gXy5vcHRpb25zLmFzTmF2Rm9yO1xuXG4gICAgICAgIGlmICggYXNOYXZGb3IgJiYgYXNOYXZGb3IgIT09IG51bGwgKSB7XG4gICAgICAgICAgICBhc05hdkZvciA9ICQoYXNOYXZGb3IpLm5vdChfLiRzbGlkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzTmF2Rm9yO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hc05hdkZvciA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgYXNOYXZGb3IgPSBfLmdldE5hdlRhcmdldCgpO1xuXG4gICAgICAgIGlmICggYXNOYXZGb3IgIT09IG51bGwgJiYgdHlwZW9mIGFzTmF2Rm9yID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgIGFzTmF2Rm9yLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9ICQodGhpcykuc2xpY2soJ2dldFNsaWNrJyk7XG4gICAgICAgICAgICAgICAgaWYoIXRhcmdldC51bnNsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNsaWRlSGFuZGxlcihpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYXBwbHlUcmFuc2l0aW9uID0gZnVuY3Rpb24oc2xpZGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICB0cmFuc2l0aW9uID0ge307XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbltfLnRyYW5zaXRpb25UeXBlXSA9IF8udHJhbnNmb3JtVHlwZSArICcgJyArIF8ub3B0aW9ucy5zcGVlZCArICdtcyAnICsgXy5vcHRpb25zLmNzc0Vhc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uW18udHJhbnNpdGlvblR5cGVdID0gJ29wYWNpdHkgJyArIF8ub3B0aW9ucy5zcGVlZCArICdtcyAnICsgXy5vcHRpb25zLmNzc0Vhc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyh0cmFuc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZSkuY3NzKHRyYW5zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmF1dG9QbGF5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uYXV0b1BsYXlDbGVhcigpO1xuXG4gICAgICAgIGlmICggXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyApIHtcbiAgICAgICAgICAgIF8uYXV0b1BsYXlUaW1lciA9IHNldEludGVydmFsKCBfLmF1dG9QbGF5SXRlcmF0b3IsIF8ub3B0aW9ucy5hdXRvcGxheVNwZWVkICk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYXV0b1BsYXlDbGVhciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5hdXRvUGxheVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKF8uYXV0b1BsYXlUaW1lcik7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYXV0b1BsYXlJdGVyYXRvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHNsaWRlVG8gPSBfLmN1cnJlbnRTbGlkZSArIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcblxuICAgICAgICBpZiAoICFfLnBhdXNlZCAmJiAhXy5pbnRlcnJ1cHRlZCAmJiAhXy5mb2N1c3NlZCApIHtcblxuICAgICAgICAgICAgaWYgKCBfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBfLmRpcmVjdGlvbiA9PT0gMSAmJiAoIF8uY3VycmVudFNsaWRlICsgMSApID09PSAoIF8uc2xpZGVDb3VudCAtIDEgKSkge1xuICAgICAgICAgICAgICAgICAgICBfLmRpcmVjdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIF8uZGlyZWN0aW9uID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNsaWRlVG8gPSBfLmN1cnJlbnRTbGlkZSAtIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIF8uY3VycmVudFNsaWRlIC0gMSA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKCBzbGlkZVRvICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5idWlsZEFycm93cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgXy4kcHJldkFycm93ID0gJChfLm9wdGlvbnMucHJldkFycm93KS5hZGRDbGFzcygnc2xpY2stYXJyb3cnKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdyA9ICQoXy5vcHRpb25zLm5leHRBcnJvdykuYWRkQ2xhc3MoJ3NsaWNrLWFycm93Jyk7XG5cbiAgICAgICAgICAgIGlmKCBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICkge1xuXG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZUNsYXNzKCdzbGljay1oaWRkZW4nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCcpO1xuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2staGlkZGVuJykucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4gdGFiaW5kZXgnKTtcblxuICAgICAgICAgICAgICAgIGlmIChfLmh0bWxFeHByLnRlc3QoXy5vcHRpb25zLnByZXZBcnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgXy4kcHJldkFycm93LnByZXBlbmRUbyhfLm9wdGlvbnMuYXBwZW5kQXJyb3dzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5odG1sRXhwci50ZXN0KF8ub3B0aW9ucy5uZXh0QXJyb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5hcHBlbmRUbyhfLm9wdGlvbnMuYXBwZW5kQXJyb3dzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1kaXNhYmxlZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LmFkZCggXy4kbmV4dEFycm93IClcblxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWhpZGRlbicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogJy0xJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYnVpbGREb3RzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgaSwgZG90O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZG90cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlci5hZGRDbGFzcygnc2xpY2stZG90dGVkJyk7XG5cbiAgICAgICAgICAgIGRvdCA9ICQoJzx1bCAvPicpLmFkZENsYXNzKF8ub3B0aW9ucy5kb3RzQ2xhc3MpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IF8uZ2V0RG90Q291bnQoKTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZG90LmFwcGVuZCgkKCc8bGkgLz4nKS5hcHBlbmQoXy5vcHRpb25zLmN1c3RvbVBhZ2luZy5jYWxsKHRoaXMsIF8sIGkpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uJGRvdHMgPSBkb3QuYXBwZW5kVG8oXy5vcHRpb25zLmFwcGVuZERvdHMpO1xuXG4gICAgICAgICAgICBfLiRkb3RzLmZpbmQoJ2xpJykuZmlyc3QoKS5hZGRDbGFzcygnc2xpY2stYWN0aXZlJyk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5idWlsZE91dCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLiRzbGlkZXMgPVxuICAgICAgICAgICAgXy4kc2xpZGVyXG4gICAgICAgICAgICAgICAgLmNoaWxkcmVuKCBfLm9wdGlvbnMuc2xpZGUgKyAnOm5vdCguc2xpY2stY2xvbmVkKScpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1zbGlkZScpO1xuXG4gICAgICAgIF8uc2xpZGVDb3VudCA9IF8uJHNsaWRlcy5sZW5ndGg7XG5cbiAgICAgICAgXy4kc2xpZGVzLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAgICAgICAuYXR0cignZGF0YS1zbGljay1pbmRleCcsIGluZGV4KVxuICAgICAgICAgICAgICAgIC5kYXRhKCdvcmlnaW5hbFN0eWxpbmcnLCAkKGVsZW1lbnQpLmF0dHIoJ3N0eWxlJykgfHwgJycpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfLiRzbGlkZXIuYWRkQ2xhc3MoJ3NsaWNrLXNsaWRlcicpO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2sgPSAoXy5zbGlkZUNvdW50ID09PSAwKSA/XG4gICAgICAgICAgICAkKCc8ZGl2IGNsYXNzPVwic2xpY2stdHJhY2tcIi8+JykuYXBwZW5kVG8oXy4kc2xpZGVyKSA6XG4gICAgICAgICAgICBfLiRzbGlkZXMud3JhcEFsbCgnPGRpdiBjbGFzcz1cInNsaWNrLXRyYWNrXCIvPicpLnBhcmVudCgpO1xuXG4gICAgICAgIF8uJGxpc3QgPSBfLiRzbGlkZVRyYWNrLndyYXAoXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInNsaWNrLWxpc3RcIi8+JykucGFyZW50KCk7XG4gICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKCdvcGFjaXR5JywgMCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlIHx8IF8ub3B0aW9ucy5zd2lwZVRvU2xpZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAkKCdpbWdbZGF0YS1sYXp5XScsIF8uJHNsaWRlcikubm90KCdbc3JjXScpLmFkZENsYXNzKCdzbGljay1sb2FkaW5nJyk7XG5cbiAgICAgICAgXy5zZXR1cEluZmluaXRlKCk7XG5cbiAgICAgICAgXy5idWlsZEFycm93cygpO1xuXG4gICAgICAgIF8uYnVpbGREb3RzKCk7XG5cbiAgICAgICAgXy51cGRhdGVEb3RzKCk7XG5cblxuICAgICAgICBfLnNldFNsaWRlQ2xhc3Nlcyh0eXBlb2YgXy5jdXJyZW50U2xpZGUgPT09ICdudW1iZXInID8gXy5jdXJyZW50U2xpZGUgOiAwKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRyYWdnYWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy4kbGlzdC5hZGRDbGFzcygnZHJhZ2dhYmxlJyk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYnVpbGRSb3dzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLCBhLCBiLCBjLCBuZXdTbGlkZXMsIG51bU9mU2xpZGVzLCBvcmlnaW5hbFNsaWRlcyxzbGlkZXNQZXJTZWN0aW9uO1xuXG4gICAgICAgIG5ld1NsaWRlcyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgb3JpZ2luYWxTbGlkZXMgPSBfLiRzbGlkZXIuY2hpbGRyZW4oKTtcblxuICAgICAgICBpZihfLm9wdGlvbnMucm93cyA+IDApIHtcblxuICAgICAgICAgICAgc2xpZGVzUGVyU2VjdGlvbiA9IF8ub3B0aW9ucy5zbGlkZXNQZXJSb3cgKiBfLm9wdGlvbnMucm93cztcbiAgICAgICAgICAgIG51bU9mU2xpZGVzID0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsU2xpZGVzLmxlbmd0aCAvIHNsaWRlc1BlclNlY3Rpb25cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGZvcihhID0gMDsgYSA8IG51bU9mU2xpZGVzOyBhKyspe1xuICAgICAgICAgICAgICAgIHZhciBzbGlkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGZvcihiID0gMDsgYiA8IF8ub3B0aW9ucy5yb3dzOyBiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoYyA9IDA7IGMgPCBfLm9wdGlvbnMuc2xpZGVzUGVyUm93OyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAoYSAqIHNsaWRlc1BlclNlY3Rpb24gKyAoKGIgKiBfLm9wdGlvbnMuc2xpZGVzUGVyUm93KSArIGMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFNsaWRlcy5nZXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChvcmlnaW5hbFNsaWRlcy5nZXQodGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2xpZGUuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U2xpZGVzLmFwcGVuZENoaWxkKHNsaWRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy4kc2xpZGVyLmVtcHR5KCkuYXBwZW5kKG5ld1NsaWRlcyk7XG4gICAgICAgICAgICBfLiRzbGlkZXIuY2hpbGRyZW4oKS5jaGlsZHJlbigpLmNoaWxkcmVuKClcbiAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzooMTAwIC8gXy5vcHRpb25zLnNsaWRlc1BlclJvdykgKyAnJScsXG4gICAgICAgICAgICAgICAgICAgICdkaXNwbGF5JzogJ2lubGluZS1ibG9jaydcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNoZWNrUmVzcG9uc2l2ZSA9IGZ1bmN0aW9uKGluaXRpYWwsIGZvcmNlVXBkYXRlKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgYnJlYWtwb2ludCwgdGFyZ2V0QnJlYWtwb2ludCwgcmVzcG9uZFRvV2lkdGgsIHRyaWdnZXJCcmVha3BvaW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBzbGlkZXJXaWR0aCA9IF8uJHNsaWRlci53aWR0aCgpO1xuICAgICAgICB2YXIgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCAkKHdpbmRvdykud2lkdGgoKTtcblxuICAgICAgICBpZiAoXy5yZXNwb25kVG8gPT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgICByZXNwb25kVG9XaWR0aCA9IHdpbmRvd1dpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKF8ucmVzcG9uZFRvID09PSAnc2xpZGVyJykge1xuICAgICAgICAgICAgcmVzcG9uZFRvV2lkdGggPSBzbGlkZXJXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChfLnJlc3BvbmRUbyA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgIHJlc3BvbmRUb1dpZHRoID0gTWF0aC5taW4od2luZG93V2lkdGgsIHNsaWRlcldpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy5vcHRpb25zLnJlc3BvbnNpdmUgJiZcbiAgICAgICAgICAgIF8ub3B0aW9ucy5yZXNwb25zaXZlLmxlbmd0aCAmJlxuICAgICAgICAgICAgXy5vcHRpb25zLnJlc3BvbnNpdmUgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludCA9IG51bGw7XG5cbiAgICAgICAgICAgIGZvciAoYnJlYWtwb2ludCBpbiBfLmJyZWFrcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uYnJlYWtwb2ludHMuaGFzT3duUHJvcGVydHkoYnJlYWtwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8ub3JpZ2luYWxTZXR0aW5ncy5tb2JpbGVGaXJzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25kVG9XaWR0aCA8IF8uYnJlYWtwb2ludHNbYnJlYWtwb2ludF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCcmVha3BvaW50ID0gXy5icmVha3BvaW50c1ticmVha3BvaW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25kVG9XaWR0aCA+IF8uYnJlYWtwb2ludHNbYnJlYWtwb2ludF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCcmVha3BvaW50ID0gXy5icmVha3BvaW50c1ticmVha3BvaW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldEJyZWFrcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5hY3RpdmVCcmVha3BvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRCcmVha3BvaW50ICE9PSBfLmFjdGl2ZUJyZWFrcG9pbnQgfHwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uYWN0aXZlQnJlYWtwb2ludCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmJyZWFrcG9pbnRTZXR0aW5nc1t0YXJnZXRCcmVha3BvaW50XSA9PT0gJ3Vuc2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy51bnNsaWNrKHRhcmdldEJyZWFrcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgXy5vcmlnaW5hbFNldHRpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmJyZWFrcG9pbnRTZXR0aW5nc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IF8ub3B0aW9ucy5pbml0aWFsU2xpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8ucmVmcmVzaChpbml0aWFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJCcmVha3BvaW50ID0gdGFyZ2V0QnJlYWtwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF8uYWN0aXZlQnJlYWtwb2ludCA9IHRhcmdldEJyZWFrcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmJyZWFrcG9pbnRTZXR0aW5nc1t0YXJnZXRCcmVha3BvaW50XSA9PT0gJ3Vuc2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnVuc2xpY2sodGFyZ2V0QnJlYWtwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgXy5vcmlnaW5hbFNldHRpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uYnJlYWtwb2ludFNldHRpbmdzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCcmVha3BvaW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gXy5vcHRpb25zLmluaXRpYWxTbGlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF8ucmVmcmVzaChpbml0aWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQnJlYWtwb2ludCA9IHRhcmdldEJyZWFrcG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5hY3RpdmVCcmVha3BvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uYWN0aXZlQnJlYWtwb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucyA9IF8ub3JpZ2luYWxTZXR0aW5ncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gXy5vcHRpb25zLmluaXRpYWxTbGlkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfLnJlZnJlc2goaW5pdGlhbCk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJCcmVha3BvaW50ID0gdGFyZ2V0QnJlYWtwb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciBicmVha3BvaW50cyBkdXJpbmcgYW4gYWN0dWFsIGJyZWFrLiBub3Qgb24gaW5pdGlhbGl6ZS5cbiAgICAgICAgICAgIGlmKCAhaW5pdGlhbCAmJiB0cmlnZ2VyQnJlYWtwb2ludCAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2JyZWFrcG9pbnQnLCBbXywgdHJpZ2dlckJyZWFrcG9pbnRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jaGFuZ2VTbGlkZSA9IGZ1bmN0aW9uKGV2ZW50LCBkb250QW5pbWF0ZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLFxuICAgICAgICAgICAgaW5kZXhPZmZzZXQsIHNsaWRlT2Zmc2V0LCB1bmV2ZW5PZmZzZXQ7XG5cbiAgICAgICAgLy8gSWYgdGFyZ2V0IGlzIGEgbGluaywgcHJldmVudCBkZWZhdWx0IGFjdGlvbi5cbiAgICAgICAgaWYoJHRhcmdldC5pcygnYScpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGFyZ2V0IGlzIG5vdCB0aGUgPGxpPiBlbGVtZW50IChpZTogYSBjaGlsZCksIGZpbmQgdGhlIDxsaT4uXG4gICAgICAgIGlmKCEkdGFyZ2V0LmlzKCdsaScpKSB7XG4gICAgICAgICAgICAkdGFyZ2V0ID0gJHRhcmdldC5jbG9zZXN0KCdsaScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdW5ldmVuT2Zmc2V0ID0gKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAhPT0gMCk7XG4gICAgICAgIGluZGV4T2Zmc2V0ID0gdW5ldmVuT2Zmc2V0ID8gMCA6IChfLnNsaWRlQ291bnQgLSBfLmN1cnJlbnRTbGlkZSkgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5kYXRhLm1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgY2FzZSAncHJldmlvdXMnOlxuICAgICAgICAgICAgICAgIHNsaWRlT2Zmc2V0ID0gaW5kZXhPZmZzZXQgPT09IDAgPyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgOiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gaW5kZXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoXy5jdXJyZW50U2xpZGUgLSBzbGlkZU9mZnNldCwgZmFsc2UsIGRvbnRBbmltYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgICAgIHNsaWRlT2Zmc2V0ID0gaW5kZXhPZmZzZXQgPT09IDAgPyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgOiBpbmRleE9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgICAgICBfLnNsaWRlSGFuZGxlcihfLmN1cnJlbnRTbGlkZSArIHNsaWRlT2Zmc2V0LCBmYWxzZSwgZG9udEFuaW1hdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnaW5kZXgnOlxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50LmRhdGEuaW5kZXggPT09IDAgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleCB8fCAkdGFyZ2V0LmluZGV4KCkgKiBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG5cbiAgICAgICAgICAgICAgICBfLnNsaWRlSGFuZGxlcihfLmNoZWNrTmF2aWdhYmxlKGluZGV4KSwgZmFsc2UsIGRvbnRBbmltYXRlKTtcbiAgICAgICAgICAgICAgICAkdGFyZ2V0LmNoaWxkcmVuKCkudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2hlY2tOYXZpZ2FibGUgPSBmdW5jdGlvbihpbmRleCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIG5hdmlnYWJsZXMsIHByZXZOYXZpZ2FibGU7XG5cbiAgICAgICAgbmF2aWdhYmxlcyA9IF8uZ2V0TmF2aWdhYmxlSW5kZXhlcygpO1xuICAgICAgICBwcmV2TmF2aWdhYmxlID0gMDtcbiAgICAgICAgaWYgKGluZGV4ID4gbmF2aWdhYmxlc1tuYXZpZ2FibGVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBpbmRleCA9IG5hdmlnYWJsZXNbbmF2aWdhYmxlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIG4gaW4gbmF2aWdhYmxlcykge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IG5hdmlnYWJsZXNbbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwcmV2TmF2aWdhYmxlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldk5hdmlnYWJsZSA9IG5hdmlnYWJsZXNbbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jbGVhblVwRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZG90cyAmJiBfLiRkb3RzICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgICQoJ2xpJywgXy4kZG90cylcbiAgICAgICAgICAgICAgICAub2ZmKCdjbGljay5zbGljaycsIF8uY2hhbmdlU2xpZGUpXG4gICAgICAgICAgICAgICAgLm9mZignbW91c2VlbnRlci5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIHRydWUpKVxuICAgICAgICAgICAgICAgIC5vZmYoJ21vdXNlbGVhdmUuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCBmYWxzZSkpO1xuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLiRkb3RzLm9mZigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfLiRzbGlkZXIub2ZmKCdmb2N1cy5zbGljayBibHVyLnNsaWNrJyk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hcnJvd3MgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy4kcHJldkFycm93ICYmIF8uJHByZXZBcnJvdy5vZmYoJ2NsaWNrLnNsaWNrJywgXy5jaGFuZ2VTbGlkZSk7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3cgJiYgXy4kbmV4dEFycm93Lm9mZignY2xpY2suc2xpY2snLCBfLmNoYW5nZVNsaWRlKTtcblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93ICYmIF8uJHByZXZBcnJvdy5vZmYoJ2tleWRvd24uc2xpY2snLCBfLmtleUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdyAmJiBfLiRuZXh0QXJyb3cub2ZmKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF8uJGxpc3Qub2ZmKCd0b3VjaHN0YXJ0LnNsaWNrIG1vdXNlZG93bi5zbGljaycsIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vZmYoJ3RvdWNobW92ZS5zbGljayBtb3VzZW1vdmUuc2xpY2snLCBfLnN3aXBlSGFuZGxlcik7XG4gICAgICAgIF8uJGxpc3Qub2ZmKCd0b3VjaGVuZC5zbGljayBtb3VzZXVwLnNsaWNrJywgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9mZigndG91Y2hjYW5jZWwuc2xpY2sgbW91c2VsZWF2ZS5zbGljaycsIF8uc3dpcGVIYW5kbGVyKTtcblxuICAgICAgICBfLiRsaXN0Lm9mZignY2xpY2suc2xpY2snLCBfLmNsaWNrSGFuZGxlcik7XG5cbiAgICAgICAgJChkb2N1bWVudCkub2ZmKF8udmlzaWJpbGl0eUNoYW5nZSwgXy52aXNpYmlsaXR5KTtcblxuICAgICAgICBfLmNsZWFuVXBTbGlkZUV2ZW50cygpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy4kbGlzdC5vZmYoJ2tleWRvd24uc2xpY2snLCBfLmtleUhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mb2N1c09uU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAkKF8uJHNsaWRlVHJhY2spLmNoaWxkcmVuKCkub2ZmKCdjbGljay5zbGljaycsIF8uc2VsZWN0SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICAkKHdpbmRvdykub2ZmKCdvcmllbnRhdGlvbmNoYW5nZS5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgXy5vcmllbnRhdGlvbkNoYW5nZSk7XG5cbiAgICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplLnNsaWNrLnNsaWNrLScgKyBfLmluc3RhbmNlVWlkLCBfLnJlc2l6ZSk7XG5cbiAgICAgICAgJCgnW2RyYWdnYWJsZSE9dHJ1ZV0nLCBfLiRzbGlkZVRyYWNrKS5vZmYoJ2RyYWdzdGFydCcsIF8ucHJldmVudERlZmF1bHQpO1xuXG4gICAgICAgICQod2luZG93KS5vZmYoJ2xvYWQuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsIF8uc2V0UG9zaXRpb24pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jbGVhblVwU2xpZGVFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kbGlzdC5vZmYoJ21vdXNlZW50ZXIuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCB0cnVlKSk7XG4gICAgICAgIF8uJGxpc3Qub2ZmKCdtb3VzZWxlYXZlLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgZmFsc2UpKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2xlYW5VcFJvd3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsIG9yaWdpbmFsU2xpZGVzO1xuXG4gICAgICAgIGlmKF8ub3B0aW9ucy5yb3dzID4gMCkge1xuICAgICAgICAgICAgb3JpZ2luYWxTbGlkZXMgPSBfLiRzbGlkZXMuY2hpbGRyZW4oKS5jaGlsZHJlbigpO1xuICAgICAgICAgICAgb3JpZ2luYWxTbGlkZXMucmVtb3ZlQXR0cignc3R5bGUnKTtcbiAgICAgICAgICAgIF8uJHNsaWRlci5lbXB0eSgpLmFwcGVuZChvcmlnaW5hbFNsaWRlcyk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uc2hvdWxkQ2xpY2sgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24ocmVmcmVzaCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmF1dG9QbGF5Q2xlYXIoKTtcblxuICAgICAgICBfLnRvdWNoT2JqZWN0ID0ge307XG5cbiAgICAgICAgXy5jbGVhblVwRXZlbnRzKCk7XG5cbiAgICAgICAgJCgnLnNsaWNrLWNsb25lZCcsIF8uJHNsaWRlcikuZGV0YWNoKCk7XG5cbiAgICAgICAgaWYgKF8uJGRvdHMpIHtcbiAgICAgICAgICAgIF8uJGRvdHMucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8uJHByZXZBcnJvdyAmJiBfLiRwcmV2QXJyb3cubGVuZ3RoICkge1xuXG4gICAgICAgICAgICBfLiRwcmV2QXJyb3dcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkIHNsaWNrLWFycm93IHNsaWNrLWhpZGRlbicpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuIGFyaWEtZGlzYWJsZWQgdGFiaW5kZXgnKVxuICAgICAgICAgICAgICAgIC5jc3MoJ2Rpc3BsYXknLCcnKTtcblxuICAgICAgICAgICAgaWYgKCBfLmh0bWxFeHByLnRlc3QoIF8ub3B0aW9ucy5wcmV2QXJyb3cgKSkge1xuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy4kbmV4dEFycm93ICYmIF8uJG5leHRBcnJvdy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIF8uJG5leHRBcnJvd1xuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuJylcbiAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4gYXJpYS1kaXNhYmxlZCB0YWJpbmRleCcpXG4gICAgICAgICAgICAgICAgLmNzcygnZGlzcGxheScsJycpO1xuXG4gICAgICAgICAgICBpZiAoIF8uaHRtbEV4cHIudGVzdCggXy5vcHRpb25zLm5leHRBcnJvdyApKSB7XG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoXy4kc2xpZGVzKSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stc2xpZGUgc2xpY2stYWN0aXZlIHNsaWNrLWNlbnRlciBzbGljay12aXNpYmxlIHNsaWNrLWN1cnJlbnQnKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtc2xpY2staW5kZXgnKVxuICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYXR0cignc3R5bGUnLCAkKHRoaXMpLmRhdGEoJ29yaWdpbmFsU3R5bGluZycpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmRldGFjaCgpO1xuXG4gICAgICAgICAgICBfLiRsaXN0LmRldGFjaCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZXIuYXBwZW5kKF8uJHNsaWRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfLmNsZWFuVXBSb3dzKCk7XG5cbiAgICAgICAgXy4kc2xpZGVyLnJlbW92ZUNsYXNzKCdzbGljay1zbGlkZXInKTtcbiAgICAgICAgXy4kc2xpZGVyLnJlbW92ZUNsYXNzKCdzbGljay1pbml0aWFsaXplZCcpO1xuICAgICAgICBfLiRzbGlkZXIucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRvdHRlZCcpO1xuXG4gICAgICAgIF8udW5zbGlja2VkID0gdHJ1ZTtcblxuICAgICAgICBpZighcmVmcmVzaCkge1xuICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2Rlc3Ryb3knLCBbX10pO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmRpc2FibGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oc2xpZGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICB0cmFuc2l0aW9uID0ge307XG5cbiAgICAgICAgdHJhbnNpdGlvbltfLnRyYW5zaXRpb25UeXBlXSA9ICcnO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHRyYW5zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlKS5jc3ModHJhbnNpdGlvbik7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZmFkZVNsaWRlID0gZnVuY3Rpb24oc2xpZGVJbmRleCwgY2FsbGJhY2spIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uY3NzVHJhbnNpdGlvbnMgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZUluZGV4KS5jc3Moe1xuICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZUluZGV4KS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQsIF8ub3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfLmFwcGx5VHJhbnNpdGlvbihzbGlkZUluZGV4KTtcblxuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlSW5kZXgpLmNzcyh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZGlzYWJsZVRyYW5zaXRpb24oc2xpZGVJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCgpO1xuICAgICAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5mYWRlU2xpZGVPdXQgPSBmdW5jdGlvbihzbGlkZUluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLmNzc1RyYW5zaXRpb25zID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGVJbmRleCkuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXggLSAyXG4gICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQsIF8ub3B0aW9ucy5lYXNpbmcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF8uYXBwbHlUcmFuc2l0aW9uKHNsaWRlSW5kZXgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGVJbmRleCkuY3NzKHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleCAtIDJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZmlsdGVyU2xpZGVzID0gU2xpY2sucHJvdG90eXBlLnNsaWNrRmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChmaWx0ZXIgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVzQ2FjaGUgPSBfLiRzbGlkZXM7XG5cbiAgICAgICAgICAgIF8udW5sb2FkKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVzQ2FjaGUuZmlsdGVyKGZpbHRlcikuYXBwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG5cbiAgICAgICAgICAgIF8ucmVpbml0KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5mb2N1c0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kc2xpZGVyXG4gICAgICAgICAgICAub2ZmKCdmb2N1cy5zbGljayBibHVyLnNsaWNrJylcbiAgICAgICAgICAgIC5vbignZm9jdXMuc2xpY2sgYmx1ci5zbGljaycsICcqJywgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB2YXIgJHNmID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGlmKCBfLm9wdGlvbnMucGF1c2VPbkZvY3VzICkge1xuICAgICAgICAgICAgICAgICAgICBfLmZvY3Vzc2VkID0gJHNmLmlzKCc6Zm9jdXMnKTtcbiAgICAgICAgICAgICAgICAgICAgXy5hdXRvUGxheSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXRDdXJyZW50ID0gU2xpY2sucHJvdG90eXBlLnNsaWNrQ3VycmVudFNsaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuICAgICAgICByZXR1cm4gXy5jdXJyZW50U2xpZGU7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldERvdENvdW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIHZhciBicmVha1BvaW50ID0gMDtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgcGFnZXJRdHkgPSAwO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgICArK3BhZ2VyUXR5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYnJlYWtQb2ludCA8IF8uc2xpZGVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICArK3BhZ2VyUXR5O1xuICAgICAgICAgICAgICAgICAgICBicmVha1BvaW50ID0gY291bnRlciArIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlciArPSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwYWdlclF0eSA9IF8uc2xpZGVDb3VudDtcbiAgICAgICAgfSBlbHNlIGlmKCFfLm9wdGlvbnMuYXNOYXZGb3IpIHtcbiAgICAgICAgICAgIHBhZ2VyUXR5ID0gMSArIE1hdGguY2VpbCgoXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgLyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoYnJlYWtQb2ludCA8IF8uc2xpZGVDb3VudCkge1xuICAgICAgICAgICAgICAgICsrcGFnZXJRdHk7XG4gICAgICAgICAgICAgICAgYnJlYWtQb2ludCA9IGNvdW50ZXIgKyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgICAgICAgICAgY291bnRlciArPSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFnZXJRdHkgLSAxO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24oc2xpZGVJbmRleCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHRhcmdldExlZnQsXG4gICAgICAgICAgICB2ZXJ0aWNhbEhlaWdodCxcbiAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIHRhcmdldFNsaWRlLFxuICAgICAgICAgICAgY29lZjtcblxuICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gMDtcbiAgICAgICAgdmVydGljYWxIZWlnaHQgPSBfLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCh0cnVlKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAoXy5zbGlkZVdpZHRoICogXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgKiAtMTtcbiAgICAgICAgICAgICAgICBjb2VmID0gLTFcblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IHRydWUgJiYgXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWYgPSAtMS41O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWYgPSAtMlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gKHZlcnRpY2FsSGVpZ2h0ICogXy5vcHRpb25zLnNsaWRlc1RvU2hvdykgKiBjb2VmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzbGlkZUluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsID4gXy5zbGlkZUNvdW50ICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWRlSW5kZXggPiBfLnNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAoKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLSAoc2xpZGVJbmRleCAtIF8uc2xpZGVDb3VudCkpICogXy5zbGlkZVdpZHRoKSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWxPZmZzZXQgPSAoKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLSAoc2xpZGVJbmRleCAtIF8uc2xpZGVDb3VudCkpICogdmVydGljYWxIZWlnaHQpICogLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gKChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpICogXy5zbGlkZVdpZHRoKSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWxPZmZzZXQgPSAoKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkgKiB2ZXJ0aWNhbEhlaWdodCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzbGlkZUluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA+IF8uc2xpZGVDb3VudCkge1xuICAgICAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAoKHNsaWRlSW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSAtIF8uc2xpZGVDb3VudCkgKiBfLnNsaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgdmVydGljYWxPZmZzZXQgPSAoKHNsaWRlSW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSAtIF8uc2xpZGVDb3VudCkgKiB2ZXJ0aWNhbEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9IDA7XG4gICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAoKF8uc2xpZGVXaWR0aCAqIE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdykpIC8gMikgLSAoKF8uc2xpZGVXaWR0aCAqIF8uc2xpZGVDb3VudCkgLyAyKTtcbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgKz0gXy5zbGlkZVdpZHRoICogTWF0aC5mbG9vcihfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMikgLSBfLnNsaWRlV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgXy5zbGlkZU9mZnNldCArPSBfLnNsaWRlV2lkdGggKiBNYXRoLmZsb29yKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0YXJnZXRMZWZ0ID0gKChzbGlkZUluZGV4ICogXy5zbGlkZVdpZHRoKSAqIC0xKSArIF8uc2xpZGVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRMZWZ0ID0gKChzbGlkZUluZGV4ICogdmVydGljYWxIZWlnaHQpICogLTEpICsgdmVydGljYWxPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09IHRydWUpIHtcblxuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93IHx8IF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmVxKHNsaWRlSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmVxKHNsaWRlSW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5ydGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U2xpZGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IChfLiRzbGlkZVRyYWNrLndpZHRoKCkgLSB0YXJnZXRTbGlkZVswXS5vZmZzZXRMZWZ0IC0gdGFyZ2V0U2xpZGUud2lkdGgoKSkgKiAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gdGFyZ2V0U2xpZGVbMF0gPyB0YXJnZXRTbGlkZVswXS5vZmZzZXRMZWZ0ICogLTEgOiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgfHwgXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmVxKHNsaWRlSW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykuZXEoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U2xpZGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAoXy4kc2xpZGVUcmFjay53aWR0aCgpIC0gdGFyZ2V0U2xpZGVbMF0ub2Zmc2V0TGVmdCAtIHRhcmdldFNsaWRlLndpZHRoKCkpICogLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gdGFyZ2V0U2xpZGVbMF0gPyB0YXJnZXRTbGlkZVswXS5vZmZzZXRMZWZ0ICogLTEgOiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgKz0gKF8uJGxpc3Qud2lkdGgoKSAtIHRhcmdldFNsaWRlLm91dGVyV2lkdGgoKSkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldExlZnQ7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldE9wdGlvbiA9IFNsaWNrLnByb3RvdHlwZS5zbGlja0dldE9wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbikge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICByZXR1cm4gXy5vcHRpb25zW29wdGlvbl07XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldE5hdmlnYWJsZUluZGV4ZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBicmVha1BvaW50ID0gMCxcbiAgICAgICAgICAgIGNvdW50ZXIgPSAwLFxuICAgICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgICAgbWF4O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtYXggPSBfLnNsaWRlQ291bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1BvaW50ID0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICogLTE7XG4gICAgICAgICAgICBjb3VudGVyID0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICogLTE7XG4gICAgICAgICAgICBtYXggPSBfLnNsaWRlQ291bnQgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGJyZWFrUG9pbnQgPCBtYXgpIHtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaChicmVha1BvaW50KTtcbiAgICAgICAgICAgIGJyZWFrUG9pbnQgPSBjb3VudGVyICsgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICAgICAgY291bnRlciArPSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXhlcztcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0U2xpY2sgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0U2xpZGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHNsaWRlc1RyYXZlcnNlZCwgc3dpcGVkU2xpZGUsIGNlbnRlck9mZnNldDtcblxuICAgICAgICBjZW50ZXJPZmZzZXQgPSBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSA/IF8uc2xpZGVXaWR0aCAqIE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpIDogMDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnN3aXBlVG9TbGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5maW5kKCcuc2xpY2stc2xpZGUnKS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBzbGlkZSkge1xuICAgICAgICAgICAgICAgIGlmIChzbGlkZS5vZmZzZXRMZWZ0IC0gY2VudGVyT2Zmc2V0ICsgKCQoc2xpZGUpLm91dGVyV2lkdGgoKSAvIDIpID4gKF8uc3dpcGVMZWZ0ICogLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXBlZFNsaWRlID0gc2xpZGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2xpZGVzVHJhdmVyc2VkID0gTWF0aC5hYnMoJChzd2lwZWRTbGlkZSkuYXR0cignZGF0YS1zbGljay1pbmRleCcpIC0gXy5jdXJyZW50U2xpZGUpIHx8IDE7XG5cbiAgICAgICAgICAgIHJldHVybiBzbGlkZXNUcmF2ZXJzZWQ7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ29UbyA9IFNsaWNrLnByb3RvdHlwZS5zbGlja0dvVG8gPSBmdW5jdGlvbihzbGlkZSwgZG9udEFuaW1hdGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2luZGV4JyxcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyc2VJbnQoc2xpZGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGRvbnRBbmltYXRlKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGNyZWF0aW9uKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICghJChfLiRzbGlkZXIpLmhhc0NsYXNzKCdzbGljay1pbml0aWFsaXplZCcpKSB7XG5cbiAgICAgICAgICAgICQoXy4kc2xpZGVyKS5hZGRDbGFzcygnc2xpY2staW5pdGlhbGl6ZWQnKTtcblxuICAgICAgICAgICAgXy5idWlsZFJvd3MoKTtcbiAgICAgICAgICAgIF8uYnVpbGRPdXQoKTtcbiAgICAgICAgICAgIF8uc2V0UHJvcHMoKTtcbiAgICAgICAgICAgIF8uc3RhcnRMb2FkKCk7XG4gICAgICAgICAgICBfLmxvYWRTbGlkZXIoKTtcbiAgICAgICAgICAgIF8uaW5pdGlhbGl6ZUV2ZW50cygpO1xuICAgICAgICAgICAgXy51cGRhdGVBcnJvd3MoKTtcbiAgICAgICAgICAgIF8udXBkYXRlRG90cygpO1xuICAgICAgICAgICAgXy5jaGVja1Jlc3BvbnNpdmUodHJ1ZSk7XG4gICAgICAgICAgICBfLmZvY3VzSGFuZGxlcigpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3JlYXRpb24pIHtcbiAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdpbml0JywgW19dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5pbml0QURBKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5hdXRvcGxheSApIHtcblxuICAgICAgICAgICAgXy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIF8uYXV0b1BsYXkoKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXRBREEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgICAgIG51bURvdEdyb3VwcyA9IE1hdGguY2VpbChfLnNsaWRlQ291bnQgLyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxcbiAgICAgICAgICAgICAgICB0YWJDb250cm9sSW5kZXhlcyA9IF8uZ2V0TmF2aWdhYmxlSW5kZXhlcygpLmZpbHRlcihmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWwgPj0gMCkgJiYgKHZhbCA8IF8uc2xpZGVDb3VudCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgXy4kc2xpZGVzLmFkZChfLiRzbGlkZVRyYWNrLmZpbmQoJy5zbGljay1jbG9uZWQnKSkuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gICAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnXG4gICAgICAgIH0pLmZpbmQoJ2EsIGlucHV0LCBidXR0b24sIHNlbGVjdCcpLmF0dHIoe1xuICAgICAgICAgICAgJ3RhYmluZGV4JzogJy0xJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoXy4kZG90cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgXy4kc2xpZGVzLm5vdChfLiRzbGlkZVRyYWNrLmZpbmQoJy5zbGljay1jbG9uZWQnKSkuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNsaWRlQ29udHJvbEluZGV4ID0gdGFiQ29udHJvbEluZGV4ZXMuaW5kZXhPZihpKTtcblxuICAgICAgICAgICAgICAgICQodGhpcykuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3RhYnBhbmVsJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogJ3NsaWNrLXNsaWRlJyArIF8uaW5zdGFuY2VVaWQgKyBpLFxuICAgICAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAtMVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlQ29udHJvbEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgIHZhciBhcmlhQnV0dG9uQ29udHJvbCA9ICdzbGljay1zbGlkZS1jb250cm9sJyArIF8uaW5zdGFuY2VVaWQgKyBzbGlkZUNvbnRyb2xJbmRleFxuICAgICAgICAgICAgICAgICAgIGlmICgkKCcjJyArIGFyaWFCdXR0b25Db250cm9sKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBhcmlhQnV0dG9uQ29udHJvbFxuICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfLiRkb3RzLmF0dHIoJ3JvbGUnLCAndGFibGlzdCcpLmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcHBlZFNsaWRlSW5kZXggPSB0YWJDb250cm9sSW5kZXhlc1tpXTtcblxuICAgICAgICAgICAgICAgICQodGhpcykuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3ByZXNlbnRhdGlvbidcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICQodGhpcykuZmluZCgnYnV0dG9uJykuZmlyc3QoKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAndGFiJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogJ3NsaWNrLXNsaWRlLWNvbnRyb2wnICsgXy5pbnN0YW5jZVVpZCArIGksXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogJ3NsaWNrLXNsaWRlJyArIF8uaW5zdGFuY2VVaWQgKyBtYXBwZWRTbGlkZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IChpICsgMSkgKyAnIG9mICcgKyBudW1Eb3RHcm91cHMsXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogJy0xJ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KS5lcShfLmN1cnJlbnRTbGlkZSkuZmluZCgnYnV0dG9uJykuYXR0cih7XG4gICAgICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogJzAnXG4gICAgICAgICAgICB9KS5lbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGk9Xy5jdXJyZW50U2xpZGUsIG1heD1pK18ub3B0aW9ucy5zbGlkZXNUb1Nob3c7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgIGlmIChfLm9wdGlvbnMuZm9jdXNPbkNoYW5nZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKGkpLmF0dHIoeyd0YWJpbmRleCc6ICcwJ30pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoaSkucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfLmFjdGl2YXRlQURBKCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXRBcnJvd0V2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLiRwcmV2QXJyb3dcbiAgICAgICAgICAgICAgIC5vZmYoJ2NsaWNrLnNsaWNrJylcbiAgICAgICAgICAgICAgIC5vbignY2xpY2suc2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdwcmV2aW91cydcbiAgICAgICAgICAgICAgIH0sIF8uY2hhbmdlU2xpZGUpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93XG4gICAgICAgICAgICAgICAub2ZmKCdjbGljay5zbGljaycpXG4gICAgICAgICAgICAgICAub24oJ2NsaWNrLnNsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbmV4dCdcbiAgICAgICAgICAgICAgIH0sIF8uY2hhbmdlU2xpZGUpO1xuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cub24oJ2tleWRvd24uc2xpY2snLCBfLmtleUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIF8uJG5leHRBcnJvdy5vbigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdERvdEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRvdHMgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgJCgnbGknLCBfLiRkb3RzKS5vbignY2xpY2suc2xpY2snLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2luZGV4J1xuICAgICAgICAgICAgfSwgXy5jaGFuZ2VTbGlkZSk7XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uJGRvdHMub24oJ2tleWRvd24uc2xpY2snLCBfLmtleUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzID09PSB0cnVlICYmIF8ub3B0aW9ucy5wYXVzZU9uRG90c0hvdmVyID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgJCgnbGknLCBfLiRkb3RzKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VlbnRlci5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIHRydWUpKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VsZWF2ZS5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIGZhbHNlKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0U2xpZGVFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMucGF1c2VPbkhvdmVyICkge1xuXG4gICAgICAgICAgICBfLiRsaXN0Lm9uKCdtb3VzZWVudGVyLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgdHJ1ZSkpO1xuICAgICAgICAgICAgXy4kbGlzdC5vbignbW91c2VsZWF2ZS5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIGZhbHNlKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0aWFsaXplRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uaW5pdEFycm93RXZlbnRzKCk7XG5cbiAgICAgICAgXy5pbml0RG90RXZlbnRzKCk7XG4gICAgICAgIF8uaW5pdFNsaWRlRXZlbnRzKCk7XG5cbiAgICAgICAgXy4kbGlzdC5vbigndG91Y2hzdGFydC5zbGljayBtb3VzZWRvd24uc2xpY2snLCB7XG4gICAgICAgICAgICBhY3Rpb246ICdzdGFydCdcbiAgICAgICAgfSwgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9uKCd0b3VjaG1vdmUuc2xpY2sgbW91c2Vtb3ZlLnNsaWNrJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnbW92ZSdcbiAgICAgICAgfSwgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9uKCd0b3VjaGVuZC5zbGljayBtb3VzZXVwLnNsaWNrJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnZW5kJ1xuICAgICAgICB9LCBfLnN3aXBlSGFuZGxlcik7XG4gICAgICAgIF8uJGxpc3Qub24oJ3RvdWNoY2FuY2VsLnNsaWNrIG1vdXNlbGVhdmUuc2xpY2snLCB7XG4gICAgICAgICAgICBhY3Rpb246ICdlbmQnXG4gICAgICAgIH0sIF8uc3dpcGVIYW5kbGVyKTtcblxuICAgICAgICBfLiRsaXN0Lm9uKCdjbGljay5zbGljaycsIF8uY2xpY2tIYW5kbGVyKTtcblxuICAgICAgICAkKGRvY3VtZW50KS5vbihfLnZpc2liaWxpdHlDaGFuZ2UsICQucHJveHkoXy52aXNpYmlsaXR5LCBfKSk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRsaXN0Lm9uKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZm9jdXNPblNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgJChfLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9uKCdjbGljay5zbGljaycsIF8uc2VsZWN0SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICAkKHdpbmRvdykub24oJ29yaWVudGF0aW9uY2hhbmdlLnNsaWNrLnNsaWNrLScgKyBfLmluc3RhbmNlVWlkLCAkLnByb3h5KF8ub3JpZW50YXRpb25DaGFuZ2UsIF8pKTtcblxuICAgICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgJC5wcm94eShfLnJlc2l6ZSwgXykpO1xuXG4gICAgICAgICQoJ1tkcmFnZ2FibGUhPXRydWVdJywgXy4kc2xpZGVUcmFjaykub24oJ2RyYWdzdGFydCcsIF8ucHJldmVudERlZmF1bHQpO1xuXG4gICAgICAgICQod2luZG93KS5vbignbG9hZC5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgXy5zZXRQb3NpdGlvbik7XG4gICAgICAgICQoXy5zZXRQb3NpdGlvbik7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXRVSSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uJHByZXZBcnJvdy5zaG93KCk7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3cuc2hvdygpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRvdHMgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLiRkb3RzLnNob3coKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmtleUhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcbiAgICAgICAgIC8vRG9udCBzbGlkZSBpZiB0aGUgY3Vyc29yIGlzIGluc2lkZSB0aGUgZm9ybSBmaWVsZHMgYW5kIGFycm93IGtleXMgYXJlIHByZXNzZWRcbiAgICAgICAgaWYoIWV2ZW50LnRhcmdldC50YWdOYW1lLm1hdGNoKCdURVhUQVJFQXxJTlBVVHxTRUxFQ1QnKSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDM3ICYmIF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF8ub3B0aW9ucy5ydGwgPT09IHRydWUgPyAnbmV4dCcgOiAgJ3ByZXZpb3VzJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDM5ICYmIF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF8ub3B0aW9ucy5ydGwgPT09IHRydWUgPyAncHJldmlvdXMnIDogJ25leHQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5sYXp5TG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGxvYWRSYW5nZSwgY2xvbmVSYW5nZSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQ7XG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlcyhpbWFnZXNTY29wZSkge1xuXG4gICAgICAgICAgICAkKCdpbWdbZGF0YS1sYXp5XScsIGltYWdlc1Njb3BlKS5lYWNoKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTb3VyY2UgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtbGF6eScpLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVNyY1NldCA9ICQodGhpcykuYXR0cignZGF0YS1zcmNzZXQnKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTaXplcyAgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtc2l6ZXMnKSB8fCBfLiRzbGlkZXIuYXR0cignZGF0YS1zaXplcycpLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVRvTG9hZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gICAgICAgICAgICAgICAgaW1hZ2VUb0xvYWQub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hbmltYXRlKHsgb3BhY2l0eTogMCB9LCAxMDAsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlU3JjU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Jjc2V0JywgaW1hZ2VTcmNTZXQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VTaXplcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc2l6ZXMnLCBpbWFnZVNpemVzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3JjJywgaW1hZ2VTb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hbmltYXRlKHsgb3BhY2l0eTogMSB9LCAyMDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1sYXp5IGRhdGEtc3Jjc2V0IGRhdGEtc2l6ZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stbG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignbGF6eUxvYWRlZCcsIFtfLCBpbWFnZSwgaW1hZ2VTb3VyY2VdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGltYWdlVG9Mb2FkLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoICdkYXRhLWxhenknIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyggJ3NsaWNrLWxvYWRpbmcnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyggJ3NsaWNrLWxhenlsb2FkLWVycm9yJyApO1xuXG4gICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdsYXp5TG9hZEVycm9yJywgWyBfLCBpbWFnZSwgaW1hZ2VTb3VyY2UgXSk7XG5cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaW1hZ2VUb0xvYWQuc3JjID0gaW1hZ2VTb3VyY2U7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByYW5nZVN0YXJ0ID0gXy5jdXJyZW50U2xpZGUgKyAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIgKyAxKTtcbiAgICAgICAgICAgICAgICByYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VTdGFydCA9IE1hdGgubWF4KDAsIF8uY3VycmVudFNsaWRlIC0gKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyICsgMSkpO1xuICAgICAgICAgICAgICAgIHJhbmdlRW5kID0gMiArIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMiArIDEpICsgXy5jdXJyZW50U2xpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gXy5vcHRpb25zLmluZmluaXRlID8gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIF8uY3VycmVudFNsaWRlIDogXy5jdXJyZW50U2xpZGU7XG4gICAgICAgICAgICByYW5nZUVuZCA9IE1hdGguY2VpbChyYW5nZVN0YXJ0ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyk7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VTdGFydCA+IDApIHJhbmdlU3RhcnQtLTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VFbmQgPD0gXy5zbGlkZUNvdW50KSByYW5nZUVuZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9hZFJhbmdlID0gXy4kc2xpZGVyLmZpbmQoJy5zbGljay1zbGlkZScpLnNsaWNlKHJhbmdlU3RhcnQsIHJhbmdlRW5kKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmxhenlMb2FkID09PSAnYW50aWNpcGF0ZWQnKSB7XG4gICAgICAgICAgICB2YXIgcHJldlNsaWRlID0gcmFuZ2VTdGFydCAtIDEsXG4gICAgICAgICAgICAgICAgbmV4dFNsaWRlID0gcmFuZ2VFbmQsXG4gICAgICAgICAgICAgICAgJHNsaWRlcyA9IF8uJHNsaWRlci5maW5kKCcuc2xpY2stc2xpZGUnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2U2xpZGUgPCAwKSBwcmV2U2xpZGUgPSBfLnNsaWRlQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgIGxvYWRSYW5nZSA9IGxvYWRSYW5nZS5hZGQoJHNsaWRlcy5lcShwcmV2U2xpZGUpKTtcbiAgICAgICAgICAgICAgICBsb2FkUmFuZ2UgPSBsb2FkUmFuZ2UuYWRkKCRzbGlkZXMuZXEobmV4dFNsaWRlKSk7XG4gICAgICAgICAgICAgICAgcHJldlNsaWRlLS07XG4gICAgICAgICAgICAgICAgbmV4dFNsaWRlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkSW1hZ2VzKGxvYWRSYW5nZSk7XG5cbiAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBjbG9uZVJhbmdlID0gXy4kc2xpZGVyLmZpbmQoJy5zbGljay1zbGlkZScpO1xuICAgICAgICAgICAgbG9hZEltYWdlcyhjbG9uZVJhbmdlKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgIGlmIChfLmN1cnJlbnRTbGlkZSA+PSBfLnNsaWRlQ291bnQgLSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBjbG9uZVJhbmdlID0gXy4kc2xpZGVyLmZpbmQoJy5zbGljay1jbG9uZWQnKS5zbGljZSgwLCBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KTtcbiAgICAgICAgICAgIGxvYWRJbWFnZXMoY2xvbmVSYW5nZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5jdXJyZW50U2xpZGUgPT09IDApIHtcbiAgICAgICAgICAgIGNsb25lUmFuZ2UgPSBfLiRzbGlkZXIuZmluZCgnLnNsaWNrLWNsb25lZCcpLnNsaWNlKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKiAtMSk7XG4gICAgICAgICAgICBsb2FkSW1hZ2VzKGNsb25lUmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmxvYWRTbGlkZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5zZXRQb3NpdGlvbigpO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy4kc2xpZGVyLnJlbW92ZUNsYXNzKCdzbGljay1sb2FkaW5nJyk7XG5cbiAgICAgICAgXy5pbml0VUkoKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmxhenlMb2FkID09PSAncHJvZ3Jlc3NpdmUnKSB7XG4gICAgICAgICAgICBfLnByb2dyZXNzaXZlTGF6eUxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5uZXh0ID0gU2xpY2sucHJvdG90eXBlLnNsaWNrTmV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbmV4dCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLm9yaWVudGF0aW9uQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uY2hlY2tSZXNwb25zaXZlKCk7XG4gICAgICAgIF8uc2V0UG9zaXRpb24oKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucGF1c2UgPSBTbGljay5wcm90b3R5cGUuc2xpY2tQYXVzZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmF1dG9QbGF5Q2xlYXIoKTtcbiAgICAgICAgXy5wYXVzZWQgPSB0cnVlO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5wbGF5ID0gU2xpY2sucHJvdG90eXBlLnNsaWNrUGxheSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmF1dG9QbGF5KCk7XG4gICAgICAgIF8ub3B0aW9ucy5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIF8ucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIF8uZm9jdXNzZWQgPSBmYWxzZTtcbiAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5wb3N0U2xpZGUgPSBmdW5jdGlvbihpbmRleCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiggIV8udW5zbGlja2VkICkge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignYWZ0ZXJDaGFuZ2UnLCBbXywgaW5kZXhdKTtcblxuICAgICAgICAgICAgXy5hbmltYXRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICBfLnNldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uc3dpcGVMZWZ0ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCBfLm9wdGlvbnMuYXV0b3BsYXkgKSB7XG4gICAgICAgICAgICAgICAgXy5hdXRvUGxheSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLmluaXRBREEoKTtcblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuZm9jdXNPbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJGN1cnJlbnRTbGlkZSA9ICQoXy4kc2xpZGVzLmdldChfLmN1cnJlbnRTbGlkZSkpO1xuICAgICAgICAgICAgICAgICAgICAkY3VycmVudFNsaWRlLmF0dHIoJ3RhYmluZGV4JywgMCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5wcmV2ID0gU2xpY2sucHJvdG90eXBlLnNsaWNrUHJldiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAncHJldmlvdXMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucHJvZ3Jlc3NpdmVMYXp5TG9hZCA9IGZ1bmN0aW9uKCB0cnlDb3VudCApIHtcblxuICAgICAgICB0cnlDb3VudCA9IHRyeUNvdW50IHx8IDE7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgJGltZ3NUb0xvYWQgPSAkKCAnaW1nW2RhdGEtbGF6eV0nLCBfLiRzbGlkZXIgKSxcbiAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgaW1hZ2VTb3VyY2UsXG4gICAgICAgICAgICBpbWFnZVNyY1NldCxcbiAgICAgICAgICAgIGltYWdlU2l6ZXMsXG4gICAgICAgICAgICBpbWFnZVRvTG9hZDtcblxuICAgICAgICBpZiAoICRpbWdzVG9Mb2FkLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgaW1hZ2UgPSAkaW1nc1RvTG9hZC5maXJzdCgpO1xuICAgICAgICAgICAgaW1hZ2VTb3VyY2UgPSBpbWFnZS5hdHRyKCdkYXRhLWxhenknKTtcbiAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gaW1hZ2UuYXR0cignZGF0YS1zcmNzZXQnKTtcbiAgICAgICAgICAgIGltYWdlU2l6ZXMgID0gaW1hZ2UuYXR0cignZGF0YS1zaXplcycpIHx8IF8uJHNsaWRlci5hdHRyKCdkYXRhLXNpemVzJyk7XG4gICAgICAgICAgICBpbWFnZVRvTG9hZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gICAgICAgICAgICBpbWFnZVRvTG9hZC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbWFnZVNyY1NldCkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3NyY3NldCcsIGltYWdlU3JjU2V0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlU2l6ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3NpemVzJywgaW1hZ2VTaXplcyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoICdzcmMnLCBpbWFnZVNvdXJjZSApXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLWxhenkgZGF0YS1zcmNzZXQgZGF0YS1zaXplcycpXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stbG9hZGluZycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBfLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQgPT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uc2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignbGF6eUxvYWRlZCcsIFsgXywgaW1hZ2UsIGltYWdlU291cmNlIF0pO1xuICAgICAgICAgICAgICAgIF8ucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpbWFnZVRvTG9hZC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRyeUNvdW50IDwgMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogdHJ5IHRvIGxvYWQgdGhlIGltYWdlIDMgdGltZXMsXG4gICAgICAgICAgICAgICAgICAgICAqIGxlYXZlIGEgc2xpZ2h0IGRlbGF5IHNvIHdlIGRvbid0IGdldFxuICAgICAgICAgICAgICAgICAgICAgKiBzZXJ2ZXJzIGJsb2NraW5nIHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnByb2dyZXNzaXZlTGF6eUxvYWQoIHRyeUNvdW50ICsgMSApO1xuICAgICAgICAgICAgICAgICAgICB9LCA1MDAgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCAnZGF0YS1sYXp5JyApXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoICdzbGljay1sb2FkaW5nJyApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoICdzbGljay1sYXp5bG9hZC1lcnJvcicgKTtcblxuICAgICAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignbGF6eUxvYWRFcnJvcicsIFsgXywgaW1hZ2UsIGltYWdlU291cmNlIF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIF8ucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpbWFnZVRvTG9hZC5zcmMgPSBpbWFnZVNvdXJjZTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignYWxsSW1hZ2VzTG9hZGVkJywgWyBfIF0pO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCBpbml0aWFsaXppbmcgKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLCBjdXJyZW50U2xpZGUsIGxhc3RWaXNpYmxlSW5kZXg7XG5cbiAgICAgICAgbGFzdFZpc2libGVJbmRleCA9IF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG5cbiAgICAgICAgLy8gaW4gbm9uLWluZmluaXRlIHNsaWRlcnMsIHdlIGRvbid0IHdhbnQgdG8gZ28gcGFzdCB0aGVcbiAgICAgICAgLy8gbGFzdCB2aXNpYmxlIGluZGV4LlxuICAgICAgICBpZiggIV8ub3B0aW9ucy5pbmZpbml0ZSAmJiAoIF8uY3VycmVudFNsaWRlID4gbGFzdFZpc2libGVJbmRleCApKSB7XG4gICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IGxhc3RWaXNpYmxlSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsZXNzIHNsaWRlcyB0aGFuIHRvIHNob3csIGdvIHRvIHN0YXJ0LlxuICAgICAgICBpZiAoIF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICkge1xuICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSAwO1xuXG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50U2xpZGUgPSBfLmN1cnJlbnRTbGlkZTtcblxuICAgICAgICBfLmRlc3Ryb3kodHJ1ZSk7XG5cbiAgICAgICAgJC5leHRlbmQoXywgXy5pbml0aWFscywgeyBjdXJyZW50U2xpZGU6IGN1cnJlbnRTbGlkZSB9KTtcblxuICAgICAgICBfLmluaXQoKTtcblxuICAgICAgICBpZiggIWluaXRpYWxpemluZyApIHtcblxuICAgICAgICAgICAgXy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogY3VycmVudFNsaWRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucmVnaXN0ZXJCcmVha3BvaW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcywgYnJlYWtwb2ludCwgY3VycmVudEJyZWFrcG9pbnQsIGwsXG4gICAgICAgICAgICByZXNwb25zaXZlU2V0dGluZ3MgPSBfLm9wdGlvbnMucmVzcG9uc2l2ZSB8fCBudWxsO1xuXG4gICAgICAgIGlmICggJC50eXBlKHJlc3BvbnNpdmVTZXR0aW5ncykgPT09ICdhcnJheScgJiYgcmVzcG9uc2l2ZVNldHRpbmdzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgXy5yZXNwb25kVG8gPSBfLm9wdGlvbnMucmVzcG9uZFRvIHx8ICd3aW5kb3cnO1xuXG4gICAgICAgICAgICBmb3IgKCBicmVha3BvaW50IGluIHJlc3BvbnNpdmVTZXR0aW5ncyApIHtcblxuICAgICAgICAgICAgICAgIGwgPSBfLmJyZWFrcG9pbnRzLmxlbmd0aC0xO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNpdmVTZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShicmVha3BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QnJlYWtwb2ludCA9IHJlc3BvbnNpdmVTZXR0aW5nc1ticmVha3BvaW50XS5icmVha3BvaW50O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgYnJlYWtwb2ludHMgYW5kIGN1dCBvdXQgYW55IGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uZXMgd2l0aCB0aGUgc2FtZSBicmVha3BvaW50IG51bWJlciwgd2UgZG9uJ3Qgd2FudCBkdXBlcy5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoIGwgPj0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfLmJyZWFrcG9pbnRzW2xdICYmIF8uYnJlYWtwb2ludHNbbF0gPT09IGN1cnJlbnRCcmVha3BvaW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uYnJlYWtwb2ludHMuc3BsaWNlKGwsMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsLS07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfLmJyZWFrcG9pbnRzLnB1c2goY3VycmVudEJyZWFrcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBfLmJyZWFrcG9pbnRTZXR0aW5nc1tjdXJyZW50QnJlYWtwb2ludF0gPSByZXNwb25zaXZlU2V0dGluZ3NbYnJlYWtwb2ludF0uc2V0dGluZ3M7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5icmVha3BvaW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCBfLm9wdGlvbnMubW9iaWxlRmlyc3QgKSA/IGEtYiA6IGItYTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucmVpbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uJHNsaWRlcyA9XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrXG4gICAgICAgICAgICAgICAgLmNoaWxkcmVuKF8ub3B0aW9ucy5zbGlkZSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLXNsaWRlJyk7XG5cbiAgICAgICAgXy5zbGlkZUNvdW50ID0gXy4kc2xpZGVzLmxlbmd0aDtcblxuICAgICAgICBpZiAoXy5jdXJyZW50U2xpZGUgPj0gXy5zbGlkZUNvdW50ICYmIF8uY3VycmVudFNsaWRlICE9PSAwKSB7XG4gICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IF8uY3VycmVudFNsaWRlIC0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBfLnJlZ2lzdGVyQnJlYWtwb2ludHMoKTtcblxuICAgICAgICBfLnNldFByb3BzKCk7XG4gICAgICAgIF8uc2V0dXBJbmZpbml0ZSgpO1xuICAgICAgICBfLmJ1aWxkQXJyb3dzKCk7XG4gICAgICAgIF8udXBkYXRlQXJyb3dzKCk7XG4gICAgICAgIF8uaW5pdEFycm93RXZlbnRzKCk7XG4gICAgICAgIF8uYnVpbGREb3RzKCk7XG4gICAgICAgIF8udXBkYXRlRG90cygpO1xuICAgICAgICBfLmluaXREb3RFdmVudHMoKTtcbiAgICAgICAgXy5jbGVhblVwU2xpZGVFdmVudHMoKTtcbiAgICAgICAgXy5pbml0U2xpZGVFdmVudHMoKTtcblxuICAgICAgICBfLmNoZWNrUmVzcG9uc2l2ZShmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mb2N1c09uU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAkKF8uJHNsaWRlVHJhY2spLmNoaWxkcmVuKCkub24oJ2NsaWNrLnNsaWNrJywgXy5zZWxlY3RIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uc2V0U2xpZGVDbGFzc2VzKHR5cGVvZiBfLmN1cnJlbnRTbGlkZSA9PT0gJ251bWJlcicgPyBfLmN1cnJlbnRTbGlkZSA6IDApO1xuXG4gICAgICAgIF8uc2V0UG9zaXRpb24oKTtcbiAgICAgICAgXy5mb2N1c0hhbmRsZXIoKTtcblxuICAgICAgICBfLnBhdXNlZCA9ICFfLm9wdGlvbnMuYXV0b3BsYXk7XG4gICAgICAgIF8uYXV0b1BsYXkoKTtcblxuICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcigncmVJbml0JywgW19dKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICgkKHdpbmRvdykud2lkdGgoKSAhPT0gXy53aW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF8ud2luZG93RGVsYXkpO1xuICAgICAgICAgICAgXy53aW5kb3dEZWxheSA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF8ud2luZG93V2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcbiAgICAgICAgICAgICAgICBfLmNoZWNrUmVzcG9uc2l2ZSgpO1xuICAgICAgICAgICAgICAgIGlmKCAhXy51bnNsaWNrZWQgKSB7IF8uc2V0UG9zaXRpb24oKTsgfVxuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5yZW1vdmVTbGlkZSA9IFNsaWNrLnByb3RvdHlwZS5zbGlja1JlbW92ZSA9IGZ1bmN0aW9uKGluZGV4LCByZW1vdmVCZWZvcmUsIHJlbW92ZUFsbCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAodHlwZW9mKGluZGV4KSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZW1vdmVCZWZvcmUgPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gcmVtb3ZlQmVmb3JlID09PSB0cnVlID8gMCA6IF8uc2xpZGVDb3VudCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IHJlbW92ZUJlZm9yZSA9PT0gdHJ1ZSA/IC0taW5kZXggOiBpbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLnNsaWRlQ291bnQgPCAxIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+IF8uc2xpZGVDb3VudCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8udW5sb2FkKCk7XG5cbiAgICAgICAgaWYgKHJlbW92ZUFsbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbigpLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmVxKGluZGV4KS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlcyA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5hcHBlbmQoXy4kc2xpZGVzKTtcblxuICAgICAgICBfLiRzbGlkZXNDYWNoZSA9IF8uJHNsaWRlcztcblxuICAgICAgICBfLnJlaW5pdCgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRDU1MgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMgPSB7fSxcbiAgICAgICAgICAgIHgsIHk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5ydGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gLXBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHggPSBfLnBvc2l0aW9uUHJvcCA9PSAnbGVmdCcgPyBNYXRoLmNlaWwocG9zaXRpb24pICsgJ3B4JyA6ICcwcHgnO1xuICAgICAgICB5ID0gXy5wb3NpdGlvblByb3AgPT0gJ3RvcCcgPyBNYXRoLmNlaWwocG9zaXRpb24pICsgJ3B4JyA6ICcwcHgnO1xuXG4gICAgICAgIHBvc2l0aW9uUHJvcHNbXy5wb3NpdGlvblByb3BdID0gcG9zaXRpb247XG5cbiAgICAgICAgaWYgKF8udHJhbnNmb3Jtc0VuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhwb3NpdGlvblByb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uUHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGlmIChfLmNzc1RyYW5zaXRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHNbXy5hbmltVHlwZV0gPSAndHJhbnNsYXRlKCcgKyB4ICsgJywgJyArIHkgKyAnKSc7XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MocG9zaXRpb25Qcm9wcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uUHJvcHNbXy5hbmltVHlwZV0gPSAndHJhbnNsYXRlM2QoJyArIHggKyAnLCAnICsgeSArICcsIDBweCknO1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHBvc2l0aW9uUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldERpbWVuc2lvbnMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uJGxpc3QuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogKCcwcHggJyArIF8ub3B0aW9ucy5jZW50ZXJQYWRkaW5nKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy4kbGlzdC5oZWlnaHQoXy4kc2xpZGVzLmZpcnN0KCkub3V0ZXJIZWlnaHQodHJ1ZSkgKiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KTtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uJGxpc3QuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogKF8ub3B0aW9ucy5jZW50ZXJQYWRkaW5nICsgJyAwcHgnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXy5saXN0V2lkdGggPSBfLiRsaXN0LndpZHRoKCk7XG4gICAgICAgIF8ubGlzdEhlaWdodCA9IF8uJGxpc3QuaGVpZ2h0KCk7XG5cblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSAmJiBfLm9wdGlvbnMudmFyaWFibGVXaWR0aCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uc2xpZGVXaWR0aCA9IE1hdGguY2VpbChfLmxpc3RXaWR0aCAvIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpO1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay53aWR0aChNYXRoLmNlaWwoKF8uc2xpZGVXaWR0aCAqIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmxlbmd0aCkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKF8ub3B0aW9ucy52YXJpYWJsZVdpZHRoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLndpZHRoKDUwMDAgKiBfLnNsaWRlQ291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy5zbGlkZVdpZHRoID0gTWF0aC5jZWlsKF8ubGlzdFdpZHRoKTtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suaGVpZ2h0KE1hdGguY2VpbCgoXy4kc2xpZGVzLmZpcnN0KCkub3V0ZXJIZWlnaHQodHJ1ZSkgKiBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS5sZW5ndGgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gXy4kc2xpZGVzLmZpcnN0KCkub3V0ZXJXaWR0aCh0cnVlKSAtIF8uJHNsaWRlcy5maXJzdCgpLndpZHRoKCk7XG4gICAgICAgIGlmIChfLm9wdGlvbnMudmFyaWFibGVXaWR0aCA9PT0gZmFsc2UpIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLndpZHRoKF8uc2xpZGVXaWR0aCAtIG9mZnNldCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldEZhZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXRMZWZ0O1xuXG4gICAgICAgIF8uJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgICB0YXJnZXRMZWZ0ID0gKF8uc2xpZGVXaWR0aCAqIGluZGV4KSAqIC0xO1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5ydGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdGFyZ2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXggLSAyLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQoZWxlbWVudCkuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRhcmdldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4IC0gMixcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfLiRzbGlkZXMuZXEoXy5jdXJyZW50U2xpZGUpLmNzcyh7XG4gICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXggLSAxLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID09PSAxICYmIF8ub3B0aW9ucy5hZGFwdGl2ZUhlaWdodCA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gXy4kc2xpZGVzLmVxKF8uY3VycmVudFNsaWRlKS5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAgICAgICAgIF8uJGxpc3QuY3NzKCdoZWlnaHQnLCB0YXJnZXRIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldE9wdGlvbiA9XG4gICAgU2xpY2sucHJvdG90eXBlLnNsaWNrU2V0T3B0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFjY2VwdHMgYXJndW1lbnRzIGluIGZvcm1hdCBvZjpcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gZm9yIGNoYW5naW5nIGEgc2luZ2xlIG9wdGlvbidzIHZhbHVlOlxuICAgICAgICAgKiAgICAgLnNsaWNrKFwic2V0T3B0aW9uXCIsIG9wdGlvbiwgdmFsdWUsIHJlZnJlc2ggKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBmb3IgY2hhbmdpbmcgYSBzZXQgb2YgcmVzcG9uc2l2ZSBvcHRpb25zOlxuICAgICAgICAgKiAgICAgLnNsaWNrKFwic2V0T3B0aW9uXCIsICdyZXNwb25zaXZlJywgW3t9LCAuLi5dLCByZWZyZXNoIClcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gZm9yIHVwZGF0aW5nIG11bHRpcGxlIHZhbHVlcyBhdCBvbmNlIChub3QgcmVzcG9uc2l2ZSlcbiAgICAgICAgICogICAgIC5zbGljayhcInNldE9wdGlvblwiLCB7ICdvcHRpb24nOiB2YWx1ZSwgLi4uIH0sIHJlZnJlc2ggKVxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgXyA9IHRoaXMsIGwsIGl0ZW0sIG9wdGlvbiwgdmFsdWUsIHJlZnJlc2ggPSBmYWxzZSwgdHlwZTtcblxuICAgICAgICBpZiggJC50eXBlKCBhcmd1bWVudHNbMF0gKSA9PT0gJ29iamVjdCcgKSB7XG5cbiAgICAgICAgICAgIG9wdGlvbiA9ICBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZWZyZXNoID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdHlwZSA9ICdtdWx0aXBsZSc7XG5cbiAgICAgICAgfSBlbHNlIGlmICggJC50eXBlKCBhcmd1bWVudHNbMF0gKSA9PT0gJ3N0cmluZycgKSB7XG5cbiAgICAgICAgICAgIG9wdGlvbiA9ICBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHJlZnJlc2ggPSBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgICAgIGlmICggYXJndW1lbnRzWzBdID09PSAncmVzcG9uc2l2ZScgJiYgJC50eXBlKCBhcmd1bWVudHNbMV0gKSA9PT0gJ2FycmF5JyApIHtcblxuICAgICAgICAgICAgICAgIHR5cGUgPSAncmVzcG9uc2l2ZSc7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBhcmd1bWVudHNbMV0gIT09ICd1bmRlZmluZWQnICkge1xuXG4gICAgICAgICAgICAgICAgdHlwZSA9ICdzaW5nbGUnO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdHlwZSA9PT0gJ3NpbmdsZScgKSB7XG5cbiAgICAgICAgICAgIF8ub3B0aW9uc1tvcHRpb25dID0gdmFsdWU7XG5cblxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09PSAnbXVsdGlwbGUnICkge1xuXG4gICAgICAgICAgICAkLmVhY2goIG9wdGlvbiAsIGZ1bmN0aW9uKCBvcHQsIHZhbCApIHtcblxuICAgICAgICAgICAgICAgIF8ub3B0aW9uc1tvcHRdID0gdmFsO1xuXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09ICdyZXNwb25zaXZlJyApIHtcblxuICAgICAgICAgICAgZm9yICggaXRlbSBpbiB2YWx1ZSApIHtcblxuICAgICAgICAgICAgICAgIGlmKCAkLnR5cGUoIF8ub3B0aW9ucy5yZXNwb25zaXZlICkgIT09ICdhcnJheScgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zLnJlc3BvbnNpdmUgPSBbIHZhbHVlW2l0ZW1dIF07XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGwgPSBfLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGgtMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIHJlc3BvbnNpdmUgb2JqZWN0IGFuZCBzcGxpY2Ugb3V0IGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKCBsID49IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfLm9wdGlvbnMucmVzcG9uc2l2ZVtsXS5icmVha3BvaW50ID09PSB2YWx1ZVtpdGVtXS5icmVha3BvaW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zLnJlc3BvbnNpdmUuc3BsaWNlKGwsMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbC0tO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMucmVzcG9uc2l2ZS5wdXNoKCB2YWx1ZVtpdGVtXSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcmVmcmVzaCApIHtcblxuICAgICAgICAgICAgXy51bmxvYWQoKTtcbiAgICAgICAgICAgIF8ucmVpbml0KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLnNldERpbWVuc2lvbnMoKTtcblxuICAgICAgICBfLnNldEhlaWdodCgpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uc2V0Q1NTKF8uZ2V0TGVmdChfLmN1cnJlbnRTbGlkZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy5zZXRGYWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignc2V0UG9zaXRpb24nLCBbX10pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRQcm9wcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbiAgICAgICAgXy5wb3NpdGlvblByb3AgPSBfLm9wdGlvbnMudmVydGljYWwgPT09IHRydWUgPyAndG9wJyA6ICdsZWZ0JztcblxuICAgICAgICBpZiAoXy5wb3NpdGlvblByb3AgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICBfLiRzbGlkZXIuYWRkQ2xhc3MoJ3NsaWNrLXZlcnRpY2FsJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLiRzbGlkZXIucmVtb3ZlQ2xhc3MoJ3NsaWNrLXZlcnRpY2FsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9keVN0eWxlLldlYmtpdFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgYm9keVN0eWxlLk1velRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgYm9keVN0eWxlLm1zVHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLnVzZUNTUyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uY3NzVHJhbnNpdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMuZmFkZSApIHtcbiAgICAgICAgICAgIGlmICggdHlwZW9mIF8ub3B0aW9ucy56SW5kZXggPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgICAgIGlmKCBfLm9wdGlvbnMuekluZGV4IDwgMyApIHtcbiAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zLnpJbmRleCA9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfLm9wdGlvbnMuekluZGV4ID0gXy5kZWZhdWx0cy56SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9keVN0eWxlLk9UcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9ICdPVHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNmb3JtVHlwZSA9ICctby10cmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2l0aW9uVHlwZSA9ICdPVHJhbnNpdGlvbic7XG4gICAgICAgICAgICBpZiAoYm9keVN0eWxlLnBlcnNwZWN0aXZlUHJvcGVydHkgPT09IHVuZGVmaW5lZCAmJiBib2R5U3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPT09IHVuZGVmaW5lZCkgXy5hbmltVHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5U3R5bGUuTW96VHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF8uYW5pbVR5cGUgPSAnTW96VHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNmb3JtVHlwZSA9ICctbW96LXRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gJ01velRyYW5zaXRpb24nO1xuICAgICAgICAgICAgaWYgKGJvZHlTdHlsZS5wZXJzcGVjdGl2ZVByb3BlcnR5ID09PSB1bmRlZmluZWQgJiYgYm9keVN0eWxlLk1velBlcnNwZWN0aXZlID09PSB1bmRlZmluZWQpIF8uYW5pbVR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keVN0eWxlLndlYmtpdFRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gJ3dlYmtpdFRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zZm9ybVR5cGUgPSAnLXdlYmtpdC10cmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2l0aW9uVHlwZSA9ICd3ZWJraXRUcmFuc2l0aW9uJztcbiAgICAgICAgICAgIGlmIChib2R5U3R5bGUucGVyc3BlY3RpdmVQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICYmIGJvZHlTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9PT0gdW5kZWZpbmVkKSBfLmFuaW1UeXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlTdHlsZS5tc1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gJ21zVHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNmb3JtVHlwZSA9ICctbXMtdHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSAnbXNUcmFuc2l0aW9uJztcbiAgICAgICAgICAgIGlmIChib2R5U3R5bGUubXNUcmFuc2Zvcm0gPT09IHVuZGVmaW5lZCkgXy5hbmltVHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5U3R5bGUudHJhbnNmb3JtICE9PSB1bmRlZmluZWQgJiYgXy5hbmltVHlwZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uYW5pbVR5cGUgPSAndHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNmb3JtVHlwZSA9ICd0cmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2l0aW9uVHlwZSA9ICd0cmFuc2l0aW9uJztcbiAgICAgICAgfVxuICAgICAgICBfLnRyYW5zZm9ybXNFbmFibGVkID0gXy5vcHRpb25zLnVzZVRyYW5zZm9ybSAmJiAoXy5hbmltVHlwZSAhPT0gbnVsbCAmJiBfLmFuaW1UeXBlICE9PSBmYWxzZSk7XG4gICAgfTtcblxuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldFNsaWRlQ2xhc3NlcyA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgY2VudGVyT2Zmc2V0LCBhbGxTbGlkZXMsIGluZGV4T2Zmc2V0LCByZW1haW5kZXI7XG5cbiAgICAgICAgYWxsU2xpZGVzID0gXy4kc2xpZGVyXG4gICAgICAgICAgICAuZmluZCgnLnNsaWNrLXNsaWRlJylcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stYWN0aXZlIHNsaWNrLWNlbnRlciBzbGljay1jdXJyZW50JylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgICAgXy4kc2xpZGVzXG4gICAgICAgICAgICAuZXEoaW5kZXgpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWN1cnJlbnQnKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcblxuICAgICAgICAgICAgdmFyIGV2ZW5Db2VmID0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAlIDIgPT09IDAgPyAxIDogMDtcblxuICAgICAgICAgICAgY2VudGVyT2Zmc2V0ID0gTWF0aC5mbG9vcihfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMik7XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBjZW50ZXJPZmZzZXQgJiYgaW5kZXggPD0gKF8uc2xpZGVDb3VudCAtIDEpIC0gY2VudGVyT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4IC0gY2VudGVyT2Zmc2V0ICsgZXZlbkNvZWYsIGluZGV4ICsgY2VudGVyT2Zmc2V0ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpbmRleE9mZnNldCA9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaW5kZXhPZmZzZXQgLSBjZW50ZXJPZmZzZXQgKyAxICsgZXZlbkNvZWYsIGluZGV4T2Zmc2V0ICsgY2VudGVyT2Zmc2V0ICsgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXEoYWxsU2xpZGVzLmxlbmd0aCAtIDEgLSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1jZW50ZXInKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IF8uc2xpZGVDb3VudCAtIDEpIHtcblxuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcShfLm9wdGlvbnMuc2xpZGVzVG9TaG93KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1jZW50ZXInKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgICAgICAuZXEoaW5kZXgpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1jZW50ZXInKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8PSAoXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykpIHtcblxuICAgICAgICAgICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaW5kZXgsIGluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGxTbGlkZXMubGVuZ3RoIDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmVtYWluZGVyID0gXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcbiAgICAgICAgICAgICAgICBpbmRleE9mZnNldCA9IF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSA/IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyBpbmRleCA6IGluZGV4O1xuXG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPT0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICYmIChfLnNsaWRlQ291bnQgLSBpbmRleCkgPCBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaW5kZXhPZmZzZXQgLSAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIHJlbWFpbmRlciksIGluZGV4T2Zmc2V0ICsgcmVtYWluZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4T2Zmc2V0LCBpbmRleE9mZnNldCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmxhenlMb2FkID09PSAnb25kZW1hbmQnIHx8IF8ub3B0aW9ucy5sYXp5TG9hZCA9PT0gJ2FudGljaXBhdGVkJykge1xuICAgICAgICAgICAgXy5sYXp5TG9hZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXR1cEluZmluaXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgaSwgc2xpZGVJbmRleCwgaW5maW5pdGVDb3VudDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8ub3B0aW9ucy5jZW50ZXJNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlICYmIF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICBzbGlkZUluZGV4ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZpbml0ZUNvdW50ID0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5maW5pdGVDb3VudCA9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gXy5zbGlkZUNvdW50OyBpID4gKF8uc2xpZGVDb3VudCAtXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZpbml0ZUNvdW50KTsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSW5kZXggPSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgJChfLiRzbGlkZXNbc2xpZGVJbmRleF0pLmNsb25lKHRydWUpLmF0dHIoJ2lkJywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZGF0YS1zbGljay1pbmRleCcsIHNsaWRlSW5kZXggLSBfLnNsaWRlQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAucHJlcGVuZFRvKF8uJHNsaWRlVHJhY2spLmFkZENsYXNzKCdzbGljay1jbG9uZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZmluaXRlQ291bnQgICsgXy5zbGlkZUNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICQoXy4kc2xpZGVzW3NsaWRlSW5kZXhdKS5jbG9uZSh0cnVlKS5hdHRyKCdpZCcsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnLCBzbGlkZUluZGV4ICsgXy5zbGlkZUNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKF8uJHNsaWRlVHJhY2spLmFkZENsYXNzKCdzbGljay1jbG9uZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5maW5kKCcuc2xpY2stY2xvbmVkJykuZmluZCgnW2lkXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYXR0cignaWQnLCAnJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmludGVycnVwdCA9IGZ1bmN0aW9uKCB0b2dnbGUgKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmKCAhdG9nZ2xlICkge1xuICAgICAgICAgICAgXy5hdXRvUGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIF8uaW50ZXJydXB0ZWQgPSB0b2dnbGU7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNlbGVjdEhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9XG4gICAgICAgICAgICAkKGV2ZW50LnRhcmdldCkuaXMoJy5zbGljay1zbGlkZScpID9cbiAgICAgICAgICAgICAgICAkKGV2ZW50LnRhcmdldCkgOlxuICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCcuc2xpY2stc2xpZGUnKTtcblxuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludCh0YXJnZXRFbGVtZW50LmF0dHIoJ2RhdGEtc2xpY2staW5kZXgnKSk7XG5cbiAgICAgICAgaWYgKCFpbmRleCkgaW5kZXggPSAwO1xuXG4gICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLnNsaWRlSGFuZGxlcihpbmRleCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfLnNsaWRlSGFuZGxlcihpbmRleCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNsaWRlSGFuZGxlciA9IGZ1bmN0aW9uKGluZGV4LCBzeW5jLCBkb250QW5pbWF0ZSkge1xuXG4gICAgICAgIHZhciB0YXJnZXRTbGlkZSwgYW5pbVNsaWRlLCBvbGRTbGlkZSwgc2xpZGVMZWZ0LCB0YXJnZXRMZWZ0ID0gbnVsbCxcbiAgICAgICAgICAgIF8gPSB0aGlzLCBuYXZUYXJnZXQ7XG5cbiAgICAgICAgc3luYyA9IHN5bmMgfHwgZmFsc2U7XG5cbiAgICAgICAgaWYgKF8uYW5pbWF0aW5nID09PSB0cnVlICYmIF8ub3B0aW9ucy53YWl0Rm9yQW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlICYmIF8uY3VycmVudFNsaWRlID09PSBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLmFzTmF2Rm9yKGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFNsaWRlID0gaW5kZXg7XG4gICAgICAgIHRhcmdldExlZnQgPSBfLmdldExlZnQodGFyZ2V0U2xpZGUpO1xuICAgICAgICBzbGlkZUxlZnQgPSBfLmdldExlZnQoXy5jdXJyZW50U2xpZGUpO1xuXG4gICAgICAgIF8uY3VycmVudExlZnQgPSBfLnN3aXBlTGVmdCA9PT0gbnVsbCA/IHNsaWRlTGVmdCA6IF8uc3dpcGVMZWZ0O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlICYmIF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSBmYWxzZSAmJiAoaW5kZXggPCAwIHx8IGluZGV4ID4gXy5nZXREb3RDb3VudCgpICogXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy5jdXJyZW50U2xpZGU7XG4gICAgICAgICAgICAgICAgaWYgKGRvbnRBbmltYXRlICE9PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5hbmltYXRlU2xpZGUoc2xpZGVMZWZ0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKHRhcmdldFNsaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUodGFyZ2V0U2xpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlICYmIF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlICYmIChpbmRleCA8IDAgfHwgaW5kZXggPiAoXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSkpIHtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTbGlkZSA9IF8uY3VycmVudFNsaWRlO1xuICAgICAgICAgICAgICAgIGlmIChkb250QW5pbWF0ZSAhPT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIF8uYW5pbWF0ZVNsaWRlKHNsaWRlTGVmdCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZSh0YXJnZXRTbGlkZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKHRhcmdldFNsaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5hdXRvcGxheSApIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoXy5hdXRvUGxheVRpbWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRTbGlkZSA8IDApIHtcbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgIT09IDApIHtcbiAgICAgICAgICAgICAgICBhbmltU2xpZGUgPSBfLnNsaWRlQ291bnQgLSAoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbVNsaWRlID0gXy5zbGlkZUNvdW50ICsgdGFyZ2V0U2xpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0U2xpZGUgPj0gXy5zbGlkZUNvdW50KSB7XG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgYW5pbVNsaWRlID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbVNsaWRlID0gdGFyZ2V0U2xpZGUgLSBfLnNsaWRlQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmltU2xpZGUgPSB0YXJnZXRTbGlkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uYW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignYmVmb3JlQ2hhbmdlJywgW18sIF8uY3VycmVudFNsaWRlLCBhbmltU2xpZGVdKTtcblxuICAgICAgICBvbGRTbGlkZSA9IF8uY3VycmVudFNsaWRlO1xuICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IGFuaW1TbGlkZTtcblxuICAgICAgICBfLnNldFNsaWRlQ2xhc3NlcyhfLmN1cnJlbnRTbGlkZSk7XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMuYXNOYXZGb3IgKSB7XG5cbiAgICAgICAgICAgIG5hdlRhcmdldCA9IF8uZ2V0TmF2VGFyZ2V0KCk7XG4gICAgICAgICAgICBuYXZUYXJnZXQgPSBuYXZUYXJnZXQuc2xpY2soJ2dldFNsaWNrJyk7XG5cbiAgICAgICAgICAgIGlmICggbmF2VGFyZ2V0LnNsaWRlQ291bnQgPD0gbmF2VGFyZ2V0Lm9wdGlvbnMuc2xpZGVzVG9TaG93ICkge1xuICAgICAgICAgICAgICAgIG5hdlRhcmdldC5zZXRTbGlkZUNsYXNzZXMoXy5jdXJyZW50U2xpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBfLnVwZGF0ZURvdHMoKTtcbiAgICAgICAgXy51cGRhdGVBcnJvd3MoKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChkb250QW5pbWF0ZSAhPT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgXy5mYWRlU2xpZGVPdXQob2xkU2xpZGUpO1xuXG4gICAgICAgICAgICAgICAgXy5mYWRlU2xpZGUoYW5pbVNsaWRlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUoYW5pbVNsaWRlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZShhbmltU2xpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5hbmltYXRlSGVpZ2h0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9udEFuaW1hdGUgIT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy5hbmltYXRlU2xpZGUodGFyZ2V0TGVmdCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUoYW5pbVNsaWRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy5wb3N0U2xpZGUoYW5pbVNsaWRlKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zdGFydExvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hcnJvd3MgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cuaGlkZSgpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93LmhpZGUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgXy4kZG90cy5oaWRlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlci5hZGRDbGFzcygnc2xpY2stbG9hZGluZycpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zd2lwZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB4RGlzdCwgeURpc3QsIHIsIHN3aXBlQW5nbGUsIF8gPSB0aGlzO1xuXG4gICAgICAgIHhEaXN0ID0gXy50b3VjaE9iamVjdC5zdGFydFggLSBfLnRvdWNoT2JqZWN0LmN1clg7XG4gICAgICAgIHlEaXN0ID0gXy50b3VjaE9iamVjdC5zdGFydFkgLSBfLnRvdWNoT2JqZWN0LmN1clk7XG4gICAgICAgIHIgPSBNYXRoLmF0YW4yKHlEaXN0LCB4RGlzdCk7XG5cbiAgICAgICAgc3dpcGVBbmdsZSA9IE1hdGgucm91bmQociAqIDE4MCAvIE1hdGguUEkpO1xuICAgICAgICBpZiAoc3dpcGVBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIHN3aXBlQW5nbGUgPSAzNjAgLSBNYXRoLmFicyhzd2lwZUFuZ2xlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoc3dpcGVBbmdsZSA8PSA0NSkgJiYgKHN3aXBlQW5nbGUgPj0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoXy5vcHRpb25zLnJ0bCA9PT0gZmFsc2UgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN3aXBlQW5nbGUgPD0gMzYwKSAmJiAoc3dpcGVBbmdsZSA+PSAzMTUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKF8ub3B0aW9ucy5ydGwgPT09IGZhbHNlID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzd2lwZUFuZ2xlID49IDEzNSkgJiYgKHN3aXBlQW5nbGUgPD0gMjI1KSkge1xuICAgICAgICAgICAgcmV0dXJuIChfLm9wdGlvbnMucnRsID09PSBmYWxzZSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoKHN3aXBlQW5nbGUgPj0gMzUpICYmIChzd2lwZUFuZ2xlIDw9IDEzNSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3VwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAndmVydGljYWwnO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zd2lwZUVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgc2xpZGVDb3VudCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjtcblxuICAgICAgICBfLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIF8uc3dpcGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfLnNjcm9sbGluZykge1xuICAgICAgICAgICAgXy5zY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgXy5zaG91bGRDbGljayA9ICggXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA+IDEwICkgPyBmYWxzZSA6IHRydWU7XG5cbiAgICAgICAgaWYgKCBfLnRvdWNoT2JqZWN0LmN1clggPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy50b3VjaE9iamVjdC5lZGdlSGl0ID09PSB0cnVlICkge1xuICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2VkZ2UnLCBbXywgXy5zd2lwZURpcmVjdGlvbigpIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID49IF8udG91Y2hPYmplY3QubWluU3dpcGUgKSB7XG5cbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IF8uc3dpcGVEaXJlY3Rpb24oKTtcblxuICAgICAgICAgICAgc3dpdGNoICggZGlyZWN0aW9uICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG93bic6XG5cbiAgICAgICAgICAgICAgICAgICAgc2xpZGVDb3VudCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMuc3dpcGVUb1NsaWRlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmNoZWNrTmF2aWdhYmxlKCBfLmN1cnJlbnRTbGlkZSArIF8uZ2V0U2xpZGVDb3VudCgpICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY3VycmVudFNsaWRlICsgXy5nZXRTbGlkZUNvdW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50RGlyZWN0aW9uID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBjYXNlICd1cCc6XG5cbiAgICAgICAgICAgICAgICAgICAgc2xpZGVDb3VudCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMuc3dpcGVUb1NsaWRlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmNoZWNrTmF2aWdhYmxlKCBfLmN1cnJlbnRTbGlkZSAtIF8uZ2V0U2xpZGVDb3VudCgpICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY3VycmVudFNsaWRlIC0gXy5nZXRTbGlkZUNvdW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50RGlyZWN0aW9uID0gMTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggZGlyZWN0aW9uICE9ICd2ZXJ0aWNhbCcgKSB7XG5cbiAgICAgICAgICAgICAgICBfLnNsaWRlSGFuZGxlciggc2xpZGVDb3VudCApO1xuICAgICAgICAgICAgICAgIF8udG91Y2hPYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignc3dpcGUnLCBbXywgZGlyZWN0aW9uIF0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKCBfLnRvdWNoT2JqZWN0LnN0YXJ0WCAhPT0gXy50b3VjaE9iamVjdC5jdXJYICkge1xuXG4gICAgICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoIF8uY3VycmVudFNsaWRlICk7XG4gICAgICAgICAgICAgICAgXy50b3VjaE9iamVjdCA9IHt9O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zd2lwZUhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoKF8ub3B0aW9ucy5zd2lwZSA9PT0gZmFsc2UpIHx8ICgnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQgJiYgXy5vcHRpb25zLnN3aXBlID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuZHJhZ2dhYmxlID09PSBmYWxzZSAmJiBldmVudC50eXBlLmluZGV4T2YoJ21vdXNlJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfLnRvdWNoT2JqZWN0LmZpbmdlckNvdW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoIDogMTtcblxuICAgICAgICBfLnRvdWNoT2JqZWN0Lm1pblN3aXBlID0gXy5saXN0V2lkdGggLyBfLm9wdGlvbnNcbiAgICAgICAgICAgIC50b3VjaFRocmVzaG9sZDtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy50b3VjaE9iamVjdC5taW5Td2lwZSA9IF8ubGlzdEhlaWdodCAvIF8ub3B0aW9uc1xuICAgICAgICAgICAgICAgIC50b3VjaFRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGF0YS5hY3Rpb24pIHtcblxuICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgIF8uc3dpcGVTdGFydChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICAgIF8uc3dpcGVNb3ZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICBfLnN3aXBlRW5kKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgZWRnZVdhc0hpdCA9IGZhbHNlLFxuICAgICAgICAgICAgY3VyTGVmdCwgc3dpcGVEaXJlY3Rpb24sIHN3aXBlTGVuZ3RoLCBwb3NpdGlvbk9mZnNldCwgdG91Y2hlcywgdmVydGljYWxTd2lwZUxlbmd0aDtcblxuICAgICAgICB0b3VjaGVzID0gZXZlbnQub3JpZ2luYWxFdmVudCAhPT0gdW5kZWZpbmVkID8gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzIDogbnVsbDtcblxuICAgICAgICBpZiAoIV8uZHJhZ2dpbmcgfHwgXy5zY3JvbGxpbmcgfHwgdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyTGVmdCA9IF8uZ2V0TGVmdChfLmN1cnJlbnRTbGlkZSk7XG5cbiAgICAgICAgXy50b3VjaE9iamVjdC5jdXJYID0gdG91Y2hlcyAhPT0gdW5kZWZpbmVkID8gdG91Y2hlc1swXS5wYWdlWCA6IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIF8udG91Y2hPYmplY3QuY3VyWSA9IHRvdWNoZXMgIT09IHVuZGVmaW5lZCA/IHRvdWNoZXNbMF0ucGFnZVkgOiBldmVudC5jbGllbnRZO1xuXG4gICAgICAgIF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPSBNYXRoLnJvdW5kKE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KF8udG91Y2hPYmplY3QuY3VyWCAtIF8udG91Y2hPYmplY3Quc3RhcnRYLCAyKSkpO1xuXG4gICAgICAgIHZlcnRpY2FsU3dpcGVMZW5ndGggPSBNYXRoLnJvdW5kKE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KF8udG91Y2hPYmplY3QuY3VyWSAtIF8udG91Y2hPYmplY3Quc3RhcnRZLCAyKSkpO1xuXG4gICAgICAgIGlmICghXy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyAmJiAhXy5zd2lwaW5nICYmIHZlcnRpY2FsU3dpcGVMZW5ndGggPiA0KSB7XG4gICAgICAgICAgICBfLnNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA9IHZlcnRpY2FsU3dpcGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZURpcmVjdGlvbiA9IF8uc3dpcGVEaXJlY3Rpb24oKTtcblxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudCAhPT0gdW5kZWZpbmVkICYmIF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPiA0KSB7XG4gICAgICAgICAgICBfLnN3aXBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uT2Zmc2V0ID0gKF8ub3B0aW9ucy5ydGwgPT09IGZhbHNlID8gMSA6IC0xKSAqIChfLnRvdWNoT2JqZWN0LmN1clggPiBfLnRvdWNoT2JqZWN0LnN0YXJ0WCA/IDEgOiAtMSk7XG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk9mZnNldCA9IF8udG91Y2hPYmplY3QuY3VyWSA+IF8udG91Y2hPYmplY3Quc3RhcnRZID8gMSA6IC0xO1xuICAgICAgICB9XG5cblxuICAgICAgICBzd2lwZUxlbmd0aCA9IF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGg7XG5cbiAgICAgICAgXy50b3VjaE9iamVjdC5lZGdlSGl0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICgoXy5jdXJyZW50U2xpZGUgPT09IDAgJiYgc3dpcGVEaXJlY3Rpb24gPT09ICdyaWdodCcpIHx8IChfLmN1cnJlbnRTbGlkZSA+PSBfLmdldERvdENvdW50KCkgJiYgc3dpcGVEaXJlY3Rpb24gPT09ICdsZWZ0JykpIHtcbiAgICAgICAgICAgICAgICBzd2lwZUxlbmd0aCA9IF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggKiBfLm9wdGlvbnMuZWRnZUZyaWN0aW9uO1xuICAgICAgICAgICAgICAgIF8udG91Y2hPYmplY3QuZWRnZUhpdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy5zd2lwZUxlZnQgPSBjdXJMZWZ0ICsgc3dpcGVMZW5ndGggKiBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uc3dpcGVMZWZ0ID0gY3VyTGVmdCArIChzd2lwZUxlbmd0aCAqIChfLiRsaXN0LmhlaWdodCgpIC8gXy5saXN0V2lkdGgpKSAqIHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnN3aXBlTGVmdCA9IGN1ckxlZnQgKyBzd2lwZUxlbmd0aCAqIHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSB0cnVlIHx8IF8ub3B0aW9ucy50b3VjaE1vdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5hbmltYXRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uc3dpcGVMZWZ0ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uc2V0Q1NTKF8uc3dpcGVMZWZ0KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc3dpcGVTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgdG91Y2hlcztcblxuICAgICAgICBfLmludGVycnVwdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoXy50b3VjaE9iamVjdC5maW5nZXJDb3VudCAhPT0gMSB8fCBfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy50b3VjaE9iamVjdCA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG91Y2hlcyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8udG91Y2hPYmplY3Quc3RhcnRYID0gXy50b3VjaE9iamVjdC5jdXJYID0gdG91Y2hlcyAhPT0gdW5kZWZpbmVkID8gdG91Y2hlcy5wYWdlWCA6IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIF8udG91Y2hPYmplY3Quc3RhcnRZID0gXy50b3VjaE9iamVjdC5jdXJZID0gdG91Y2hlcyAhPT0gdW5kZWZpbmVkID8gdG91Y2hlcy5wYWdlWSA6IGV2ZW50LmNsaWVudFk7XG5cbiAgICAgICAgXy5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnVuZmlsdGVyU2xpZGVzID0gU2xpY2sucHJvdG90eXBlLnNsaWNrVW5maWx0ZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uJHNsaWRlc0NhY2hlICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIF8udW5sb2FkKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVzQ2FjaGUuYXBwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG5cbiAgICAgICAgICAgIF8ucmVpbml0KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51bmxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgJCgnLnNsaWNrLWNsb25lZCcsIF8uJHNsaWRlcikucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKF8uJGRvdHMpIHtcbiAgICAgICAgICAgIF8uJGRvdHMucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy4kcHJldkFycm93ICYmIF8uaHRtbEV4cHIudGVzdChfLm9wdGlvbnMucHJldkFycm93KSkge1xuICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uJG5leHRBcnJvdyAmJiBfLmh0bWxFeHByLnRlc3QoXy5vcHRpb25zLm5leHRBcnJvdykpIHtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdy5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1zbGlkZSBzbGljay1hY3RpdmUgc2xpY2stdmlzaWJsZSBzbGljay1jdXJyZW50JylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJylcbiAgICAgICAgICAgIC5jc3MoJ3dpZHRoJywgJycpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51bnNsaWNrID0gZnVuY3Rpb24oZnJvbUJyZWFrcG9pbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG4gICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCd1bnNsaWNrJywgW18sIGZyb21CcmVha3BvaW50XSk7XG4gICAgICAgIF8uZGVzdHJveSgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS51cGRhdGVBcnJvd3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBjZW50ZXJPZmZzZXQ7XG5cbiAgICAgICAgY2VudGVyT2Zmc2V0ID0gTWF0aC5mbG9vcihfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMik7XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMuYXJyb3dzID09PSB0cnVlICYmXG4gICAgICAgICAgICBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmXG4gICAgICAgICAgICAhXy5vcHRpb25zLmluZmluaXRlICkge1xuXG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93LnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgaWYgKF8uY3VycmVudFNsaWRlID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cuYWRkQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmN1cnJlbnRTbGlkZSA+PSBfLnNsaWRlQ291bnQgLSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LmFkZENsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5jdXJyZW50U2xpZGUgPj0gXy5zbGlkZUNvdW50IC0gMSAmJiBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LmFkZENsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnVwZGF0ZURvdHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uJGRvdHMgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgXy4kZG90c1xuICAgICAgICAgICAgICAgIC5maW5kKCdsaScpXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgLmVuZCgpO1xuXG4gICAgICAgICAgICBfLiRkb3RzXG4gICAgICAgICAgICAgICAgLmZpbmQoJ2xpJylcbiAgICAgICAgICAgICAgICAuZXEoTWF0aC5mbG9vcihfLmN1cnJlbnRTbGlkZSAvIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnZpc2liaWxpdHkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMuYXV0b3BsYXkgKSB7XG5cbiAgICAgICAgICAgIGlmICggZG9jdW1lbnRbXy5oaWRkZW5dICkge1xuXG4gICAgICAgICAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBfLmludGVycnVwdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgJC5mbi5zbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBvcHQgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIGwgPSBfLmxlbmd0aCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICByZXQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0ID09ICdvYmplY3QnIHx8IHR5cGVvZiBvcHQgPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgX1tpXS5zbGljayA9IG5ldyBTbGljayhfW2ldLCBvcHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldCA9IF9baV0uc2xpY2tbb3B0XS5hcHBseShfW2ldLnNsaWNrLCBhcmdzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0ICE9ICd1bmRlZmluZWQnKSByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfO1xuICAgIH07XG5cbn0pKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4gKiBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbiAqIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4gKiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbiAqIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuICogT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuICogVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlLycpO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vKlxuICogZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbiAqIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxuICovXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAvKlxuICAgKiBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgKiBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgKi9cbiAgZGVsaW1zID0gW1xuICAgICc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J1xuICBdLFxuXG4gIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gIHVud2lzZSA9IFtcbiAgICAneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXG4gIF0uY29uY2F0KGRlbGltcyksXG5cbiAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgLypcbiAgICogQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICogTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgKiBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICogdGhlbS5cbiAgICovXG4gIG5vbkhvc3RDaGFycyA9IFtcbiAgICAnJScsICcvJywgJz8nLCAnOycsICcjJ1xuICBdLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgaG9zdEVuZGluZ0NoYXJzID0gW1xuICAgICcvJywgJz8nLCAnIydcbiAgXSxcbiAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgamF2YXNjcmlwdDogdHJ1ZSxcbiAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gIH0sXG4gIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICBqYXZhc2NyaXB0OiB0cnVlLFxuICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgfSxcbiAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICBodHRwOiB0cnVlLFxuICAgIGh0dHBzOiB0cnVlLFxuICAgIGZ0cDogdHJ1ZSxcbiAgICBnb3BoZXI6IHRydWUsXG4gICAgZmlsZTogdHJ1ZSxcbiAgICAnaHR0cDonOiB0cnVlLFxuICAgICdodHRwczonOiB0cnVlLFxuICAgICdmdHA6JzogdHJ1ZSxcbiAgICAnZ29waGVyOic6IHRydWUsXG4gICAgJ2ZpbGU6JzogdHJ1ZVxuICB9LFxuICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3FzJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0JyAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHsgcmV0dXJuIHVybDsgfVxuXG4gIHZhciB1ID0gbmV3IFVybCgpO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvKlxuICAgKiBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgICogQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gICAqIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gICAqL1xuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgc3BsaXR0ZXIgPSBxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSA/ICc/JyA6ICcjJyxcbiAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLypcbiAgICogdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICogVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICAgKi9cbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8qXG4gICAqIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gICAqIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgICogcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAgKiBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgICovXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AL10rQFteQC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvKlxuICAgICAqIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAgKiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgICAqIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgICogY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAgKiBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgICpcbiAgICAgKiBleDpcbiAgICAgKiBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgICAqIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcbiAgICAgKi9cblxuICAgIC8qXG4gICAgICogdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgICAqIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG4gICAgICovXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7IGhvc3RFbmQgPSBoZWM7IH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgICAqIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgICAqL1xuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKlxuICAgICAgICogYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgICogaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgICAqL1xuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgICogUHVsbCB0aGF0IG9mZi5cbiAgICAgKi9cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkgeyBob3N0RW5kID0gaGVjOyB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHsgaG9zdEVuZCA9IHJlc3QubGVuZ3RoOyB9XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLypcbiAgICAgKiB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgICAqIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgICovXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvKlxuICAgICAqIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgICogYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgICovXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJiB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICogd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAqIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgICogYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvKlxuICAgICAgICogSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAgKiBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAgKiBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAgKiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgICovXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLypcbiAgICAgKiBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgICogdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICAgKi9cbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gICAqIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgICovXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8qXG4gICAgICogRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgICAqIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgICAqIG5lZWQgdG8gYmUuXG4gICAgICovXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSkgeyBjb250aW51ZTsgfVxuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHsgdGhpcy5wYXRobmFtZSA9IHJlc3Q7IH1cbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJiB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8qXG4gICAqIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gICAqIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gICAqIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgICogdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgICovXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgeyBvYmogPSB1cmxQYXJzZShvYmopOyB9XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHsgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTsgfVxuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgaG9zdCA9IGZhbHNlLFxuICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgPyB0aGlzLmhvc3RuYW1lIDogJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiYgdHlwZW9mIHRoaXMucXVlcnkgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnksIHtcbiAgICAgIGFycmF5Rm9ybWF0OiAncmVwZWF0JyxcbiAgICAgIGFkZFF1ZXJ5UHJlZml4OiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSB7IHByb3RvY29sICs9ICc6JzsgfVxuXG4gIC8qXG4gICAqIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAgKiB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICAgKi9cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fCAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7IHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7IH1cbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHsgaGFzaCA9ICcjJyArIGhhc2g7IH1cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHsgc2VhcmNoID0gJz8nICsgc2VhcmNoOyB9XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSB7IHJldHVybiByZWxhdGl2ZTsgfVxuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xuICBpZiAodHlwZW9mIHJlbGF0aXZlID09PSAnc3RyaW5nJykge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvKlxuICAgKiBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgICogZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gICAqL1xuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJykgeyByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTsgfVxuICAgIH1cblxuICAgIC8vIHVybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJiByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWU7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLypcbiAgICAgKiBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgICogdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgICogZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgICogYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAgKiB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgICogaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAgKiBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAgKiBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgICovXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpIHsgfVxuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSB7IHJlbGF0aXZlLmhvc3QgPSAnJzsgfVxuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgeyByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnOyB9XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHsgcmVsUGF0aC51bnNoaWZ0KCcnKTsgfVxuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgeyByZWxQYXRoLnVuc2hpZnQoJycpOyB9XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsXG4gICAgaXNSZWxBYnMgPSByZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgIG11c3RFbmRBYnMgPSBpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fCAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpLFxuICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvKlxuICAgKiBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gICAqIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgICogdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAgKiByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAgKiBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgICovXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHsgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0OyB9IGVsc2UgeyBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpOyB9XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgeyByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDsgfSBlbHNlIHsgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpOyB9XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnID8gcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJyA/IHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvKlxuICAgICAqIGl0J3MgcmVsYXRpdmVcbiAgICAgKiB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICAgKi9cbiAgICBpZiAoIXNyY1BhdGgpIHsgc3JjUGF0aCA9IFtdOyB9XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmIChyZWxhdGl2ZS5zZWFyY2ggIT0gbnVsbCkge1xuICAgIC8qXG4gICAgICoganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgICAqIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgICogUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgICovXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdDtcbiAgICAgIC8qXG4gICAgICAgKiBvY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgICogdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgICogdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICAgKi9cbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/IHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSAhPT0gbnVsbCB8fCByZXN1bHQuc2VhcmNoICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgKyAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLypcbiAgICAgKiBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgICogd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICAgKi9cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLypcbiAgICogaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gICAqIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAgKiB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgKi9cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJyc7XG5cbiAgLypcbiAgICogc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAgKiBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICAgKi9cbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8IChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSBpc0Fic29sdXRlID8gJycgOiBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lO1xuICAgIC8qXG4gICAgICogb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgKiB0aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICogdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICovXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID8gcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKHNyY1BhdGgubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9XG5cbiAgLy8gdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKHJlc3VsdC5wYXRobmFtZSAhPT0gbnVsbCB8fCByZXN1bHQuc2VhcmNoICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICsgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHsgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7IH1cbn07XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuIiwiY29uc3QgcmFuZG9tVVVJRCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEICYmIGNyeXB0by5yYW5kb21VVUlELmJpbmQoY3J5cHRvKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRFxufTsiLCJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG5sZXQgZ2V0UmFuZG9tVmFsdWVzO1xuY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHJldHVybiBieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiLCJpbXBvcnQgbmF0aXZlIGZyb20gJy4vbmF0aXZlLmpzJztcbmltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiLCJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiLCIvKiFcbiAqIFZhbGlkZXR0YSAoaHR0cHM6Ly9naXRodWIuY29tL1BpeGVsVW5pb24vdmFsaWRldHRhKVxuICogVmVyc2lvbiAyLjAuM1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vaHNuYXlkL3ZhbGlkZXR0YS9ibG9iL21hc3Rlci9MSUNFTkNFKVxuICogQ29weXJpZ2h0IDIwMTMtMjAxNyBIYXNhbiBBeWRvxJ9kdSAtIGh0dHA6Ly93d3cuaGFzYW5heWRvZ2R1LmNvbSBcbiAqL1xuLyplc2xpbnQtZW52IGVzNjpmYWxzZSovXG5cbihmdW5jdGlvbigkKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqICBEZWNsYXJlIHZhcmlhYmxlc1xuICAgKi9cbiAgdmFyIEZJRUxEUyA9IHt9OyAvLyBDdXJyZW50IGZpZWxkcy9maWVsZHNcbiAgLy8gUmVnRXhwIGZvciBpbnB1dCB2YWxpZGF0aW9uIHJ1bGVzXG4gIHZhciBSUlVMRSA9IG5ldyBSZWdFeHAoL14obWluQ2hlY2tlZHxtYXhDaGVja2VkfG1pblNlbGVjdGVkfG1heFNlbGVjdGVkfG1pbkxlbmd0aHxtYXhMZW5ndGh8ZXF1YWxUb3xkaWZmZXJlbnR8cmVnRXhwfHJlbW90ZXxjYWxsYmFjaylcXFsoXFx3ezEsMTV9KVxcXS9pKTtcbiAgLy8gUmVnRXhwIGZvciBtYWlsIGNvbnRyb2wgbWV0aG9kXG4gIC8vIEBmcm9tIChodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9zdGF0ZXMtb2YtdGhlLXR5cGUtYXR0cmlidXRlLmh0bWwjZS1tYWlsLXN0YXRlLSUyOHR5cGU9ZW1haWwlMjkpXG4gIHZhciBSTUFJTCA9IG5ldyBSZWdFeHAoL15bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvKTtcbiAgLy9SZWdFeHAgZm9yIGlucHV0IG51bWJlciBjb250cm9sIG1ldGhvZFxuICB2YXIgUk5VTUJFUiA9IG5ldyBSZWdFeHAoL15bXFwtXFwrXT8oXFxkK3xcXGQrXFwuP1xcZCspJC8pO1xuXG4gIC8qKlxuICAgKiAgRm9ybSB2YWxpZGF0ZSBlcnJvciBtZXNzYWdlc1xuICAgKi9cbiAgdmFyIG1lc3NhZ2VzID0ge1xuICAgIHJlcXVpcmVkICA6ICdUaGlzIGZpZWxkIGlzIHJlcXVpcmVkLicsXG4gICAgZW1haWwgICAgIDogJ1lvdXIgRS1tYWlsIGFkZHJlc3MgYXBwZWFycyB0byBiZSBpbnZhbGlkLicsXG4gICAgbnVtYmVyICAgIDogJ1lvdSBjYW4gZW50ZXIgb25seSBudW1iZXJzIGluIHRoaXMgZmllbGQuJyxcbiAgICBudW1NYXggICAgOiAnUGxlYXNlIGVudGVyIGEgbnVtYmVyIGxlc3MgdGhhbiB7bWF4fS4nLFxuICAgIG51bU1pbiAgICA6ICdQbGVhc2UgZW50ZXIgYSBudW1iZXIgZ3JlYXRlciB0aGFuIHttaW59LicsXG4gICAgbnVtUmFuZ2UgIDogJ1BsZWFzZSBlbnRlciBhIG51bWJlciBncmVhdGVyIHRoYW4ge21pbn0gYW5kIGxlc3MgdGhhbiB7bWF4fS4nLFxuICAgIG1heExlbmd0aCA6ICdNYXhpbXVtIHtjb3VudH0gY2hhcmFjdGVycyBhbGxvd2VkLicsXG4gICAgbWluTGVuZ3RoIDogJ01pbmltdW0ge2NvdW50fSBjaGFyYWN0ZXJzIGFsbG93ZWQuJyxcbiAgICBtYXhDaGVja2VkICA6ICdNYXhpbXVtIHtjb3VudH0gb3B0aW9ucyBhbGxvd2VkLicsXG4gICAgbWluQ2hlY2tlZCAgOiAnUGxlYXNlIHNlbGVjdCBtaW5pbXVtIHtjb3VudH0gb3B0aW9ucy4nLFxuICAgIG1heFNlbGVjdGVkIDogJ01heGltdW0ge2NvdW50fSBzZWxlY3Rpb24gYWxsb3dlZC4nLFxuICAgIG1pblNlbGVjdGVkIDogJ01pbmltdW0ge2NvdW50fSBzZWxlY3Rpb24gYWxsb3dlZC4nLFxuICAgIG5vdEVxdWFsICAgIDogJ0ZpZWxkcyBkbyBub3QgbWF0Y2guJyxcbiAgICBkaWZmZXJlbnQgICA6ICdGaWVsZHMgY2Fubm90IGJlIHRoZSBzYW1lIGFzIGVhY2ggb3RoZXInLFxuICAgIGNyZWRpdENhcmQgIDogJ0ludmFsaWQgY3JlZGl0IGNhcmQgbnVtYmVyLicsXG4gIH07XG5cbiAgLyoqXG4gICAqICBQbHVnaW4gZGVmYXVsdHNcbiAgICovXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBzaG93RXJyb3JNZXNzYWdlIDogdHJ1ZSwgLy8gSWYgeW91IGRvbnQgd2FudCB0byBkaXNwbGF5IGVycm9yIG1lc3NhZ2VzIHNldCB0aGlzIG9wdGlvbnMgZmFsc2VcbiAgICBzaG93TXVsdGlwbGU6IGZhbHNlLCAvLyB3aGV0aGVyIG9yIG5vdCB0byBzaG93IGFsbCBlcnJvcnMgb24gYW4gaW5wdXQgYXQgb25jZVxuICAgIGRpc2FibGVOYXRpdmU6IHRydWUsIC8vIHdoZXRoZXIgb3Igbm90IHRvIHNob3cgYWxsIGVycm9ycyBvbiBhbiBpbnB1dCBhdCBvbmNlXG4gICAgdmFsaWRhdGlvbkNsYXNzOiAnZm9ybS1pbnB1dCcsIC8vIENsYXNzIG9mIGVsZW1lbnRzIHRvIGJlIHZhbGlkYXRlZFxuICAgIGlucHV0V3JhcHBlckNsYXNzIDogJ2Zvcm0tZmllbGQnLCAvLyBDbGFzcyBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciB3ZSB3YW50IHRvIGFwcGVuZCB0aGUgZXJyb3IgbWVzc2FnZSB0b1xuICAgIGVycm9yVGVtcGxhdGVDbGFzcyA6ICdmb3JtLWlubGluZS1tZXNzYWdlJywgLy8gQ2xhc3Mgb2YgdGhlIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgZXJyb3JDbGFzcyA6ICdmb3JtLWZpZWxkLWludmFsaWQnLCAvLyBDbGFzcyBhZGRlZCB0byBwYXJlbnQgb2YgZWFjaCBmYWlsaW5nIHZhbGlkYXRpb24gZmllbGRcbiAgICB2YWxpZENsYXNzIDogJ2Zvcm0tZmllbGQtdmFsaWQnLCAvLyBTYW1lIGZvciB2YWxpZCB2YWxpZGF0aW9uXG4gICAgcmVhbFRpbWU6IGZhbHNlLCAvLyBUbyBlbmFibGUgcmVhbC10aW1lIGZvcm0gY29udHJvbCwgc2V0IHRoaXMgb3B0aW9uIHRydWUuXG4gICAgb25WYWxpZDogZnVuY3Rpb24oKXt9LCAvLyBUaGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN1Ym1pdHMgdGhlIGZvcm0gYW5kIHRoZXJlIGlzIG5vIGVycm9yLlxuICAgIG9uRXJyb3I6IGZ1bmN0aW9uKCl7fSwgLy8gVGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdWJtaXRzIHRoZSBmb3JtIGFuZCB0aGVyZSBhcmUgc29tZSBlcnJvcnNcbiAgICB2YWxpZGF0b3JzOiB7fSwgLy8gQ3VzdG9tIHZhbGlkYXRvcnMgc3RvcmVkIGluIHRoaXMgdmFyaWFibGVcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBsZWZ0IGFuZCByaWdodCBzcGFjZXMgb2YgZ2l2ZW4gcGFyYW1ldGVyLlxuICAgKiBUaGlzIGlzIHRoZSBmdW5jdGlvbiBmb3Igc3RyaW5nIHBhcmFtZXRlciFcbiAgICogSWYgcGFyYW1ldGVyIGlzIGFuIGFycmF5LCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgdW50cmltbWVkIHBhcmFtZXRlclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybiB7bWl4ZWR9XG4gICAqL1xuICB2YXIgdHJpbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykgOiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdG9yXG4gICAqIHtjb3VudH0gd2hpY2ggdXNlZCBiZWxvdyBpcyB0aGUgc3BlY2lmaWVkIG1heGltdW0gb3IgbWluaW11bSB2YWx1ZVxuICAgKiBlLmcgaWYgbWV0aG9kIGlzIG1pbkxlbmd0aCBhbmQgIHJ1bGUgaXMgMiAobWluTGVuZ3RoWzJdKVxuICAgKiBPdXRwdXQgZXJyb3IgbWVzc2FnZXMgdGV4dCB3aWxsIGJlIDogJ1BsZWFzZSBzZWxlY3QgbWluaW11bSAyIG9wdGlvbnMuJ1xuICAgKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0bXAgPSB0aGlzLnRtcCBUbXAgb2JqZWN0IGZvciBzdG9yZSBjdXJyZW50IGZpZWxkIGFuZCBpdHMgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbDogZmllbGQgdmFsdWVcbiAgICovXG4gIHZhciBWYWxpZGF0b3IgPSB7XG4gICAgcmVxdWlyZWQ6IGZ1bmN0aW9uKHRtcCwgc2VsZikge1xuICAgICAgc3dpdGNoICh0bXAuZWwudHlwZSkge1xuICAgICAgICBjYXNlICdjaGVja2JveCcgOiByZXR1cm4gdG1wLmVsLmNoZWNrZWQgfHwgbWVzc2FnZXMucmVxdWlyZWQ7XG4gICAgICAgIGNhc2UgJ3JhZGlvJyA6IHJldHVybiB0aGlzLnJhZGlvLmNhbGwoc2VsZiwgdG1wLmVsKSB8fCBtZXNzYWdlcy5yZXF1aXJlZDtcbiAgICAgICAgY2FzZSAnc2VsZWN0LW11bHRpcGxlJyA6IHJldHVybiB0bXAudmFsICE9PSBudWxsIHx8IG1lc3NhZ2VzLnJlcXVpcmVkO1xuICAgICAgICBjYXNlICdzZWxlY3Qtb25lJyA6IHJldHVybiB0bXAudmFsICE9PSBudWxsIHx8IG1lc3NhZ2VzLnJlcXVpcmVkO1xuICAgICAgICBkZWZhdWx0IDogcmV0dXJuIHRtcC52YWwgIT09ICcnIHx8IG1lc3NhZ2VzLnJlcXVpcmVkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAgTWFpbCBjaGVjayAtIGl0IGNoZWNrcyB0aGUgdmFsdWUgaWYgaXQncyBhIHZhbGlkIGVtYWlsIGFkZHJlc3Mgb3Igbm90XG4gICAgZW1haWw6IGZ1bmN0aW9uKHRtcCkge1xuICAgICAgcmV0dXJuIFJNQUlMLnRlc3QodG1wLnZhbCkgfHwgbWVzc2FnZXMuZW1haWw7XG4gICAgfSxcblxuICAgIC8vIE51bWJlciBjaGVja1xuICAgIG51bWJlcjogZnVuY3Rpb24odG1wLCBzZWxmKSB7XG4gICAgICBpZiAoUk5VTUJFUi50ZXN0KHRtcC52YWwpKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICB2YXIgdmFsID0gcGFyc2VJbnQodG1wLnZhbCwgMTApO1xuICAgICAgICB2YXIgbWF4ID0gdG1wLmVsLm1heCA/IHBhcnNlSW50KHRtcC5lbC5tYXgsIDEwKSA6IEluZmluaXR5O1xuICAgICAgICB2YXIgbWluID0gdG1wLmVsLm1pbiA/IHBhcnNlSW50KHRtcC5lbC5taW4sIDEwKSA6IC1JbmZpbml0eTtcblxuICAgICAgICAvLyBjaGVjayBhdHRyaWJ1dGVzIGFuZCBhc3NpZ24gZXJyb3IgbWVzc2FnZXMsIGF1dG8tdmFsaWRhdGUgaWYgbmVpdGhlciBpcyBhcHBsaWVkIHRvIGVsZW1lbnRcbiAgICAgICAgaWYgKHRtcC5lbC5tYXggJiYgdG1wLmVsLm1pbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlcy5udW1SYW5nZTtcbiAgICAgICAgfSBlbHNlIGlmICh0bXAuZWwubWF4KSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzLm51bU1heDtcbiAgICAgICAgfSBlbHNlIGlmICh0bXAuZWwubWluKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzLm51bU1pbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPj0gbWluICYmIHZhbCA8PSBtYXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzTnVtYmVyTWVzc2FnZShtZXNzYWdlLCB0bXAuZWwubWluLCB0bXAuZWwubWF4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzLm51bWJlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gTWluaW11bSBsZW5ndGggY2hlY2tcbiAgICBtaW5MZW5ndGg6IGZ1bmN0aW9uKHRtcCkge1xuICAgICAgdmFyIF9sZW5ndGggPSB0bXAudmFsLmxlbmd0aDtcbiAgICAgIHJldHVybiBfbGVuZ3RoID09PSAwIHx8IF9sZW5ndGggPj0gdG1wLmFyZyB8fCBtZXNzYWdlcy5taW5MZW5ndGgucmVwbGFjZSgne2NvdW50fScsIHRtcC5hcmcpO1xuICAgIH0sXG5cbiAgICAvLyBNYXhpbXVtIGxlbmdodCBjaGVja1xuICAgIG1heExlbmd0aDogZnVuY3Rpb24odG1wKSB7XG4gICAgICByZXR1cm4gdG1wLnZhbC5sZW5ndGggPD0gdG1wLmFyZyB8fCBtZXNzYWdlcy5tYXhMZW5ndGgucmVwbGFjZSgne2NvdW50fScsIHRtcC5hcmcpO1xuICAgIH0sXG5cbiAgICAvLyBlcXVhbFRvIGNoZWNrXG4gICAgZXF1YWxUbzogZnVuY3Rpb24odG1wLCBzZWxmKSB7XG4gICAgICByZXR1cm4gc2VsZi5mb3JtLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9XCInICsgdG1wLmFyZyArICdcIl0nKS52YWx1ZSA9PT0gdG1wLnZhbCB8fCBtZXNzYWdlcy5ub3RFcXVhbDtcbiAgICB9LFxuXG4gICAgZGlmZmVyZW50OiBmdW5jdGlvbih0bXAsIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLmZvcm0ucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1cIicgKyB0bXAuYXJnICsgJ1wiXScpLnZhbHVlICE9PSB0bXAudmFsIHx8IG1lc3NhZ2VzLmRpZmZlcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlZGl0IENhcmQgQ29udHJvbFxuICAgICAqIEBmcm9tIDogaHR0cDovL2FmLWRlc2lnbi5jb20vYmxvZy8yMDEwLzA4LzE4L3ZhbGlkYXRpbmctY3JlZGl0LWNhcmQtbnVtYmVyc1xuICAgICAqL1xuICAgIGNyZWRpdENhcmQ6IGZ1bmN0aW9uKHRtcCkge1xuICAgICAgaWYgKHRtcC52YWwgPT09ICcnKSByZXR1cm4gdHJ1ZTsgLy8gYWxsb3cgZW1wdHkgYmVjYXVzZSBlbXB0eSBjaGVjayBkb2VzIGJ5IHJlcXVpcmVkIG1ldGhlb2RcbiAgICAgIHZhciByZWc7XG4gICAgICB2YXIgY2FyZE51bWJlcjtcbiAgICAgIHZhciBwb3M7XG4gICAgICB2YXIgZGlnaXQ7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBzdWJUb3RhbDtcbiAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgdmFyIHN0cmxlbjtcbiAgICAgIHJlZyA9IG5ldyBSZWdFeHAoL1teMC05XSsvZyk7XG4gICAgICBjYXJkTnVtYmVyID0gdG1wLnZhbC5yZXBsYWNlKHJlZywgJycpO1xuICAgICAgc3RybGVuID0gY2FyZE51bWJlci5sZW5ndGg7XG4gICAgICBpZiAoc3RybGVuIDwgMTYpIHJldHVybiBtZXNzYWdlcy5jcmVkaXRDYXJkO1xuICAgICAgZm9yIChpID0gMCA7IGkgPCBzdHJsZW4gOyBpKyspIHtcbiAgICAgICAgcG9zID0gc3RybGVuIC0gaTtcbiAgICAgICAgZGlnaXQgPSBwYXJzZUludChjYXJkTnVtYmVyLnN1YnN0cmluZyhwb3MgLSAxLCBwb3MpLCAxMCk7XG4gICAgICAgIGlmIChpICUgMiA9PT0gMSkge1xuICAgICAgICAgIHN1YlRvdGFsID0gZGlnaXQgKiAyIDtcbiAgICAgICAgICBpZiAoc3ViVG90YWwgPiA5KSB7XG4gICAgICAgICAgICBzdWJUb3RhbCA9IDEgKyAoc3ViVG90YWwgLSAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YlRvdGFsID0gZGlnaXQgO1xuICAgICAgICB9XG4gICAgICAgIHN1bSArPSBzdWJUb3RhbCA7XG4gICAgICB9XG4gICAgICBpZiAoc3VtID4gMCAmJiBzdW0gJSAxMCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gbWVzc2FnZXMuY3JlZGl0Q2FyZDtcbiAgICB9LFxuXG4gICAgLy9DaGVja2JveCBjaGVja1xuICAgIG1heENoZWNrZWQ6IGZ1bmN0aW9uKHRtcCwgc2VsZikge1xuICAgICAgdmFyIGNvbnQgPSAkKHNlbGYuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPWNoZWNrYm94XVtuYW1lPVwiJyArIHRtcC5lbC5uYW1lICsgJ1wiXScpKTtcbiAgICAgIHZhciBjb3VudCA9ICBjb250LmZpbHRlcignOmNoZWNrZWQnKS5sZW5ndGg7XG4gICAgICBpZiAoY291bnQgPT09IDApIHJldHVybjtcbiAgICAgIHJldHVybiBjb3VudCA8PSB0bXAuYXJnIHx8IG1lc3NhZ2VzLm1heENoZWNrZWQucmVwbGFjZSgne2NvdW50fScsIHRtcC5hcmcpO1xuICAgIH0sXG5cbiAgICBtaW5DaGVja2VkOiBmdW5jdGlvbih0bXAsIHNlbGYpIHtcbiAgICAgIHZhciBjb250ID0gJChzZWxmLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1jaGVja2JveF1bbmFtZT1cIicgKyB0bXAuZWwubmFtZSArICdcIl0nKSk7XG4gICAgICB2YXIgY291bnQgPSAgY29udC5maWx0ZXIoJzpjaGVja2VkJykubGVuZ3RoO1xuICAgICAgcmV0dXJuIGNvdW50ID49IHRtcC5hcmcgfHwgbWVzc2FnZXMubWluQ2hlY2tlZC5yZXBsYWNlKCd7Y291bnR9JywgdG1wLmFyZyk7XG4gICAgfSxcblxuICAgIC8vU2VsZWN0Ym94IGNoZWNrXG4gICAgbWF4U2VsZWN0ZWQ6IGZ1bmN0aW9uKHRtcCkge1xuICAgICAgaWYgKHRtcC52YWwgPT09IG51bGwpIHJldHVybjtcbiAgICAgIHJldHVybiB0bXAudmFsLmxlbmd0aCA8PSB0bXAuYXJnIHx8IG1lc3NhZ2VzLm1heFNlbGVjdGVkLnJlcGxhY2UoJ3tjb3VudH0nLCB0bXAuYXJnKTtcbiAgICB9LFxuXG4gICAgbWluU2VsZWN0ZWQ6IGZ1bmN0aW9uKHRtcCkge1xuICAgICAgcmV0dXJuICh0bXAudmFsICE9PSBudWxsICYmIHRtcC52YWwubGVuZ3RoID49IHRtcC5hcmcpIHx8IG1lc3NhZ2VzLm1pblNlbGVjdGVkLnJlcGxhY2UoJ3tjb3VudH0nLCB0bXAuYXJnKTtcbiAgICB9LFxuXG4gICAgLy8gUmFkaW9cbiAgICByYWRpbzogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBjb3VudCA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPXJhZGlvXVtuYW1lPVwiJyArIGVsLm5hbWUgKyAnXCJdOmNoZWNrZWQnKS5sZW5ndGg7XG4gICAgICByZXR1cm4gY291bnQgPT09IDE7XG4gICAgfSxcblxuICAgIC8vIEN1c3RvbSByZWcgY2hlY2tcbiAgICByZWdFeHA6IGZ1bmN0aW9uKHRtcCwgc2VsZikge1xuICAgICAgdmFyIF9hcmcgPSBzZWxmLm9wdGlvbnMudmFsaWRhdG9ycy5yZWdFeHBbdG1wLmFyZ107XG4gICAgICB2YXIgX3JlZyA9IG5ldyBSZWdFeHAoX2FyZy5wYXR0ZXJuKTtcbiAgICAgIHJldHVybiBfcmVnLnRlc3QodG1wLnZhbCkgfHwgX2FyZy5lcnJvck1lc3NhZ2U7XG4gICAgfSxcblxuICAgIC8vIFJlbW90ZVxuICAgIHJlbW90ZTogZnVuY3Rpb24odG1wKSB7XG4gICAgICB0bXAucmVtb3RlID0gdG1wLmFyZztcbiAgICAgIHJldHVybjtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGJhY2tcbiAgICBjYWxsYmFjazogZnVuY3Rpb24odG1wLCBzZWxmKSB7XG4gICAgICB2YXIgX2NiID0gc2VsZi5vcHRpb25zLnZhbGlkYXRvcnMuY2FsbGJhY2tbdG1wLmFyZ107XG4gICAgICByZXR1cm4gX2NiLmNhbGxiYWNrKHRtcC5lbCwgdG1wLnZhbCkgfHwgX2NiLmVycm9yTWVzc2FnZTtcbiAgICB9LFxuICB9O1xuXG4gIC8qKlxuICAgKiBQbHVnaW4gQ2xhc3NcbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmb3JtIDogPGZvcm0+IGVsZW1lbnQgd2hpY2ggYmVpbmcgY29udHJvbGxlZFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyA6IFVzZXItc3BlY2lmaWVkIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge21ldGhvZH0gZXZlbnRzXG4gICAqL1xuICB2YXIgVmFsaWRldHRhID0gZnVuY3Rpb24oZm9ybSwgb3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqICBQdWJsaWMgIFByb3BlcnRpZXNcbiAgICAgKiAgQHByb3BlcnR5IHttaXhlZH0gaGFuZGxlciBJdCBpcyB1c2VkIHRvIHN0b3Agb3IgcmVzdW1lIHN1Ym1pdCBldmVudCBoYW5kbGVyXG4gICAgICogIEBwcm9wZXJ0eSB7b2JqZWN0fSBvcHRpb25zIFByb3BlcnR5IGlzIHN0b3JlZCBpbiBwbHVnaW4gb3B0aW9uc1xuICAgICAqICBAcHJvcGVydHkge29iamVjdH0geGhyIFN0b3JlcyB4aHIgcmVxdWVzdHNcbiAgICAgKiAgQHByb3BlcnR5IHtvYmplY3R9IGZvcm0gUHJvcGVydHkgaXMgc3RvcmVkIGluIDxmb3JtPiBlbGVtZW50XG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVyID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMueGhyID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplRm9ybSgpO1xuICAgIHRoaXMuZXZlbnRzKCk7XG4gIH07XG5cbiAgVmFsaWRldHRhLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogVmFsaWRldHRhLFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG5hdGl2ZSBicm93c2VyIHZhbGlkYXRpb24gZnJvbSB0YXJnZXQgZm9ybSBpZiBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZUZvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlTmF0aXZlKSB7XG4gICAgICAgIHRoaXMuZm9ybS5zZXRBdHRyaWJ1dGUoJ25vdmFsaWRhdGUnLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgbWV0aG9kIG9mIGhhbmRsaW5nIGV2ZW50c1xuICAgICAqXG4gICAgICogQHJldHVybiB7bWl4ZWR9XG4gICAgICovXG4gICAgZXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpczsgLy8gc3RvcmVkIHRoaXNcbiAgICAgIC8vIEhhbmRsZSBzdWJtaXQgZXZlbnRcbiAgICAgICQodGhpcy5mb3JtKS5zdWJtaXQoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy8gZmllbGRzIHRvIGJlIGNvbnRyb2xsZWQgdHJhbnNmZXJyZWQgdG8gZ2xvYmFsIHZhcmlhYmxlXG4gICAgICAgIEZJRUxEUyA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShzZWxmLm9wdGlvbnMudmFsaWRhdGlvbkNsYXNzKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW5pdChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIC8vIHJlYWwtdGltZSBvcHRpb24gY29udHJvbFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWFsVGltZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBoYW5kbGUgY2hhbmdlIGV2ZW50IGZvciBmb3JtIGVsZW1lbnRzICh3aXRob3V0IGNoZWNrYm94KVxuICAgICAgICAkKHRoaXMuZm9ybSkuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMudmFsaWRhdGlvbkNsYXNzKS5ub3QoJ1t0eXBlPWNoZWNrYm94XScpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIC8vIGZpZWxkIHRvIGJlIGNvbnRyb2xsZWQgdHJhbnNmZXJyZWQgdG8gZ2xvYmFsIHZhcmlhYmxlXG4gICAgICAgICAgRklFTERTID0gJChzZWxmKTtcbiAgICAgICAgICByZXR1cm4gc2VsZi5pbml0KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGhhbmRsZSBjbGljayBldmVudCBmb3IgY2hlY2tib3hlc1xuICAgICAgICAkKHRoaXMuZm9ybSkuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMudmFsaWRhdGlvbkNsYXNzICsgJ1t0eXBlPWNoZWNrYm94XScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgLy8gZmllbGRzIHRvIGJlIGNvbnRyb2xsZWQgdHJhbnNmZXJyZWQgdG8gZ2xvYmFsIHZhcmlhYmxlXG4gICAgICAgICAgRklFTERTID0gc2VsZi5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgc2VsZi5vcHRpb25zLnZhbGlkYXRpb25DbGFzcyArICdbdHlwZT1jaGVja2JveF1bbmFtZT1cIicgKyBzZWxmLm5hbWUgKyAnXCJdJyk7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuaW5pdChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIDxmb3JtPiByZXNldCBidXR0b24gdG8gY2xlYXIgZXJyb3IgbWVzc2FnZXNcbiAgICAgICQodGhpcy5mb3JtKS5vbigncmVzZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgJChzZWxmLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnLicgKyBzZWxmLm9wdGlvbnMuZXJyb3JDbGFzcyArICcgLCAuJyArIHNlbGYub3B0aW9ucy52YWxpZENsYXNzKSlcbiAgICAgICAgICAucmVtb3ZlQ2xhc3Moc2VsZi5vcHRpb25zLmVycm9yQ2xhc3MgKyAnICcgKyBzZWxmLm9wdGlvbnMudmFsaWRDbGFzcyk7XG4gICAgICAgIHJldHVybiBzZWxmLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW4gdGhpcyBtZXRob2QsIGZpZWxkcyBhcmUgdmFsaWRhdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW1zIHtvYmplY3R9IGUgOiBldmVudCBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHttaXhlZH1cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gUmVzZXQgZXJyb3IgbWVzc2FnZXMgZnJvbSBhbGwgZWxlbWVudHNcbiAgICAgIHRoaXMucmVzZXQoRklFTERTKTtcbiAgICAgIC8vIFN0YXJ0IGNvbnRyb2wgZWFjaCBlbGVtZW50c1xuICAgICAgdGhpcy5jaGVja0ZpZWxkcyhldmVudCk7XG4gICAgICBpZiAoZXZlbnQudHlwZSAhPT0gJ3N1Ym1pdCcpIHJldHVybjsgLy8gaWYgZXZlbnQgdHlwZSBpcyBub3Qgc3VibWl0LCBicmVha1xuICAgICAgLy8gVGhpcyBpcyBmb3Igd2hlbiBydW5uaW5nIHJlbW90ZSByZXF1ZXN0LCByZXR1cm4gZmFsc2UgYW5kIHdhaXQgcmVxdWVzdCByZXNwb25zZVxuICAgICAgZWxzZSBpZiAodGhpcy5oYW5kbGVyID09PSAncGVuZGluZycpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIGlmIGV2ZW50IHR5cGUgaXMgc3VibWl0IGFuZCBoYW5kbGVyIGlzIHRydWUsIGJyZWFrIHN1Ym1pdCBhbmQgY2FsbCBvbkVycm9yKCkgZnVuY3Rpb25cbiAgICAgIGVsc2UgaWYgKHRoaXMuaGFuZGxlciA9PT0gdHJ1ZSkgeyB0aGlzLm9wdGlvbnMub25FcnJvci5jYWxsKHRoaXMsIGV2ZW50KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBlbHNlIHJldHVybiB0aGlzLm9wdGlvbnMub25WYWxpZC5jYWxsKHRoaXMsIGV2ZW50KTsgLy8gaWYgZm9ybSBpcyB2YWxpZCBjYWxsIG9uVmFsaWQoKSBmdW5jdGlvblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgRmllbGRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGUgZXZlbnQgb2JqZWN0XG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBjaGVja0ZpZWxkczogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpczsgLy8gc3RvcmVkIHRoaXNcbiAgICAgIHZhciBpbnZhbGlkRmllbGRzID0gW107XG5cbiAgICAgIC8vIE1ha2UgaW52YWxpZEZpZWxkcyBhY2Nlc3NpYmxlXG4gICAgICB0aGlzLmdldEludmFsaWRGaWVsZHMgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gaW52YWxpZEZpZWxkcztcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBfbGVuZ3RoRmllbGRzID0gRklFTERTLmxlbmd0aDsgaSA8IF9sZW5ndGhGaWVsZHM7IGkrKykge1xuICAgICAgICAvLyBpZiBmaWVsZCBpcyBkaXNhYmxlZCwgZG8gbm90IGNoZWNrXG4gICAgICAgIGlmIChGSUVMRFNbaV0uZGlzYWJsZWQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZWwgPSBGSUVMRFNbaV07IC8vY3VycmVudCBmaWVsZFxuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlcyA9ICcnOyAvL2N1cnJlbnQgZmllbGQncyBlcnJvcnNcbiAgICAgICAgdmFyIHZhbCA9IHRyaW0oJChlbCkudmFsKCkpOyAvL2N1cnJlbnQgZmllbGQncyB2YWx1ZVxuICAgICAgICB2YXIgbWV0aG9kcyA9IHNlbGYuZ2V0SW5wdXRWYWxpZGF0b3JzKGVsKTsgLy9jdXJyZW50IGZpZWxkJ3MgY29udHJvbCBtZXRob2RzXG4gICAgICAgIHZhciBzdGF0ZTsgLy8gVmFsaWRhdGlvbiBzdGF0ZVxuICAgICAgICAvLyBDcmVhdGUgdG1wXG4gICAgICAgIHRoaXMudG1wID0ge307XG4gICAgICAgIC8vIHN0b3JlIGVsIGFuZCB2YWwgdmFyaWFibGVzIGluIHRtcFxuICAgICAgICB0aGlzLnRtcCA9IHsgZWwgOiBlbCwgdmFsIDogdmFsLCBwYXJlbnQgOiB0aGlzLnBhcmVudHMoZWwpIH07XG4gICAgICAgIC8vIFN0YXJ0IHRvIGNoZWNrIGZpZWxkc1xuICAgICAgICAvLyBWYWxpZGF0b3IgOiBGaWVsZHMgQ29udHJvbCBPYmplY3RcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIF9sZW5ndGhNZXRob2RzID0gbWV0aG9kcy5sZW5ndGg7IGogPCBfbGVuZ3RoTWV0aG9kczsgaisrKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgUnVsZVxuICAgICAgICAgIHZhciBydWxlID0gbWV0aG9kc1tqXS5tYXRjaChSUlVMRSk7XG4gICAgICAgICAgdmFyIG1ldGhvZDtcbiAgICAgICAgICAvLyBEb2VzIGl0IGhhdmUgcnVsZT9cbiAgICAgICAgICBpZiAocnVsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRG9lcyBpdCBoYXZlIGFueSBhcmd1bWVudCA/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGVbMl0gIT09ICd1bmRlZmluZWQnKSB0aGlzLnRtcC5hcmcgPSBydWxlWzJdO1xuICAgICAgICAgICAgLy8gU2V0IG1ldGhvZCBuYW1lXG4gICAgICAgICAgICBtZXRob2QgPSBydWxlWzFdO1xuICAgICAgICAgIH0gZWxzZSB7IG1ldGhvZCA9IG1ldGhvZHNbal07IH1cbiAgICAgICAgICAvLyBwcmV2ZW50IGVtcHR5IHZhbGlkYXRpb24gaWYgbWV0aG9kIGlzIG5vdCByZXF1aXJlZFxuICAgICAgICAgIGlmICh2YWwgPT09ICcnICYmIG1ldGhvZCAhPT0gJ3JlcXVpcmVkJyAmJiBtZXRob2QgIT09ICdlcXVhbFRvJykgY29udGludWU7XG4gICAgICAgICAgLy8gSXMgdGhlcmUgYSBtZXRob2QgaW4gVmFsaWRhdG9yID9cbiAgICAgICAgICBpZiAoVmFsaWRhdG9yLmhhc093blByb3BlcnR5KG1ldGhvZCkpIHtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRvciByZXR1cm5zIGVycm9yIG1lc3NhZ2UgaWYgbWV0aG9kIGludmFsaWRcbiAgICAgICAgICAgIHN0YXRlID0gVmFsaWRhdG9yW21ldGhvZF0oc2VsZi50bXAsIHNlbGYpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc3RhdGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIF9kYXRhTXNnID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXZkLW1lc3NhZ2UtJyArIG1ldGhvZCk7XG4gICAgICAgICAgICAgIC8vIGlzIHRoZXJlIGEgY3VzdG9tIG1lc3NhZ2U/XG4gICAgICAgICAgICAgIGlmIChfZGF0YU1zZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gX2RhdGFNc2c7XG4gICAgICAgICAgICAgICAgLy8gYWRkIG91ciBtaW4gYW5kIG1heCB2YWx1ZXMgaWYgaXQncyBhIG51bWJlciBpbnB1dFxuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZSA9IHRoaXMucHJvY2Vzc051bWJlck1lc3NhZ2Uoc3RhdGUsIHRoaXMudG1wLmVsLm1pbiwgdGhpcy50bXAuZWwubWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaG93IGFsbCBzdGF0ZXMgdGhhdCByZXR1cm4gaW52YWxpZFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZXMgKz0gc3RhdGUgKyAnPGJyPic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8ganVzdCBzaG93IHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZXMgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoZSBlcnJvcnNcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZXMgIT09ICcnKSB7XG4gICAgICAgICAgaW52YWxpZEZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGZpZWxkOiBlbCxcbiAgICAgICAgICAgIGVycm9yczogZXJyb3JNZXNzYWdlcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBpZiBwYXJlbnQgZWxlbWVudCBoYXMgdmFsaWQgY2xhc3MsIHJlbW92ZSBhbmQgYWRkIGVycm9yIGNsYXNzXG4gICAgICAgICAgdGhpcy5hZGRFcnJvckNsYXNzKHRoaXMudG1wLnBhcmVudCk7XG4gICAgICAgICAgLy8gc2hvdyBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgdGhpcy5ub3RpZnkuc2hvdy5jYWxsKHRoaXMgLCBlbCwgZXJyb3JNZXNzYWdlcyk7XG4gICAgICAgIC8vIENoZWNrIHJlbW90ZSB2YWxpZGF0aW9uXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMudG1wLnJlbW90ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrUmVtb3RlKGVsLCBldmVudCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIE5pY2UsIHRoZXJlIGFyZSBubyBlcnJvclxuICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgIT09ICd1bmRlZmluZWQnKSB0aGlzLmFkZFZhbGlkQ2xhc3ModGhpcy50bXAucGFyZW50KTtcbiAgICAgICAgICBlbHNlICQodGhpcy50bXAucGFyZW50KS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcyArICcgJyArIHRoaXMub3B0aW9ucy52YWxpZENsYXNzKTtcbiAgICAgICAgICBzdGF0ZSA9IHVuZGVmaW5lZDsgLy8gUmVzZXQgc3RhdGUgdmFyaWFibGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoYXQgdmFsaWRhdG9ycyB0byBydW4gcGVyIGlucHV0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGVsIGN1cnJlbnQgZmllbGRcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gYSBsaXN0IG9mIGFsbCB2YWxpZGF0b3JzIHRvIHJ1biBhZ2FpbnN0IHRoZSBpbnB1dCdzIHZhbHVlXG4gICAgICovXG4gICAgZ2V0SW5wdXRWYWxpZGF0b3JzOiBmdW5jdGlvbihlbCkge1xuICAgICAgLy8gdmFsaWRhdG9ycyBkZWZpbmVkIG91dHNpZGUgb2YgbmF0aXZlIGh0bWw1IGF0dHJzXG4gICAgICB2YXIgdmFsaWRhdG9ycyA9IGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS12YWxpZGF0ZXMnKSA/IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS12YWxpZGF0ZXMnKS5zcGxpdCgnLCcpIDogW107XG5cbiAgICAgIGlmIChlbC5yZXF1aXJlZCAmJiB2YWxpZGF0b3JzLmluZGV4T2YoJ3JlcXVpcmVkJykgPT09IC0xKSB2YWxpZGF0b3JzLnB1c2goJ3JlcXVpcmVkJyk7XG4gICAgICBpZiAoZWwudHlwZSA9PT0gJ251bWJlcicgJiYgdmFsaWRhdG9ycy5pbmRleE9mKCdudW1iZXInKSA9PT0gLTEpIHZhbGlkYXRvcnMucHVzaCgnbnVtYmVyJyk7XG4gICAgICBpZiAoZWwudHlwZSA9PT0gJ2VtYWlsJyAmJiB2YWxpZGF0b3JzLmluZGV4T2YoJ2VtYWlsJykgPT09IC0xKSB2YWxpZGF0b3JzLnB1c2goJ2VtYWlsJyk7XG5cbiAgICAgIHJldHVybiB2YWxpZGF0b3JzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgcmVtb3RlIHZhbGlkYXRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGVsIGN1cnJlbnQgZmllbGRcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGUgZXZlbnQgb2JqZWN0XG4gICAgICogQHRocm93cyB7ZXJyb3J9IElmIHByZXZpb3VzIHJlbW90ZSByZXF1ZXN0IGZvciBzYW1lIHZhbHVlIGhhcyByZWplY3RlZFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgY2hlY2tSZW1vdGU6IGZ1bmN0aW9uKGVsLCBldmVudCkge1xuICAgICAgdmFyIGFqYXhPcHRpb25zID0ge307XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgdmFyIGZpZWxkTmFtZSA9IGVsLm5hbWUgfHwgZWwuaWQ7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5yZW1vdGVDYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHRoaXMucmVtb3RlQ2FjaGUgPSB7fTtcblxuICAgICAgZGF0YVtmaWVsZE5hbWVdID0gdGhpcy50bXAudmFsOyAvLyBTZXQgZGF0YVxuICAgICAgLy8gZXhlbmRzIGFqYXggb3B0aW9uc1xuICAgICAgYWpheE9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgfSwgdGhpcy5vcHRpb25zLnZhbGlkYXRvcnMucmVtb3RlW3RoaXMudG1wLnJlbW90ZV0gfHwge30pO1xuXG4gICAgICAvLyB1c2UgJC5wYXJhbSgpIGZ1bmN0aW9uIGZvciBnZW5lcmF0ZSBzcGVjaWZpYyBjYWNoZSBrZXlcbiAgICAgIHZhciBjYWNoZUtleSA9ICQucGFyYW0oYWpheE9wdGlvbnMpO1xuXG4gICAgICAvLyBDaGVjayBjYWNoZVxuICAgICAgdmFyIGNhY2hlID0gdGhpcy5yZW1vdGVDYWNoZVtjYWNoZUtleV07XG5cbiAgICAgIGlmICh0eXBlb2YgY2FjaGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN3aXRjaChjYWNoZS5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgJ3BlbmRpbmcnIDogLy8gcGVuZGluZyBtZWFucyByZW1vdGUgcmVxdWVzdCBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSAncGVuZGluZyc7IC8vIHVwZGF0ZSBoYW5kbGVyIGFuZCBjYWNoZSBldmVudCB0eXBlXG4gICAgICAgICAgICBjYWNoZS5ldmVudCA9IGV2ZW50LnR5cGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZWplY3RlZCcgOiAvLyByZWplY3RlZCBtZWFucyByZW1vdGUgcmVxdWVzdCBjb3VsZCBub3QgYmUgcGVyZm9ybWVkXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyB3ZSBoYXZlIHRvIGJyZWFrIHN1Ym1pdCBiZWNhdXNlIG9mIHRocm93IGVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2FjaGUucmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICAgIGNhc2UgJ3Jlc29sdmVkJyA6IC8vIHJlc29sdmVkIG1lYW5zIHJlbW90ZSByZXF1ZXN0IGhhcyBkb25lXG4gICAgICAgICAgICAvLyBDaGVjayB0byBjYWNoZSwgaWYgcmVzdWx0IGlzIGludmFsaWQsIHNob3cgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgaWYgKGNhY2hlLnJlc3VsdC52YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGRFcnJvckNsYXNzKHRoaXMudG1wLnBhcmVudCk7XG4gICAgICAgICAgICAgIHRoaXMubm90aWZ5LnNob3cuY2FsbCh0aGlzLCBlbCwgY2FjaGUucmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGRWYWxpZENsYXNzKHRoaXMudG1wLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFib3J0IGlmIHByZXZpb3VzIGFqYXggcmVxdWVzdCBzdGlsbCBydW5uaW5nXG4gICAgICAgIHZhciBfeGhyID0gdGhpcy54aHJbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBfeGhyICE9PSAndW5kZWZpbmVkJyAmJiBfeGhyLnN0YXRlKCkgPT09ICdwZW5kaW5nJykgX3hoci5hYm9ydCgpO1xuICAgICAgICAvLyBTdGFydCBjYWNoaW5nXG4gICAgICAgIGNhY2hlID0gdGhpcy5yZW1vdGVDYWNoZVtjYWNoZUtleV0gPSB7IHN0YXRlIDogJ3BlbmRpbmcnLCBldmVudCA6IGV2ZW50LnR5cGUgfTtcbiAgICAgICAgLy8gbWFrZSBhIHJlbW90ZSByZXF1ZXN0XG4gICAgICAgIHRoaXMucmVtb3RlUmVxdWVzdChhamF4T3B0aW9ucywgY2FjaGUsIGVsLCBmaWVsZE5hbWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBhamF4IHJlcXVlc3QgZm9yIHJlbW90ZSB2YWxpZGF0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBhamF4T3B0aW9ucyBBamF4IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGNhY2hlIENhY2hlIG9iamVjdFxuICAgICAqIEBwYXJhbSAge29iamVjdH0gZWwgcHJvY2Vzc2luZyBlbGVtZW50XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBmaWVsZE5hbWUgRmllbGQgbmFtZSBmb3IgbWFrZSBzcGVjaWZpYyBjYWNoaW5nXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICByZW1vdGVSZXF1ZXN0OiBmdW5jdGlvbihhamF4T3B0aW9ucywgY2FjaGUsIGVsLCBmaWVsZE5hbWUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgJCh0aGlzLnRtcC5wYXJlbnQpLmFkZENsYXNzKCd2YWxpZGV0dGEtcGVuZGluZycpO1xuXG4gICAgICAvLyBjYWNoZSB4aHJcbiAgICAgIHRoaXMueGhyW2ZpZWxkTmFtZV0gPSAkLmFqYXgoYWpheE9wdGlvbnMpXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0JykgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xuICAgICAgICAgIGNhY2hlLnN0YXRlID0gJ3Jlc29sdmVkJztcbiAgICAgICAgICBjYWNoZS5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgaWYgKGNhY2hlLmV2ZW50ID09PSAnc3VibWl0Jykge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyID0gZmFsc2U7XG4gICAgICAgICAgICAkKHNlbGYuZm9ybSkudHJpZ2dlcignc3VibWl0Jyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQudmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzZWxmLmFkZEVycm9yQ2xhc3Moc2VsZi50bXAucGFyZW50KTtcbiAgICAgICAgICAgIHNlbGYubm90aWZ5LnNob3cuY2FsbChzZWxmLCBlbCwgcmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmFkZFZhbGlkQ2xhc3Moc2VsZi50bXAucGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5mYWlsKGZ1bmN0aW9uKGpxWEhSLCB0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgaWYgKHRleHRTdGF0dXMgIT09ICdhYm9ydCcpIHsgLy8gRG9udCB0aHJvdyBlcnJvciBpZiByZXF1ZXN0IGlzIGFib3J0ZWRcbiAgICAgICAgICAgIHZhciBfbXNnID0gJ0FqYXggcmVxdWVzdCBmYWlsZWQgZm9yIGZpZWxkICgnICsgZmllbGROYW1lICsgJykgOiAnICsganFYSFIuc3RhdHVzICsgJyAnICsganFYSFIuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgIGNhY2hlLnN0YXRlID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIGNhY2hlLnJlc3VsdCA9IHsgdmFsaWQ6IGZhbHNlLCBtZXNzYWdlIDogX21zZyB9O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9tc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmFsd2F5cyhmdW5jdGlvbigpIHsgJChzZWxmLnRtcC5wYXJlbnQpLnJlbW92ZUNsYXNzKCd2YWxpZGV0dGEtcGVuZGluZycpOyB9KTtcblxuICAgICAgdGhpcy5oYW5kbGVyID0gJ3BlbmRpbmcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93aW5nIG9yIGhpZGluZyBlcnJvciBtZXNzYWdlc1xuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqL1xuICAgIG5vdGlmeToge1xuICAgICAgLyoqXG4gICAgICAgKiBFcnJvciBtZXNzYWdlIHNob3dzXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtcyB7b2JqZWN0fSBlbCA6IGVsZW1lbnQgd2hpY2ggaGFzIGFuIGVycm9yIChpdCBjYW4gYmUgbmF0aXZlIGVsZW1lbnQgb3IgalF1ZXJ5IG9iamVjdClcbiAgICAgICAqIEBwYXJhbXMge3N0cmluZ30gZXJyb3IgOiBlcnJvciBtZXNzYWdlc1xuICAgICAgICovXG4gICAgICBzaG93OiBmdW5jdGlvbihlbCwgZXJyb3IpIHtcbiAgICAgICAgLy8gV2Ugd2FudCBkaXNwbGF5IGVycm9ycyA/XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAvLyBiZWNhdXNlIG9mIGZvcm0gbm90IHZhbGlkLCBzZXQgaGFuZGxlciB0cnVlIGZvciBicmVhayBzdWJtaXRcbiAgICAgICAgICB0aGlzLmhhbmRsZXIgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxQYXJlbnQgPSB0aGlzLnBhcmVudHMoZWwpO1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IGVsZW1lbnQgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIGVsIGlzIGFuIG9iamVjdC4gU28gd2UgbmVlZCB0byB0cmFuc2Zvcm0gdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgaWYgKHR5cGVvZiBlbFBhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIGVsUGFyZW50ID0gZWxbMF0ucGFyZW50Tm9kZTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gZXJyb3IgbWVzc2FnZSB3aGljaCBwcmV2aW91c2x5IHNob3duIGZvciBlbCwgcmV0dXJuXG4gICAgICAgIGlmIChlbFBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIHRoaXMub3B0aW9ucy5lcnJvclRlbXBsYXRlQ2xhc3MpLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGVycm9yIG1lc3NhZ2Ugb2JqZWN0XG4gICAgICAgIHZhciBlcnJvck9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgZXJyb3JPYmplY3QuY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmVycm9yVGVtcGxhdGVDbGFzcztcbiAgICAgICAgZWxQYXJlbnQuYXBwZW5kQ2hpbGQoZXJyb3JPYmplY3QpO1xuICAgICAgICBlcnJvck9iamVjdC5pbm5lckhUTUwgPSBlcnJvciA7XG5cbiAgICAgICAgLy8gd2UgaGF2ZSBhbiBlcnJvciBzbyB3ZSBuZWVkIHRvIGJyZWFrIHN1Ym1pdFxuICAgICAgICAvLyBzZXQgdG8gaGFuZGxlciB0cnVlXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IHRydWU7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBFcnJvciBtZXNzYWdlIGhpZGVzXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtcyBlbCA6IHRoZSBlcnJvciBtZXNzYWdlIHdoaWNoIHdpbGwgYmUgZGlzYXBwZWFyXG4gICAgICAgKi9cbiAgICAgIGhpZGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfSxcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlcnJvciBtZXNzYWdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9yIHt2b2lkfSBlbCA6IGZvcm0gZWxlbWVudHMgd2hpY2ggaGF2ZSBhbiBlcnJvciBtZXNzYWdlXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgX2Vycm9yTWVzc2FnZXMgPSB7fTtcbiAgICAgIC8vIGlmIGVsIGlzIHVuZGVmaW5lZCAoVGhpcyBpcyB0aGUgcHJvY2VzcyBvZiByZXNldHRpbmcgYWxsIDxmb3JtPilcbiAgICAgIC8vIG9yIGVsIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBlbGVtZW50IG1vcmUgdGhhbiBvbmVcbiAgICAgIC8vIGFuZCB0aGVzZSBlbGVtZW50cyBhcmUgbm90IGNoZWNrYm94XG4gICAgICBpZiAodHlwZW9mIGVsID09PSAndW5kZWZpbmVkJyB8fCAoZWwubGVuZ3RoID4gMSAmJiBlbFswXS50eXBlICE9PSAnY2hlY2tib3gnKSkge1xuICAgICAgICBfZXJyb3JNZXNzYWdlcyA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIHRoaXMub3B0aW9ucy5lcnJvclRlbXBsYXRlQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2Vycm9yTWVzc2FnZXMgPSB0aGlzLnBhcmVudHMoZWxbMF0pLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgdGhpcy5vcHRpb25zLmVycm9yVGVtcGxhdGVDbGFzcyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgX2xlbmd0aEVycm9yTWVzc2FnZXMgPSBfZXJyb3JNZXNzYWdlcy5sZW5ndGg7IGkgPCBfbGVuZ3RoRXJyb3JNZXNzYWdlczsgaSsrKSB7XG4gICAgICAgIHRoaXMubm90aWZ5LmhpZGUuY2FsbCh0aGlzLCBfZXJyb3JNZXNzYWdlc1tpXSk7XG4gICAgICB9XG4gICAgICAvLyBzZXQgdG8gaGFuZGxlciBmYWxzZVxuICAgICAgLy8gb3RoZXJ3aXNlIGF0IHRoZSBuZXh0IHZhbGlkYXRpb24gYXR0ZW1wdCwgc3VibWl0IHdpbGwgbm90IGNvbnRpbnVlIGV2ZW4gdGhlIHZhbGlkYXRpb24gaXMgc3VjY2Vzc2Z1bFxuICAgICAgdGhpcy5oYW5kbGVyID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgZXJyb3IgY2xhc3MgYW5kIHJlbW92ZXMgdmFsaWQgY2xhc3MgaWYgZXhpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbCBlbGVtZW50XG4gICAgICovXG4gICAgYWRkRXJyb3JDbGFzczogZnVuY3Rpb24oZWwpIHtcbiAgICAgICQoZWwpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy52YWxpZENsYXNzKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsaWQgY2xhc3MgYW5kIHJlbW92ZXMgZXJyb3IgY2xhc3MgaWYgZXhpc3RcbiAgICAgKiBpZiBlcnJvciBjbGFzcyBub3QgZXhpc3QsIGRvIG5vdCBhZGQgdmFsaWQgY2xhc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbCBlbGVtZW50XG4gICAgICovXG4gICAgYWRkVmFsaWRDbGFzczogZnVuY3Rpb24oZWwpIHtcbiAgICAgICQoZWwpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5lcnJvckNsYXNzKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudmFsaWRDbGFzcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHBhcmVudCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGVsIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IGVsIHBhcmVudCBlbGVtZW50XG4gICAgICovXG4gICAgcGFyZW50czogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiAkKGVsKS5wYXJlbnRzKCcuJyArIHRoaXMub3B0aW9ucy5pbnB1dFdyYXBwZXJDbGFzcylbMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1pbiAmIG1hIHBsYWNlaG9sZGVycyBpbiBudW1iZXIgaW5wdXRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIHJhdyBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbiAtIHRoZSBpbnB1dCdzIG1pbiByYW5nZSAoY2FuIGJlIG51bGwpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1heCAtIHRoZSBpbnB1dCdzIG1heCByYW5nZSAoY2FuIGJlIG51bGwpXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBtZXNzYWdlIC0gcHJvY2Vzc2VkIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBwcm9jZXNzTnVtYmVyTWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSwgbWluLCBtYXgpIHtcbiAgICAgIGlmIChtaW4pIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoJ3ttaW59JywgbWluKTtcbiAgICAgIGlmIChtYXgpIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoJ3ttYXh9JywgbWF4KTtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gIH07XG5cbiAgLyoqXG4gICAqIFBsdWdpbiBWYWxpZGV0dGFcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgOiBVc2VyLXNwZWNpZmllZCBzZXR0aW5nc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9IHRoaXNcbiAgICovXG4gICQuZm4udmFsaWRldHRhID0gZnVuY3Rpb24ob3B0aW9ucywgX21lc3NhZ2VzKSB7XG4gICAgaWYgKHR5cGVvZiBfbWVzc2FnZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBtZXNzYWdlcyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBtZXNzYWdlcywgX21lc3NhZ2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIG5ldyBWYWxpZGV0dGEodGhpcywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH07XG59KShqUXVlcnkpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG52YXIgZyA9XG4gICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCkgfHxcbiAge31cblxudmFyIHN1cHBvcnQgPSB7XG4gIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gZyxcbiAgaXRlcmFibGU6ICdTeW1ib2wnIGluIGcgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gIGJsb2I6XG4gICAgJ0ZpbGVSZWFkZXInIGluIGcgJiZcbiAgICAnQmxvYicgaW4gZyAmJlxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gZyxcbiAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gZ1xufVxuXG5mdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbn1cblxuaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gIF1cblxuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgfVxuICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5eX2B8fiFdL2kudGVzdChuYW1lKSB8fCBuYW1lID09PSAnJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiJylcbiAgfVxuICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG5mdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvclxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gIHRoaXMubWFwID0ge31cblxuICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIGlmIChoZWFkZXIubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGVhZGVycyBjb25zdHJ1Y3RvcjogZXhwZWN0ZWQgbmFtZS92YWx1ZSBwYWlyIHRvIGJlIGxlbmd0aCAyLCBmb3VuZCcgKyBoZWFkZXIubGVuZ3RoKVxuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgIH0sIHRoaXMpXG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgJywgJyArIHZhbHVlIDogdmFsdWVcbn1cblxuSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgfVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChuYW1lKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpdGVtcy5wdXNoKHZhbHVlKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbmlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgaWYgKGJvZHkuX25vQm9keSkgcmV0dXJuXG4gIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICB9XG4gIGJvZHkuYm9keVVzZWQgPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICB9XG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgdmFyIG1hdGNoID0gL2NoYXJzZXQ9KFtBLVphLXowLTlfLV0rKS8uZXhlYyhibG9iLnR5cGUpXG4gIHZhciBlbmNvZGluZyA9IG1hdGNoID8gbWF0Y2hbMV0gOiAndXRmLTgnXG4gIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IsIGVuY29kaW5nKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gIH1cbiAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICB9IGVsc2Uge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBCb2R5KCkge1xuICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAvKlxuICAgICAgZmV0Y2gtbW9jayB3cmFwcyB0aGUgUmVzcG9uc2Ugb2JqZWN0IGluIGFuIEVTNiBQcm94eSB0b1xuICAgICAgcHJvdmlkZSB1c2VmdWwgdGVzdCBoYXJuZXNzIGZlYXR1cmVzIHN1Y2ggYXMgZmx1c2guIEhvd2V2ZXIsIG9uXG4gICAgICBFUzUgYnJvd3NlcnMgd2l0aG91dCBmZXRjaCBvciBQcm94eSBzdXBwb3J0IHBvbGx5ZmlsbHMgbXVzdCBiZSB1c2VkO1xuICAgICAgdGhlIHByb3h5LXBvbGx5ZmlsbCBpcyB1bmFibGUgdG8gcHJveHkgYW4gYXR0cmlidXRlIHVubGVzcyBpdCBleGlzdHNcbiAgICAgIG9uIHRoZSBvYmplY3QgYmVmb3JlIHRoZSBQcm94eSBpcyBjcmVhdGVkLiBUaGlzIGNoYW5nZSBlbnN1cmVzXG4gICAgICBSZXNwb25zZS5ib2R5VXNlZCBleGlzdHMgb24gdGhlIGluc3RhbmNlLCB3aGlsZSBtYWludGFpbmluZyB0aGVcbiAgICAgIHNlbWFudGljIG9mIHNldHRpbmcgUmVxdWVzdC5ib2R5VXNlZCBpbiB0aGUgY29uc3RydWN0b3IgYmVmb3JlXG4gICAgICBfaW5pdEJvZHkgaXMgY2FsbGVkLlxuICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgdGhpcy5ib2R5VXNlZCA9IHRoaXMuYm9keVVzZWRcbiAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHRoaXMuX25vQm9keSA9IHRydWU7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JylcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGlzQ29uc3VtZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKGlzQ29uc3VtZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29uc3VtZWRcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnVmZmVyLnNsaWNlKFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCArIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIGFzIEFycmF5QnVmZmVyJylcbiAgICB9XG4gIH1cblxuICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICB9XG4gIH1cblxuICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG52YXIgbWV0aG9kcyA9IFsnQ09OTkVDVCcsICdERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQQVRDSCcsICdQT1NUJywgJ1BVVCcsICdUUkFDRSddXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICByZXR1cm4gbWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEgPyB1cGNhc2VkIDogbWV0aG9kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICB9XG4gICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWxcbiAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgfVxuXG4gIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJ1xuICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIH1cbiAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdBYm9ydENvbnRyb2xsZXInIGluIGcpIHtcbiAgICAgIHZhciBjdHJsID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgcmV0dXJuIGN0cmwuc2lnbmFsO1xuICAgIH1cbiAgfSgpKTtcbiAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICB9XG4gIHRoaXMuX2luaXRCb2R5KGJvZHkpXG5cbiAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgaWYgKG9wdGlvbnMuY2FjaGUgPT09ICduby1zdG9yZScgfHwgb3B0aW9ucy5jYWNoZSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgLy8gU2VhcmNoIGZvciBhICdfJyBwYXJhbWV0ZXIgaW4gdGhlIHF1ZXJ5IHN0cmluZ1xuICAgICAgdmFyIHJlUGFyYW1TZWFyY2ggPSAvKFs/Jl0pXz1bXiZdKi9cbiAgICAgIGlmIChyZVBhcmFtU2VhcmNoLnRlc3QodGhpcy51cmwpKSB7XG4gICAgICAgIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzIHRoZW4gc2V0IHRoZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5yZXBsYWNlKHJlUGFyYW1TZWFyY2gsICckMV89JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBhIG5ldyAnXycgcGFyYW1ldGVyIHRvIHRoZSBlbmQgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHZhciByZVF1ZXJ5U3RyaW5nID0gL1xcPy9cbiAgICAgICAgdGhpcy51cmwgKz0gKHJlUXVlcnlTdHJpbmcudGVzdCh0aGlzLnVybCkgPyAnJicgOiAnPycpICsgJ189JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxufVxuXG5mdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gIGJvZHlcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KCcmJylcbiAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGZvcm1cbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJylcbiAgLy8gQXZvaWRpbmcgc3BsaXQgdmlhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgY29tbW9uIElFMTEgYnVnIHdpdGggdGhlIGNvcmUtanMgMy42LjAgcmVnZXggcG9seWZpbGxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaC9pc3N1ZXMvNzQ4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy83NTFcbiAgcHJlUHJvY2Vzc2VkSGVhZGVyc1xuICAgIC5zcGxpdCgnXFxyJylcbiAgICAubWFwKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgcmV0dXJuIGhlYWRlci5pbmRleE9mKCdcXG4nKSA9PT0gMCA/IGhlYWRlci5zdWJzdHIoMSwgaGVhZGVyLmxlbmd0aCkgOiBoZWFkZXJcbiAgICB9KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignUmVzcG9uc2UgJyArIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gaGVhZGVyc1xufVxuXG5Cb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbmV4cG9ydCBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzXG4gIGlmICh0aGlzLnN0YXR1cyA8IDIwMCB8fCB0aGlzLnN0YXR1cyA+IDU5OSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzcG9uc2UnOiBUaGUgc3RhdHVzIHByb3ZpZGVkICgwKSBpcyBvdXRzaWRlIHRoZSByYW5nZSBbMjAwLCA1OTldLlwiKVxuICB9XG4gIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0ID09PSB1bmRlZmluZWQgPyAnJyA6ICcnICsgb3B0aW9ucy5zdGF0dXNUZXh0XG4gIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbn1cblxuQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgIHVybDogdGhpcy51cmxcbiAgfSlcbn1cblxuUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDIwMCwgc3RhdHVzVGV4dDogJyd9KVxuICByZXNwb25zZS5vayA9IGZhbHNlXG4gIHJlc3BvbnNlLnN0YXR1cyA9IDBcbiAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbnZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG5SZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbn1cblxuZXhwb3J0IHZhciBET01FeGNlcHRpb24gPSBnLkRPTUV4Y2VwdGlvblxudHJ5IHtcbiAgbmV3IERPTUV4Y2VwdGlvbigpXG59IGNhdGNoIChlcnIpIHtcbiAgRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSlcbiAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2tcbiAgfVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBET01FeGNlcHRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgIHhoci5hYm9ydCgpXG4gICAgfVxuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgfVxuICAgICAgLy8gVGhpcyBjaGVjayBpZiBzcGVjaWZpY2FsbHkgZm9yIHdoZW4gYSB1c2VyIGZldGNoZXMgYSBmaWxlIGxvY2FsbHkgZnJvbSB0aGUgZmlsZSBzeXN0ZW1cbiAgICAgIC8vIE9ubHkgaWYgdGhlIHN0YXR1cyBpcyBvdXQgb2YgYSBub3JtYWwgcmFuZ2VcbiAgICAgIGlmIChyZXF1ZXN0LnVybC5pbmRleE9mKCdmaWxlOi8vJykgPT09IDAgJiYgKHhoci5zdGF0dXMgPCAyMDAgfHwgeGhyLnN0YXR1cyA+IDU5OSkpIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSAyMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpXG4gICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IHRpbWVkIG91dCcpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhVcmwodXJsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXJsID09PSAnJyAmJiBnLmxvY2F0aW9uLmhyZWYgPyBnLmxvY2F0aW9uLmhyZWYgOiB1cmxcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCBmaXhVcmwocmVxdWVzdC51cmwpLCB0cnVlKVxuXG4gICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhocikge1xuICAgICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBzdXBwb3J0LmFycmF5QnVmZmVyXG4gICAgICApIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5pdCAmJiB0eXBlb2YgaW5pdC5oZWFkZXJzID09PSAnb2JqZWN0JyAmJiAhKGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgfHwgKGcuSGVhZGVycyAmJiBpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBnLkhlYWRlcnMpKSkge1xuICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbml0LmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBuYW1lcy5wdXNoKG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG5vcm1hbGl6ZVZhbHVlKGluaXQuaGVhZGVyc1tuYW1lXSkpXG4gICAgICB9KVxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG5cbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgfSlcbn1cblxuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG5cbmlmICghZy5mZXRjaCkge1xuICBnLmZldGNoID0gZmV0Y2hcbiAgZy5IZWFkZXJzID0gSGVhZGVyc1xuICBnLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIGcuUmVzcG9uc2UgPSBSZXNwb25zZVxufVxuIiwiLyohIHplcm8tZmlsbC4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyoqXG4gKiBHaXZlbiBhIG51bWJlciwgcmV0dXJuIGEgemVyby1maWxsZWQgc3RyaW5nLlxuICogRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNjcyODMvXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG51bWJlclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHplcm9GaWxsICh3aWR0aCwgbnVtYmVyLCBwYWQpIHtcbiAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChudW1iZXIsIHBhZCkge1xuICAgICAgcmV0dXJuIHplcm9GaWxsKHdpZHRoLCBudW1iZXIsIHBhZClcbiAgICB9XG4gIH1cbiAgaWYgKHBhZCA9PT0gdW5kZWZpbmVkKSBwYWQgPSAnMCdcbiAgd2lkdGggLT0gbnVtYmVyLnRvU3RyaW5nKCkubGVuZ3RoXG4gIGlmICh3aWR0aCA+IDApIHJldHVybiBuZXcgQXJyYXkod2lkdGggKyAoL1xcLi8udGVzdChudW1iZXIpID8gMiA6IDEpKS5qb2luKHBhZCkgKyBudW1iZXJcbiAgcmV0dXJuIG51bWJlciArICcnXG59XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKipcbiAqIENyZWF0ZXMgYSBjb250aW51YXRpb24gZnVuY3Rpb24gd2l0aCBzb21lIGFyZ3VtZW50cyBhbHJlYWR5IGFwcGxpZWQuXG4gKlxuICogVXNlZnVsIGFzIGEgc2hvcnRoYW5kIHdoZW4gY29tYmluZWQgd2l0aCBvdGhlciBjb250cm9sIGZsb3cgZnVuY3Rpb25zLiBBbnlcbiAqIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uIGFyZSBhZGRlZCB0byB0aGUgYXJndW1lbnRzXG4gKiBvcmlnaW5hbGx5IHBhc3NlZCB0byBhcHBseS5cbiAqXG4gKiBAbmFtZSBhcHBseVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHkgYWxsXG4gKiBhcmd1bWVudHMgdG8uIEludm9rZXMgd2l0aCAoYXJndW1lbnRzLi4uKS5cbiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXV0b21hdGljYWxseSBhcHBseVxuICogd2hlbiB0aGUgY29udGludWF0aW9uIGlzIGNhbGxlZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdGhlIHBhcnRpYWxseS1hcHBsaWVkIGZ1bmN0aW9uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIHVzaW5nIGFwcGx5XG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgYXN5bmMuYXBwbHkoZnMud3JpdGVGaWxlLCAndGVzdGZpbGUxJywgJ3Rlc3QxJyksXG4gKiAgICAgYXN5bmMuYXBwbHkoZnMud3JpdGVGaWxlLCAndGVzdGZpbGUyJywgJ3Rlc3QyJylcbiAqIF0pO1xuICpcbiAqXG4gKiAvLyB0aGUgc2FtZSBwcm9jZXNzIHdpdGhvdXQgdXNpbmcgYXBwbHlcbiAqIGFzeW5jLnBhcmFsbGVsKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMScsICd0ZXN0MScsIGNhbGxiYWNrKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGZzLndyaXRlRmlsZSgndGVzdGZpbGUyJywgJ3Rlc3QyJywgY2FsbGJhY2spO1xuICogICAgIH1cbiAqIF0pO1xuICpcbiAqIC8vIEl0J3MgcG9zc2libGUgdG8gcGFzcyBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHdoZW4gY2FsbGluZyB0aGVcbiAqIC8vIGNvbnRpbnVhdGlvbjpcbiAqXG4gKiBub2RlPiB2YXIgZm4gPSBhc3luYy5hcHBseShzeXMucHV0cywgJ29uZScpO1xuICogbm9kZT4gZm4oJ3R3bycsICd0aHJlZScpO1xuICogb25lXG4gKiB0d29cbiAqIHRocmVlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuICguLi5jYWxsQXJncykgPT4gZm4oLi4uYXJncywuLi5jYWxsQXJncyk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxQYXJhbXMgKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzLyosIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYXJncywgY2FsbGJhY2spO1xuICAgIH07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5cbnZhciBoYXNRdWV1ZU1pY3JvdGFzayA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJyAmJiBxdWV1ZU1pY3JvdGFzaztcbnZhciBoYXNTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIHNldEltbWVkaWF0ZTtcbnZhciBoYXNOZXh0VGljayA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gZmFsbGJhY2soZm4pIHtcbiAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZnVuY3Rpb24gd3JhcChkZWZlcikge1xuICAgIHJldHVybiAoZm4sIC4uLmFyZ3MpID0+IGRlZmVyKCgpID0+IGZuKC4uLmFyZ3MpKTtcbn1cblxudmFyIF9kZWZlciQxO1xuXG5pZiAoaGFzUXVldWVNaWNyb3Rhc2spIHtcbiAgICBfZGVmZXIkMSA9IHF1ZXVlTWljcm90YXNrO1xufSBlbHNlIGlmIChoYXNTZXRJbW1lZGlhdGUpIHtcbiAgICBfZGVmZXIkMSA9IHNldEltbWVkaWF0ZTtcbn0gZWxzZSBpZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIkMSA9IHByb2Nlc3MubmV4dFRpY2s7XG59IGVsc2Uge1xuICAgIF9kZWZlciQxID0gZmFsbGJhY2s7XG59XG5cbnZhciBzZXRJbW1lZGlhdGUkMSA9IHdyYXAoX2RlZmVyJDEpO1xuXG4vKipcbiAqIFRha2UgYSBzeW5jIGZ1bmN0aW9uIGFuZCBtYWtlIGl0IGFzeW5jLCBwYXNzaW5nIGl0cyByZXR1cm4gdmFsdWUgdG8gYVxuICogY2FsbGJhY2suIFRoaXMgaXMgdXNlZnVsIGZvciBwbHVnZ2luZyBzeW5jIGZ1bmN0aW9ucyBpbnRvIGEgd2F0ZXJmYWxsLFxuICogc2VyaWVzLCBvciBvdGhlciBhc3luYyBmdW5jdGlvbnMuIEFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIChleGNlcHQgZm9yIHRoZSBmaW5hbFxuICogY2FsbGJhY2sgYXJndW1lbnQpLiBFcnJvcnMgdGhyb3duIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBhc3luY2lmeWAgcmV0dXJucyBhIFByb21pc2UsIHRoYXQgcHJvbWlzZXMnc1xuICogcmVzb2x2ZWQvcmVqZWN0ZWQgc3RhdGUgd2lsbCBiZSB1c2VkIHRvIGNhbGwgdGhlIGNhbGxiYWNrLCByYXRoZXIgdGhhbiBzaW1wbHlcbiAqIHRoZSBzeW5jaHJvbm91cyByZXR1cm4gdmFsdWUuXG4gKlxuICogVGhpcyBhbHNvIG1lYW5zIHlvdSBjYW4gYXN5bmNpZnkgRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25zLlxuICpcbiAqIEBuYW1lIGFzeW5jaWZ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgd3JhcFN5bmNcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9uLCBvciBQcm9taXNlLXJldHVybmluZ1xuICogZnVuY3Rpb24gdG8gY29udmVydCB0byBhbiB7QGxpbmsgQXN5bmNGdW5jdGlvbn0uXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gQW4gYXN5bmNocm9ub3VzIHdyYXBwZXIgb2YgdGhlIGBmdW5jYC4gVG8gYmVcbiAqIGludm9rZWQgd2l0aCBgKGFyZ3MuLi4sIGNhbGxiYWNrKWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIHBhc3NpbmcgYSByZWd1bGFyIHN5bmNocm9ub3VzIGZ1bmN0aW9uXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCBmaWxlbmFtZSwgXCJ1dGY4XCIpLFxuICogICAgIGFzeW5jLmFzeW5jaWZ5KEpTT04ucGFyc2UpLFxuICogICAgIGZ1bmN0aW9uIChkYXRhLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGRhdGEgaXMgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSB0ZXh0LlxuICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwYXJzaW5nIGVycm9yLCBpdCB3b3VsZCBoYXZlIGJlZW4gY2F1Z2h0LlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBwYXNzaW5nIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcHJvbWlzZVxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBhc3luYy5hc3luY2lmeShmdW5jdGlvbiAoY29udGVudHMpIHtcbiAqICAgICAgICAgcmV0dXJuIGRiLm1vZGVsLmNyZWF0ZShjb250ZW50cyk7XG4gKiAgICAgfSksXG4gKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGBtb2RlbGAgaXMgdGhlIGluc3RhbnRpYXRlZCBtb2RlbCBvYmplY3QuXG4gKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgdGhpcyBmdW5jdGlvbiB3b3VsZCBiZSBza2lwcGVkLlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBlczIwMTcgZXhhbXBsZSwgdGhvdWdoIGBhc3luY2lmeWAgaXMgbm90IG5lZWRlZCBpZiB5b3VyIEpTIGVudmlyb25tZW50XG4gKiAvLyBzdXBwb3J0cyBhc3luYyBmdW5jdGlvbnMgb3V0IG9mIHRoZSBib3hcbiAqIHZhciBxID0gYXN5bmMucXVldWUoYXN5bmMuYXN5bmNpZnkoYXN5bmMgZnVuY3Rpb24oZmlsZSkge1xuICogICAgIHZhciBpbnRlcm1lZGlhdGVTdGVwID0gYXdhaXQgcHJvY2Vzc0ZpbGUoZmlsZSk7XG4gKiAgICAgcmV0dXJuIGF3YWl0IHNvbWVQcm9taXNlKGludGVybWVkaWF0ZVN0ZXApXG4gKiB9KSk7XG4gKlxuICogcS5wdXNoKGZpbGVzKTtcbiAqL1xuZnVuY3Rpb24gYXN5bmNpZnkoZnVuYykge1xuICAgIGlmIChpc0FzeW5jKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncy8qLCBjYWxsYmFjayovKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQcm9taXNlKHByb21pc2UsIGNhbGxiYWNrKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgcmVzdWx0IGlzIFByb21pc2Ugb2JqZWN0XG4gICAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUHJvbWlzZShyZXN1bHQsIGNhbGxiYWNrKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQcm9taXNlKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBudWxsLCB2YWx1ZSk7XG4gICAgfSwgZXJyID0+IHtcbiAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIGVyciAmJiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyLm1lc3NhZ2UpID8gZXJyIDogbmV3IEVycm9yKGVycikpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgZXJyb3IsIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlJDEoZSA9PiB7IHRocm93IGUgfSwgZXJyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQXN5bmMoZm4pIHtcbiAgICByZXR1cm4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0dlbmVyYXRvcic7XG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHdyYXBBc3luYyhhc3luY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBhc3luY0ZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGEgZnVuY3Rpb24nKVxuICAgIHJldHVybiBpc0FzeW5jKGFzeW5jRm4pID8gYXN5bmNpZnkoYXN5bmNGbikgOiBhc3luY0ZuO1xufVxuXG4vLyBjb25kaXRpb25hbGx5IHByb21pc2lmeSBhIGZ1bmN0aW9uLlxuLy8gb25seSByZXR1cm4gYSBwcm9taXNlIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuZnVuY3Rpb24gYXdhaXRpZnkgKGFzeW5jRm4sIGFyaXR5KSB7XG4gICAgaWYgKCFhcml0eSkgYXJpdHkgPSBhc3luY0ZuLmxlbmd0aDtcbiAgICBpZiAoIWFyaXR5KSB0aHJvdyBuZXcgRXJyb3IoJ2FyaXR5IGlzIHVuZGVmaW5lZCcpXG4gICAgZnVuY3Rpb24gYXdhaXRhYmxlICguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1thcml0eSAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNGbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGFyZ3NbYXJpdHkgLSAxXSA9IChlcnIsIC4uLmNiQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICAgICAgICAgIHJlc29sdmUoY2JBcmdzLmxlbmd0aCA+IDEgPyBjYkFyZ3MgOiBjYkFyZ3NbMF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0YWJsZVxufVxuXG5mdW5jdGlvbiBhcHBseUVhY2gkMSAoZWFjaGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5RWFjaChmbnMsIC4uLmNhbGxBcmdzKSB7XG4gICAgICAgIGNvbnN0IGdvID0gYXdhaXRpZnkoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgKGZuLCBjYikgPT4ge1xuICAgICAgICAgICAgICAgIHdyYXBBc3luYyhmbikuYXBwbHkodGhhdCwgY2FsbEFyZ3MuY29uY2F0KGNiKSk7XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ287XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX2FzeW5jTWFwKGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBhcnIgPSBhcnIgfHwgW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG5cbiAgICByZXR1cm4gZWFjaGZuKGFyciwgKHZhbHVlLCBfLCBpdGVyQ2IpID0+IHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICBfaXRlcmF0ZWUodmFsdWUsIChlcnIsIHYpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdjtcbiAgICAgICAgICAgIGl0ZXJDYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZS5sZW5ndGggPj0gMCAmJlxuICAgICAgICB2YWx1ZS5sZW5ndGggJSAxID09PSAwO1xufVxuXG4vLyBBIHRlbXBvcmFyeSB2YWx1ZSB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBsb29wIHNob3VsZCBiZSBicm9rZW4uXG4vLyBTZWUgIzEwNjQsICMxMjkzXG5jb25zdCBicmVha0xvb3AgPSB7fTtcblxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGZ1bmN0aW9uIHdyYXBwZXIgKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGZuID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIHZhciBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlciwgZm4pO1xuICAgIHJldHVybiB3cmFwcGVyXG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yIChjb2xsKSB7XG4gICAgcmV0dXJuIGNvbGxbU3ltYm9sLml0ZXJhdG9yXSAmJiBjb2xsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gY29sbC5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiArK2kgPCBsZW4gPyB7dmFsdWU6IGNvbGxbaV0sIGtleTogaX0gOiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZW0uZG9uZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IGl0ZW0udmFsdWUsIGtleTogaX07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RJdGVyYXRvcihvYmopIHtcbiAgICB2YXIgb2tleXMgPSBvYmogPyBPYmplY3Qua2V5cyhvYmopIDogW107XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gb2tleXMubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIga2V5ID0gb2tleXNbKytpXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyB7dmFsdWU6IG9ialtrZXldLCBrZXl9IDogbnVsbDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihjb2xsKSB7XG4gICAgaWYgKGlzQXJyYXlMaWtlKGNvbGwpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpO1xuICAgIH1cblxuICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGwpO1xuICAgIHJldHVybiBpdGVyYXRvciA/IGNyZWF0ZUVTMjAxNUl0ZXJhdG9yKGl0ZXJhdG9yKSA6IGNyZWF0ZU9iamVjdEl0ZXJhdG9yKGNvbGwpO1xufVxuXG5mdW5jdGlvbiBvbmx5T25jZShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgIHZhciBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbn1cblxuLy8gZm9yIGFzeW5jIGdlbmVyYXRvcnNcbmZ1bmN0aW9uIGFzeW5jRWFjaE9mTGltaXQoZ2VuZXJhdG9yLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBsZXQgYXdhaXRpbmcgPSBmYWxzZTtcbiAgICBsZXQgcnVubmluZyA9IDA7XG4gICAgbGV0IGlkeCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZXBsZW5pc2goKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3JlcGxlbmlzaCcpXG4gICAgICAgIGlmIChydW5uaW5nID49IGxpbWl0IHx8IGF3YWl0aW5nIHx8IGRvbmUpIHJldHVyblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXBsZW5pc2ggYXdhaXRpbmcnKVxuICAgICAgICBhd2FpdGluZyA9IHRydWU7XG4gICAgICAgIGdlbmVyYXRvci5uZXh0KCkudGhlbigoe3ZhbHVlLCBkb25lOiBpdGVyRG9uZX0pID0+IHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2dvdCB2YWx1ZScsIHZhbHVlKVxuICAgICAgICAgICAgaWYgKGNhbmNlbGVkIHx8IGRvbmUpIHJldHVyblxuICAgICAgICAgICAgYXdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpdGVyRG9uZSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG9uZSBuZXh0Q2InKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVubmluZysrO1xuICAgICAgICAgICAgaXRlcmF0ZWUodmFsdWUsIGlkeCwgaXRlcmF0ZWVDYWxsYmFjayk7XG4gICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICB9KS5jYXRjaChoYW5kbGVFcnJvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWVDYWxsYmFjayhlcnIsIHJlc3VsdCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdpdGVyYXRlZUNhbGxiYWNrJylcbiAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICBpZiAoY2FuY2VsZWQpIHJldHVyblxuICAgICAgICBpZiAoZXJyKSByZXR1cm4gaGFuZGxlRXJyb3IoZXJyKVxuXG4gICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gYnJlYWtMb29wIHx8IChkb25lICYmIHJ1bm5pbmcgPD0gMCkpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG9uZSBpdGVyQ2InKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxlbmlzaCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgICAgICBpZiAoY2FuY2VsZWQpIHJldHVyblxuICAgICAgICBhd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICByZXBsZW5pc2goKTtcbn1cblxudmFyIGVhY2hPZkxpbWl0JDIgPSAobGltaXQpID0+IHtcbiAgICByZXR1cm4gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignY29uY3VycmVuY3kgbGltaXQgY2Fubm90IGJlIGxlc3MgdGhhbiAxJylcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FzeW5jR2VuZXJhdG9yKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luY0VhY2hPZkxpbWl0KG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBc3luY0l0ZXJhYmxlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luY0VhY2hPZkxpbWl0KG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dEVsZW0gPSBjcmVhdGVJdGVyYXRvcihvYmopO1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuICAgICAgICB2YXIgbG9vcGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVlQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm5cbiAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBicmVha0xvb3AgfHwgKGRvbmUgJiYgcnVubmluZyA8PSAwKSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFsb29waW5nKSB7XG4gICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgbG9vcGluZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmICFkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBuZXh0RWxlbSgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZShlbGVtLnZhbHVlLCBlbGVtLmtleSwgb25seU9uY2UoaXRlcmF0ZWVDYWxsYmFjaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9vcGluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaE9mTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn1cbiAqIEBhbGlhcyBmb3JFYWNoT2ZMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2hcbiAqIGl0ZW0gaW4gYGNvbGxgLiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuXG4gKiBhcnJheS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGVhY2hPZkxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZWFjaE9mTGltaXQkMihsaW1pdCkoY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xufVxuXG52YXIgZWFjaE9mTGltaXQkMSA9IGF3YWl0aWZ5KGVhY2hPZkxpbWl0LCA0KTtcblxuLy8gZWFjaE9mIGltcGxlbWVudGF0aW9uIG9wdGltaXplZCBmb3IgYXJyYXktbGlrZXNcbmZ1bmN0aW9uIGVhY2hPZkFycmF5TGlrZShjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgIGNvbXBsZXRlZCA9IDAsXG4gICAgICAgIHtsZW5ndGh9ID0gY29sbCxcbiAgICAgICAgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5jZWxlZCA9PT0gdHJ1ZSkgcmV0dXJuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAoKCsrY29tcGxldGVkID09PSBsZW5ndGgpIHx8IHZhbHVlID09PSBicmVha0xvb3ApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKGNvbGxbaW5kZXhdLCBpbmRleCwgb25seU9uY2UoaXRlcmF0b3JDYWxsYmFjaykpO1xuICAgIH1cbn1cblxuLy8gYSBnZW5lcmljIHZlcnNpb24gb2YgZWFjaE9mIHdoaWNoIGNhbiBoYW5kbGUgYXJyYXksIG9iamVjdCwgYW5kIGl0ZXJhdG9yIGNhc2VzLlxuZnVuY3Rpb24gZWFjaE9mR2VuZXJpYyAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGVhY2hPZkxpbWl0JDEoY29sbCwgSW5maW5pdHksIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogTGlrZSBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0sIGV4Y2VwdCB0aGF0IGl0IHBhc3NlcyB0aGUga2V5IChvciBpbmRleCkgYXMgdGhlIHNlY29uZCBhcmd1bWVudFxuICogdG8gdGhlIGl0ZXJhdGVlLlxuICpcbiAqIEBuYW1lIGVhY2hPZlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGZvckVhY2hPZlxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXkuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBkZXYuanNvbiBpcyBhIGZpbGUgY29udGFpbmluZyBhIHZhbGlkIGpzb24gb2JqZWN0IGNvbmZpZyBmb3IgZGV2IGVudmlyb25tZW50XG4gKiAvLyBkZXYuanNvbiBpcyBhIGZpbGUgY29udGFpbmluZyBhIHZhbGlkIGpzb24gb2JqZWN0IGNvbmZpZyBmb3IgdGVzdCBlbnZpcm9ubWVudFxuICogLy8gcHJvZC5qc29uIGlzIGEgZmlsZSBjb250YWluaW5nIGEgdmFsaWQganNvbiBvYmplY3QgY29uZmlnIGZvciBwcm9kIGVudmlyb25tZW50XG4gKiAvLyBpbnZhbGlkLmpzb24gaXMgYSBmaWxlIHdpdGggYSBtYWxmb3JtZWQganNvbiBvYmplY3RcbiAqXG4gKiBsZXQgY29uZmlncyA9IHt9OyAvL2dsb2JhbCB2YXJpYWJsZVxuICogbGV0IHZhbGlkQ29uZmlnRmlsZU1hcCA9IHtkZXY6ICdkZXYuanNvbicsIHRlc3Q6ICd0ZXN0Lmpzb24nLCBwcm9kOiAncHJvZC5qc29uJ307XG4gKiBsZXQgaW52YWxpZENvbmZpZ0ZpbGVNYXAgPSB7ZGV2OiAnZGV2Lmpzb24nLCB0ZXN0OiAndGVzdC5qc29uJywgaW52YWxpZDogJ2ludmFsaWQuanNvbid9O1xuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHJlYWRzIGEganNvbiBmaWxlIGFuZCBwYXJzZXMgdGhlIGNvbnRlbnRzIGFzIGpzb24gb2JqZWN0XG4gKiBmdW5jdGlvbiBwYXJzZUZpbGUoZmlsZSwga2V5LCBjYWxsYmFjaykge1xuICogICAgIGZzLnJlYWRGaWxlKGZpbGUsIFwidXRmOFwiLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAqICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGJhY2soZXJyKTtcbiAqICAgICAgICAgdHJ5IHtcbiAqICAgICAgICAgICAgIGNvbmZpZ3Nba2V5XSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gKiAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBjYWxsYmFjaygpO1xuICogICAgIH0pO1xuICogfVxuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMuZm9yRWFjaE9mKHZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlLCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gKiAgICAgICAgIC8vIGNvbmZpZ3MgaXMgbm93IGEgbWFwIG9mIEpTT04gZGF0YSwgZS5nLlxuICogICAgICAgICAvLyB7IGRldjogLy9wYXJzZWQgZGV2Lmpzb24sIHRlc3Q6IC8vcGFyc2VkIHRlc3QuanNvbiwgcHJvZDogLy9wYXJzZWQgcHJvZC5qc29ufVxuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vRXJyb3IgaGFuZGluZ1xuICogYXN5bmMuZm9yRWFjaE9mKGludmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAqICAgICAgICAgLy8gSlNPTiBwYXJzZSBlcnJvciBleGNlcHRpb25cbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhjb25maWdzKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuZm9yRWFjaE9mKHZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlKVxuICogLnRoZW4oICgpID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhjb25maWdzKTtcbiAqICAgICAvLyBjb25maWdzIGlzIG5vdyBhIG1hcCBvZiBKU09OIGRhdGEsIGUuZy5cbiAqICAgICAvLyB7IGRldjogLy9wYXJzZWQgZGV2Lmpzb24sIHRlc3Q6IC8vcGFyc2VkIHRlc3QuanNvbiwgcHJvZDogLy9wYXJzZWQgcHJvZC5qc29ufVxuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICogfSk7XG4gKlxuICogLy9FcnJvciBoYW5kaW5nXG4gKiBhc3luYy5mb3JFYWNoT2YoaW52YWxpZENvbmZpZ0ZpbGVNYXAsIHBhcnNlRmlsZSlcbiAqIC50aGVuKCAoKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gKiAgICAgLy8gSlNPTiBwYXJzZSBlcnJvciBleGNlcHRpb25cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLmZvckVhY2hPZih2YWxpZENvbmZpZ0ZpbGVNYXAsIHBhcnNlRmlsZSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGNvbmZpZ3MpO1xuICogICAgICAgICAvLyBjb25maWdzIGlzIG5vdyBhIG1hcCBvZiBKU09OIGRhdGEsIGUuZy5cbiAqICAgICAgICAgLy8geyBkZXY6IC8vcGFyc2VkIGRldi5qc29uLCB0ZXN0OiAvL3BhcnNlZCB0ZXN0Lmpzb24sIHByb2Q6IC8vcGFyc2VkIHByb2QuanNvbn1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiAvL0Vycm9yIGhhbmRpbmdcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZm9yRWFjaE9mKGludmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhjb25maWdzKTtcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICAvLyBKU09OIHBhcnNlIGVycm9yIGV4Y2VwdGlvblxuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGVhY2hPZihjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZWFjaE9mSW1wbGVtZW50YXRpb24gPSBpc0FycmF5TGlrZShjb2xsKSA/IGVhY2hPZkFycmF5TGlrZSA6IGVhY2hPZkdlbmVyaWM7XG4gICAgcmV0dXJuIGVhY2hPZkltcGxlbWVudGF0aW9uKGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTtcbn1cblxudmFyIGVhY2hPZiQxID0gYXdhaXRpZnkoZWFjaE9mLCAzKTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhIG5ldyBjb2xsZWN0aW9uIG9mIHZhbHVlcyBieSBtYXBwaW5nIGVhY2ggdmFsdWUgaW4gYGNvbGxgIHRocm91Z2hcbiAqIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCBhbiBpdGVtIGZyb20gYGNvbGxgXG4gKiBhbmQgYSBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja3NcbiAqIHRha2VzIDIgYXJndW1lbnRzOiBhbiBgZXJyb3JgLCBhbmQgdGhlIHRyYW5zZm9ybWVkIGl0ZW0gZnJvbSBgY29sbGAuIElmXG4gKiBgaXRlcmF0ZWVgIHBhc3NlcyBhbiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgKGZvciB0aGVcbiAqIGBtYXBgIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKlxuICogTm90ZSwgdGhhdCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgdGhlIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluXG4gKiBwYXJhbGxlbCwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIHdpbGwgY29tcGxldGVcbiAqIGluIG9yZGVyLiBIb3dldmVyLCB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuICogb3JpZ2luYWwgYGNvbGxgLlxuICpcbiAqIElmIGBtYXBgIGlzIHBhc3NlZCBhbiBPYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgYW4gQXJyYXkuICBUaGUgcmVzdWx0c1xuICogd2lsbCByb3VnaGx5IGJlIGluIHRoZSBvcmRlciBvZiB0aGUgb3JpZ2luYWwgT2JqZWN0cycga2V5cyAoYnV0IHRoaXMgY2FuXG4gKiB2YXJ5IGFjcm9zcyBKYXZhU2NyaXB0IGVuZ2luZXMpLlxuICpcbiAqIEBuYW1lIG1hcFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBBcnJheSBvZiB0aGVcbiAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGZpbGUxLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAxMDAwIGJ5dGVzIGluIHNpemVcbiAqIC8vIGZpbGUyLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAyMDAwIGJ5dGVzIGluIHNpemVcbiAqIC8vIGZpbGUzLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAzMDAwIGJ5dGVzIGluIHNpemVcbiAqIC8vIGZpbGU0LnR4dCBkb2VzIG5vdCBleGlzdFxuICpcbiAqIGNvbnN0IGZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlMy50eHQnXTtcbiAqIGNvbnN0IHdpdGhNaXNzaW5nRmlsZUxpc3QgPSBbJ2ZpbGUxLnR4dCcsJ2ZpbGUyLnR4dCcsJ2ZpbGU0LnR4dCddO1xuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpbGUgc2l6ZSBpbiBieXRlc1xuICogZnVuY3Rpb24gZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdC5zaXplKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLm1hcChmaWxlTGlzdCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICogICAgICAgICAvLyBbIDEwMDAsIDIwMDAsIDMwMDBdXG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLm1hcCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBnZXRGaWxlU2l6ZUluQnl0ZXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMubWFwKGZpbGVMaXN0LCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gKiAudGhlbiggcmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgYW4gYXJyYXkgb2YgdGhlIGZpbGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaCBmaWxlLCBlLmcuXG4gKiAgICAgLy8gWyAxMDAwLCAyMDAwLCAzMDAwXVxuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYy5tYXAod2l0aE1pc3NpbmdGaWxlTGlzdCwgZ2V0RmlsZVNpemVJbkJ5dGVzKVxuICogLnRoZW4oIHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLm1hcChmaWxlTGlzdCwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICogICAgICAgICAvLyBbIDEwMDAsIDIwMDAsIDMwMDBdXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLm1hcCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBnZXRGaWxlU2l6ZUluQnl0ZXMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIG1hcCAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9hc3luY01hcChlYWNoT2YkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIG1hcCQxID0gYXdhaXRpZnkobWFwLCAzKTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgdG8gZWFjaCBmdW5jdGlvbiBpbiB0aGUgYXJyYXksIGNhbGxpbmdcbiAqIGBjYWxsYmFja2AgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gSWYgeW91IG9ubHkgcHJvdmlkZSB0aGUgZmlyc3RcbiAqIGFyZ3VtZW50LCBgZm5zYCwgdGhlbiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlXG4gKiBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsLiBJZiBtb3JlIGFyZ3VtZW50cyBhcmVcbiAqIHByb3ZpZGVkLCBgY2FsbGJhY2tgIGlzIHJlcXVpcmVkIHdoaWxlIGBhcmdzYCBpcyBzdGlsbCBvcHRpb25hbC4gVGhlIHJlc3VsdHNcbiAqIGZvciBlYWNoIG9mIHRoZSBhcHBsaWVkIGFzeW5jIGZ1bmN0aW9ucyBhcmUgcGFzc2VkIHRvIHRoZSBmaW5hbCBjYWxsYmFja1xuICogYXMgYW4gYXJyYXkuXG4gKlxuICogQG5hbWUgYXBwbHlFYWNoXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259c1xuICogdG8gYWxsIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLFxuICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IC0gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm8gYXJncyBvdGhlciB0aGFuXG4gKiBhbiBvcHRpb25hbCBjYWxsYmFjaywgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBgYXJnc2AgdG8gZWFjaFxuICogb2YgdGhlIGZ1bmN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKlxuICogY29uc3QgYXBwbGllZEZuID0gYXN5bmMuYXBwbHlFYWNoKFtlbmFibGVTZWFyY2gsIHVwZGF0ZVNjaGVtYV0sICdidWNrZXQnKVxuICpcbiAqIGFwcGxpZWRGbigoZXJyLCByZXN1bHRzKSA9PiB7XG4gKiAgICAgLy8gcmVzdWx0c1swXSBpcyB0aGUgcmVzdWx0cyBmb3IgYGVuYWJsZVNlYXJjaGBcbiAqICAgICAvLyByZXN1bHRzWzFdIGlzIHRoZSByZXN1bHRzIGZvciBgdXBkYXRlU2NoZW1hYFxuICogfSk7XG4gKlxuICogLy8gcGFydGlhbCBhcHBsaWNhdGlvbiBleGFtcGxlOlxuICogYXN5bmMuZWFjaChcbiAqICAgICBidWNrZXRzLFxuICogICAgIGFzeW5jIChidWNrZXQpID0+IGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdLCBidWNrZXQpKCksXG4gKiAgICAgY2FsbGJhY2tcbiAqICk7XG4gKi9cbnZhciBhcHBseUVhY2ggPSBhcHBseUVhY2gkMShtYXAkMSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaE9mU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9XG4gKiBAYWxpYXMgZm9yRWFjaE9mU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICovXG5mdW5jdGlvbiBlYWNoT2ZTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGVhY2hPZkxpbWl0JDEoY29sbCwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGVhY2hPZlNlcmllcyQxID0gYXdhaXRpZnkoZWFjaE9mU2VyaWVzLCAzKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBtYXBTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH1cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkgb2YgdGhlXG4gKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBtYXBTZXJpZXMgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfYXN5bmNNYXAoZWFjaE9mU2VyaWVzJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBtYXBTZXJpZXMkMSA9IGF3YWl0aWZ5KG1hcFNlcmllcywgMyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BhcHBseUVhY2hgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXBwbHlFYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgYXBwbHlFYWNoU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5hcHBseUVhY2hde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259cyB0byBhbGxcbiAqIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLFxuICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IC0gQSBmdW5jdGlvbiwgdGhhdCB3aGVuIGNhbGxlZCwgaXMgdGhlIHJlc3VsdCBvZlxuICogYXBwbGluZyB0aGUgYGFyZ3NgIHRvIHRoZSBsaXN0IG9mIGZ1bmN0aW9ucy4gIEl0IHRha2VzIG5vIGFyZ3MsIG90aGVyIHRoYW5cbiAqIGEgY2FsbGJhY2suXG4gKi9cbnZhciBhcHBseUVhY2hTZXJpZXMgPSBhcHBseUVhY2gkMShtYXBTZXJpZXMkMSk7XG5cbmNvbnN0IFBST01JU0VfU1lNQk9MID0gU3ltYm9sKCdwcm9taXNlQ2FsbGJhY2snKTtcblxuZnVuY3Rpb24gcHJvbWlzZUNhbGxiYWNrICgpIHtcbiAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0O1xuICAgIGZ1bmN0aW9uIGNhbGxiYWNrIChlcnIsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIHJlc29sdmUoYXJncy5sZW5ndGggPiAxID8gYXJncyA6IGFyZ3NbMF0pO1xuICAgIH1cblxuICAgIGNhbGxiYWNrW1BST01JU0VfU1lNQk9MXSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzLFxuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2tcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBiZXN0IG9yZGVyIGZvciBydW5uaW5nIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGluIGB0YXNrc2AsIGJhc2VkIG9uXG4gKiB0aGVpciByZXF1aXJlbWVudHMuIEVhY2ggZnVuY3Rpb24gY2FuIG9wdGlvbmFsbHkgZGVwZW5kIG9uIG90aGVyIGZ1bmN0aW9uc1xuICogYmVpbmcgY29tcGxldGVkIGZpcnN0LCBhbmQgZWFjaCBmdW5jdGlvbiBpcyBydW4gYXMgc29vbiBhcyBpdHMgcmVxdWlyZW1lbnRzXG4gKiBhcmUgc2F0aXNmaWVkLlxuICpcbiAqIElmIGFueSBvZiB0aGUge0BsaW5rIEFzeW5jRnVuY3Rpb259cyBwYXNzIGFuIGVycm9yIHRvIHRoZWlyIGNhbGxiYWNrLCB0aGUgYGF1dG9gIHNlcXVlbmNlXG4gKiB3aWxsIHN0b3AuIEZ1cnRoZXIgdGFza3Mgd2lsbCBub3QgZXhlY3V0ZSAoc28gYW55IG90aGVyIGZ1bmN0aW9ucyBkZXBlbmRpbmdcbiAqIG9uIGl0IHdpbGwgbm90IHJ1biksIGFuZCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZVxuICogZXJyb3IuXG4gKlxuICoge0BsaW5rIEFzeW5jRnVuY3Rpb259cyBhbHNvIHJlY2VpdmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgb2YgZnVuY3Rpb25zIHdoaWNoXG4gKiBoYXZlIGNvbXBsZXRlZCBzbyBmYXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiB0aGV5IGhhdmUgZGVwZW5kZW5jaWVzLiBJZiBhXG4gKiB0YXNrIGZ1bmN0aW9uIGhhcyBubyBkZXBlbmRlbmNpZXMsIGl0IHdpbGwgb25seSBiZSBwYXNzZWQgYSBjYWxsYmFjay5cbiAqXG4gKiBAbmFtZSBhdXRvXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge09iamVjdH0gdGFza3MgLSBBbiBvYmplY3QuIEVhY2ggb2YgaXRzIHByb3BlcnRpZXMgaXMgZWl0aGVyIGFcbiAqIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHJlcXVpcmVtZW50cywgd2l0aCB0aGUge0BsaW5rIEFzeW5jRnVuY3Rpb259IGl0c2VsZiB0aGUgbGFzdCBpdGVtXG4gKiBpbiB0aGUgYXJyYXkuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eSBzZXJ2ZXMgYXMgdGhlIG5hbWUgb2YgdGhlIHRhc2tcbiAqIGRlZmluZWQgYnkgdGhhdCBwcm9wZXJ0eSwgaS5lLiBjYW4gYmUgdXNlZCB3aGVuIHNwZWNpZnlpbmcgcmVxdWlyZW1lbnRzIGZvclxuICogb3RoZXIgdGFza3MuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBvbmUgb3IgdHdvIGFyZ3VtZW50czpcbiAqICogYSBgcmVzdWx0c2Agb2JqZWN0LCBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91c2x5IGV4ZWN1dGVkXG4gKiAgIGZ1bmN0aW9ucywgb25seSBwYXNzZWQgaWYgdGhlIHRhc2sgaGFzIGFueSBkZXBlbmRlbmNpZXMsXG4gKiAqIGEgYGNhbGxiYWNrKGVyciwgcmVzdWx0KWAgZnVuY3Rpb24sIHdoaWNoIG11c3QgYmUgY2FsbGVkIHdoZW4gZmluaXNoZWQsXG4gKiAgIHBhc3NpbmcgYW4gYGVycm9yYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uJ3NcbiAqICAgZXhlY3V0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yXG4gKiBkZXRlcm1pbmluZyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGFza3MgdGhhdCBjYW4gYmUgcnVuIGluIHBhcmFsbGVsLiBCeVxuICogZGVmYXVsdCwgYXMgbWFueSBhcyBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIHRoZSB0YXNrcyBoYXZlIGJlZW4gY29tcGxldGVkLiBJdCByZWNlaXZlcyB0aGUgYGVycmAgYXJndW1lbnQgaWYgYW55IGB0YXNrc2BcbiAqIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2suIFJlc3VsdHMgYXJlIGFsd2F5cyByZXR1cm5lZDsgaG93ZXZlciwgaWYgYW5cbiAqIGVycm9yIG9jY3Vycywgbm8gZnVydGhlciBgdGFza3NgIHdpbGwgYmUgcGVyZm9ybWVkLCBhbmQgdGhlIHJlc3VsdHMgb2JqZWN0XG4gKiB3aWxsIG9ubHkgY29udGFpbiBwYXJ0aWFsIHJlc3VsdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgbm90IHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvL1VzaW5nIENhbGxiYWNrc1xuICogYXN5bmMuYXV0byh7XG4gKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gZ2V0IHNvbWUgZGF0YVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknKTtcbiAqICAgICB9LFxuICogICAgIG1ha2VfZm9sZGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0byBzdG9yZSBhIGZpbGUgaW5cbiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTtcbiAqICAgICB9LFxuICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsXG4gKiAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgIH1dLFxuICogICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgeydmaWxlJzpyZXN1bHRzLndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7XG4gKiAgICAgfV1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ2VyciA9ICcsIGVycik7XG4gKiAgICAgfVxuICogICAgIGNvbnNvbGUubG9nKCdyZXN1bHRzID0gJywgcmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyA9IHtcbiAqICAgICAvLyAgICAgZ2V0X2RhdGE6IFsnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknXVxuICogICAgIC8vICAgICBtYWtlX2ZvbGRlcjsgJ2ZvbGRlcicsXG4gKiAgICAgLy8gICAgIHdyaXRlX2ZpbGU6ICdmaWxlbmFtZSdcbiAqICAgICAvLyAgICAgZW1haWxfbGluazogeyBmaWxlOiAnZmlsZW5hbWUnLCBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nIH1cbiAqICAgICAvLyB9XG4gKiB9KTtcbiAqXG4gKiAvL1VzaW5nIFByb21pc2VzXG4gKiBhc3luYy5hdXRvKHtcbiAqICAgICBnZXRfZGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ2luIGdldF9kYXRhJyk7XG4gKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gZ2V0IHNvbWUgZGF0YVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknKTtcbiAqICAgICB9LFxuICogICAgIG1ha2VfZm9sZGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gbWFrZV9mb2xkZXInKTtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluXG4gKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZm9sZGVyJyk7XG4gKiAgICAgfSxcbiAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gb25jZSB0aGVyZSBpcyBzb21lIGRhdGEgYW5kIHRoZSBkaXJlY3RvcnkgZXhpc3RzLFxuICogICAgICAgICAvLyB3cml0ZSB0aGUgZGF0YSB0byBhIGZpbGUgaW4gdGhlIGRpcmVjdG9yeVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAqICAgICB9XSxcbiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6cmVzdWx0cy53cml0ZV9maWxlLCAnZW1haWwnOid1c2VyQGV4YW1wbGUuY29tJ30pO1xuICogICAgIH1dXG4gKiB9KS50aGVuKHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdyZXN1bHRzID0gJywgcmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyA9IHtcbiAqICAgICAvLyAgICAgZ2V0X2RhdGE6IFsnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknXVxuICogICAgIC8vICAgICBtYWtlX2ZvbGRlcjsgJ2ZvbGRlcicsXG4gKiAgICAgLy8gICAgIHdyaXRlX2ZpbGU6ICdmaWxlbmFtZSdcbiAqICAgICAvLyAgICAgZW1haWxfbGluazogeyBmaWxlOiAnZmlsZW5hbWUnLCBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nIH1cbiAqICAgICAvLyB9XG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpO1xuICogfSk7XG4gKlxuICogLy9Vc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMuYXV0byh7XG4gKiAgICAgICAgICAgICBnZXRfZGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGdldCBzb21lIGRhdGFcbiAqICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnZGF0YScsICdjb252ZXJ0ZWQgdG8gYXJyYXknKTtcbiAqICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgICBtYWtlX2ZvbGRlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0byBzdG9yZSBhIGZpbGUgaW5cbiAqICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHJ1biBhdCB0aGUgc2FtZSB0aW1lIGFzIGdldHRpbmcgdGhlIGRhdGFcbiAqICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnZm9sZGVyJyk7XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgd3JpdGVfZmlsZTogWydnZXRfZGF0YScsICdtYWtlX2ZvbGRlcicsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgLy8gb25jZSB0aGVyZSBpcyBzb21lIGRhdGEgYW5kIHRoZSBkaXJlY3RvcnkgZXhpc3RzLFxuICogICAgICAgICAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZpbGVuYW1lJyk7XG4gKiAgICAgICAgICAgICB9XSxcbiAqICAgICAgICAgICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgLy8gb25jZSB0aGUgZmlsZSBpcyB3cml0dGVuIGxldCdzIGVtYWlsIGEgbGluayB0byBpdC4uLlxuICogICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6cmVzdWx0cy53cml0ZV9maWxlLCAnZW1haWwnOid1c2VyQGV4YW1wbGUuY29tJ30pO1xuICogICAgICAgICAgICAgfV1cbiAqICAgICAgICAgfSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdyZXN1bHRzID0gJywgcmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgPSB7XG4gKiAgICAgICAgIC8vICAgICBnZXRfZGF0YTogWydkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheSddXG4gKiAgICAgICAgIC8vICAgICBtYWtlX2ZvbGRlcjsgJ2ZvbGRlcicsXG4gKiAgICAgICAgIC8vICAgICB3cml0ZV9maWxlOiAnZmlsZW5hbWUnXG4gKiAgICAgICAgIC8vICAgICBlbWFpbF9saW5rOiB7IGZpbGU6ICdmaWxlbmFtZScsIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScgfVxuICogICAgICAgICAvLyB9XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBhdXRvKHRhc2tzLCBjb25jdXJyZW5jeSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBjb25jdXJyZW5jeSBpcyBvcHRpb25hbCwgc2hpZnQgdGhlIGFyZ3MuXG4gICAgICAgIGNhbGxiYWNrID0gY29uY3VycmVuY3k7XG4gICAgICAgIGNvbmN1cnJlbmN5ID0gbnVsbDtcbiAgICB9XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IHByb21pc2VDYWxsYmFjaygpKTtcbiAgICB2YXIgbnVtVGFza3MgPSBPYmplY3Qua2V5cyh0YXNrcykubGVuZ3RoO1xuICAgIGlmICghbnVtVGFza3MpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICBpZiAoIWNvbmN1cnJlbmN5KSB7XG4gICAgICAgIGNvbmN1cnJlbmN5ID0gbnVtVGFza3M7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICB2YXIgcnVubmluZ1Rhc2tzID0gMDtcbiAgICB2YXIgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB2YXIgaGFzRXJyb3IgPSBmYWxzZTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdmFyIHJlYWR5VGFza3MgPSBbXTtcblxuICAgIC8vIGZvciBjeWNsZSBkZXRlY3Rpb246XG4gICAgdmFyIHJlYWR5VG9DaGVjayA9IFtdOyAvLyB0YXNrcyB0aGF0IGhhdmUgYmVlbiBpZGVudGlmaWVkIGFzIHJlYWNoYWJsZVxuICAgIC8vIHdpdGhvdXQgdGhlIHBvc3NpYmlsaXR5IG9mIHJldHVybmluZyB0byBhbiBhbmNlc3RvciB0YXNrXG4gICAgdmFyIHVuY2hlY2tlZERlcGVuZGVuY2llcyA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXModGFza3MpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgdmFyIHRhc2sgPSB0YXNrc1trZXldO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFzaykpIHtcbiAgICAgICAgICAgIC8vIG5vIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCBbdGFza10pO1xuICAgICAgICAgICAgcmVhZHlUb0NoZWNrLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSB0YXNrLnNsaWNlKDAsIHRhc2subGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciByZW1haW5pbmdEZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuICAgICAgICBpZiAocmVtYWluaW5nRGVwZW5kZW5jaWVzID09PSAwKSB7XG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhrZXksIHRhc2spO1xuICAgICAgICAgICAgcmVhZHlUb0NoZWNrLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bmNoZWNrZWREZXBlbmRlbmNpZXNba2V5XSA9IHJlbWFpbmluZ0RlcGVuZGVuY2llcztcblxuICAgICAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaChkZXBlbmRlbmN5TmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRhc2tzW2RlcGVuZGVuY3lOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXN5bmMuYXV0byB0YXNrIGAnICsga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgJ2AgaGFzIGEgbm9uLWV4aXN0ZW50IGRlcGVuZGVuY3kgYCcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TmFtZSArICdgIGluICcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuam9pbignLCAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihkZXBlbmRlbmN5TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0RlcGVuZGVuY2llcy0tO1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjaGVja0ZvckRlYWRsb2NrcygpO1xuICAgIHByb2Nlc3NRdWV1ZSgpO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2soa2V5LCB0YXNrKSB7XG4gICAgICAgIHJlYWR5VGFza3MucHVzaCgoKSA9PiBydW5UYXNrKGtleSwgdGFzaykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm5cbiAgICAgICAgaWYgKHJlYWR5VGFza3MubGVuZ3RoID09PSAwICYmIHJ1bm5pbmdUYXNrcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHJlYWR5VGFza3MubGVuZ3RoICYmIHJ1bm5pbmdUYXNrcyA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICB2YXIgcnVuID0gcmVhZHlUYXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgcnVuKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhc2tOYW1lLCBmbikge1xuICAgICAgICB2YXIgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV07XG4gICAgICAgIGlmICghdGFza0xpc3RlbmVycykge1xuICAgICAgICAgICAgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhc2tMaXN0ZW5lcnMucHVzaChmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXSB8fCBbXTtcbiAgICAgICAgdGFza0xpc3RlbmVycy5mb3JFYWNoKGZuID0+IGZuKCkpO1xuICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHJ1blRhc2soa2V5LCB0YXNrKSB7XG4gICAgICAgIGlmIChoYXNFcnJvcikgcmV0dXJuO1xuXG4gICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBvbmx5T25jZSgoZXJyLCAuLi5yZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJ1bm5pbmdUYXNrcy0tO1xuICAgICAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBbcmVzdWx0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZXN1bHRzKS5mb3JFYWNoKHJrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHJlc3VsdHNbcmtleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsZWQpIHJldHVyblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGFza0NvbXBsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJ1bm5pbmdUYXNrcysrO1xuICAgICAgICB2YXIgdGFza0ZuID0gd3JhcEFzeW5jKHRhc2tbdGFzay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0YXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRhc2tGbihyZXN1bHRzLCB0YXNrQ2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFza0ZuKHRhc2tDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0ZvckRlYWRsb2NrcygpIHtcbiAgICAgICAgLy8gS2FobidzIGFsZ29yaXRobVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub3BvbG9naWNhbF9zb3J0aW5nI0thaG4uMjdzX2FsZ29yaXRobVxuICAgICAgICAvLyBodHRwOi8vY29ubmFsbGUuYmxvZ3Nwb3QuY29tLzIwMTMvMTAvdG9wb2xvZ2ljYWwtc29ydGluZ2thaG4tYWxnb3JpdGhtLmh0bWxcbiAgICAgICAgdmFyIGN1cnJlbnRUYXNrO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIHdoaWxlIChyZWFkeVRvQ2hlY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50VGFzayA9IHJlYWR5VG9DaGVjay5wb3AoKTtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgIGdldERlcGVuZGVudHMoY3VycmVudFRhc2spLmZvckVhY2goZGVwZW5kZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoLS11bmNoZWNrZWREZXBlbmRlbmNpZXNbZGVwZW5kZW50XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWFkeVRvQ2hlY2sucHVzaChkZXBlbmRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvdW50ZXIgIT09IG51bVRhc2tzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2FzeW5jLmF1dG8gY2Fubm90IGV4ZWN1dGUgdGFza3MgZHVlIHRvIGEgcmVjdXJzaXZlIGRlcGVuZGVuY3knXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGVwZW5kZW50cyh0YXNrTmFtZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHRhc2tzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gdGFza3Nba2V5XTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhc2spICYmIHRhc2suaW5kZXhPZih0YXNrTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFja1tQUk9NSVNFX1NZTUJPTF1cbn1cblxudmFyIEZOX0FSR1MgPSAvXig/OmFzeW5jXFxzKT8oPzpmdW5jdGlvbik/XFxzKig/OlxcdytcXHMqKT9cXCgoW14pXSspXFwpKD86XFxzKnspLztcbnZhciBBUlJPV19GTl9BUkdTID0gL14oPzphc3luY1xccyk/XFxzKig/OlxcKFxccyopPygoPzpbXik9XFxzXVxccyopKikoPzpcXClcXHMqKT89Pi87XG52YXIgRk5fQVJHX1NQTElUID0gLywvO1xudmFyIEZOX0FSRyA9IC8oPS4rKT8oXFxzKikkLztcblxuZnVuY3Rpb24gc3RyaXBDb21tZW50cyhzdHJpbmcpIHtcbiAgICBsZXQgc3RyaXBwZWQgPSAnJztcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBlbmRCbG9ja0NvbW1lbnQgPSBzdHJpbmcuaW5kZXhPZignKi8nKTtcbiAgICB3aGlsZSAoaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJpbmdbaW5kZXhdID09PSAnLycgJiYgc3RyaW5nW2luZGV4KzFdID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIGlubGluZSBjb21tZW50XG4gICAgICAgICAgICBsZXQgZW5kSW5kZXggPSBzdHJpbmcuaW5kZXhPZignXFxuJywgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggPSAoZW5kSW5kZXggPT09IC0xKSA/IHN0cmluZy5sZW5ndGggOiBlbmRJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmICgoZW5kQmxvY2tDb21tZW50ICE9PSAtMSkgJiYgKHN0cmluZ1tpbmRleF0gPT09ICcvJykgJiYgKHN0cmluZ1tpbmRleCsxXSA9PT0gJyonKSkge1xuICAgICAgICAgICAgLy8gYmxvY2sgY29tbWVudFxuICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gc3RyaW5nLmluZGV4T2YoJyovJywgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGVuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZW5kSW5kZXggKyAyO1xuICAgICAgICAgICAgICAgIGVuZEJsb2NrQ29tbWVudCA9IHN0cmluZy5pbmRleE9mKCcqLycsIGluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaXBwZWQgKz0gc3RyaW5nW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaXBwZWQgKz0gc3RyaW5nW2luZGV4XTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmlwcGVkO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhcmFtcyhmdW5jKSB7XG4gICAgY29uc3Qgc3JjID0gc3RyaXBDb21tZW50cyhmdW5jLnRvU3RyaW5nKCkpO1xuICAgIGxldCBtYXRjaCA9IHNyYy5tYXRjaChGTl9BUkdTKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIG1hdGNoID0gc3JjLm1hdGNoKEFSUk9XX0ZOX0FSR1MpO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBwYXJzZSBhcmdzIGluIGF1dG9JbmplY3RcXG5Tb3VyY2U6XFxuJyArIHNyYylcbiAgICBsZXQgWywgYXJnc10gPSBtYXRjaDtcbiAgICByZXR1cm4gYXJnc1xuICAgICAgICAucmVwbGFjZSgvXFxzL2csICcnKVxuICAgICAgICAuc3BsaXQoRk5fQVJHX1NQTElUKVxuICAgICAgICAubWFwKChhcmcpID0+IGFyZy5yZXBsYWNlKEZOX0FSRywgJycpLnRyaW0oKSk7XG59XG5cbi8qKlxuICogQSBkZXBlbmRlbmN5LWluamVjdGVkIHZlcnNpb24gb2YgdGhlIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30gZnVuY3Rpb24uIERlcGVuZGVudFxuICogdGFza3MgYXJlIHNwZWNpZmllZCBhcyBwYXJhbWV0ZXJzIHRvIHRoZSBmdW5jdGlvbiwgYWZ0ZXIgdGhlIHVzdWFsIGNhbGxiYWNrXG4gKiBwYXJhbWV0ZXIsIHdpdGggdGhlIHBhcmFtZXRlciBuYW1lcyBtYXRjaGluZyB0aGUgbmFtZXMgb2YgdGhlIHRhc2tzIGl0XG4gKiBkZXBlbmRzIG9uLiBUaGlzIGNhbiBwcm92aWRlIGV2ZW4gbW9yZSByZWFkYWJsZSB0YXNrIGdyYXBocyB3aGljaCBjYW4gYmVcbiAqIGVhc2llciB0byBtYWludGFpbi5cbiAqXG4gKiBJZiBhIGZpbmFsIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgdGhlIHRhc2sgcmVzdWx0cyBhcmUgc2ltaWxhcmx5IGluamVjdGVkLFxuICogc3BlY2lmaWVkIGFzIG5hbWVkIHBhcmFtZXRlcnMgYWZ0ZXIgdGhlIGluaXRpYWwgZXJyb3IgcGFyYW1ldGVyLlxuICpcbiAqIFRoZSBhdXRvSW5qZWN0IGZ1bmN0aW9uIGlzIHB1cmVseSBzeW50YWN0aWMgc3VnYXIgYW5kIGl0cyBzZW1hbnRpY3MgYXJlXG4gKiBvdGhlcndpc2UgZXF1aXZhbGVudCB0byBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99LlxuICpcbiAqIEBuYW1lIGF1dG9JbmplY3RcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmF1dG9de0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtPYmplY3R9IHRhc2tzIC0gQW4gb2JqZWN0LCBlYWNoIG9mIHdob3NlIHByb3BlcnRpZXMgaXMgYW4ge0BsaW5rIEFzeW5jRnVuY3Rpb259IG9mXG4gKiB0aGUgZm9ybSAnZnVuYyhbZGVwZW5kZW5jaWVzLi4uXSwgY2FsbGJhY2spLiBUaGUgb2JqZWN0J3Mga2V5IG9mIGEgcHJvcGVydHlcbiAqIHNlcnZlcyBhcyB0aGUgbmFtZSBvZiB0aGUgdGFzayBkZWZpbmVkIGJ5IHRoYXQgcHJvcGVydHksIGkuZS4gY2FuIGJlIHVzZWRcbiAqIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yIG90aGVyIHRhc2tzLlxuICogKiBUaGUgYGNhbGxiYWNrYCBwYXJhbWV0ZXIgaXMgYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCB3aGljaCBtdXN0IGJlIGNhbGxlZFxuICogICB3aGVuIGZpbmlzaGVkLCBwYXNzaW5nIGFuIGBlcnJvcmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCB0aGUgcmVzdWx0IG9mXG4gKiAgIHRoZSBmdW5jdGlvbidzIGV4ZWN1dGlvbi4gVGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzIG5hbWUgb3RoZXIgdGFza3Mgb25cbiAqICAgd2hpY2ggdGhlIHRhc2sgaXMgZGVwZW5kZW50LCBhbmQgdGhlIHJlc3VsdHMgZnJvbSB0aG9zZSB0YXNrcyBhcmUgdGhlXG4gKiAgIGFyZ3VtZW50cyBvZiB0aG9zZSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogdGhlIHRhc2tzIGhhdmUgYmVlbiBjb21wbGV0ZWQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYCBhcmd1bWVudCBpZiBhbnkgYHRhc2tzYFxuICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjaywgYW5kIGEgYHJlc3VsdHNgIG9iamVjdCB3aXRoIGFueSBjb21wbGV0ZWRcbiAqIHRhc2sgcmVzdWx0cywgc2ltaWxhciB0byBgYXV0b2AuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gIFRoZSBleGFtcGxlIGZyb20gYGF1dG9gIGNhbiBiZSByZXdyaXR0ZW4gYXMgZm9sbG93czpcbiAqIGFzeW5jLmF1dG9JbmplY3Qoe1xuICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGdldCBzb21lIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gKiAgICAgfSxcbiAqICAgICBtYWtlX2ZvbGRlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluXG4gKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZm9sZGVyJyk7XG4gKiAgICAgfSxcbiAqICAgICB3cml0ZV9maWxlOiBmdW5jdGlvbihnZXRfZGF0YSwgbWFrZV9mb2xkZXIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cyxcbiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnlcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZpbGVuYW1lJyk7XG4gKiAgICAgfSxcbiAqICAgICBlbWFpbF9saW5rOiBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gKiAgICAgICAgIC8vIHdyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygnZW1haWxfbGluayA9ICcsIHJlc3VsdHMuZW1haWxfbGluayk7XG4gKiB9KTtcbiAqXG4gKiAvLyBJZiB5b3UgYXJlIHVzaW5nIGEgSlMgbWluaWZpZXIgdGhhdCBtYW5nbGVzIHBhcmFtZXRlciBuYW1lcywgYGF1dG9JbmplY3RgXG4gKiAvLyB3aWxsIG5vdCB3b3JrIHdpdGggcGxhaW4gZnVuY3Rpb25zLCBzaW5jZSB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGwgYmVcbiAqIC8vIGNvbGxhcHNlZCB0byBhIHNpbmdsZSBsZXR0ZXIgaWRlbnRpZmllci4gIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHlvdSBjYW5cbiAqIC8vIGV4cGxpY2l0bHkgc3BlY2lmeSB0aGUgbmFtZXMgb2YgdGhlIHBhcmFtZXRlcnMgeW91ciB0YXNrIGZ1bmN0aW9uIG5lZWRzXG4gKiAvLyBpbiBhbiBhcnJheSwgc2ltaWxhciB0byBBbmd1bGFyLmpzIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIC8vIFRoaXMgc3RpbGwgaGFzIGFuIGFkdmFudGFnZSBvdmVyIHBsYWluIGBhdXRvYCwgc2luY2UgdGhlIHJlc3VsdHMgYSB0YXNrXG4gKiAvLyBkZXBlbmRzIG9uIGFyZSBzdGlsbCBzcHJlYWQgaW50byBhcmd1bWVudHMuXG4gKiBhc3luYy5hdXRvSW5qZWN0KHtcbiAqICAgICAvLy4uLlxuICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihnZXRfZGF0YSwgbWFrZV9mb2xkZXIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgIH1dLFxuICogICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHdyaXRlX2ZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XVxuICogICAgIC8vLi4uXG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygnZW1haWxfbGluayA9ICcsIHJlc3VsdHMuZW1haWxfbGluayk7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gYXV0b0luamVjdCh0YXNrcywgY2FsbGJhY2spIHtcbiAgICB2YXIgbmV3VGFza3MgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKHRhc2tzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHZhciB0YXNrRm4gPSB0YXNrc1trZXldO1xuICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICB2YXIgZm5Jc0FzeW5jID0gaXNBc3luYyh0YXNrRm4pO1xuICAgICAgICB2YXIgaGFzTm9EZXBzID1cbiAgICAgICAgICAgICghZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDEpIHx8XG4gICAgICAgICAgICAoZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDApO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhc2tGbikpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFsuLi50YXNrRm5dO1xuICAgICAgICAgICAgdGFza0ZuID0gcGFyYW1zLnBvcCgpO1xuXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChwYXJhbXMubGVuZ3RoID4gMCA/IG5ld1Rhc2sgOiB0YXNrRm4pO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc05vRGVwcykge1xuICAgICAgICAgICAgLy8gbm8gZGVwZW5kZW5jaWVzLCB1c2UgdGhlIGZ1bmN0aW9uIGFzLWlzXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gdGFza0ZuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXModGFza0ZuKTtcbiAgICAgICAgICAgIGlmICgodGFza0ZuLmxlbmd0aCA9PT0gMCAmJiAhZm5Jc0FzeW5jKSAmJiBwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXV0b0luamVjdCB0YXNrIGZ1bmN0aW9ucyByZXF1aXJlIGV4cGxpY2l0IHBhcmFtZXRlcnMuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZW1vdmUgY2FsbGJhY2sgcGFyYW1cbiAgICAgICAgICAgIGlmICghZm5Jc0FzeW5jKSBwYXJhbXMucG9wKCk7XG5cbiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSBwYXJhbXMuY29uY2F0KG5ld1Rhc2spO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbmV3VGFzayhyZXN1bHRzLCB0YXNrQ2IpIHtcbiAgICAgICAgICAgIHZhciBuZXdBcmdzID0gcGFyYW1zLm1hcChuYW1lID0+IHJlc3VsdHNbbmFtZV0pO1xuICAgICAgICAgICAgbmV3QXJncy5wdXNoKHRhc2tDYik7XG4gICAgICAgICAgICB3cmFwQXN5bmModGFza0ZuKSguLi5uZXdBcmdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF1dG8obmV3VGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLy8gU2ltcGxlIGRvdWJseSBsaW5rZWQgbGlzdCAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Ymx5X2xpbmtlZF9saXN0KSBpbXBsZW1lbnRhdGlvblxuLy8gdXNlZCBmb3IgcXVldWVzLiBUaGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhhdCB0aGUgbm9kZSBwcm92aWRlZCBieSB0aGUgdXNlciBjYW4gYmUgbW9kaWZpZWRcbi8vIHRvIGFkanVzdCB0aGUgbmV4dCBhbmQgbGFzdCBwcm9wZXJ0aWVzLiBXZSBpbXBsZW1lbnQgb25seSB0aGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5XG4vLyBmb3IgcXVldWUgc3VwcG9ydC5cbmNsYXNzIERMTCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICByZW1vdmVMaW5rKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgIGVsc2UgdGhpcy5oZWFkID0gbm9kZS5uZXh0O1xuICAgICAgICBpZiAobm9kZS5uZXh0KSBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgZWxzZSB0aGlzLnRhaWwgPSBub2RlLnByZXY7XG5cbiAgICAgICAgbm9kZS5wcmV2ID0gbm9kZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZW5ndGggLT0gMTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZW1wdHkgKCkge1xuICAgICAgICB3aGlsZSh0aGlzLmhlYWQpIHRoaXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5zZXJ0QWZ0ZXIobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICBuZXdOb2RlLnByZXYgPSBub2RlO1xuICAgICAgICBuZXdOb2RlLm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbmV3Tm9kZTtcbiAgICAgICAgZWxzZSB0aGlzLnRhaWwgPSBuZXdOb2RlO1xuICAgICAgICBub2RlLm5leHQgPSBuZXdOb2RlO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSAxO1xuICAgIH1cblxuICAgIGluc2VydEJlZm9yZShub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIG5ld05vZGUucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgbmV3Tm9kZS5uZXh0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IG5ld05vZGU7XG4gICAgICAgIG5vZGUucHJldiA9IG5ld05vZGU7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDE7XG4gICAgfVxuXG4gICAgdW5zaGlmdChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQpIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCwgbm9kZSk7XG4gICAgICAgIGVsc2Ugc2V0SW5pdGlhbCh0aGlzLCBub2RlKTtcbiAgICB9XG5cbiAgICBwdXNoKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGFpbCkgdGhpcy5pbnNlcnRBZnRlcih0aGlzLnRhaWwsIG5vZGUpO1xuICAgICAgICBlbHNlIHNldEluaXRpYWwodGhpcywgbm9kZSk7XG4gICAgfVxuXG4gICAgc2hpZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQgJiYgdGhpcy5yZW1vdmVMaW5rKHRoaXMuaGVhZCk7XG4gICAgfVxuXG4gICAgcG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWlsICYmIHRoaXMucmVtb3ZlTGluayh0aGlzLnRhaWwpO1xuICAgIH1cblxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpc11cbiAgICB9XG5cbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgICB2YXIgY3VyID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoY3VyKSB7XG4gICAgICAgICAgICB5aWVsZCBjdXIuZGF0YTtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlICh0ZXN0Rm4pIHtcbiAgICAgICAgdmFyIGN1cnIgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlKGN1cnIpIHtcbiAgICAgICAgICAgIHZhciB7bmV4dH0gPSBjdXJyO1xuICAgICAgICAgICAgaWYgKHRlc3RGbihjdXJyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGluayhjdXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnIgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbChkbGwsIG5vZGUpIHtcbiAgICBkbGwubGVuZ3RoID0gMTtcbiAgICBkbGwuaGVhZCA9IGRsbC50YWlsID0gbm9kZTtcbn1cblxuZnVuY3Rpb24gcXVldWUkMSh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKSB7XG4gICAgaWYgKGNvbmN1cnJlbmN5ID09IG51bGwpIHtcbiAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmKGNvbmN1cnJlbmN5ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb25jdXJyZW5jeSBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgfVxuXG4gICAgdmFyIF93b3JrZXIgPSB3cmFwQXN5bmMod29ya2VyKTtcbiAgICB2YXIgbnVtUnVubmluZyA9IDA7XG4gICAgdmFyIHdvcmtlcnNMaXN0ID0gW107XG4gICAgY29uc3QgZXZlbnRzID0ge1xuICAgICAgICBlcnJvcjogW10sXG4gICAgICAgIGRyYWluOiBbXSxcbiAgICAgICAgc2F0dXJhdGVkOiBbXSxcbiAgICAgICAgdW5zYXR1cmF0ZWQ6IFtdLFxuICAgICAgICBlbXB0eTogW11cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIGV2ZW50c1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNlIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBoYW5kbGVBbmRSZW1vdmUgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgb2ZmKGV2ZW50LCBoYW5kbGVBbmRSZW1vdmUpO1xuICAgICAgICAgICAgaGFuZGxlciguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnRzW2V2ZW50XS5wdXNoKGhhbmRsZUFuZFJlbW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2ZmIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICBpZiAoIWV2ZW50KSByZXR1cm4gT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKGV2ID0+IGV2ZW50c1tldl0gPSBbXSlcbiAgICAgICAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZXZlbnRzW2V2ZW50XSA9IFtdXG4gICAgICAgIGV2ZW50c1tldmVudF0gPSBldmVudHNbZXZlbnRdLmZpbHRlcihldiA9PiBldiAhPT0gaGFuZGxlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlciAoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgZXZlbnRzW2V2ZW50XS5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlciguLi5hcmdzKSk7XG4gICAgfVxuXG4gICAgdmFyIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBfaW5zZXJ0KGRhdGEsIGluc2VydEF0RnJvbnQsIHJlamVjdE9uRXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXNrIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIHJlcywgcmVqO1xuICAgICAgICBmdW5jdGlvbiBwcm9taXNlQ2FsbGJhY2sgKGVyciwgLi4uYXJncykge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgZXJyb3IsIGxldCB0aGUgZ2xvYmFsIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIC8vIGRlYWwgd2l0aCBpdFxuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdE9uRXJyb3IgPyByZWooZXJyKSA6IHJlcygpXG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkgcmV0dXJuIHJlcyhhcmdzWzBdKVxuICAgICAgICAgICAgcmVzKGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW0gPSBxLl9jcmVhdGVUYXNrSXRlbShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZWplY3RPbkVycm9yID8gcHJvbWlzZUNhbGxiYWNrIDpcbiAgICAgICAgICAgICAgICAoY2FsbGJhY2sgfHwgcHJvbWlzZUNhbGxiYWNrKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpbnNlcnRBdEZyb250KSB7XG4gICAgICAgICAgICBxLl90YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvY2Vzc2luZ1NjaGVkdWxlZCkge1xuICAgICAgICAgICAgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUkMSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVqZWN0T25FcnJvciB8fCAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICByZWogPSByZWplY3Q7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUNCKHRhc2tzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBudW1SdW5uaW5nIC09IDE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFza3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHdvcmtlcnNMaXN0LmluZGV4T2YodGFzayk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrKGVyciwgLi4uYXJncyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcignZXJyb3InLCBlcnIsIHRhc2suZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtUnVubmluZyA8PSAocS5jb25jdXJyZW5jeSAtIHEuYnVmZmVyKSApIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCd1bnNhdHVyYXRlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocS5pZGxlKCkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdkcmFpbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX21heWJlRHJhaW4oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDAgJiYgcS5pZGxlKCkpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUkMSgoKSA9PiB0cmlnZ2VyKCdkcmFpbicpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRNZXRob2QgPSAobmFtZSkgPT4gKGhhbmRsZXIpID0+IHtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uY2UobmFtZSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgb2ZmKG5hbWUpO1xuICAgICAgICBvbihuYW1lLCBoYW5kbGVyKTtcblxuICAgIH07XG5cbiAgICB2YXIgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgdmFyIHEgPSB7XG4gICAgICAgIF90YXNrczogbmV3IERMTCgpLFxuICAgICAgICBfY3JlYXRlVGFza0l0ZW0gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICAgICAgICB5aWVsZCogcS5fdGFza3NbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICB9LFxuICAgICAgICBjb25jdXJyZW5jeSxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgYnVmZmVyOiBjb25jdXJyZW5jeSAvIDQsXG4gICAgICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgICBwdXNoIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX21heWJlRHJhaW4oZGF0YSkpIHJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChkYXR1bSA9PiBfaW5zZXJ0KGRhdHVtLCBmYWxzZSwgZmFsc2UsIGNhbGxiYWNrKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfaW5zZXJ0KGRhdGEsIGZhbHNlLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBwdXNoQXN5bmMgKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChfbWF5YmVEcmFpbihkYXRhKSkgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGRhdHVtID0+IF9pbnNlcnQoZGF0dW0sIGZhbHNlLCB0cnVlLCBjYWxsYmFjaykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2luc2VydChkYXRhLCBmYWxzZSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBraWxsICgpIHtcbiAgICAgICAgICAgIG9mZigpO1xuICAgICAgICAgICAgcS5fdGFza3MuZW1wdHkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaGlmdCAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9tYXliZURyYWluKGRhdGEpKSByZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoZGF0dW0gPT4gX2luc2VydChkYXR1bSwgdHJ1ZSwgZmFsc2UsIGNhbGxiYWNrKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfaW5zZXJ0KGRhdGEsIHRydWUsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2hpZnRBc3luYyAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9tYXliZURyYWluKGRhdGEpKSByZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoZGF0dW0gPT4gX2luc2VydChkYXR1bSwgdHJ1ZSwgdHJ1ZSwgY2FsbGJhY2spKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9pbnNlcnQoZGF0YSwgdHJ1ZSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmUgKHRlc3RGbikge1xuICAgICAgICAgICAgcS5fdGFza3MucmVtb3ZlKHRlc3RGbik7XG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3MgKCkge1xuICAgICAgICAgICAgLy8gQXZvaWQgdHJ5aW5nIHRvIHN0YXJ0IHRvbyBtYW55IHByb2Nlc3Npbmcgb3BlcmF0aW9ucy4gVGhpcyBjYW4gb2NjdXJcbiAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIHJlc29sdmUgc3luY2hyb25vdXNseSAoIzEyNjcpLlxuICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSghcS5wYXVzZWQgJiYgbnVtUnVubmluZyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICB2YXIgdGFza3MgPSBbXSwgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBsID0gcS5fdGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChxLnBheWxvYWQpIGwgPSBNYXRoLm1pbihsLCBxLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcS5fdGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3QucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKG5vZGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbnVtUnVubmluZyArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKHEuX3Rhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdlbXB0eScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChudW1SdW5uaW5nID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ3NhdHVyYXRlZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlPbmNlKF9jcmVhdGVDQih0YXNrcykpO1xuICAgICAgICAgICAgICAgIF93b3JrZXIoZGF0YSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aCAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcS5fdGFza3MubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBydW5uaW5nICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1SdW5uaW5nO1xuICAgICAgICB9LFxuICAgICAgICB3b3JrZXJzTGlzdCAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd29ya2Vyc0xpc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGlkbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcS5fdGFza3MubGVuZ3RoICsgbnVtUnVubmluZyA9PT0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgcGF1c2UgKCkge1xuICAgICAgICAgICAgcS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICByZXN1bWUgKCkge1xuICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBkZWZpbmUgdGhlc2UgYXMgZml4ZWQgcHJvcGVydGllcywgc28gcGVvcGxlIGdldCB1c2VmdWwgZXJyb3JzIHdoZW4gdXBkYXRpbmdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhxLCB7XG4gICAgICAgIHNhdHVyYXRlZDoge1xuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50TWV0aG9kKCdzYXR1cmF0ZWQnKVxuICAgICAgICB9LFxuICAgICAgICB1bnNhdHVyYXRlZDoge1xuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50TWV0aG9kKCd1bnNhdHVyYXRlZCcpXG4gICAgICAgIH0sXG4gICAgICAgIGVtcHR5OiB7XG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZXZlbnRNZXRob2QoJ2VtcHR5JylcbiAgICAgICAgfSxcbiAgICAgICAgZHJhaW46IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudE1ldGhvZCgnZHJhaW4nKVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50TWV0aG9kKCdlcnJvcicpXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHE7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBjYXJnb2Agb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBwYXlsb2FkLiBUYXNrcyBhZGRlZCB0byB0aGVcbiAqIGNhcmdvIHdpbGwgYmUgcHJvY2Vzc2VkIGFsdG9nZXRoZXIgKHVwIHRvIHRoZSBgcGF5bG9hZGAgbGltaXQpLiBJZiB0aGVcbiAqIGB3b3JrZXJgIGlzIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgaXQgYmVjb21lcyBhdmFpbGFibGUuIE9uY2VcbiAqIHRoZSBgd29ya2VyYCBoYXMgY29tcGxldGVkIHNvbWUgdGFza3MsIGVhY2ggY2FsbGJhY2sgb2YgdGhvc2UgdGFza3MgaXNcbiAqIGNhbGxlZC4gQ2hlY2sgb3V0IFt0aGVzZV0oaHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS82YmJkMzZmNGNmNWIzNWEwZjExYTk2ZGNkMmU5NzcxMWZmYzJmYjM3LzY4NzQ3NDcwNzMzYTJmMmY2NjJlNjM2YzZmNzU2NDJlNjc2OTc0Njg3NTYyMmU2MzZmNmQyZjYxNzM3MzY1NzQ3MzJmMzEzNjM3MzYzODM3MzEyZjM2MzgzMTMwMzgyZjYyNjI2MzMwNjM2NjYyMzAyZDM1NjYzMjM5MmQzMTMxNjUzMjJkMzkzNzM0NjYyZDMzMzMzOTM3NjMzNjM0NjQ2MzM4MzUzODJlNjc2OTY2KSBbYW5pbWF0aW9uc10oaHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS9mNDgxMGUwMGUxYzVmNWY4YWRkYmUzZTlmNDkwNjRmZDVkMTAyNjk5LzY4NzQ3NDcwNzMzYTJmMmY2NjJlNjM2YzZmNzU2NDJlNjc2OTc0Njg3NTYyMmU2MzZmNmQyZjYxNzM3MzY1NzQ3MzJmMzEzNjM3MzYzODM3MzEyZjM2MzgzMTMwMzEyZjM4MzQ2MzM5MzIzMDM2MzYyZDM1NjYzMjM5MmQzMTMxNjUzMjJkMzgzMTM0NjYyZDM5NjQzMzY0MzAzMjM0MzEzMzYyNjY2NDJlNjc2OTY2KVxuICogZm9yIGhvdyBgY2FyZ29gIGFuZCBgcXVldWVgIHdvcmsuXG4gKlxuICogV2hpbGUgW2BxdWV1ZWBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0gcGFzc2VzIG9ubHkgb25lIHRhc2sgdG8gb25lIG9mIGEgZ3JvdXAgb2Ygd29ya2Vyc1xuICogYXQgYSB0aW1lLCBjYXJnbyBwYXNzZXMgYW4gYXJyYXkgb2YgdGFza3MgdG8gYSBzaW5nbGUgd29ya2VyLCByZXBlYXRpbmdcbiAqIHdoZW4gdGhlIHdvcmtlciBpcyBmaW5pc2hlZC5cbiAqXG4gKiBAbmFtZSBjYXJnb1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGFuIGFycmF5XG4gKiBvZiBxdWV1ZWQgdGFza3MuIEludm9rZWQgd2l0aCBgKHRhc2tzLCBjYWxsYmFjaylgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXlsb2FkPUluZmluaXR5XSAtIEFuIG9wdGlvbmFsIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmdcbiAqIGhvdyBtYW55IHRhc2tzIHNob3VsZCBiZSBwcm9jZXNzZWQgcGVyIHJvdW5kOyBpZiBvbWl0dGVkLCB0aGUgZGVmYXVsdCBpc1xuICogdW5saW1pdGVkLlxuICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBjYXJnbyBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gQ2FsbGJhY2tzIGNhblxuICogYXR0YWNoZWQgYXMgY2VydGFpbiBwcm9wZXJ0aWVzIHRvIGxpc3RlbiBmb3Igc3BlY2lmaWMgZXZlbnRzIGR1cmluZyB0aGVcbiAqIGxpZmVjeWNsZSBvZiB0aGUgY2FyZ28gYW5kIGlubmVyIHF1ZXVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBjcmVhdGUgYSBjYXJnbyBvYmplY3Qgd2l0aCBwYXlsb2FkIDJcbiAqIHZhciBjYXJnbyA9IGFzeW5jLmNhcmdvKGZ1bmN0aW9uKHRhc2tzLCBjYWxsYmFjaykge1xuICogICAgIGZvciAodmFyIGk9MDsgaTx0YXNrcy5sZW5ndGg7IGkrKykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaGVsbG8gJyArIHRhc2tzW2ldLm5hbWUpO1xuICogICAgIH1cbiAqICAgICBjYWxsYmFjaygpO1xuICogfSwgMik7XG4gKlxuICogLy8gYWRkIHNvbWUgaXRlbXNcbiAqIGNhcmdvLnB1c2goe25hbWU6ICdmb28nfSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgZm9vJyk7XG4gKiB9KTtcbiAqIGNhcmdvLnB1c2goe25hbWU6ICdiYXInfSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmFyJyk7XG4gKiB9KTtcbiAqIGF3YWl0IGNhcmdvLnB1c2goe25hbWU6ICdiYXonfSk7XG4gKiBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXonKTtcbiAqL1xuZnVuY3Rpb24gY2FyZ28kMSh3b3JrZXIsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gcXVldWUkMSh3b3JrZXIsIDEsIHBheWxvYWQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgY2FyZ29RdWV1ZWAgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBwYXlsb2FkLiBUYXNrcyBhZGRlZCB0byB0aGVcbiAqIGNhcmdvUXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgdG9nZXRoZXIgKHVwIHRvIHRoZSBgcGF5bG9hZGAgbGltaXQpIGluIGBjb25jdXJyZW5jeWAgcGFyYWxsZWwgd29ya2Vycy5cbiAqIElmIHRoZSBhbGwgYHdvcmtlcnNgIGFyZSBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIG9uZSBiZWNvbWVzIGF2YWlsYWJsZS4gT25jZVxuICogYSBgd29ya2VyYCBoYXMgY29tcGxldGVkIHNvbWUgdGFza3MsIGVhY2ggY2FsbGJhY2sgb2YgdGhvc2UgdGFza3MgaXNcbiAqIGNhbGxlZC4gQ2hlY2sgb3V0IFt0aGVzZV0oaHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS82YmJkMzZmNGNmNWIzNWEwZjExYTk2ZGNkMmU5NzcxMWZmYzJmYjM3LzY4NzQ3NDcwNzMzYTJmMmY2NjJlNjM2YzZmNzU2NDJlNjc2OTc0Njg3NTYyMmU2MzZmNmQyZjYxNzM3MzY1NzQ3MzJmMzEzNjM3MzYzODM3MzEyZjM2MzgzMTMwMzgyZjYyNjI2MzMwNjM2NjYyMzAyZDM1NjYzMjM5MmQzMTMxNjUzMjJkMzkzNzM0NjYyZDMzMzMzOTM3NjMzNjM0NjQ2MzM4MzUzODJlNjc2OTY2KSBbYW5pbWF0aW9uc10oaHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS9mNDgxMGUwMGUxYzVmNWY4YWRkYmUzZTlmNDkwNjRmZDVkMTAyNjk5LzY4NzQ3NDcwNzMzYTJmMmY2NjJlNjM2YzZmNzU2NDJlNjc2OTc0Njg3NTYyMmU2MzZmNmQyZjYxNzM3MzY1NzQ3MzJmMzEzNjM3MzYzODM3MzEyZjM2MzgzMTMwMzEyZjM4MzQ2MzM5MzIzMDM2MzYyZDM1NjYzMjM5MmQzMTMxNjUzMjJkMzgzMTM0NjYyZDM5NjQzMzY0MzAzMjM0MzEzMzYyNjY2NDJlNjc2OTY2KVxuICogZm9yIGhvdyBgY2FyZ29gIGFuZCBgcXVldWVgIHdvcmsuXG4gKlxuICogV2hpbGUgW2BxdWV1ZWBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0gcGFzc2VzIG9ubHkgb25lIHRhc2sgdG8gb25lIG9mIGEgZ3JvdXAgb2Ygd29ya2Vyc1xuICogYXQgYSB0aW1lLCBhbmQgW2BjYXJnb2Bde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jYXJnb30gcGFzc2VzIGFuIGFycmF5IG9mIHRhc2tzIHRvIGEgc2luZ2xlIHdvcmtlcixcbiAqIHRoZSBjYXJnb1F1ZXVlIHBhc3NlcyBhbiBhcnJheSBvZiB0YXNrcyB0byBtdWx0aXBsZSBwYXJhbGxlbCB3b3JrZXJzLlxuICpcbiAqIEBuYW1lIGNhcmdvUXVldWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9XG4gKiBAc2VlIFthc3luYy5jYXJnb117QGxpbmsgbW9kdWxlOkNvbnRyb2xGTG93LmNhcmdvfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYW4gYXJyYXlcbiAqIG9mIHF1ZXVlZCB0YXNrcy4gSW52b2tlZCB3aXRoIGAodGFza3MsIGNhbGxiYWNrKWAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PTFdIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueVxuICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3lcbiAqIGRlZmF1bHRzIHRvIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGF5bG9hZD1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nXG4gKiBob3cgbWFueSB0YXNrcyBzaG91bGQgYmUgcHJvY2Vzc2VkIHBlciByb3VuZDsgaWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXNcbiAqIHVubGltaXRlZC5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgY2FyZ29RdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gQ2FsbGJhY2tzIGNhblxuICogYXR0YWNoZWQgYXMgY2VydGFpbiBwcm9wZXJ0aWVzIHRvIGxpc3RlbiBmb3Igc3BlY2lmaWMgZXZlbnRzIGR1cmluZyB0aGVcbiAqIGxpZmVjeWNsZSBvZiB0aGUgY2FyZ29RdWV1ZSBhbmQgaW5uZXIgcXVldWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGNyZWF0ZSBhIGNhcmdvUXVldWUgb2JqZWN0IHdpdGggcGF5bG9hZCAyIGFuZCBjb25jdXJyZW5jeSAyXG4gKiB2YXIgY2FyZ29RdWV1ZSA9IGFzeW5jLmNhcmdvUXVldWUoZnVuY3Rpb24odGFza3MsIGNhbGxiYWNrKSB7XG4gKiAgICAgZm9yICh2YXIgaT0wOyBpPHRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbyAnICsgdGFza3NbaV0ubmFtZSk7XG4gKiAgICAgfVxuICogICAgIGNhbGxiYWNrKCk7XG4gKiB9LCAyLCAyKTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtc1xuICogY2FyZ29RdWV1ZS5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiBjYXJnb1F1ZXVlLnB1c2goe25hbWU6ICdiYXInfSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmFyJyk7XG4gKiB9KTtcbiAqIGNhcmdvUXVldWUucHVzaCh7bmFtZTogJ2Jheid9LCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXonKTtcbiAqIH0pO1xuICogY2FyZ29RdWV1ZS5wdXNoKHtuYW1lOiAnYm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJvbycpO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNhcmdvKHdvcmtlciwgY29uY3VycmVuY3ksIHBheWxvYWQpIHtcbiAgICByZXR1cm4gcXVldWUkMSh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKTtcbn1cblxuLyoqXG4gKiBSZWR1Y2VzIGBjb2xsYCBpbnRvIGEgc2luZ2xlIHZhbHVlIHVzaW5nIGFuIGFzeW5jIGBpdGVyYXRlZWAgdG8gcmV0dXJuIGVhY2hcbiAqIHN1Y2Nlc3NpdmUgc3RlcC4gYG1lbW9gIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uIFRoaXMgZnVuY3Rpb25cbiAqIG9ubHkgb3BlcmF0ZXMgaW4gc2VyaWVzLlxuICpcbiAqIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBtYXkgbWFrZSBzZW5zZSB0byBzcGxpdCBhIGNhbGwgdG8gdGhpcyBmdW5jdGlvblxuICogaW50byBhIHBhcmFsbGVsIG1hcCwgYW5kIHRoZW4gdXNlIHRoZSBub3JtYWwgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG9uIHRoZVxuICogcmVzdWx0cy4gVGhpcyBmdW5jdGlvbiBpcyBmb3Igc2l0dWF0aW9ucyB3aGVyZSBlYWNoIHN0ZXAgaW4gdGhlIHJlZHVjdGlvblxuICogbmVlZHMgdG8gYmUgYXN5bmM7IGlmIHlvdSBjYW4gZ2V0IHRoZSBkYXRhIGJlZm9yZSByZWR1Y2luZyBpdCwgdGhlbiBpdCdzXG4gKiBwcm9iYWJseSBhIGdvb2QgaWRlYSB0byBkbyBzby5cbiAqXG4gKiBAbmFtZSByZWR1Y2VcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBpbmplY3RcbiAqIEBhbGlhcyBmb2xkbFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsqfSBtZW1vIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZVxuICogYXJyYXkgdG8gcHJvZHVjZSB0aGUgbmV4dCBzdGVwIGluIHRoZSByZWR1Y3Rpb24uXG4gKiBUaGUgYGl0ZXJhdGVlYCBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICogSWYgdGhlIGl0ZXJhdGVlIGNvbXBsZXRlcyB3aXRoIGFuIGVycm9yLCB0aGUgcmVkdWN0aW9uIGlzIHN0b3BwZWQgYW5kIHRoZVxuICogbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAqIEludm9rZWQgd2l0aCAobWVtbywgaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCBpcyB0aGUgcmVkdWNlZCB2YWx1ZS4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGZpbGUxLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAxMDAwIGJ5dGVzIGluIHNpemVcbiAqIC8vIGZpbGUyLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAyMDAwIGJ5dGVzIGluIHNpemVcbiAqIC8vIGZpbGUzLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAzMDAwIGJ5dGVzIGluIHNpemVcbiAqIC8vIGZpbGU0LnR4dCBkb2VzIG5vdCBleGlzdFxuICpcbiAqIGNvbnN0IGZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlMy50eHQnXTtcbiAqIGNvbnN0IHdpdGhNaXNzaW5nRmlsZUxpc3QgPSBbJ2ZpbGUxLnR4dCcsJ2ZpbGUyLnR4dCcsJ2ZpbGUzLnR4dCcsICdmaWxlNC50eHQnXTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyB0aGUgZmlsZSBzaXplIGluIGJ5dGVzXG4gKiAvLyBmaWxlIHNpemUgaXMgYWRkZWQgdG8gdGhlIG1lbW9pemVkIHZhbHVlLCB0aGVuIHJldHVybmVkXG4gKiBmdW5jdGlvbiBnZXRGaWxlU2l6ZUluQnl0ZXMobWVtbywgZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCBtZW1vICsgc3RhdC5zaXplKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLnJlZHVjZShmaWxlTGlzdCwgMCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyA2MDAwXG4gKiAgICAgICAgIC8vIHdoaWNoIGlzIHRoZSBzdW0gb2YgdGhlIGZpbGUgc2l6ZXMgb2YgdGhlIHRocmVlIGZpbGVzXG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLnJlZHVjZSh3aXRoTWlzc2luZ0ZpbGVMaXN0LCAwLCBnZXRGaWxlU2l6ZUluQnl0ZXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnJlZHVjZShmaWxlTGlzdCwgMCwgZ2V0RmlsZVNpemVJbkJ5dGVzKVxuICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyA2MDAwXG4gKiAgICAgLy8gd2hpY2ggaXMgdGhlIHN1bSBvZiB0aGUgZmlsZSBzaXplcyBvZiB0aGUgdGhyZWUgZmlsZXNcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMucmVkdWNlKHdpdGhNaXNzaW5nRmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHQgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5yZWR1Y2UoZmlsZUxpc3QsIDAsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIDYwMDBcbiAqICAgICAgICAgLy8gd2hpY2ggaXMgdGhlIHN1bSBvZiB0aGUgZmlsZSBzaXplcyBvZiB0aGUgdGhyZWUgZmlsZXNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5yZWR1Y2Uod2l0aE1pc3NpbmdGaWxlTGlzdCwgMCwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZShjb2xsLCBtZW1vLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHJldHVybiBlYWNoT2ZTZXJpZXMkMShjb2xsLCAoeCwgaSwgaXRlckNiKSA9PiB7XG4gICAgICAgIF9pdGVyYXRlZShtZW1vLCB4LCAoZXJyLCB2KSA9PiB7XG4gICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgIGl0ZXJDYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4gY2FsbGJhY2soZXJyLCBtZW1vKSk7XG59XG52YXIgcmVkdWNlJDEgPSBhd2FpdGlmeShyZWR1Y2UsIDQpO1xuXG4vKipcbiAqIFZlcnNpb24gb2YgdGhlIGNvbXBvc2UgZnVuY3Rpb24gdGhhdCBpcyBtb3JlIG5hdHVyYWwgdG8gcmVhZC4gRWFjaCBmdW5jdGlvblxuICogY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZnVuY3Rpb24uIEl0IGlzIHRoZSBlcXVpdmFsZW50IG9mXG4gKiBbY29tcG9zZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNvbXBvc2V9IHdpdGggdGhlIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAqXG4gKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAqXG4gKiBAbmFtZSBzZXFcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmNvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHsuLi5Bc3luY0Z1bmN0aW9ufSBmdW5jdGlvbnMgLSB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjb21wb3NlcyB0aGUgYGZ1bmN0aW9uc2AgaW4gb3JkZXJcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gUmVxdWlyZXMgbG9kYXNoIChvciB1bmRlcnNjb3JlKSwgZXhwcmVzczMgYW5kIGRyZXNlbmRlJ3Mgb3JtMi5cbiAqIC8vIFBhcnQgb2YgYW4gYXBwLCB0aGF0IGZldGNoZXMgY2F0cyBvZiB0aGUgbG9nZ2VkIHVzZXIuXG4gKiAvLyBUaGlzIGV4YW1wbGUgdXNlcyBgc2VxYCBmdW5jdGlvbiB0byBhdm9pZCBvdmVybmVzdGluZyBhbmQgZXJyb3JcbiAqIC8vIGhhbmRsaW5nIGNsdXR0ZXIuXG4gKiBhcHAuZ2V0KCcvY2F0cycsIGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gKiAgICAgdmFyIFVzZXIgPSByZXF1ZXN0Lm1vZGVscy5Vc2VyO1xuICogICAgIGFzeW5jLnNlcShcbiAqICAgICAgICAgVXNlci5nZXQuYmluZChVc2VyKSwgIC8vICdVc2VyLmdldCcgaGFzIHNpZ25hdHVyZSAoaWQsIGNhbGxiYWNrKGVyciwgZGF0YSkpXG4gKiAgICAgICAgIGZ1bmN0aW9uKHVzZXIsIGZuKSB7XG4gKiAgICAgICAgICAgICB1c2VyLmdldENhdHMoZm4pOyAgICAgIC8vICdnZXRDYXRzJyBoYXMgc2lnbmF0dXJlIChjYWxsYmFjayhlcnIsIGRhdGEpKVxuICogICAgICAgICB9XG4gKiAgICAgKShyZXEuc2Vzc2lvbi51c2VyX2lkLCBmdW5jdGlvbiAoZXJyLCBjYXRzKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGVyci5tZXNzYWdlIH0pO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgcmVzcG9uc2UuanNvbih7IHN0YXR1czogJ29rJywgbWVzc2FnZTogJ0NhdHMgZm91bmQnLCBkYXRhOiBjYXRzIH0pO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc2VxKC4uLmZ1bmN0aW9ucykge1xuICAgIHZhciBfZnVuY3Rpb25zID0gZnVuY3Rpb25zLm1hcCh3cmFwQXN5bmMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYiA9IHByb21pc2VDYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVkdWNlJDEoX2Z1bmN0aW9ucywgYXJncywgKG5ld2FyZ3MsIGZuLCBpdGVyQ2IpID0+IHtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KChlcnIsIC4uLm5leHRhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlckNiKGVyciwgbmV4dGFyZ3MpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyLCByZXN1bHRzKSA9PiBjYihlcnIsIC4uLnJlc3VsdHMpKTtcblxuICAgICAgICByZXR1cm4gY2JbUFJPTUlTRV9TWU1CT0xdXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggaXMgYSBjb21wb3NpdGlvbiBvZiB0aGUgcGFzc2VkIGFzeW5jaHJvbm91c1xuICogZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXRcbiAqIGZvbGxvd3MuIENvbXBvc2luZyBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgd291bGQgcHJvZHVjZSB0aGUgcmVzdWx0XG4gKiBvZiBgZihnKGgoKSkpYCwgb25seSB0aGlzIHZlcnNpb24gdXNlcyBjYWxsYmFja3MgdG8gb2J0YWluIHRoZSByZXR1cm4gdmFsdWVzLlxuICpcbiAqIElmIHRoZSBsYXN0IGFyZ3VtZW50IHRvIHRoZSBjb21wb3NlZCBmdW5jdGlvbiBpcyBub3QgYSBmdW5jdGlvbiwgYSBwcm9taXNlXG4gKiBpcyByZXR1cm5lZCB3aGVuIHlvdSBjYWxsIGl0LlxuICpcbiAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICpcbiAqIEBuYW1lIGNvbXBvc2VcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7Li4uQXN5bmNGdW5jdGlvbn0gZnVuY3Rpb25zIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zZWRcbiAqIGFzeW5jaHJvbm91cyBgZnVuY3Rpb25zYFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBhZGQxKG4sIGNhbGxiYWNrKSB7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG4gKyAxKTtcbiAqICAgICB9LCAxMCk7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gbXVsMyhuLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICogMyk7XG4gKiAgICAgfSwgMTApO1xuICogfVxuICpcbiAqIHZhciBhZGQxbXVsMyA9IGFzeW5jLmNvbXBvc2UobXVsMywgYWRkMSk7XG4gKiBhZGQxbXVsMyg0LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAxNVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2UoLi4uYXJncykge1xuICAgIHJldHVybiBzZXEoLi4uYXJncy5yZXZlcnNlKCkpO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgbWFwYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgbWFwTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH1cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkgb2YgdGhlXG4gKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBtYXBMaW1pdCAoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfYXN5bmNNYXAoZWFjaE9mTGltaXQkMihsaW1pdCksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBtYXBMaW1pdCQxID0gYXdhaXRpZnkobWFwTGltaXQsIDQpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgY29uY2F0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgY29uY2F0TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmNvbmNhdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH1cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAYWxpYXMgZmxhdE1hcExpbWl0XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsXG4gKiB3aGljaCBzaG91bGQgdXNlIGFuIGFycmF5IGFzIGl0cyByZXN1bHQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheVxuICogY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGVkIHJlc3VsdHMgb2YgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyBBIFByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBjb25jYXRMaW1pdChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgcmV0dXJuIG1hcExpbWl0JDEoY29sbCwgbGltaXQsICh2YWwsIGl0ZXJDYikgPT4ge1xuICAgICAgICBfaXRlcmF0ZWUodmFsLCAoZXJyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gaXRlckNiKGVycik7XG4gICAgICAgICAgICByZXR1cm4gaXRlckNiKGVyciwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH0sIChlcnIsIG1hcFJlc3VsdHMpID0+IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcFJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtYXBSZXN1bHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCguLi5tYXBSZXN1bHRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgfSk7XG59XG52YXIgY29uY2F0TGltaXQkMSA9IGF3YWl0aWZ5KGNvbmNhdExpbWl0LCA0KTtcblxuLyoqXG4gKiBBcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cy4gUmV0dXJuc1xuICogdGhlIGNvbmNhdGVuYXRlZCBsaXN0LiBUaGUgYGl0ZXJhdGVlYHMgYXJlIGNhbGxlZCBpbiBwYXJhbGxlbCwgYW5kIHRoZVxuICogcmVzdWx0cyBhcmUgY29uY2F0ZW5hdGVkIGFzIHRoZXkgcmV0dXJuLiBUaGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlIHJldHVybmVkIGluXG4gKiB0aGUgb3JpZ2luYWwgb3JkZXIgb2YgYGNvbGxgIHBhc3NlZCB0byB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi5cbiAqXG4gKiBAbmFtZSBjb25jYXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAYWxpYXMgZmxhdE1hcFxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLFxuICogd2hpY2ggc2hvdWxkIHVzZSBhbiBhcnJheSBhcyBpdHMgcmVzdWx0LiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMgQSBQcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAqIC8vIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAqXG4gKiBsZXQgZGlyZWN0b3J5TGlzdCA9IFsnZGlyMScsJ2RpcjInLCdkaXIzJ107XG4gKiBsZXQgd2l0aE1pc3NpbmdEaXJlY3RvcnlMaXN0ID0gWydkaXIxJywnZGlyMicsJ2RpcjMnLCAnZGlyNCddO1xuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMuY29uY2F0KGRpcmVjdG9yeUxpc3QsIGZzLnJlYWRkaXIsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgaWYgKGVycikge1xuICogICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICB9IGVsc2Uge1xuICogICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgIC8vIFsgJ2ZpbGUxLnR4dCcsICdmaWxlMi50eHQnLCAnZmlsZTMudHh0JywgJ2ZpbGU0LnR4dCcsIGZpbGU1LnR4dCBdXG4gKiAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMuY29uY2F0KHdpdGhNaXNzaW5nRGlyZWN0b3J5TGlzdCwgZnMucmVhZGRpciwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogICAgICAgIC8vIHNpbmNlIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAqICAgIH0gZWxzZSB7XG4gKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuY29uY2F0KGRpcmVjdG9yeUxpc3QsIGZzLnJlYWRkaXIpXG4gKiAudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyBbICdmaWxlMS50eHQnLCAnZmlsZTIudHh0JywgJ2ZpbGUzLnR4dCcsICdmaWxlNC50eHQnLCBmaWxlNS50eHQgXVxuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYy5jb25jYXQod2l0aE1pc3NpbmdEaXJlY3RvcnlMaXN0LCBmcy5yZWFkZGlyKVxuICogLnRoZW4ocmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAvLyBzaW5jZSBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMuY29uY2F0KGRpcmVjdG9yeUxpc3QsIGZzLnJlYWRkaXIpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gWyAnZmlsZTEudHh0JywgJ2ZpbGUyLnR4dCcsICdmaWxlMy50eHQnLCAnZmlsZTQudHh0JywgZmlsZTUudHh0IF1cbiAqICAgICB9IGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLmNvbmNhdCh3aXRoTWlzc2luZ0RpcmVjdG9yeUxpc3QsIGZzLnJlYWRkaXIpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICB9IGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAgICAgLy8gc2luY2UgZGlyNCBkb2VzIG5vdCBleGlzdFxuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY29uY2F0TGltaXQkMShjb2xsLCBJbmZpbml0eSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGNvbmNhdCQxID0gYXdhaXRpZnkoY29uY2F0LCAzKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGNvbmNhdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBjb25jYXRTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmNvbmNhdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH1cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAYWxpYXMgZmxhdE1hcFNlcmllc1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGFuIGFycmF5IGFuIGFycmF5IG9mIHJlc3VsdHMuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMgQSBQcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gY29uY2F0U2VyaWVzKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBjb25jYXRMaW1pdCQxKGNvbGwsIDEsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBjb25jYXRTZXJpZXMkMSA9IGF3YWl0aWZ5KGNvbmNhdFNlcmllcywgMyk7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBjYWxsZWQsIGNhbGxzLWJhY2sgd2l0aCB0aGUgdmFsdWVzIHByb3ZpZGVkLlxuICogVXNlZnVsIGFzIHRoZSBmaXJzdCBmdW5jdGlvbiBpbiBhIFtgd2F0ZXJmYWxsYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndhdGVyZmFsbH0sIG9yIGZvciBwbHVnZ2luZyB2YWx1ZXMgaW4gdG9cbiAqIFtgYXV0b2Bde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfS5cbiAqXG4gKiBAbmFtZSBjb25zdGFudFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXV0b21hdGljYWxseSBpbnZva2VcbiAqIGNhbGxiYWNrIHdpdGguXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBpbnZva2VkLCBhdXRvbWF0aWNhbGx5XG4gKiBpbnZva2VzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBwcmV2aW91cyBnaXZlbiBhcmd1bWVudHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuY29uc3RhbnQoNDIpLFxuICogICAgIGZ1bmN0aW9uICh2YWx1ZSwgbmV4dCkge1xuICogICAgICAgICAvLyB2YWx1ZSA9PT0gNDJcbiAqICAgICB9LFxuICogICAgIC8vLi4uXG4gKiBdLCBjYWxsYmFjayk7XG4gKlxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBhc3luYy5jb25zdGFudChmaWxlbmFtZSwgXCJ1dGY4XCIpLFxuICogICAgIGZzLnJlYWRGaWxlLFxuICogICAgIGZ1bmN0aW9uIChmaWxlRGF0YSwgbmV4dCkge1xuICogICAgICAgICAvLy4uLlxuICogICAgIH1cbiAqICAgICAvLy4uLlxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIGhvc3RuYW1lOiBhc3luYy5jb25zdGFudChcImh0dHBzOi8vc2VydmVyLm5ldC9cIiksXG4gKiAgICAgcG9ydDogZmluZEZyZWVQb3J0LFxuICogICAgIGxhdW5jaFNlcnZlcjogW1wiaG9zdG5hbWVcIiwgXCJwb3J0XCIsIGZ1bmN0aW9uIChvcHRpb25zLCBjYikge1xuICogICAgICAgICBzdGFydFNlcnZlcihvcHRpb25zLCBjYik7XG4gKiAgICAgfV0sXG4gKiAgICAgLy8uLi5cbiAqIH0sIGNhbGxiYWNrKTtcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQkMSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5pZ25vcmVkQXJncy8qLCBjYWxsYmFjayovKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGlnbm9yZWRBcmdzLnBvcCgpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgLi4uYXJncyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVRlc3RlcihjaGVjaywgZ2V0UmVzdWx0KSB7XG4gICAgcmV0dXJuIChlYWNoZm4sIGFyciwgX2l0ZXJhdGVlLCBjYikgPT4ge1xuICAgICAgICB2YXIgdGVzdFBhc3NlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdGVzdFJlc3VsdDtcbiAgICAgICAgY29uc3QgaXRlcmF0ZWUgPSB3cmFwQXN5bmMoX2l0ZXJhdGVlKTtcbiAgICAgICAgZWFjaGZuKGFyciwgKHZhbHVlLCBfLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgaXRlcmF0ZWUodmFsdWUsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgZXJyID09PSBmYWxzZSkgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2socmVzdWx0KSAmJiAhdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0UGFzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGVzdFJlc3VsdCA9IGdldFJlc3VsdCh0cnVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBicmVha0xvb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgIGNiKG51bGwsIHRlc3RQYXNzZWQgPyB0ZXN0UmVzdWx0IDogZ2V0UmVzdWx0KGZhbHNlKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gYGNvbGxgIHRoYXQgcGFzc2VzIGFuIGFzeW5jIHRydXRoIHRlc3QuIFRoZVxuICogYGl0ZXJhdGVlYCBpcyBhcHBsaWVkIGluIHBhcmFsbGVsLCBtZWFuaW5nIHRoZSBmaXJzdCBpdGVyYXRlZSB0byByZXR1cm5cbiAqIGB0cnVlYCB3aWxsIGZpcmUgdGhlIGRldGVjdCBgY2FsbGJhY2tgIHdpdGggdGhhdCByZXN1bHQuIFRoYXQgbWVhbnMgdGhlXG4gKiByZXN1bHQgbWlnaHQgbm90IGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBvcmlnaW5hbCBgY29sbGAgKGluIHRlcm1zIG9mIG9yZGVyKVxuICogdGhhdCBwYXNzZXMgdGhlIHRlc3QuXG5cbiAqIElmIG9yZGVyIHdpdGhpbiB0aGUgb3JpZ2luYWwgYGNvbGxgIGlzIGltcG9ydGFudCwgdGhlbiBsb29rIGF0XG4gKiBbYGRldGVjdFNlcmllc2Bde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3RTZXJpZXN9LlxuICpcbiAqIEBuYW1lIGRldGVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGZpbmRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICogZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlLCBjYWxsYmFjaykge1xuICogICAgZnMuYWNjZXNzKGZpbGUsIGZzLmNvbnN0YW50cy5GX09LLCAoZXJyKSA9PiB7XG4gKiAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycik7XG4gKiAgICB9KTtcbiAqIH1cbiAqXG4gKiBhc3luYy5kZXRlY3QoWydmaWxlMy50eHQnLCdmaWxlMi50eHQnLCdkaXIxL2ZpbGUxLnR4dCddLCBmaWxlRXhpc3RzLFxuICogICAgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgIC8vIGRpcjEvZmlsZTEudHh0XG4gKiAgICAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgdGhlIGZpcnN0IGZpbGUgaW4gdGhlIGxpc3QgdGhhdCBleGlzdHNcbiAqICAgIH1cbiAqKTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuZGV0ZWN0KFsnZmlsZTMudHh0JywnZmlsZTIudHh0JywnZGlyMS9maWxlMS50eHQnXSwgZmlsZUV4aXN0cylcbiAqIC50aGVuKHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyBkaXIxL2ZpbGUxLnR4dFxuICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzIHRoZSBmaXJzdCBmaWxlIGluIHRoZSBsaXN0IHRoYXQgZXhpc3RzXG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5kZXRlY3QoWydmaWxlMy50eHQnLCdmaWxlMi50eHQnLCdkaXIxL2ZpbGUxLnR4dCddLCBmaWxlRXhpc3RzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8gZGlyMS9maWxlMS50eHRcbiAqICAgICAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgdGhlIGZpbGUgaW4gdGhlIGxpc3QgdGhhdCBleGlzdHNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGRldGVjdChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+IGJvb2wsIChyZXMsIGl0ZW0pID0+IGl0ZW0pKGVhY2hPZiQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZGV0ZWN0JDEgPSBhd2FpdGlmeShkZXRlY3QsIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZGV0ZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIGRldGVjdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kZXRlY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9XG4gKiBAYWxpYXMgZmluZExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGRldGVjdExpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+IGJvb2wsIChyZXMsIGl0ZW0pID0+IGl0ZW0pKGVhY2hPZkxpbWl0JDIobGltaXQpLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZGV0ZWN0TGltaXQkMSA9IGF3YWl0aWZ5KGRldGVjdExpbWl0LCA0KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBkZXRlY3RTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGRldGVjdFNlcmllcyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3Rlcihib29sID0+IGJvb2wsIChyZXMsIGl0ZW0pID0+IGl0ZW0pKGVhY2hPZkxpbWl0JDIoMSksIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cblxudmFyIGRldGVjdFNlcmllcyQxID0gYXdhaXRpZnkoZGV0ZWN0U2VyaWVzLCAzKTtcblxuZnVuY3Rpb24gY29uc29sZUZ1bmMobmFtZSkge1xuICAgIHJldHVybiAoZm4sIC4uLmFyZ3MpID0+IHdyYXBBc3luYyhmbikoLi4uYXJncywgKGVyciwgLi4ucmVzdWx0QXJncykgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVtuYW1lXSkgeyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIHJlc3VsdEFyZ3MuZm9yRWFjaCh4ID0+IGNvbnNvbGVbbmFtZV0oeCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuLyoqXG4gKiBMb2dzIHRoZSByZXN1bHQgb2YgYW4gW2Bhc3luY2AgZnVuY3Rpb25de0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHRoZVxuICogYGNvbnNvbGVgIHVzaW5nIGBjb25zb2xlLmRpcmAgdG8gZGlzcGxheSB0aGUgcHJvcGVydGllcyBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIE9ubHkgd29ya3MgaW4gTm9kZS5qcyBvciBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgYGNvbnNvbGUuZGlyYCBhbmRcbiAqIGBjb25zb2xlLmVycm9yYCAoc3VjaCBhcyBGRiBhbmQgQ2hyb21lKS5cbiAqIElmIG11bHRpcGxlIGFyZ3VtZW50cyBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgYXN5bmMgZnVuY3Rpb24sXG4gKiBgY29uc29sZS5kaXJgIGlzIGNhbGxlZCBvbiBlYWNoIGFyZ3VtZW50IGluIG9yZGVyLlxuICpcbiAqIEBuYW1lIGRpclxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseVxuICogYWxsIGFyZ3VtZW50cyB0by5cbiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBpbiBhIG1vZHVsZVxuICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCB7aGVsbG86IG5hbWV9KTtcbiAqICAgICB9LCAxMDAwKTtcbiAqIH07XG4gKlxuICogLy8gaW4gdGhlIG5vZGUgcmVwbFxuICogbm9kZT4gYXN5bmMuZGlyKGhlbGxvLCAnd29ybGQnKTtcbiAqIHtoZWxsbzogJ3dvcmxkJ31cbiAqL1xudmFyIGRpciA9IGNvbnNvbGVGdW5jKCdkaXInKTtcblxuLyoqXG4gKiBUaGUgcG9zdC1jaGVjayB2ZXJzaW9uIG9mIFtgd2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uIFRvIHJlZmxlY3QgdGhlIGRpZmZlcmVuY2UgaW5cbiAqIHRoZSBvcmRlciBvZiBvcGVyYXRpb25zLCB0aGUgYXJndW1lbnRzIGB0ZXN0YCBhbmQgYGl0ZXJhdGVlYCBhcmUgc3dpdGNoZWQuXG4gKlxuICogYGRvV2hpbHN0YCBpcyB0byBgd2hpbHN0YCBhcyBgZG8gd2hpbGVgIGlzIHRvIGB3aGlsZWAgaW4gcGxhaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBAbmFtZSBkb1doaWxzdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZSBgdGVzdGBcbiAqIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGFmdGVyIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKC4uLmFyZ3MsIGNhbGxiYWNrKSwgd2hlcmUgYC4uLmFyZ3NgIGFyZSB0aGVcbiAqIG5vbi1lcnJvciBhcmdzIGZyb20gdGhlIHByZXZpb3VzIGNhbGxiYWNrIG9mIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLlxuICogYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsXG4gKiBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pO1xuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGRvV2hpbHN0KGl0ZXJhdGVlLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2spO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcbiAgICB2YXIgcmVzdWx0cztcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICByZXN1bHRzID0gYXJncztcbiAgICAgICAgX3Rlc3QoLi4uYXJncywgY2hlY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrKGVyciwgdHJ1dGgpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGlmICghdHJ1dGgpIHJldHVybiBjYWxsYmFjayhudWxsLCAuLi5yZXN1bHRzKTtcbiAgICAgICAgX2ZuKG5leHQpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGVjayhudWxsLCB0cnVlKTtcbn1cblxudmFyIGRvV2hpbHN0JDEgPSBhd2FpdGlmeShkb1doaWxzdCwgMyk7XG5cbi8qKlxuICogTGlrZSBbJ2RvV2hpbHN0J117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fSwgZXhjZXB0IHRoZSBgdGVzdGAgaXMgaW52ZXJ0ZWQuIE5vdGUgdGhlXG4gKiBhcmd1bWVudCBvcmRlcmluZyBkaWZmZXJzIGZyb20gYHVudGlsYC5cbiAqXG4gKiBAbmFtZSBkb1VudGlsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kb1doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBmYWlscy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGFmdGVyIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKC4uLmFyZ3MsIGNhbGxiYWNrKSwgd2hlcmUgYC4uLmFyZ3NgIGFyZSB0aGVcbiAqIG5vbi1lcnJvciBhcmdzIGZyb20gdGhlIHByZXZpb3VzIGNhbGxiYWNrIG9mIGBpdGVyYXRlZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdFxuICogZnVuY3Rpb24gaGFzIHBhc3NlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2BcbiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzXG4gKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZG9VbnRpbChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcbiAgICByZXR1cm4gZG9XaGlsc3QkMShpdGVyYXRlZSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgY2IgPSBhcmdzLnBvcCgpO1xuICAgICAgICBfdGVzdCguLi5hcmdzLCAoZXJyLCB0cnV0aCkgPT4gY2IgKGVyciwgIXRydXRoKSk7XG4gICAgfSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSA9PiBpdGVyYXRlZSh2YWx1ZSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGZ1bmN0aW9uIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgaW4gcGFyYWxsZWwuXG4gKiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCBhbiBpdGVtIGZyb20gdGhlIGxpc3QsIGFuZCBhIGNhbGxiYWNrIGZvciB3aGVuXG4gKiBpdCBoYXMgZmluaXNoZWQuIElmIHRoZSBgaXRlcmF0ZWVgIHBhc3NlcyBhbiBlcnJvciB0byBpdHMgYGNhbGxiYWNrYCwgdGhlXG4gKiBtYWluIGBjYWxsYmFja2AgKGZvciB0aGUgYGVhY2hgIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGVcbiAqIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIHBhcmFsbGVsLFxuICogdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlIGluIG9yZGVyLlxuICpcbiAqIEBuYW1lIGVhY2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG9cbiAqIGVhY2ggaXRlbSBpbiBgY29sbGAuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gKiAvLyBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogY29uc3QgZmlsZUxpc3QgPSBbICdkaXIxL2ZpbGUyLnR4dCcsICdkaXIyL2ZpbGUzLnR4dCcsICdkaXIvZmlsZTUudHh0J107XG4gKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVMaXN0ID0gWydkaXIxL2ZpbGUxLnR4dCcsICdkaXI0L2ZpbGUyLnR4dCddO1xuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGRlbGV0ZXMgYSBmaWxlXG4gKiBjb25zdCBkZWxldGVGaWxlID0gZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy51bmxpbmsoZmlsZSwgY2FsbGJhY2spO1xuICogfTtcbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLmVhY2goZmlsZUxpc3QsIGRlbGV0ZUZpbGUsIGZ1bmN0aW9uKGVycikge1xuICogICAgIGlmKCBlcnIgKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ0FsbCBmaWxlcyBoYXZlIGJlZW4gZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMuZWFjaCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBkZWxldGVGaWxlLCBmdW5jdGlvbihlcnIpe1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAvLyBzaW5jZSBkaXI0L2ZpbGUyLnR4dCBkb2VzIG5vdCBleGlzdFxuICogICAgIC8vIGRpcjEvZmlsZTEudHh0IGNvdWxkIGhhdmUgYmVlbiBkZWxldGVkXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuZWFjaChmaWxlTGlzdCwgZGVsZXRlRmlsZSlcbiAqIC50aGVuKCAoKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ0FsbCBmaWxlcyBoYXZlIGJlZW4gZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMuZWFjaChmaWxlTGlzdCwgZGVsZXRlRmlsZSlcbiAqIC50aGVuKCAoKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ0FsbCBmaWxlcyBoYXZlIGJlZW4gZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAvLyBzaW5jZSBkaXI0L2ZpbGUyLnR4dCBkb2VzIG5vdCBleGlzdFxuICogICAgIC8vIGRpcjEvZmlsZTEudHh0IGNvdWxkIGhhdmUgYmVlbiBkZWxldGVkXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGF3YWl0IGFzeW5jLmVhY2goZmlsZXMsIGRlbGV0ZUZpbGUpO1xuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgYXdhaXQgYXN5bmMuZWFjaCh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBkZWxldGVGaWxlKTtcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogICAgICAgICAvLyBzaW5jZSBkaXI0L2ZpbGUyLnR4dCBkb2VzIG5vdCBleGlzdFxuICogICAgICAgICAvLyBkaXIxL2ZpbGUxLnR4dCBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZFxuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGVhY2hMaW1pdCQyKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBlYWNoT2YkMShjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7XG59XG5cbnZhciBlYWNoID0gYXdhaXRpZnkoZWFjaExpbWl0JDIsIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBlYWNoTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICogQGFsaWFzIGZvckVhY2hMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZkxpbWl0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICovXG5mdW5jdGlvbiBlYWNoTGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBlYWNoT2ZMaW1pdCQyKGxpbWl0KShjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7XG59XG52YXIgZWFjaExpbWl0JDEgPSBhd2FpdGlmeShlYWNoTGltaXQsIDQpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogTm90ZSwgdGhhdCB1bmxpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgaXRlcmF0ZWUgdG8gZWFjaCBpdGVtXG4gKiBpbiBzZXJpZXMgYW5kIHRoZXJlZm9yZSB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuXG5cbiAqIEBuYW1lIGVhY2hTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICogQGFsaWFzIGZvckVhY2hTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZTZXJpZXNgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGVhY2hTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGVhY2hMaW1pdCQxKGNvbGwsIDEsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBlYWNoU2VyaWVzJDEgPSBhd2FpdGlmeShlYWNoU2VyaWVzLCAzKTtcblxuLyoqXG4gKiBXcmFwIGFuIGFzeW5jIGZ1bmN0aW9uIGFuZCBlbnN1cmUgaXQgY2FsbHMgaXRzIGNhbGxiYWNrIG9uIGEgbGF0ZXIgdGljayBvZlxuICogdGhlIGV2ZW50IGxvb3AuICBJZiB0aGUgZnVuY3Rpb24gYWxyZWFkeSBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBuZXh0IHRpY2ssXG4gKiBubyBleHRyYSBkZWZlcnJhbCBpcyBhZGRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIHByZXZlbnRpbmcgc3RhY2sgb3ZlcmZsb3dzXG4gKiAoYFJhbmdlRXJyb3I6IE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkYCkgYW5kIGdlbmVyYWxseSBrZWVwaW5nXG4gKiBbWmFsZ29dKGh0dHA6Ly9ibG9nLml6cy5tZS9wb3N0LzU5MTQyNzQyMTQzL2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogY29udGFpbmVkLiBFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbnMgYXJlIHJldHVybmVkIGFzLWlzIC0tIHRoZXkgYXJlIGltbXVuZVxuICogdG8gWmFsZ28ncyBjb3JydXB0aW5nIGluZmx1ZW5jZXMsIGFzIHRoZXkgYWx3YXlzIHJlc29sdmUgb24gYSBsYXRlciB0aWNrLlxuICpcbiAqIEBuYW1lIGVuc3VyZUFzeW5jXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIGFuIGFzeW5jIGZ1bmN0aW9uLCBvbmUgdGhhdCBleHBlY3RzIGEgbm9kZS1zdHlsZVxuICogY2FsbGJhY2sgYXMgaXRzIGxhc3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIHdyYXBwZWQgZnVuY3Rpb24gd2l0aCB0aGUgZXhhY3Qgc2FtZSBjYWxsXG4gKiBzaWduYXR1cmUgYXMgdGhlIGZ1bmN0aW9uIHBhc3NlZCBpbi5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc29tZXRpbWVzQXN5bmMoYXJnLCBjYWxsYmFjaykge1xuICogICAgIGlmIChjYWNoZVthcmddKSB7XG4gKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjYWNoZVthcmddKTsgLy8gdGhpcyB3b3VsZCBiZSBzeW5jaHJvbm91cyEhXG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgZG9Tb21lSU8oYXJnLCBjYWxsYmFjayk7IC8vIHRoaXMgSU8gd291bGQgYmUgYXN5bmNocm9ub3VzXG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIHRoaXMgaGFzIGEgcmlzayBvZiBzdGFjayBvdmVyZmxvd3MgaWYgbWFueSByZXN1bHRzIGFyZSBjYWNoZWQgaW4gYSByb3dcbiAqIGFzeW5jLm1hcFNlcmllcyhhcmdzLCBzb21ldGltZXNBc3luYywgZG9uZSk7XG4gKlxuICogLy8gdGhpcyB3aWxsIGRlZmVyIHNvbWV0aW1lc0FzeW5jJ3MgY2FsbGJhY2sgaWYgbmVjZXNzYXJ5LFxuICogLy8gcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3NcbiAqIGFzeW5jLm1hcFNlcmllcyhhcmdzLCBhc3luYy5lbnN1cmVBc3luYyhzb21ldGltZXNBc3luYyksIGRvbmUpO1xuICovXG5mdW5jdGlvbiBlbnN1cmVBc3luYyhmbikge1xuICAgIGlmIChpc0FzeW5jKGZuKSkgcmV0dXJuIGZuO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncy8qLCBjYWxsYmFjayovKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgYXJncy5wdXNoKCguLi5pbm5lckFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4gY2FsbGJhY2soLi4uaW5uZXJBcmdzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC4uLmlubmVyQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgc3luYyA9IGZhbHNlO1xuICAgIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgZXZlcnkgZWxlbWVudCBpbiBgY29sbGAgc2F0aXNmaWVzIGFuIGFzeW5jIHRlc3QuIElmIGFueVxuICogaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGBmYWxzZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICpcbiAqIEBuYW1lIGV2ZXJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgYWxsXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9uIGluIHBhcmFsbGVsLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gcmVzdWx0IHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgXG4gKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAqIC8vIGRpcjQgZG9lcyBub3QgZXhpc3RcbiAqXG4gKiBjb25zdCBmaWxlTGlzdCA9IFsnZGlyMS9maWxlMS50eHQnLCdkaXIyL2ZpbGUzLnR4dCcsJ2RpcjMvZmlsZTUudHh0J107XG4gKiBjb25zdCB3aXRoTWlzc2luZ0ZpbGVMaXN0ID0gWydmaWxlMS50eHQnLCdmaWxlMi50eHQnLCdmaWxlNC50eHQnXTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICogZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlLCBjYWxsYmFjaykge1xuICogICAgZnMuYWNjZXNzKGZpbGUsIGZzLmNvbnN0YW50cy5GX09LLCAoZXJyKSA9PiB7XG4gKiAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycik7XG4gKiAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLmV2ZXJ5KGZpbGVMaXN0LCBmaWxlRXhpc3RzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gdHJ1ZVxuICogICAgIC8vIHJlc3VsdCBpcyB0cnVlIHNpbmNlIGV2ZXJ5IGZpbGUgZXhpc3RzXG4gKiB9KTtcbiAqXG4gKiBhc3luYy5ldmVyeSh3aXRoTWlzc2luZ0ZpbGVMaXN0LCBmaWxlRXhpc3RzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gZmFsc2VcbiAqICAgICAvLyByZXN1bHQgaXMgZmFsc2Ugc2luY2UgTk9UIGV2ZXJ5IGZpbGUgZXhpc3RzXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuZXZlcnkoZmlsZUxpc3QsIGZpbGVFeGlzdHMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIHRydWVcbiAqICAgICAvLyByZXN1bHQgaXMgdHJ1ZSBzaW5jZSBldmVyeSBmaWxlIGV4aXN0c1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIGFzeW5jLmV2ZXJ5KHdpdGhNaXNzaW5nRmlsZUxpc3QsIGZpbGVFeGlzdHMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIGZhbHNlXG4gKiAgICAgLy8gcmVzdWx0IGlzIGZhbHNlIHNpbmNlIE5PVCBldmVyeSBmaWxlIGV4aXN0c1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLmV2ZXJ5KGZpbGVMaXN0LCBmaWxlRXhpc3RzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8gdHJ1ZVxuICogICAgICAgICAvLyByZXN1bHQgaXMgdHJ1ZSBzaW5jZSBldmVyeSBmaWxlIGV4aXN0c1xuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZXZlcnkod2l0aE1pc3NpbmdGaWxlTGlzdCwgZmlsZUV4aXN0cyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIGZhbHNlXG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBOT1QgZXZlcnkgZmlsZSBleGlzdHNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGV2ZXJ5KGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKGJvb2wgPT4gIWJvb2wsIHJlcyA9PiAhcmVzKShlYWNoT2YkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGV2ZXJ5JDEgPSBhd2FpdGlmeShldmVyeSwgMyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BldmVyeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZXZlcnlMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZXZlcnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX1cbiAqIEBhbGlhcyBhbGxMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIGV2ZXJ5TGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfY3JlYXRlVGVzdGVyKGJvb2wgPT4gIWJvb2wsIHJlcyA9PiAhcmVzKShlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGV2ZXJ5TGltaXQkMSA9IGF3YWl0aWZ5KGV2ZXJ5TGltaXQsIDQpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZXZlcnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBldmVyeVNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZXZlcnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX1cbiAqIEBhbGlhcyBhbGxTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gc2VyaWVzLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gcmVzdWx0IHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgXG4gKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqL1xuZnVuY3Rpb24gZXZlcnlTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoYm9vbCA9PiAhYm9vbCwgcmVzID0+ICFyZXMpKGVhY2hPZlNlcmllcyQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgZXZlcnlTZXJpZXMkMSA9IGF3YWl0aWZ5KGV2ZXJ5U2VyaWVzLCAzKTtcblxuZnVuY3Rpb24gZmlsdGVyQXJyYXkoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciB0cnV0aFZhbHVlcyA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgICBlYWNoZm4oYXJyLCAoeCwgaW5kZXgsIGl0ZXJDYikgPT4ge1xuICAgICAgICBpdGVyYXRlZSh4LCAoZXJyLCB2KSA9PiB7XG4gICAgICAgICAgICB0cnV0aFZhbHVlc1tpbmRleF0gPSAhIXY7XG4gICAgICAgICAgICBpdGVyQ2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHJ1dGhWYWx1ZXNbaV0pIHJlc3VsdHMucHVzaChhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJHZW5lcmljKGVhY2hmbiwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBlYWNoZm4oY29sbCwgKHgsIGluZGV4LCBpdGVyQ2IpID0+IHtcbiAgICAgICAgaXRlcmF0ZWUoeCwgKGVyciwgdikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe2luZGV4LCB2YWx1ZTogeH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlckNiKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpXG4gICAgICAgICAgICAubWFwKHYgPT4gdi52YWx1ZSkpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZmlsdGVyKGVhY2hmbiwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpbHRlciA9IGlzQXJyYXlMaWtlKGNvbGwpID8gZmlsdGVyQXJyYXkgOiBmaWx0ZXJHZW5lcmljO1xuICAgIHJldHVybiBmaWx0ZXIoZWFjaGZuLCBjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBvZiBhbGwgdGhlIHZhbHVlcyBpbiBgY29sbGAgd2hpY2ggcGFzcyBhbiBhc3luYyB0cnV0aFxuICogdGVzdC4gVGhpcyBvcGVyYXRpb24gaXMgcGVyZm9ybWVkIGluIHBhcmFsbGVsLCBidXQgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZVxuICogaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIG9yaWdpbmFsLlxuICpcbiAqIEBuYW1lIGZpbHRlclxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIHNlbGVjdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGlyMSBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUxLnR4dCwgZmlsZTIudHh0XG4gKiAvLyBkaXIyIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTMudHh0LCBmaWxlNC50eHRcbiAqIC8vIGRpcjMgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlNS50eHRcbiAqXG4gKiBjb25zdCBmaWxlcyA9IFsnZGlyMS9maWxlMS50eHQnLCdkaXIyL2ZpbGUzLnR4dCcsJ2RpcjMvZmlsZTYudHh0J107XG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAqIGZ1bmN0aW9uIGZpbGVFeGlzdHMoZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgIGZzLmFjY2VzcyhmaWxlLCBmcy5jb25zdGFudHMuRl9PSywgKGVycikgPT4ge1xuICogICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpO1xuICogICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5maWx0ZXIoZmlsZXMsIGZpbGVFeGlzdHMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgaWYoZXJyKSB7XG4gKiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgIH0gZWxzZSB7XG4gKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgLy8gWyAnZGlyMS9maWxlMS50eHQnLCAnZGlyMi9maWxlMy50eHQnIF1cbiAqICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAqICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5maWx0ZXIoZmlsZXMsIGZpbGVFeGlzdHMpXG4gKiAudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyBbICdkaXIxL2ZpbGUxLnR4dCcsICdkaXIyL2ZpbGUzLnR4dCcgXVxuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHRoZSBleGlzdGluZyBmaWxlc1xuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLmZpbHRlcihmaWxlcywgZmlsZUV4aXN0cyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyBbICdkaXIxL2ZpbGUxLnR4dCcsICdkaXIyL2ZpbGUzLnR4dCcgXVxuICogICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGZpbHRlciAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9maWx0ZXIoZWFjaE9mJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBmaWx0ZXIkMSA9IGF3YWl0aWZ5KGZpbHRlciwgMyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZmlsdGVyTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmZpbHRlcl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn1cbiAqIEBhbGlhcyBzZWxlY3RMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqL1xuZnVuY3Rpb24gZmlsdGVyTGltaXQgKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2ZpbHRlcihlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIGZpbHRlckxpbWl0JDEgPSBhd2FpdGlmeShmaWx0ZXJMaW1pdCwgNCk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZmlsdGVyU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9XG4gKiBAYWxpYXMgc2VsZWN0U2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGBpdGVyYXRlZWAgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgLCB3aGljaCBtdXN0IGJlIGNhbGxlZFxuICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cylcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIGZpbHRlclNlcmllcyAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9maWx0ZXIoZWFjaE9mU2VyaWVzJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBmaWx0ZXJTZXJpZXMkMSA9IGF3YWl0aWZ5KGZpbHRlclNlcmllcywgMyk7XG5cbi8qKlxuICogQ2FsbHMgdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBgZm5gIHdpdGggYSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhhdCBhbGxvd3MgaXRcbiAqIHRvIGNhbGwgaXRzZWxmIGFnYWluLCBpbiBzZXJpZXMsIGluZGVmaW5pdGVseS5cblxuICogSWYgYW4gZXJyb3IgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayB0aGVuIGBlcnJiYWNrYCBpcyBjYWxsZWQgd2l0aCB0aGVcbiAqIGVycm9yLCBhbmQgZXhlY3V0aW9uIHN0b3BzLCBvdGhlcndpc2UgaXQgd2lsbCBuZXZlciBiZSBjYWxsZWQuXG4gKlxuICogQG5hbWUgZm9yZXZlclxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgcmVwZWF0ZWRseS5cbiAqIEludm9rZWQgd2l0aCAobmV4dCkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyYmFja10gLSB3aGVuIGBmbmAgcGFzc2VzIGFuIGVycm9yIHRvIGl0J3MgY2FsbGJhY2ssXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkLCBhbmQgZXhlY3V0aW9uIHN0b3BzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgcmVqZWN0cyBpZiBhbiBlcnJvciBvY2N1cnMgYW5kIGFuIGVycmJhY2tcbiAqIGlzIG5vdCBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZm9yZXZlcihcbiAqICAgICBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICAgIC8vIG5leHQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gdGhpbmdzIHRoYXQgbmVlZCBhIGNhbGxiYWNrKGVyciBbLCB3aGF0ZXZlcl0pO1xuICogICAgICAgICAvLyBpdCB3aWxsIHJlc3VsdCBpbiB0aGlzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBhZ2Fpbi5cbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICAvLyBpZiBuZXh0IGlzIGNhbGxlZCB3aXRoIGEgdmFsdWUgaW4gaXRzIGZpcnN0IHBhcmFtZXRlciwgaXQgd2lsbCBhcHBlYXJcbiAqICAgICAgICAgLy8gaW4gaGVyZSBhcyAnZXJyJywgYW5kIGV4ZWN1dGlvbiB3aWxsIHN0b3AuXG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gZm9yZXZlcihmbiwgZXJyYmFjaykge1xuICAgIHZhciBkb25lID0gb25seU9uY2UoZXJyYmFjayk7XG4gICAgdmFyIHRhc2sgPSB3cmFwQXN5bmMoZW5zdXJlQXN5bmMoZm4pKTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHRhc2sobmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG59XG52YXIgZm9yZXZlciQxID0gYXdhaXRpZnkoZm9yZXZlciwgMik7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bncm91cEJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGdyb3VwQnlMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZ3JvdXBCeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBga2V5YCB0byBncm91cCB0aGUgdmFsdWUgdW5kZXIuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0IGlzIGFuIGBPYmplY3RgIHdob3Nlc1xuICogcHJvcGVydGllcyBhcmUgYXJyYXlzIG9mIHZhbHVlcyB3aGljaCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZ3JvdXBCeUxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICByZXR1cm4gbWFwTGltaXQkMShjb2xsLCBsaW1pdCwgKHZhbCwgaXRlckNiKSA9PiB7XG4gICAgICAgIF9pdGVyYXRlZSh2YWwsIChlcnIsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJDYihlcnIsIHtrZXksIHZhbH0pO1xuICAgICAgICB9KTtcbiAgICB9LCAoZXJyLCBtYXBSZXN1bHRzKSA9PiB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gZnJvbSBNRE4sIGhhbmRsZSBvYmplY3QgaGF2aW5nIGFuIGBoYXNPd25Qcm9wZXJ0eWAgcHJvcFxuICAgICAgICB2YXIge2hhc093blByb3BlcnR5fSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBSZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWFwUmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgIHZhciB7a2V5fSA9IG1hcFJlc3VsdHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHt2YWx9ID0gbWFwUmVzdWx0c1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBbdmFsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgIH0pO1xufVxuXG52YXIgZ3JvdXBCeUxpbWl0JDEgPSBhd2FpdGlmeShncm91cEJ5TGltaXQsIDQpO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHZhbHVlIGNvcnJlc3BvbmRzIHRvIGFuIGFycmF5IG9mIGl0ZW1zLCBmcm9tXG4gKiBgY29sbGAsIHRoYXQgcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LiBUaGF0IGlzLCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0XG4gKiBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBgaXRlcmF0ZWVgIGNhbGxiYWNrLlxuICpcbiAqIE5vdGU6IFNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsXG4gKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci5cbiAqIEhvd2V2ZXIsIHRoZSB2YWx1ZXMgZm9yIGVhY2gga2V5IGluIHRoZSBgcmVzdWx0YCB3aWxsIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzXG4gKiB0aGUgb3JpZ2luYWwgYGNvbGxgLiBGb3IgT2JqZWN0cywgdGhlIHZhbHVlcyB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mXG4gKiB0aGUgb3JpZ2luYWwgT2JqZWN0cycga2V5cyAoYnV0IHRoaXMgY2FuIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuXG4gKlxuICogQG5hbWUgZ3JvdXBCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYGtleWAgdG8gZ3JvdXAgdGhlIHZhbHVlIHVuZGVyLlxuICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdCBpcyBhbiBgT2JqZWN0YCB3aG9zZXNcbiAqIHByb3BlcnRpZXMgYXJlIGFycmF5cyBvZiB2YWx1ZXMgd2hpY2ggcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGRpcjEgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMS50eHQsIGZpbGUyLnR4dFxuICogLy8gZGlyMiBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGUzLnR4dCwgZmlsZTQudHh0XG4gKiAvLyBkaXIzIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTUudHh0XG4gKiAvLyBkaXI0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogY29uc3QgZmlsZXMgPSBbJ2RpcjEvZmlsZTEudHh0JywnZGlyMicsJ2RpcjQnXVxuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGRldGVjdHMgZmlsZSB0eXBlIGFzIG5vbmUsIGZpbGUsIG9yIGRpcmVjdG9yeVxuICogZnVuY3Rpb24gZGV0ZWN0RmlsZShmaWxlLCBjYWxsYmFjaykge1xuICogICAgIGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnbm9uZScpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdkaXJlY3RvcnknIDogJ2ZpbGUnKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiAvL1VzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMuZ3JvdXBCeShmaWxlcywgZGV0ZWN0RmlsZSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICBpZihlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9IGVsc2Uge1xuICpcdCAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyB7XG4gKiAgICAgICAgIC8vICAgICBmaWxlOiBbICdkaXIxL2ZpbGUxLnR4dCcgXSxcbiAqICAgICAgICAgLy8gICAgIG5vbmU6IFsgJ2RpcjQnIF0sXG4gKiAgICAgICAgIC8vICAgICBkaXJlY3Rvcnk6IFsgJ2RpcjInXVxuICogICAgICAgICAvLyB9XG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgZ3JvdXBlZCBieSB0eXBlXG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmdyb3VwQnkoZmlsZXMsIGRldGVjdEZpbGUpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIHtcbiAqICAgICAvLyAgICAgZmlsZTogWyAnZGlyMS9maWxlMS50eHQnIF0sXG4gKiAgICAgLy8gICAgIG5vbmU6IFsgJ2RpcjQnIF0sXG4gKiAgICAgLy8gICAgIGRpcmVjdG9yeTogWyAnZGlyMiddXG4gKiAgICAgLy8gfVxuICogICAgIC8vIHJlc3VsdCBpcyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgZ3JvdXBlZCBieSB0eXBlXG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMuZ3JvdXBCeShmaWxlcywgZGV0ZWN0RmlsZSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIHtcbiAqICAgICAgICAgLy8gICAgIGZpbGU6IFsgJ2RpcjEvZmlsZTEudHh0JyBdLFxuICogICAgICAgICAvLyAgICAgbm9uZTogWyAnZGlyNCcgXSxcbiAqICAgICAgICAgLy8gICAgIGRpcmVjdG9yeTogWyAnZGlyMiddXG4gKiAgICAgICAgIC8vIH1cbiAqICAgICAgICAgLy8gcmVzdWx0IGlzIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyBncm91cGVkIGJ5IHR5cGVcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIGdyb3VwQnkgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBncm91cEJ5TGltaXQkMShjb2xsLCBJbmZpbml0eSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZ3JvdXBCeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZ3JvdXBCeVNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZ3JvdXBCeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBga2V5YCB0byBncm91cCB0aGUgdmFsdWUgdW5kZXIuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0IGlzIGFuIGBPYmplY3RgIHdob3NlXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBncm91cEJ5U2VyaWVzIChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZ3JvdXBCeUxpbWl0JDEoY29sbCwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIExvZ3MgdGhlIHJlc3VsdCBvZiBhbiBgYXN5bmNgIGZ1bmN0aW9uIHRvIHRoZSBgY29uc29sZWAuIE9ubHkgd29ya3MgaW5cbiAqIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmxvZ2AgYW5kIGBjb25zb2xlLmVycm9yYCAoc3VjaFxuICogYXMgRkYgYW5kIENocm9tZSkuIElmIG11bHRpcGxlIGFyZ3VtZW50cyBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgYXN5bmNcbiAqIGZ1bmN0aW9uLCBgY29uc29sZS5sb2dgIGlzIGNhbGxlZCBvbiBlYWNoIGFyZ3VtZW50IGluIG9yZGVyLlxuICpcbiAqIEBuYW1lIGxvZ1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseVxuICogYWxsIGFyZ3VtZW50cyB0by5cbiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBpbiBhIG1vZHVsZVxuICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnaGVsbG8gJyArIG5hbWUpO1xuICogICAgIH0sIDEwMDApO1xuICogfTtcbiAqXG4gKiAvLyBpbiB0aGUgbm9kZSByZXBsXG4gKiBub2RlPiBhc3luYy5sb2coaGVsbG8sICd3b3JsZCcpO1xuICogJ2hlbGxvIHdvcmxkJ1xuICovXG52YXIgbG9nID0gY29uc29sZUZ1bmMoJ2xvZycpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgbWFwVmFsdWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcFZhbHVlc0xpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBWYWx1ZXNde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHZhbHVlIGFuZCBrZXlcbiAqIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nXG4gKiBvZiBlYWNoIGtleSBmcm9tIGBvYmpgLCB3aXRoIGVhY2ggdHJhbnNmb3JtZWQgdmFsdWUgb24gdGhlIHJpZ2h0LWhhbmQgc2lkZS5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlc0xpbWl0KG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gICAgdmFyIG5ld09iaiA9IHt9O1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHJldHVybiBlYWNoT2ZMaW1pdCQyKGxpbWl0KShvYmosICh2YWwsIGtleSwgbmV4dCkgPT4ge1xuICAgICAgICBfaXRlcmF0ZWUodmFsLCBrZXksIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgICAgICAgIG5ld09ialtrZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4gY2FsbGJhY2soZXJyLCBuZXdPYmopKTtcbn1cblxudmFyIG1hcFZhbHVlc0xpbWl0JDEgPSBhd2FpdGlmeShtYXBWYWx1ZXNMaW1pdCwgNCk7XG5cbi8qKlxuICogQSByZWxhdGl2ZSBvZiBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LCBkZXNpZ25lZCBmb3IgdXNlIHdpdGggb2JqZWN0cy5cbiAqXG4gKiBQcm9kdWNlcyBhIG5ldyBPYmplY3QgYnkgbWFwcGluZyBlYWNoIHZhbHVlIG9mIGBvYmpgIHRocm91Z2ggdGhlIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgZWFjaCBgdmFsdWVgIGFuZCBga2V5YCBmcm9tIGBvYmpgIGFuZCBhXG4gKiBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja3MgdGFrZXNcbiAqIHR3byBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBvYmpgLiBJZiBgaXRlcmF0ZWVgXG4gKiBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBtYXBWYWx1ZXNgXG4gKiBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoZSBvcmRlciBvZiB0aGUga2V5cyBpbiB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkLiAgVGhlIGtleXMgd2lsbFxuICogYmUgcm91Z2hseSBpbiB0aGUgb3JkZXIgdGhleSBjb21wbGV0ZSwgKGJ1dCB0aGlzIGlzIHZlcnkgZW5naW5lLXNwZWNpZmljKVxuICpcbiAqIEBuYW1lIG1hcFZhbHVlc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gKiBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlNC50eHQgZG9lcyBub3QgZXhpc3RcbiAqXG4gKiBjb25zdCBmaWxlTWFwID0ge1xuICogICAgIGYxOiAnZmlsZTEudHh0JyxcbiAqICAgICBmMjogJ2ZpbGUyLnR4dCcsXG4gKiAgICAgZjM6ICdmaWxlMy50eHQnXG4gKiB9O1xuICpcbiAqIGNvbnN0IHdpdGhNaXNzaW5nRmlsZU1hcCA9IHtcbiAqICAgICBmMTogJ2ZpbGUxLnR4dCcsXG4gKiAgICAgZjI6ICdmaWxlMi50eHQnLFxuICogICAgIGYzOiAnZmlsZTQudHh0J1xuICogfTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXNcbiAqIGZ1bmN0aW9uIGdldEZpbGVTaXplSW5CeXRlcyhmaWxlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdC5zaXplKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLm1hcFZhbHVlcyhmaWxlTWFwLCBnZXRGaWxlU2l6ZUluQnl0ZXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBub3cgYSBtYXAgb2YgZmlsZSBzaXplIGluIGJ5dGVzIGZvciBlYWNoIGZpbGUsIGUuZy5cbiAqICAgICAgICAgLy8ge1xuICogICAgICAgICAvLyAgICAgZjE6IDEwMDAsXG4gKiAgICAgICAgIC8vICAgICBmMjogMjAwMCxcbiAqICAgICAgICAgLy8gICAgIGYzOiAzMDAwXG4gKiAgICAgICAgIC8vIH1cbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBoYW5kbGluZ1xuICogYXN5bmMubWFwVmFsdWVzKHdpdGhNaXNzaW5nRmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5tYXBWYWx1ZXMoZmlsZU1hcCwgZ2V0RmlsZVNpemVJbkJ5dGVzKVxuICogLnRoZW4oIHJlc3VsdCA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAvLyByZXN1bHQgaXMgbm93IGEgbWFwIG9mIGZpbGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaCBmaWxlLCBlLmcuXG4gKiAgICAgLy8ge1xuICogICAgIC8vICAgICBmMTogMTAwMCxcbiAqICAgICAvLyAgICAgZjI6IDIwMDAsXG4gKiAgICAgLy8gICAgIGYzOiAzMDAwXG4gKiAgICAgLy8gfVxuICogfSkuY2F0Y2ggKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIEVycm9yIEhhbmRsaW5nXG4gKiBhc3luYy5tYXBWYWx1ZXMod2l0aE1pc3NpbmdGaWxlTWFwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogfSkuY2F0Y2ggKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAvLyBbIEVycm9yOiBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkgXVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgYXN5bmMubWFwVmFsdWVzKGZpbGVNYXAsIGdldEZpbGVTaXplSW5CeXRlcyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBub3cgYSBtYXAgb2YgZmlsZSBzaXplIGluIGJ5dGVzIGZvciBlYWNoIGZpbGUsIGUuZy5cbiAqICAgICAgICAgLy8ge1xuICogICAgICAgICAvLyAgICAgZjE6IDEwMDAsXG4gKiAgICAgICAgIC8vICAgICBmMjogMjAwMCxcbiAqICAgICAgICAgLy8gICAgIGYzOiAzMDAwXG4gKiAgICAgICAgIC8vIH1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5tYXBWYWx1ZXMod2l0aE1pc3NpbmdGaWxlTWFwLCBnZXRGaWxlU2l6ZUluQnl0ZXMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1hcFZhbHVlc0xpbWl0JDEob2JqLCBJbmZpbml0eSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgbWFwVmFsdWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcFZhbHVlc1Nlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWFwVmFsdWVzXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gKiBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBtYXBWYWx1ZXNTZXJpZXMob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWFwVmFsdWVzTGltaXQkMShvYmosIDEsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cblxuLyoqXG4gKiBDYWNoZXMgdGhlIHJlc3VsdHMgb2YgYW4gYXN5bmMgZnVuY3Rpb24uIFdoZW4gY3JlYXRpbmcgYSBoYXNoIHRvIHN0b3JlXG4gKiBmdW5jdGlvbiByZXN1bHRzIGFnYWluc3QsIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkIGZyb20gdGhlIGhhc2ggYW5kIGFuXG4gKiBvcHRpb25hbCBoYXNoIGZ1bmN0aW9uIGNhbiBiZSB1c2VkLlxuICpcbiAqICoqTm90ZTogaWYgdGhlIGFzeW5jIGZ1bmN0aW9uIGVycnMsIHRoZSByZXN1bHQgd2lsbCBub3QgYmUgY2FjaGVkIGFuZFxuICogc3Vic2VxdWVudCBjYWxscyB3aWxsIGNhbGwgdGhlIHdyYXBwZWQgZnVuY3Rpb24uKipcbiAqXG4gKiBJZiBubyBoYXNoIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoYXNoIGtleSxcbiAqIHdoaWNoIG1heSB3b3JrIHJlYXNvbmFibHkgaWYgaXQgaXMgYSBzdHJpbmcgb3IgYSBkYXRhIHR5cGUgdGhhdCBjb252ZXJ0cyB0byBhXG4gKiBkaXN0aW5jdCBzdHJpbmcuIE5vdGUgdGhhdCBvYmplY3RzIGFuZCBhcnJheXMgd2lsbCBub3QgYmVoYXZlIHJlYXNvbmFibHkuXG4gKiBOZWl0aGVyIHdpbGwgY2FzZXMgd2hlcmUgdGhlIG90aGVyIGFyZ3VtZW50cyBhcmUgc2lnbmlmaWNhbnQuIEluIHN1Y2ggY2FzZXMsXG4gKiBzcGVjaWZ5IHlvdXIgb3duIGhhc2ggZnVuY3Rpb24uXG4gKlxuICogVGhlIGNhY2hlIG9mIHJlc3VsdHMgaXMgZXhwb3NlZCBhcyB0aGUgYG1lbW9gIHByb3BlcnR5IG9mIHRoZSBmdW5jdGlvblxuICogcmV0dXJuZWQgYnkgYG1lbW9pemVgLlxuICpcbiAqIEBuYW1lIG1lbW9pemVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIHByb3h5IGFuZCBjYWNoZSByZXN1bHRzIGZyb20uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNoZXIgLSBBbiBvcHRpb25hbCBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhIGN1c3RvbSBoYXNoXG4gKiBmb3Igc3RvcmluZyByZXN1bHRzLiBJdCBoYXMgYWxsIHRoZSBhcmd1bWVudHMgYXBwbGllZCB0byBpdCBhcGFydCBmcm9tIHRoZVxuICogY2FsbGJhY2ssIGFuZCBtdXN0IGJlIHN5bmNocm9ub3VzLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IGEgbWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBzbG93X2ZuID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmdcbiAqICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICogfTtcbiAqIHZhciBmbiA9IGFzeW5jLm1lbW9pemUoc2xvd19mbik7XG4gKlxuICogLy8gZm4gY2FuIG5vdyBiZSB1c2VkIGFzIGlmIGl0IHdlcmUgc2xvd19mblxuICogZm4oJ3NvbWUgbmFtZScsIGZ1bmN0aW9uKCkge1xuICogICAgIC8vIGNhbGxiYWNrXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmbiwgaGFzaGVyID0gdiA9PiB2KSB7XG4gICAgdmFyIG1lbW8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBxdWV1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHZhciBtZW1vaXplZCA9IGluaXRpYWxQYXJhbXMoKGFyZ3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHZhciBrZXkgPSBoYXNoZXIoLi4uYXJncyk7XG4gICAgICAgIGlmIChrZXkgaW4gbWVtbykge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoKCkgPT4gY2FsbGJhY2sobnVsbCwgLi4ubWVtb1trZXldKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XG4gICAgICAgICAgICBfZm4oLi4uYXJncywgKGVyciwgLi4ucmVzdWx0QXJncykgPT4ge1xuICAgICAgICAgICAgICAgIC8vICMxNDY1IGRvbid0IG1lbW9pemUgaWYgYW4gZXJyb3Igb2NjdXJyZWRcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSByZXN1bHRBcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHFbaV0oZXJyLCAuLi5yZXN1bHRBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5cbi8qKlxuICogQ2FsbHMgYGNhbGxiYWNrYCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kIHRoZSBldmVudCBsb29wLiBJbiBOb2RlLmpzIHRoaXMganVzdFxuICogY2FsbHMgYHByb2Nlc3MubmV4dFRpY2tgLiAgSW4gdGhlIGJyb3dzZXIgaXQgd2lsbCB1c2UgYHNldEltbWVkaWF0ZWAgaWZcbiAqIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKWAsIHdoaWNoIG1lYW5zIG90aGVyIGhpZ2hlclxuICogcHJpb3JpdHkgZXZlbnRzIG1heSBwcmVjZWRlIHRoZSBleGVjdXRpb24gb2YgYGNhbGxiYWNrYC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBmb3IgYnJvd3Nlci1jb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuICpcbiAqIEBuYW1lIG5leHRUaWNrXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zZXRJbW1lZGlhdGVde0BsaW5rIG1vZHVsZTpVdGlscy5zZXRJbW1lZGlhdGV9XG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kXG4gKiB0aGUgZXZlbnQgbG9vcC4gSW52b2tlZCB3aXRoIChhcmdzLi4uKS5cbiAqIEBwYXJhbSB7Li4uKn0gYXJncy4uLiAtIGFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGNhbGxiYWNrIG9uIHRoZSBuZXh0IHRpY2suXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBjYWxsX29yZGVyID0gW107XG4gKiBhc3luYy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAqICAgICBjYWxsX29yZGVyLnB1c2goJ3R3bycpO1xuICogICAgIC8vIGNhbGxfb3JkZXIgbm93IGVxdWFscyBbJ29uZScsJ3R3byddXG4gKiB9KTtcbiAqIGNhbGxfb3JkZXIucHVzaCgnb25lJyk7XG4gKlxuICogYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gKiAgICAgLy8gYSwgYiwgYW5kIGMgZXF1YWwgMSwgMiwgYW5kIDNcbiAqIH0sIDEsIDIsIDMpO1xuICovXG52YXIgX2RlZmVyO1xuXG5pZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIgPSBwcm9jZXNzLm5leHRUaWNrO1xufSBlbHNlIGlmIChoYXNTZXRJbW1lZGlhdGUpIHtcbiAgICBfZGVmZXIgPSBzZXRJbW1lZGlhdGU7XG59IGVsc2Uge1xuICAgIF9kZWZlciA9IGZhbGxiYWNrO1xufVxuXG52YXIgbmV4dFRpY2sgPSB3cmFwKF9kZWZlcik7XG5cbnZhciBfcGFyYWxsZWwgPSBhd2FpdGlmeSgoZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spID0+IHtcbiAgICB2YXIgcmVzdWx0cyA9IGlzQXJyYXlMaWtlKHRhc2tzKSA/IFtdIDoge307XG5cbiAgICBlYWNoZm4odGFza3MsICh0YXNrLCBrZXksIHRhc2tDYikgPT4ge1xuICAgICAgICB3cmFwQXN5bmModGFzaykoKGVyciwgLi4ucmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBbcmVzdWx0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHRhc2tDYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4gY2FsbGJhY2soZXJyLCByZXN1bHRzKSk7XG59LCAzKTtcblxuLyoqXG4gKiBSdW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbFxuICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBvZiB0aGUgZnVuY3Rpb25zIHBhc3MgYW4gZXJyb3IgdG9cbiAqIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlXG4gKiBlcnJvci4gT25jZSB0aGUgYHRhc2tzYCBoYXZlIGNvbXBsZXRlZCwgdGhlIHJlc3VsdHMgYXJlIHBhc3NlZCB0byB0aGUgZmluYWxcbiAqIGBjYWxsYmFja2AgYXMgYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIGBwYXJhbGxlbGAgaXMgYWJvdXQga2lja2luZy1vZmYgSS9PIHRhc2tzIGluIHBhcmFsbGVsLCBub3QgYWJvdXRcbiAqIHBhcmFsbGVsIGV4ZWN1dGlvbiBvZiBjb2RlLiAgSWYgeW91ciB0YXNrcyBkbyBub3QgdXNlIGFueSB0aW1lcnMgb3IgcGVyZm9ybVxuICogYW55IEkvTywgdGhleSB3aWxsIGFjdHVhbGx5IGJlIGV4ZWN1dGVkIGluIHNlcmllcy4gIEFueSBzeW5jaHJvbm91cyBzZXR1cFxuICogc2VjdGlvbnMgZm9yIGVhY2ggdGFzayB3aWxsIGhhcHBlbiBvbmUgYWZ0ZXIgdGhlIG90aGVyLiAgSmF2YVNjcmlwdCByZW1haW5zXG4gKiBzaW5nbGUtdGhyZWFkZWQuXG4gKlxuICogKipIaW50OioqIFVzZSBbYHJlZmxlY3RgXXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH0gdG8gY29udGludWUgdGhlXG4gKiBleGVjdXRpb24gb2Ygb3RoZXIgdGFza3Mgd2hlbiBhIHRhc2sgZmFpbHMuXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbFxuICogYmUgcnVuIGFzIGEgZnVuY3Rpb24gYW5kIHRoZSByZXN1bHRzIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmaW5hbCBgY2FsbGJhY2tgXG4gKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZ1xuICogcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5wYXJhbGxlbH0uXG4gKlxuICogQG5hbWUgcGFyYWxsZWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIG9mXG4gKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byBydW4uXG4gKiBFYWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGVcbiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXlcbiAqIChvciBvYmplY3QpIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgdGFzayBjYWxsYmFja3MuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG5vdCBwYXNzZWRcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vVXNpbmcgQ2FsbGJhY2tzXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddIGV2ZW4gdGhvdWdoXG4gKiAgICAgLy8gdGhlIHNlY29uZCBmdW5jdGlvbiBoYWQgYSBzaG9ydGVyIHRpbWVvdXQuXG4gKiB9KTtcbiAqXG4gKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gKiBhc3luYy5wYXJhbGxlbCh7XG4gKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAqIH0pO1xuICpcbiAqIC8vVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnBhcmFsbGVsKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdKS50aGVuKHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXSBldmVuIHRob3VnaFxuICogICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LlxuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICogYXN5bmMucGFyYWxsZWwoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfSkudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnBhcmFsbGVsKFtcbiAqICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgXSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2hcbiAqICAgICAgICAgLy8gdGhlIHNlY29uZCBmdW5jdGlvbiBoYWQgYSBzaG9ydGVyIHRpbWVvdXQuXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMucGFyYWxsZWwoe1xuICogICAgICAgICAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpO1xuICogICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAqICAgICAgICAgICAgfVxuICogICAgICAgICB9KTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG86IHsgb25lOiAxLCB0d286IDIgfVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gcGFyYWxsZWwodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9wYXJhbGxlbChlYWNoT2YkMSwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHBhcmFsbGVsYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnBhcmFsbGVsfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgcGFyYWxsZWxMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucGFyYWxsZWxde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIG9mXG4gKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byBydW4uXG4gKiBFYWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGVcbiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXlcbiAqIChvciBvYmplY3QpIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgdGFzayBjYWxsYmFja3MuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG5vdCBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gcGFyYWxsZWxMaW1pdCh0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9wYXJhbGxlbChlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBBIHF1ZXVlIG9mIHRhc2tzIGZvciB0aGUgd29ya2VyIGZ1bmN0aW9uIHRvIGNvbXBsZXRlLlxuICogQHR5cGVkZWYge0l0ZXJhYmxlfSBRdWV1ZU9iamVjdFxuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGVuZ3RoIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5sZW5ndGgoKWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWQgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbnlcbiAqIGl0ZW1zIGhhdmUgYmVlbiBwdXNoZWQgYW5kIHByb2Nlc3NlZCBieSB0aGUgcXVldWUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBydW5uaW5nIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJ1bm5pbmcoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB3b3JrZXJzTGlzdCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhcnJheSBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLndvcmtlcnNMaXN0KClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2Ugd2l0aCBgcXVldWUuaWRsZSgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb25jdXJyZW5jeSAtIGFuIGludGVnZXIgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhXG4gKiBgcXVldWVgIGlzIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIGNvbmN1cnJlbmN5IG9uLXRoZS1mbHkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGF5bG9hZCAtIGFuIGludGVnZXIgdGhhdCBzcGVjaWZpZXMgaG93IG1hbnkgaXRlbXMgYXJlXG4gKiBwYXNzZWQgdG8gdGhlIHdvcmtlciBmdW5jdGlvbiBhdCBhIHRpbWUuIG9ubHkgYXBwbGllcyBpZiB0aGlzIGlzIGFcbiAqIFtjYXJnb117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNhcmdvfSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7QXN5bmNGdW5jdGlvbn0gcHVzaCAtIGFkZCBhIG5ldyB0YXNrIHRvIHRoZSBgcXVldWVgLiBDYWxscyBgY2FsbGJhY2tgXG4gKiBvbmNlIHRoZSBgd29ya2VyYCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgdGFzay4gSW5zdGVhZCBvZiBhIHNpbmdsZSB0YXNrLFxuICogYSBgdGFza3NgIGFycmF5IGNhbiBiZSBzdWJtaXR0ZWQuIFRoZSByZXNwZWN0aXZlIGNhbGxiYWNrIGlzIHVzZWQgZm9yIGV2ZXJ5XG4gKiB0YXNrIGluIHRoZSBsaXN0LiBJbnZva2Ugd2l0aCBgcXVldWUucHVzaCh0YXNrLCBbY2FsbGJhY2tdKWAsXG4gKiBAcHJvcGVydHkge0FzeW5jRnVuY3Rpb259IHVuc2hpZnQgLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgZnJvbnQgb2YgdGhlIGBxdWV1ZWAuXG4gKiBJbnZva2Ugd2l0aCBgcXVldWUudW5zaGlmdCh0YXNrLCBbY2FsbGJhY2tdKWAuXG4gKiBAcHJvcGVydHkge0FzeW5jRnVuY3Rpb259IHB1c2hBc3luYyAtIHRoZSBzYW1lIGFzIGBxLnB1c2hgLCBleGNlcHQgdGhpcyByZXR1cm5zXG4gKiBhIHByb21pc2UgdGhhdCByZWplY3RzIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAqIEBwcm9wZXJ0eSB7QXN5bmNGdW5jdGlvbn0gdW5zaGlmdEFzeW5jIC0gdGhlIHNhbWUgYXMgYHEudW5zaGlmdGAsIGV4Y2VwdCB0aGlzIHJldHVybnNcbiAqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVtb3ZlIC0gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHF1ZXVlIHRoYXQgbWF0Y2ggYSB0ZXN0XG4gKiBmdW5jdGlvbi4gIFRoZSB0ZXN0IGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGFuIG9iamVjdCB3aXRoIGEgYGRhdGFgIHByb3BlcnR5LFxuICogYW5kIGEgYHByaW9yaXR5YCBwcm9wZXJ0eSwgaWYgdGhpcyBpcyBhXG4gKiBbcHJpb3JpdHlRdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnByaW9yaXR5UXVldWV9IG9iamVjdC5cbiAqIEludm9rZWQgd2l0aCBgcXVldWUucmVtb3ZlKHRlc3RGbilgLCB3aGVyZSBgdGVzdEZuYCBpcyBvZiB0aGUgZm9ybVxuICogYGZ1bmN0aW9uICh7ZGF0YSwgcHJpb3JpdHl9KSB7fWAgYW5kIHJldHVybnMgYSBCb29sZWFuLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2F0dXJhdGVkIC0gYSBmdW5jdGlvbiB0aGF0IHNldHMgYSBjYWxsYmFjayB0aGF0IGlzXG4gKiBjYWxsZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHJ1bm5pbmcgd29ya2VycyBoaXRzIHRoZSBgY29uY3VycmVuY3lgIGxpbWl0LCBhbmRcbiAqIGZ1cnRoZXIgdGFza3Mgd2lsbCBiZSBxdWV1ZWQuICBJZiB0aGUgY2FsbGJhY2sgaXMgb21pdHRlZCwgYHEuc2F0dXJhdGVkKClgXG4gKiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIG5leHQgb2NjdXJyZW5jZS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2F0dXJhdGVkIC0gYSBmdW5jdGlvbiB0aGF0IHNldHMgYSBjYWxsYmFjayB0aGF0IGlzXG4gKiBjYWxsZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHJ1bm5pbmcgd29ya2VycyBpcyBsZXNzIHRoYW4gdGhlIGBjb25jdXJyZW5jeWAgJlxuICogYGJ1ZmZlcmAgbGltaXRzLCBhbmQgZnVydGhlciB0YXNrcyB3aWxsIG5vdCBiZSBxdWV1ZWQuIElmIHRoZSBjYWxsYmFjayBpc1xuICogb21pdHRlZCwgYHEudW5zYXR1cmF0ZWQoKWAgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBuZXh0IG9jY3VycmVuY2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnVmZmVyIC0gQSBtaW5pbXVtIHRocmVzaG9sZCBidWZmZXIgaW4gb3JkZXIgdG8gc2F5IHRoYXRcbiAqIHRoZSBgcXVldWVgIGlzIGB1bnNhdHVyYXRlZGAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlbXB0eSAtIGEgZnVuY3Rpb24gdGhhdCBzZXRzIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWRcbiAqIHdoZW4gdGhlIGxhc3QgaXRlbSBmcm9tIHRoZSBgcXVldWVgIGlzIGdpdmVuIHRvIGEgYHdvcmtlcmAuIElmIHRoZSBjYWxsYmFja1xuICogaXMgb21pdHRlZCwgYHEuZW1wdHkoKWAgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBuZXh0IG9jY3VycmVuY2UuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIGEgZnVuY3Rpb24gdGhhdCBzZXRzIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWRcbiAqIHdoZW4gdGhlIGxhc3QgaXRlbSBmcm9tIHRoZSBgcXVldWVgIGhhcyByZXR1cm5lZCBmcm9tIHRoZSBgd29ya2VyYC4gSWYgdGhlXG4gKiBjYWxsYmFjayBpcyBvbWl0dGVkLCBgcS5kcmFpbigpYCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIG5leHQgb2NjdXJyZW5jZS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVycm9yIC0gYSBmdW5jdGlvbiB0aGF0IHNldHMgYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZFxuICogd2hlbiBhIHRhc2sgZXJyb3JzLiBIYXMgdGhlIHNpZ25hdHVyZSBgZnVuY3Rpb24oZXJyb3IsIHRhc2spYC4gSWYgdGhlXG4gKiBjYWxsYmFjayBpcyBvbWl0dGVkLCBgZXJyb3IoKWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZWplY3RzIG9uIHRoZSBuZXh0XG4gKiBlcnJvci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGF1c2VkIC0gYSBib29sZWFuIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBxdWV1ZSBpc1xuICogaW4gYSBwYXVzZWQgc3RhdGUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwYXVzZSAtIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGFza3NcbiAqIHVudGlsIGByZXN1bWUoKWAgaXMgY2FsbGVkLiBJbnZva2Ugd2l0aCBgcXVldWUucGF1c2UoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXN1bWUgLSBhIGZ1bmN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZlxuICogcXVldWVkIHRhc2tzIHdoZW4gdGhlIHF1ZXVlIGlzIHBhdXNlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJlc3VtZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGtpbGwgLSBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgYGRyYWluYCBjYWxsYmFjayBhbmRcbiAqIGVtcHRpZXMgcmVtYWluaW5nIHRhc2tzIGZyb20gdGhlIHF1ZXVlIGZvcmNpbmcgaXQgdG8gZ28gaWRsZS4gTm8gbW9yZSB0YXNrc1xuICogc2hvdWxkIGJlIHB1c2hlZCB0byB0aGUgcXVldWUgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBJbnZva2Ugd2l0aCBgcXVldWUua2lsbCgpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcSA9IGFzeW5jLnF1ZXVlKHdvcmtlciwgMilcbiAqIHEucHVzaChpdGVtMSlcbiAqIHEucHVzaChpdGVtMilcbiAqIHEucHVzaChpdGVtMylcbiAqIC8vIHF1ZXVlcyBhcmUgaXRlcmFibGUsIHNwcmVhZCBpbnRvIGFuIGFycmF5IHRvIGluc3BlY3RcbiAqIGNvbnN0IGl0ZW1zID0gWy4uLnFdIC8vIFtpdGVtMSwgaXRlbTIsIGl0ZW0zXVxuICogLy8gb3IgdXNlIGZvciBvZlxuICogZm9yIChsZXQgaXRlbSBvZiBxKSB7XG4gKiAgICAgY29uc29sZS5sb2coaXRlbSlcbiAqIH1cbiAqXG4gKiBxLmRyYWluKCgpID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygnYWxsIGRvbmUnKVxuICogfSlcbiAqIC8vIG9yXG4gKiBhd2FpdCBxLmRyYWluKClcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgcXVldWVgIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgYGNvbmN1cnJlbmN5YC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBgcXVldWVgIGFyZSBwcm9jZXNzZWQgaW4gcGFyYWxsZWwgKHVwIHRvIHRoZSBgY29uY3VycmVuY3lgIGxpbWl0KS4gSWYgYWxsXG4gKiBgd29ya2VyYHMgYXJlIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgb25lIGJlY29tZXMgYXZhaWxhYmxlLlxuICogT25jZSBhIGB3b3JrZXJgIGNvbXBsZXRlcyBhIGB0YXNrYCwgdGhhdCBgdGFza2AncyBjYWxsYmFjayBpcyBjYWxsZWQuXG4gKlxuICogQG5hbWUgcXVldWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZWQgdGFzay5cbiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0b1xuICogYHEucHVzaCgpYC4gSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PTFdIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueVxuICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3lcbiAqIGRlZmF1bHRzIHRvIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgcXVldWUgb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW4gYmVcbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIHF1ZXVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBjcmVhdGUgYSBxdWV1ZSBvYmplY3Qgd2l0aCBjb25jdXJyZW5jeSAyXG4gKiB2YXIgcSA9IGFzeW5jLnF1ZXVlKGZ1bmN0aW9uKHRhc2ssIGNhbGxiYWNrKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrLm5hbWUpO1xuICogICAgIGNhbGxiYWNrKCk7XG4gKiB9LCAyKTtcbiAqXG4gKiAvLyBhc3NpZ24gYSBjYWxsYmFja1xuICogcS5kcmFpbihmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZygnYWxsIGl0ZW1zIGhhdmUgYmVlbiBwcm9jZXNzZWQnKTtcbiAqIH0pO1xuICogLy8gb3IgYXdhaXQgdGhlIGVuZFxuICogYXdhaXQgcS5kcmFpbigpXG4gKlxuICogLy8gYXNzaWduIGFuIGVycm9yIGNhbGxiYWNrXG4gKiBxLmVycm9yKGZ1bmN0aW9uKGVyciwgdGFzaykge1xuICogICAgIGNvbnNvbGUuZXJyb3IoJ3Rhc2sgZXhwZXJpZW5jZWQgYW4gZXJyb3InKTtcbiAqIH0pO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBxdWV1ZVxuICogcS5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiAvLyBjYWxsYmFjayBpcyBvcHRpb25hbFxuICogcS5wdXNoKHtuYW1lOiAnYmFyJ30pO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBxdWV1ZSAoYmF0Y2gtd2lzZSlcbiAqIHEucHVzaChbe25hbWU6ICdiYXonfSx7bmFtZTogJ2JheSd9LHtuYW1lOiAnYmF4J31dLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBpdGVtJyk7XG4gKiB9KTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gKiBxLnVuc2hpZnQoe25hbWU6ICdiYXInfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHF1ZXVlICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgdmFyIF93b3JrZXIgPSB3cmFwQXN5bmMod29ya2VyKTtcbiAgICByZXR1cm4gcXVldWUkMSgoaXRlbXMsIGNiKSA9PiB7XG4gICAgICAgIF93b3JrZXIoaXRlbXNbMF0sIGNiKTtcbiAgICB9LCBjb25jdXJyZW5jeSwgMSk7XG59XG5cbi8vIEJpbmFyeSBtaW4taGVhcCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBwcmlvcml0eSBxdWV1ZS5cbi8vIEltcGxlbWVudGF0aW9uIGlzIHN0YWJsZSwgaS5lLiBwdXNoIHRpbWUgaXMgY29uc2lkZXJlZCBmb3IgZXF1YWwgcHJpb3JpdGllc1xuY2xhc3MgSGVhcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xuICAgICAgICB0aGlzLnB1c2hDb3VudCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAubGVuZ3RoO1xuICAgIH1cblxuICAgIGVtcHR5ICgpIHtcbiAgICAgICAgdGhpcy5oZWFwID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHBlcmNVcChpbmRleCkge1xuICAgICAgICBsZXQgcDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPiAwICYmIHNtYWxsZXIodGhpcy5oZWFwW2luZGV4XSwgdGhpcy5oZWFwW3A9cGFyZW50KGluZGV4KV0pKSB7XG4gICAgICAgICAgICBsZXQgdCA9IHRoaXMuaGVhcFtpbmRleF07XG4gICAgICAgICAgICB0aGlzLmhlYXBbaW5kZXhdID0gdGhpcy5oZWFwW3BdO1xuICAgICAgICAgICAgdGhpcy5oZWFwW3BdID0gdDtcblxuICAgICAgICAgICAgaW5kZXggPSBwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGVyY0Rvd24oaW5kZXgpIHtcbiAgICAgICAgbGV0IGw7XG5cbiAgICAgICAgd2hpbGUgKChsPWxlZnRDaGkoaW5kZXgpKSA8IHRoaXMuaGVhcC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChsKzEgPCB0aGlzLmhlYXAubGVuZ3RoICYmIHNtYWxsZXIodGhpcy5oZWFwW2wrMV0sIHRoaXMuaGVhcFtsXSkpIHtcbiAgICAgICAgICAgICAgICBsID0gbCsxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc21hbGxlcih0aGlzLmhlYXBbaW5kZXhdLCB0aGlzLmhlYXBbbF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5oZWFwW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuaGVhcFtpbmRleF0gPSB0aGlzLmhlYXBbbF07XG4gICAgICAgICAgICB0aGlzLmhlYXBbbF0gPSB0O1xuXG4gICAgICAgICAgICBpbmRleCA9IGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKG5vZGUpIHtcbiAgICAgICAgbm9kZS5wdXNoQ291bnQgPSArK3RoaXMucHVzaENvdW50O1xuICAgICAgICB0aGlzLmhlYXAucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5wZXJjVXAodGhpcy5oZWFwLmxlbmd0aC0xKTtcbiAgICB9XG5cbiAgICB1bnNoaWZ0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcC5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIHNoaWZ0KCkge1xuICAgICAgICBsZXQgW3RvcF0gPSB0aGlzLmhlYXA7XG5cbiAgICAgICAgdGhpcy5oZWFwWzBdID0gdGhpcy5oZWFwW3RoaXMuaGVhcC5sZW5ndGgtMV07XG4gICAgICAgIHRoaXMuaGVhcC5wb3AoKTtcbiAgICAgICAgdGhpcy5wZXJjRG93bigwKTtcblxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpc107XG4gICAgfVxuXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhlYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuaGVhcFtpXS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlICh0ZXN0Rm4pIHtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGVhcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0ZXN0Rm4odGhpcy5oZWFwW2ldKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcFtqXSA9IHRoaXMuaGVhcFtpXTtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhlYXAuc3BsaWNlKGopO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXJlbnQodGhpcy5oZWFwLmxlbmd0aC0xKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMucGVyY0Rvd24oaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxlZnRDaGkoaSkge1xuICAgIHJldHVybiAoaTw8MSkrMTtcbn1cblxuZnVuY3Rpb24gcGFyZW50KGkpIHtcbiAgICByZXR1cm4gKChpKzEpPj4xKS0xO1xufVxuXG5mdW5jdGlvbiBzbWFsbGVyKHgsIHkpIHtcbiAgICBpZiAoeC5wcmlvcml0eSAhPT0geS5wcmlvcml0eSkge1xuICAgICAgICByZXR1cm4geC5wcmlvcml0eSA8IHkucHJpb3JpdHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geC5wdXNoQ291bnQgPCB5LnB1c2hDb3VudDtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IG9ubHkgdGFza3MgYXJlIGFzc2lnbmVkIGEgcHJpb3JpdHkgYW5kXG4gKiBjb21wbGV0ZWQgaW4gYXNjZW5kaW5nIHByaW9yaXR5IG9yZGVyLlxuICpcbiAqIEBuYW1lIHByaW9yaXR5UXVldWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGEgcXVldWVkIHRhc2suXG4gKiBJZiB5b3Ugd2FudCB0byBoYW5kbGUgZXJyb3JzIGZyb20gYW4gaW5kaXZpZHVhbCB0YXNrLCBwYXNzIGEgY2FsbGJhY2sgdG9cbiAqIGBxLnB1c2goKWAuXG4gKiBJbnZva2VkIHdpdGggKHRhc2ssIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb25jdXJyZW5jeSAtIEFuIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnkgYHdvcmtlcmBcbiAqIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5IGRlZmF1bHRzIHRvXG4gKiBgMWAuICBJZiB0aGUgY29uY3VycmVuY3kgaXMgYDBgLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyB7bW9kdWxlOkNvbnRyb2xGbG93LlF1ZXVlT2JqZWN0fSBBIHByaW9yaXR5UXVldWUgb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIFRoZXJlIGFyZSB0aHJlZVxuICogZGlmZmVyZW5jZXMgYmV0d2VlbiBgcXVldWVgIGFuZCBgcHJpb3JpdHlRdWV1ZWAgb2JqZWN0czpcbiAqICogYHB1c2godGFzaywgcHJpb3JpdHksIFtjYWxsYmFja10pYCAtIGBwcmlvcml0eWAgc2hvdWxkIGJlIGEgbnVtYmVyLiBJZiBhblxuICogICBhcnJheSBvZiBgdGFza3NgIGlzIGdpdmVuLCBhbGwgdGFza3Mgd2lsbCBiZSBhc3NpZ25lZCB0aGUgc2FtZSBwcmlvcml0eS5cbiAqICogYHB1c2hBc3luYyh0YXNrLCBwcmlvcml0eSwgW2NhbGxiYWNrXSlgIC0gdGhlIHNhbWUgYXMgYHByaW9yaXR5UXVldWUucHVzaGAsXG4gKiAgIGV4Y2VwdCB0aGlzIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVqZWN0cyBpZiBhbiBlcnJvciBvY2N1cnMuXG4gKiAqIFRoZSBgdW5zaGlmdGAgYW5kIGB1bnNoaWZ0QXN5bmNgIG1ldGhvZHMgd2VyZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiBwcmlvcml0eVF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgbm9ybWFsIHF1ZXVlXG4gICAgdmFyIHEgPSBxdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcblxuICAgIHZhciB7XG4gICAgICAgIHB1c2gsXG4gICAgICAgIHB1c2hBc3luY1xuICAgIH0gPSBxO1xuXG4gICAgcS5fdGFza3MgPSBuZXcgSGVhcCgpO1xuICAgIHEuX2NyZWF0ZVRhc2tJdGVtID0gKHtkYXRhLCBwcmlvcml0eX0sIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRhSXRlbXModGFza3MsIHByaW9yaXR5KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICAgIHJldHVybiB7ZGF0YTogdGFza3MsIHByaW9yaXR5fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFza3MubWFwKGRhdGEgPT4geyByZXR1cm4ge2RhdGEsIHByaW9yaXR5fTsgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHlcbiAgICBxLnB1c2ggPSBmdW5jdGlvbihkYXRhLCBwcmlvcml0eSA9IDAsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBwdXNoKGNyZWF0ZURhdGFJdGVtcyhkYXRhLCBwcmlvcml0eSksIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgcS5wdXNoQXN5bmMgPSBmdW5jdGlvbihkYXRhLCBwcmlvcml0eSA9IDAsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBwdXNoQXN5bmMoY3JlYXRlRGF0YUl0ZW1zKGRhdGEsIHByaW9yaXR5KSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvbnNcbiAgICBkZWxldGUgcS51bnNoaWZ0O1xuICAgIGRlbGV0ZSBxLnVuc2hpZnRBc3luYztcblxuICAgIHJldHVybiBxO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHBhcmFsbGVsLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlXG4gKiBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBPbmNlIGFueSBvZiB0aGUgYHRhc2tzYCBjb21wbGV0ZSBvciBwYXNzIGFuXG4gKiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLiBJdCdzXG4gKiBlcXVpdmFsZW50IHRvIGBQcm9taXNlLnJhY2UoKWAuXG4gKlxuICogQG5hbWUgcmFjZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheX0gdGFza3MgLSBBbiBhcnJheSBjb250YWluaW5nIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259XG4gKiB0byBydW4uIEVhY2ggZnVuY3Rpb24gY2FuIGNvbXBsZXRlIHdpdGggYW4gb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYW55IG9mIHRoZSBmdW5jdGlvbnMgaGF2ZVxuICogY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYW4gZXJyb3Igb3IgcmVzdWx0IGZyb20gdGhlIGZpcnN0IGZ1bmN0aW9uIHRoYXRcbiAqIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMucmFjZShbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSxcbiAqIC8vIG1haW4gY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gdGhlIHJlc3VsdCB3aWxsIGJlIGVxdWFsIHRvICd0d28nIGFzIGl0IGZpbmlzaGVzIGVhcmxpZXJcbiAqIH0pO1xuICovXG5mdW5jdGlvbiByYWNlKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHJhY2UgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKSk7XG4gICAgaWYgKCF0YXNrcy5sZW5ndGgpIHJldHVybiBjYWxsYmFjaygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFza3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHdyYXBBc3luYyh0YXNrc1tpXSkoY2FsbGJhY2spO1xuICAgIH1cbn1cblxudmFyIHJhY2UkMSA9IGF3YWl0aWZ5KHJhY2UsIDIpO1xuXG4vKipcbiAqIFNhbWUgYXMgW2ByZWR1Y2VgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVkdWNlfSwgb25seSBvcGVyYXRlcyBvbiBgYXJyYXlgIGluIHJldmVyc2Ugb3JkZXIuXG4gKlxuICogQG5hbWUgcmVkdWNlUmlnaHRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnJlZHVjZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlZHVjZX1cbiAqIEBhbGlhcyBmb2xkclxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Kn0gbWVtbyAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggaXRlbSBpbiB0aGVcbiAqIGFycmF5IHRvIHByb2R1Y2UgdGhlIG5leHQgc3RlcCBpbiB0aGUgcmVkdWN0aW9uLlxuICogVGhlIGBpdGVyYXRlZWAgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIG5leHQgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAqIElmIHRoZSBpdGVyYXRlZSBjb21wbGV0ZXMgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBJbnZva2VkIHdpdGggKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiByZWR1Y2VSaWdodCAoYXJyYXksIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciByZXZlcnNlZCA9IFsuLi5hcnJheV0ucmV2ZXJzZSgpO1xuICAgIHJldHVybiByZWR1Y2UkMShyZXZlcnNlZCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBXcmFwcyB0aGUgYXN5bmMgZnVuY3Rpb24gaW4gYW5vdGhlciBmdW5jdGlvbiB0aGF0IGFsd2F5cyBjb21wbGV0ZXMgd2l0aCBhXG4gKiByZXN1bHQgb2JqZWN0LCBldmVuIHdoZW4gaXQgZXJyb3JzLlxuICpcbiAqIFRoZSByZXN1bHQgb2JqZWN0IGhhcyBlaXRoZXIgdGhlIHByb3BlcnR5IGBlcnJvcmAgb3IgYHZhbHVlYC5cbiAqXG4gKiBAbmFtZSByZWZsZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB5b3Ugd2FudCB0byB3cmFwXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyBwYXNzZXMgbnVsbCB0byBpdCdzIGNhbGxiYWNrIGFzXG4gKiB0aGUgZXJyb3IuIFRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrIHdpbGwgYmUgYW4gYG9iamVjdGAgd2l0aFxuICogZWl0aGVyIGFuIGBlcnJvcmAgb3IgYSBgdmFsdWVgIHByb3BlcnR5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgfSksXG4gKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgYnV0IGVycm9yIC4uLlxuICogICAgICAgICBjYWxsYmFjaygnYmFkIHN0dWZmIGhhcHBlbmVkJyk7XG4gKiAgICAgfSksXG4gKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICB9KVxuICogXSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB2YWx1ZXNcbiAqICAgICAvLyByZXN1bHRzWzBdLnZhbHVlID0gJ29uZSdcbiAqICAgICAvLyByZXN1bHRzWzFdLmVycm9yID0gJ2JhZCBzdHVmZiBoYXBwZW5lZCdcbiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bydcbiAqIH0pO1xuICovXG5mdW5jdGlvbiByZWZsZWN0KGZuKSB7XG4gICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gcmVmbGVjdE9uKGFyZ3MsIHJlZmxlY3RDYWxsYmFjaykge1xuICAgICAgICBhcmdzLnB1c2goKGVycm9yLCAuLi5jYkFyZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCByZXRWYWwgPSB7fTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldFZhbC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNiQXJncy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjYkFyZ3M7XG4gICAgICAgICAgICAgICAgaWYgKGNiQXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBbdmFsdWVdID0gY2JBcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRWYWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZmxlY3RDYWxsYmFjayhudWxsLCByZXRWYWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYW4gYXJyYXkgb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB3aXRoIGByZWZsZWN0YC5cbiAqXG4gKiBAbmFtZSByZWZsZWN0QWxsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWZsZWN0XXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH1cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxJdGVyYWJsZX0gdGFza3MgLSBUaGUgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gd3JhcCBpbiBgYXN5bmMucmVmbGVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgYXN5bmMgZnVuY3Rpb25zLCBlYWNoIHdyYXBwZWQgaW5cbiAqIGBhc3luYy5yZWZsZWN0YFxuICogQGV4YW1wbGVcbiAqXG4gKiBsZXQgdGFza3MgPSBbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJykpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdO1xuICpcbiAqIGFzeW5jLnBhcmFsbGVsKGFzeW5jLnJlZmxlY3RBbGwodGFza3MpLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHZhbHVlc1xuICogICAgIC8vIHJlc3VsdHNbMF0udmFsdWUgPSAnb25lJ1xuICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJylcbiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bydcbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGxldCB0YXNrcyA9IHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKCd0d28nKTtcbiAqICAgICB9LFxuICogICAgIHRocmVlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfTtcbiAqXG4gKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB2YWx1ZXNcbiAqICAgICAvLyByZXN1bHRzLm9uZS52YWx1ZSA9ICdvbmUnXG4gKiAgICAgLy8gcmVzdWx0cy50d28uZXJyb3IgPSAndHdvJ1xuICogICAgIC8vIHJlc3VsdHMudGhyZWUudmFsdWUgPSAndGhyZWUnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmVmbGVjdEFsbCh0YXNrcykge1xuICAgIHZhciByZXN1bHRzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICByZXN1bHRzID0gdGFza3MubWFwKHJlZmxlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGFza3MpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlZmxlY3QuY2FsbCh0aGlzLCB0YXNrc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiByZWplY3QkMihlYWNoZm4sIGFyciwgX2l0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGl0ZXJhdGVlID0gd3JhcEFzeW5jKF9pdGVyYXRlZSk7XG4gICAgcmV0dXJuIF9maWx0ZXIoZWFjaGZuLCBhcnIsICh2YWx1ZSwgY2IpID0+IHtcbiAgICAgICAgaXRlcmF0ZWUodmFsdWUsIChlcnIsIHYpID0+IHtcbiAgICAgICAgICAgIGNiKGVyciwgIXYpO1xuICAgICAgICB9KTtcbiAgICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0uIFJlbW92ZXMgdmFsdWVzIHRoYXQgcGFzcyBhbiBgYXN5bmNgIHRydXRoIHRlc3QuXG4gKlxuICogQG5hbWUgcmVqZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBkaXIxIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTEudHh0LCBmaWxlMi50eHRcbiAqIC8vIGRpcjIgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMy50eHQsIGZpbGU0LnR4dFxuICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICpcbiAqIGNvbnN0IGZpbGVMaXN0ID0gWydkaXIxL2ZpbGUxLnR4dCcsJ2RpcjIvZmlsZTMudHh0JywnZGlyMy9maWxlNi50eHQnXTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSBmaWxlIGV4aXN0c1xuICogZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlLCBjYWxsYmFjaykge1xuICogICAgZnMuYWNjZXNzKGZpbGUsIGZzLmNvbnN0YW50cy5GX09LLCAoZXJyKSA9PiB7XG4gKiAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycik7XG4gKiAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLnJlamVjdChmaWxlTGlzdCwgZmlsZUV4aXN0cywgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAvLyBbICdkaXIzL2ZpbGU2LnR4dCcgXVxuICogICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIHRoZSBub24tZXhpc3RpbmcgZmlsZXNcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIFByb21pc2VzXG4gKiBhc3luYy5yZWplY3QoZmlsZUxpc3QsIGZpbGVFeGlzdHMpXG4gKiAudGhlbiggcmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gWyAnZGlyMy9maWxlNi50eHQnIF1cbiAqICAgICAvLyByZXN1bHRzIG5vdyBlcXVhbHMgYW4gYXJyYXkgb2YgdGhlIG5vbi1leGlzdGluZyBmaWxlc1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5yZWplY3QoZmlsZUxpc3QsIGZpbGVFeGlzdHMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gWyAnZGlyMy9maWxlNi50eHQnIF1cbiAqICAgICAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIHRoZSBub24tZXhpc3RpbmcgZmlsZXNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIHJlamVjdCAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlamVjdCQyKGVhY2hPZiQxLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG52YXIgcmVqZWN0JDEgPSBhd2FpdGlmeShyZWplY3QsIDMpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIHJlamVjdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiByZWplY3RMaW1pdCAoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiByZWplY3QkMihlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIHJlamVjdExpbWl0JDEgPSBhd2FpdGlmeShyZWplY3RMaW1pdCwgNCk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2ByZWplY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgcmVqZWN0U2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiByZWplY3RTZXJpZXMgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiByZWplY3QkMihlYWNoT2ZTZXJpZXMkMSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIHJlamVjdFNlcmllcyQxID0gYXdhaXRpZnkocmVqZWN0U2VyaWVzLCAzKTtcblxuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGdldCBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZnJvbSBgdGFza2Agbm8gbW9yZSB0aGFuIGB0aW1lc2AgdGltZXNcbiAqIGJlZm9yZSByZXR1cm5pbmcgYW4gZXJyb3IuIElmIHRoZSB0YXNrIGlzIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmVcbiAqIHBhc3NlZCB0aGUgcmVzdWx0IG9mIHRoZSBzdWNjZXNzZnVsIHRhc2suIElmIGFsbCBhdHRlbXB0cyBmYWlsLCB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LlxuICpcbiAqIEBuYW1lIHJldHJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAc2VlIFthc3luYy5yZXRyeWFibGVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeWFibGV9XG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRzID0ge3RpbWVzOiA1LCBpbnRlcnZhbDogMH18IDVdIC0gQ2FuIGJlIGVpdGhlciBhblxuICogb2JqZWN0IHdpdGggYHRpbWVzYCBhbmQgYGludGVydmFsYCBvciBhIG51bWJlci5cbiAqICogYHRpbWVzYCAtIFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gbWFrZSBiZWZvcmUgZ2l2aW5nIHVwLiAgVGhlIGRlZmF1bHRcbiAqICAgaXMgYDVgLlxuICogKiBgaW50ZXJ2YWxgIC0gVGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIHJldHJpZXMsIGluIG1pbGxpc2Vjb25kcy4gIFRoZVxuICogICBkZWZhdWx0IGlzIGAwYC4gVGhlIGludGVydmFsIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhcyBhIGZ1bmN0aW9uIG9mIHRoZVxuICogICByZXRyeSBjb3VudCAoc2VlIGV4YW1wbGUpLlxuICogKiBgZXJyb3JGaWx0ZXJgIC0gQW4gb3B0aW9uYWwgc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIG9uXG4gKiAgIGVycm9uZW91cyByZXN1bHQuIElmIGl0IHJldHVybnMgYHRydWVgIHRoZSByZXRyeSBhdHRlbXB0cyB3aWxsIGNvbnRpbnVlO1xuICogICBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgIHRoZSByZXRyeSBmbG93IGlzIGFib3J0ZWQgd2l0aCB0aGUgY3VycmVudFxuICogICBhdHRlbXB0J3MgZXJyb3IgYW5kIHJlc3VsdCBiZWluZyByZXR1cm5lZCB0byB0aGUgZmluYWwgY2FsbGJhY2suXG4gKiAgIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqICogSWYgYG9wdHNgIGlzIGEgbnVtYmVyLCB0aGUgbnVtYmVyIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5LFxuICogICB3aXRoIHRoZSBkZWZhdWx0IGludGVydmFsIG9mIGAwYC5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIHJldHJ5LlxuICogSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiB0YXNrIGhhcyBzdWNjZWVkZWQsIG9yIGFmdGVyIHRoZSBmaW5hbCBmYWlsZWQgYXR0ZW1wdC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgXG4gKiBhbmQgYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkXG4gKiB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVGhlIGByZXRyeWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgYSBzdGFuZC1hbG9uZSBjb250cm9sIGZsb3cgYnkgcGFzc2luZ1xuICogLy8gYSBjYWxsYmFjaywgYXMgc2hvd24gYmVsb3c6XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXNcbiAqIGFzeW5jLnJldHJ5KDMsIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lcywgd2FpdGluZyAyMDAgbXMgYmV0d2VlbiBlYWNoIHJldHJ5XG4gKiBhc3luYy5yZXRyeSh7dGltZXM6IDMsIGludGVydmFsOiAyMDB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDEwIHRpbWVzIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICogLy8gKGkuZS4gaW50ZXJ2YWxzIG9mIDEwMCwgMjAwLCA0MDAsIDgwMCwgMTYwMCwgLi4uIG1pbGxpc2Vjb25kcylcbiAqIGFzeW5jLnJldHJ5KHtcbiAqICAgdGltZXM6IDEwLFxuICogICBpbnRlcnZhbDogZnVuY3Rpb24ocmV0cnlDb3VudCkge1xuICogICAgIHJldHVybiA1MCAqIE1hdGgucG93KDIsIHJldHJ5Q291bnQpO1xuICogICB9XG4gKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIHRoZSBkZWZhdWx0IDUgdGltZXMgbm8gZGVsYXkgYmV0d2VlbiBlYWNoIHJldHJ5XG4gKiBhc3luYy5yZXRyeShhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIG9ubHkgd2hlbiBlcnJvciBjb25kaXRpb24gc2F0aXNmaWVzLCBhbGwgb3RoZXJcbiAqIC8vIGVycm9ycyB3aWxsIGFib3J0IHRoZSByZXRyeSBjb250cm9sIGZsb3cgYW5kIHJldHVybiB0byBmaW5hbCBjYWxsYmFja1xuICogYXN5bmMucmV0cnkoe1xuICogICBlcnJvckZpbHRlcjogZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgcmV0dXJuIGVyci5tZXNzYWdlID09PSAnVGVtcG9yYXJ5IGVycm9yJzsgLy8gb25seSByZXRyeSBvbiBhIHNwZWNpZmljIGVycm9yXG4gKiAgIH1cbiAqIH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0byByZXRyeSBpbmRpdmlkdWFsIG1ldGhvZHMgdGhhdCBhcmUgbm90IGFzIHJlbGlhYmxlIHdpdGhpbiBvdGhlclxuICogLy8gY29udHJvbCBmbG93IGZ1bmN0aW9ucywgdXNlIHRoZSBgcmV0cnlhYmxlYCB3cmFwcGVyOlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgdXNlcnM6IGFwaS5nZXRVc2Vycy5iaW5kKGFwaSksXG4gKiAgICAgcGF5bWVudHM6IGFzeW5jLnJldHJ5YWJsZSgzLCBhcGkuZ2V0UGF5bWVudHMuYmluZChhcGkpKVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdHNcbiAqIH0pO1xuICpcbiAqL1xuY29uc3QgREVGQVVMVF9USU1FUyA9IDU7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuZnVuY3Rpb24gcmV0cnkob3B0cywgdGFzaywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgdGltZXM6IERFRkFVTFRfVElNRVMsXG4gICAgICAgIGludGVydmFsRnVuYzogY29uc3RhbnQoREVGQVVMVF9JTlRFUlZBTClcbiAgICB9O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCBwcm9taXNlQ2FsbGJhY2soKTtcbiAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VUaW1lcyhvcHRpb25zLCBvcHRzKTtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBwcm9taXNlQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhc2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5XCIpO1xuICAgIH1cblxuICAgIHZhciBfdGFzayA9IHdyYXBBc3luYyh0YXNrKTtcblxuICAgIHZhciBhdHRlbXB0ID0gMTtcbiAgICBmdW5jdGlvbiByZXRyeUF0dGVtcHQoKSB7XG4gICAgICAgIF90YXNrKChlcnIsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICAgIGlmIChlcnIgJiYgYXR0ZW1wdCsrIDwgb3B0aW9ucy50aW1lcyAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5lcnJvckZpbHRlciAhPSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JGaWx0ZXIoZXJyKSkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldHJ5QXR0ZW1wdCwgb3B0aW9ucy5pbnRlcnZhbEZ1bmMoYXR0ZW1wdCAtIDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0cnlBdHRlbXB0KCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrW1BST01JU0VfU1lNQk9MXVxufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWVzKGFjYywgdCkge1xuICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWNjLnRpbWVzID0gK3QudGltZXMgfHwgREVGQVVMVF9USU1FUztcblxuICAgICAgICBhY2MuaW50ZXJ2YWxGdW5jID0gdHlwZW9mIHQuaW50ZXJ2YWwgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgdC5pbnRlcnZhbCA6XG4gICAgICAgICAgICBjb25zdGFudCgrdC5pbnRlcnZhbCB8fCBERUZBVUxUX0lOVEVSVkFMKTtcblxuICAgICAgICBhY2MuZXJyb3JGaWx0ZXIgPSB0LmVycm9yRmlsdGVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBhY2MudGltZXMgPSArdCB8fCBERUZBVUxUX1RJTUVTO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBjbG9zZSByZWxhdGl2ZSBvZiBbYHJldHJ5YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5fS4gIFRoaXMgbWV0aG9kXG4gKiB3cmFwcyBhIHRhc2sgYW5kIG1ha2VzIGl0IHJldHJ5YWJsZSwgcmF0aGVyIHRoYW4gaW1tZWRpYXRlbHkgY2FsbGluZyBpdFxuICogd2l0aCByZXRyaWVzLlxuICpcbiAqIEBuYW1lIHJldHJ5YWJsZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucmV0cnlde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeX1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcn0gW29wdHMgPSB7dGltZXM6IDUsIGludGVydmFsOiAwfXwgNV0gLSBvcHRpb25hbFxuICogb3B0aW9ucywgZXhhY3RseSB0aGUgc2FtZSBhcyBmcm9tIGByZXRyeWAsIGV4Y2VwdCBmb3IgYSBgb3B0cy5hcml0eWAgdGhhdFxuICogaXMgdGhlIGFyaXR5IG9mIHRoZSBgdGFza2AgZnVuY3Rpb24sIGRlZmF1bHRpbmcgdG8gYHRhc2subGVuZ3RoYFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0byB3cmFwLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgd3JhcHBlci5cbiAqIEludm9rZWQgd2l0aCAoLi4uYXJncywgY2FsbGJhY2spLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLCB3aGljaCB3aGVuIGludm9rZWQsIHdpbGxcbiAqIHJldHJ5IG9uIGFuIGVycm9yLCBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gYG9wdHNgLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFjY2VwdCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIGB0YXNrYC5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgZGVwMTogYXN5bmMucmV0cnlhYmxlKDMsIGdldEZyb21GbGFreVNlcnZpY2UpLFxuICogICAgIHByb2Nlc3M6IFtcImRlcDFcIiwgYXN5bmMucmV0cnlhYmxlKDMsIGZ1bmN0aW9uIChyZXN1bHRzLCBjYikge1xuICogICAgICAgICBtYXliZVByb2Nlc3NEYXRhKHJlc3VsdHMuZGVwMSwgY2IpO1xuICogICAgIH0pXVxuICogfSwgY2FsbGJhY2spO1xuICovXG5mdW5jdGlvbiByZXRyeWFibGUgKG9wdHMsIHRhc2spIHtcbiAgICBpZiAoIXRhc2spIHtcbiAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgICAgIG9wdHMgPSBudWxsO1xuICAgIH1cbiAgICBsZXQgYXJpdHkgPSAob3B0cyAmJiBvcHRzLmFyaXR5KSB8fCB0YXNrLmxlbmd0aDtcbiAgICBpZiAoaXNBc3luYyh0YXNrKSkge1xuICAgICAgICBhcml0eSArPSAxO1xuICAgIH1cbiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoKGFyZ3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IGFyaXR5IC0gMSB8fCBjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBwcm9taXNlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0YXNrRm4oY2IpIHtcbiAgICAgICAgICAgIF90YXNrKC4uLmFyZ3MsIGNiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzKSByZXRyeShvcHRzLCB0YXNrRm4sIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZSByZXRyeSh0YXNrRm4sIGNhbGxiYWNrKTtcblxuICAgICAgICByZXR1cm4gY2FsbGJhY2tbUFJPTUlTRV9TWU1CT0xdXG4gICAgfSk7XG59XG5cbi8qKlxuICogUnVuIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBpbiBzZXJpZXMsIGVhY2ggb25lIHJ1bm5pbmcgb25jZVxuICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBmdW5jdGlvbnMgaW4gdGhlIHNlcmllcyBwYXNzIGFuXG4gKiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIG5vIG1vcmUgZnVuY3Rpb25zIGFyZSBydW4sIGFuZCBgY2FsbGJhY2tgIGlzXG4gKiBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGVycm9yLiBPdGhlcndpc2UsIGBjYWxsYmFja2BcbiAqIHJlY2VpdmVzIGFuIGFycmF5IG9mIHJlc3VsdHMgd2hlbiBgdGFza3NgIGhhdmUgY29tcGxldGVkLlxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBFYWNoIHByb3BlcnR5IHdpbGxcbiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uLCBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2BcbiAqIGFzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBUaGlzIGNhbiBiZSBhIG1vcmUgcmVhZGFibGUgd2F5IG9mIGhhbmRsaW5nXG4gKiAgcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5zZXJpZXN9LlxuICpcbiAqICoqTm90ZSoqIHRoYXQgd2hpbGUgbWFueSBpbXBsZW1lbnRhdGlvbnMgcHJlc2VydmUgdGhlIG9yZGVyIG9mIG9iamVjdFxuICogcHJvcGVydGllcywgdGhlIFtFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb25dKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04LjYpXG4gKiBleHBsaWNpdGx5IHN0YXRlcyB0aGF0XG4gKlxuICogPiBUaGUgbWVjaGFuaWNzIGFuZCBvcmRlciBvZiBlbnVtZXJhdGluZyB0aGUgcHJvcGVydGllcyBpcyBub3Qgc3BlY2lmaWVkLlxuICpcbiAqIFNvIGlmIHlvdSByZWx5IG9uIHRoZSBvcmRlciBpbiB3aGljaCB5b3VyIHNlcmllcyBvZiBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkLFxuICogYW5kIHdhbnQgdGhpcyB0byB3b3JrIG9uIGFsbCBwbGF0Zm9ybXMsIGNvbnNpZGVyIHVzaW5nIGFuIGFycmF5LlxuICpcbiAqIEBuYW1lIHNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZ1xuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuIGluIHNlcmllcy5cbiAqIEVhY2ggZnVuY3Rpb24gY2FuIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5IChvciBvYmplY3QpXG4gKiBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGB0YXNrYCBjYWxsYmFja3MuIEludm9rZWRcbiAqIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vVXNpbmcgQ2FsbGJhY2tzXG4gKiBhc3luYy5zZXJpZXMoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyBkbyBzb21lIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyB0aGVuIGRvIGFub3RoZXIgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIF0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXVxuICogfSk7XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBvYmplY3RzIGluc3RlYWQgb2YgYXJyYXlzXG4gKiBhc3luYy5zZXJpZXMoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIC8vIGRvIHNvbWUgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyB0aGVuIGRvIGFub3RoZXIgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0bzogeyBvbmU6IDEsIHR3bzogMiB9XG4gKiB9KTtcbiAqXG4gKiAvL1VzaW5nIFByb21pc2VzXG4gKiBhc3luYy5zZXJpZXMoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIF0pLnRoZW4ocmVzdWx0cyA9PiB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddXG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gKiBhc3luYy5zZXJpZXMoe1xuICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIC8vIGRvIHNvbWUgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAvLyB0aGVuIGRvIGFub3RoZXIgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfSkudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnNlcmllcyhbXG4gKiAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIC8vIGRvIHNvbWUgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAqICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZG8gYW5vdGhlciBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICogICAgICAgICAgICAgfVxuICogICAgICAgICBdKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG8gWydvbmUnLCd0d28nXVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGFzeW5jLnBhcmFsbGVsKHtcbiAqICAgICAgICAgICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICAvLyBkbyBzb21lIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAqICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGRvIGFub3RoZXIgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAqICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICogICAgICAgICAgICB9XG4gKiAgICAgICAgIH0pO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0bzogeyBvbmU6IDEsIHR3bzogMiB9XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBzZXJpZXModGFza3MsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9wYXJhbGxlbChlYWNoT2ZTZXJpZXMkMSwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgYGNvbGxgIHNhdGlzZmllcyBhbiBhc3luYyB0ZXN0LlxuICogSWYgYW55IGl0ZXJhdGVlIGNhbGwgcmV0dXJucyBgdHJ1ZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHlcbiAqIGNhbGxlZC5cbiAqXG4gKiBAbmFtZSBzb21lXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgYW55XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gYHJlc3VsdGAgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jXG4gKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBkaXIxIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTEudHh0LCBmaWxlMi50eHRcbiAqIC8vIGRpcjIgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMy50eHQsIGZpbGU0LnR4dFxuICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICogLy8gZGlyNCBkb2VzIG5vdCBleGlzdFxuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhIGZpbGUgZXhpc3RzXG4gKiBmdW5jdGlvbiBmaWxlRXhpc3RzKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICBmcy5hY2Nlc3MoZmlsZSwgZnMuY29uc3RhbnRzLkZfT0ssIChlcnIpID0+IHtcbiAqICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKTtcbiAqICAgIH0pO1xuICogfVxuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMuc29tZShbJ2RpcjEvbWlzc2luZy50eHQnLCdkaXIyL21pc3NpbmcudHh0JywnZGlyMy9maWxlNS50eHQnXSwgZmlsZUV4aXN0cyxcbiAqICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAvLyB0cnVlXG4gKiAgICAgICAgLy8gcmVzdWx0IGlzIHRydWUgc2luY2Ugc29tZSBmaWxlIGluIHRoZSBsaXN0IGV4aXN0c1xuICogICAgfVxuICopO1xuICpcbiAqIGFzeW5jLnNvbWUoWydkaXIxL21pc3NpbmcudHh0JywnZGlyMi9taXNzaW5nLnR4dCcsJ2RpcjQvbWlzc2luZy50eHQnXSwgZmlsZUV4aXN0cyxcbiAqICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAvLyBmYWxzZVxuICogICAgICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBub25lIG9mIHRoZSBmaWxlcyBleGlzdHNcbiAqICAgIH1cbiAqKTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMuc29tZShbJ2RpcjEvbWlzc2luZy50eHQnLCdkaXIyL21pc3NpbmcudHh0JywnZGlyMy9maWxlNS50eHQnXSwgZmlsZUV4aXN0cylcbiAqIC50aGVuKCByZXN1bHQgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gdHJ1ZVxuICogICAgIC8vIHJlc3VsdCBpcyB0cnVlIHNpbmNlIHNvbWUgZmlsZSBpbiB0aGUgbGlzdCBleGlzdHNcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiBhc3luYy5zb21lKFsnZGlyMS9taXNzaW5nLnR4dCcsJ2RpcjIvbWlzc2luZy50eHQnLCdkaXI0L21pc3NpbmcudHh0J10sIGZpbGVFeGlzdHMpXG4gKiAudGhlbiggcmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIGZhbHNlXG4gKiAgICAgLy8gcmVzdWx0IGlzIGZhbHNlIHNpbmNlIG5vbmUgb2YgdGhlIGZpbGVzIGV4aXN0c1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLnNvbWUoWydkaXIxL21pc3NpbmcudHh0JywnZGlyMi9taXNzaW5nLnR4dCcsJ2RpcjMvZmlsZTUudHh0J10sIGZpbGVFeGlzdHMpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyB0cnVlXG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyB0cnVlIHNpbmNlIHNvbWUgZmlsZSBpbiB0aGUgbGlzdCBleGlzdHNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLnNvbWUoWydkaXIxL21pc3NpbmcudHh0JywnZGlyMi9taXNzaW5nLnR4dCcsJ2RpcjQvbWlzc2luZy50eHQnXSwgZmlsZUV4aXN0cyk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIGZhbHNlXG4gKiAgICAgICAgIC8vIHJlc3VsdCBpcyBmYWxzZSBzaW5jZSBub25lIG9mIHRoZSBmaWxlcyBleGlzdHNcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIHNvbWUoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgcmVzID0+IHJlcykoZWFjaE9mJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBzb21lJDEgPSBhd2FpdGlmeShzb21lLCAzKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgc29tZUxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX1cbiAqIEBhbGlhcyBhbnlMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbnMgaW4gcGFyYWxsZWwuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luY1xuICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAqL1xuZnVuY3Rpb24gc29tZUxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRlc3RlcihCb29sZWFuLCByZXMgPT4gcmVzKShlYWNoT2ZMaW1pdCQyKGxpbWl0KSwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxudmFyIHNvbWVMaW1pdCQxID0gYXdhaXRpZnkoc29tZUxpbWl0LCA0KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIHNvbWVTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnNvbWVde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfVxuICogQGFsaWFzIGFueVNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbnMgaW4gc2VyaWVzLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIHNvbWVTZXJpZXMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgcmVzID0+IHJlcykoZWFjaE9mU2VyaWVzJDEsIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaylcbn1cbnZhciBzb21lU2VyaWVzJDEgPSBhd2FpdGlmeShzb21lU2VyaWVzLCAzKTtcblxuLyoqXG4gKiBTb3J0cyBhIGxpc3QgYnkgdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGBjb2xsYCB2YWx1ZSB0aHJvdWdoIGFuIGFzeW5jXG4gKiBgaXRlcmF0ZWVgLlxuICpcbiAqIEBuYW1lIHNvcnRCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgdmFsdWUgdG8gdXNlIGFzIHRoZSBzb3J0IGNyaXRlcmlhIGFzXG4gKiBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIHRoZSBpdGVtc1xuICogZnJvbSB0aGUgb3JpZ2luYWwgYGNvbGxgIHNvcnRlZCBieSB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBgaXRlcmF0ZWVgXG4gKiBjYWxscy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGJpZ2ZpbGUudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDI1MTEwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBtZWRpdW1maWxlLnR4dCBpcyBhIGZpbGUgdGhhdCBpcyAxMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBzbWFsbGZpbGUudHh0IGlzIGEgZmlsZSB0aGF0IGlzIDEyMSBieXRlcyBpbiBzaXplXG4gKlxuICogLy8gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZmlsZSBzaXplIGluIGJ5dGVzXG4gKiBmdW5jdGlvbiBnZXRGaWxlU2l6ZUluQnl0ZXMoZmlsZSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCBzdGF0LnNpemUpO1xuICogICAgIH0pO1xuICogfVxuICpcbiAqIC8vIFVzaW5nIGNhbGxiYWNrc1xuICogYXN5bmMuc29ydEJ5KFsnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0JywnYmlnZmlsZS50eHQnXSwgZ2V0RmlsZVNpemVJbkJ5dGVzLFxuICogICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gKiAgICAgICAgICAgICAvLyBmaWxlIHNpemUgKGFzY2VuZGluZyBieSBkZWZhdWx0KSwgZS5nLlxuICogICAgICAgICAgICAgLy8gWyAnc21hbGxmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdiaWdmaWxlLnR4dCddXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKiApO1xuICpcbiAqIC8vIEJ5IG1vZGlmeWluZyB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyIHRoZVxuICogLy8gc29ydGluZyBvcmRlciBjYW4gYmUgaW5mbHVlbmNlZDpcbiAqXG4gKiAvLyBhc2NlbmRpbmcgb3JkZXJcbiAqIGFzeW5jLnNvcnRCeShbJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCcsJ2JpZ2ZpbGUudHh0J10sIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGZ1bmN0aW9uKGdldEZpbGVTaXplRXJyLCBmaWxlU2l6ZSkge1xuICogICAgICAgICBpZiAoZ2V0RmlsZVNpemVFcnIpIHJldHVybiBjYWxsYmFjayhnZXRGaWxlU2l6ZUVycik7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbGVTaXplKTtcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gKiAgICAgICAgICAgICAvLyBmaWxlIHNpemUgKGFzY2VuZGluZyBieSBkZWZhdWx0KSwgZS5nLlxuICogICAgICAgICAgICAgLy8gWyAnc21hbGxmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdiaWdmaWxlLnR4dCddXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKiApO1xuICpcbiAqIC8vIGRlc2NlbmRpbmcgb3JkZXJcbiAqIGFzeW5jLnNvcnRCeShbJ2JpZ2ZpbGUudHh0JywnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0J10sIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZ2V0RmlsZVNpemVJbkJ5dGVzKGZpbGUsIGZ1bmN0aW9uKGdldEZpbGVTaXplRXJyLCBmaWxlU2l6ZSkge1xuICogICAgICAgICBpZiAoZ2V0RmlsZVNpemVFcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhnZXRGaWxlU2l6ZUVycik7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmlsZVNpemUgKiAtMSk7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieVxuICogICAgICAgICAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAqICAgICAgICAgICAgIC8vIFsgJ2JpZ2ZpbGUudHh0JywgJ21lZGl1bWZpbGUudHh0JywgJ3NtYWxsZmlsZS50eHQnXVxuICogICAgICAgICB9XG4gKiAgICAgfVxuICogKTtcbiAqXG4gKiAvLyBFcnJvciBoYW5kbGluZ1xuICogYXN5bmMuc29ydEJ5KFsnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0JywnbWlzc2luZ2ZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcyxcbiAqICAgICBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqICk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnNvcnRCeShbJ21lZGl1bWZpbGUudHh0Jywnc21hbGxmaWxlLnR4dCcsJ2JpZ2ZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5XG4gKiAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAqICAgICAvLyBbICdzbWFsbGZpbGUudHh0JywgJ21lZGl1bWZpbGUudHh0JywgJ2JpZ2ZpbGUudHh0J11cbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBFcnJvciBoYW5kbGluZ1xuICogYXN5bmMuc29ydEJ5KFsnbWVkaXVtZmlsZS50eHQnLCdzbWFsbGZpbGUudHh0JywnbWlzc2luZ2ZpbGUudHh0J10sIGdldEZpbGVTaXplSW5CeXRlcylcbiAqIC50aGVuKCByZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiAoYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMuc29ydEJ5KFsnYmlnZmlsZS50eHQnLCdtZWRpdW1maWxlLnR4dCcsJ3NtYWxsZmlsZS50eHQnXSwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMgaXMgbm93IHRoZSBvcmlnaW5hbCBhcnJheSBvZiBmaWxlcyBzb3J0ZWQgYnlcbiAqICAgICAgICAgLy8gZmlsZSBzaXplIChhc2NlbmRpbmcgYnkgZGVmYXVsdCksIGUuZy5cbiAqICAgICAgICAgLy8gWyAnc21hbGxmaWxlLnR4dCcsICdtZWRpdW1maWxlLnR4dCcsICdiaWdmaWxlLnR4dCddXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9KSgpO1xuICpcbiAqIC8vIEVycm9yIGhhbmRsaW5nXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBhc3luYy5zb3J0QnkoWydtaXNzaW5nZmlsZS50eHQnLCdtZWRpdW1maWxlLnR4dCcsJ3NtYWxsZmlsZS50eHQnXSwgZ2V0RmlsZVNpemVJbkJ5dGVzKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBzb3J0QnkgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHJldHVybiBtYXAkMShjb2xsLCAoeCwgaXRlckNiKSA9PiB7XG4gICAgICAgIF9pdGVyYXRlZSh4LCAoZXJyLCBjcml0ZXJpYSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGl0ZXJDYihlcnIpO1xuICAgICAgICAgICAgaXRlckNiKGVyciwge3ZhbHVlOiB4LCBjcml0ZXJpYX0pO1xuICAgICAgICB9KTtcbiAgICB9LCAoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzLnNvcnQoY29tcGFyYXRvcikubWFwKHYgPT4gdi52YWx1ZSkpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH1cbn1cbnZhciBzb3J0QnkkMSA9IGF3YWl0aWZ5KHNvcnRCeSwgMyk7XG5cbi8qKlxuICogU2V0cyBhIHRpbWUgbGltaXQgb24gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgY2FsbFxuICogaXRzIGNhbGxiYWNrIHdpdGhpbiB0aGUgc3BlY2lmaWVkIG1pbGxpc2Vjb25kcywgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gKiB0aW1lb3V0IGVycm9yLiBUaGUgY29kZSBwcm9wZXJ0eSBmb3IgdGhlIGVycm9yIG9iamVjdCB3aWxsIGJlIGAnRVRJTUVET1VUJ2AuXG4gKlxuICogQG5hbWUgdGltZW91dFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gYXN5bmNGbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBsaW1pdCBpbiB0aW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpc2Vjb25kcyAtIFRoZSBzcGVjaWZpZWQgdGltZSBsaW1pdC5cbiAqIEBwYXJhbSB7Kn0gW2luZm9dIC0gQW55IHZhcmlhYmxlIHlvdSB3YW50IGF0dGFjaGVkIChgc3RyaW5nYCwgYG9iamVjdGAsIGV0YylcbiAqIHRvIHRpbWVvdXQgRXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSB3cmFwcGVkIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBhbnlcbiAqIG9mIHRoZSBjb250cm9sIGZsb3cgZnVuY3Rpb25zLlxuICogSW52b2tlIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHlvdSB3b3VsZCBgYXN5bmNGdW5jYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gbXlGdW5jdGlvbihmb28sIGNhbGxiYWNrKSB7XG4gKiAgICAgZG9Bc3luY1Rhc2soZm9vLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAqICAgICAgICAgLy8gaGFuZGxlIGVycm9yc1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqXG4gKiAgICAgICAgIC8vIGRvIHNvbWUgc3R1ZmYgLi4uXG4gKlxuICogICAgICAgICAvLyByZXR1cm4gcHJvY2Vzc2VkIGRhdGFcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICogICAgIH0pO1xuICogfVxuICpcbiAqIHZhciB3cmFwcGVkID0gYXN5bmMudGltZW91dChteUZ1bmN0aW9uLCAxMDAwKTtcbiAqXG4gKiAvLyBjYWxsIGB3cmFwcGVkYCBhcyB5b3Ugd291bGQgYG15RnVuY3Rpb25gXG4gKiB3cmFwcGVkKHsgYmFyOiAnYmFyJyB9LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAqICAgICAvLyBpZiBgbXlGdW5jdGlvbmAgdGFrZXMgPCAxMDAwIG1zIHRvIGV4ZWN1dGUsIGBlcnJgXG4gKiAgICAgLy8gYW5kIGBkYXRhYCB3aWxsIGhhdmUgdGhlaXIgZXhwZWN0ZWQgdmFsdWVzXG4gKlxuICogICAgIC8vIGVsc2UgYGVycmAgd2lsbCBiZSBhbiBFcnJvciB3aXRoIHRoZSBjb2RlICdFVElNRURPVVQnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gdGltZW91dChhc3luY0ZuLCBtaWxsaXNlY29uZHMsIGluZm8pIHtcbiAgICB2YXIgZm4gPSB3cmFwQXN5bmMoYXN5bmNGbik7XG5cbiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcygoYXJncywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgdmFyIHRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgIHZhciB0aW1lcjtcblxuICAgICAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFzeW5jRm4ubmFtZSB8fCAnYW5vbnltb3VzJztcbiAgICAgICAgICAgIHZhciBlcnJvciAgPSBuZXcgRXJyb3IoJ0NhbGxiYWNrIGZ1bmN0aW9uIFwiJyArIG5hbWUgKyAnXCIgdGltZWQgb3V0LicpO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdFVElNRURPVVQnO1xuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0gaW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MucHVzaCgoLi4uY2JBcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soLi4uY2JBcmdzKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXR1cCB0aW1lciBhbmQgY2FsbCBvcmlnaW5hbCBmdW5jdGlvblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBtaWxsaXNlY29uZHMpO1xuICAgICAgICBmbiguLi5hcmdzKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmFuZ2Uoc2l6ZSkge1xuICAgIHZhciByZXN1bHQgPSBBcnJheShzaXplKTtcbiAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgIHJlc3VsdFtzaXplXSA9IHNpemU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW3RpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSB0aW1lc0xpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy50aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy5cbiAqIEludm9rZWQgd2l0aCB0aGUgaXRlcmF0aW9uIGluZGV4IGFuZCBhIGNhbGxiYWNrOiAobiwgbmV4dCkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIHRpbWVzTGltaXQoY291bnQsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICByZXR1cm4gbWFwTGltaXQkMShyYW5nZShjb3VudCksIGxpbWl0LCBfaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBDYWxscyB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbiBgbmAgdGltZXMsIGFuZCBhY2N1bXVsYXRlcyByZXN1bHRzIGluIHRoZSBzYW1lXG4gKiBtYW5uZXIgeW91IHdvdWxkIHVzZSB3aXRoIFttYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICpcbiAqIEBuYW1lIHRpbWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gUHJldGVuZCB0aGlzIGlzIHNvbWUgY29tcGxpY2F0ZWQgYXN5bmMgZmFjdG9yeVxuICogdmFyIGNyZWF0ZVVzZXIgPSBmdW5jdGlvbihpZCwgY2FsbGJhY2spIHtcbiAqICAgICBjYWxsYmFjayhudWxsLCB7XG4gKiAgICAgICAgIGlkOiAndXNlcicgKyBpZFxuICogICAgIH0pO1xuICogfTtcbiAqXG4gKiAvLyBnZW5lcmF0ZSA1IHVzZXJzXG4gKiBhc3luYy50aW1lcyg1LCBmdW5jdGlvbihuLCBuZXh0KSB7XG4gKiAgICAgY3JlYXRlVXNlcihuLCBmdW5jdGlvbihlcnIsIHVzZXIpIHtcbiAqICAgICAgICAgbmV4dChlcnIsIHVzZXIpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCB1c2Vycykge1xuICogICAgIC8vIHdlIHNob3VsZCBub3cgaGF2ZSA1IHVzZXJzXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gdGltZXMgKG4sIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aW1lc0xpbWl0KG4sIEluZmluaXR5LCBpdGVyYXRlZSwgY2FsbGJhY2spXG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW3RpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSB0aW1lc1Nlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMudGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy5cbiAqIEludm9rZWQgd2l0aCB0aGUgaXRlcmF0aW9uIGluZGV4IGFuZCBhIGNhbGxiYWNrOiAobiwgbmV4dCkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSB7QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZFxuICovXG5mdW5jdGlvbiB0aW1lc1NlcmllcyAobiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRpbWVzTGltaXQobiwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIEEgcmVsYXRpdmUgb2YgYHJlZHVjZWAuICBUYWtlcyBhbiBPYmplY3Qgb3IgQXJyYXksIGFuZCBpdGVyYXRlcyBvdmVyIGVhY2hcbiAqIGVsZW1lbnQgaW4gcGFyYWxsZWwsIGVhY2ggc3RlcCBwb3RlbnRpYWxseSBtdXRhdGluZyBhbiBgYWNjdW11bGF0b3JgIHZhbHVlLlxuICogVGhlIHR5cGUgb2YgdGhlIGFjY3VtdWxhdG9yIGRlZmF1bHRzIHRvIHRoZSB0eXBlIG9mIGNvbGxlY3Rpb24gcGFzc2VkIGluLlxuICpcbiAqIEBuYW1lIHRyYW5zZm9ybVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHRyYW5zZm9ybS4gIElmIG9taXR0ZWQsXG4gKiBpdCB3aWxsIGRlZmF1bHQgdG8gYW4gZW1wdHkgT2JqZWN0IG9yIEFycmF5LCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgYGNvbGxgXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggaXRlbSBpbiB0aGVcbiAqIGNvbGxlY3Rpb24gdGhhdCBwb3RlbnRpYWxseSBtb2RpZmllcyB0aGUgYWNjdW11bGF0b3IuXG4gKiBJbnZva2VkIHdpdGggKGFjY3VtdWxhdG9yLCBpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHRyYW5zZm9ybWVkIGFjY3VtdWxhdG9yLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gKlxuICogLy8gaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBodW1hbi1yZWFkYWJsZSBzaXplIGZvcm1hdCBmcm9tIGJ5dGVzXG4gKiBmdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlcywgZGVjaW1hbHMgPSAyKSB7XG4gKiAgIC8vIGltcGxlbWVudGF0aW9uIG5vdCBpbmNsdWRlZCBmb3IgYnJldml0eVxuICogICByZXR1cm4gaHVtYW5SZWFkYmxlRmlsZXNpemU7XG4gKiB9XG4gKlxuICogY29uc3QgZmlsZUxpc3QgPSBbJ2ZpbGUxLnR4dCcsJ2ZpbGUyLnR4dCcsJ2ZpbGUzLnR4dCddO1xuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpbGUgc2l6ZSwgdHJhbnNmb3JtZWQgdG8gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gKiAvLyBlLmcuIDEwMjQgYnl0ZXMgPSAxS0IsIDEyMzQgYnl0ZXMgPSAxLjIxIEtCLCAxMDQ4NTc2IGJ5dGVzID0gMU1CLCBldGMuXG4gKiBmdW5jdGlvbiB0cmFuc2Zvcm1GaWxlU2l6ZShhY2MsIHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdCh2YWx1ZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGFjY1trZXldID0gZm9ybWF0Qnl0ZXMoc3RhdC5zaXplKTtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy50cmFuc2Zvcm0oZmlsZUxpc3QsIHRyYW5zZm9ybUZpbGVTaXplLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIGlmKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgICAgIC8vIFsgJzEwMDAgQnl0ZXMnLCAnMS45NSBLQicsICcyLjkzIEtCJyBdXG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnRyYW5zZm9ybShmaWxlTGlzdCwgdHJhbnNmb3JtRmlsZVNpemUpXG4gKiAudGhlbihyZXN1bHQgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgICAgLy8gWyAnMTAwMCBCeXRlcycsICcxLjk1IEtCJywgJzIuOTMgS0InIF1cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIFVzaW5nIGFzeW5jL2F3YWl0XG4gKiAoYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy50cmFuc2Zvcm0oZmlsZUxpc3QsIHRyYW5zZm9ybUZpbGVTaXplKTtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8gWyAnMTAwMCBCeXRlcycsICcxLjk1IEtCJywgJzIuOTMgS0InIF1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH0pKCk7XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBmaWxlMS50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMTAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMi50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMjAwMCBieXRlcyBpbiBzaXplXG4gKiAvLyBmaWxlMy50eHQgaXMgYSBmaWxlIHRoYXQgaXMgMzAwMCBieXRlcyBpbiBzaXplXG4gKlxuICogLy8gaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBodW1hbi1yZWFkYWJsZSBzaXplIGZvcm1hdCBmcm9tIGJ5dGVzXG4gKiBmdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlcywgZGVjaW1hbHMgPSAyKSB7XG4gKiAgIC8vIGltcGxlbWVudGF0aW9uIG5vdCBpbmNsdWRlZCBmb3IgYnJldml0eVxuICogICByZXR1cm4gaHVtYW5SZWFkYmxlRmlsZXNpemU7XG4gKiB9XG4gKlxuICogY29uc3QgZmlsZU1hcCA9IHsgZjE6ICdmaWxlMS50eHQnLCBmMjogJ2ZpbGUyLnR4dCcsIGYzOiAnZmlsZTMudHh0JyB9O1xuICpcbiAqIC8vIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpbGUgc2l6ZSwgdHJhbnNmb3JtZWQgdG8gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gKiAvLyBlLmcuIDEwMjQgYnl0ZXMgPSAxS0IsIDEyMzQgYnl0ZXMgPSAxLjIxIEtCLCAxMDQ4NTc2IGJ5dGVzID0gMU1CLCBldGMuXG4gKiBmdW5jdGlvbiB0cmFuc2Zvcm1GaWxlU2l6ZShhY2MsIHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdCh2YWx1ZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGFjY1trZXldID0gZm9ybWF0Qnl0ZXMoc3RhdC5zaXplKTtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy50cmFuc2Zvcm0oZmlsZU1hcCwgdHJhbnNmb3JtRmlsZVNpemUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgaWYoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqICAgICAgICAgLy8geyBmMTogJzEwMDAgQnl0ZXMnLCBmMjogJzEuOTUgS0InLCBmMzogJzIuOTMgS0InIH1cbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBQcm9taXNlc1xuICogYXN5bmMudHJhbnNmb3JtKGZpbGVNYXAsIHRyYW5zZm9ybUZpbGVTaXplKVxuICogLnRoZW4ocmVzdWx0ID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgIC8vIHsgZjE6ICcxMDAwIEJ5dGVzJywgZjI6ICcxLjk1IEtCJywgZjM6ICcyLjkzIEtCJyB9XG4gKiB9KS5jYXRjaChlcnIgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy50cmFuc2Zvcm0oZmlsZU1hcCwgdHJhbnNmb3JtRmlsZVNpemUpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogICAgICAgICAvLyB7IGYxOiAnMTAwMCBCeXRlcycsIGYyOiAnMS45NSBLQicsIGYzOiAnMi45MyBLQicgfVxuICogICAgIH1cbiAqICAgICBjYXRjaCAoZXJyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gKiAgICAgfVxuICogfVxuICpcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtIChjb2xsLCBhY2N1bXVsYXRvciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMyAmJiB0eXBlb2YgYWNjdW11bGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBpdGVyYXRlZTtcbiAgICAgICAgaXRlcmF0ZWUgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBBcnJheS5pc0FycmF5KGNvbGwpID8gW10gOiB7fTtcbiAgICB9XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IHByb21pc2VDYWxsYmFjaygpKTtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcblxuICAgIGVhY2hPZiQxKGNvbGwsICh2LCBrLCBjYikgPT4ge1xuICAgICAgICBfaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHYsIGssIGNiKTtcbiAgICB9LCBlcnIgPT4gY2FsbGJhY2soZXJyLCBhY2N1bXVsYXRvcikpO1xuICAgIHJldHVybiBjYWxsYmFja1tQUk9NSVNFX1NZTUJPTF1cbn1cblxuLyoqXG4gKiBJdCBydW5zIGVhY2ggdGFzayBpbiBzZXJpZXMgYnV0IHN0b3BzIHdoZW5ldmVyIGFueSBvZiB0aGUgZnVuY3Rpb25zIHdlcmVcbiAqIHN1Y2Nlc3NmdWwuIElmIG9uZSBvZiB0aGUgdGFza3Mgd2VyZSBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlXG4gKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgdGFza3MgZmFpbCwgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC5cbiAqXG4gKiBAbmFtZSB0cnlFYWNoXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBjb250YWluaW5nIGZ1bmN0aW9ucyB0b1xuICogcnVuLCBlYWNoIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGl0IG11c3QgY2FsbCBvblxuICogY29tcGxldGlvbiB3aXRoIGFuIGVycm9yIGBlcnJgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgYW4gb3B0aW9uYWwgYHJlc3VsdGBcbiAqIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIG9uZVxuICogb2YgdGhlIHRhc2tzIGhhcyBzdWNjZWVkZWQsIG9yIGFsbCBoYXZlIGZhaWxlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFuZFxuICogYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgbm8gY2FsbGJhY2sgaXMgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogYXN5bmMudHJ5RWFjaChbXG4gKiAgICAgZnVuY3Rpb24gZ2V0RGF0YUZyb21GaXJzdFdlYnNpdGUoY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgd2Vic2l0ZVxuICogICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24gZ2V0RGF0YUZyb21TZWNvbmRXZWJzaXRlKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIEZpcnN0IHdlYnNpdGUgZmFpbGVkLFxuICogICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgZGF0YSBmcm9tIHRoZSBiYWNrdXAgd2Vic2l0ZVxuICogICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICogICAgIH1cbiAqIF0sXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgTm93IGRvIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLlxuICogfSk7XG4gKlxuICovXG5mdW5jdGlvbiB0cnlFYWNoKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgdmFyIHJlc3VsdDtcbiAgICByZXR1cm4gZWFjaFNlcmllcyQxKHRhc2tzLCAodGFzaywgdGFza0NiKSA9PiB7XG4gICAgICAgIHdyYXBBc3luYyh0YXNrKSgoZXJyLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuIHRhc2tDYihlcnIpO1xuXG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgW3Jlc3VsdF0gPSBhcmdzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB0YXNrQ2IoZXJyID8gbnVsbCA6IHt9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgKCkgPT4gY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkpO1xufVxuXG52YXIgdHJ5RWFjaCQxID0gYXdhaXRpZnkodHJ5RWFjaCk7XG5cbi8qKlxuICogVW5kb2VzIGEgW21lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfWQgZnVuY3Rpb24sIHJldmVydGluZyBpdCB0byB0aGUgb3JpZ2luYWwsXG4gKiB1bm1lbW9pemVkIGZvcm0uIEhhbmR5IGZvciB0ZXN0aW5nLlxuICpcbiAqIEBuYW1lIHVubWVtb2l6ZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWVtb2l6ZV17QGxpbmsgbW9kdWxlOlV0aWxzLm1lbW9pemV9XG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIHRoZSBtZW1vaXplZCBmdW5jdGlvblxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgb3JpZ2luYWwgdW5tZW1vaXplZCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiB1bm1lbW9pemUoZm4pIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKSguLi5hcmdzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFJlcGVhdGVkbHkgY2FsbCBgaXRlcmF0ZWVgLCB3aGlsZSBgdGVzdGAgcmV0dXJucyBgdHJ1ZWAuIENhbGxzIGBjYWxsYmFja2Agd2hlblxuICogc3RvcHBlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLlxuICpcbiAqIEBuYW1lIHdoaWxzdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0ZXN0IC0gYXN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBiZWZvcmUgZWFjaFxuICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY291bnQgPSAwO1xuICogYXN5bmMud2hpbHN0KFxuICogICAgIGZ1bmN0aW9uIHRlc3QoY2IpIHsgY2IobnVsbCwgY291bnQgPCA1KTsgfSxcbiAqICAgICBmdW5jdGlvbiBpdGVyKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvdW50Kys7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjb3VudCk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24gKGVyciwgbikge1xuICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQsIG4gPSA1XG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gd2hpbHN0KHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2spO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gbmV4dChlcnIsIC4uLnJlc3QpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJlc3VsdHMgPSByZXN0O1xuICAgICAgICBpZiAoZXJyID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBfdGVzdChjaGVjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2soZXJyLCB0cnV0aCkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgaWYgKCF0cnV0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIC4uLnJlc3VsdHMpO1xuICAgICAgICBfZm4obmV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90ZXN0KGNoZWNrKTtcbn1cbnZhciB3aGlsc3QkMSA9IGF3YWl0aWZ5KHdoaWxzdCwgMyk7XG5cbi8qKlxuICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAgdW50aWwgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW5cbiAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suXG4gKlxuICogVGhlIGludmVyc2Ugb2YgW3doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uXG4gKlxuICogQG5hbWUgdW50aWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGVzdCAtIGFzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lXG4gKiBgdGVzdGAgZmFpbHMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgbm90IHBhc3NlZFxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByZXN1bHRzID0gW11cbiAqIGxldCBmaW5pc2hlZCA9IGZhbHNlXG4gKiBhc3luYy51bnRpbChmdW5jdGlvbiB0ZXN0KGNiKSB7XG4gKiAgICAgY2IobnVsbCwgZmluaXNoZWQpXG4gKiB9LCBmdW5jdGlvbiBpdGVyKG5leHQpIHtcbiAqICAgICBmZXRjaFBhZ2UodXJsLCAoZXJyLCBib2R5KSA9PiB7XG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycilcbiAqICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KGJvZHkub2JqZWN0cylcbiAqICAgICAgICAgZmluaXNoZWQgPSAhIWJvZHkubmV4dFxuICogICAgICAgICBuZXh0KGVycilcbiAqICAgICB9KVxuICogfSwgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gKiAgICAgLy8gYWxsIHBhZ2VzIGhhdmUgYmVlbiBmZXRjaGVkXG4gKiB9KVxuICovXG5mdW5jdGlvbiB1bnRpbCh0ZXN0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcbiAgICByZXR1cm4gd2hpbHN0JDEoKGNiKSA9PiBfdGVzdCgoZXJyLCB0cnV0aCkgPT4gY2IgKGVyciwgIXRydXRoKSksIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyB0aGUgYHRhc2tzYCBhcnJheSBvZiBmdW5jdGlvbnMgaW4gc2VyaWVzLCBlYWNoIHBhc3NpbmcgdGhlaXIgcmVzdWx0cyB0b1xuICogdGhlIG5leHQgaW4gdGhlIGFycmF5LiBIb3dldmVyLCBpZiBhbnkgb2YgdGhlIGB0YXNrc2AgcGFzcyBhbiBlcnJvciB0byB0aGVpclxuICogb3duIGNhbGxiYWNrLCB0aGUgbmV4dCBmdW5jdGlvbiBpcyBub3QgZXhlY3V0ZWQsIGFuZCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzXG4gKiBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKlxuICogQG5hbWUgd2F0ZXJmYWxsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IG9mIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259XG4gKiB0byBydW4uXG4gKiBFYWNoIGZ1bmN0aW9uIHNob3VsZCBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2YgYHJlc3VsdGAgdmFsdWVzLlxuICogVGhlIGByZXN1bHRgIHZhbHVlcyB3aWxsIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMsIGluIG9yZGVyLCB0byB0aGUgbmV4dCB0YXNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGVcbiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gVGhpcyB3aWxsIGJlIHBhc3NlZCB0aGUgcmVzdWx0cyBvZiB0aGUgbGFzdCB0YXNrJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnLCAndHdvJyk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihhcmcxLCBhcmcyLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJ1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGFyZzEsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFyZzEgbm93IGVxdWFscyAndGhyZWUnXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7XG4gKiAgICAgfVxuICogXSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgJ2RvbmUnXG4gKiB9KTtcbiAqXG4gKiAvLyBPciwgd2l0aCBuYW1lZCBmdW5jdGlvbnM6XG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIG15Rmlyc3RGdW5jdGlvbixcbiAqICAgICBteVNlY29uZEZ1bmN0aW9uLFxuICogICAgIG15TGFzdEZ1bmN0aW9uLFxuICogXSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgJ2RvbmUnXG4gKiB9KTtcbiAqIGZ1bmN0aW9uIG15Rmlyc3RGdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgIGNhbGxiYWNrKG51bGwsICdvbmUnLCAndHdvJyk7XG4gKiB9XG4gKiBmdW5jdGlvbiBteVNlY29uZEZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gYXJnMSBub3cgZXF1YWxzICdvbmUnIGFuZCBhcmcyIG5vdyBlcXVhbHMgJ3R3bydcbiAqICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTtcbiAqIH1cbiAqIGZ1bmN0aW9uIG15TGFzdEZ1bmN0aW9uKGFyZzEsIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZSdcbiAqICAgICBjYWxsYmFjayhudWxsLCAnZG9uZScpO1xuICogfVxuICovXG5mdW5jdGlvbiB3YXRlcmZhbGwgKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB2YXIgdGFza0luZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHtcbiAgICAgICAgdmFyIHRhc2sgPSB3cmFwQXN5bmModGFza3NbdGFza0luZGV4KytdKTtcbiAgICAgICAgdGFzayguLi5hcmdzLCBvbmx5T25jZShuZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dChlcnIsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHJldHVyblxuICAgICAgICBpZiAoZXJyIHx8IHRhc2tJbmRleCA9PT0gdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VGFzayhhcmdzKTtcbiAgICB9XG5cbiAgICBuZXh0VGFzayhbXSk7XG59XG5cbnZhciB3YXRlcmZhbGwkMSA9IGF3YWl0aWZ5KHdhdGVyZmFsbCk7XG5cbi8qKlxuICogQW4gXCJhc3luYyBmdW5jdGlvblwiIGluIHRoZSBjb250ZXh0IG9mIEFzeW5jIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB3aXRoXG4gKiBhIHZhcmlhYmxlIG51bWJlciBvZiBwYXJhbWV0ZXJzLCB3aXRoIHRoZSBmaW5hbCBwYXJhbWV0ZXIgYmVpbmcgYSBjYWxsYmFjay5cbiAqIChgZnVuY3Rpb24gKGFyZzEsIGFyZzIsIC4uLiwgY2FsbGJhY2spIHt9YClcbiAqIFRoZSBmaW5hbCBjYWxsYmFjayBpcyBvZiB0aGUgZm9ybSBgY2FsbGJhY2soZXJyLCByZXN1bHRzLi4uKWAsIHdoaWNoIG11c3QgYmVcbiAqIGNhbGxlZCBvbmNlIHRoZSBmdW5jdGlvbiBpcyBjb21wbGV0ZWQuICBUaGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGFcbiAqIEVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudCB0byBzaWduYWwgdGhhdCBhbiBlcnJvciBvY2N1cnJlZC5cbiAqIE90aGVyd2lzZSwgaWYgbm8gZXJyb3Igb2NjdXJyZWQsIGl0IHNob3VsZCBiZSBjYWxsZWQgd2l0aCBgbnVsbGAgYXMgdGhlIGZpcnN0XG4gKiBhcmd1bWVudCwgYW5kIGFueSBhZGRpdGlvbmFsIGByZXN1bHRgIGFyZ3VtZW50cyB0aGF0IG1heSBhcHBseSwgdG8gc2lnbmFsXG4gKiBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gKiBUaGUgY2FsbGJhY2sgbXVzdCBiZSBjYWxsZWQgZXhhY3RseSBvbmNlLCBpZGVhbGx5IG9uIGEgbGF0ZXIgdGljayBvZiB0aGVcbiAqIEphdmFTY3JpcHQgZXZlbnQgbG9vcC5cbiAqXG4gKiBUaGlzIHR5cGUgb2YgZnVuY3Rpb24gaXMgYWxzbyByZWZlcnJlZCB0byBhcyBhIFwiTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvblwiLFxuICogb3IgYSBcImNvbnRpbnVhdGlvbiBwYXNzaW5nLXN0eWxlIGZ1bmN0aW9uXCIgKENQUykuIE1vc3Qgb2YgdGhlIG1ldGhvZHMgb2YgdGhpc1xuICogbGlicmFyeSBhcmUgdGhlbXNlbHZlcyBDUFMvTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbnMsIG9yIGZ1bmN0aW9ucyB0aGF0XG4gKiByZXR1cm4gQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLlxuICpcbiAqIFdoZXJldmVyIHdlIGFjY2VwdCBhIE5vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb24sIHdlIGFsc28gZGlyZWN0bHkgYWNjZXB0IGFuXG4gKiBbRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1N0YXRlbWVudHMvYXN5bmNfZnVuY3Rpb259LlxuICogSW4gdGhpcyBjYXNlLCB0aGUgYGFzeW5jYCBmdW5jdGlvbiB3aWxsIG5vdCBiZSBwYXNzZWQgYSBmaW5hbCBjYWxsYmFja1xuICogYXJndW1lbnQsIGFuZCBhbnkgdGhyb3duIGVycm9yIHdpbGwgYmUgdXNlZCBhcyB0aGUgYGVycmAgYXJndW1lbnQgb2YgdGhlXG4gKiBpbXBsaWNpdCBjYWxsYmFjaywgYW5kIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBgcmVzdWx0YCB2YWx1ZS5cbiAqIChpLmUuIGEgYHJlamVjdGVkYCBvZiB0aGUgcmV0dXJuZWQgUHJvbWlzZSBiZWNvbWVzIHRoZSBgZXJyYCBjYWxsYmFja1xuICogYXJndW1lbnQsIGFuZCBhIGByZXNvbHZlZGAgdmFsdWUgYmVjb21lcyB0aGUgYHJlc3VsdGAuKVxuICpcbiAqIE5vdGUsIGR1ZSB0byBKYXZhU2NyaXB0IGxpbWl0YXRpb25zLCB3ZSBjYW4gb25seSBkZXRlY3QgbmF0aXZlIGBhc3luY2BcbiAqIGZ1bmN0aW9ucyBhbmQgbm90IHRyYW5zcGlsaWVkIGltcGxlbWVudGF0aW9ucy5cbiAqIFlvdXIgZW52aXJvbm1lbnQgbXVzdCBoYXZlIGBhc3luY2AvYGF3YWl0YCBzdXBwb3J0IGZvciB0aGlzIHRvIHdvcmsuXG4gKiAoZS5nLiBOb2RlID4gdjcuNiwgb3IgYSByZWNlbnQgdmVyc2lvbiBvZiBhIG1vZGVybiBicm93c2VyKS5cbiAqIElmIHlvdSBhcmUgdXNpbmcgYGFzeW5jYCBmdW5jdGlvbnMgdGhyb3VnaCBhIHRyYW5zcGlsZXIgKGUuZy4gQmFiZWwpLCB5b3VcbiAqIG11c3Qgc3RpbGwgd3JhcCB0aGUgZnVuY3Rpb24gd2l0aCBbYXN5bmNpZnlde0BsaW5rIG1vZHVsZTpVdGlscy5hc3luY2lmeX0sXG4gKiBiZWNhdXNlIHRoZSBgYXN5bmMgZnVuY3Rpb25gIHdpbGwgYmUgY29tcGlsZWQgdG8gYW4gb3JkaW5hcnkgZnVuY3Rpb24gdGhhdFxuICogcmV0dXJucyBhIHByb21pc2UuXG4gKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSBBc3luY0Z1bmN0aW9uXG4gKiBAc3RhdGljXG4gKi9cblxuXG52YXIgaW5kZXggPSB7XG4gICAgYXBwbHksXG4gICAgYXBwbHlFYWNoLFxuICAgIGFwcGx5RWFjaFNlcmllcyxcbiAgICBhc3luY2lmeSxcbiAgICBhdXRvLFxuICAgIGF1dG9JbmplY3QsXG4gICAgY2FyZ286IGNhcmdvJDEsXG4gICAgY2FyZ29RdWV1ZTogY2FyZ28sXG4gICAgY29tcG9zZSxcbiAgICBjb25jYXQ6IGNvbmNhdCQxLFxuICAgIGNvbmNhdExpbWl0OiBjb25jYXRMaW1pdCQxLFxuICAgIGNvbmNhdFNlcmllczogY29uY2F0U2VyaWVzJDEsXG4gICAgY29uc3RhbnQ6IGNvbnN0YW50JDEsXG4gICAgZGV0ZWN0OiBkZXRlY3QkMSxcbiAgICBkZXRlY3RMaW1pdDogZGV0ZWN0TGltaXQkMSxcbiAgICBkZXRlY3RTZXJpZXM6IGRldGVjdFNlcmllcyQxLFxuICAgIGRpcixcbiAgICBkb1VudGlsLFxuICAgIGRvV2hpbHN0OiBkb1doaWxzdCQxLFxuICAgIGVhY2gsXG4gICAgZWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBlYWNoT2Y6IGVhY2hPZiQxLFxuICAgIGVhY2hPZkxpbWl0OiBlYWNoT2ZMaW1pdCQxLFxuICAgIGVhY2hPZlNlcmllczogZWFjaE9mU2VyaWVzJDEsXG4gICAgZWFjaFNlcmllczogZWFjaFNlcmllcyQxLFxuICAgIGVuc3VyZUFzeW5jLFxuICAgIGV2ZXJ5OiBldmVyeSQxLFxuICAgIGV2ZXJ5TGltaXQ6IGV2ZXJ5TGltaXQkMSxcbiAgICBldmVyeVNlcmllczogZXZlcnlTZXJpZXMkMSxcbiAgICBmaWx0ZXI6IGZpbHRlciQxLFxuICAgIGZpbHRlckxpbWl0OiBmaWx0ZXJMaW1pdCQxLFxuICAgIGZpbHRlclNlcmllczogZmlsdGVyU2VyaWVzJDEsXG4gICAgZm9yZXZlcjogZm9yZXZlciQxLFxuICAgIGdyb3VwQnksXG4gICAgZ3JvdXBCeUxpbWl0OiBncm91cEJ5TGltaXQkMSxcbiAgICBncm91cEJ5U2VyaWVzLFxuICAgIGxvZyxcbiAgICBtYXA6IG1hcCQxLFxuICAgIG1hcExpbWl0OiBtYXBMaW1pdCQxLFxuICAgIG1hcFNlcmllczogbWFwU2VyaWVzJDEsXG4gICAgbWFwVmFsdWVzLFxuICAgIG1hcFZhbHVlc0xpbWl0OiBtYXBWYWx1ZXNMaW1pdCQxLFxuICAgIG1hcFZhbHVlc1NlcmllcyxcbiAgICBtZW1vaXplLFxuICAgIG5leHRUaWNrLFxuICAgIHBhcmFsbGVsLFxuICAgIHBhcmFsbGVsTGltaXQsXG4gICAgcHJpb3JpdHlRdWV1ZSxcbiAgICBxdWV1ZSxcbiAgICByYWNlOiByYWNlJDEsXG4gICAgcmVkdWNlOiByZWR1Y2UkMSxcbiAgICByZWR1Y2VSaWdodCxcbiAgICByZWZsZWN0LFxuICAgIHJlZmxlY3RBbGwsXG4gICAgcmVqZWN0OiByZWplY3QkMSxcbiAgICByZWplY3RMaW1pdDogcmVqZWN0TGltaXQkMSxcbiAgICByZWplY3RTZXJpZXM6IHJlamVjdFNlcmllcyQxLFxuICAgIHJldHJ5LFxuICAgIHJldHJ5YWJsZSxcbiAgICBzZXEsXG4gICAgc2VyaWVzLFxuICAgIHNldEltbWVkaWF0ZTogc2V0SW1tZWRpYXRlJDEsXG4gICAgc29tZTogc29tZSQxLFxuICAgIHNvbWVMaW1pdDogc29tZUxpbWl0JDEsXG4gICAgc29tZVNlcmllczogc29tZVNlcmllcyQxLFxuICAgIHNvcnRCeTogc29ydEJ5JDEsXG4gICAgdGltZW91dCxcbiAgICB0aW1lcyxcbiAgICB0aW1lc0xpbWl0LFxuICAgIHRpbWVzU2VyaWVzLFxuICAgIHRyYW5zZm9ybSxcbiAgICB0cnlFYWNoOiB0cnlFYWNoJDEsXG4gICAgdW5tZW1vaXplLFxuICAgIHVudGlsLFxuICAgIHdhdGVyZmFsbDogd2F0ZXJmYWxsJDEsXG4gICAgd2hpbHN0OiB3aGlsc3QkMSxcblxuICAgIC8vIGFsaWFzZXNcbiAgICBhbGw6IGV2ZXJ5JDEsXG4gICAgYWxsTGltaXQ6IGV2ZXJ5TGltaXQkMSxcbiAgICBhbGxTZXJpZXM6IGV2ZXJ5U2VyaWVzJDEsXG4gICAgYW55OiBzb21lJDEsXG4gICAgYW55TGltaXQ6IHNvbWVMaW1pdCQxLFxuICAgIGFueVNlcmllczogc29tZVNlcmllcyQxLFxuICAgIGZpbmQ6IGRldGVjdCQxLFxuICAgIGZpbmRMaW1pdDogZGV0ZWN0TGltaXQkMSxcbiAgICBmaW5kU2VyaWVzOiBkZXRlY3RTZXJpZXMkMSxcbiAgICBmbGF0TWFwOiBjb25jYXQkMSxcbiAgICBmbGF0TWFwTGltaXQ6IGNvbmNhdExpbWl0JDEsXG4gICAgZmxhdE1hcFNlcmllczogY29uY2F0U2VyaWVzJDEsXG4gICAgZm9yRWFjaDogZWFjaCxcbiAgICBmb3JFYWNoU2VyaWVzOiBlYWNoU2VyaWVzJDEsXG4gICAgZm9yRWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBmb3JFYWNoT2Y6IGVhY2hPZiQxLFxuICAgIGZvckVhY2hPZlNlcmllczogZWFjaE9mU2VyaWVzJDEsXG4gICAgZm9yRWFjaE9mTGltaXQ6IGVhY2hPZkxpbWl0JDEsXG4gICAgaW5qZWN0OiByZWR1Y2UkMSxcbiAgICBmb2xkbDogcmVkdWNlJDEsXG4gICAgZm9sZHI6IHJlZHVjZVJpZ2h0LFxuICAgIHNlbGVjdDogZmlsdGVyJDEsXG4gICAgc2VsZWN0TGltaXQ6IGZpbHRlckxpbWl0JDEsXG4gICAgc2VsZWN0U2VyaWVzOiBmaWx0ZXJTZXJpZXMkMSxcbiAgICB3cmFwU3luYzogYXN5bmNpZnksXG4gICAgZHVyaW5nOiB3aGlsc3QkMSxcbiAgICBkb0R1cmluZzogZG9XaGlsc3QkMVxufTtcblxuZXhwb3J0IHsgZXZlcnkkMSBhcyBhbGwsIGV2ZXJ5TGltaXQkMSBhcyBhbGxMaW1pdCwgZXZlcnlTZXJpZXMkMSBhcyBhbGxTZXJpZXMsIHNvbWUkMSBhcyBhbnksIHNvbWVMaW1pdCQxIGFzIGFueUxpbWl0LCBzb21lU2VyaWVzJDEgYXMgYW55U2VyaWVzLCBhcHBseSwgYXBwbHlFYWNoLCBhcHBseUVhY2hTZXJpZXMsIGFzeW5jaWZ5LCBhdXRvLCBhdXRvSW5qZWN0LCBjYXJnbyQxIGFzIGNhcmdvLCBjYXJnbyBhcyBjYXJnb1F1ZXVlLCBjb21wb3NlLCBjb25jYXQkMSBhcyBjb25jYXQsIGNvbmNhdExpbWl0JDEgYXMgY29uY2F0TGltaXQsIGNvbmNhdFNlcmllcyQxIGFzIGNvbmNhdFNlcmllcywgY29uc3RhbnQkMSBhcyBjb25zdGFudCwgaW5kZXggYXMgZGVmYXVsdCwgZGV0ZWN0JDEgYXMgZGV0ZWN0LCBkZXRlY3RMaW1pdCQxIGFzIGRldGVjdExpbWl0LCBkZXRlY3RTZXJpZXMkMSBhcyBkZXRlY3RTZXJpZXMsIGRpciwgZG9XaGlsc3QkMSBhcyBkb0R1cmluZywgZG9VbnRpbCwgZG9XaGlsc3QkMSBhcyBkb1doaWxzdCwgd2hpbHN0JDEgYXMgZHVyaW5nLCBlYWNoLCBlYWNoTGltaXQkMSBhcyBlYWNoTGltaXQsIGVhY2hPZiQxIGFzIGVhY2hPZiwgZWFjaE9mTGltaXQkMSBhcyBlYWNoT2ZMaW1pdCwgZWFjaE9mU2VyaWVzJDEgYXMgZWFjaE9mU2VyaWVzLCBlYWNoU2VyaWVzJDEgYXMgZWFjaFNlcmllcywgZW5zdXJlQXN5bmMsIGV2ZXJ5JDEgYXMgZXZlcnksIGV2ZXJ5TGltaXQkMSBhcyBldmVyeUxpbWl0LCBldmVyeVNlcmllcyQxIGFzIGV2ZXJ5U2VyaWVzLCBmaWx0ZXIkMSBhcyBmaWx0ZXIsIGZpbHRlckxpbWl0JDEgYXMgZmlsdGVyTGltaXQsIGZpbHRlclNlcmllcyQxIGFzIGZpbHRlclNlcmllcywgZGV0ZWN0JDEgYXMgZmluZCwgZGV0ZWN0TGltaXQkMSBhcyBmaW5kTGltaXQsIGRldGVjdFNlcmllcyQxIGFzIGZpbmRTZXJpZXMsIGNvbmNhdCQxIGFzIGZsYXRNYXAsIGNvbmNhdExpbWl0JDEgYXMgZmxhdE1hcExpbWl0LCBjb25jYXRTZXJpZXMkMSBhcyBmbGF0TWFwU2VyaWVzLCByZWR1Y2UkMSBhcyBmb2xkbCwgcmVkdWNlUmlnaHQgYXMgZm9sZHIsIGVhY2ggYXMgZm9yRWFjaCwgZWFjaExpbWl0JDEgYXMgZm9yRWFjaExpbWl0LCBlYWNoT2YkMSBhcyBmb3JFYWNoT2YsIGVhY2hPZkxpbWl0JDEgYXMgZm9yRWFjaE9mTGltaXQsIGVhY2hPZlNlcmllcyQxIGFzIGZvckVhY2hPZlNlcmllcywgZWFjaFNlcmllcyQxIGFzIGZvckVhY2hTZXJpZXMsIGZvcmV2ZXIkMSBhcyBmb3JldmVyLCBncm91cEJ5LCBncm91cEJ5TGltaXQkMSBhcyBncm91cEJ5TGltaXQsIGdyb3VwQnlTZXJpZXMsIHJlZHVjZSQxIGFzIGluamVjdCwgbG9nLCBtYXAkMSBhcyBtYXAsIG1hcExpbWl0JDEgYXMgbWFwTGltaXQsIG1hcFNlcmllcyQxIGFzIG1hcFNlcmllcywgbWFwVmFsdWVzLCBtYXBWYWx1ZXNMaW1pdCQxIGFzIG1hcFZhbHVlc0xpbWl0LCBtYXBWYWx1ZXNTZXJpZXMsIG1lbW9pemUsIG5leHRUaWNrLCBwYXJhbGxlbCwgcGFyYWxsZWxMaW1pdCwgcHJpb3JpdHlRdWV1ZSwgcXVldWUsIHJhY2UkMSBhcyByYWNlLCByZWR1Y2UkMSBhcyByZWR1Y2UsIHJlZHVjZVJpZ2h0LCByZWZsZWN0LCByZWZsZWN0QWxsLCByZWplY3QkMSBhcyByZWplY3QsIHJlamVjdExpbWl0JDEgYXMgcmVqZWN0TGltaXQsIHJlamVjdFNlcmllcyQxIGFzIHJlamVjdFNlcmllcywgcmV0cnksIHJldHJ5YWJsZSwgZmlsdGVyJDEgYXMgc2VsZWN0LCBmaWx0ZXJMaW1pdCQxIGFzIHNlbGVjdExpbWl0LCBmaWx0ZXJTZXJpZXMkMSBhcyBzZWxlY3RTZXJpZXMsIHNlcSwgc2VyaWVzLCBzZXRJbW1lZGlhdGUkMSBhcyBzZXRJbW1lZGlhdGUsIHNvbWUkMSBhcyBzb21lLCBzb21lTGltaXQkMSBhcyBzb21lTGltaXQsIHNvbWVTZXJpZXMkMSBhcyBzb21lU2VyaWVzLCBzb3J0QnkkMSBhcyBzb3J0QnksIHRpbWVvdXQsIHRpbWVzLCB0aW1lc0xpbWl0LCB0aW1lc1NlcmllcywgdHJhbnNmb3JtLCB0cnlFYWNoJDEgYXMgdHJ5RWFjaCwgdW5tZW1vaXplLCB1bnRpbCwgd2F0ZXJmYWxsJDEgYXMgd2F0ZXJmYWxsLCB3aGlsc3QkMSBhcyB3aGlsc3QsIGFzeW5jaWZ5IGFzIHdyYXBTeW5jIH07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmFtZE8gPSB7fTsiLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5obWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZSA9IE9iamVjdC5jcmVhdGUobW9kdWxlKTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdHNldDogKCkgPT4ge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFUyBNb2R1bGVzIG1heSBub3QgYXNzaWduIG1vZHVsZS5leHBvcnRzIG9yIGV4cG9ydHMuKiwgVXNlIEVTTSBleHBvcnQgc3ludGF4LCBpbnN0ZWFkOiAnICsgbW9kdWxlLmlkKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIi8vIExvYWQgcGx1Z2luc1xuaW1wb3J0ICdqcXVlcnktdHJlbmQnO1xuaW1wb3J0ICdqcXVlcnktcmV2ZWFsZXInO1xuaW1wb3J0ICd2YWxpZGV0dGEnO1xuXG5pbXBvcnQgc3RlbmNpbFV0aWxzIGZyb20gJ0BiaWdjb21tZXJjZS9zdGVuY2lsLXV0aWxzJztcbmltcG9ydCBhc3luYyBmcm9tICdhc3luYyc7XG5pbXBvcnQgYWNjb3VudCBmcm9tICcuL3RoZW1lL2NvcmUvQWNjb3VudCc7XG5pbXBvcnQgYXV0aCBmcm9tICcuL3RoZW1lL0F1dGgnO1xuaW1wb3J0IGJsb2cgZnJvbSAnLi90aGVtZS9CbG9nJztcbmltcG9ydCBicmFuZCBmcm9tICcuL3RoZW1lL0JyYW5kJztcbmltcG9ydCBicmFuZHMgZnJvbSAnLi90aGVtZS9CcmFuZHMnO1xuaW1wb3J0IGNhcnQgZnJvbSAnLi90aGVtZS9DYXJ0JztcbmltcG9ydCBDYXRlZ29yeSBmcm9tICcuL3RoZW1lL0NhdGVnb3J5JztcbmltcG9ydCBjb21wYXJlIGZyb20gJy4vdGhlbWUvQ29tcGFyZSc7XG5pbXBvcnQgY29udGFjdFVzIGZyb20gJy4vdGhlbWUvQ29udGFjdFVzJztcbmltcG9ydCBlcnJvcnMgZnJvbSAnLi90aGVtZS9FcnJvcnMnO1xuaW1wb3J0IGVycm9yczQwNCBmcm9tICcuL3RoZW1lLzQwNC1lcnJvcic7XG5pbXBvcnQgZ2lmdENlcnRpZmljYXRlIGZyb20gJy4vdGhlbWUvY29yZS9HaWZ0Q2VydGlmaWNhdGUnO1xuaW1wb3J0IGdsb2JhbCBmcm9tICcuL3RoZW1lL0dsb2JhbCc7XG5pbXBvcnQgaG9tZSBmcm9tICcuL3RoZW1lL0hvbWUnO1xuaW1wb3J0IG9yZGVyQ29tcGxldGUgZnJvbSAnLi90aGVtZS9PcmRlckNvbXBsZXRlJztcbmltcG9ydCBwYWdlIGZyb20gJy4vdGhlbWUvUGFnZSc7XG5pbXBvcnQgcHJvZHVjdCBmcm9tICcuL3RoZW1lL1Byb2R1Y3QnO1xuaW1wb3J0IEFtcFByb2R1Y3QgZnJvbSAnLi90aGVtZS9BbXBQcm9kdWN0JztcbmltcG9ydCBzZWFyY2ggZnJvbSAnLi90aGVtZS9TZWFyY2gnO1xuaW1wb3J0IHNpdGVtYXAgZnJvbSAnLi90aGVtZS9TaXRlbWFwJztcbmltcG9ydCBzdWJzY3JpYmUgZnJvbSAnLi90aGVtZS9TdWJzY3JpYmUnO1xuaW1wb3J0IHdpc2hsaXN0IGZyb20gJy4vdGhlbWUvV2lzaGxpc3QnO1xuXG5sZXQgUGFnZUNsYXNzZXMgPSB7XG4gIG1hcHBpbmc6IHtcbiAgICAncGFnZXMvYWNjb3VudC9vcmRlcnMvYWxsJzogYWNjb3VudCxcbiAgICAncGFnZXMvYWNjb3VudC9vcmRlcnMvZGV0YWlscyc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvYWRkcmVzc2VzJzogYWNjb3VudCxcbiAgICAncGFnZXMvYWNjb3VudC9hZGQtYWRkcmVzcyc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvYWRkLXJldHVybic6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvYWRkLXdpc2hsaXN0Jzogd2lzaGxpc3QsXG4gICAgJ3BhZ2VzL2FjY291bnQvZG93bmxvYWQtaXRlbSc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvZWRpdCc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvaW5ib3gnOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L2FkZC1wYXltZW50LW1ldGhvZCc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvZWRpdC1wYXltZW50LW1ldGhvZCc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvcGF5bWVudC1tZXRob2RzJzogYWNjb3VudCxcbiAgICAncGFnZXMvYWNjb3VudC9yZWNlbnQtaXRlbXMnOiBhY2NvdW50LFxuICAgICdwYWdlcy9hY2NvdW50L3JldHVybi1zYXZlZCc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2FjY291bnQvcmV0dXJucyc6IGFjY291bnQsXG4gICAgJ3BhZ2VzL2F1dGgvbG9naW4nOiBhdXRoLFxuICAgICdwYWdlcy9hdXRoL2FjY291bnQtY3JlYXRlZCc6IGF1dGgsXG4gICAgJ3BhZ2VzL2F1dGgvY3JlYXRlLWFjY291bnQnOiBhdXRoLFxuICAgICdwYWdlcy9hdXRoL25ldy1wYXNzd29yZCc6IGF1dGgsXG4gICAgJ3BhZ2VzL2F1dGgvZm9yZ290LXBhc3N3b3JkJzogYXV0aCxcbiAgICAncGFnZXMvYmxvZyc6IGJsb2csXG4gICAgJ3BhZ2VzL2Jsb2ctcG9zdCc6IGJsb2csXG4gICAgJ3BhZ2VzL2JyYW5kJzogYnJhbmQsXG4gICAgJ3BhZ2VzL2JyYW5kcyc6IGJyYW5kLFxuICAgICdwYWdlcy9jYXJ0JzogY2FydCxcbiAgICAncGFnZXMvY2F0ZWdvcnknOiBDYXRlZ29yeSxcbiAgICAncGFnZXMvY29tcGFyZSc6IGNvbXBhcmUsXG4gICAgJ3BhZ2VzL2NvbnRhY3QtdXMnOiBjb250YWN0VXMsXG4gICAgJ3BhZ2VzL2Vycm9ycyc6IGVycm9ycyxcbiAgICAncGFnZXMvZXJyb3JzLzQwNCc6IGVycm9yczQwNCxcbiAgICAncGFnZXMvZ2lmdC1jZXJ0aWZpY2F0ZS9wdXJjaGFzZSc6IGdpZnRDZXJ0aWZpY2F0ZSxcbiAgICAncGFnZXMvZ2lmdC1jZXJ0aWZpY2F0ZS9iYWxhbmNlJzogZ2lmdENlcnRpZmljYXRlLFxuICAgICdwYWdlcy9naWZ0LWNlcnRpZmljYXRlL3JlZGVlbSc6IGdpZnRDZXJ0aWZpY2F0ZSxcbiAgICAnZ2xvYmFsJzogZ2xvYmFsLFxuICAgICdwYWdlcy9ob21lJzogaG9tZSxcbiAgICAncGFnZXMvb3JkZXItY29tcGxldGUnOiBvcmRlckNvbXBsZXRlLFxuICAgICdwYWdlcy9wYWdlJzogcGFnZSxcbiAgICAncGFnZXMvcHJvZHVjdCc6IHByb2R1Y3QsXG4gICAgJ3BhZ2VzL3NlYXJjaCc6IHNlYXJjaCxcbiAgICAncGFnZXMvc2l0ZW1hcCc6IHNpdGVtYXAsXG4gICAgJ3BhZ2VzL3N1YnNjcmliZWQnOiBzdWJzY3JpYmUsXG4gICAgJ3BhZ2VzL2FjY291bnQvd2lzaGxpc3QtZGV0YWlscyc6IHdpc2hsaXN0LFxuICAgICdwYWdlcy9hY2NvdW50L3dpc2hsaXN0cyc6IHdpc2hsaXN0LFxuICAgICdwYWdlcy9hbXAvcHJvZHVjdC1vcHRpb25zJzogQW1wUHJvZHVjdFxuICB9LFxuICAvKipcbiAgICogR2V0dGVyIG1ldGhvZCB0byBlbnN1cmUgYSBnb29kIHBhZ2UgdHlwZSBpcyBhY2Nlc3NlZC5cbiAgICogQHBhcmFtIHBhZ2VcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgICBpZiAodGhpcy5tYXBwaW5nW3BhZ2VdKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBwaW5nW3BhZ2VdO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWdlT2JqXG4gKi9cbmZ1bmN0aW9uIHNlcmllcyhwYWdlT2JqKSB7XG4gIGFzeW5jLnNlcmllcyhbXG4gICAgcGFnZU9iai5iZWZvcmUuYmluZChwYWdlT2JqKSwgLy8gRXhlY3V0ZWQgZmlyc3QgYWZ0ZXIgY29uc3RydWN0b3IoKVxuICAgIHBhZ2VPYmoubG9hZGVkLmJpbmQocGFnZU9iaiksIC8vIE1haW4gbW9kdWxlIGxvZ2ljXG4gICAgcGFnZU9iai5hZnRlci5iaW5kKHBhZ2VPYmopIC8vIENsZWFuIHVwIG1ldGhvZCB0aGF0IGNhbiBiZSBvdmVycmlkZGVuIGZvciBjbGVhbnVwLlxuICBdLCBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIExvYWRzIHRoZSBnbG9iYWwgbW9kdWxlIHRoYXQgZ2V0cyBleGVjdXRlZCBvbiBldmVyeSBwYWdlIGxvYWQuXG4gKiBDb2RlIHRoYXQgeW91IHdhbnQgdG8gcnVuIG9uIGV2ZXJ5IHBhZ2UgZ29lcyBpbiB0aGUgZ2xvYmFsIG1vZHVsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYWdlc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGxvYWRHbG9iYWwocGFnZXMpIHtcbiAgbGV0IEdsb2JhbCA9IHBhZ2VzLmdldCgnZ2xvYmFsJyk7XG5cbiAgcmV0dXJuIG5ldyBHbG9iYWw7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHBhZ2VGdW5jXG4gKiBAcGFyYW0ge30gcGFnZXNcbiAqL1xuZnVuY3Rpb24gbG9hZGVyKHBhZ2VGdW5jLCBwYWdlcykge1xuICBpZiAocGFnZXMuZ2V0KCdnbG9iYWwnKSkge1xuICAgIGxldCBnbG9iYWxQYWdlTWFuYWdlciA9IGxvYWRHbG9iYWwocGFnZXMpO1xuICAgIGdsb2JhbFBhZ2VNYW5hZ2VyLmNvbnRleHQgPSBwYWdlRnVuYy5jb250ZXh0O1xuXG4gICAgc2VyaWVzKGdsb2JhbFBhZ2VNYW5hZ2VyKTtcbiAgfVxuICBzZXJpZXMocGFnZUZ1bmMpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZ2V0cyBhZGRlZCB0byB0aGUgZ2xvYmFsIHdpbmRvdyBhbmQgdGhlbiBjYWxsZWRcbiAqIG9uIHBhZ2UgbG9hZCB3aXRoIHRoZSBjdXJyZW50IHRlbXBsYXRlIGxvYWRlZCBhbmQgSlMgQ29udGV4dCBwYXNzZWQgaW5cbiAqIEBwYXJhbSB0ZW1wbGF0ZUZpbGUgU3RyaW5nXG4gKiBAcGFyYW0gY29udGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbndpbmRvdy5zdGVuY2lsQm9vdHN0cmFwID0gZnVuY3Rpb24gc3RlbmNpbEJvb3RzdHJhcCh0ZW1wbGF0ZUZpbGUsIGNvbnRleHQpIHtcbiAgbGV0IHBhZ2VzID0gUGFnZUNsYXNzZXM7XG5cbiAgY29udGV4dCA9IGNvbnRleHQgfHwgJ3t9JztcbiAgY29udGV4dCA9IEpTT04ucGFyc2UoY29udGV4dCk7XG5cbiAgcmV0dXJuIHtcbiAgICBsb2FkKCkge1xuICAgICAgJCgoKSA9PiB7XG4gICAgICAgIGxldCBQYWdlVHlwZUZuID0gcGFnZXMuZ2V0KHRlbXBsYXRlRmlsZSk7IC8vIEZpbmRzIHRoZSBhcHByb3ByaWF0ZSBtb2R1bGUgZnJvbSB0aGUgcGFnZVR5cGUgb2JqZWN0IGFuZCBzdG9yZSB0aGUgcmVzdWx0IGFzIGEgZnVuY3Rpb24uXG5cbiAgICAgICAgaWYgKFBhZ2VUeXBlRm4pIHtcbiAgICAgICAgICBsZXQgcGFnZVR5cGUgPSBuZXcgUGFnZVR5cGVGbigpO1xuXG4gICAgICAgICAgcGFnZVR5cGUuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAgICAgICByZXR1cm4gbG9hZGVyKHBhZ2VUeXBlLCBwYWdlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGVtcGxhdGVGaWxlICsgJyBNb2R1bGUgbm90IGZvdW5kJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbIlBhZ2VNYW5hZ2VyIiwiX3Byb3RvIiwicHJvdG90eXBlIiwiYmVmb3JlIiwibmV4dCIsImxvYWRlZCIsImFmdGVyIiwidHlwZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImRlZmF1bHQiLCJFcnJvcnM0MDQiLCJfUGFnZU1hbmFnZXIiLCJjYWxsIiwiX2luaGVyaXRzTG9vc2UiLCJBbXBQcm9kdWN0VXRpbHMiLCJBbXBRdWFudGl0eVdpZGdldCIsImluaXRGb3JtU3dhdGNoRmllbGRzIiwiQW1wUHJvZHVjdCIsImNvbnRleHQiLCJfdGhpcyIsImVsIiwic2NvcGUiLCJQcm9kdWN0VXRpbHMiLCJjYWxsYmFja3MiLCJ0ZW1wbGF0ZSIsImluaXQiLCJDb3JlQXV0aCIsIlNlbGVjdFdyYXBwZXIiLCJBdXRoIiwiX0NvcmVBdXRoIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJzZWxlY3RXcmFwQ2FsbGJhY2siLCIkc2VsZWN0RWwiLCJCbG9nIiwiRmFjZXRlZFNlYXJjaCIsImluaXRDb21wYXJlIiwidXBkYXRlQ29tcGFyZSIsIkxvYWRpbmciLCJzdmdJY29uIiwiZmlsbEZhY2V0UmF0aW5nU3RhcnMiLCJ0b2dnbGVGYWNldCIsIkJyYW5kIiwiJGJvZHkiLCIkIiwiZG9jdW1lbnQiLCJib2R5IiwibGVuZ3RoIiwiX2JpbmRFdmVudHMiLCJfaW5pdGlhbGl6ZUZhY2V0ZWRTZWFyY2giLCJsaXN0aW5nUHJvZHVjdENvdW50IiwiX3RoaXMyIiwib24iLCJldmVudCIsIl90b2dnbGVWaWV3IiwicHJldmVudERlZmF1bHQiLCJjdXJyZW50VGFyZ2V0IiwidG9nZ2xlQ2xhc3MiLCJwcm9kdWN0Q291bnQiLCJsb2FkaW5nT3B0aW9ucyIsImxvYWRpbmdNYXJrdXAiLCJmYWNldGVkU2VhcmNoT3ZlcmxheSIsImZhY2V0ZWRTZWFyY2hPcHRpb25zIiwiY29uZmlnIiwiYnJhbmQiLCJzaG9wX2J5X3ByaWNlIiwicHJvZHVjdHMiLCJsaW1pdCIsInByb2R1Y3RMaXN0aW5nIiwic2lkZWJhciIsInNob3dNb3JlIiwid2lsbFVwZGF0ZSIsInNob3ciLCJkaWRVcGRhdGUiLCJoaWRlIiwibGlzdGluZ1ZpZXdNb2RlIiwiJHRhcmdldCIsImRhdGEiLCJvcHRpb25zIiwiYWRkQ2xhc3MiLCJzaWJsaW5ncyIsInJlbW92ZUNsYXNzIiwiQnJhbmRzIiwidXRpbHMiLCJDYXJ0VXRpbHMiLCJTaGlwcGluZ0NhbGN1bGF0b3IiLCJDb3Vwb25Db2RlcyIsIkdpZnRDZXJ0aWZpY2F0ZXMiLCJHaWZ0V3JhcHBpbmciLCJRdWFudGl0eVdpZGdldCIsIkVkaXRPcHRpb25zIiwiQ2FydCIsIiRjYXJ0Q29udGVudCIsIndpbmRvdyIsIkFwcGxlUGF5U2Vzc2lvbiIsIl9hZGRUb0NhcnQiLCJjYXJ0Q29udGVudE92ZXJsYXkiLCJjYXJ0VG90YWxzT3ZlcmxheSIsInZpc2libGVDbGFzcyIsImNhcnRFZGl0T3B0aW9ucyIsIkNhdGVnb3J5IiwiY2F0ZWdvcnkiLCJDb21wYXJlIiwiQ29udGFjdFVzIiwiRXJyb3JzIiwiU2Nyb2xsTGluayIsIkZvcm1WYWxpZGF0b3IiLCJEcm9wZG93biIsIkhlYWRlciIsIlF1aWNrU2VhcmNoIiwiTWluaUNhcnQiLCJRdWlja1Nob3AiLCJ3aXNobGlzdERyb3Bkb3duIiwiTWVnYU5hdiIsIk1vYmlsZU5hdiIsIkdsb2JhbCIsInNlbGVjdG9yIiwiX3RvZ2dsZVNjcm9sbExpbmsiLCJfaW5pdEFuY2hvcnMiLCJfaW5pdGlhbGl6ZVF1aWNrU2VhcmNoIiwidmFsaWRhdG9yIiwiaW5pdEdsb2JhbCIsImFuY2hvclNlbGVjdG9yIiwiZWFjaCIsImluZGV4IiwiZWxlbWVudCIsInRhcmdldElkIiwiYXR0ciIsInRhcmdldCIsInN1YnN0cmluZyIsIm9mZnNldCIsImUiLCJ3aW5TY3JvbGxUb3AiLCJzY3JvbGxUb3AiLCJ3aW5IZWlnaHQiLCJoZWlnaHQiLCJUYWJzIiwic2xpY2siLCJpbWFnZXNMb2FkZWQiLCJIb21lIiwiX2luaXRTbGljayIsIl9pbml0VGFicyIsInRhYnMiLCJhZnRlclNldHVwIiwiYWZ0ZXJDaGFuZ2UiLCIkY2Fyb3VzZWwiLCJpc05hdHVyYWxBc3BlY3RSYXRpbyIsImhhc0NsYXNzIiwic3BlZWQiLCJ0cmlnZ2VyIiwiZG90cyIsImZhZGUiLCJhdXRvcGxheSIsImF1dG9wbGF5U3BlZWQiLCJsYXp5TG9hZCIsImFkYXB0aXZlSGVpZ2h0IiwicHJldkFycm93IiwibmV4dEFycm93IiwiY3VycmVudFNsaWRlIiwibmV4dFNsaWRlIiwic2V0dGluZ3MiLCJpbmZpbml0ZSIsInNsaWRlc1RvU2hvdyIsInNsaWRlc1RvU2Nyb2xsIiwicmVzcG9uc2l2ZSIsImJyZWFrcG9pbnQiLCIkcHJvZHVjdENhcm91c2VsIiwid2lkdGgiLCJPcmRlckNvbXBsZXRlIiwiUGFnZSIsImNyZWF0ZVdyYXBwZXJGb3JUYWJsZSIsInRhYmxlIiwiJHBhcmVudCIsInBhcmVudCIsIiRwcmV2U2libGluZyIsInByZXYiLCIkZGl2IiwiYXBwZW5kIiwiaW5zZXJ0QWZ0ZXIiLCJwcmVwZW5kIiwiQWxlcnQiLCJQcm9kdWN0SW1hZ2VzIiwiUHJvZHVjdFJldmlld3MiLCJDb2xvclN3YXRjaCIsInByb2R1Y3RWaWV3VGVtcGxhdGVzIiwidmFyaWF0aW9uSW1nUHJldmlldyIsImZpdFZpZHMiLCJQcm9kdWN0IiwiJGVsIiwicHJvZHVjdEltZ3MiLCJmaXRWaWRzSW5pdGlhbGl6ZWQiLCJwcmljZVdpdGhvdXRUYXhUZW1wbGF0ZSIsInByaWNlV2l0aG91dFRheCIsInByaWNlV2l0aFRheFRlbXBsYXRlIiwicHJpY2VXaXRoVGF4IiwicHJpY2VTYXZlZFRlbXBsYXRlIiwicHJpY2VTYXZlZCIsInZhcmlhdGlvblByZXZpZXdJbWFnZVRlbXBsYXRlIiwidmFyaWF0aW9uUHJldmlld0ltYWdlIiwic3dpdGNoSW1hZ2UiLCJzd2F0Y2hlcyIsImFjdGl2YXRlVGFiIiwic2V0VGltZW91dCIsInJldmVhbGVyIiwiX2FjY29yZGlvblRhYlRvZ2dsZSIsIl90aGlzMyIsInRhYklkIiwiX2luaXRWaWRzIiwia2VlcFRhYnNPcGVuIiwiY3NzIiwidGFiIiwiZmluZCIsImRpc3BsYXlUYWJDb250ZW50IiwiU2VhcmNoIiwibG9jYXRpb24iLCJzZWFyY2giLCJpbmRleE9mIiwicHJvZHVjdF9yZXN1bHRzIiwiU2l0ZU1hcCIsIlN1YnNjcmliZSIsIndpc2hsaXN0UGFnaW5hdGlvbkhlbHBlciIsIldpc2hMaXN0Iiwib25SZWFkeSIsInJlZnJlc2hDb250ZW50IiwibW9kdWxlcyIsIiRhZGRUb0NhcnQiLCJxdWFudGl0eUlucHV0IiwiY2FydEFsZXJ0cyIsImNhcnRQcm9tb3MiLCJwcm9kdWN0RGF0YSIsImV4dGVuZCIsImNvbnNvbGUiLCJsb2ciLCJfY2FjaGVJbml0aWFsUXVhbnRpdGllcyIsIiRmb3JtIiwiY2xvc2VzdCIsImZvcm1EYXRhIiwic2VyaWFsaXplIiwiYXBpIiwiY2FydCIsIml0ZW1BZGQiLCJlcnIiLCJyZXNwb25zZSIsInN0YXR1cyIsImVycm9yTWVzc2FnZSIsImVycm9ycyIsImpvaW4iLCJlcnJvciIsIl9iaW5kIiwiX2RlYm91bmNlIiwiX3VwZGF0ZUNhcnRJdGVtIiwiZXZ0IiwiaXRlbUlkIiwicXVhbnRpdHlBbHRlcmVkIiwibmV3UXVhbnRpdHkiLCJwYXJzZUludCIsInZhbCIsIl9yZW1vdmVDYXJ0SXRlbSIsImhvb2tzIiwicmVhZHkiLCJjYXJ0VXRpbHMiLCJpIiwiJGNhcnRJdGVtIiwib2xkUXVhbnRpdHkiLCJfdGhpczQiLCIkcXVhbnRpdHlJbnB1dCIsIml0ZW1VcGRhdGUiLCJyZW1vdmUiLCJfdGhpczUiLCJpdGVtUmVtb3ZlIiwiY291cG9uQWxlcnRzIiwiJHNjb3BlIiwiX2FkZENvZGUiLCIkaW5wdXQiLCJjb2RlIiwiY2xlYXIiLCJjb3Vwb25Db2RlRW1wdHlJbnB1dCIsImFwcGx5Q29kZSIsIk1vZGFsIiwiQXR0cmlidXRlc0hlbHBlciIsIkNhcnRFZGl0T3B0aW9ucyIsImlkIiwiY2FydE9wdGlvbnNNb2RhbCIsIm1vZGFsQ2xhc3MiLCJhZnRlclNob3ciLCIkbW9kYWwiLCJfZmV0Y2hQcm9kdWN0IiwiYXR0cmlidXRlc0hlbHBlciIsIm9wZW4iLCIkaXRlbUlEIiwicHJvZHVjdEF0dHJpYnV0ZXMiLCJjb25maWd1cmVJbkNhcnQiLCJjb250ZW50IiwicG9zaXRpb24iLCIkc2VsZWN0Iiwib3B0aW9uIiwiJGNoYW5nZWRPcHRpb24iLCIkc3VibWl0IiwiJG1lc3NhZ2VCb3giLCJpdGVtIiwib3B0aW9uQ2hhbmdlIiwicmVzdWx0IiwidXBkYXRlQXR0cmlidXRlcyIsInB1cmNoYXNpbmdfbWVzc2FnZSIsImh0bWwiLCJwcm9wIiwicHVyY2hhc2FibGUiLCJpbnN0b2NrIiwiZW1pdCIsImNlcnRpZmljYXRlQWxlcnRzIiwiX3RvZ2dsZSIsIl9pc1ZhbGlkQ29kZSIsImdpZnRDZXJ0aWZpY2F0ZUlucHV0RW1wdHkiLCJhcHBseUdpZnRDZXJ0aWZpY2F0ZSIsIl9pbml0aWFsaXplIiwiR2lmdFdyYXBNb2RhbCIsIl9nZXRGb3JtIiwiX2JpbmRQYWdlRXZlbnRzIiwiY29uZmlybSIsInJlbW92ZUdpZnRXcmFwIiwiY2xvc2UiLCJnZXRJdGVtR2lmdFdyYXBwaW5nT3B0aW9ucyIsIl9iaW5kTW9kYWxFdmVudHMiLCJfdG9nZ2xlU2luZ2xlTXVsdGlwbGUiLCJ2YWx1ZSIsImNoYW5nZSIsImFsbG93TWVzc2FnZSIsIiRzaW5nbGVGb3JtIiwiJG11bHRpRm9ybSIsInNoaXBwaW5nQWxlcnRzIiwiX2NhbGN1bGF0ZVNoaXBwaW5nIiwiX3VwZGF0ZVN0YXRlcyIsImNvdW50cnkiLCIkc3RhdGVFbGVtZW50IiwiZ2V0QnlOYW1lIiwic3RhdGVzIiwic3RhdGVBcnJheSIsInB1c2giLCJwcmVmaXgiLCJzdGF0ZSIsInJlcGxhY2VXaXRoIiwic2hpcHBpbmdTdGF0ZSIsInBhcmFtcyIsImNvdW50cnlfaWQiLCIkY2FsY3VsYXRvckZvcm0iLCJzdGF0ZV9pZCIsInppcF9jb2RlIiwiZ2V0U2hpcHBpbmdRdW90ZXMiLCIkc2hpcHBpbmdRdW90ZXMiLCJxdW90ZXMiLCJxdW90ZUlkIiwic3VibWl0U2hpcHBpbmdRdW90ZSIsIiRjYXJ0VG90YWxzIiwiJGNhcnRQcm9tb3MiLCJ0b3RhbHMiLCJwcm9tb3MiLCJyZWxvYWQiLCJnZXRDb250ZW50IiwiY2xhc3NlcyIsImJhc2UiLCJpbmZvIiwic3VjY2VzcyIsIl9pc0VtcHR5IiwiX3RlbXBsYXRlIiwiJGFsZXJ0IiwiX2Rpc21pc3NNZXNzYWdlIiwib25lIiwidGV4dCIsImRpc21pc3NhYmxlIiwibWVzc2FnZSIsImVxIiwibWVzc2FnZVR5cGUiLCJtZXNzYWdlVGV4dCIsImlzRGlzbWlzc2FibGUiLCIkbW9kYWxCb2R5IiwiYXBwZW5kTWVzc2FnZSIsInByb2R1Y3RBbGVydHMiLCJhbGVydHMiLCJjbnRybCIsImFjdGlvbiIsIm1pbiIsIm1heCIsIkluZmluaXR5Iiwid3JhcCIsInVwZGF0ZVNlbGVjdFRleHQiLCJuZXdPcHRpb24iLCJpbml0QWxlcnREaXNtaXNzYWJsZSIsImluaXREb3dubG9hZEdhbGxlcnkiLCJ1cGRhdGVTdGF0ZSIsImNyZWRpdENhcmRUeXBlIiwic3RvcmVJbnN0cnVtZW50IiwiVmFsaWRhdG9ycyIsIkNDVmFsaWRhdG9ycyIsIkZvcm1hdHRlcnMiLCJDQ0Zvcm1hdHRlcnMiLCJBY2NvdW50IiwiJHBheW1lbnRNZXRob2RGb3JtIiwiaW5pdFBheW1lbnRNZXRob2RGb3JtVmFsaWRhdGlvbiIsInBhZ2VBbGVydHMiLCJWYWxpZGF0b3IiLCJpbml0U2luZ2xlIiwiJHJlb3JkZXJGb3JtIiwiaW5pdFJlb3JkZXJGb3JtIiwidG9nZ2xlIiwiYmluZERlbGV0ZVBheW1lbnRNZXRob2QiLCJzdWJtaXRGb3JtIiwiJHByb2R1Y3RSZW9yZGVyQ2hlY2tib3hlcyIsInByb2R1Y3RDaGVja2JveCIsInByb2R1Y3RJZCIsImZpcnN0TmFtZUxhYmVsIiwibGFzdE5hbWVMYWJlbCIsImNvbXBhbnlMYWJlbCIsInBob25lTGFiZWwiLCJhZGRyZXNzMUxhYmVsIiwiYWRkcmVzczJMYWJlbCIsImNpdHlMYWJlbCIsImNvdW50cnlMYWJlbCIsImNob29zZUNvdW50cnlMYWJlbCIsInN0YXRlTGFiZWwiLCJwb3N0YWxDb2RlTGFiZWwiLCJwYXltZW50TWV0aG9kU2VsZWN0b3IiLCIkbGFzdCIsIl9yZWYiLCJjYXJkVHlwZSIsInNldENyZWRpdENhcmROdW1iZXJWYWxpZGF0aW9uIiwiY3JlZGl0Q2FyZE51bWJlciIsInNldEV4cGlyYXRpb25WYWxpZGF0aW9uIiwiZXhwaXJhdGlvbiIsInNldE5hbWVPbkNhcmRWYWxpZGF0aW9uIiwibmFtZU9uQ2FyZCIsInNldEN2dlZhbGlkYXRpb24iLCJjdnYiLCJzZXRDcmVkaXRDYXJkTnVtYmVyRm9ybWF0Iiwic2V0RXhwaXJhdGlvbkZvcm1hdCIsIiRmb3JtSXNWYWxpZCIsIl9yZWR1Y2UiLCJzZXJpYWxpemVBcnJheSIsIm9iaiIsInJlZk9iaiIsIl9maW5kIiwiY291bnRyaWVzIiwiX3JlZjIiLCJfcmVmMyIsImNvdW50cnlfY29kZSIsInN0YXRlX29yX3Byb3ZpbmNlX2NvZGUiLCJkZWZhdWx0X2luc3RydW1lbnQiLCJocmVmIiwicGF5bWVudE1ldGhvZHNVcmwiLCJnZW5lcmljX2Vycm9yIiwiR2lmdENlcnRpZmljYXRlIiwiJHB1cmNoYXNlRm9ybSIsIl9zaG93UHJldmlldyIsInN0b3BQcm9wYWdhdGlvbiIsIiR0aGVtZSIsImJhc2VVcmwiLCJ1cmwiLCIkcHJldmlldyIsInNyYyIsImNvbnRlbnREb2N1bWVudCIsImNyZWRpdGNhcmRzIiwib21pdE51bGxTdHJpbmciLCJrZXkiLCJjYXJkIiwicGFyc2UiLCJkb25lIiwiZmFpbCIsInBheW1lbnRzVXJsIiwic2hvcHBlcklkIiwic3RvcmVIYXNoIiwidmF1bHRUb2tlbiIsInByb3ZpZGVyX2lkIiwiY3VycmVuY3lfY29kZSIsImNyZWRpdF9jYXJkX251bWJlciIsIm5hbWVfb25fY2FyZCIsImFkZHJlc3MxIiwiYWRkcmVzczIiLCJjaXR5IiwicG9zdGFsX2NvZGUiLCJjb21wYW55IiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImVtYWlsIiwicGhvbmUiLCJleHBpcnkiLCJzcGxpdCIsImFqYXgiLCJkYXRhVHlwZSIsIm1ldGhvZCIsImNhY2hlIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJBY2NlcHQiLCJKU09OIiwic3RyaW5naWZ5IiwiaW5zdHJ1bWVudCIsImNhcmRob2xkZXJfbmFtZSIsIm51bWJlciIsImV4cGlyeV9tb250aCIsIm1vbnRoIiwiZXhwaXJ5X3llYXIiLCJ5ZWFyIiwidmVyaWZpY2F0aW9uX3ZhbHVlIiwiYmlsbGluZ19hZGRyZXNzIiwiZmllbGQiLCJyZWZUYXJnZXQiLCJmb3JtYXQiLCJfcmVmNCIsIndoaWNoIiwidGVzdCIsInNsaWNlIiwicmVwbGFjZSIsImFkZCIsInZhbGlkYXRlIiwiY2IiLCJpc1ZhbGlkIiwiaXNQYXN0IiwiY3ZjIiwiX3JlYWRPbmx5RXJyb3IiLCJyIiwiVHlwZUVycm9yIiwidHJlbmQiLCJBbXBBbGVydCIsImJ1dHRvbkRpc2FibGVkQ2xhc3MiLCJjYXJ0QWRkQWxlcnQiLCJjYXJ0T3B0aW9uQWxlcnQiLCJfYmluZFByb2R1Y3RPcHRpb25DaGFuZ2UiLCJfYm91bmRDYXJ0Q2FsbGJhY2siLCJfYmluZENhcnRBZGQiLCJiaW5kIiwiX3VwZGF0ZUF0dHJpYnV0ZXMiLCJCQ0RhdGEiLCJwcm9kdWN0X2F0dHJpYnV0ZXMiLCJfZ2V0Vmlld01vZGVsIiwiY2hhbmdlZE9wdGlvbiIsInBhcmVudHMiLCJGb3JtRGF0YSIsInVuZGVmaW5lZCIsInByb2R1Y3RUZW1wbGF0ZSIsInZpZXdNb2RlbCIsIl91cGRhdGVRdWFudGl0eSIsIiRxdWFudGl0eSIsImlzTmFOIiwiaXMiLCJiZWhhdmlvciIsIm91dF9vZl9zdG9ja19iZWhhdmlvciIsImluU3RvY2tJZHMiLCJpbl9zdG9ja19hdHRyaWJ1dGVzIiwib3V0T2ZTdG9ja01lc3NhZ2UiLCJvdXRfb2Zfc3RvY2tfbWVzc2FnZSIsImF0dHJpYnV0ZSIsIiRhdHRyaWJ1dGUiLCJhdHRySWQiLCJfZW5hYmxlQXR0cmlidXRlIiwiX2Rpc2FibGVBdHRyaWJ1dGUiLCJfZ2V0QXR0cmlidXRlVHlwZSIsImRpc2FibGVTZWxlY3RPcHRpb25BdHRyaWJ1dGUiLCJ0b2dnbGVPcHRpb24iLCJlbmFibGVTZWxlY3RPcHRpb25BdHRyaWJ1dGUiLCJyZW1vdmVBdHRyIiwiZm9ybSIsInRvcCIsInVybHNDYXJ0IiwiZ2FsbGVyeSIsIiR0aHVtYnMiLCIkaW1hZ2UiLCJmaWVsZFNlbGVjdG9yIiwidmFsdWVTZWxlY3RvciIsImxhYmVsU2VsZWN0b3IiLCJmb3JtU2VsZWN0ZWRWYWx1ZSIsIiRsYWJlbCIsImN1cnJlbnRTZWxlY3RFbGVtZW50IiwiZGlzYWJsZWRTZWxlY3RFbGVtZW50Iiwic2VsZWN0RWxlbWVudCIsInNlbGVjdGVkT3B0aW9uIiwiJHByZWZpeCIsInByZXZpb3VzSW5kZXgiLCJhcHBlbmRUbyIsInByZXBlbmRUbyIsImZuIiwic3RhdGVBc1NlbGVjdCIsInJlc3BvbnNlRGF0YSIsInN0YXRlQXR0cnMiLCJ1c2VJZCIsIl9pdGVyYXRvciIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UiLCJfc3RlcCIsIm9wdGlvblZhbHVlIiwiJHN0YXRlU2VsZWN0IiwiY2xhc3MiLCJzdGF0ZUlkIiwic3RhdGVOYW1lIiwicmVxdWlyZWQiLCJzdGF0ZUFzSW5wdXQiLCIkc3RhdGVJbnB1dCIsImZldGNoQW5kVXBkYXRlU3RhdGVJbnB1dCIsImNhbGxiYWNrIiwiJHN0YXRlV3JhcHBlciIsIiRuZXdTdGF0ZUVsZW1lbnQiLCIkbmV3U3RhdGVFbGVtZW50UGFyZW50IiwiJHNlbGVjdGVkVGV4dCIsInRpbWVvdXRMZWF2ZSIsImRlbGF5TGVhdmUiLCJfaGFuZGxlU2Nyb2xsIiwiX2hhbmRsZU1vdXNlRW50ZXIiLCJfaGFuZGxlTW91c2VMZWF2ZSIsIl9oaWRlQWxsQ2hpbGRyZW4iLCJfaGFuZGxlUm9vdEl0ZW1Nb3VzZU92ZXIiLCIkZHJvcGRvd24iLCIkZHJvcGRvd25QYW5lbCIsImNsZWFyVGltZW91dCIsIm5vdCIsIiRmaXJzdFRpZXIyIiwiZmlyc3QiLCJjYXRlZ29yeUlkIiwiJGNoaWxkTGlzdCIsIiRyb290SXRlbSIsInJlbW92ZUFjdGl2ZSIsIlVybCIsImZhY2V0VG9nZ2xlIiwibW9yZVRvZ2dsZSIsIm1vcmVGYWNldHMiLCJfc2FuaXRpemVGYWNldHMiLCJfb25TdGF0ZUNoYW5nZSIsIl90b2dnbGVGYWNldCIsIl9zaG93QWRkaXRpb25hbEZpbHRlcnMiLCJfc2hvd01vcmVGYWNldHMiLCJfb25GYWNldENsaWNrIiwiX29uUmFuZ2VTdWJtaXQiLCJfb25Tb3J0QnlTdWJtaXQiLCJvbGRUYXJnZXRJZCIsIm5ld1RhcmdldElkIiwidG9Mb3dlckNhc2UiLCJvbGRIcmVmIiwibmV3SHJlZiIsIiR0b2dnbGUiLCIkbmF2TGlzdCIsImZhY2V0IiwiZmFjZXRVcmwiLCJvcmlnaW4iLCJwYXRobmFtZSIsImxpc3RfYWxsIiwicXVlcnlTdHJpbmciLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJfc3RlcCR2YWx1ZSIsImdldFBhZ2UiLCJFcnJvciIsImNoaWxkcmVuIiwiX2dvVG9VcmwiLCJxdWVyeVBhcmFtcyIsImN1cnJlbnRTZWFyY2giLCJxdWVyeSIsIkhpc3RvcnkiLCJnZXRTdGF0ZSIsInB1c2hTdGF0ZSIsInRpdGxlIiwiJHdyYXBwZXIiLCIkc2VhcmNoV3JhcCIsIiRoZWFkZXIiLCIkdG9wQmFyIiwiJG5hdkJhciIsImNhcnRPcGVuQ2xhc3MiLCJzZWFyY2hPcGVuQ2xhc3MiLCJuYXZPcGVuQ2xhc3MiLCIkbG9naW5SZWdpc3RlciIsIiRmb3Jnb3RQYXNzd29yZCIsIl9hZGp1c3RIZWlnaHRzIiwiX2hlYWRlclNjcm9sbCIsIl90b2dnbGVNaW5pQ2FydCIsImtleUNvZGUiLCJfdG9nZ2xlU2VhcmNoIiwiX3RvZ2dsZU1vYmlsZU5hdiIsIl9oYW5kbGVSZXNpemUiLCJyZXNpemUiLCJmb2N1cyIsImRlZmF1bHROYXZiYXJIZWlnaHQiLCIkY3VycmVudE5hdkJhciIsImN1cnJlbnROYXZCYXJIZWlnaHQiLCJvdXRlckhlaWdodCIsIiR3aW4iLCIkY2FudmFzIiwiZGVmYXVsdFRvcEJhckhlaWdodCIsInRvcEJhckhlaWdodCIsImRlZmF1bHRGdWxsSGVhZGVySGVpZ2h0IiwiY3VycmVudEZ1bGxIZWFkZXJIZWlnaHQiLCJ0b3RhbEhlaWdodCIsIiRtb2JpbGVOYXYiLCIkcm9vdE1lbnUiLCIkY2hpbGRDb250YWluZXIiLCIkZHJvcGRvd25Ub2dnbGUiLCJfZmluZENoaWxkRnJvbVJvb3QiLCJkcm9wZG93bk9wZW4iLCJjaGlsZFRpbWVyIiwiX2ZpbmRDaGlsZCIsImNoaWxkSWQiLCJfZmluZFBhcmVudCIsIiRtaW51cyIsInBhcmVudElkIiwiX2FkanVzdE1lZ2FOYXZQYW5lbCIsIiRtZWdhTmF2UGFuZWwiLCJjYXJ0Q2hhbmdlUmVtb3RlSG9va3MiLCJfdXBkYXRlIiwiX3JlbW92ZVByb2R1Y3RNaW5pQ2FydCIsImZvckVhY2giLCJob29rIiwiX2JpbmRTY3JvbGwiLCIkbWluaUNhcnQiLCIkbWluaUNhcnRUb3RhbCIsIiRtaW5pQ2FydENvbnRlbnRzIiwic3VidG90YWwiLCJzdWJ0b3RhbFJhdyIsImFuaW1hdGUiLCJhbGVydCIsIm9sZFNjcm9sbFRvcCIsIm1pbmlDYXJ0SGVpZ2h0IiwibWF4U2Nyb2xsIiwibmV3U2Nyb2xsVG9wIiwiY2FydFRvcFBvcyIsInNjcm9sbEFtb3VudCIsIm5hdlRvZ2dsZSIsInBhZ2VDb3ZlciIsIiRtZW51IiwiJG5hdkJhY2tCdXR0b24iLCJnZXRNZW51cyIsInRhcmdldE1lbnUiLCJuYXZQYW5lbCIsImFjdGl2ZSIsImxlZnQiLCJyaWdodCIsImZvcmNlU3RhdGUiLCJtZW51U3RhdGUiLCJfaW5pdE1vYmlsZSIsIl9iaW5kTW9iaWxlRXZlbnRzIiwiJGNoaWxkcmVuIiwiY291bnRlciIsIl90cmF2ZXJzZURvd24iLCJfdHJhdmVyc2VCYWNrIiwicHJldk1lbnUiLCJmaWx0ZXIiLCJwb3AiLCJwcmV2QWxsIiwiUHJvZHVjdENvbXBhcmUiLCJjb21wYXJlIiwibWF4SXRlbXMiLCJpdGVtVGVtcGxhdGUiLCJjb21wYXJlTGlzdCIsInNpemUiLCJyZW1vdmVBbGwiLCJ1cGRhdGVDaGVja2JveGVzIiwiZGVib3VuY2VXYWl0VGltZSIsIiRxdWlja1NlYXJjaFJlc3VsdHMiLCIkcXVpY2tTZWFyY2hGb3JtcyIsIiRzZWFyY2hRdWVyeSIsIiRxdWlja1NlYXJjaEFyaWFNZXNzYWdlIiwic2VhcmNoUmVzdWx0c1Zpc2libGUiLCJkb1NlYXJjaCIsInNlYXJjaFF1ZXJ5IiwiZW1wdHkiLCIkcXVpY2tTZWFyY2hSZXN1bHRzQ3VycmVudCIsIiRub1Jlc3VsdHNNZXNzYWdlIiwicm9sZSIsInByZWRlZmluZWRUZXh0IiwiaXRlbXNGb3VuZENvdW50IiwiaWNvbkNsYXNzIiwiJHRyaWdnZXIiLCJlbmFibGVBdHRyaWJ1dGUiLCJkaXNhYmxlQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlVHlwZSIsImJpbmRTd2F0Y2hFdmVudCIsImNsaWNrIiwiJHN3YXRjaFRleHQiLCIkc3dhdGNoVmFsdWUiLCJJbWFnZVpvb20iLCJkZWZhdWx0SW1nIiwiSW1hZ2UiLCJpbWFnZSIsIl96b29tSW1hZ2UiLCJ0b3BPZmZzZXQiLCJsZWZ0T2Zmc2V0IiwicGFnZVkiLCJwYWdlWCIsImJhZ3VldHRlQm94IiwiY3VzdG9tTGVmdEFycm93IiwiY3VzdG9tUmlnaHRBcnJvdyIsImN1c3RvbUNsb3NlWCIsInJ1biIsImxlZnRBcnJvdyIsInJpZ2h0QXJyb3ciLCJjbG9zZVgiLCJwcmVsb2FkIiwiYnV0dG9ucyIsImFuaW1hdGlvbiIsIm5vU2Nyb2xsYmFycyIsImZ1bGxTY3JlZW4iLCJ0b3RhbEltYWdlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJuZXh0QnV0dG9uIiwicXVlcnlTZWxlY3RvciIsInByZXZCdXR0b24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibmV4dEltYWdlIiwicHJldmlvdXNJbWFnZSIsImN1cnJlbnRJbmRleCIsImdldEN1cnJlbnRJbmRleCIsIm5leHRJbmRleCIsInByZXZJbmRleCIsImFkZEV2ZW50TGlzdGVuZXIiLCJtYXhTbGlkZXNCZWZvcmVBcnJvd3MiLCJjb250YWluZXIiLCJzbGlkZXNXcmFwIiwicGFnaW5hdGlvbiIsInBhZ2luYXRpb25JdGVtIiwibG9hZGVyIiwiJHBhZ2luYXRpb24iLCJfaW5pdCIsIl90aGlzJCRwYWdpbmF0aW9uJHNsaSIsImFycm93cyIsImFzTmF2Rm9yIiwiZHJhZ2dhYmxlIiwic3dpcGUiLCJ0b3VjaFRocmVzaG9sZCIsImVkZ2VGcmljdGlvbiIsImltYWdlQ291bnQiLCIkc2xpZGVzIiwiY2VudGVyTW9kZSIsImxvb3AiLCJ2YXJpYWJsZVdpZHRoIiwicm93cyIsImZvY3VzT25TZWxlY3QiLCJfYmluZFJhdGluZyIsInJhdGluZyIsInJhdGluZ0xhYmVsIiwiUHJvZ3Jlc3NCdXR0b24iLCJyZXNldFByb2R1Y3RJbWFnZXMiLCJvbkltYWdlU3dpdGNoIiwicHJvZHVjdFRpdGxlIiwiJHByb2R1Y3RDb250YWluZXIiLCJwcm9kdWN0QXR0cmlidXRlc0RhdGEiLCJwcm9ncmVzc0J1dHRvbiIsIl9ib3VuZFByb2R1Y3RPcHRpb25DaGFuZ2UiLCJib3VuZENhcnRDYWxsYmFjayIsIl9iaW5kQWRkVG9DYXJ0IiwiX2NoZWNrUXVhbnRpdHkiLCIkcHJvZHVjdE9wdGlvbnNFbGVtZW50IiwiaGFzT3B0aW9ucyIsImhhc0RlZmF1bHRPcHRpb25zIiwiJHByb2R1Y3RJZCIsImF0dHJpYnV0ZXNEYXRhIiwiYXR0cmlidXRlc0NvbnRlbnQiLCJfdXBkYXRlVmlldyIsIl9iaW5kQWRkV2lzaGxpc3QiLCJkZXN0cm95Iiwib2ZmIiwiJHByaWNlIiwiJHByaWNlV2l0aFRheCIsIiRzYXZlZCIsIiRza3UiLCIkd2VpZ2h0IiwiJGltYWdlUHJldmlldyIsInN0b2NrIiwiJHNlbGVjdG9yIiwiJGxldmVsIiwiZmlsdGVyRW1wdHlGaWxlc0Zyb21Gb3JtIiwiRmlsZSIsImRlbGV0ZSIsImZvcm1Qcm9kdWN0SWQiLCJkYXRhc2V0IiwicHJvZHVjdEF0dHJpYnV0ZXNDb250ZW50Iiwic2V0UHJvZHVjdFZhcmlhbnQiLCJwcmljZVN0cmluZ3MiLCJwcmljZSIsImV4Y2x1ZGluZ1RheCIsInByb2R1Y3RFeGNsdWRpbmdUYXgiLCJzYWxlUHJpY2VMYWJlbCIsIm5vblNhbGVQcmljZUxhYmVsIiwicmV0YWlsUHJpY2VMYWJlbCIsInByaWNlTGFiZWwiLCJpbmNsdWRpbmdUYXgiLCJwcm9kdWN0SW5jbHVkaW5nVGF4Iiwic2F2ZWRTdHJpbmciLCJwcm9kdWN0WW91U2F2ZSIsInNrdSIsIndlaWdodCIsImZvcm1hdHRlZCIsInByb2R1Y3RJbWFnZVVybCIsInRvb2xzIiwiZ2V0U3JjIiwidGhlbWVJbWFnZVNpemVzIiwiem9vbSIsInpvb21JbWFnZVVybCIsInByb2R1Y3QiLCJpbWFnZUlkIiwiYWx0Iiwic3RvY2tfbWVzc2FnZSIsInNvbGRPdXRCdXR0b25MYWJlbCIsImFkZFRvQ2FydEJ1dHRvbkxhYmVsIiwicXVhbnRpdHkiLCJwcm9ncmVzcyIsIl9wYXJzZVJlc3BvbnNlIiwiY29tcGxldGUiLCJtZXNzYWdlc1Byb2R1Y3RHZW5lcmFsIiwibWVzc2FnZXNQcm9kdWN0QWRkU3VjY2Vzc0JhZyIsImJhZ0xpbmsiLCJ1cmxzQ2hlY2tvdXQiLCJjaGVja291dExpbmsiLCJtZXNzYWdlc1Byb2R1Y3RBZGRTdWNjZXNzQ2FydCIsImNhcnRMaW5rIiwiX3RoaXM2IiwiJGJ1dHRvbiIsImFkZFVybCIsInZpZXdVcmwiLCJtZXNzYWdlc1dpc2hsaXN0QWRkU3VjY2VzcyIsIm1lc3NhZ2VzV2lzaGxpc3RBZGRFcnJvciIsInVuc2F0aXNmaWVkUmVxdWlyZWRGaWVsZHMiLCJvcHRpb25MYWJlbCIsImlubmVyVGV4dCIsIm9wdGlvblRpdGxlIiwidHJpbSIsImluY2x1ZGVzIiwiZ2V0QXR0cmlidXRlIiwiaXNTYXRpc2ZpZWQiLCJBcnJheSIsImZyb20iLCJldmVyeSIsInNlbGVjdCIsInNlbGVjdGVkSW5kZXgiLCJkYXRlU3RyaW5nIiwibWFwIiwieCIsImNoZWNrZWQiLCJsYWJlbCIsImxhYmVscyIsInByb2R1Y3RWYXJpYW50Iiwic29ydCIsInZpZXciLCJwcm9kdWN0TmFtZSIsIlF1aWNrU2hvcE1vZGFsIiwiY2VudGVyVmVydGljYWxseSIsImFmdGVySGlkZSIsImdldEJ5SWQiLCJkIiwicyIsImpzIiwiZmpzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50QnlJZCIsImNyZWF0ZUVsZW1lbnQiLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwidmFyaWF0aW9uSW1hZ2UiLCJ2YXJpYXRpb25JbWFnZU5hdiIsInNjcm9sbFRvVG9wIiwibnVtU2xpZGVzIiwibWFpblNsaWRlIiwicHJvZHVjdEltYWdlU3JjIiwiem9vbUltYWdlU3JjIiwiYmFja2dyb3VuZCIsImRyb3Bkb3duIiwicGFuZWwiLCJfdG9nZ2xlRHJvcGRvd24iLCJmb3JtU2VsZWN0b3IiLCJ2YWxpZGF0aW9uT3B0aW9ucyIsInZhbGlkYXRpb25NZXNzYWdlcyIsInZhbGlkYXRpb25SZXF1aXJlZCIsInZhbGlkYXRpb25FbWFpbCIsInZhbGlkYXRpb25OdW1iZXIiLCJudW1NYXgiLCJ2YWxpZGF0aW9uTnVtYmVyTWF4IiwibnVtTWluIiwidmFsaWRhdGlvbk51bWJlck1pbiIsIm51bVJhbmdlIiwidmFsaWRhdGlvbk51bWJlclJhbmdlIiwibWF4TGVuZ3RoIiwidmFsaWRhdGlvbk1heExlbmd0aCIsIm1pbkxlbmd0aCIsInZhbGlkYXRpb25NaW5MZW5ndGgiLCJtYXhDaGVja2VkIiwidmFsaWRhdGlvbk1heENoZWNrZWQiLCJtaW5DaGVja2VkIiwidmFsaWRhdGlvbk1pbkNoZWNrZWQiLCJtYXhTZWxlY3RlZCIsInZhbGlkYXRpb25NYXhTZWxlY3RlZCIsIm1pblNlbGVjdGVkIiwidmFsaWRhdGlvbk1pblNlbGVjdGVkIiwibm90RXF1YWwiLCJ2YWxpZGF0aW9uTm90RXF1YWwiLCJkaWZmZXJlbnQiLCJ2YWxpZGF0aW9uRGlmZmVyZW50IiwidmFsaWRldHRhIiwibG9jYWxPcHRpb25zIiwiY3VzdG9tT3B0aW9ucyIsInByb2dyZXNzVGV4dCIsInNwaW5uZXIiLCJkZWZhdWx0VGV4dCIsImNoYW5nZVdpc2hsaXN0UGFnaW5hdGlvbkxpbmtzIiwid2lzaGxpc3RVcmwiLCJfbGVuIiwicGFnaW5hdGlvbkl0ZW1zIiwiX2tleSIsIl8iLCIkaXRlbSIsInBhZ2VOdW1iZXIiLCIkbmV4dEl0ZW0iLCIkcHJldkl0ZW0iLCJjdXJyZW50SHJlZiIsInBhcnRpYWxQYWdpbmF0aW9uVXJsIiwic2hpZnQiLCJyZXF1ZXN0IiwiX2RlZmF1bHQiLCJ2ZXJzaW9uIiwicmVtb3RlVmVyc2lvbiIsInJlbW90ZUJhc2VFbmRwb2ludCIsIm1ha2VSZXF1ZXN0IiwicmVtb3RlIiwicmVxdWVzdE9wdGlvbnMiLCJyZW1vdGVSZXF1ZXN0IiwiZW5kcG9pbnQiLCJyZW1vdGVVcmwiLCJCb2RsRXZlbnRzQ2FydCIsIkJhc2UiLCJIb29rcyIsIl9CYXNlIiwiYm9kbEV2ZW50c0NhcnQiLCJnZXRCb2RsRXZlbnRzQ2FydCIsImdldENhcnRzIiwiaW5jbHVkZU9wdGlvbnMiLCJnZXRDYXJ0IiwiY2FydElkIiwiZ2V0Q2FydFN1bW1hcnkiLCJnZXRDYXJ0UXVhbnRpdHkiLCJ0b3RhbF9xdWFudGl0eSIsImhhbmRsZUl0ZW1BZGQiLCJlbWl0QWRkSXRlbSIsImVtaXREYXRhIiwicXR5IiwiY2FsbGJhY2tBcmciLCJpdGVtcyIsImlzQXJyYXkiLCJ1cGRhdGUiLCJlbWl0UmVtb3ZlSXRlbSIsImhhbmRsZUl0ZW1SZW1vdmUiLCJvcHRzIiwic3VibWl0SXRlbUdpZnRXcmFwcGluZ09wdGlvbiIsInBheWxvYWQiLCJyZW5kZXJXaXRoIiwicmVuZGVyV2l0aEFyZyIsInNoaXBwaW5nX21ldGhvZCIsIkNvdW50cnlBcGkiLCJQcm9kdWN0QXBpIiwiUHJvZHVjdEF0dHJpYnV0ZXNBcGkiLCJTZWFyY2hBcGkiLCJDYXJ0QXBpIiwiV2lzaGxpc3QiLCJpbnRlcm5hbHMiLCJnZXRQYWdlQnlHUUwiLCJwYWdlIiwidGVtcGxhdGVfbmFtZSIsIndpc2hsaXN0IiwiaW5DYXJ0RW5kcG9pbnQiLCJ0ZW1wbGF0ZUFyZyIsInBhcmFtc0FyZyIsImVuY29kZVVSSUNvbXBvbmVudCIsIndpc2hsaXN0SWQiLCJjYWxsYmFja0ZuIiwiZ2V0Qk9ETEV2ZW50cyIsImJvZGxFdmVudHMiLCJnZXRFdmVudElkIiwiaXNCT0RMRW5hYmxlZCIsIkFkZENhcnRJdGVtRXZlbnQiLCJDUkVBVEUiLCJzaG91bGRFbWl0UmVtb3ZlSXRlbSIsIlJlbW92ZUNhcnRJdGVtRXZlbnQiLCJfcmVzcG9uc2UkZGF0YSRsaW5lX2kiLCJsaW5lX2l0ZW1zIiwiZXZlbnROYW1lIiwicHJlcGFyZVBheWxvYWQiLCJldmVudF9pZCIsImNoYW5uZWxfaWQiLCJjdXJyZW5jeSIsInByb2R1Y3RfdmFsdWUiLCJPYmplY3QiLCJhc3NpZ24iLCJwcm9kdWN0X2lkIiwiU3RyaW5nIiwidjQiLCJ1dWlkdjQiLCJGYWtlQk9ETEV2ZW50cyIsImFkZEl0ZW0iLCJyZW1vdmVJdGVtIiwiRXZlbnRFbWl0dGVyIiwiX0V2ZW50RW1pdHRlciIsInN1YnNjcmliZSIsImVsZW1lbnRTZWxlY3RvciIsImhhbmRsZXIiLCJtYXRjaGVzIiwiQmFzZUhvb2tzIiwiX0Jhc2VIb29rcyIsImN1cnJlbmN5U2VsZWN0b3IiLCJzZWFyY2hFdmVudHMiLCJDYXJ0SG9va3MiLCJDb29raWVIb29rcyIsIkN1cnJlbmN5U2VsZWN0b3JIb29rcyIsIlByb2R1Y3RIb29rcyIsIlNlYXJjaEhvb2tzIiwiRmFjZXRlZFNlYXJjaEhvb2tzIiwiU29ydEJ5SG9va3MiLCJjb29raWUiLCJmYWNldGVkU2VhcmNoIiwic29ydEJ5IiwicGFyc2VIb29rcyIsImhvb2tOYW1lIiwiaG9va1R5cGUiLCJvcHRpb25zQ2hhbmdlIiwicXVpY2tTZWFyY2giLCJFbGVtZW50IiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJzb3J0QnlFdmVudHMiLCJkZWZhdWx0UHJldmVudGVkIiwicGFyZW50RWxlbWVudCIsIm5vZGVUeXBlIiwiZW5jb2RlIiwic3RyaW5nIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJzcGxpdE9uRmlyc3QiLCJzZXBhcmF0b3IiLCJzZXBhcmF0b3JJbmRleCIsInNvcnRCeUtleXMiLCJpbnB1dCIsImtleXMiLCJhIiwiYiIsIk51bWJlciIsImdldFBhcnNlZFZhbHVlIiwiYWNjdW11bGF0b3IiLCJjb25jYXQiLCJyZWR1Y2VCeUtleSIsImluY2x1ZGVBcnJheUluZGV4Iiwia2V5T2ZWYWx1ZSIsInJldCIsImNyZWF0ZSIsImlucHV0UGFyc2VkIiwicGFyYW0iLCJfc3BsaXRPbkZpcnN0IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVkdWNlIiwiQm9vbGVhbiIsIm9iamVjdCIsImZpbHRlclZhbHVlcyIsImFycmF5SW5kZXgiLCJvYmplY3RDb3B5Iiwic2hvdWxkRmlsdGVyIiwiaXNWYWxpZEhUVFBNZXRob2QiLCJpc1VzaW5nU2VjdGlvbnMiLCJyZXF1ZXN0ZWRUZW1wbGF0ZSIsImdldFRlbXBsYXRlcyIsInRlbXBsYXRlcyIsInZhbHVlcyIsInJlbGF0aXZlVXJsIiwiZGVmYXVsdE9wdGlvbnMiLCJjc3JmX3Rva2VuIiwidXNpbmdTZWN0aW9ucyIsInVzaW5nVGVtcGxhdGVzIiwicmVuZGVyX3dpdGgiLCJjcmVkZW50aWFscyIsImRlbGltaXRlciIsImZldGNoIiwidGhlbiIsImdldCIsImpzb24iLCJjbGVhbktleSIsInRlbXBsYXRlVmFyaWFibGUiLCJjYXRjaCIsIlN0ZW5jaWxVdGlscyIsInJvb3QiLCJkZWZpbmUiLCJhbWQiLCJzdGVuY2lsVXRpbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwicGF0aCIsImRpbWVuc2lvbnMiLCJzaXplUmVnZXgiLCJnZXRTcmNzZXQiLCJzaXplcyIsImRlc2NyaXB0b3JSZWdleCIsInNyY3NldHMiLCJzb21lIiwiZGVzY3JpcHRvciIsIkltYWdlVG9vbCIsIkltYWdlU3Jjc2V0VG9vbCIsIlN0b3JhZ2VUb29scyIsImltYWdlU3Jjc2V0Iiwic3RvcmFnZSIsInN0b3JhZ2VBdmFpbGFibGUiLCJzZXRJdGVtIiwiRE9NRXhjZXB0aW9uIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiYXN5bmMiLCJhY2NvdW50IiwiYXV0aCIsImJsb2ciLCJicmFuZHMiLCJjb250YWN0VXMiLCJlcnJvcnM0MDQiLCJnaWZ0Q2VydGlmaWNhdGUiLCJnbG9iYWwiLCJob21lIiwib3JkZXJDb21wbGV0ZSIsInNpdGVtYXAiLCJQYWdlQ2xhc3NlcyIsIm1hcHBpbmciLCJzZXJpZXMiLCJwYWdlT2JqIiwibG9hZEdsb2JhbCIsInBhZ2VzIiwicGFnZUZ1bmMiLCJnbG9iYWxQYWdlTWFuYWdlciIsInN0ZW5jaWxCb290c3RyYXAiLCJ0ZW1wbGF0ZUZpbGUiLCJsb2FkIiwiUGFnZVR5cGVGbiIsInBhZ2VUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==